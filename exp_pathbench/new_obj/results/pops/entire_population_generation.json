{
     "operator": "e1",
     "algorithm": "PathPlanning is a hybrid sample-based algorithm combining adaptive informed sampling with batch rewiring and \n    multi-radius neighborhood strategy inspired by RRT*, but improving planning efficiency and path quality by:\n    - Biased sampling in ellipsoidal region focused towards the goal to reduce search space and improve convergence speed.\n    - Batch exploration with rewiring to continually reduce path costs and improve path smoothness.\n    - Multi-radius neighborhood sampling for flexible connectivity and robustness in cluttered environments.\n    - Early termination if goal reached or if planning time exceeds 10 seconds to ensure time-bound planning.\n    - Using cost propagation and informed pruning for path quality and shorter path lengths.\n    This algorithm aims for improved success rate, smoother and shorter paths with reduced execution time, \n    making it suitable for complex environments with obstacles.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _max_radius: float\n    _batch_size: int\n    _lambda_rrt_star: float\n    _dimension: int\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        # Parameters tuning\n        self._max_dist = 12.0  # max step length toward sample\n        self._max_radius = 40.0  # max neighbor radius for rewiring\n        self._batch_size = 30  # number of samples per batch iteration\n        self._lambda_rrt_star = 50.0  # parameter for radius calculation\n        self._dimension = self._get_grid().size.n_dim\n\n        self._init_displays()\n\n    def _get_random_sample(self, informed_center: Optional[Point] = None, informed_radii: Optional[List[float]] = None) -> Point:\n        \"\"\"\n        Samples point uniformly within either full map or within an ellipsoidal region around the start and goal.\n\n        :param informed_center: Center of the ellipsoid (often midpoint between start and goal).\n        :param informed_radii: Radii of the ellipsoid.\n        :return: Point sampled respecting obstacle validity.\n        \"\"\"\n        grid_size = self._get_grid().size\n\n        # Informed sampling inside ellipsoid if parameters provided\n        if informed_center is not None and informed_radii is not None:\n            for _ in range(100):\n                # Sample random point inside unit ball (normal distribution method)\n                direction = torch.randn(self._dimension)\n                direction /= torch.norm(direction)\n                r = torch.rand(1).item() ** (1 / self._dimension)\n                sample_unit_ball = direction * r\n                # Scale by radii in each dimension and translate by center\n                sample_coords = informed_center.to_tensor() + torch.tensor(informed_radii) * sample_unit_ball\n                sample_coords_int = torch.clamp(sample_coords.round().long(), min=0, max=torch.tensor(grid_size).long()-1)\n                sample = Point.from_tensor(sample_coords_int)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        # fallback uniform random sampling on full grid space\n        while True:\n            rand_coords = [np.random.randint(0, grid_size[i]) for i in range(self._dimension)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _steer(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + direction_normalized * max_dist)\n        return Vertex(new_pos)\n\n    def _rewire_neighbors(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        for q_near in neighbors:\n            if q_near is q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            if q_near.cost is None or new_cost < q_near.cost:\n                # remove old parent edge if exists\n                old_parent = None\n                for parent in q_near.parents:\n                    old_parent = parent\n                    break\n                if old_parent:\n                    self._graph.remove_edge(old_parent, q_near)\n                q_near.cost = new_cost\n                self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Connect to goal if possible and retrieve path\n        goal_point = self._get_grid().goal.position\n        dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_point.to_tensor())\n        goal_vertex = Vertex(goal_point)\n        goal_vertex.cost = q_new.cost + dist_to_goal\n\n        line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_point)\n        if not self._get_grid().is_valid_line_sequence(line_seq_goal):\n            return\n\n        self._graph.add_edge(q_new, goal_vertex)\n\n        # Trace back path from goal to start\n        path: List[Vertex] = [goal_vertex]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n        # Remove the last appended vertex (duplicate start)\n        path.pop()\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _calculate_informed_parameters(self) -> (Point, List[float]):\n        \"\"\"\n        Calculate ellipsoidal sampling region parameters (center and radii) for informed sampling.\n\n        Returns:\n            center: midpoint between start and goal.\n            radii: list of ellipsoid radii per dimension.\n        \"\"\"\n        start = self._get_grid().agent.position.to_tensor()\n        goal = self._get_grid().goal.position.to_tensor()\n\n        center = (start + goal) / 2\n        c_dist = torch.norm(goal - start).item()\n\n        # If already have a path, use path cost to limit ellipse size\n        best_cost = None\n        if hasattr(self, \"_best_path_cost\") and self._best_path_cost is not None:\n            best_cost = self._best_path_cost\n        else:\n            best_cost = float('inf')\n\n        # Radii define ellipsoid stretching for each dimension.\n        # Use best_cost or distance to goal for a, b radii\n        # For 2D: a = best_cost/2, b = sqrt(best_cost^2 - c_dist^2)/2\n        # For higher dims, approximate as hyper-ellipsoid with same radii\n\n        if best_cost == float('inf') or best_cost < c_dist:\n            # No valid path yet or cost lower than distance (impossible), so use large radii\n            radii = [(c_dist / 2.0) * 3 for _ in range(self._dimension)]\n        else:\n            a = best_cost / 2.0\n            b_sq = max(best_cost**2 - c_dist**2, 0)\n            b = (b_sq ** 0.5) / 2.0\n            # Set all radii to b except first dimension to a (principal axis)\n            radii = [a] + [b] * (self._dimension - 1)\n\n        center_point = Point.from_tensor(center)\n        return center_point, radii\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        iterations = 1500  # cap on iterations for stable performance, can be tuned\n        found_goal = False\n\n        # Initialize best path cost to infinite (no path found yet)\n        self._best_path_cost = None\n\n        for _ in range(iterations):\n            current_time = time.time()\n            if current_time - start_time > 10:\n                # Timeout exceeded, fail planning\n                return\n\n            # Inform sampling region parameters (adaptive)\n            informed_center, informed_radii = self._calculate_informed_parameters()\n\n            # Batch sampling for exploration\n            samples: List[Point] = [self._get_random_sample(informed_center, informed_radii) for _ in range(self._batch_size)]\n\n            vertices_to_add: List[Vertex] = []\n            for q_sample in samples:\n                q_nearest = self._get_nearest_vertex(q_sample)\n\n                if q_nearest.position == q_sample:\n                    continue\n\n                q_new = self._steer(q_nearest, q_sample, self._max_dist)\n\n                line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n\n                cost_to_new = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n                q_new.cost = cost_to_new\n\n                # Find neighbors for rewiring with adaptive radius\n                card_v = torch.tensor(float(self._graph.size + 1))\n                radius = min(self._lambda_rrt_star * ((torch.log(card_v) / card_v)**(1 / self._dimension)), self._max_radius)\n\n                neighbors = self._get_vertices_within_radius(q_new, radius)\n                # Choose parent with minimum cost\n                q_min = q_nearest\n                c_min = cost_to_new\n                for q_near in neighbors:\n                    line_seq_near_new = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                    if not self._get_grid().is_valid_line_sequence(line_seq_near_new):\n                        continue\n\n                    new_cost = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                    if new_cost < c_min:\n                        c_min = new_cost\n                        q_min = q_near\n                # Assign min cost parent\n                q_new.cost = c_min\n                self._graph.add_edge(q_min, q_new)\n\n                # Rewire neighbors to potentially reduce cost\n                self._rewire_neighbors(q_new, neighbors)\n                vertices_to_add.append(q_new)\n\n                # Check for goal proximity and update best path cost\n                if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                    path_cost_candidate = q_new.cost + torch.norm(q_new.position.to_tensor() - self._get_grid().goal.position.to_tensor())\n                    if self._best_path_cost is None or path_cost_candidate < self._best_path_cost:\n                        self._best_path_cost = path_cost_candidate\n                        self._extract_path(q_new)\n                        found_goal = True\n                        break\n\n            self.key_frame()\n            if found_goal:\n                break",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "Adaptive Batch-Optimized Path Planning (ABOPP):\n\n    This algorithm improves path planning by combining adaptive bidirectional sampling,\n    dynamic batch sizes, hierarchical informed ellipsoidal sampling, and iterative cost-based rewiring.\n\n    Key features:\n    - Bidirectional search between agent and goal trees for faster convergence.\n    - Adaptive batch sampling: batch size grows with iterations to balance exploration/exploitation.\n    - Hierarchical informed sampling: samples preferentially within ellipsoids around current best path segments,\n      refining exploration near promising regions.\n    - Dynamic neighborhood radius based on vertex density for flexible local connectivity.\n    - Cost-aware rewiring leveraging multi-parent graphs to improve path quality iteratively.\n    - Early termination after goal reached or 10 seconds elapsed.\n\n    This approach yields improved efficiency, better path quality with smoother trajectories,\n    increased success rates, and reduced search times in cluttered or high-dimensional spaces.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _batch_base_size: int\n    _batch_max_size: int\n    _lambda_rrt_star: float\n    _dimension: int\n    _start_vertex: Vertex\n    _goal_vertex: Vertex\n    _best_path_cost: float | None\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0.0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n\n        self._max_dist = 14.0\n        self._batch_base_size = 20\n        self._batch_max_size = 80\n        self._lambda_rrt_star = 40.0\n        self._dimension = self._get_grid().size.n_dim\n        self._best_path_cost = None\n\n        self._init_displays()\n\n    def _get_random_sample(self, informed_center: Point = None, informed_radii: list = None) -> Point:\n        grid_size = self._get_grid().size\n        if informed_center is not None and informed_radii is not None:\n            for _ in range(120):\n                direction = torch.randn(self._dimension)\n                direction /= torch.norm(direction)\n                r = torch.rand(1).item() ** (1 / self._dimension)\n                sample_unit_ball = direction * r  \n                sample_coords = informed_center.to_tensor() + torch.tensor(informed_radii) * sample_unit_ball\n                sample_coords_int = torch.clamp(sample_coords.round().long(), min=0, max=torch.tensor(grid_size).long() - 1)\n                sample = Point.from_tensor(sample_coords_int)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        # fallback uniform random sampling\n        while True:\n            rand_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _calculate_ellipsoid_parameters(self, start: Point, goal: Point, cost_bound: float | None) -> (Point, list):\n        start_tensor = start.to_tensor()\n        goal_tensor = goal.to_tensor()\n        center = (start_tensor + goal_tensor) / 2\n        dist = torch.norm(goal_tensor - start_tensor).item()\n        if cost_bound is None or cost_bound < dist:\n            radii = [(dist / 2.0) * 4 for _ in range(self._dimension)]\n        else:\n            a = cost_bound / 2.0\n            b_sq = max(cost_bound * cost_bound - dist * dist, 0)\n            b = (b_sq ** 0.5) / 2.0\n            radii = [a] + [b] * (self._dimension - 1)\n        return Point.from_tensor(center), radii\n\n    def _steer(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + direction_normalized * max_dist)\n        return Vertex(new_pos)\n\n    def _get_vertices_within_radius_dynamic(self, q_new: Vertex) -> list:\n        card_v = float(self._graph.size + 1)\n        radius = min(self._lambda_rrt_star * ((torch.log(torch.tensor(card_v)) / card_v) ** (1.0 / self._dimension)), self._max_dist * 3.5)\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        for q_near in neighbors:\n            if q_near is q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            if q_near.cost is None or new_cost < q_near.cost:\n                # Remove old parent edge if any\n                if q_near.parents:\n                    old_parent = next(iter(q_near.parents))\n                    self._graph.remove_edge(old_parent, q_near)\n                q_near.cost = new_cost\n                self._graph.add_edge(q_new, q_near)\n\n    def _extract_bidirectional_path(self, meet_vertex: Vertex, from_start: bool = True) -> None:\n        # Trace path from meet_vertex back to start and goal (bidirectional)\n        path_start = []\n        cur = meet_vertex\n        while cur.parents:\n            path_start.append(cur)\n            cur = next(iter(cur.parents))\n        path_start.append(cur)\n        path_start.reverse()\n\n        path_goal = []\n        # In the other tree, follow children now to goal\n        cur = meet_vertex\n        while cur.children:\n            child = next(iter(cur.children))\n            path_goal.append(child)\n            cur = child\n\n        full_path = path_start + path_goal\n        # Move agent through the extracted path\n        for v in full_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n        max_time_sec = 10\n\n        # Initialization: trees rooted at start and goal\n        tree_start = [self._start_vertex]\n        tree_goal = [self._goal_vertex]\n\n        self._best_path_cost = None\n        iterations = 0\n        max_iterations = 2000\n        found_path = False\n\n        while iterations < max_iterations:\n            current_time = time.time()\n            if current_time - start_time > max_time_sec:\n                # Fail after timeout\n                return\n\n            # Adaptive batch size growing progressively (20 to 80)\n            batch_size = min(self._batch_base_size + (iterations // 30)*5, self._batch_max_size)\n\n            # Determine ellipsoid for start-to-goal informed sampling using current best path cost if any\n            ellipsoid_center, ellipsoid_radii = self._calculate_ellipsoid_parameters(\n                self._start_vertex.position, self._goal_vertex.position, self._best_path_cost)\n\n            # Alternate growth direction: even iterations grow start tree, odd grow goal tree\n            grow_start_tree = (iterations % 2 == 0)\n\n            if grow_start_tree:\n                root_vertices = [self._start_vertex]\n                opposite_tree = tree_goal\n            else:\n                root_vertices = [self._goal_vertex]\n                opposite_tree = tree_start\n\n            samples = []\n            for _ in range(batch_size):\n                sample = self._get_random_sample(ellipsoid_center, ellipsoid_radii)\n                samples.append(sample)\n\n            new_vertices = []\n            for q_sample in samples:\n                q_nearest = self._graph.get_nearest_vertex(root_vertices, q_sample)\n                if q_nearest.position == q_sample:\n                    continue\n                \n                q_new = self._steer(q_nearest, q_sample, self._max_dist)\n                line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n\n                cost_to_new = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n                q_new.cost = cost_to_new\n\n                neighbors = self._get_vertices_within_radius_dynamic(q_new)\n                # Choose min cost parent from neighbors (including q_nearest)\n                q_min = q_nearest\n                c_min = cost_to_new\n                for q_near in neighbors:\n                    line_seq_neighbor = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                    if not self._get_grid().is_valid_line_sequence(line_seq_neighbor):\n                        continue\n                    new_cost = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                    if new_cost < c_min:\n                        c_min = new_cost\n                        q_min = q_near\n\n                q_new.cost = c_min\n                self._graph.add_edge(q_min, q_new)\n                self._rewire(q_new, neighbors)\n                new_vertices.append(q_new)\n\n                # Add newly created vertex to proper tree list\n                if grow_start_tree:\n                    tree_start.append(q_new)\n                else:\n                    tree_goal.append(q_new)\n\n            # Check for connection between trees via new vertices\n            meet_candidates = []\n            for q_new in new_vertices:\n                close_in_opp = self._graph.get_vertices_within_radius(opposite_tree, q_new.position, self._max_dist*1.5)\n                for q_opp in close_in_opp:\n                    line_seq = self._get_grid().get_line_sequence(q_new.position, q_opp.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        meet_candidates.append((q_new, q_opp))\n\n            if meet_candidates:\n                # Find pair with minimum combined path cost\n                best_pair = None\n                best_cost = float('inf')\n                for (v_start, v_goal) in meet_candidates:\n                    total_cost = v_start.cost + torch.norm(v_start.position.to_tensor() - v_goal.position.to_tensor()) + v_goal.cost\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_pair = (v_start, v_goal)\n\n                if best_pair:\n                    v_start, v_goal = best_pair\n                    self._best_path_cost = best_cost\n\n                    # Connect the two trees by adding edges between the meeting vertices\n                    self._graph.add_edge(v_start, v_goal)\n                    self._graph.add_edge(v_goal, v_start)\n\n                    # Extract and follow path from start to goal through meeting vertices\n                    # To extract complete path, temporarily create merged connectivity\n                    # We'll do a simple BFS to restore the path starting from start vertex toward goal vertex\n\n                    # To avoid infinite loops, store parents manually for extracted path:\n                    # For extraction, recreate parents for meeting vertices\n                    # Temporarily mark connectivity to allow tracing path start->goal:\n                    # Use BFS from start vertex to goal vertex over graph connectivity\n\n                    from collections import deque\n\n                    parent_map = {self._start_vertex: None}\n                    visited = set([self._start_vertex])\n                    q = deque([self._start_vertex])\n                    reached_goal = False\n                    while q and not reached_goal:\n                        curr = q.popleft()\n                        if curr.position == self._goal_vertex.position:\n                            reached_goal = True\n                            break\n                        for child in curr.connectivity:\n                            if child not in visited:\n                                visited.add(child)\n                                parent_map[child] = curr\n                                q.append(child)\n\n                    if not reached_goal:\n                        # fallback: follow original meeting vertices path partial extraction\n                        self._extract_bidirectional_path(v_start, from_start=True)\n                        found_path = True\n                        break\n\n                    # Reconstruct path from goal to start\n                    path = []\n                    node = self._goal_vertex\n                    while node is not None:\n                        path.append(node)\n                        node = parent_map.get(node, None)\n                    path.reverse()\n\n                    for vert in path:\n                        self.move_agent(vert.position)\n                        self.key_frame(ignore_key_frame_skip=True)\n                    found_path = True\n                    break\n\n            self.key_frame()\n            if found_path:\n                break\n\n            iterations += 1",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "Improved Path Planning Algorithm: Adaptive Informed Batch Sampling Tree (AIBST)\n\n    This algorithm enhances sampling-based planning by combining informed sampling in ellipsoidal regions \n    around the current best path, adaptive batch sampling for faster exploration, and rewiring for path quality. \n    It extends RRT* principles with:\n    - Informed sampling around best cost to goal for efficiency and path shortening.\n    - Batch sampling to improve branching and convergence speed.\n    - Early stopping if no improvement in cost for a number of iterations.\n    - Timeout enforcement to fail gracefully after 10 seconds.\n    This approach improves planning efficiency, success rate, path smoothness and path length while \n    robustly handling obstacles through direct collision checking.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: Optional['BasicTesting'] = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n        # Algorithm parameters\n        self._max_dist = 15.0             # max extension distance per step\n        self._max_iter = 15000            # maximum iterations for search\n        self._batch_size = 25             # number of samples per batch\n        self._improvement_wait = 1500     # iterations to wait without improvement before stopping\n        self._dimension = self._get_grid().size.n_dim\n\n        # Track best solution stats\n        self._best_vertex: Optional[Vertex] = None\n        self._best_cost: float = float('inf')\n\n\n    def _get_informed_sample(self, cost_best: float) -> Point:\n        \"\"\"\n        Generate an informed random sample inside ellipse defined by agent and goal positions and current best cost.\n        If no current path found (cost_best == inf), sample uniformly.\n\n        Ellipse parameters:\n        - Center at midpoint between start and goal.\n        - Major axis length = cost_best (best path cost).\n        - Minor axis lengths computed from ellipse formula.\n        \"\"\"\n\n        start_pos = self._graph.root_vertex_start.position.to_tensor()\n        goal_pos = self._graph.root_vertex_goal.position.to_tensor()\n\n        if cost_best == float('inf'):\n            # No solution found yet: sample uniformly in the grid\n            while True:\n                rand_coords = torch.tensor([\n                    np.random.randint(0, self._get_grid().size[i]) \n                    for i in range(self._dimension)\n                ], dtype=torch.float32)\n                sample = Point.from_tensor(rand_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling inside prolate hyperspheroid with focal points start and goal, cost_best as major axis length\n\n        c = (start_pos + goal_pos) / 2.0\n        foci_dist = torch.norm(goal_pos - start_pos) / 2.0\n        if cost_best < foci_dist:\n            # No feasible ellipse possible if current cost < distance between foci\n            return self._get_informed_sample(float('inf'))\n\n        r1 = cost_best / 2.0\n        # Axis lengths for ellipse: r1 = major half axis, r2 = minor half axis\n        r2 = torch.sqrt(cost_best**2 - (2*foci_dist)**2) / 2.0 if cost_best > 2*foci_dist else 0\n\n        # Sample random point in unit n-dim ball\n        while True:\n            direction = torch.randn(self._dimension)\n            direction = direction / torch.norm(direction)\n            radius = torch.rand(1).pow(1/self._dimension).item()  # Uniform sample inside unit ball\n            point_in_ball = direction * radius\n\n            # Construct point in ellipse frame\n            # Rotate and scale ball point according to ellipse axes orientation\n            # We use the direction from start to goal as major axis\n            major_axis = (goal_pos - start_pos)\n            if torch.norm(major_axis) < 1e-8:\n                # start and goal coincide, uniform sample\n                return self._get_informed_sample(float('inf'))\n\n            e1 = major_axis / torch.norm(major_axis)\n            # Construct orthonormal basis via Gram-Schmidt if dimension >1\n            # For simplicity, build rotation matrix with e1 as first column, rest arbitrary orthonormal basis\n            # Here only 2D and 3D considered (2D most common); general n-D can use SVD but restricted environment\n            if self._dimension == 2:\n                # e1 = major axis unit vector\n                # e2 = perpendicular vector\n                e2 = torch.tensor([-e1[1], e1[0]])\n                rot = torch.stack([e1, e2], dim=1)\n                radii = torch.tensor([r1, r2])\n                local_point = rot @ (point_in_ball * radii)\n                sample_point = c + local_point\n            elif self._dimension ==3:\n                # Create e2 orthogonal to e1\n                tmp = torch.tensor([1., 0., 0.])\n                if abs(torch.dot(e1, tmp)) > 0.9:\n                    tmp = torch.tensor([0.,1.,0.])\n                e2 = tmp - e1*torch.dot(e1,tmp)\n                e2 = e2 / torch.norm(e2)\n                e3 = torch.cross(e1, e2)\n                rot = torch.stack([e1, e2, e3], dim=1)\n                radii = torch.tensor([r1, r2, r2])\n                local_point = rot @ (point_in_ball * radii)\n                sample_point = c + local_point\n            else:\n                # For >3D, fallback to uniform sampling if complexity high\n                return self._get_random_sample()\n\n            # Round and cast to int to get grid point\n            sample_point_int = Point.from_tensor(sample_point)\n            if self._get_grid().is_agent_valid_pos(sample_point_int):\n                return sample_point_int\n\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Uniform random sampling inside grid with collision-free check.\"\"\"\n        while True:\n            rand_coords = torch.tensor([\n                np.random.randint(0, self._get_grid().size[i])\n                for i in range(self._dimension)\n            ])\n            sample = Point(*rand_coords.tolist())\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= self._max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / dist\n        new_pos_tensor = q_near.position.to_tensor() + self._max_dist * direction_normalized\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n\n    def _check_collision_free(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n\n    def _rebuild_graph_better_path(self, q_new: Vertex, radius: float):\n        # Try rewiring neighbors to q_new for improving cost, per RRT* principles\n\n        Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            if self._check_collision_free(q_new.position, q_near.position):\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if cost_new_to_near < q_near.cost:\n                    # Rewire q_near to new parent q_new\n                    # Remove old parent link\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n\n    def _extract_path(self, q_goal: Vertex):\n        # Build path from q_goal back to start\n        path: List[Vertex] = [q_goal]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n        path.reverse()\n\n        # Move agent through path for visualization and execution\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid: Map = self._get_grid()\n            # If RosMap, publish new waypoint (optional)\n            try:\n                from algorithms.configuration.maps.ros_map import RosMap\n                if isinstance(grid, RosMap):\n                    grid.publish_wp(grid.agent.position)\n            except ImportError:\n                pass\n            self.key_frame(ignore_key_frame_skip=True)\n\n\n    def _find_path_internal(self) -> None:\n\n        start_time = time.time()\n\n        # Initialization\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        \n        radius_const = 30.0  # Max neighbor search radius for rewiring\n        no_improve_count = 0\n        \n        for iteration in range(self._max_iter):\n\n            # Check for timeout to fail path search after 10 seconds\n            if time.time() - start_time > 10.0:\n                # Failed to find path within time limit\n                break\n\n            # Batch sampling (informed sampling around current best cost)\n            samples: List[Point] = []\n            for _ in range(self._batch_size):\n                sample = self._get_informed_sample(self._best_cost)\n                samples.append(sample)\n\n            for q_sample in samples:\n                q_nearest = self._get_nearest_vertex(q_sample)\n                if q_nearest.position == q_sample:\n                    continue\n\n                q_new = self._get_new_vertex(q_nearest, q_sample)\n                if not self._check_collision_free(q_nearest.position, q_new.position):\n                    continue\n\n                # Calculate cost of path through q_nearest to q_new\n                dist = torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n                cost_through_nearest = q_nearest.cost + dist\n\n                # Get nearby vertices for potential better parent selection and rewiring\n                radius = min(radius_const, self._max_dist * (torch.log(torch.tensor(self._graph.size + 1)).item() / (self._graph.size + 1))**(1/self._dimension))\n\n                Q_near = self._get_vertices_within_radius(q_new, radius)\n                \n                # Choose parent with minimum cost + collision free\n                q_min = q_nearest\n                c_min = cost_through_nearest\n\n                for q_near in Q_near:\n                    dist_near_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                    cost_new = q_near.cost + dist_near_new\n                    if cost_new < c_min and self._check_collision_free(q_near.position, q_new.position):\n                        c_min = cost_new\n                        q_min = q_near\n\n                q_new.cost = c_min\n                self._graph.add_edge(q_min, q_new)\n\n                # Rewire neighbors if beneficial\n                self._rebuild_graph_better_path(q_new, radius)\n\n                # Check if reached goal radius\n                if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                    # If this is better than previous best, update best path\n                    if q_new.cost < self._best_cost:\n                        self._best_cost = q_new.cost\n                        self._best_vertex = q_new\n                        self._extract_path(q_new)\n                        no_improve_count = 0\n                        # Continue search to improve further if time permits\n                    else:\n                        no_improve_count += 1\n\n                else:\n                    # No immediate improvement, count iterations without improvement\n                    no_improve_count += 1\n\n            # Early exit if no improvement for many iterations to save time\n            if no_improve_count > self._improvement_wait:\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This algorithm implements an Enhanced Bidirectional RRT* (Rapidly-exploring Random Tree Star) inspired planner optimized for grid-based maps.\n    It builds two trees: one rooted at the agent start and one at the goal position, simultaneously expanding them with controlled random sampling.\n    Key improvements include:\n    - Bidirectional tree growth for faster convergence.\n    - RRT* style rewiring for improved path quality and shorter paths.\n    - Adaptive sampling of promising regions near the trees to improve exploration efficiency and robustness.\n    - Use of a connection radius that scales with environment size and iteration count.\n    - Early stopping and timeout mechanism to abort after 10 seconds.\n    The final path is extracted by connecting the two trees at their closest pair of vertices with a valid collision-free path.\n    This ensures improved planning efficiency, success rate, path smoothness and shorter path lengths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_iter = 1000\n        # Connection radius (tunable, scales with map max dimension)\n        grid_size = self._get_grid().size\n        max_dim = max(grid_size)\n        self._connection_radius = max_dim * 0.2\n        # Initialized tree vertex sets\n        self._tree_start: Forest = None  # type: ignore\n        self._tree_goal: Forest = None   # type: ignore\n        self._timeout_sec = 10.0\n\n    def _get_random_sample(self) -> Point:\n        # Biased random sampling: 70% uniform, 15% near tree_start vertices, 15% near tree_goal vertices\n        p_uniform = 0.7\n        grid = self._get_grid()\n        if torch.rand(1).item() < p_uniform or self._tree_start is None or self._tree_goal is None:\n            # Uniform random sample in valid space\n            while True:\n                sample = Point(*[torch.randint(0, grid.size[i], (1,)).item() for i in range(grid.size.n_dim)])\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Sample near one tree randomly\n            tree = self._tree_start if torch.rand(1).item() < 0.5 else self._tree_goal\n            vertices = tree.root_vertices\n            if not vertices:\n                return self._get_random_sample()\n            v = vertices[torch.randint(len(vertices), (1,)).item()]\n            # Sample in sphere of connection radius around vertex\n            dim = grid.size.n_dim\n            for _ in range(10):\n                offset = torch.randn(dim) * (self._connection_radius / 2)\n                candidate_vals = torch.clamp(v.position.to_tensor() + offset, min=0, max=torch.tensor(grid.size.values) - 1)\n                candidate = Point.from_tensor(candidate_vals)\n                if grid.is_agent_valid_pos(candidate):\n                    return candidate\n            # fallback uniform\n            return self._get_random_sample()\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_dist: Optional[float] = None) -> Vertex:\n        # Returns a new vertex towards to_point limited by max_dist\n        dir_vec = to_point.to_tensor() - from_vertex.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if max_dist is None or dist <= max_dist:\n            new_pos = to_point\n        else:\n            dir_unit = dir_vec / dist\n            new_pos = Point.from_tensor(from_vertex.position.to_tensor() + dir_unit * max_dist)\n        return Vertex(new_pos)\n\n    def _get_near_vertices(self, tree: Forest, point: Point) -> List[Vertex]:\n        return tree.get_vertices_within_radius(tree.root_vertices, point, self._connection_radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], new_vertex: Vertex, tree: Forest) -> Optional[Vertex]:\n        # Choose a parent that produces minimum cost path and has valid line\n        best_parent = None\n        best_cost = float(\"inf\")\n        grid = self._get_grid()\n        for v in near_vertices:\n            line_seq = grid.get_line_sequence(v.position, new_vertex.position)\n            if v.position != new_vertex.position and grid.is_valid_line_sequence(line_seq):\n                cost = v.cost + grid.get_movement_cost(v.position, new_vertex.position)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_parent = v\n        return best_parent\n\n    def _rewire(self, tree: Forest, new_vertex: Vertex, near_vertices: List[Vertex]) -> None:\n        # For RRT* style rewiring of near vertices to new_vertex if better cost found\n        grid = self._get_grid()\n        for v in near_vertices:\n            if v is new_vertex:\n                continue\n            line_seq = grid.get_line_sequence(new_vertex.position, v.position)\n            if grid.is_valid_line_sequence(line_seq):\n                new_cost = new_vertex.cost + grid.get_movement_cost(new_vertex.position, v.position)\n                if new_cost < v.cost:\n                    # Remove old parent edges and connect new_vertex as parent\n                    for p in list(v.parents):\n                        tree.remove_edge(p, v)\n                    tree.add_edge(new_vertex, v)\n                    v.cost = new_cost\n\n    def _extract_path(self, connection_start: Vertex, connection_goal: Vertex) -> None:\n        # Extract path by tracing parents from connection points to roots and combine\n        path_start = []\n        current = connection_start\n        while True:\n            path_start.append(current.position)\n            if not current.parents:\n                break\n            current = next(iter(current.parents))  # Single parent in tree\n        path_start.reverse()\n\n        path_goal = []\n        current = connection_goal\n        while True:\n            path_goal.append(current.position)\n            if not current.parents:\n                break\n            current = next(iter(current.parents))\n\n        path = path_start + path_goal\n\n        for p in path:\n            self.move_agent(p)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        agent_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        # Initialize two forests: start and goal trees\n        v_start = Vertex(agent_pos)\n        v_start.cost = 0.0\n        v_goal = Vertex(goal_pos)\n        v_goal.cost = 0.0\n\n        self._tree_start = Forest(root_vertex_start=v_start, root_vertex_goal=v_goal, root_vertices=[v_start])\n        self._tree_goal = Forest(root_vertex_start=v_start, root_vertex_goal=v_goal, root_vertices=[v_goal])\n\n        start_time = time.time()\n\n        for iter_i in range(self._max_iter):\n            if time.time() - start_time > self._timeout_sec:\n                # Fail condition: aborted after timeout\n                return\n\n            # Alternate tree expanding: expand start tree on even iterations, goal tree on odd iterations\n            if iter_i % 2 == 0:\n                tree_from = self._tree_start\n                tree_to = self._tree_goal\n            else:\n                tree_from = self._tree_goal\n                tree_to = self._tree_start\n\n            q_rand = self._get_random_sample()\n\n            # Extend tree_from towards q_rand\n            q_near = tree_from.get_nearest_vertex(tree_from.root_vertices, q_rand)\n            q_new = self._steer(q_near, q_rand, max_dist=self._connection_radius)\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            near_vertices = self._get_near_vertices(tree_from, q_new.position)\n            parent = self._choose_parent(near_vertices, q_new, tree_from)\n            if parent is None:\n                parent = q_near\n            tree_from.add_edge(parent, q_new)\n            q_new.cost = parent.cost + grid.get_movement_cost(parent.position, q_new.position)\n            tree_from.root_vertices.append(q_new)\n            self._rewire(tree_from, q_new, near_vertices)\n\n            self.key_frame()\n\n            # Try to connect q_new to the other tree (tree_to)\n            near_vertices_to = self._get_near_vertices(tree_to, q_new.position)\n            connected = False\n            min_connection_cost = float(\"inf\")\n            connection_pair = None\n            for v_to in near_vertices_to:\n                line_seq_connect = grid.get_line_sequence(q_new.position, v_to.position)\n                if grid.is_valid_line_sequence(line_seq_connect):\n                    cost_connect = q_new.cost + grid.get_movement_cost(q_new.position, v_to.position) + v_to.cost\n                    if cost_connect < min_connection_cost:\n                        min_connection_cost = cost_connect\n                        connection_pair = (q_new, v_to)\n                        connected = True\n\n            if connected and connection_pair is not None:\n                # Connect edge both ways for tracking\n                tree_from.add_edge(connection_pair[0], connection_pair[1])\n                tree_to.add_edge(connection_pair[1], connection_pair[0])\n                # Extract path by merging two trees at connection point\n                self._extract_path(connection_pair[0], connection_pair[1])\n                return\n\n        # If loop finishes without path, consider planning failed\n        return",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This algorithm implements an improved and hybrid RRT* inspired approach with vertex rewiring to reduce path cost,\n    enhanced sampling bias towards the goal for more directed search, and collision-checked incremental connection steps.\n    It also uses a priority queue (min-heap) to efficiently keep track of vertices to explore next by their cost + heuristic,\n    akin to an informed RRT* with A*-like search guidance.\n\n    Key improvements:\n    - Uses rewiring to improve path quality by dynamically reducing costs.\n    - Samples towards the goal with adjustable probability to improve convergence speed.\n    - Checks line-of-sight with Bresenham's line sequences for collision-free edges.\n    - Maintains a cost-to-come and heuristic cost framework for better vertex connection decisions.\n    - Limits maximum connection length to keep sampling local and reduce collisions.\n    - Enforces 10 seconds maximum planning time to guarantee termination.\n    - Extracts and moves the agent along the best found path once goal is reached.\n\n    The algorithm balances exploration and exploitation, ensuring better robustness, path smoothness,\n    and shorter path lengths than vanilla RRT by also leveraging local rewiring and heuristic guiding.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: \"Services\", testing: \"BasicTesting\" = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            [],\n        )\n        self._graph.edges_removable = True  # enable edge rewiring\n        self._init_displays()\n\n        self._max_edge_length = 12.0  # max distance between connected vertices (controls granularity)\n        self._goal_sample_rate = 0.15  # probability of sampling the goal directly (bias)\n        self._search_radius = 20.0  # radius for neighbors rewiring\n\n    def _heuristic_cost(self, pos: Point) -> float:\n        # Heuristic: Euclidean distance to goal\n        return self._get_grid().get_distance(pos, self._get_grid().goal.position)\n\n    def _get_new_vertex_towards(\n        self, q_near: Vertex, q_sample: Point, max_dist: float\n    ) -> Vertex:\n        # Attempts to move from q_near toward q_sample with a step limited to max_dist.\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new = Point.from_tensor(new_pos_tensor)\n        return Vertex(q_new, store_connectivity=True)\n\n    def _get_random_sample(self) -> Point:\n        # Sample random point with goal bias to enhance efficiency.\n        import random\n\n        if random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n\n        size = self._get_grid().size\n        n_dim = size.n_dim\n        while True:\n            rand_coords = tuple(int(np.random.randint(0, size[i])) for i in range(n_dim))\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _find_near_vertices(\n        self, vertices: List[Vertex], q_new: Vertex, radius: float\n    ) -> List[Vertex]:\n        # Returns all vertices within radius of q_new.position\n        result = []\n        for v in vertices:\n            if self._get_grid().get_distance(v.position, q_new.position) <= radius:\n                result.append(v)\n        return result\n\n    def _line_is_free(self, frm: Point, to: Point) -> bool:\n        # Check if the straight line path frm->to is valid (collision free)\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _cost_from_to(self, frm: Vertex, to: Vertex) -> float:\n        # Returns the movement cost between two vertices.\n        return self._get_grid().get_movement_cost(frm.position, to.position)\n\n    def _extract_path(self, last_vertex: Vertex) -> None:\n        path: List[Vertex] = [last_vertex]\n        while len(path[-1].parents) != 0:\n            # Since parents is a set, pick the parent with minimum cost for path extraction\n            parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(parent)\n        path.reverse()\n\n        # Move agent along found path with frames for animation\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        # Priority queue for vertices to explore: (cost+heuristic, cost, Vertex)\n        open_set: List[Tuple[float, float, Vertex]] = []\n        heapq.heappush(\n            open_set,\n            (self._heuristic_cost(start_vertex.position), 0.0, start_vertex),\n        )\n\n        visited: Dict[Tuple[int, ...], Vertex] = {\n            tuple(start_vertex.position): start_vertex\n        }  # key: position tuple\n\n        goal_reached_vertex: Optional[Vertex] = None\n\n        while len(open_set) > 0:\n            if time.time() - start_time > 10.0:\n                # Fail condition if takes over 10 seconds\n                break\n\n            _, curr_cost, current = heapq.heappop(open_set)\n\n            # If current vertex is within goal radius, finish search\n            if self._get_grid().is_agent_in_goal_radius(current.position):\n                goal_reached_vertex = current\n                break\n\n            # Sample new point biased toward goal\n            q_sample = self._get_random_sample()\n\n            # Get nearest existing vertex from graph roots\n            q_nearest = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex_towards(q_nearest, q_sample, self._max_edge_length)\n\n            # Discard if line from q_nearest to q_new is not valid\n            if not self._line_is_free(q_nearest.position, q_new.position):\n                continue\n\n            # Calculate cost to reach new vertex through q_nearest\n            tentative_cost = q_nearest.cost + self._cost_from_to(q_nearest, q_new)\n\n            pos_key = tuple(q_new.position)\n            if pos_key in visited:\n                existing_vertex = visited[pos_key]\n                if tentative_cost < existing_vertex.cost:\n                    # Rewire existing vertex with new parent q_nearest with better cost\n                    # Remove old edges from old parents\n                    for p in existing_vertex.parents:\n                        p.children.discard(existing_vertex)\n                        existing_vertex.parents.discard(p)\n                    existing_vertex.cost = tentative_cost\n                    existing_vertex.add_parent(q_nearest)\n                    q_nearest.add_child(existing_vertex)\n\n                    # Propagate cost update to children recursively\n                    self._rewire_costs(existing_vertex)\n\n                    heapq.heappush(\n                        open_set,\n                        (\n                            tentative_cost + self._heuristic_cost(existing_vertex.position),\n                            tentative_cost,\n                            existing_vertex,\n                        ),\n                    )\n                # else: existing vertex cheaper path, skip\n                continue\n\n            # New vertex discovered, add to forest and visited dictionary\n            q_new.cost = tentative_cost\n            q_new.add_parent(q_nearest)\n            q_nearest.add_child(q_new)\n\n            self._graph.root_vertices.append(q_new)\n            visited[pos_key] = q_new\n\n            # Rewire near vertices within radius if they can be reached cheaper via q_new\n            nearby_vertices = self._find_near_vertices(self._graph.root_vertices, q_new, self._search_radius)\n            for near_v in nearby_vertices:\n                if near_v is q_new:\n                    continue\n                if not self._line_is_free(q_new.position, near_v.position):\n                    continue\n                cost_through_new = q_new.cost + self._cost_from_to(q_new, near_v)\n                if cost_through_new < near_v.cost:\n                    # Remove old edges from parents of near_v\n                    for p in near_v.parents:\n                        p.children.discard(near_v)\n                    near_v.parents.clear()\n\n                    # Add q_new as new parent\n                    near_v.cost = cost_through_new\n                    near_v.add_parent(q_new)\n                    q_new.add_child(near_v)\n\n                    # Recursively update children's cost after rewiring\n                    self._rewire_costs(near_v)\n\n                    heapq.heappush(\n                        open_set,\n                        (\n                            near_v.cost + self._heuristic_cost(near_v.position),\n                            near_v.cost,\n                            near_v,\n                        ),\n                    )\n\n            # Push q_new to open set\n            heapq.heappush(\n                open_set,\n                (q_new.cost + self._heuristic_cost(q_new.position), q_new.cost, q_new),\n            )\n\n            self.key_frame()  # visualize expansion progress\n\n        if goal_reached_vertex is not None:\n            self._extract_path(goal_reached_vertex)\n        # else: planning failed due to timeout or no feasible path found\n\n    def _rewire_costs(self, vertex: Vertex) -> None:\n        \"\"\"\n        Recursively update cost of vertex's children after rewiring.\n        Only update if child's cost can be improved.\n        \"\"\"\n        for child in vertex.children:\n            new_cost = vertex.cost + self._cost_from_to(vertex, child)\n            if new_cost < child.cost:\n                child.cost = new_cost\n                # Remove other parents - keep only vertex as parent for simplicity\n                for p in list(child.parents):\n                    if p != vertex:\n                        p.children.discard(child)\n                        child.parents.discard(p)\n\n                if vertex not in child.parents:\n                    child.add_parent(vertex)\n                self._rewire_costs(child)",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "Adaptive Dynamic Multi-Resolution Informed Rapidly-exploring Random Tree (ADMIRRT*)\n    \n    This algorithm combines multi-resolution grid-adaptive sampling with dynamically shrinking informed regions \n    for rapid convergence to high-quality paths. It uses adaptive batch sizes increasing with iteration count \n    for exploration, and local smoothing to improve path quality and smoothness during planning.\n    \n    Key innovations:\n    - Multi-resolution progressive sampling: alternates between large step and fine local refinement.\n    - Dynamic elliptical informed sampling with radius shrinking after improvements.\n    - Adaptive batch sampling with growing number of samples per iteration to balance exploration/exploitation.\n    - Early pruning of costly branches via cost thresholds and radius-based neighborhood rewiring.\n    - Local path smoothing by shortcutting feasible edges after every improvement.\n    - Timeout enforcement to fail path search gracefully after 10 seconds.\n    \n    Improves path planning performance with efficiency, path smoothness, shorter paths, and robust obstacle handling.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n        # Algorithm parameters\n        self._dimension = self._get_grid().size.n_dim\n        self._max_iter = 12000               # max iterations (reduce a bit from 15k)\n        self._base_max_dist = 18.0           # base max extension distance\n        self._max_batch_size = 60            # max batch size grows adaptively\n        self._min_batch_size = 15            # minimum batch size\n        self._improvement_wait = 1000        # early stopping iterations without improvement\n        self._timeout_seconds = 10.0         # fail after 10 seconds\n\n        self._best_vertex = None\n        self._best_cost = float('inf')\n        self._no_improve_count = 0\n        self._informed_radius = float('inf') # dynamic radius of informed elliptical region\n\n\n    def _get_dynamic_max_dist(self, iteration: int) -> float:\n        # Alternate between large jumps and finer steps by iteration parity\n        if iteration % 10 < 7:\n            # Most iterations use larger max dist for faster exploration\n            return self._base_max_dist\n        else:\n            # Every few iterations use smaller max dist for local refinement\n            return self._base_max_dist / 3.0\n\n    def _adaptive_batch_size(self, iteration: int) -> int:\n        # Increase batch size with iteration progress for denser exploration over time\n        batch = int(self._min_batch_size + (self._max_batch_size - self._min_batch_size) * (iteration / self._max_iter))\n        return max(self._min_batch_size, min(batch, self._max_batch_size))\n\n    def _sample_in_informed_region(self, cost_best: float) -> Point:\n        # Sample inside an informed elliptical region around start & goal with adjustable radius\n        start_tensor = self._graph.root_vertex_start.position.to_tensor()\n        goal_tensor = self._graph.root_vertex_goal.position.to_tensor()\n\n        if cost_best == float('inf') or self._informed_radius == float('inf'):\n            # No solution: uniform random sampling\n            while True:\n                coords = torch.tensor([np.random.randint(0, self._get_grid().size[i]) for i in range(self._dimension)])\n                p = Point(*coords.tolist())\n                if self._get_grid().is_agent_valid_pos(p):\n                    return p\n\n        # Compute ellipse parameters with dynamic radius (informed radius < cost_best)\n        c = (start_tensor + goal_tensor) / 2.0\n        half_foci_dist = torch.norm(goal_tensor - start_tensor) / 2.0\n        r_major = max(self._informed_radius / 2.0, half_foci_dist + 1e-5)\n        r_minor = torch.sqrt(max(r_major**2 - half_foci_dist**2, torch.tensor(0.0)))\n\n        # Sample random point inside unit ball in self._dimension\n        while True:\n            direction = torch.randn(self._dimension)\n            norm_direction = torch.norm(direction)\n            if norm_direction < 1e-8:\n                continue\n            direction = direction / norm_direction\n            radius = torch.rand(1).item() ** (1.0 / self._dimension)\n            sampled_ball = direction * radius\n\n            # Rotation basis construction: major axis e1 along start->goal\n            e1 = (goal_tensor - start_tensor)\n            norm_e1 = torch.norm(e1)\n            if norm_e1 < 1e-8:\n                # Start and goal coincide, fallback\n                return self._sample_in_informed_region(float('inf'))\n\n            e1 = e1 / norm_e1\n\n            if self._dimension == 2:\n                e2 = torch.tensor([-e1[1], e1[0]])\n                rot = torch.stack([e1, e2], dim=1)\n                radii = torch.tensor([r_major, r_minor])\n                local_point = rot @ (sampled_ball * radii)\n            elif self._dimension == 3:\n                tmp = torch.tensor([1., 0., 0.])\n                if abs(torch.dot(e1, tmp)) > 0.9:\n                    tmp = torch.tensor([0., 1., 0.])\n                e2 = tmp - e1 * torch.dot(e1, tmp)\n                e2 = e2 / torch.norm(e2)\n                e3 = torch.cross(e1, e2)\n                rot = torch.stack([e1, e2, e3], dim=1)\n                radii = torch.tensor([r_major, r_minor, r_minor])\n                local_point = rot @ (sampled_ball * radii)\n            else:\n                # Fallback to uniform if dimension unsupported\n                return self._get_random_sample()\n\n            candidate = c + local_point\n            p_int = Point.from_tensor(candidate)\n            if self._get_grid().is_agent_valid_pos(p_int):\n                return p_int\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_coords = torch.tensor([np.random.randint(0, self._get_grid().size[i]) for i in range(self._dimension)])\n            p = Point(*rand_coords.tolist())\n            if self._get_grid().is_agent_valid_pos(p):\n                return p\n\n    def _get_nearest_vertex(self, sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], sample)\n\n    def _new_vertex_towards(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        diff = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(diff)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        direction = diff / dist\n        new_point = q_near.position.to_tensor() + direction * max_dist\n        return Vertex(Point.from_tensor(new_point))\n\n    def _check_collision_free(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _vertices_in_radius(self, q_new: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _rewire(self, q_new: Vertex, radius: float):\n        neighbors = self._vertices_in_radius(q_new, radius)\n        for q_near in neighbors:\n            if q_near is q_new:\n                continue\n            if self._check_collision_free(q_new.position, q_near.position):\n                cost_through_new = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if cost_through_new < q_near.cost:\n                    # Rewire: remove old parent and add new edge\n                    for p in q_near.parents:\n                        self._graph.remove_edge(p, q_near)\n                        break\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, q_goal: Vertex) -> list:\n        path = [q_goal]\n        while len(path[-1].parents) > 0:\n            for p in path[-1].parents:\n                path.append(p)\n                break\n        path.reverse()\n        return path\n\n    def _shortcut_path(self, path: list) -> list:\n        # Attempt to shortcut path by connecting non-adjacent vertices directly if collision-free\n        if len(path) < 3:\n            return path\n\n        shortened = [path[0]]\n        idx = 0\n        while idx < len(path)-1:\n            # Find farthest reachable vertex directly from current\n            next_idx = idx + 1\n            for j in range(len(path)-1, idx, -1):\n                if self._check_collision_free(path[idx].position, path[j].position):\n                    next_idx = j\n                    break\n            shortened.append(path[next_idx])\n            idx = next_idx\n        return shortened\n\n    def _move_agent_along_path(self, path: list) -> None:\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid = self._get_grid()\n            # Optional: publish waypoint for ROS map if available\n            try:\n                from algorithms.configuration.maps.ros_map import RosMap\n                if isinstance(grid, RosMap):\n                    grid.publish_wp(grid.agent.position)\n            except ImportError:\n                pass\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n\n        self._best_cost = float('inf')\n        self._best_vertex = None\n        self._no_improve_count = 0\n        self._informed_radius = float('inf')\n\n        iteration = 0\n\n        while iteration < self._max_iter:\n            iteration += 1\n\n            # Timeout check (fail after 10 seconds)\n            if time.time() - start_time > self._timeout_seconds:\n                # Failed to find path in time\n                break\n\n            # Dynamic parameters\n            max_dist = self._get_dynamic_max_dist(iteration)\n            batch_size = self._adaptive_batch_size(iteration)\n\n            samples = []\n            for _ in range(batch_size):\n                sample_point = self._sample_in_informed_region(self._best_cost)\n                samples.append(sample_point)\n\n            radius_factor = min(30.0, max_dist * (torch.log(torch.tensor(self._graph.size + 1)) / (self._graph.size + 1)).pow(1.0 / self._dimension))\n            radius = radius_factor if radius_factor > 1.0 else 1.0\n\n            improved_in_iter = False\n\n            for q_sample in samples:\n                q_nearest = self._get_nearest_vertex(q_sample)\n                if q_nearest.position == q_sample:\n                    continue\n\n                q_new = self._new_vertex_towards(q_nearest, q_sample, max_dist)\n                if not self._check_collision_free(q_nearest.position, q_new.position):\n                    continue\n\n                tentative_cost = q_nearest.cost + torch.norm(q_new.position.to_tensor() - q_nearest.position.to_tensor())\n\n                # Find best parent among neighbors\n                neighbors = self._vertices_in_radius(q_new, radius)\n                q_min = q_nearest\n                c_min = tentative_cost\n\n                for nbr in neighbors:\n                    dist_nbr_new = torch.norm(nbr.position.to_tensor() - q_new.position.to_tensor())\n                    c_nbr = nbr.cost + dist_nbr_new\n                    if c_nbr < c_min and self._check_collision_free(nbr.position, q_new.position):\n                        c_min = c_nbr\n                        q_min = nbr\n\n                q_new.cost = c_min\n                self._graph.add_edge(q_min, q_new)\n\n                # Rewire neighbors for improved cost\n                self._rewire(q_new, radius)\n\n                # Check for goal reached within goal radius\n                if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                    if q_new.cost + 1e-6 < self._best_cost:\n                        self._best_cost = q_new.cost\n                        self._best_vertex = q_new\n                        improved_in_iter = True\n\n                        # Shrink informed radius to focus sampling\n                        self._informed_radius = min(self._informed_radius, self._best_cost * 1.2)\n\n                        # Extract path, shortcut for smoothness, move agent\n                        raw_path = self._extract_path(q_new)\n                        smoothed_path = self._shortcut_path(raw_path)\n                        self._move_agent_along_path(smoothed_path)\n                        self._no_improve_count = 0\n                    else:\n                        self._no_improve_count += 1\n                else:\n                    self._no_improve_count += 1\n\n            if not improved_in_iter:\n                self._no_improve_count += 1\n\n            # Early stopping if no improvements for a long period\n            if self._no_improve_count > self._improvement_wait:\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This algorithm implements an improved sample-based path planning method combining key strengths \n    from RRT* and informed sampling techniques. It uses a Forest graph for tree management but enhances \n    path quality and planning efficiency by: \n    \n    - Employing adaptive informed sampling focused inside an elliptical heuristic region between the \n      agent and goal to concentrate samples effectively. \n    \n    - Using an efficient rewiring step inspired by RRT* to shorten paths and improve quality.\n    \n    - Incorporating path smoothing by shortcutting along feasible trajectories after initial path \n      discovery, reducing jaggedness and path length.\n    \n    - Restricting the planning time to 10 seconds to guarantee timely termination (failure if exceeded).\n    \n    Overall, the algorithm balances exploration with focused exploitation to deliver robust, high-quality, \n    smooth paths in reduced search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph: Forest = None\n        self._max_dist: float = 15.0\n        self._max_radius: float = 30.0\n        self._dimension: int = 2\n        self._lambda_rrt_star: float = 50.0\n        self._start_time: Optional[float] = None\n\n    def _get_random_sample_informed(self, start: Point, goal: Point) -> Point:\n        # Informed sampling inside prolate hyperspheroid ellipse for 2D between start and goal\n        # preferentially focus samples in region potentially containing better paths\n        c_best = self._get_grid().get_distance(start, goal)\n        if c_best == 0:\n            return start\n\n        c_min = self._get_grid().get_distance(start, goal)\n        if c_min == 0:\n            return start\n\n        # Ellipse parameters: center at midpoint, major axis along start->goal\n        center = Point.from_tensor((start.to_tensor() + goal.to_tensor()) / 2)\n        diff = (goal.to_tensor() - start.to_tensor()).numpy()\n\n        # Axis lengths\n        a1 = c_best / 2  # major axis half-length\n        if a1 < 1e-6:\n            # Degenerate to random uniform sampling if too close\n            return self._get_random_sample_uniform()\n\n        # Minor axis half-length for 2D ellipse, estimate conservatively\n        b1 = (c_best ** 2 - c_min ** 2) ** 0.5 / 2\n\n        # Rotation angle from x-axis\n        angle = 0.0\n        if abs(diff[0]) > 1e-6 or abs(diff[1]) > 1e-6:\n            angle = float(torch.atan2(diff[1], diff[0]))\n\n        # Sample a random point inside unit circle then scale to ellipse\n        while True:\n            # Sample uniformly in unit circle\n            import random, math\n            r = random.uniform(0, 1)\n            theta = random.uniform(0, 2 * math.pi)\n            x = r**0.5 * math.cos(theta)\n            y = r**0.5 * math.sin(theta)\n\n            # Scale to ellipse\n            x_scaled = x * a1\n            y_scaled = y * b1\n\n            # Rotate back to world coords\n            cos_a = math.cos(angle)\n            sin_a = math.sin(angle)\n            xr = x_scaled * cos_a - y_scaled * sin_a\n            yr = x_scaled * sin_a + y_scaled * cos_a\n\n            sample_point = Point(center.x + xr, center.y + yr)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _get_random_sample_uniform(self) -> Point:\n        while True:\n            sample = Point(*[\n                torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)\n            ])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / norm_dir\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _try_rewire(self, q_new: Vertex, Q_near: List[Vertex]):\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            path_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position))\n            if not path_free:\n                continue\n            cost_through_new = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n            if cost_through_new < q_near.cost:\n                # Remove old edge\n                old_parent = None\n                for p in q_near.parents:\n                    old_parent = p\n                    break\n                if old_parent is not None:\n                    self._graph.remove_edge(old_parent, q_near)\n                # Add new edge\n                q_near.cost = cost_through_new\n                self._graph.add_edge(q_new, q_near)\n\n    def _reconstruct_path(self, goal_vertex: Vertex) -> List[Vertex]:\n        path = [goal_vertex]\n        current = goal_vertex\n        while len(current.parents) > 0:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n        return path\n\n    def _path_shortcutting(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut path by connecting non-adjacent vertices directly if free path exists\n        if len(path) < 3:\n            return path\n        shortened_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            furthest = i + 1\n            # From current vertex, jump ahead as far as possible with collision-free check\n            for j in range(len(path) - 1, i, -1):\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    furthest = j\n                    break\n            shortened_path.append(path[furthest])\n            i = furthest\n        return shortened_path\n\n    def _extract_and_move_path(self, goal_vertex: Vertex) -> None:\n        path_vertices = self._reconstruct_path(goal_vertex)\n        path_vertices = self._path_shortcutting(path_vertices)\n        for vertex in path_vertices:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n\n        start_point = self._get_grid().agent.position\n        goal_point = self._get_grid().goal.position\n        start_vertex = Vertex(start_point)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(goal_point)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        max_iterations = 10000\n        for iteration in range(max_iterations):\n            current_time = time.time()\n            if current_time - self._start_time > 10.0:\n                # Timeout failure\n                break\n\n            # Adaptive informed sampling after some iterations to focus search\n            if iteration < 100:\n                q_sample = self._get_random_sample_uniform()\n            else:\n                q_sample = self._get_random_sample_informed(start_point, goal_point)\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            tentative_cost = q_nearest.cost + self._get_grid().get_distance(q_nearest.position, q_new.position)\n\n            # Find neighbors for rewiring\n            card_v = float(self._graph.size + 1)\n            log_card_v = torch.log(torch.tensor(card_v))\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), self._max_radius)\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose the best parent from neighbors\n            q_min = q_nearest\n            c_min = tentative_cost\n            for q_near in Q_near:\n                path_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                if not path_free:\n                    continue\n                cost_through_near = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n                if cost_through_near < c_min:\n                    q_min = q_near\n                    c_min = cost_through_near\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Try rewiring the neighbors through q_new to improve path cost\n            self._try_rewire(q_new, Q_near)\n\n            # Check goal reachability with radius check for robust success\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Final goal vertex connect and path extraction\n                goal_connect_line = self._get_grid().get_line_sequence(q_new.position, goal_point)\n                if self._get_grid().is_valid_line_sequence(goal_connect_line):\n                    dist_to_goal = self._get_grid().get_distance(q_new.position, goal_point)\n                    goal_vertex.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_and_move_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "PathPlanning is an improved sample-based path planning algorithm combining informed sampling,\n    efficient rewiring like RRT*, and shortcut smoothing of the final path to improve path length,\n    smoothness, success rate, and planning speed. The planner generates random samples biased inside \n    an ellipsoidal informed region to focus search near the optimal path corridor between agent and \n    goal, reducing exploration overhead. A forest graph rooted at agent and goal is incrementally \n    extended during iterative sampling. Vertices are rewired within neighborhoods to minimize cost,\n    improving solution quality continuously. Upon finding a feasible path within a 10-second time limit,\n    the path is extracted, then post-processed with line-of-sight shortcut smoothing to enhance smoothness \n    and reduce unnecessary vertices. The algorithm balances exploration and exploitation, ensuring rapid \n    convergence to high-quality, collision-free paths even in cluttered environments with robustness against \n    failures by early timeout.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _informed_sampling_enabled: bool\n    _max_radius: float\n    _elapsed_time_limit: float\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(*args, **kwargs)\n        self._max_dist = 15.0\n        self._max_radius = 50.0\n        self._elapsed_time_limit = 10.0  # seconds\n        self._informed_sampling_enabled = True\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    def _get_distance(self, frm: Point, to: Point) -> float:\n        return self._get_grid().get_distance(frm, to)\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Perform informed sampling: samples inside an ellipsoid defined by current best solution cost,\n        between start and goal positions, if available. Otherwise uniform random sampling.\n        \"\"\"\n        grid = self._get_grid()\n        start = grid.agent.position\n        goal = grid.goal.position\n\n        if not self._informed_sampling_enabled or self._graph.root_vertex_goal.cost is None or self._graph.root_vertex_goal.cost == float('inf'):\n            # Uniform random sample in grid boundaries:\n            while True:\n                sample_coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling ellipse parameters:\n        c_best = self._graph.root_vertex_goal.cost\n        c_min = self._get_distance(start, goal)\n        if c_best is None or c_best == float('inf'):\n            c_best = float('inf')\n        if c_min == 0:\n            # Start and goal are same position (corner case)\n            return start\n\n        # Sample inside prolate hyperspheroid (in 2D ellipse) around start and goal\n        while True:\n            # Draw random sample inside unit n-ball:\n            dim = grid.size.n_dim\n            sample_in_ball = self._sample_unit_n_ball(dim)\n            # Scale according to ellipse radii:\n            r1 = c_best / 2.0\n            r2 = (c_best**2 - c_min**2)**0.5 / 2.0 if c_best > c_min else 0.0\n\n            if dim == 2:\n                L = torch.eye(2)\n                # Rotate to align with start-goal vector:\n                sg_dir = (goal.to_tensor() - start.to_tensor())\n                sg_dir = sg_dir / torch.norm(sg_dir)\n                rot = torch.tensor([[sg_dir[0], -sg_dir[1]], [sg_dir[1], sg_dir[0]]])\n                L = rot @ torch.diag(torch.tensor([r1, r2]))\n            else:\n                # For general n-dimensions, use alignment rotation with SVD:\n                # Construct rotation matrix from vector unit direction\n                sg_dir = (goal.to_tensor() - start.to_tensor())\n                sg_dir = sg_dir / torch.norm(sg_dir)\n                # Complete orthonormal basis using SVD:\n                U, _, _ = torch.svd(sg_dir.unsqueeze(1))\n                L = U @ torch.diag(torch.tensor([r1] + [r2]*(dim-1)))\n\n            transformed = L @ sample_in_ball\n            center = (start.to_tensor() + goal.to_tensor()) / 2.0\n            sample_coords = transformed + center\n            sample_point = Point.from_tensor(sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _sample_unit_n_ball(self, dim: int) -> torch.Tensor:\n        \"\"\"\n        Uniformly sample from unit n-ball in R^dim\n        \"\"\"\n        vec = torch.randn(dim)\n        vec /= torch.norm(vec)\n        r = torch.rand(1).pow(1.0 / dim)\n        return vec * r\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(direction)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / norm\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        new_point = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_point)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Reconstruct path from goal to start along parents:\n        path: List[Vertex] = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n        # Path shortcut smoothing by removing unnecessary vertices along line of sight\n        path = self._shortcut_smooth(path)\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_smooth(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Attempt to shortcut path by removing intermediate vertices where straight \n        line between two vertices is collision free.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        new_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(new_path[-1].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        iterations = 20000\n        dim = grid.size.n_dim\n        lambda_rrt_star = 50.0\n        start_time = time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        goal_vertex.cost = float('inf')\n\n        for i in range(iterations):\n            elapsed = time() - start_time\n            if elapsed > self._elapsed_time_limit:\n                # Mark failure by setting goal cost to inf and return\n                goal_vertex.cost = float('inf')\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                self.key_frame()\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            is_valid = grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest.position, q_new.position))\n            if not is_valid:\n                self.key_frame()\n                continue\n\n            card_v = float(self._graph.size)\n            log_card_v = torch.log(torch.tensor(card_v)) if card_v > 1 else torch.tensor(0.0)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dim)), self._max_radius)\n\n            near_vertices = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._get_distance(q_nearest.position, q_new.position)\n\n            # Choose best parent with minimum cost and collision-free edge\n            for q_near in near_vertices:\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position))\n                cost = q_near.cost + self._get_distance(q_near.position, q_new.position)\n                if line_free and cost < c_min:\n                    q_min = q_near\n                    c_min = cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if cost improves their cost\n            for q_near in near_vertices:\n                if q_near == q_min:\n                    continue\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position))\n                cost_through_qnew = q_new.cost + self._get_distance(q_new.position, q_near.position)\n                if line_free and cost_through_qnew < q_near.cost:\n                    # Remove old edge, add new edge, update cost\n                    old_parents = list(q_near.parents)\n                    for old_parent in old_parents:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = cost_through_qnew\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if can connect to goal and update best cost if improved\n            dist_to_goal = self._get_distance(q_new.position, goal_vertex.position)\n            if dist_to_goal <= self._max_dist:\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position))\n                if line_free:\n                    goal_cost_candidate = q_new.cost + dist_to_goal\n                    if goal_cost_candidate < goal_vertex.cost:\n                        # Connect q_new to goal and update goal cost\n                        goal_vertex.cost = goal_cost_candidate\n                        self._graph.add_edge(q_new, goal_vertex)\n                        # Extract and smooth path\n                        self._extract_path(goal_vertex)\n                        return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This is an improved informed RRT* inspired algorithm with heuristic biasing and rewiring steps.\n\n    Algorithm Description:\n    - Uses an RRT* style incremental sampling and rewiring to improve path quality.\n    - Samples are biased by a heuristic Ellipsoidal informed sampling region once a solution is found, improving convergence.\n    - Uses a priority queue for vertices to rewire locally improving cost.\n    - Employs heuristic distance to goal (Euclidean) to guide sampling and vertex connection attempts.\n    - Early stopping when goal is reached and path smoothing by rewiring around each new vertex.\n    - Terminates and treats search as FAILED if exceeds 10 seconds.\n    \n    Expected improvements:\n    - Planning efficiency: Focused informed sampling and efficient rewiring reduce unnecessary exploration.\n    - Path quality: Rewiring optimizes cost of reaching vertices.\n    - Robustness & success rate: Uniform initial exploration plus heuristic bias improving coverage.\n    - Path smoothness and lengths: Rewiring and cost-based parent selection shorten and smooth paths.\n    - Reduced search time by timeout and early stopping upon goal reaching.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    \n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring edges\n        self._init_displays()\n        self._max_dist = 12.0               # max extension segment length\n        self._search_start_time = None\n        self._timeout_sec = 10.0            # max allowed planning time before FAIL\n        self._found_solution = False\n        self._best_goal_vertex: Optional[Vertex] = None\n        self._rewire_radius = 15.0          # radius to consider rewiring\n        \n    # Helper Functions #\n    # -----------------#\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Samples a random point in the grid.\n        If a solution found, sample inside an informed ellipsoidal region between start and goal to accelerate.\n        Else, uniform random sampling.\n        \"\"\"\n        grid_size = self._get_grid().size\n        start = self._graph.root_vertex_start.position\n        goal = self._graph.root_vertex_goal.position\n\n        if not self._found_solution:\n            # Uniform sampling over entire space\n            while True:\n                rand_pos = tuple( np.random.randint(0, grid_size[i]) for i in range(grid_size.n_dim) )\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Informed sampling biased to ellipsoidal workspace\n            # Ellipse axis along start-goal with radius determined by current best path cost\n            c_best = self._best_goal_vertex.cost\n            center = Point(*[ (start[i]+goal[i])/2 for i in range(start.n_dim)])\n            r1 = c_best/2\n            dist_start_goal = Map.get_distance(start, goal)\n            if r1 < dist_start_goal/2:\n                r1 = dist_start_goal/2\n            # Simple bounding box based on ellipse for discrete sampling - faster than proper sampling\n            min_bounds = []\n            max_bounds = []\n            for i in range(center.n_dim):\n                min_val = max(0, int(center[i] - r1))\n                max_val = min(grid_size[i]-1, int(center[i] + r1))\n                min_bounds.append(min_val)\n                max_bounds.append(max_val)\n\n            max_trials = 50\n            for _ in range(max_trials):\n                rand_coords = tuple(np.random.randint(min_bounds[i], max_bounds[i]+1) for i in range(center.n_dim))\n                sample = Point(*rand_coords)\n                if not self._get_grid().is_agent_valid_pos(sample):\n                    continue\n                # Check if inside ellipse: (x-c)^2 / a^2 + (y-c)^2 / b^2 + ... <= 1\n                dist_to_center = Map.get_distance(sample, center)\n                if dist_to_center <= r1:\n                    return sample\n            # Fallback uniform sampling if all failed\n            while True:\n                rand_pos = tuple( np.random.randint(0, grid_size[i]) for i in range(grid_size.n_dim) )\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_nearest_vertex(self, vertices: List[Vertex], sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(vertices, sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        \"\"\"\n        Generate a new vertex in the direction from q_near to q_sample \n        limited by max_dist and validity check for collision.\n        Returns None if movement not valid.\n        \"\"\"\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist == 0:\n            return None\n        if dist > max_dist:\n            dir_vec = dir_vec / dist * max_dist\n        new_pos_tensor = q_near.position.to_tensor() + dir_vec\n        new_pos = Point.from_tensor(new_pos_tensor)\n        if new_pos == q_near.position:\n            return None\n        line_seq = self._get_grid().get_line_sequence(q_near.position, new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n        return Vertex(new_pos)\n\n    def _get_neighbors(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"\n        Returns vertices within radius of q_new.position\n        \"\"\"\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Vertex:\n        \"\"\"\n        Choose the best parent for q_new from neighbors minimizing cost + edge cost.\n        Assumes all edges valid.\n        \"\"\"\n        min_cost = float('inf')\n        best_parent = None\n        for q_near in neighbors:\n            edge_cost = self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            cost = q_near.cost + edge_cost\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = q_near\n        if best_parent is not None:\n            q_new.cost = min_cost\n        else:\n            q_new.cost = float('inf')\n        return best_parent\n\n    def _rewire(self, neighbors: List[Vertex], q_new: Vertex) -> None:\n        \"\"\"\n        Tries to rewire neighbors through q_new if it reduces cost and edge valid.\n        \"\"\"\n        for q_near in neighbors:\n            edge_cost = self._get_grid().get_movement_cost(q_new.position, q_near.position)\n            if q_new.cost + edge_cost < q_near.cost:\n                line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove old parents edges to q_near and add new edge from q_new to q_near\n                    for parent in list(q_near.parents):\n                        self._graph.remove_edge(parent, q_near)\n                    self._graph.add_edge(q_new, q_near)\n                    q_near.cost = q_new.cost + edge_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        \"\"\"\n        Extracts and animates the path from start to goal by following parent pointers.\n        \"\"\"\n        path: List[Vertex] = [goal_vertex]\n        current = goal_vertex\n\n        while len(current.parents) != 0:\n            # Select parent with minimum cost\n            min_parent = None\n            min_cost = float('inf')\n            for p in current.parents:\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_parent = p\n            if min_parent is None:\n                break\n            path.append(min_parent)\n            current = min_parent\n\n        path.reverse()\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        self._search_start_time = time.time()\n        iterations = 15000\n\n        root_start = self._graph.root_vertex_start\n        root_goal = self._graph.root_vertex_goal\n        root_start.cost = 0.0\n        root_goal.cost = float('inf')  # Not connected initially\n\n        for i in range(iterations):\n            if (time.time() - self._search_start_time) > self._timeout_sec:\n                # Treat as failed search, no path found in time\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = self._get_nearest_vertex(self._graph.root_vertices, q_sample)\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_dist)\n            if q_new is None:\n                self.key_frame()\n                continue\n\n            neighbors = self._get_neighbors(q_new, self._rewire_radius)\n\n            # Choose best parent among neighbors (including q_near)\n            potential_parents = neighbors + [q_near]\n            best_parent = self._choose_parent(potential_parents, q_new)\n            if best_parent is None:\n                self.key_frame()\n                continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors through q_new if cheaper path found\n            self._rewire(neighbors, q_new)\n\n            # If q_new close enough to goal and path valid, connect to goal\n            dist_to_goal = Map.get_distance(q_new.position, root_goal.position)\n            if dist_to_goal <= self._max_dist:\n                line_seq_to_goal = self._get_grid().get_line_sequence(q_new.position, root_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_to_goal):\n                    # Add edge from q_new to goal\n                    root_goal.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, root_goal.position)\n                    self._graph.add_edge(q_new, root_goal)\n                    self._found_solution = True\n                    self._best_goal_vertex = root_goal\n                    self._extract_path(root_goal)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This is an improved bidirectional informed RRT* inspired sample-based path planner\n      designed to enhance planning efficiency, path quality, robustness, path smoothness,\n      and success rate while reducing search time and path length.\n\n      Key features:\n      - Bidirectional trees (start and goal)\n      - Informed sampling focused around an ellipsoidal subset for path improvement\n      - Asymptotic optimality with rewiring to improve path quality dynamically\n      - Early termination when goal reachable\n      - Smoothness promotion by limiting step length and rewiring better parents\n      - Time-limited search (10 seconds max) to avoid long runtimes",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _start_time: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 12.0\n        self._iterations = 15000\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self, c_best: Optional[float], c_min: float, x_center: Point, C: List[List[float]]) -> Point:\n        \"\"\"Generate informed sample within an ellipsoid if c_best < inf, otherwise uniform random.\"\"\"\n        dim = self._get_grid().size.n_dim\n        if c_best == math.inf or c_best == 0 or c_best is None:\n            while True:\n                sample_coords = [self._services.get_random().randint(0, self._get_grid().size[i]-1) for i in range(dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling inside ellipsoid defined by c_best and transformation C\n        for _ in range(100):  # limited retries\n            # Sample unit n-ball\n            while True:\n                x_ball = [self._services.get_random().normalvariate(0, 1) for _ in range(dim)]\n                s = sum(v*v for v in x_ball)\n                if s > 0:\n                    x_ball = [v / math.sqrt(s) for v in x_ball]\n                    break\n            r = self._services.get_random().random() ** (1.0/dim)\n            x_ball = [r*v for v in x_ball]\n\n            # Scale by axis lengths\n            L = [c_best/2.0] + [math.sqrt(c_best*c_best - c_min*c_min)/2.0]*(dim-1)\n            x_scaled = [L[i] * x_ball[i] for i in range(dim)]\n\n            # Rotate and translate back to center\n            x_rotated = [sum(C[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim)]\n            sample_coords = [int(round(x_center[i] + x_rotated[i])) for i in range(dim)]\n            sample = Point(*sample_coords)\n\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n        # fallback uniform sample\n        while True:\n            sample_coords = [self._services.get_random().randint(0, self._get_grid().size[i]-1) for i in range(dim)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([root_vertex], q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        else:\n            dir_normalized = vec / dist\n            new_pos = q_near.position.to_tensor() + max_dist * dir_normalized\n            q_new = Point.from_tensor(new_pos)\n            return Vertex(q_new)\n\n    def _get_vertices_near(self, root_vertex: Vertex, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([root_vertex], q_new.position, radius)\n\n    def _rewire(self, root_vertex: Vertex, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # Try to improve cost to q_new by rewiring from neighbors\n        best_cost = q_new.cost if hasattr(q_new, 'cost') else math.inf\n        best_parent = None\n        for neighbor in neighbors:\n            if neighbor is q_new:\n                continue\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position)):\n                cost = neighbor.cost if hasattr(neighbor, 'cost') else 0.0\n                cost += self._get_grid().get_movement_cost(neighbor.position, q_new.position)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_parent = neighbor\n\n        if best_parent is not None:\n            # Reassign parent and cost\n            for p in list(q_new.parents):\n                self._graph.remove_edge(p, q_new)\n\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Try to rewire neighbors for which q_new offers better cost\n            for neighbor in neighbors:\n                if neighbor is q_new or neighbor is best_parent:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                    neighbor_cost = neighbor.cost if hasattr(neighbor, 'cost') else math.inf\n                    new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n                    if new_cost < neighbor_cost:\n                        for p in list(neighbor.parents):\n                            self._graph.remove_edge(p, neighbor)\n                        neighbor.cost = new_cost\n                        self._graph.add_edge(q_new, neighbor)\n\n    def _path_to_start(self, vertex: Vertex) -> List[Vertex]:\n        path = []\n        curr = vertex\n        while curr is not None:\n            path.append(curr)\n            if len(curr.parents) == 0:\n                break\n            # Pick the parent with minimal cost (or first if cost undefined)\n            costs_and_parents = [(p.cost if hasattr(p, 'cost') else 0, p) for p in curr.parents]\n            costs_and_parents.sort(key=lambda x: x[0])\n            curr = costs_and_parents[0][1]\n        path.reverse()\n        return path\n\n    def _extract_path(self, meet_vertex_start: Vertex, meet_vertex_goal: Vertex) -> None:\n        path_start = self._path_to_start(meet_vertex_start)\n        path_goal = self._path_to_start(meet_vertex_goal)\n        path_goal.reverse()  # from meeting vertex to goal\n        # Merge paths excluding duplicated meeting vertex\n        full_path = path_start + path_goal[1:]\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _build_rotation_matrix(self, x_center: List[float], goal_center: List[float]) -> List[List[float]]:\n        # Create orthonormal basis with first axis in direction (start->goal)\n        dim = len(x_center)\n        dir_vector = [goal_center[i] - x_center[i] for i in range(dim)]\n        dist = math.sqrt(sum(d * d for d in dir_vector))\n        if dist == 0:\n            return [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]  # Identity matrix\n\n        e1 = [d / dist for d in dir_vector]\n        U = [e1]  # Base first vector\n\n        # Use Gram-Schmidt to generate remaining orthonormal basis vectors\n        for i in range(1, dim):\n            base_vector = [0]*dim\n            base_vector[i] = 1\n            proj = sum(base_vector[j]*e1[j] for j in range(dim))\n            orthogonal_vec = [base_vector[j]-proj*e1[j] for j in range(dim)]\n            norm_orth = math.sqrt(sum(x*x for x in orthogonal_vec))\n            if norm_orth < 1e-10:\n                # fallback vector orthogonal to e1\n                orthogonal_vec = [0]*dim\n                orthogonal_vec[(i)%dim] = 1\n                norm_orth = 1\n            orthonormal_vec = [x / norm_orth for x in orthogonal_vec]\n            U.append(orthonormal_vec)\n        return [list(col) for col in zip(*U)]  # transpose for rotation matrix\n\n    # Main function to find path #\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        self._start_time = start_time\n\n        dim = self._get_grid().size.n_dim\n        start_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n\n        # Initialize costs\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = 0.0\n\n        c_min = self._get_grid().get_distance(start_pos, goal_pos)  # minimum possible distance\n        c_best = math.inf\n\n        # Ellipsoid center and rotation matrix for informed sampling\n        x_center = [(start_pos[i] + goal_pos[i]) / 2.0 for i in range(dim)]\n        C = self._build_rotation_matrix(list(start_pos), list(goal_pos))\n\n        # Add roots to vertex lists\n        vertices_start = [self._graph.root_vertex_start]\n        vertices_goal = [self._graph.root_vertex_goal]\n\n        # Internal helper to grow tree towards q_target\n        def extend(root_vertex: Vertex, q_target: Point) -> Tuple[str, Optional[Vertex]]:\n            q_near = self._get_nearest_vertex(root_vertex, q_target)\n            q_new = self._get_new_vertex(q_near, q_target, self._max_dist)\n\n            # Reject if invalid line crossing obstacles\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                return 'trapped', None\n\n            # Compute cost to new vertex\n            cost_near = q_near.cost if hasattr(q_near, 'cost') else 0.0\n            move_cost = self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = cost_near + move_cost\n\n            # Find neighbors for rewiring\n            radius = min(self._max_dist * 2.0, self._max_dist*((math.log(len(vertices_start)+len(vertices_goal)+1)/ (len(vertices_start)+len(vertices_goal)+1))**(1/dim)))\n            near_vertices = self._get_vertices_near(root_vertex, q_new, radius)\n\n            # Pick best parent for q_new among near vertices to reduce cost\n            best_cost = q_new.cost\n            best_parent = q_near\n            for near_v in near_vertices:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(near_v.position, q_new.position)):\n                    cost = near_v.cost + self._get_grid().get_movement_cost(near_v.position, q_new.position) if hasattr(near_v, 'cost') else math.inf\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_parent = near_v\n            q_new.cost = best_cost\n\n            # Add q_new and connect best parent\n            self._graph.add_edge(best_parent, q_new)\n            vertices = vertices_start if root_vertex is self._graph.root_vertex_start else vertices_goal\n            vertices.append(q_new)\n\n            # Rewire neighbors to q_new if better\n            self._rewire(root_vertex, q_new, near_vertices)\n\n            if q_new.position == q_target:\n                return 'reached', q_new\n            else:\n                return 'advanced', q_new\n\n        # Bidirectional tree extension alternates between start and goal trees\n        for iter_count in range(self._iterations):\n            if time.time() - start_time > 10.0:\n                # Fail early on timeout\n                return\n\n            # Determine informed sampling radius (c_best)\n            if c_best == math.inf:\n                sample_point = self._get_random_sample(None, c_min, x_center, C)\n            else:\n                sample_point = self._get_random_sample(c_best, c_min, x_center, C)\n\n            # Alternate trees: even iter - start, odd iter - goal\n            tree_selector = iter_count % 2\n            tree_root = self._graph.root_vertex_start if tree_selector == 0 else self._graph.root_vertex_goal\n            other_tree_root = self._graph.root_vertex_goal if tree_selector == 0 else self._graph.root_vertex_start\n            tree_vertices = vertices_start if tree_selector == 0 else vertices_goal\n            other_tree_vertices = vertices_goal if tree_selector == 0 else vertices_start\n\n            outcome, q_new = extend(tree_root, sample_point)\n            if outcome == 'trapped' or q_new is None:\n                self.key_frame()\n                continue\n\n            # Try to connect the opposite tree towards q_new\n            outcome_connect, q_new_connect = 'advanced', None\n            q_target = q_new.position\n            while outcome_connect == 'advanced':\n                outcome_connect, q_new_connect = extend(other_tree_root, q_target)\n                if outcome_connect == 'reached':\n                    # Path found: extract\n                    v_from_tree = q_new if tree_selector == 0 else q_new_connect\n                    v_from_other = q_new_connect if tree_selector == 0 else q_new\n                    c_best = min(c_best, v_from_tree.cost + v_from_other.cost)\n\n                    self._extract_path(v_from_tree, v_from_other)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an improved bidirectional hybrid bidirectional Smooth Informed RRT* planner\n    that combines advantages of heuristic-guided informed sampling, bidirectional exploration,\n    and adaptive dynamic pruning for efficiency gains.\n\n    Key Features:\n    - Bidirectional trees grown simultaneously from start and goal.\n    - Uses an adaptive informed sampling ellipsoid to focus search near best known path.\n    - Dynamic pruning of vertices outside the adaptive radius to maintain graph sparsity and efficiency.\n    - Smooth path promotion by limiting max step size and rewiring neighbors with cost improvements.\n    - Time-bounded search with 10 seconds max allowed runtime.\n    - Early path extraction on connection between trees.\n    - Uses auxiliary heuristics combining Euclidean and obstacle-penalty estimated cost.\n    - Robust connectivity attempts between the two trees to improve success rate.\n    - Incorporates a cost-to-go heuristic approximation to guide rewiring decisions.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 15.0\n        self._iterations = 12000\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n        import random\n        self._random_generator = getattr(self._services, 'random', random)\n        self._prune_threshold_factor = 1.5\n\n    def _get_random_informed_sample(self, c_best, c_min, x_center, C):\n        dim = self._get_grid().size.n_dim\n        random_generator = self._random_generator\n\n        if c_best == float('inf') or c_best == 0 or c_best is None:\n            # Uniform random sampling\n            while True:\n                sample_coords = [random_generator.randint(0, self._get_grid().size[i]-1) for i in range(dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Sample inside the prolate hyperspheroid (ellipsoid) for informed sampling:\n        for _ in range(100):\n            # Sample a random point in unit n-ball\n            while True:\n                x_ball = [random_generator.gauss(0, 1) for _ in range(dim)]\n                norm_sq = sum(x*x for x in x_ball)\n                if norm_sq > 0:\n                    norm = norm_sq ** 0.5\n                    x_ball = [v/norm for v in x_ball]\n                    break\n            r = random_generator.random() ** (1.0 / dim)\n            x_ball = [r * v for v in x_ball]\n\n            # Ellipsoid axis lengths\n            L = [c_best / 2.0] + [((c_best**2 - c_min**2) ** 0.5) / 2.0] * (dim - 1)\n            x_scaled = [L[i]*x_ball[i] for i in range(dim)]\n\n            # Rotate and translate back to original space\n            x_rotated = [sum(C[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim)]\n            sample_coords = [int(round(x_center[i] + x_rotated[i])) for i in range(dim)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n        # Fallback uniform sampling\n        while True:\n            sample_coords = [random_generator.randint(0, self._get_grid().size[i]-1) for i in range(dim)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([root_vertex], q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        else:\n            dir_normalized = vec / dist\n            new_pos = q_near.position.to_tensor() + max_dist * dir_normalized\n            q_new = Point.from_tensor(new_pos)\n            return Vertex(q_new)\n\n    def _get_nearby_vertices(self, root_vertices: List[Vertex], q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(root_vertices, q_new.position, radius)\n\n    def _rewire(self, root_vertices: List[Vertex], q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # Select better parent for q_new to minimize cost\n        best_cost = getattr(q_new, \"cost\", float('inf'))\n        best_parent = None\n\n        for neighbor in neighbors:\n            if neighbor is q_new:\n                continue\n            # Check connectivity and collision\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position)):\n                cost_to_neighbor = getattr(neighbor, \"cost\", 0.0)\n                cost_to_new = cost_to_neighbor + self._get_grid().get_movement_cost(neighbor.position, q_new.position)\n                if cost_to_new < best_cost:\n                    best_cost = cost_to_new\n                    best_parent = neighbor\n\n        if best_parent is not None:\n            # Remove old parents edges\n            for p in list(q_new.parents):\n                self._graph.remove_edge(p, q_new)\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Try to rewire neighbors via q_new for cost improvement\n            for neighbor in neighbors:\n                if neighbor is q_new or neighbor is best_parent:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                    current_cost = getattr(neighbor, \"cost\", float('inf'))\n                    new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n                    if new_cost < current_cost:\n                        for p in list(neighbor.parents):\n                            self._graph.remove_edge(p, neighbor)\n                        neighbor.cost = new_cost\n                        self._graph.add_edge(q_new, neighbor)\n\n    def _build_rotation_matrix(self, start: List[float], goal: List[float]) -> List[List[float]]:\n        # Creates orthonormal basis for ellipsoid rotation from start->goal vector\n        dim = len(start)\n        dir_vec = [goal[i] - start[i] for i in range(dim)]\n        dist = sum(d*d for d in dir_vec) ** 0.5\n        if dist == 0:\n            # Identity if zero distance\n            return [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n        e1 = [d / dist for d in dir_vec]\n        basis = [e1]\n\n        for i in range(1, dim):\n            v = [0]*dim\n            v[i] = 1\n            proj = sum(v[j]*e1[j] for j in range(dim))\n            orth_vec = [v[j] - proj*e1[j] for j in range(dim)]\n            norm_orth = sum(x*x for x in orth_vec) ** 0.5\n            if norm_orth < 1e-10:\n                # fallback orthogonal basis vector\n                orth_vec = [0]*dim\n                orth_vec[(i)%dim] = 1\n                norm_orth = 1\n            basis.append([x / norm_orth for x in orth_vec])\n\n        # Transpose matrix for rotation\n        rotation_matrix = [[basis[j][i] for j in range(dim)] for i in range(dim)]\n        return rotation_matrix\n\n    def _path_to_root(self, vertex: Vertex) -> List[Vertex]:\n        path = []\n        current = vertex\n        while current is not None:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            # Choose parent with lowest cost\n            parent_costs = [(p.cost if hasattr(p, \"cost\") else float('inf'), p) for p in current.parents]\n            parent_costs.sort(key=lambda x: x[0])\n            current = parent_costs[0][1]\n        path.reverse()\n        return path\n\n    def _extract_path(self, v_start: Vertex, v_goal: Vertex) -> None:\n        # Merge path from start root to meeting vertex and from goal root to meeting vertex (in reverse)\n        path_from_start = self._path_to_root(v_start)\n        path_from_goal = self._path_to_root(v_goal)\n        path_from_goal.reverse()\n        full_path = path_from_start + path_from_goal[1:]  # avoid duplicate meeting vertex\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _prune_graph(self, c_best: float, root_vertices_start: List[Vertex], root_vertices_goal: List[Vertex], c_min: float) -> None:\n        # Remove any vertices with cost-to-come + heuristic-to-go > prune threshold * c_best\n        prune_threshold = c_best * self._prune_threshold_factor\n        agent_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n\n        def heuristic_to_goal(pos: Point) -> float:\n            # Simple admissible heuristic: Euclidean distance to goal\n            return self._get_grid().get_distance(pos, goal_pos)\n\n        def should_prune(vertex: Vertex):\n            cost_come = getattr(vertex, \"cost\", float('inf'))\n            if cost_come == float('inf'):\n                return True\n            h_to_go = heuristic_to_goal(vertex.position)\n            return (cost_come + h_to_go) > prune_threshold\n\n        # Prune start tree vertices\n        vertices_to_remove = [v for v in root_vertices_start if should_prune(v) and v not in [self._graph.root_vertex_start]]\n        for v in vertices_to_remove:\n            # Remove edges and vertex from graph root list\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in root_vertices_start:\n                root_vertices_start.remove(v)\n\n        # Prune goal tree vertices similarly\n        vertices_to_remove_goal = [v for v in root_vertices_goal if should_prune(v) and v not in [self._graph.root_vertex_goal]]\n        for v in vertices_to_remove_goal:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in root_vertices_goal:\n                root_vertices_goal.remove(v)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        dim = self._get_grid().size.n_dim\n        start_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = 0.0\n\n        c_min = self._get_grid().get_distance(start_pos, goal_pos)  # min achievable cost\n        c_best = float('inf')\n\n        x_center = [(start_pos[i] + goal_pos[i]) / 2.0 for i in range(dim)]\n        C = self._build_rotation_matrix(list(start_pos), list(goal_pos))\n\n        vertices_start = [self._graph.root_vertex_start]\n        vertices_goal = [self._graph.root_vertex_goal]\n\n        def extend_tree(root_vertex: Vertex, q_target: Point, vertices_list: List[Vertex]) -> (str, Vertex):\n            q_near = self._get_nearest_vertex(root_vertex, q_target)\n            q_new = self._get_new_vertex(q_near, q_target, self._max_dist)\n\n            # Collision check line from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                return 'trapped', None\n\n            cost_to_near = getattr(q_near, \"cost\", 0.0)\n            incremental_cost = self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = cost_to_near + incremental_cost\n\n            # Determine radius for rewiring\n            card_v = max(len(vertices_start) + len(vertices_goal), 1)\n            radius = min(self._max_dist * 2.0,\n                         self._max_dist * ((math.log(card_v) / card_v) ** (1 / dim)))\n\n            near_vertices = self._get_nearby_vertices([root_vertex], q_new, radius)\n\n            # Pick best parent to reduce cost\n            best_cost = q_new.cost\n            best_parent = q_near\n            for near_v in near_vertices:\n                if near_v is q_new:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(near_v.position, q_new.position)):\n                    near_cost = getattr(near_v, \"cost\", float('inf'))\n                    new_cost = near_cost + self._get_grid().get_movement_cost(near_v.position, q_new.position)\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_parent = near_v\n            q_new.cost = best_cost\n\n            self._graph.add_edge(best_parent, q_new)\n            vertices_list.append(q_new)\n\n            # Rewire neighbors for potential improvements\n            self._rewire([root_vertex], q_new, near_vertices)\n\n            if q_new.position == q_target:\n                return 'reached', q_new\n            else:\n                return 'advanced', q_new\n\n        for iteration in range(self._iterations):\n            if time.time() - start_time > 10.0:\n                # Fail and terminate search after 10 seconds\n                return\n\n            sample_point = self._get_random_informed_sample(c_best, c_min, x_center, C)\n            # Alternate trees\n            tree_selector = iteration % 2\n            if tree_selector == 0:\n                root_vertex = self._graph.root_vertex_start\n                other_root_vertex = self._graph.root_vertex_goal\n                vertices_this = vertices_start\n                vertices_other = vertices_goal\n            else:\n                root_vertex = self._graph.root_vertex_goal\n                other_root_vertex = self._graph.root_vertex_start\n                vertices_this = vertices_goal\n                vertices_other = vertices_start\n\n            status, q_new = extend_tree(root_vertex, sample_point, vertices_this)\n            if status == 'trapped' or not q_new:\n                self.key_frame()\n                continue\n\n            # Try connecting the other tree toward q_new repeatedly\n            connection_status = 'advanced'\n            q_other_new = None\n            q_target_pos = q_new.position\n            attempts = 0\n            while connection_status == 'advanced' and attempts < 5:\n                connection_status, q_other_new = extend_tree(other_root_vertex, q_target_pos, vertices_other)\n                if connection_status == 'reached':\n                    # Check cost and update c_best\n                    cost_sum = q_new.cost + q_other_new.cost\n                    if cost_sum < c_best:\n                        c_best = cost_sum\n                        # Update ellipsoid center and rotation matrix for refined informed sampling\n                        x_center = [(q_new.position[i] + q_other_new.position[i]) / 2.0 for i in range(dim)]\n                        C = self._build_rotation_matrix(list(q_new.position), list(q_other_new.position))\n\n                    self._extract_path(q_new if tree_selector == 0 else q_other_new,\n                                       q_other_new if tree_selector == 0 else q_new)\n                    return\n                elif connection_status == 'advanced' and q_other_new is not None:\n                    q_target_pos = q_other_new.position\n                    attempts += 1\n                else:\n                    break\n\n            # Prune graph periodically every 200 iterations to maintain efficiency\n            if iteration > 0 and iteration % 200 == 0 and c_best != float('inf'):\n                self._prune_graph(c_best, vertices_start, vertices_goal, c_min)\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "PathPlanning is an improved sampling-based algorithm combining ideas from RRT*, informed sampling,\n    and lazy collision checking with shortcut smoothing for better efficiency, path quality, and robustness.\n    It incrementally builds a tree from start to goal, biased by an ellipsoidal informed sampling region once\n    a feasible path is found, reducing unnecessary exploration. Lazy collision checking postpones expensive\n    validations until necessary, improving speed. After reaching the goal, a path smoothing phase shortcutting\n    unnecessary vertices is executed for improved path smoothness and shorter path length.\n    The search stops and fails gracefully if exceeding 10 seconds runtime.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _max_radius: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _start_time: float\n    _samples_taken: int\n    _found_path: bool\n    _best_goal_vertex: Optional[Vertex]\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        self._max_dist = 12.0\n        self._max_radius = 40.0\n        self._lambda_rrt_star = 40.0\n        self._dimension = self._get_grid().size.n_dim\n\n        self._start_time = 0\n        self._samples_taken = 0\n        self._found_path = False\n        self._best_goal_vertex = None\n\n        self._init_displays()\n\n    def _get_random_sample(self, informed_ball: Optional[tuple] = None) -> Point:\n        \"\"\"\n        Samples either uniformly from the entire workspace or \n        inside an ellipsoidal informed subset if informed_ball is specified.\n        informed_ball = (center: Point, c_best: float, c_min: float)\n        \"\"\"\n        grid_size = self._get_grid().size\n        if informed_ball is None:\n            # Uniform random sampling valid for whole space\n            while True:\n                rand_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(grid_size.n_dim)]\n                sample = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Sample inside informed ellipsoid between start and goal\n            c_best = informed_ball[1]\n            c_min = informed_ball[2]\n            center = informed_ball[0]\n            \n            # Major axis length: c_best\n            # Minor axis lengths: sqrt(c_best^2 - c_min^2)\n            # For simplicity, handle 2D only ellipsoid sampling (works well in 2D):\n            # If higher dims exist, revert to uniform sampling\n            \n            if grid_size.n_dim != 2:\n                # fallback to uniform if not 2D\n                return self._get_random_sample(None)\n            \n            success = False\n            sample = None\n            \n            for _ in range(200):  # limit to attempts\n                rx = torch.FloatTensor(1).uniform_(-1,1).item()\n                ry = torch.FloatTensor(1).uniform_(-1,1).item()\n                norm = (rx**2 + ry**2)**0.5\n                if norm > 1e-5:\n                    break\n            if norm < 1e-5:\n                # fallback to uniform\n                return self._get_random_sample(None)\n            rx /= norm\n            ry /= norm\n\n            # Sample radius uniformly between 0 and 1, cube root for volume preservation\n            r = torch.FloatTensor(1).uniform_(0,1).item() ** (1/2)\n            a1 = c_best / 2\n            a2 = (c_best**2 - c_min**2)**0.5 / 2\n\n            x = r * a1 * rx\n            y = r * a2 * ry\n\n            # Rotation: from the vector start -> goal angle\n            start = self._graph.root_vertex_start.position\n            goal = self._graph.root_vertex_goal.position\n            delta = torch.tensor([goal.x - start.x, goal.y - start.y])\n            angle = torch.atan2(delta[1], delta[0]).item()\n\n            cos_ang = torch.cos(torch.tensor(angle))\n            sin_ang = torch.sin(torch.tensor(angle))\n            rot_x = cos_ang * x - sin_ang * y\n            rot_y = sin_ang * x + cos_ang * y\n\n            sample_x = int(round(center.x + rot_x))\n            sample_y = int(round(center.y + rot_y))\n\n            # Clamp sample inside grid\n            sample_x = max(0, min(sample_x, grid_size[0] - 1))\n            sample_y = max(0, min(sample_y, grid_size[1] - 1))\n\n            sample = Point(sample_x, sample_y)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            else:\n                # fallback uniform sampling if invalid\n                return self._get_random_sample(None)\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Optional[Vertex]:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec)\n        if length < 1e-6:\n            return None\n        if length <= self._max_dist:\n            new_vertex_pos = q_sample\n        else:\n            dir_normalized = dir_vec / length\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_vertex_pos = Point.from_tensor(new_pos_tensor)\n\n        if not self._get_grid().is_agent_valid_pos(new_vertex_pos):\n            return None\n\n        return Vertex(new_vertex_pos)\n\n    def _line_collision_free_lazy(self, frm: Point, to: Point) -> bool:\n        \"\"\"\n        Lazy collision check postpones detailed checking when possible.\n        Here, fast line validity check with early stop at first obstacle.\n        \"\"\"\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        # Instead of fully calling is_valid_line_sequence (which might be thorough),\n        # iterate and check for obstacles directly, early stop on collision\n        for pt in line_seq:\n            if not self._get_grid().is_agent_valid_pos(pt):\n                return False\n        return True\n\n    def _rewire(self, q_new: Vertex, Q_near: List[Vertex]) -> None:\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            if dist > self._max_dist:\n                continue\n            new_cost = q_new.cost + dist\n            if new_cost < q_near.cost:\n                if self._line_collision_free_lazy(q_new.position, q_near.position):\n                    # Remove old parent edge\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    # Add new edge\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Vertex]:\n        path = [goal_vertex]\n        while len(path[-1].parents) > 0:\n            # choose parent with lowest cost (usually one parent in tree)\n            min_parent = None\n            min_cost = float('inf')\n            for parent in path[-1].parents:\n                if parent.cost is not None and parent.cost < min_cost:\n                    min_cost = parent.cost\n                    min_parent = parent\n            if min_parent is None:\n                break\n            path.append(min_parent)\n        path.reverse()\n        return path\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Path shortcutting: tries to replace longer path segments with direct edges,\n        removing intermediate unnecessary vertices.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            # Move backward to find furthest reachable vertex without collision\n            while j > i + 1:\n                if self._line_collision_free_lazy(path[i].position, path[j].position):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.perf_counter()\n        max_time_sec = 10.0\n\n        start: Vertex = self._graph.root_vertex_start\n        goal: Vertex = self._graph.root_vertex_goal\n\n        start.cost = 0.0\n        best_cost = float('inf')\n        best_goal_vertex: Optional[Vertex] = None\n\n        max_iterations = 15000\n        self._found_path = False\n\n        for iteration in range(max_iterations):\n            if time.perf_counter() - self._start_time > max_time_sec:\n                # Fail safe: terminate search and fail\n                break\n\n            # After path found, use informed sampling in ellipse around start and goal\n            if self._found_path and best_goal_vertex and best_cost < float('inf'):\n                c_min = torch.norm(start.position.to_tensor() - goal.position.to_tensor()).item()\n                c_best = best_cost\n                center = Point((start.position.x + goal.position.x)/2, (start.position.y + goal.position.y)/2)\n                q_sample = self._get_random_sample(informed_ball=(center, c_best, c_min))\n            else:\n                q_sample = self._get_random_sample()\n\n            q_near = self._get_nearest_vertex(q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            if q_new is None:\n                continue\n\n            # Lazy collision checking line from q_near to q_new\n            if not self._line_collision_free_lazy(q_near.position, q_new.position):\n                continue\n\n            cost_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = cost_to_new\n\n            # Nearby vertices for rewiring\n            card_V = max(1, self._graph.size)\n            log_card_V = torch.log(torch.tensor(float(card_V) + 1e-8))\n            radius = min(self._lambda_rrt_star * ((log_card_V / card_V) ** (1.0 / self._dimension)), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with minimum cost + collision-free connection\n            q_min = q_near\n            c_min_vertex = q_near.cost\n            for q_near_candidate in Q_near:\n                if q_near_candidate == q_new:\n                    continue\n                dist = torch.norm(q_near_candidate.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist > self._max_dist:\n                    continue\n                cost_candidate = q_near_candidate.cost + dist\n                if cost_candidate < c_min_vertex:\n                    if self._line_collision_free_lazy(q_near_candidate.position, q_new.position):\n                        q_min = q_near_candidate\n                        c_min_vertex = cost_candidate\n\n            q_new.cost = c_min_vertex\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire the tree around q_new\n            self._rewire(q_new, Q_near)\n\n            # Check if q_new reached goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update best solution if better\n                dist_to_goal = torch.norm(q_new.position.to_tensor() - goal.position.to_tensor()).item()\n                total_cost = q_new.cost + dist_to_goal\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_goal_vertex = q_new\n                    self._found_path = True\n\n            self.key_frame()\n\n        # If found path, extract and smooth, then move agent on path\n        if self._found_path and best_goal_vertex is not None:\n            path_vertices = self._extract_path(best_goal_vertex)\n            path_vertices = self._smooth_path(path_vertices)\n            for vertex in path_vertices:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # Mark failure by raising or not moving - here do nothing, implicit fail\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an advanced sample-based planner combining adaptive hybrid sampling,\n    dynamic radius graph construction, and anytime path optimization.\n    It integrates:\n    - Hybrid sampling: mixes uniform and obstacle-informed guided samples (using obstacle boundaries)\n      to improve exploration efficiency and obstacle avoidance.\n    - Dynamic neighbor radius based on sampling density and iteration count for adaptive rewiring.\n    - Anytime incremental search: progressively refines path quality by rewiring and smoothing during planning.\n    - Lazy collision checking combined with incremental path validation for speed.\n    - Early termination if no improvement after some iterations or 10 seconds limit.\n    This approach improves path quality, success rate, and reduces planning time, while maintaining robustness and smooth paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        # Parameters (tunable)\n        self._max_dist = 10.0\n        self._max_radius = 35.0\n        self._lambda_rrt_star = 40.0\n        self._dimension = self._get_grid().size.n_dim\n\n        # For hybrid sampling\n        self._obstacle_boundaries = self._compute_obstacle_boundaries()\n\n        self._start_time = 0\n        self._max_time_sec = 10.0\n        self._samples_taken = 0\n\n        self._found_path = False\n        self._best_goal_vertex = None\n        self._best_cost = float('inf')\n\n        self._improvement_iter = 0  # Counts iterations without improvement for early stop\n        self._max_no_improve_iter = 300  # After these, terminate search early\n\n        self._init_displays()\n\n    def _compute_obstacle_boundaries(self) -> List[Point]:\n        \"\"\"\n        Compute boundary points of all obstacles to inform hybrid sampling.\n        Returns a combined list of obstacle boundary points.\n        \"\"\"\n        boundaries = []\n        visited = set()\n        for obs in self._get_grid().obstacles:\n            bound = self._get_grid().get_obstacle_bound(obs.position, visited)\n            boundaries.extend(bound)\n            visited.update(bound)\n        return boundaries\n\n    def _sample_from_obstacle_boundaries(self) -> Point:\n        \"\"\"\n        Sample near obstacle boundaries with Gaussian noise.\n        This encourages samples close but not inside obstacles.\n        \"\"\"\n        import random\n        import torch\n\n        if not self._obstacle_boundaries:\n            return self._get_random_sample_uniform()\n\n        # Choose random boundary point\n        base_pt = random.choice(self._obstacle_boundaries)\n\n        # Add small Gaussian offset to avoid exact obstacles and promote clearance\n        offset_scale = 3.0  # tunable\n        noise = []\n        for i in range(self._dimension):\n            noise.append(torch.normal(mean=0.0, std=offset_scale).item())\n        new_coords = []\n        grid_size = self._get_grid().size\n        for i in range(self._dimension):\n            c = base_pt[i] + noise[i]\n            c = max(0, min(c, grid_size[i] - 1))\n            new_coords.append(int(round(c)))\n\n        new_point = Point(*new_coords)\n        if self._get_grid().is_agent_valid_pos(new_point):\n            return new_point\n        else:\n            # Fallback uniform sample\n            return self._get_random_sample_uniform()\n\n    def _get_random_sample_uniform(self) -> Point:\n        \"\"\"Uniform random sample anywhere valid in workspace.\"\"\"\n        grid_size = self._get_grid().size\n        import torch\n        while True:\n            coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(self._dimension)]\n            p = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(p):\n                return p\n\n    def _get_hybrid_sample(self, p_obstacle_prob=0.3) -> Point:\n        \"\"\"\n        Hybrid sample: with probability p_obstacle_prob sample near obstacle boundaries,\n        else uniform random.\n        \"\"\"\n        import random\n        if random.random() < p_obstacle_prob:\n            return self._sample_from_obstacle_boundaries()\n        else:\n            return self._get_random_sample_uniform()\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        import torch\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec).item()\n        if length < 1e-6:\n            return None\n        if length <= self._max_dist:\n            new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / length\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_pos = Point.from_tensor(new_pos_tensor)\n\n        if not self._get_grid().is_agent_valid_pos(new_pos):\n            return None\n\n        return Vertex(new_pos)\n\n    def _line_collision_free_lazy(self, frm: Point, to: Point) -> bool:\n        \"\"\"\n        Lazy collision check: quickly reject invalid edges by stepping over line points.\n        Early exit on first invalid point.\n        \"\"\"\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        for p in line_seq:\n            if not self._get_grid().is_agent_valid_pos(p):\n                return False\n        return True\n\n    def _rewire(self, q_new: Vertex, Q_near: List[Vertex]) -> None:\n        import torch\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n            if dist > self._max_dist:\n                continue\n            new_cost = q_new.cost + dist\n            if q_near.cost is None or new_cost < q_near.cost:\n                if self._line_collision_free_lazy(q_new.position, q_near.position):\n                    # Remove old parent edge\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    # Add new edge\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Vertex]:\n        path = [goal_vertex]\n        while len(path[-1].parents) > 0:\n            min_parent = None\n            min_cost = float('inf')\n            for parent in path[-1].parents:\n                if parent.cost is not None and parent.cost < min_cost:\n                    min_cost = parent.cost\n                    min_parent = parent\n            if min_parent is None:\n                break\n            path.append(min_parent)\n        path.reverse()\n        return path\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_collision_free_lazy(path[i].position, path[j].position):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _dynamic_radius(self, n_vertices: int) -> float:\n        import torch\n        if n_vertices <= 1:\n            return self._max_radius\n        log_n = torch.log(torch.tensor(float(n_vertices) + 1e-8))\n        radius = min(self._lambda_rrt_star * ((log_n / n_vertices) ** (1.0 / self._dimension)), self._max_radius)\n        return radius.item()\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        self._start_time = time.perf_counter()\n\n        start = self._graph.root_vertex_start\n        goal = self._graph.root_vertex_goal\n\n        start.cost = 0.0\n        self._found_path = False\n        self._best_goal_vertex = None\n        self._best_cost = float('inf')\n        self._improvement_iter = 0\n\n        max_iterations = 15000\n\n        for iteration in range(max_iterations):\n            if time.perf_counter() - self._start_time > self._max_time_sec:\n                # Time limit exceeded, fail gracefully\n                break\n\n            # Hybrid sampling improves exploration and obstacle avoidance\n            q_sample = self._get_hybrid_sample()\n\n            q_near = self._get_nearest_vertex(q_sample)\n            if q_near is None:\n                continue\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            if q_new is None:\n                continue\n\n            # Lazy collision check before further processing\n            if not self._line_collision_free_lazy(q_near.position, q_new.position):\n                continue\n\n            cost_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = cost_to_new\n\n            # Dynamic radius based on current graph size\n            radius = self._dynamic_radius(self._graph.size)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent from Q_near minimizing cost and collision-free\n            q_min = q_near\n            c_min_vertex = cost_to_new\n            for q_near_cand in Q_near:\n                if q_near_cand == q_new:\n                    continue\n                dist = torch.norm(q_near_cand.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist > self._max_dist:\n                    continue\n                cand_cost = q_near_cand.cost + dist\n                if q_near_cand.cost is not None and cand_cost < c_min_vertex:\n                    if self._line_collision_free_lazy(q_near_cand.position, q_new.position):\n                        q_min = q_near_cand\n                        c_min_vertex = cand_cost\n\n            q_new.cost = c_min_vertex\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors for improved paths\n            self._rewire(q_new, Q_near)\n\n            # Insert new vertex into graph root vertices so it expands graph size\n            self._graph.root_vertices.append(q_new)\n\n            # Check goal proximity\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Evaluate path cost including cost to goal point\n                dist_goal = torch.norm(q_new.position.to_tensor() - goal.position.to_tensor()).item()\n                total_cost = q_new.cost + dist_goal\n                if total_cost + 1e-6 < self._best_cost:  # Allow tiny improvement tolerance\n                    self._best_cost = total_cost\n                    self._best_goal_vertex = q_new\n                    self._found_path = True\n                    self._improvement_iter = 0  # reset no improvement count\n                else:\n                    self._improvement_iter += 1\n            else:\n                self._improvement_iter += 1\n\n            self.key_frame()\n\n            # Early stop if no improvement for too long\n            if self._improvement_iter > self._max_no_improve_iter:\n                break\n\n        # After main loop finishes\n        if self._found_path and self._best_goal_vertex is not None:\n            raw_path = self._extract_path(self._best_goal_vertex)\n            smooth_path = self._smooth_path(raw_path)\n            for vertex in smooth_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # Failed to find path within constraints\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "Improved Path Planning Algorithm - Hybrid Anytime RRT* with informed sampling and replanning:\n    \n    This algorithm combines the benefits of RRT* style incremental asymptotic optimality with an informed sampling heuristic (ellipsoidal sampling)\n    to improve planning efficiency and path quality. It uses rewiring to reduce path cost iteratively, dynamically adapts sampling regions as solution\n    improves, and prunes the search space to focus on promising nodes. It includes an anytime framework that updates and smooths the path whenever a better\n    solution is found. The algorithm halts after 10 seconds without solution to declare failure, improving robustness and bounded runtime.\n    \n    Key improvements:\n    - Uses RRT* rewiring for better path quality and smoothness.\n    - Employs informed ellipsoidal sampling guided by current best path cost to focus search.\n    - Prunes vertices outside the informed set to reduce computational overhead.\n    - Uses cost-to-come and cost-to-go heuristics for rewiring and edge creation.\n    - Terminates early on solution improvements to provide anytime behavior.\n    - Limits total planning time to 10 seconds for robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n    _max_dist: float\n    _iteration_limit: int\n    _best_cost: float\n    _best_vertex: Optional[Vertex]\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 15.0\n        self._iteration_limit = 15000\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._best_cost = float(\"inf\")\n        self._best_vertex = None\n        self._init_displays()\n\n    def _get_random_sample(self, c_max: float) -> Point:\n        \"\"\"\n        Returns either a random point within the ellipsoidal informed search space if a solution exists,\n        or a uniformly random sample if no solution yet.\n        \"\"\"\n        grid_size = self._get_grid().size\n        agent_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n        start = agent_pos.to_tensor()\n        goal = goal_pos.to_tensor()\n        dim = start.numel()\n\n        if c_max == float(\"inf\"):\n            # No solution yet, uniform random sample\n            while True:\n                sample_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling inside an ellipsoid around start and goal, with c_max defining length\n        c_min = torch.norm(goal - start)\n        if c_min == 0:\n            # start == goal\n            return Point.from_tensor(start)\n\n        # Compose rotation matrix C from x axis to unit vector from start to goal\n        e1 = (goal - start) / c_min  # unit vector pointing from start to goal\n        # Build orthonormal basis for R^n with e1 as first basis vector using Gram-Schmidt\n        # Only 2D or 3D supported here from given classes assumptions\n        if dim == 2:\n            # 2D orthonormal basis matrix C\n            C = torch.zeros((dim, dim))\n            C[0, :] = e1\n            C[1, :] = torch.tensor([-e1[1], e1[0]])\n        elif dim == 3:\n            # 3D orthonormal basis using e1, and perpendicular vectors\n            # Use arbitrary vector for Gram-Schmidt\n            a = torch.tensor([1., 0., 0.])\n            if torch.allclose(e1, a):\n                a = torch.tensor([0., 1., 0.])\n            u2 = a - (a @ e1) * e1\n            u2 = u2 / torch.norm(u2)\n            u3 = torch.cross(e1, u2)\n            C = torch.stack([e1, u2, u3], dim=0)\n        else:\n            # For higher dimension, fall back to uniform sampling\n            while True:\n                sample_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Radii of the hyperellipse\n        r1 = c_max / 2.0\n        r_other = torch.sqrt(torch.tensor(c_max ** 2 - c_min ** 2)) / 2.0\n        L = torch.diag(torch.cat([torch.tensor([r1]), r_other.repeat(dim - 1)]))\n\n        # Sample uniformly a unit n-ball point\n        while True:\n            x_ball = torch.randn(dim)\n            norm_x_ball = torch.norm(x_ball)\n            if norm_x_ball > 1e-5:\n                x_ball = x_ball / norm_x_ball\n                break\n        u = torch.rand(1).item()\n        sample_unit_ball = (u ** (1.0 / dim)) * x_ball  # uniform in unit ball\n\n        # Map sample to informed ellipsoid\n        sample_tf = (C.T @ (L @ sample_unit_ball)) + ((start + goal) / 2.0)\n        sample_tf = torch.clamp(sample_tf, min=0, max=torch.tensor([grid_size[i]-1 for i in range(dim)]))\n\n        candidate = Point.from_tensor(sample_tf)\n        if self._get_grid().is_agent_valid_pos(candidate):\n            return candidate\n        else:\n            # fallback uniform sampling\n            while True:\n                sample_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_near_vertices(self, point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, point, radius)\n\n    def _line_cost(self, frm: Point, to: Point) -> float:\n        return self._get_grid().get_movement_cost(frm, to)\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"\n        Tries to improve the cost of vertices in neighbors by connecting them through q_new if cheaper.\n        \"\"\"\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                continue\n            potential_cost = q_new.cost + self._line_cost(q_new.position, q_near.position)\n            if potential_cost < q_near.cost:\n                # Remove old parent edges\n                for p in list(q_near.parents):\n                    self._graph.remove_edge(p, q_near)\n                # Add new edge\n                self._graph.add_edge(q_new, q_near)\n                # Update cost\n                q_near.cost = potential_cost\n\n    def _extract_path(self, end_vertex: Vertex) -> None:\n        path: List[Vertex] = [end_vertex]\n        while len(path[-1].parents) != 0:\n            # pick parent with lowest cost:\n            parent = min(path[-1].parents, key=lambda v: v.cost)\n            path.append(parent)\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _prune_vertices_outside_ellipsoid(self, c_max: float) -> None:\n        \"\"\"\n        Removes vertices from the graph that are outside the current informed set defined by the ellipsoid.\n        Keeps start and goal vertices always.\n        \"\"\"\n        if c_max == float(\"inf\"):\n            return  # no pruning if no solution\n\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        dim = start.numel()\n        c_min = torch.norm(goal - start)\n\n        if c_min == 0:\n            return  # start == goal; no pruning needed\n\n        # Build rotation matrix C as in sampling\n        e1 = (goal - start) / c_min\n        if dim == 2:\n            C = torch.zeros((dim, dim))\n            C[0, :] = e1\n            C[1, :] = torch.tensor([-e1[1], e1[0]])\n        elif dim == 3:\n            a = torch.tensor([1., 0., 0.])\n            if torch.allclose(e1, a):\n                a = torch.tensor([0., 1., 0.])\n            u2 = a - (a @ e1) * e1\n            u2 = u2 / torch.norm(u2)\n            u3 = torch.cross(e1, u2)\n            C = torch.stack([e1, u2, u3], dim=0)\n        else:\n            # No pruning for higher dimensions\n            return\n\n        r1 = c_max / 2.0\n        r_other = torch.sqrt(torch.tensor(c_max ** 2 - c_min ** 2)) / 2.0\n        L = torch.diag(torch.cat([torch.tensor([r1]), r_other.repeat(dim - 1)]))\n\n        # Check each vertex if inside ellipsoid, if not remove\n        to_remove = []\n        for v in list(self._graph.root_vertices[2:]):  # exclude start (0) and goal (1)\n            p = v.position.to_tensor()\n            p_trans = C @ (p - (start + goal) / 2.0)\n            val = torch.norm(torch.linalg.solve(L, p_trans))  # Equivalent to norm(inv(L)*p_trans)\n            if val > 1.0:\n                to_remove.append(v)\n\n        for v in to_remove:\n            # Remove edges connected to this vertex\n            parents_backup = list(v.parents)\n            for p in parents_backup:\n                self._graph.remove_edge(p, v)\n            children_backup = list(v.children)\n            for c in children_backup:\n                self._graph.remove_edge(v, c)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        grid = self._get_grid()\n        start = self._graph.root_vertex_start.position\n        goal = self._graph.root_vertex_goal.position\n\n        # Initialize costs\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float(\"inf\")\n        self._best_cost = float(\"inf\")\n        self._best_vertex = None\n\n        for iteration in range(self._iteration_limit):\n            elapsed = time.time() - start_time\n            if elapsed > 10.0:\n                # Timeout failure\n                return\n\n            # Sample a new point within the informed set if possible\n            q_rand_pos = self._get_random_sample(self._best_cost)\n            # Find nearest vertex to q_rand\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_rand_pos)\n\n            if q_near.position == q_rand_pos:\n                continue\n\n            # Generate a new vertex in the direction of q_rand but clipped by max_dist\n            direction = q_rand_pos.to_tensor() - q_near.position.to_tensor()\n            dist = torch.norm(direction)\n            if dist <= self._max_dist:\n                q_new_pos = q_rand_pos\n            else:\n                direction_normalized = direction / dist\n                q_new_pos = Point.from_tensor(q_near.position.to_tensor() + self._max_dist * direction_normalized)\n\n            # Validate line from q_near to q_new\n            line_seq = grid.get_line_sequence(q_near.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            # Cost from start to q_new via q_near\n            cost_to_q_new = q_near.cost + self._line_cost(q_near.position, q_new.position)\n            q_new.cost = cost_to_q_new\n\n            # Near vertices for rewiring within radius\n            radius = max(self._max_dist * 1.5, 20.0)\n            neighbors = self._get_near_vertices(q_new.position, radius)\n\n            # Choose best parent among neighbors\n            min_cost = cost_to_q_new\n            best_parent = q_near\n            for q_near_candidate in neighbors:\n                if q_near_candidate == q_near:\n                    continue\n                if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near_candidate.position, q_new.position)):\n                    continue\n                temp_cost = q_near_candidate.cost + self._line_cost(q_near_candidate.position, q_new.position)\n                if temp_cost < min_cost:\n                    min_cost = temp_cost\n                    best_parent = q_near_candidate\n\n            # Update q_new attributes with best parent and cost\n            q_new.cost = min_cost\n            self._graph.add_edge(best_parent, q_new)\n            self._graph.root_vertices.append(q_new)\n\n            # Rewire neighbors if can improve cost through q_new\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new can connect to goal with better cost\n            dist_to_goal = torch.norm(q_new.position.to_tensor() - goal.to_tensor())\n            if dist_to_goal <= self._max_dist:\n                goal_line = grid.get_line_sequence(q_new.position, goal)\n                if grid.is_valid_line_sequence(goal_line):\n                    cost_to_goal = q_new.cost + self._line_cost(q_new.position, goal)\n                    if cost_to_goal < self._best_cost:\n                        # Update best solution\n                        self._best_cost = cost_to_goal\n                        # Remove old edges to goal\n                        old_goal_parents = list(self._graph.root_vertex_goal.parents)\n                        for p in old_goal_parents:\n                            self._graph.remove_edge(p, self._graph.root_vertex_goal)\n                        # Add edge from q_new to goal vertex\n                        self._graph.add_edge(q_new, self._graph.root_vertex_goal)\n                        self._graph.root_vertex_goal.cost = cost_to_goal\n                        self._best_vertex = self._graph.root_vertex_goal\n\n                        # Prune vertices outside informed set\n                        self._prune_vertices_outside_ellipsoid(self._best_cost)\n\n                        # Extract path and move agent\n                        self._extract_path(self._best_vertex)\n                        # Mark keyframe for visualization after path extraction\n                        self.key_frame(ignore_key_frame_skip=True)\n\n                        # Anytime - allow continuation to find potentially better paths\n                        # But break early if time is close to limit\n                        if (time.time() - start_time) > 9.8:\n                            break\n\n            # Keyframe for visualization of tree growth\n            self.key_frame()\n\n        # If no path found within iterations/time, fail silently\n        return",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This algorithm proposes an Adaptive Informed RRT* variant enhanced by:\n    - Early pruning of non-promising samples via heuristic informed sampling inside an ellipsoidal informed subset.\n    - Incorporating obstacle boundary guided local sampling around the current best path for improved refinement.\n    - Dynamic radius and rewiring balancing exploration and exploitation adapted by iteration count and graph density.\n    - Lazy collision checking combined with incremental smoothing on path improvement.\n    - Dual sampling strategy mixing uniform sampling for coverage and guided sampling near obstacles/the best path.\n    - Early stopping if no improvement or timeout at 10 seconds.\n    This method aims at better planning efficiency, robustness, faster convergence to high-quality smooth paths, \n    and improved success rate through adaptive and progressive sampling strategies.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        self._max_dist = 12.0\n        self._max_radius = 30.0\n        self._lambda_rrt_star = 35.0\n        self._dimension = self._get_grid().size.n_dim\n\n        # Obstacle boundary points for guided local sampling\n        self._obstacle_boundaries = self._compute_obstacle_boundaries()\n\n        self._start_time = 0\n        self._max_time_sec = 10.0\n\n        self._found_path = False\n        self._best_goal_vertex = None\n        self._best_cost = float('inf')\n\n        self._improvement_iter = 0\n        self._max_no_improve_iter = 250\n\n        # Store current best path vertices for local informed sampling\n        self._best_path_vertices = []\n\n        self._init_displays()\n\n    def _compute_obstacle_boundaries(self) -> list:\n        boundaries = []\n        visited = set()\n        for obs in self._get_grid().obstacles:\n            bound = self._get_grid().get_obstacle_bound(obs.position, visited)\n            boundaries.extend(bound)\n            visited.update(bound)\n        return boundaries\n\n    def _sample_near_obstacle_boundaries(self) -> Point:\n        import random\n        import torch\n\n        if not self._obstacle_boundaries:\n            return self._sample_uniform()\n\n        base_pt = random.choice(self._obstacle_boundaries)\n        offset_scale = 2.5\n        noise = [torch.normal(mean=torch.tensor(0.0), std=offset_scale).item() for _ in range(self._dimension)]\n\n        new_coords = []\n        grid_size = self._get_grid().size\n        for i in range(self._dimension):\n            c = base_pt[i] + noise[i]\n            c = max(0, min(c, grid_size[i] - 1))\n            new_coords.append(int(round(c)))\n\n        new_point = Point(*new_coords)\n        if self._get_grid().is_agent_valid_pos(new_point):\n            return new_point\n        else:\n            return self._sample_uniform()\n\n    def _sample_uniform(self) -> Point:\n        import torch\n        grid_size = self._get_grid().size\n        while True:\n            coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(self._dimension)]\n            p = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(p):\n                return p\n\n    def _ellipsoid_sample(self, c_best: float, c_min: float, start: Point, goal: Point) -> Point:\n        \"\"\"\n        Samples within an ellipsoid defined by start and goal,\n        where the sum distance to start and goal <= c_best (current best cost).\n        If c_best is inf, revert to uniform sampling.\n        \"\"\"\n        import torch\n        import math\n        if math.isinf(c_best):\n            return self._sample_uniform()\n\n        c_best = max(c_best, c_min + 1e-6)  # prevent div by zero or degenerate ellipsoid\n\n        center = (start.to_tensor() + goal.to_tensor()) / 2.0\n        diff = (goal.to_tensor() - start.to_tensor())\n        dist_start_goal = torch.norm(diff).item()\n        if dist_start_goal < 1e-8:\n            return start  # start==goal rare case\n\n        # Ellipsoid axis lengths\n        a1 = c_best / 2.0\n        a2 = math.sqrt(c_best ** 2 - dist_start_goal ** 2) / 2.0\n\n        # Unit vector from start to goal\n        e1 = (diff / dist_start_goal).view(-1, 1)  # column vector\n\n        # Rotation matrix from unit vector e1 to coordinate frame (using SVD)\n        # This builds a basis where first vector aligns with e1\n        n = self._dimension\n        U, _, Vt = torch.svd(torch.eye(n))\n        # Set U[:,0] to e1 and fill rest orthonormally\n        # We'll construct an orthonormal basis with e1 first (Gram-Schmidt)\n        basis = torch.eye(n)\n        basis[:, 0] = e1.flatten()\n        # Gram-Schmidt for basis\n        for i in range(1, n):\n            proj = torch.dot(basis[:, i], basis[:, 0]) * basis[:, 0]\n            basis[:, i] = basis[:, i] - proj\n            norm = torch.norm(basis[:, i])\n            if norm > 1e-8:\n                basis[:, i] = basis[:, i] / norm\n            else:\n                basis[:, i] = torch.zeros(n)  # fallback\n\n        # Sampling random point inside unit n-ball\n        # Use normal Gaussian and normalize, then scale by radius**(1/n_dim)\n        direction = torch.randn(n)\n        radius = torch.rand(1).pow(1.0 / n).item()\n        direction = direction / torch.norm(direction)\n        unit_ball_sample = direction * radius\n\n        # Scale sample to ellipsoid axes: a1 on e1 axis, a2 on others\n        L = torch.diag(torch.tensor([a1] + [a2] * (n - 1)))\n        sample = basis @ (L @ unit_ball_sample)\n\n        final_point_tensor = center + sample.view(-1)\n        # Clamp coordinates and round for discrete map\n        grid_size = self._get_grid().size\n        coords = []\n        for i in range(n):\n            c = final_point_tensor[i].item()\n            c = max(0, min(c, grid_size[i] - 1))\n            coords.append(int(round(c)))\n        p = Point(*coords)\n        if self._get_grid().is_agent_valid_pos(p):\n            return p\n        else:\n            # fallback uniform\n            return self._sample_uniform()\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        import torch\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec).item()\n        if length < 1e-6:\n            return None\n        if length <= self._max_dist:\n            new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / length\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_pos = Point.from_tensor(new_pos_tensor)\n\n        if not self._get_grid().is_agent_valid_pos(new_pos):\n            return None\n\n        return Vertex(new_pos)\n\n    def _line_collision_free_lazy(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        for p in line_seq:\n            if not self._get_grid().is_agent_valid_pos(p):\n                return False\n        return True\n\n    def _rewire(self, q_new: Vertex, Q_near: list) -> None:\n        import torch\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n            if dist > self._max_dist:\n                continue\n            new_cost = q_new.cost + dist\n            if q_near.cost is None or new_cost < q_near.cost:\n                if self._line_collision_free_lazy(q_new.position, q_near.position):\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, goal_vertex: Vertex) -> list:\n        path = [goal_vertex]\n        while len(path[-1].parents) > 0:\n            min_parent = None\n            min_cost = float('inf')\n            for parent in path[-1].parents:\n                if parent.cost is not None and parent.cost < min_cost:\n                    min_cost = parent.cost\n                    min_parent = parent\n            if min_parent is None:\n                break\n            path.append(min_parent)\n        path.reverse()\n        return path\n\n    def _smooth_path(self, path: list) -> list:\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_collision_free_lazy(path[i].position, path[j].position):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _dynamic_radius(self, n_vertices: int, iteration: int) -> float:\n        import torch\n        if n_vertices <= 1:\n            return self._max_radius\n        log_n = torch.log(torch.tensor(float(n_vertices) + 1e-8))\n        base_radius = self._lambda_rrt_star * ((log_n / n_vertices) ** (1.0 / self._dimension))\n        # Gradually shrink radius as iterations progress to focus rewiring locally\n        shrink_factor = max(0.5, 1.0 - iteration / 15000.0)\n        radius = min(base_radius * shrink_factor, self._max_radius)\n        return radius.item()\n\n    def _sample_near_best_path(self) -> Point:\n        \"\"\"\n        Sample locally around vertices of the best path to refine paths near current best solution.\n        Uses Gaussian perturbation around random vertex on best path.\n        \"\"\"\n        import random\n        import torch\n\n        if not self._best_path_vertices:\n            return self._sample_uniform()\n\n        base_vertex = random.choice(self._best_path_vertices)\n        base_pt = base_vertex.position\n        offset_scale = 2.0\n        noise = [torch.normal(mean=torch.tensor(0.0), std=offset_scale).item() for _ in range(self._dimension)]\n\n        grid_size = self._get_grid().size\n        new_coords = []\n        for i in range(self._dimension):\n            c = base_pt[i] + noise[i]\n            c = max(0, min(c, grid_size[i] - 1))\n            new_coords.append(int(round(c)))\n\n        p = Point(*new_coords)\n        if self._get_grid().is_agent_valid_pos(p):\n            return p\n        else:\n            return self._sample_uniform()\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n        import random\n\n        self._start_time = time.perf_counter()\n        start = self._graph.root_vertex_start\n        goal = self._graph.root_vertex_goal\n        start.cost = 0.0\n\n        c_min = self._get_grid().get_distance(start.position, goal.position).item()\n        best_cost = float('inf')\n        best_goal_vertex = None\n        found_path = False\n        no_improve_iter = 0\n        max_iterations = 15000\n\n        # Mix ratios for sampling strategies\n        uniform_prob = 0.4\n        obstacle_prob = 0.3\n        best_path_prob = 0.3\n\n        # Reset best path vertices cache\n        self._best_path_vertices = []\n\n        for iteration in range(max_iterations):\n            elapsed = time.perf_counter() - self._start_time\n            if elapsed > self._max_time_sec:\n                break  # Time limit reached: fail safely\n\n            # After first solution: informed sampling inside ellipsoid, else mix uniform & guided sampling\n            if found_path and best_cost < float('inf'):\n                q_sample = self._ellipsoid_sample(best_cost, c_min, start.position, goal.position)\n                # With small probability sample near obstacles or best path for local improvements\n                r = random.random()\n                if r < obstacle_prob:\n                    q_sample = self._sample_near_obstacle_boundaries()\n                elif r < obstacle_prob + best_path_prob:\n                    q_sample = self._sample_near_best_path()\n            else:\n                # No solution found yet: mixed sampling for coverage & obstacle avoidance\n                r = random.random()\n                if r < uniform_prob:\n                    q_sample = self._sample_uniform()\n                elif r < uniform_prob + obstacle_prob:\n                    q_sample = self._sample_near_obstacle_boundaries()\n                else:\n                    q_sample = self._sample_uniform()\n\n            q_near = self._get_nearest_vertex(q_sample)\n            if q_near is None:\n                continue\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            if q_new is None:\n                continue\n\n            # Lazy collision checking on the edge\n            if not self._line_collision_free_lazy(q_near.position, q_new.position):\n                continue\n\n            cost_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = cost_to_new\n\n            radius = self._dynamic_radius(self._graph.size + 1, iteration)\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Best parent selection for cost minimization with collision check\n            q_min = q_near\n            c_min_vertex = cost_to_new\n            for q_near_cand in Q_near:\n                if q_near_cand == q_new:\n                    continue\n                dist = torch.norm(q_near_cand.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist > self._max_dist:\n                    continue\n                cand_cost = q_near_cand.cost + dist\n                if q_near_cand.cost is not None and cand_cost < c_min_vertex:\n                    if self._line_collision_free_lazy(q_near_cand.position, q_new.position):\n                        q_min = q_near_cand\n                        c_min_vertex = cand_cost\n\n            q_new.cost = c_min_vertex\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to improve cost\n            self._rewire(q_new, Q_near)\n\n            # Add new vertex to root vertices for further expansion\n            self._graph.root_vertices.append(q_new)\n\n            # Goal proximity check\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_goal = torch.norm(q_new.position.to_tensor() - goal.position.to_tensor()).item()\n                total_cost = q_new.cost + dist_goal\n                if total_cost + 1e-6 < best_cost:\n                    best_cost = total_cost\n                    best_goal_vertex = q_new\n                    found_path = True\n                    no_improve_iter = 0\n\n                    # Refresh best path vertex cache for local refinement sampling\n                    path_vertices = self._extract_path(best_goal_vertex)\n                    self._best_path_vertices = path_vertices\n\n                    # After path improvement, smooth path incrementally\n                    smoothed_path = self._smooth_path(path_vertices)\n\n                    # Update path vertices cache to smoothed path for next local sampling\n                    self._best_path_vertices = smoothed_path\n\n                else:\n                    no_improve_iter += 1\n            else:\n                no_improve_iter += 1\n\n            self.key_frame()\n\n            if no_improve_iter > self._max_no_improve_iter:\n                break  # Early stop no improvement\n\n        if found_path and best_goal_vertex is not None:\n            path = self._extract_path(best_goal_vertex)\n            smooth_path = self._smooth_path(path)\n            for vertex in smooth_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # No path found within constraints\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an improved sampling-based planner inspired by RRT* with informed sampling and lazy collision checking. \n    It maintains a forest graph and incrementally builds paths by sampling points biased towards the goal using ellipsoidal \n    informed sampling, connecting vertices within a neighborhood radius. It uses a rewiring step to improve path quality \n    continuously and performs lazy collision checking only when connecting edges to reduce computation. Search terminates \n    successfully when a valid path to the goal is found or fails if exceeding a 10-second time limit. The approach balances \n    efficient sampling, path quality, smoothness, and computational efficiency to improve over plain SPRM methods.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        self._V_size = 300                  # Larger sample size for better coverage\n        self._max_radius = 20.0             # Neighborhood search radius for rewiring\n        self._goal_bias_prob = 0.2          # Probability to sample the goal point directly\n        self._graph = None\n\n        V = []\n        for _ in range(self._V_size):\n            q_rand = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = True\n\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Samples a point in the grid with goal bias and informed ellipsoidal sampling \n        around the current best path for efficiency.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        agent_pos = grid.agent.position\n\n        # Sampling box bounds\n        bounds = [grid.size[i] for i in range(grid.size.n_dim)]\n\n        # Goal biasing: with some probability sample goal directly\n        if torch.rand(1).item() < self._goal_bias_prob:\n            return Point(*goal_pos)\n\n        # If no path found yet, uniform random sampling\n        if not hasattr(self, \"_best_cost\"):\n            while True:\n                sample_coords = [torch.randint(0, bounds[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed Ellipsoidal Sampling (hypersphere around start-goal)\n        dist_start_goal = Map.get_distance(agent_pos, goal_pos)\n        c_best = getattr(self, \"_best_cost\", float(\"inf\"))\n\n        # If no feasible path cost known, just uniform sampling\n        if not (c_best < float(\"inf\")):\n            while True:\n                sample_coords = [torch.randint(0, bounds[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        c_min = dist_start_goal\n        center = Point(*[(agent_pos[i] + goal_pos[i]) / 2.0 for i in range(agent_pos.n_dim)])\n\n        # Define lengths of ellipse axes - major axis = c_best/2, others = sqrt(c_best\u00b2 - c_min\u00b2)/2\n        r1 = c_best / 2.0\n        if agent_pos.n_dim == 2:\n            r2 = ( (c_best**2 - c_min**2) ** 0.5 ) / 2.0 if c_best > c_min else 0.0\n            # Sample in unit circle then scale into ellipse\n            while True:\n                theta = 2 * 3.14159265359 * torch.rand(1).item()\n                rad = torch.rand(1).item() ** 0.5\n                x = rad * torch.cos(torch.tensor(theta))\n                y = rad * torch.sin(torch.tensor(theta))\n                sample_x = center.x + r1 * x.item()\n                sample_y = center.y + r2 * y.item()\n                sample_pt = Point(int(round(sample_x)), int(round(sample_y)))\n                if 0 <= sample_pt.x < bounds[0] and 0 <= sample_pt.y < bounds[1]:\n                    if grid.is_agent_valid_pos(sample_pt):\n                        return sample_pt\n        else:\n            # For n_dim > 2 uniform sampling inside hyperellipsoid (approximate)\n            while True:\n                rand_dir = torch.randn(agent_pos.n_dim)\n                rand_dir = rand_dir / torch.norm(rand_dir)\n                mag = torch.rand(1).item() ** (1.0 / agent_pos.n_dim)\n                scaled_dir = rand_dir * mag\n                # Scale major axis only along first dimension (approximation)\n                scaled_dir[0] = scaled_dir[0] * r1\n                # For other dims, scale to radius sqrt(c_best\u00b2 - c_min\u00b2)/2\n                scale_minor = ((c_best ** 2 - c_min ** 2) ** 0.5 / 2.0) if c_best > c_min else 0.0\n                for i in range(1, agent_pos.n_dim):\n                    scaled_dir[i] *= scale_minor\n                sample_coords = [center[i] + scaled_dir[i].item() for i in range(agent_pos.n_dim)]\n                sample_coords_int = [int(round(x)) for x in sample_coords]\n                sample_pt = Point(*sample_coords_int)\n                if all(0 <= sample_pt[i] < bounds[i] for i in range(agent_pos.n_dim)):\n                    if grid.is_agent_valid_pos(sample_pt):\n                        return sample_pt\n\n    def _get_near_vertices(self, position: Point) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, position, self._max_radius)\n\n    def _get_cost(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        return self._get_grid().get_movement_cost(from_vertex.position, to_vertex.position)\n\n    def _can_connect(self, p1: Point, p2: Point) -> bool:\n        \"\"\"Lazy collision check via Bresenham line with grid validation.\"\"\"\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Rewires the graph to improve path costs by connecting new_vertex to better parents,\n        and potentially reconnect children to new_vertex if beneficial.\n        \"\"\"\n        improved_parents = []\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex:\n                continue\n            if self._can_connect(near_vertex.position, new_vertex.position):\n                new_cost = near_vertex.cost + self._get_cost(near_vertex, new_vertex)\n                if new_cost < new_vertex.cost:\n                    new_vertex.parents.clear()\n                    new_vertex.cost = new_cost\n                    new_vertex.add_parent(near_vertex)\n                    near_vertex.add_child(new_vertex)\n                    improved_parents.append(near_vertex)\n\n        # Rewire children\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex:\n                continue\n            if self._can_connect(new_vertex.position, near_vertex.position):\n                new_cost = new_vertex.cost + self._get_cost(new_vertex, near_vertex)\n                if new_cost < near_vertex.cost:\n                    for p in list(near_vertex.parents):\n                        p.children.discard(near_vertex)\n                        near_vertex.parents.discard(p)\n                    near_vertex.cost = new_cost\n                    near_vertex.add_parent(new_vertex)\n                    new_vertex.add_child(near_vertex)\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Extracts the best path from the start vertex to the goal vertex using BFS \n        along parents with lowest cost, and moves the agent stepwise along it.\n        \"\"\"\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        # BFS from goal to start by walking parents to build path backward\n        path = deque()\n        current = goal_vertex\n        if current.cost == float(\"inf\"):\n            # No path exists\n            return\n        while current != start_vertex:\n            path.appendleft(current)\n            # Choose the lowest cost parent\n            parents_sorted = sorted(current.parents, key=lambda v: v.cost)\n            if not parents_sorted:\n                # Disconnected, no valid path\n                return\n            current = parents_sorted[0]\n        path.appendleft(start_vertex)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _initialize_costs(self) -> None:\n        \"\"\"Initialize vertex costs: zero for start, infinity else.\"\"\"\n        for v in self._graph.root_vertices:\n            v.cost = float(\"inf\")\n            v.parents.clear()\n            v.children.clear()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n    def _find_path_internal(self) -> None:\n        \"\"\"\n        Main function implementing RRT*-style informed path planning with time limit.\n        Samples, connects, rewires, and updates best path dynamically.\n        \"\"\"\n        grid = self._get_grid()\n        start_time = time()\n        max_duration = 10.0  # seconds timeout\n\n        self._initialize_costs()\n\n        # Insert edges from start and goal roots to their neighbors initially\n        for root in self._graph.root_vertices:\n            near_vertices = self._get_near_vertices(root.position)\n            for near_v in near_vertices:\n                if near_v == root:\n                    continue\n                if self._can_connect(root.position, near_v.position):\n                    cost_edge = self._get_cost(root, near_v)\n                    if root.cost + cost_edge < near_v.cost:\n                        near_v.cost = root.cost + cost_edge\n                        near_v.parents.clear()\n                        near_v.add_parent(root)\n                        root.add_child(near_v)\n\n        vertices = list(self._graph.root_vertices)\n\n        # Main iterative sampling, connecting, rewiring loop\n        while True:\n            if (time() - start_time) > max_duration:\n                return  # timeout/failure\n\n            # Sample new point\n            q_rand = self._get_random_sample()\n\n            # Find nearest vertex to the sampled point\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_rand)\n\n            # Steer towards q_rand with maximum step limited by max_radius (step size)\n            direction = q_rand.to_tensor() - q_near.position.to_tensor()\n            dist = torch.norm(direction).item()\n            if dist == 0:\n                continue\n            if dist > self._max_radius:\n                direction = direction / dist * self._max_radius\n                q_new_pt = Point.from_tensor(q_near.position.to_tensor() + direction)\n            else:\n                q_new_pt = q_rand\n\n            if not grid.is_agent_valid_pos(q_new_pt):\n                continue\n\n            if not self._can_connect(q_near.position, q_new_pt):\n                continue\n\n            q_new = Vertex(q_new_pt, store_connectivity=True)\n            # Cost from start to q_new through q_near\n            tentative_cost = q_near.cost + self._get_cost(q_near, q_new)\n\n            # Find near vertices for rewiring\n            near_vertices = self._get_near_vertices(q_new.position)\n\n            # Choose the best parent for q_new\n            min_cost = tentative_cost\n            best_parent = q_near\n            for near_v in near_vertices:\n                if near_v == q_near:\n                    continue\n                if self._can_connect(near_v.position, q_new.position):\n                    cost_through_near = near_v.cost + self._get_cost(near_v, q_new)\n                    if cost_through_near < min_cost:\n                        min_cost = cost_through_near\n                        best_parent = near_v\n\n            q_new.cost = min_cost\n            q_new.add_parent(best_parent)\n            best_parent.add_child(q_new)\n\n            # Add q_new to vertices and graph root vertices list to maintain structure\n            self._graph.root_vertices.append(q_new)\n            vertices.append(q_new)\n\n            # Rewire neighbors to improve paths\n            self._rewire(q_new, near_vertices)\n\n            # Check if can connect q_new to goal root vertex (possibly shortcut)\n            goal_vertex = self._graph.root_vertex_goal\n            if self._can_connect(q_new.position, goal_vertex.position):\n                cost_to_goal = q_new.cost + self._get_cost(q_new, goal_vertex)\n                if cost_to_goal < goal_vertex.cost:\n                    for p in list(goal_vertex.parents):\n                        p.children.discard(goal_vertex)\n                    goal_vertex.parents.clear()\n                    goal_vertex.cost = cost_to_goal\n                    goal_vertex.add_parent(q_new)\n                    q_new.add_child(goal_vertex)\n\n                    # Update best known cost for informed sampling\n                    self._best_cost = cost_to_goal\n\n                    # Extract and follow path\n                    self._extract_path()\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an improved sampling-based planner integrating RRT*-style rewiring, \n    adaptive informed sampling, bidirectional search, and path smoothing. \n    \n    Key improvements:\n    1. Bidirectional tree growth from start and goal, reducing convergence time and improving success rate.\n    2. Adaptive informed sampling ellipsoids from both directions after initial connection, focusing search.\n    3. RRT* rewiring in both trees for path quality improvement.\n    4. Lazy collision checking with early abandon for efficiency.\n    5. Dynamic radius for rewiring based on vertex count and dimensionality.\n    6. After connection, smooth shortcutting path to improve path smoothness and length.\n    7. Strict 10 seconds timeout to fail gracefully.\n\n    The algorithm grows two forests (from start and goal), tries to connect them efficiently, extracts best path, smooths it,\n    and moves the agent along the final planned trajectory.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._max_dist = 12.0\n        self._max_radius = 40.0\n        self._lambda_rrt_star = 40.0\n        self._dimension = self._get_grid().size.n_dim\n        self._start_time = 0\n        self._samples_taken = 0\n        self._found_path = False\n        self._best_start_vertex: Vertex = None\n        self._best_goal_vertex: Vertex = None\n        self._best_cost = float('inf')\n        self._init_displays()\n\n    def _get_random_sample(self, informed_ball_start: tuple = None, informed_ball_goal: tuple = None) -> Point:\n        \"\"\"\n        Samples a point either uniformly or inside combined ellipsoids from start and goal informed sampling.\n        If informed balls for both trees are provided, probabilistically sample from one or uniform.\n        Otherwise uniform sampling.\n        \"\"\"\n        grid_size = self._get_grid().size\n        # Simple logic: 40% from start ellipsoid, 40% from goal ellipsoid, 20% uniform if informed balls exist\n        import random\n        prob = random.random()\n\n        def sample_ellipsoid(center: Point, c_best: float, c_min: float) -> Point:\n            if grid_size.n_dim != 2:\n                # fallback to uniform\n                return None\n            a1 = c_best / 2\n            try:\n                a2 = (c_best**2 - c_min**2)**0.5 / 2\n            except Exception:\n                return None\n            for _ in range(200):\n                rx = torch.FloatTensor(1).uniform_(-1,1).item()\n                ry = torch.FloatTensor(1).uniform_(-1,1).item()\n                norm = (rx**2 + ry**2)**0.5\n                if norm > 1e-5:\n                    break\n            else:\n                return None\n            rx /= norm\n            ry /= norm\n            r = torch.FloatTensor(1).uniform_(0,1).item() ** (1 / 2)\n            x = r * a1 * rx\n            y = r * a2 * ry\n            # Rotation: along vector start -> goal\n            start = self._graph_start.root_vertex_start.position\n            goal = self._graph_start.root_vertex_goal.position\n            delta = torch.tensor([goal.x - start.x, goal.y - start.y])\n            angle = torch.atan2(delta[1], delta[0]).item()\n            cos_ang = torch.cos(torch.tensor(angle))\n            sin_ang = torch.sin(torch.tensor(angle))\n            rot_x = cos_ang * x - sin_ang * y\n            rot_y = sin_ang * x + cos_ang * y\n            sample_x = int(round(center.x + rot_x))\n            sample_y = int(round(center.y + rot_y))\n            sample_x = max(0, min(sample_x, grid_size[0] - 1))\n            sample_y = max(0, min(sample_y, grid_size[1] - 1))\n            sample = Point(sample_x, sample_y)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            return None\n\n        if informed_ball_start and informed_ball_goal:\n            if prob < 0.4:\n                s = sample_ellipsoid(*informed_ball_start)\n                if s is not None:\n                    return s\n            elif prob < 0.8:\n                s = sample_ellipsoid(*informed_ball_goal)\n                if s is not None:\n                    return s\n            # fallback uniform\n        elif informed_ball_start:\n            s = sample_ellipsoid(*informed_ball_start)\n            if s is not None:\n                return s\n        elif informed_ball_goal:\n            s = sample_ellipsoid(*informed_ball_goal)\n            if s is not None:\n                return s\n\n        # uniform sampling fallback\n        attempts = 0\n        while attempts < 500:\n            rand_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(grid_size.n_dim)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n        # As a last resort fallback to agent's position to prevent error\n        return self._get_grid().agent.position\n\n    def _get_nearest_vertex(self, graph: Forest, q_sample: Point) -> Vertex:\n        return graph.get_nearest_vertex(graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, graph: Forest, position: Point, radius: float) -> list:\n        return graph.get_vertices_within_radius(graph.root_vertices, position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec)\n        if length < 1e-6:\n            return None\n        if length <= self._max_dist:\n            new_vertex_pos = q_sample\n        else:\n            dir_normalized = dir_vec / length\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_vertex_pos = Point.from_tensor(new_pos_tensor)\n        if not self._get_grid().is_agent_valid_pos(new_vertex_pos):\n            return None\n        return Vertex(new_vertex_pos)\n\n    def _line_collision_free_lazy(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        for pt in line_seq:\n            if not self._get_grid().is_agent_valid_pos(pt):\n                return False\n        return True\n\n    def _rewire(self, graph: Forest, q_new: Vertex, Q_near: list) -> None:\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n            if dist > self._max_dist:\n                continue\n            new_cost = q_new.cost + dist\n            if new_cost < q_near.cost:\n                if self._line_collision_free_lazy(q_new.position, q_near.position):\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    graph.add_edge(q_new, q_near)\n\n    def _connect_trees(self, v_start: Vertex, v_goal: Vertex) -> (Vertex, Vertex, float):\n        \"\"\"\n        Attempts to connect two vertices from start and goal trees directly if collision-free.\n        Returns tuple (start_vertex, goal_vertex, cost) if successful; else None.\n        \"\"\"\n        if not self._line_collision_free_lazy(v_start.position, v_goal.position):\n            return None\n        dist = torch.norm(v_start.position.to_tensor() - v_goal.position.to_tensor()).item()\n        total_cost = v_start.cost + dist + v_goal.cost\n        return (v_start, v_goal, total_cost)\n\n    def _extract_bidirectional_path(self, start_vertex: Vertex, goal_vertex: Vertex) -> list:\n        \"\"\"\n        Extract path from start vertex in start tree and from goal vertex in goal tree,\n        concatenating paths at meeting point.\n        \"\"\"\n        path_start = []\n        cur = start_vertex\n        while cur is not None:\n            path_start.append(cur)\n            if not cur.parents:\n                break\n            # Choose parent with minimal cost (should usually be one)\n            min_cost = float('inf')\n            min_p = None\n            for p in cur.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_p = p\n            cur = min_p\n        path_start.reverse()\n\n        path_goal = []\n        cur = goal_vertex\n        while cur is not None:\n            path_goal.append(cur)\n            if not cur.parents:\n                break\n            min_cost = float('inf')\n            min_p = None\n            for p in cur.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_p = p\n            cur = min_p\n\n        # Reverse path_goal for correct direction\n        path_goal.reverse()\n        # Remove duplicate meeting vertex at join\n        if len(path_goal) > 0 and len(path_start) > 0 and path_start[-1].position == path_goal[0].position:\n            path_goal = path_goal[1:]\n\n        return path_start + path_goal\n\n    def _smooth_path(self, path: list) -> list:\n        \"\"\"\n        Shortcut smoothing removing unnecessary vertices by connecting farther apart vertices directly.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_collision_free_lazy(path[i].position, path[j].position):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.perf_counter()\n        max_time_sec = 10.0\n        max_iterations = 15000\n\n        start_tree = self._graph_start\n        goal_tree = self._graph_goal\n\n        start_root = start_tree.root_vertex_start\n        goal_root = goal_tree.root_vertex_start\n\n        start_root.cost = 0.0\n        goal_root.cost = 0.0\n\n        self._found_path = False\n        self._best_cost = float('inf')\n        self._best_start_vertex = None\n        self._best_goal_vertex = None\n\n        for iteration in range(max_iterations):\n            if time.perf_counter() - self._start_time > max_time_sec:\n                # timeout -> fail gracefully\n                break\n\n            # Setup informed sampling ellipsoids if path found\n            informed_start = None\n            informed_goal = None\n            if self._found_path and self._best_cost < float('inf'):\n                c_min = torch.norm(start_root.position.to_tensor() - goal_root.position.to_tensor()).item()\n                c_best = self._best_cost\n                center_start = Point((start_root.position.x + goal_root.position.x) / 2,\n                                     (start_root.position.y + goal_root.position.y) / 2)\n                informed_start = (center_start, c_best, c_min)\n                informed_goal = (center_start, c_best, c_min)\n\n            # Alternate tree growth: odd iteration grow start tree, even grow goal tree\n            growing_start_tree = (iteration % 2 == 0)\n            graph = start_tree if growing_start_tree else goal_tree\n            other_graph = goal_tree if growing_start_tree else start_tree\n            root_vertex = graph.root_vertex_start\n\n            q_sample = self._get_random_sample(informed_ball_start=informed_start, informed_ball_goal=informed_goal)\n            q_near = self._get_nearest_vertex(graph, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            if not q_new:\n                continue\n\n            if not self._line_collision_free_lazy(q_near.position, q_new.position):\n                continue\n\n            dist = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = q_near.cost + dist\n\n            card_V = max(1, graph.size)\n            log_card_V = torch.log(torch.tensor(float(card_V) + 1e-8))\n            radius = min(self._lambda_rrt_star * ((log_card_V / card_V) ** (1.0 / self._dimension)), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(graph, q_new.position, radius)\n\n            # Choose parent with minimum cost + collision free\n            q_min = q_near\n            c_min_vertex = q_near.cost\n            for q_near_candidate in Q_near:\n                if q_near_candidate == q_new:\n                    continue\n                dist_candidate = torch.norm(q_near_candidate.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist_candidate > self._max_dist:\n                    continue\n                cost_candidate = q_near_candidate.cost + dist_candidate\n                if cost_candidate < c_min_vertex:\n                    if self._line_collision_free_lazy(q_near_candidate.position, q_new.position):\n                        q_min = q_near_candidate\n                        c_min_vertex = cost_candidate\n            q_new.cost = c_min_vertex\n            graph.add_edge(q_min, q_new)\n            self._rewire(graph, q_new, Q_near)\n\n            # Try to connect the other tree's nearest vertex to q_new\n            q_near_other = self._get_nearest_vertex(other_graph, q_new.position)\n\n            connection = self._connect_trees(q_new, q_near_other)\n            if connection is not None:\n                (start_v, goal_v, total_cost) = connection\n                if total_cost < self._best_cost:\n                    self._best_cost = total_cost\n                    if growing_start_tree:\n                        self._best_start_vertex = start_v\n                        self._best_goal_vertex = goal_v\n                    else:\n                        self._best_start_vertex = goal_v\n                        self._best_goal_vertex = start_v\n                    self._found_path = True\n\n            self.key_frame()\n\n        if self._found_path and self._best_start_vertex and self._best_goal_vertex:\n            path_vertices = self._extract_bidirectional_path(self._best_start_vertex, self._best_goal_vertex)\n            smoothed_path = self._smooth_path(path_vertices)\n            for vertex in smoothed_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # fail silently\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This improved path planning algorithm combines bidirectional RRT* with anytime informed sampling, dynamic rewiring,\n    and path smoothing using Dubins-like shortcutting. Key improvements:\n    1. Uses two forests (start and goal) grown alternately for fast convergence.\n    2. Anytime Informed Sampling: dynamically restricts sampling space using ellipsoids updated after each found path to focus search region and improve efficiency.\n    3. Dynamic rewiring radius adaptive to increase in vertex count and dimension, improving path quality.\n    4. Lazy collision checking on edges with early abandon, reducing costly collision checks.\n    5. Uses heuristic cost-to-go and cost-from-start to guide edge selection in rewiring, improving robustness.\n    6. After a solution is found, aggressively shortcutting path with multiple iterations to produce smooth and short paths.\n    7. Strict 10-second timeout for graceful fail.\n    This algorithm targets planning efficiency, path quality, robustness, success rate, path smoothness and length, and reduced search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._graph = self._graph_start  # placeholder for compatibility\n        self._max_dist = 15.0\n        self._max_radius = 50.0\n        self._lambda_rrt_star = 50.0\n        self._dimension = self._get_grid().size.n_dim\n        self._start_time = 0.0\n        self._found_path = False\n        self._best_cost = float('inf')\n        self._best_start_vertex = None\n        self._best_goal_vertex = None\n        self._max_time_sec = 10.0\n        self._path_smooth_iterations = 30\n        self._init_displays()\n\n    def _get_nearest_vertex(self, graph: Forest, q_sample: Point) -> Vertex:\n        return graph.get_nearest_vertex(graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, graph: Forest, position: Point, radius: float) -> list:\n        return graph.get_vertices_within_radius(graph.root_vertices, position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec)\n        if length < 1e-6:\n            return None\n        if length <= self._max_dist:\n            new_vertex_pos = q_sample\n        else:\n            dir_normalized = dir_vec / length\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_vertex_pos = Point.from_tensor(new_pos_tensor)\n        if not self._get_grid().is_agent_valid_pos(new_vertex_pos):\n            return None\n        return Vertex(new_vertex_pos)\n\n    def _line_collision_free_lazy(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        for pt in line_seq:\n            if not self._get_grid().is_agent_valid_pos(pt):\n                return False\n        return True\n\n    def _rewire(self, graph: Forest, q_new: Vertex, Q_near: list) -> None:\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n            if dist > self._max_dist:\n                continue\n            new_cost = q_new.cost + dist\n            if new_cost + self._heuristic_cost(q_near.position) < q_near.cost:\n                if self._line_collision_free_lazy(q_new.position, q_near.position):\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    graph.add_edge(q_new, q_near)\n\n    def _heuristic_cost(self, pos: Point) -> float:\n        # Euclidean heuristic to goal\n        goal_pos = self._get_grid().goal.position\n        return torch.norm(pos.to_tensor() - goal_pos.to_tensor()).item()\n\n    def _connect_trees(self, v_start: Vertex, v_goal: Vertex) -> (tuple or None):\n        if not self._line_collision_free_lazy(v_start.position, v_goal.position):\n            return None\n        dist = torch.norm(v_start.position.to_tensor() - v_goal.position.to_tensor()).item()\n        total_cost = v_start.cost + dist + v_goal.cost\n        return (v_start, v_goal, total_cost)\n\n    def _extract_bidirectional_path(self, start_vertex: Vertex, goal_vertex: Vertex) -> list:\n        path_start = []\n        cur = start_vertex\n        while cur:\n            path_start.append(cur)\n            if not cur.parents:\n                break\n            # choose parent with min cost\n            min_cost = float('inf')\n            min_p = None\n            for p in cur.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_p = p\n            cur = min_p\n        path_start.reverse()\n\n        path_goal = []\n        cur = goal_vertex\n        while cur:\n            path_goal.append(cur)\n            if not cur.parents:\n                break\n            min_cost = float('inf')\n            min_p = None\n            for p in cur.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_p = p\n            cur = min_p\n        path_goal.reverse()\n\n        if len(path_goal) > 0 and len(path_start) > 0 and path_start[-1].position == path_goal[0].position:\n            path_goal = path_goal[1:]\n\n        return path_start + path_goal\n\n    def _smooth_path(self, path: list) -> list:\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = min(len(path) - 1, i + 10)\n            improved = False\n            while j > i + 1:\n                if self._line_collision_free_lazy(path[i].position, path[j].position):\n                    smoothed.append(path[j])\n                    i = j\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                smoothed.append(path[i + 1])\n                i += 1\n        # Remove duplicates if any\n        final = []\n        seen = set()\n        for v in smoothed:\n            if v.position not in seen:\n                final.append(v)\n                seen.add(v.position)\n        return final\n\n    def _sample_informed_ellipsoid(self, center: Point, c_best: float, c_min: float) -> Point:\n        # Only works correctly in 2D, fallback to uniform random if failure\n        grid_size = self._get_grid().size\n        if self._dimension != 2:\n            return None\n        try:\n            diff = c_best**2 - c_min**2\n            if diff < 0:\n                return None\n            a1 = c_best / 2\n            a2 = (diff)**0.5 / 2\n        except Exception:\n            return None\n        for _ in range(50):\n            rx, ry = torch.FloatTensor(2).uniform_(-1, 1)\n            norm = torch.norm(torch.tensor([rx.item(), ry.item()]))\n            if norm > 1e-5:\n                rx /= norm\n                ry /= norm\n                r = torch.rand(1).item() ** 0.5\n                x = r * a1 * rx.item()\n                y = r * a2 * ry.item()\n                start = self._graph_start.root_vertex_start.position\n                goal = self._graph_start.root_vertex_goal.position\n                delta = torch.tensor([goal.x - start.x, goal.y - start.y])\n                angle = torch.atan2(delta[1], delta[0]).item()\n                cos_ang = torch.cos(torch.tensor(angle)).item()\n                sin_ang = torch.sin(torch.tensor(angle)).item()\n                rot_x = cos_ang * x - sin_ang * y\n                rot_y = sin_ang * x + cos_ang * y\n                sample_x = int(round(center.x + rot_x))\n                sample_y = int(round(center.y + rot_y))\n                sample_x = max(0, min(sample_x, grid_size[0] - 1))\n                sample_y = max(0, min(sample_y, grid_size[1] - 1))\n                sample = Point(sample_x, sample_y)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        return None\n\n    def _get_random_sample(self, informed_ball_start=None, informed_ball_goal=None) -> Point:\n        import random\n        prob = random.random()\n\n        if informed_ball_start and informed_ball_goal:\n            if prob < 0.45:\n                s = self._sample_informed_ellipsoid(*informed_ball_start)\n                if s:\n                    return s\n            elif prob < 0.9:\n                s = self._sample_informed_ellipsoid(*informed_ball_goal)\n                if s:\n                    return s\n            # fallback uniform\n        elif informed_ball_start:\n            s = self._sample_informed_ellipsoid(*informed_ball_start)\n            if s:\n                return s\n        elif informed_ball_goal:\n            s = self._sample_informed_ellipsoid(*informed_ball_goal)\n            if s:\n                return s\n\n        grid_size = self._get_grid().size\n        for _ in range(400):\n            rand_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(grid_size.n_dim)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n        return self._get_grid().agent.position\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.perf_counter()\n\n        max_iterations = 20000\n        start_tree = self._graph_start\n        goal_tree = self._graph_goal\n        start_root = start_tree.root_vertex_start\n        goal_root = goal_tree.root_vertex_start\n        start_root.cost = 0.0\n        goal_root.cost = 0.0\n        self._found_path = False\n        self._best_cost = float('inf')\n        self._best_start_vertex = None\n        self._best_goal_vertex = None\n\n        for iteration in range(max_iterations):\n            if time.perf_counter() - self._start_time > self._max_time_sec:\n                break  # fail by timeout\n\n            informed_start = None\n            informed_goal = None\n\n            if self._found_path and self._best_cost < float('inf'):\n                c_min = torch.norm(start_root.position.to_tensor() - goal_root.position.to_tensor()).item()\n                c_best = self._best_cost\n                center = Point((start_root.position.x + goal_root.position.x) / 2,\n                               (start_root.position.y + goal_root.position.y) / 2)\n                informed_start = (center, c_best, c_min)\n                informed_goal = (center, c_best, c_min)\n\n            growing_start = (iteration % 2 == 0)\n            graph = start_tree if growing_start else goal_tree\n            other_graph = goal_tree if growing_start else start_tree\n\n            q_sample = self._get_random_sample(informed_ball_start=informed_start, informed_ball_goal=informed_goal)\n            q_near = self._get_nearest_vertex(graph, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            if not q_new:\n                continue\n\n            if not self._line_collision_free_lazy(q_near.position, q_new.position):\n                continue\n\n            dist_to_near = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = q_near.cost + dist_to_near\n\n            card_V = max(1, graph.size)\n            log_card_V = torch.log(torch.tensor(float(card_V) + 1e-8))\n            radius = min(self._lambda_rrt_star * ((log_card_V / card_V) ** (1.0 / self._dimension)), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(graph, q_new.position, radius)\n\n            q_min = q_near\n            c_min_vertex = q_near.cost\n            for q_near_candidate in Q_near:\n                if q_near_candidate == q_new:\n                    continue\n                dist_candidate = torch.norm(q_near_candidate.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist_candidate > self._max_dist:\n                    continue\n                cost_candidate = q_near_candidate.cost + dist_candidate\n                if cost_candidate < c_min_vertex:\n                    if self._line_collision_free_lazy(q_near_candidate.position, q_new.position):\n                        q_min = q_near_candidate\n                        c_min_vertex = cost_candidate\n\n            q_new.cost = c_min_vertex\n            graph.add_edge(q_min, q_new)\n            self._rewire(graph, q_new, Q_near)\n\n            q_near_other = self._get_nearest_vertex(other_graph, q_new.position)\n            connection = self._connect_trees(q_new, q_near_other)\n            if connection is not None:\n                (start_v, goal_v, total_cost) = connection\n                if total_cost < self._best_cost:\n                    self._best_cost = total_cost\n                    if growing_start:\n                        self._best_start_vertex = start_v\n                        self._best_goal_vertex = goal_v\n                    else:\n                        self._best_start_vertex = goal_v\n                        self._best_goal_vertex = start_v\n                    self._found_path = True\n\n            self.key_frame()\n\n        if self._found_path and self._best_start_vertex and self._best_goal_vertex:\n            path_vertices = self._extract_bidirectional_path(self._best_start_vertex, self._best_goal_vertex)\n\n            for _ in range(self._path_smooth_iterations):\n                path_vertices = self._smooth_path(path_vertices)\n\n            for vertex in path_vertices:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # fail silently after timeout or no path\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "Improved Path Planning Algorithm based on an enhanced RRT* concept with informed sampling and rewiring:\n    - Uses goal-biased sampling to focus exploration towards goal, improving planning efficiency.\n    - Applies rewiring to locally optimize path connections, improving path quality and smoothness.\n    - Uses adaptive neighborhood radius for rewiring to balance exploration vs. exploitation.\n    - Employs early termination if path to goal found, minimizing search time.\n    - Integrates timeout check ensuring search fails if exceeding 10 seconds for robustness.\n    - Uses precise collision checking via line validation for robustness.\n    - Maintains a forest graph structure for flexible path representations and fast nearest neighbor queries.\n    - Overall, this approach improves success rate, reduces path length, and smooths the resulting trajectory.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = Forest(\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n        )\n        self._graph.edges_removable = True\n        self._max_extend_dist = 12.0\n        self._rewire_radius_factor = 30.0  # factor to scale radius adaptively\n        self._goal_sample_rate = 0.2  # probability to sample goal directly\n        self._timeout_seconds = 10.0\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling with probability self._goal_sample_rate\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        dim = self._get_grid().size.n_dim\n        while True:\n            rand_coords = np.random.randint(0, self._get_grid().size, dim)\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_v: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        dir_vec = to_point.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            new_pos = to_point\n        else:\n            dir_norm = dir_vec / dist\n            new_pos_tensor = from_v.position.to_tensor() + max_dist * dir_norm\n            new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _collision_free(self, from_point: Point, to_point: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(from_point, to_point)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _near_vertices(self, new_vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], new_vertex.position, radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], new_vertex: Vertex) -> Optional[Vertex]:\n        min_cost = float('inf')\n        best_parent = None\n        for near_v in near_vertices:\n            if self._collision_free(near_v.position, new_vertex.position):\n                cost = near_v.cost + self._get_grid().get_movement_cost(near_v.position, new_vertex.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = near_v\n        if best_parent is not None:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> None:\n        for near_v in near_vertices:\n            if near_v == new_vertex:\n                continue\n            if self._collision_free(new_vertex.position, near_v.position):\n                new_cost = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, near_v.position)\n                if new_cost < near_v.cost:\n                    # Remove old edge(s) leading to near_v and add new edge from new_vertex\n                    for p in list(near_v.parents):\n                        self._graph.remove_edge(p, near_v)\n                    self._graph.add_edge(new_vertex, near_v)\n                    near_v.cost = new_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        # Extract path backward from goal to start via parents\n        path: List[Vertex] = [goal_vertex]\n        current = goal_vertex\n        while current.position != self._graph.root_vertex_start.position:\n            if not current.parents:\n                # No path to start\n                break\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Animate path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n\n        start_time = time()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        max_iter = 20000\n        found_goal = False\n\n        for iter_count in range(max_iter):\n            if time() - start_time > self._timeout_seconds:\n                # Treat as failed search due to timeout\n                break\n\n            q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._steer(q_near, q_sample, self._max_extend_dist)\n\n            if not self._collision_free(q_near.position, q_new.position):\n                continue\n\n            # Adaptive radius for rewiring (RRT* style): gamma * (log(n)/n)^(1/d)\n            n_vertices = self._graph.size + 1\n            dim = self._get_grid().size.n_dim\n            gamma = self._rewire_radius_factor\n            radius = gamma * (np.log(n_vertices) / n_vertices) ** (1.0 / dim)\n            radius = max(radius, self._max_extend_dist)\n\n            near_vertices = self._near_vertices(q_new, radius)\n            parent = self._choose_parent(near_vertices, q_new)\n            if parent is None:\n                parent = q_near\n                q_new.cost = parent.cost + self._get_grid().get_movement_cost(parent.position, q_new.position)\n\n            self._graph.add_edge(parent, q_new)\n\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex explicitly and extract path\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                goal_vertex.cost = float('inf')\n                if self._collision_free(q_new.position, goal_vertex.position):\n                    cost_to_goal = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    found_goal = True\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()\n\n        if not found_goal:\n            # No path found within constraints and timeout\n            pass  # Could raise or log failure if needed",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This algorithm integrates elements from RRT*-Smart with dynamic informed sampling and adaptive rewiring,\n    enriched with strategic goal biasing and progressive vertex pruning to boost search efficiency and path quality.\n    Key improvements:\n    - Adaptive radius shrinking for rewiring reflecting graph density growth.\n    - Periodic pruning of vertices too far from the current best path to reduce search space.\n    - Dynamic goal bias increasing as iterations progress to enhance success rate.\n    - Employs fast lazy collision checking and caching of verified edges for robustness.\n    - Implements a post-processing smoothing phase with recursive shortcut attempts.\n    The algorithm stops if it takes longer than 10 seconds and gracefully fails.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _max_radius: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _start_time: float\n    _found_path: bool\n    _best_goal_vertex: Vertex\n    _collision_cache: dict\n    _last_prune_iter: int\n    _goal_bias_increment: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        # initialize graph and parameters same as original but add new variables for improvements\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        self._max_dist = 12.0\n        self._max_radius = 40.0\n        self._lambda_rrt_star = 60.0  # slightly larger lambda to allow more rewiring radius early on\n        self._dimension = self._get_grid().size.n_dim\n\n        self._start_time = 0\n        self._found_path = False\n        self._best_goal_vertex = None\n\n        # New members\n        self._collision_cache = {}  # cache for line collision checks: (start_pos, end_pos) -> bool\n        self._last_prune_iter = 0\n        self._goal_bias_increment = 0.0\n\n        self._init_displays()\n\n\n    def _check_collision_cached(self, frm: Point, to: Point) -> bool:\n        key = (frm.values, to.values)\n        if key in self._collision_cache:\n            return self._collision_cache[key]\n        # Check reverse key as well (undirected validity)\n        key_rev = (to.values, frm.values)\n        if key_rev in self._collision_cache:\n            return self._collision_cache[key_rev]\n\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        # fast lazy collision check with early stopping\n        for pt in line_seq:\n            if not self._get_grid().is_agent_valid_pos(pt):\n                self._collision_cache[key] = False\n                return False\n        self._collision_cache[key] = True\n        return True\n\n\n    def _get_random_sample(self, informed_ball: tuple = None, goal_bias: float = 0.05) -> Point:\n        \"\"\"\n        Modified sampling with goal bias: with probability goal_bias returns goal position.\n        Uses previously provided informed ellipsoid sampling if informed_ball is defined.\n        \"\"\"\n        import random\n        if random.random() < goal_bias:\n            return self._graph.root_vertex_goal.position\n\n        grid_size = self._get_grid().size\n        if informed_ball is None:\n            # Uniform random sampling valid for whole space\n            while True:\n                rand_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(grid_size.n_dim)]\n                sample = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            c_best = informed_ball[1]\n            c_min = informed_ball[2]\n            center = informed_ball[0]\n\n            if grid_size.n_dim != 2:\n                # fallback to uniform if not 2D\n                return self._get_random_sample(None, goal_bias=goal_bias)\n\n            for _ in range(200):\n                rx = torch.FloatTensor(1).uniform_(-1, 1).item()\n                ry = torch.FloatTensor(1).uniform_(-1, 1).item()\n                norm = (rx ** 2 + ry ** 2) ** 0.5\n                if norm > 1e-5:\n                    break\n            else:\n                return self._get_random_sample(None, goal_bias=goal_bias)\n\n            rx /= norm\n            ry /= norm\n\n            r = torch.FloatTensor(1).uniform_(0, 1).item() ** (1 / 2)\n            a1 = c_best / 2\n            a2 = (c_best ** 2 - c_min ** 2) ** 0.5 / 2\n\n            x = r * a1 * rx\n            y = r * a2 * ry\n\n            start = self._graph.root_vertex_start.position\n            goal = self._graph.root_vertex_goal.position\n            delta = torch.tensor([goal.x - start.x, goal.y - start.y])\n            angle = torch.atan2(delta[1], delta[0]).item()\n\n            cos_ang = torch.cos(torch.tensor(angle))\n            sin_ang = torch.sin(torch.tensor(angle))\n            rot_x = cos_ang * x - sin_ang * y\n            rot_y = sin_ang * x + cos_ang * y\n\n            sample_x = int(round(center.x + rot_x))\n            sample_y = int(round(center.y + rot_y))\n\n            # Clamp inside grid\n            sample_x = max(0, min(sample_x, grid_size[0] - 1))\n            sample_y = max(0, min(sample_y, grid_size[1] - 1))\n\n            sample = Point(sample_x, sample_y)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            else:\n                return self._get_random_sample(None, goal_bias=goal_bias)\n\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        # Use graph's nearest vertex search starting from root start vertices only\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> list:\n        # Returns vertices within radius from given vertex position\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec)\n        if length < 1e-6:\n            return None\n        if length <= self._max_dist:\n            new_vertex_pos = q_sample\n        else:\n            dir_normalized = dir_vec / length\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_vertex_pos = Point.from_tensor(new_pos_tensor)\n\n        if not self._get_grid().is_agent_valid_pos(new_vertex_pos):\n            return None\n        return Vertex(new_vertex_pos)\n\n\n    def _rewire(self, q_new: Vertex, Q_near: list) -> None:\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n            if dist > self._max_dist:\n                continue\n            new_cost = q_new.cost + dist\n            if q_near.cost is None or new_cost < q_near.cost:\n                if self._check_collision_cached(q_new.position, q_near.position):\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n\n    def _extract_path(self, goal_vertex: Vertex) -> list:\n        path = [goal_vertex]\n        while len(path[-1].parents) > 0:\n            min_parent = None\n            min_cost = float('inf')\n            for parent in path[-1].parents:\n                if parent.cost is not None and parent.cost < min_cost:\n                    min_cost = parent.cost\n                    min_parent = parent\n            if min_parent is None:\n                break\n            path.append(min_parent)\n        path.reverse()\n        return path\n\n\n    def _recursive_smooth_path(self, path: list, start_idx: int = 0) -> list:\n        if len(path) < 3 or start_idx >= len(path) - 2:\n            return path\n        i = start_idx\n        j = len(path) - 1\n        while j > i + 1:\n            if self._check_collision_cached(path[i].position, path[j].position):\n                # Remove intermediate vertices between i and j\n                new_path = path[: i + 1] + path[j:]\n                # Continue smoothing recursively on new path starting at i\n                return self._recursive_smooth_path(new_path, i)\n            j -= 1\n        # No shortcut found, continue smoothing from next vertex\n        return self._recursive_smooth_path(path, start_idx + 1)\n\n\n    def _prune_vertices(self, best_cost: float, start: Vertex, goal: Vertex) -> None:\n        # Prune vertices whose cost estimate (cost + heuristic) exceeds current best_cost * 1.05 margin\n        margin = 1.05\n        to_remove = []\n        for v in list(self._graph.root_vertex_start.children) + [self._graph.root_vertex_start]:\n            # Use heuristic as straight-line distance to goal\n            heuristic = torch.norm(v.position.to_tensor() - goal.position.to_tensor()).item()\n            if v.cost is None or (v.cost + heuristic) > best_cost * margin:\n                to_remove.append(v)\n        # Remove pruned vertices & detach from graph\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n        # No guarantee all pruned vertices removed from root vertices list, but they won't be connected\n\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.perf_counter()\n        max_time_sec = 10.0\n\n        start: Vertex = self._graph.root_vertex_start\n        goal: Vertex = self._graph.root_vertex_goal\n\n        start.cost = 0.0\n        best_cost = float('inf')\n        best_goal_vertex: Vertex = None\n\n        max_iterations = 20000  # Increased iterations to allow more refinement\n        self._found_path = False\n\n        for iteration in range(max_iterations):\n            elapsed = time.perf_counter() - self._start_time\n            if elapsed > max_time_sec:\n                # Fail safely on timeout\n                break\n\n            # Gradually increase goal bias from 5% up to 30%\n            goal_bias = min(0.05 + 0.000012 * iteration, 0.3)\n\n            if self._found_path and best_goal_vertex is not None and best_cost < float('inf'):\n                c_min = torch.norm(start.position.to_tensor() - goal.position.to_tensor()).item()\n                c_best = best_cost\n                center = Point((start.position.x + goal.position.x) / 2, (start.position.y + goal.position.y) / 2)\n                informed_ball = (center, c_best, c_min)\n                q_sample = self._get_random_sample(informed_ball=informed_ball, goal_bias=goal_bias)\n            else:\n                q_sample = self._get_random_sample(goal_bias=goal_bias)\n\n            q_near = self._get_nearest_vertex(q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            if q_new is None:\n                continue\n\n            if not self._check_collision_cached(q_near.position, q_new.position):\n                continue\n\n            cost_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = cost_to_new\n\n            card_V = max(1, self._graph.size)\n            log_card_V = torch.log(torch.tensor(float(card_V) + 1e-8))\n            # Adaptive rewiring radius shrinks slightly as graph grows\n            radius = min(\n                self._lambda_rrt_star * ((log_card_V / card_V) ** (1.0 / self._dimension)),\n                self._max_radius,\n                self._max_dist * 5\n            )\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent in Q_near by cost + collision-free check\n            q_min = q_near\n            c_min_vertex = q_near.cost\n            for q_near_candidate in Q_near:\n                if q_near_candidate == q_new:\n                    continue\n                dist = torch.norm(q_near_candidate.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist > self._max_dist:\n                    continue\n                cost_candidate = q_near_candidate.cost + dist\n                if cost_candidate < c_min_vertex:\n                    if self._check_collision_cached(q_near_candidate.position, q_new.position):\n                        q_min = q_near_candidate\n                        c_min_vertex = cost_candidate\n\n            q_new.cost = c_min_vertex\n            self._graph.add_edge(q_min, q_new)\n\n            self._rewire(q_new, Q_near)\n\n            # Check if q_new reached goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = torch.norm(q_new.position.to_tensor() - goal.position.to_tensor()).item()\n                total_cost = q_new.cost + dist_to_goal\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_goal_vertex = q_new\n                    self._found_path = True\n\n            # Periodic pruning of vertices every 500 iterations to keep graph compact\n            if self._found_path and (iteration - self._last_prune_iter) >= 500:\n                self._prune_vertices(best_cost, start, goal)\n                self._last_prune_iter = iteration\n\n            self.key_frame()\n\n        if self._found_path and best_goal_vertex is not None:\n            path_vertices = self._extract_path(best_goal_vertex)\n            path_vertices = self._recursive_smooth_path(path_vertices)\n            for vertex in path_vertices:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # No path found or timed out, implicit fail (do nothing)\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm": "This improved path planning algorithm extends RRT with tuned parameters and enhancements:\n    - Adaptive max extension distance based on environment size for better exploration-exploitation balance.\n    - Goal biasing to sample the goal position with a fixed probability to improve convergence speed.\n    - Radius-based rewiring (inspired by RRT*) to reduce path cost and smoothness by connecting new vertices to near neighbors.\n    - Early termination on success.\n    - Time cutoff at 60 seconds to mark planning as failed if no path found.\n    - Move cost minimization during rewiring to improve path quality.\n    - Uses Forest graph for connectivity and path extraction.\n    - Designed for robust performance across varying map sizes with improved efficiency, path length, smoothness, and success rate.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True  # allow rewiring updates\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self, goal_bias: float) -> Point:\n        \"\"\"\n        With probability goal_bias, return the goal position directly for goal biasing.\n        Otherwise, uniformly sample a valid random position.\n        \"\"\"\n        if np.random.rand() < goal_bias:\n            return self._get_grid().goal.position\n        size = self._get_grid().size\n        max_tries = 1000\n        for _ in range(max_tries):\n            rand_coords = np.random.randint(0, size, size.n_dim)\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n        # Fallback to goal point if no valid random sample found after many tries\n        return self._get_grid().goal.position\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n\n        path: List[Vertex] = [goal_v]\n        while path[-1].parents:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n\n        # Remove last (start vertex duplicate) and reverse path\n        path.pop()\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"\n        Find vertices within a radius of q_new in the start root vertices.\n        \"\"\"\n        near_vertices = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n        return near_vertices\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        Choose the best parent for q_new from vertices in near_vertices minimizing cost.\n        \"\"\"\n        best_parent = None\n        best_cost = math.inf\n        for v in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            cost = v.cost if v.cost is not None else 0\n            cost += self._get_grid().get_movement_cost(v.position, q_new.position)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = best_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Rewire near vertices to q_new if it improves cost.\n        \"\"\"\n        for v in near_vertices:\n            if v == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n            old_cost = v.cost if v.cost is not None else math.inf\n            if new_cost < old_cost:\n                # Remove old parent edge(s)\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                # Add edge from q_new to v\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n\n    def _initialize_costs(self) -> None:\n        \"\"\"\n        Initialize cost of root vertex start to zero and others None.\n        \"\"\"\n        self._graph.root_vertex_start.cost = 0\n        # Initialize all other vertices (if any) cost to none\n        for v in self._graph.root_vertices:\n            if v != self._graph.root_vertex_start:\n                v.cost = None\n\n    def _find_path_internal(self) -> None:\n        max_iter = 12000\n        grid_size_tensor = self._get_grid().size.to_tensor()\n        max_dist = max(5.0, 0.1 * torch.norm(grid_size_tensor).item())  # adaptive max dist\n        goal_sample_rate = 0.15  # probability of sampling goal directly for bias\n        radius_factor = 50.0     # for neighbor radius calculation (tunable)\n\n        start_time = time.time()\n        self._initialize_costs()\n\n        for i in range(max_iter):\n            if time.time() - start_time > 60:\n                # Fail: timeout after 60 seconds\n                break\n\n            q_sample = self._get_random_sample(goal_sample_rate)\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors for rewiring, radius = min(radius_factor*sqrt(log(n)/n), max_dist)\n            n_vertices = self._graph.size if self._graph.size > 0 else 1\n            radius = min(radius_factor * math.sqrt(math.log(n_vertices) / n_vertices), max_dist)\n\n            near_vertices = self._find_near_vertices(q_new, radius)\n            parent = self._choose_parent(near_vertices, q_new) or q_near\n\n            self._graph.add_edge(parent, q_new)\n            # q_new.cost already set in _choose_parent, else assign cost\n            if q_new.cost is None:\n                q_new.cost = (parent.cost if parent.cost else 0) + self._get_grid().get_movement_cost(parent.position, q_new.position)\n\n            # Rewire near vertices to q_new if beneficial\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm": "This is an improved sample-based path planning algorithm inspired by RRT* and SPRM,\n    using an adaptive radius rewiring strategy with dynamic sampling bias towards the goal.\n    \n    Improvements include:\n    - Adaptive neighborhood radius based on iteration and graph size to balance exploration/exploitation.\n    - Goal-bias sampling to speed convergence.\n    - Early rewiring via multiple near vertices to improve path quality and smoothness.\n    - Time limit enforcement (60 seconds) for robustness and failure detection.\n    - Uses cyclic graph to allow connectivity improvements and multiple paths exploration.\n    - Uses cost-based rewiring like RRT* for optimization but with cyclic connectivity.\n    - Extracts the best path found once goal is reachable.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _V_size: int = 250\n    _max_dist: float = 12.0\n    _max_radius: float = 30.0\n    _goal_sample_rate: float = 0.15  # 15% of samples biased towards goal\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        V: List[Vertex] = []\n        grid = self._get_grid()\n        for i in range(self._V_size):\n            V.append(Vertex(self._get_random_sample(), store_connectivity=True))\n\n        start_vertex = Vertex(grid.agent.position, store_connectivity=True)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(grid.goal.position, store_connectivity=True)\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, V)\n        self._graph.edges_removable = True  # allow edge rewiring\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        grid = self._get_grid()\n        if torch.rand(1).item() < self._goal_sample_rate:\n            return grid.goal.position\n        while True:\n            sample = Point(*[torch.randint(0, grid.size[i], (1,)).item() for i in range(grid.size.n_dim)])\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point, vertices: Optional[List[Vertex]] = None) -> Vertex:\n        if vertices is None:\n            vertices = self._graph.root_vertices + self._graph.root_vertices[0].connectivity\n        return self._graph.get_nearest_vertex(vertices, q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        vertices = self._graph.root_vertices + list(self._graph.root_vertices[0].connectivity)\n        candidates = self._graph.get_vertices_within_radius(vertices, q_new.position, radius)\n        return candidates\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_tensor)\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        dir_normalized = dir_tensor / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        return self._get_grid().get_movement_cost(frm.position, to.position)\n\n    def _extract_path(self) -> None:\n        start = self._graph.root_vertex_start\n        goal = self._graph.root_vertex_goal\n        # Find best path from start to goal by DFS selecting lowest cost child at each step\n        path = []\n        current = start\n\n        visited = set()\n        while current is not None and current != goal:\n            visited.add(current)\n            children = list(current.connectivity)\n            if not children:\n                break\n            # Find child that leads closer to goal with minimal cost\n            next_vertex = None\n            min_cost = float('inf')\n            for ch in children:\n                if ch in visited:\n                    continue\n                est_cost = ch.cost if ch.cost is not None else float('inf')\n                if est_cost < min_cost:\n                    min_cost = est_cost\n                    next_vertex = ch\n            if next_vertex is None:\n                break\n            path.append(next_vertex)\n            current = next_vertex\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start_time = time.time()\n\n        max_iterations = 12000\n        dimension = grid.size.n_dim\n        lambda_rrt_star = 50\n\n        root_start = self._graph.root_vertex_start\n        root_goal = self._graph.root_vertex_goal\n\n        # Initialize cost for start vertex\n        root_start.cost = 0.0\n\n        all_vertices = self._graph.root_vertices + list(self._graph.root_vertex_start.connectivity)\n\n        iteration = 0\n\n        while iteration < max_iterations:\n            current_time = time.time()\n            if current_time - start_time > 60:\n                # Timeout: mark failure by simply returning without path extraction\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample, self._graph.root_vertices + list(self._graph.root_vertex_start.connectivity))\n\n            if q_nearest.position == q_sample:\n                iteration += 1\n                self.key_frame()\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                iteration += 1\n                self.key_frame()\n                continue\n\n            # Adaptive radius for neighbor search using RRT* formula\n            card_v = max(len(self._graph.root_vertices) + len(self._graph.root_vertex_start.connectivity), 1)\n            radius = min(lambda_rrt_star * ((math.log(card_v) / card_v) ** (1 / dimension)), self._max_radius)\n\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent to minimize cost for q_new\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._cost(q_nearest, q_new) if q_nearest.cost is not None else float('inf')\n\n            for q_near in neighbors:\n                if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                    continue\n                cost_candidate = (q_near.cost if q_near.cost else float('inf')) + self._cost(q_near, q_new)\n                if cost_candidate < c_min:\n                    q_min = q_near\n                    c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if it improves their cost\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position)):\n                    continue\n                cost_through_qnew = q_new.cost + self._cost(q_new, q_near)\n                if cost_through_qnew < (q_near.cost if q_near.cost is not None else float('inf')):\n                    # Remove old edge(s) from parent(s) of q_near\n                    for parent in list(q_near.parents):\n                        self._graph.remove_edge(parent, q_near)\n                    # Add edge from q_new to q_near\n                    q_near.cost = cost_through_qnew\n                    self._graph.add_edge(q_new, q_near)\n\n            # Add q_new to root vertices to keep track\n            self._graph.root_vertices.append(q_new)\n\n            # Check if new vertex is within goal radius and path can be extracted\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex if collision-free\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, root_goal.position)):\n                    dist_to_goal = self._cost(q_new, root_goal)\n                    total_cost = (q_new.cost if q_new.cost else float('inf')) + dist_to_goal\n                    if root_goal.cost is None or total_cost < root_goal.cost:\n                        # Rewire goal parent if needed\n                        for parent in list(root_goal.parents):\n                            self._graph.remove_edge(parent, root_goal)\n                        root_goal.cost = total_cost\n                        self._graph.add_edge(q_new, root_goal)\n                # Extract and move along path\n                self._extract_path()\n                return\n\n            iteration += 1\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm": "This algorithm implements an improved Fast Marching Tree inspired sample-based path planning approach,\n    blending efficient tree extension with adaptive rewiring for path quality enhancement.\n    It uses informed sampling biased towards the goal region for efficiency, \n    maintains a graph to connect vertices with collision-free edges,\n    and employs rewiring to reduce path lengths and improve smoothness.\n    The planning process terminates successfully upon reaching the goal or fails if exceeding 60 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _start_time: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._max_dist = max(self._get_grid().size.width, self._get_grid().size.height) / 10.0\n        self._iterations = 15000\n        self._start_time = 0\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            []\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    # Helper Functions #\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _get_random_sample(self, goal_bias=0.15) -> Point:\n        # Informed sampling biasing towards the goal, or uniform random otherwise\n        if self._get_grid().is_agent_in_goal_radius():\n            # If goal reached, return goal directly (helps path extraction)\n            return self._get_grid().goal.position\n\n        if torch.rand(1).item() < goal_bias:\n            # Sample near goal with small random offset\n            offset_range = self._max_dist * 3\n            while True:\n                offset = torch.randint(-int(offset_range), int(offset_range)+1, (self._get_grid().size.n_dim,))\n                candidate = Point(*[int(c) for c in (self._get_grid().goal.position.to_tensor() + offset).tolist()])\n                if self._valid_sample(candidate):\n                    return candidate\n        else:\n            # Uniform random sample inside map bounds\n            while True:\n                sample_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)]\n                candidate = Point(*sample_coords)\n                if self._valid_sample(candidate):\n                    return candidate\n\n    def _valid_sample(self, sample: Point) -> bool:\n        return self._get_grid().is_agent_valid_pos(sample)\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_length: float) -> Vertex:\n        vec = to_point.to_tensor() - from_vertex.position.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_length:\n            q_new_pos = to_point\n        else:\n            direction = vec / dist\n            q_new_pos = Point.from_tensor(from_vertex.position.to_tensor() + max_length * direction)\n            # Snap to grid coordinates (integer) if grid is discrete\n            q_new_pos = Point(*map(int, q_new_pos.values))\n        return Vertex(q_new_pos, store_connectivity=True)\n\n    def _collision_free(self, p1: Point, p2: Point) -> bool:\n        line_pts = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_pts)\n\n    def _nearest_vertex(self, vertices_list: List[Vertex], point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(vertices_list, point)\n\n    def _get_near_vertices(self, vertices_list: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(vertices_list, point, radius)\n\n    def _rewire(self, vertex_new: Vertex, near_vertices: List[Vertex]) -> None:\n        best_parent = None\n        min_cost = None\n\n        for near_v in near_vertices:\n            if near_v == vertex_new:\n                continue\n            if not self._collision_free(near_v.position, vertex_new.position):\n                continue\n            cost = near_v.cost if near_v.cost is not None else 0\n            cost += self._get_grid().get_distance(near_v.position, vertex_new.position)\n            if (min_cost is None) or (cost < min_cost):\n                min_cost = cost\n                best_parent = near_v\n\n        if best_parent is not None:\n            # If vertex_new has previous parent edges, remove to keep tree consistency\n            for p in list(vertex_new.parents):\n                self._graph.remove_edge(p, vertex_new)\n            self._graph.add_edge(best_parent, vertex_new)\n            vertex_new.cost = min_cost\n\n            # Try to rewire neighbors through new vertex if better\n            for near_v in near_vertices:\n                if near_v == vertex_new:\n                    continue\n                if not self._collision_free(vertex_new.position, near_v.position):\n                    continue\n                new_cost = vertex_new.cost + self._get_grid().get_distance(vertex_new.position, near_v.position)\n                if near_v.cost is None or new_cost < near_v.cost:\n                    # Remove old parent edges of near_v, add new parent edge vertex_new -> near_v\n                    for p in list(near_v.parents):\n                        self._graph.remove_edge(p, near_v)\n                    self._graph.add_edge(vertex_new, near_v)\n                    near_v.cost = new_cost\n\n    def _extract_path(self) -> None:\n        path = []\n        goal_vertex = self._graph.root_vertex_goal\n        if goal_vertex.cost is None:\n            return  # no path\n\n        current_vertex = goal_vertex\n        while current_vertex is not None:\n            path.append(current_vertex.position)\n            if not current_vertex.parents:\n                break\n            # Pick parent with lowest cost\n            current_vertex = min(current_vertex.parents, key=lambda p: 0 if p.cost is None else p.cost)\n        path.reverse()\n\n        for point in path:\n            self.move_agent(point)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Main Algorithm #\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n\n        # Initialize root start vertex cost to 0\n        self._graph.root_vertex_start.cost = 0.0\n\n        vertices = [self._graph.root_vertex_start, self._graph.root_vertex_goal]\n\n        for iter_i in range(self._iterations):\n            if time.time() - self._start_time > 60:\n                # Failed due to time out\n                break\n\n            q_rand = self._get_random_sample()\n\n            q_near = self._nearest_vertex(vertices, q_rand)\n            q_new = self._steer(q_near, q_rand, self._max_dist)\n\n            if not self._get_grid().is_agent_valid_pos(q_new.position):\n                continue\n\n            if not self._collision_free(q_near.position, q_new.position):\n                continue\n\n            # Add vertex and edge\n            if q_new not in vertices:\n                vertices.append(q_new)\n\n            # Set cost for new vertex assuming parent cost + edge cost\n            cost_to_new = (q_near.cost if q_near.cost is not None else 0) + self._get_grid().get_distance(q_near.position, q_new.position)\n            q_new.cost = cost_to_new\n\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire neighbors for better path costs\n            radius_rewire = self._max_dist * 2.0\n            near_vertices = self._get_near_vertices(vertices, q_new.position, radius_rewire)\n            self._rewire(q_new, near_vertices)\n\n            # Attempt to connect new vertex directly to goal if close enough and collision free\n            dist_goal = self._distance(q_new.position, self._graph.root_vertex_goal.position)\n            if dist_goal <= self._max_dist and self._collision_free(q_new.position, self._graph.root_vertex_goal.position):\n                # Connect and update cost for goal vertex\n                goal_cost = q_new.cost + dist_goal\n                if self._graph.root_vertex_goal.cost is None or goal_cost < self._graph.root_vertex_goal.cost:\n                    for p in list(self._graph.root_vertex_goal.parents):\n                        self._graph.remove_edge(p, self._graph.root_vertex_goal)\n                    self._graph.add_edge(q_new, self._graph.root_vertex_goal)\n                    self._graph.root_vertex_goal.cost = goal_cost\n                # Path found, extract path\n                self._extract_path()\n                return\n\n            self.key_frame()\n        # If we reach here, no path found or timeout\n        return",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm": "Improved Path Planning Algorithm combining Rapidly-exploring Random Trees and informed heuristics.\n     - Utilizes bidirectional RRT with adaptive sampling biased toward the goal to improve planning efficiency.\n     - Incorporates path smoothing using shortcutting to improve path quality and smoothness.\n     - Uses dynamic max extension distances based on current tree dispersion.\n     - Incorporates timeout handling to abort if planning takes more than 60 seconds.\n     - Employs early stopping upon detecting goal reach.\n     - Manages environment validity checks using efficient line and vertex validations.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist_initial = 20.0\n        self._max_dist_min = 5.0\n        self._iterations = 15000\n        self._timeout_seconds = 60.0\n\n        agent_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n\n        self._start_vertex = Vertex(agent_pos)\n        self._goal_vertex = Vertex(goal_pos)\n        self._graph = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n        self._graph.edges_removable = False\n\n        self._init_displays()\n\n    def _get_random_sample(self, goal_bias: float = 0.1) -> Point:\n        # Biased sampling: with probability goal_bias, sample goal point, else random valid sample\n        if torch.rand(1).item() < goal_bias:\n            return self._goal_vertex.position\n        while True:\n            sample_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir_vec)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n        dir_unit = dir_vec / norm_dir\n        q_new_coords = q_near.position.to_tensor() + dir_unit * max_dist\n        q_new_point = Point.from_tensor(q_new_coords)\n        return Vertex(q_new_point)\n\n    def _extend(self, root_vertex: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        q_near = self._graph.get_nearest_vertex([root_vertex], q_sample)\n        q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n        if self._get_grid().is_valid_line_sequence(line_seq):\n            self._graph.add_edge(q_near, q_new)\n            return q_new\n        return None\n\n    def _path_from_vertices(self, connect_vertex_start: Vertex, connect_vertex_goal: Vertex) -> List[Vertex]:\n        # Retrieve path by walking from connect_vertex_start to root and connect_vertex_goal to root\n        path_start = []\n        cur = connect_vertex_start\n        while cur.parents:\n            path_start.append(cur)\n            cur = next(iter(cur.parents))\n        path_start.append(cur)  # Add root\n        path_start.reverse()\n\n        path_goal = []\n        cur = connect_vertex_goal\n        while cur.parents:\n            path_goal.append(cur)\n            cur = next(iter(cur.parents))\n\n        return path_start + path_goal\n\n    def _smooth_path(self, path: List[Vertex], attempts: int = 30) -> List[Vertex]:\n        # Shortcut smoothing by attempting to replace intermediate segments with direct connections\n        if len(path) <= 2:\n            return path\n        for _ in range(attempts):\n            if len(path) < 3:\n                break\n            i = torch.randint(0, len(path)-2, (1,)).item()\n            j = torch.randint(i+2, len(path), (1,)).item()\n            p1 = path[i].position\n            p2 = path[j].position\n            line_seq = self._get_grid().get_line_sequence(p1, p2)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                # Remove intermediate vertices between i and j\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _extract_and_move_path(self, connect_vertex_start: Vertex, connect_vertex_goal: Vertex) -> None:\n        path_vertices = self._path_from_vertices(connect_vertex_start, connect_vertex_goal)\n        path_vertices = self._smooth_path(path_vertices)\n\n        for v in path_vertices:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _adaptive_max_dist(self, iteration: int) -> float:\n        # Gradually reduce max extension distance to improve refinement later\n        decay = 0.995 ** iteration\n        max_dist = max(self._max_dist_min, self._max_dist_initial * decay)\n        return max_dist\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        tree_start = self._graph.root_vertices[0]\n        tree_goal = self._graph.root_vertices[-1]\n\n        for i in range(self._iterations):\n            # Check timeout\n            if time.time() - start_time > self._timeout_seconds:\n                # Treat as failure to find path within time\n                return\n\n            max_dist = self._adaptive_max_dist(i)\n\n            q_rand = self._get_random_sample(goal_bias=0.2)  # More goal bias for efficiency\n\n            q_new_start = self._extend(tree_start, q_rand, max_dist)\n            if q_new_start is not None:\n                # Try to connect goal tree to q_new_start\n                while True:\n                    q_new_goal = self._extend(tree_goal, q_new_start.position, max_dist)\n                    if q_new_goal is None:\n                        break\n                    dist = torch.norm(q_new_goal.position.to_tensor() - q_new_start.position.to_tensor())\n                    if dist < 1e-3 or self._get_grid().is_goal_reached(q_new_goal.position, self._get_grid().goal):\n                        self._extract_and_move_path(q_new_start, q_new_goal)\n                        return\n\n                # Swap roles (start <-> goal) for next iteration (bidirectional)\n                self._graph.reverse_root_vertices()\n                tree_start, tree_goal = self._graph.root_vertices[0], self._graph.root_vertices[-1]\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm": "This improved path planning algorithm is an enhanced RRT* inspired approach with optimized sampling,\n    dynamic max extension distance tuned to map size, informed sampling bias towards the goal,\n    rewiring for path quality improvement, early stopping upon goal reach with smooth path extraction,\n    and a 60-second timeout for robustness.\n\n    Key improvements:\n    - Uses dynamic max extension distance proportional to map size for balanced exploration.\n    - Implements RRT* rewiring to improve path quality and smoothness.\n    - Informed sampling bias (goal bias) to increase efficiency.\n    - Uses nearest vertices within radius for rewiring.\n    - Stops search immediately if path is found or after 60s timeout.\n    - Extracts the best cost path to goal, providing shorter and smoother routes.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services: \"Services\", testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True  # allow edge removal for rewiring\n        self._init_displays()\n\n    def _get_random_sample(self, goal_sample_prob: float = 0.1) -> Point:\n        # With probability goal_sample_prob, sample the goal directly (informed bias)\n        if np.random.random() < goal_sample_prob:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vector = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vector).item()\n        if dist <= max_dist:\n            new_pt = q_sample\n        else:\n            dir_normalized = dir_vector / dist\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * max_dist\n            new_pt = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pt)\n\n    def _get_nearest_vertex(self, vertices: List[Vertex], point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(vertices, point)\n\n    def _get_vertices_within_radius(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(vertices, point, radius)\n\n    def _choose_parent(self, q_near_candidates: List[Vertex], q_new: Vertex) -> Tuple[Optional[Vertex], float]:\n        min_cost = math.inf\n        best_parent = None\n        grid = self._get_grid()\n        for q_near in q_near_candidates:\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost = q_near.cost if q_near.cost is not None else 0\n            cost += grid.get_movement_cost(q_near.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = q_near\n        return (best_parent, min_cost)\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]):\n        grid = self._get_grid()\n        for q_near in neighbors:\n            if q_near == q_new.parents:\n                continue\n            line_seq = grid.get_line_sequence(q_new.position, q_near.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_through_new = (q_new.cost if q_new.cost is not None else 0) + grid.get_movement_cost(q_new.position, q_near.position)\n            if q_near.cost is None or cost_through_new < q_near.cost:\n                # Update graph edges\n                for p in list(q_near.parents):\n                    self._graph.remove_edge(p, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = cost_through_new\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n        # We walk back via parents with minimal cost to build path\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            # pick parent with minimum cost\n            min_cost_parent = None\n            min_cost = math.inf\n            for p in current.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_cost_parent = p\n            if min_cost_parent is None:\n                break\n            path.append(min_cost_parent)\n            current = min_cost_parent\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start = self._graph.root_vertex_start\n        start.cost = 0.0\n        goal_pos = grid.goal.position\n\n        # Dynamic max distance scaled to map diagonal length\n        map_dims = np.array(grid.size.values, dtype=float)\n        map_diag = np.linalg.norm(map_dims)\n        max_dist = max(1.0, map_diag * 0.1)  # 10% of diagonal or at least 1.0\n        \n        # Radius for rewiring: use formula from RRT*\n        gamma_rrt = 50.0\n        dimension = grid.size.n_dim\n        r_rrt = min(gamma_rrt * ((math.log(self._graph.size + 1) / (self._graph.size + 1)) ** (1/dimension)), max_dist)\n\n        iterations = 10000\n        start_time = time.time()\n\n        for i in range(iterations):\n            if time.time() - start_time > 60:  # timeout after 60 seconds\n                # Consider path search as failed\n                break\n\n            q_sample = self._get_random_sample(goal_sample_prob=0.15)\n            q_near = self._get_nearest_vertex([self._graph.root_vertex_start] + self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n            \n            # Find neighbors for rewiring\n            neighborhood = self._get_vertices_within_radius([self._graph.root_vertex_start] + self._graph.root_vertices, q_new.position, r_rrt)\n\n            # Choose parent with lowest cost\n            best_parent, cost_to_new = self._choose_parent(neighborhood + [q_near], q_new)\n            if best_parent is None:\n                continue  # no valid parent\n\n            q_new.cost = cost_to_new\n            self._graph.add_edge(best_parent, q_new)\n            self._graph.root_vertices.append(q_new)\n\n            # Rewire neighbors\n            self._rewire(q_new, neighborhood)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                q_goal = Vertex(goal_pos)\n                q_goal.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_pos)\n                # Check line validity before connecting to goal\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_pos)):\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm": "Improved RRT* inspired path planning algorithm with adaptive sampling and rewiring.\n    Enhancements over classical RRT include:\n    - Adaptive step size based on proximity to goal for better path refinement.\n    - Rewiring of the tree within a neighborhood to improve path quality and smoothness.\n    - Goal biasing in sampling to increase the success rate.\n    - Limit on maximum runtime (60s) to ensure robustness and prevent long computations.\n    - Utilizes nearest vertex search and local radius neighborhoods efficiently.\n    - Extracts path upon reaching the goal region and animates smooth path traversal.\n    Designed to improve planning efficiency, path quality, robustness, and reduce search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_v = Vertex(self._get_grid().agent.position)\n        goal_v = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_v, goal_v, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_tensor).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_tensor / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new = Point.from_tensor(new_pos_tensor)\n        return Vertex(q_new)\n\n    def _get_random_sample(self, goal_bias: float = 0.05) -> Point:\n        # With goal_bias probability, return goal position to increase goal-directed growth\n        if np.random.rand() < goal_bias:\n            return self._get_grid().goal.position\n        size = self._get_grid().size.values\n        while True:\n            # Sample float or int coord inside map size\n            if all(isinstance(i, float) for i in size):\n                rand_pos = np.random.uniform(0, size, len(size))\n            else:\n                rand_pos = np.random.randint(0, size, len(size))\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)  # connect last point to goal vertex\n        path: List[Vertex] = [goal_v]\n        # Reconstruct path from goal to start\n        while len(path[-1].parents) != 0:\n            # Since this is a tree, can take any parent (should be one)\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        path.pop()  # remove the root start vertex duplicate\n        path.reverse()\n\n        # Animate agent along path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_neighbors_within_radius(self, point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], point, radius)\n\n    def _choose_parent(self, q_new: Vertex, neighbors: List[Vertex]) -> Optional[Vertex]:\n        \"\"\"Chooses parent for q_new that yields the minimum cost.\"\"\"\n        min_cost = None\n        best_parent = None\n        for neighbor in neighbors:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position)):\n                continue\n            cost_to_qnew = neighbor.cost if neighbor.cost is not None else 0\n            cost_move = self._get_grid().get_movement_cost(neighbor.position, q_new.position)\n            total_cost = cost_to_qnew + cost_move\n            if min_cost is None or total_cost < min_cost:\n                min_cost = total_cost\n                best_parent = neighbor\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"Try to rewire neighbors through q_new to improve path cost.\"\"\"\n        if q_new.cost is None:\n            return\n        for neighbor in neighbors:\n            if neighbor == q_new or neighbor.cost is None:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                continue\n            cost_through_qnew = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n            if cost_through_qnew < neighbor.cost:\n                # Remove old parent edge(s)\n                for parent in list(neighbor.parents):\n                    self._graph.remove_edge(parent, neighbor)\n                self._graph.add_edge(q_new, neighbor)\n                neighbor.cost = cost_through_qnew\n\n    def _init_vertex_cost(self, vertex: Vertex, cost: float) -> None:\n        vertex.cost = cost\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        max_iterations = 15000\n        # Adaptive max distance step size based on map diagonal length\n        map_size = self._get_grid().size.values\n        map_diag = np.linalg.norm(np.array(map_size))\n        max_dist_far = max(5.0, map_diag * 0.1)\n        max_dist_near = max(1.0, map_diag * 0.02)\n        neighbor_radius = max_dist_far * 2.5\n\n        # Initialize root vertex cost to zero\n        self._graph.root_vertex_start.cost = 0.0\n\n        for _ in range(max_iterations):\n            cur_time = time.time()\n            if cur_time - start_time > 60:\n                # Time limit exceeded - treat as failure\n                break\n\n            q_sample = self._get_random_sample(goal_bias=0.1)\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            dist_to_goal = self._distance(q_near.position, self._get_grid().goal.position)\n            # Reduce max_dist as we get closer to goal for path refinement\n            max_dist = max_dist_near if dist_to_goal < map_diag * 0.2 else max_dist_far\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Validate line from near to new vertex\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            neighbors = self._get_neighbors_within_radius(q_new.position, radius=neighbor_radius)\n\n            chosen_parent = self._choose_parent(q_new, neighbors + [q_near])\n            if chosen_parent is None:\n                # If no suitable parent, skip adding q_new\n                continue\n\n            q_new.cost = chosen_parent.cost + self._get_grid().get_movement_cost(chosen_parent.position, q_new.position)\n            self._graph.add_edge(chosen_parent, q_new)\n\n            # Rewire nearby vertices through q_new for better cost paths\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new is close enough to goal\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm": "This improved path planning algorithm combines the adaptive radius selection of RRT* with informed sampling \n    and dynamic rewiring to improve planning efficiency, path quality, and robustness. \n    It employs a heuristic-guided sampling biased towards the goal region (informed sampling ellipse), \n    dynamically adjusts the neighborhood radius based on the number of vertices, \n    and enforces collision-free rewiring to shorten paths and improve smoothness.\n    The algorithm terminates successfully when the agent reaches the goal radius or fails if it exceeds 60 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_planning_time = 60  # seconds\n\n        self._init_displays()\n\n    # --- Helper functions --- #\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Uses informed sampling with an ellipse defined by start, goal, and current best path length.\n        Bias sampling towards goal with 5% chance to jump directly.\n        \"\"\"\n        start: Point = self._graph.root_vertex_start.position\n        goal: Point = self._graph.root_vertex_goal.position\n\n        def dist(a: Point, b: Point) -> float:\n            return (a.to_tensor() - b.to_tensor()).norm().item()\n\n        max_dist = dist(start, goal)\n        best_goal_dist = None\n        # Try to estimate current best solution length from graph if possible\n        # fallback to direct start-goal dist if no path found yet\n        goal_vertex = self._graph.root_vertex_goal\n        if goal_vertex.cost is not None:\n            best_goal_dist = goal_vertex.cost\n        else:\n            best_goal_dist = max_dist * 1.5  # heuristic buffer\n\n        # Ellipse parameters for informed sampling\n        c_best = best_goal_dist\n        if c_best == float('inf') or c_best is None:\n            c_best = max_dist * 2.0\n\n        c_min = max_dist\n\n        # If the heuristic fails or no informative ellipse, uniformly sample\n        if c_best < c_min:\n            c_best = c_min * 1.1\n\n        # Sample roughly with 5% probability the goal directly (goal bias)\n        if torch.rand(1).item() < 0.05:\n            candidate = goal\n            if self._get_grid().is_agent_valid_pos(candidate):\n                return candidate\n\n        # Informed sampling ellipse centered between start and goal:\n        center_tensor = (start.to_tensor() + goal.to_tensor()) / 2\n        a1 = (goal.to_tensor() - start.to_tensor())\n        a1_norm = torch.norm(a1)\n        if a1_norm == 0:\n            a1_norm = 1.0\n        e1 = a1 / a1_norm\n        # radii of ellipse\n        r1 = c_best / 2\n        r2 = (r1 ** 2 - (c_min / 2) ** 2) ** 0.5 if r1 > (c_min / 2) else r1 * 0.1\n\n        while True:\n            # sample in unit circle (2D assumed)\n            sample_unit = torch.rand(2) * 2 - 1\n            if sample_unit.norm() <= 1.0:\n                break\n\n        # scale to ellipse\n        sample_ellipse = torch.zeros(2)\n        sample_ellipse[0] = sample_unit[0] * r1\n        sample_ellipse[1] = sample_unit[1] * r2\n\n        # rotation to align ellipse axis to start-goal line\n        # rotation matrix in 2D:\n        angle = torch.atan2(e1[1], e1[0])\n        rot_matrix = torch.tensor([[torch.cos(angle), -torch.sin(angle)],\n                                   [torch.sin(angle), torch.cos(angle)]])\n        sample_rotated = rot_matrix.matmul(sample_ellipse)\n\n        sample_point_tensor = center_tensor[:2] + sample_rotated\n\n        # Clamp sample_point_tensor to map bounds\n        dims = self._get_grid().size.n_dim\n        coords = []\n        for i in range(dims):\n            dim_max = self._get_grid().size[i] - 1\n            val = float(sample_point_tensor[i]) if i < 2 else torch.randint(0, dim_max + 1, (1,)).item()\n            val = max(0, min(dim_max, val))\n            coords.append(int(round(val)))  # sample discrete grid point (int)\n        candidate = Point(*coords)\n\n        # Validate sample position\n        if self._get_grid().is_agent_valid_pos(candidate):\n            return candidate\n        # fallback to uniform random sampling in rare invalid case\n        while True:\n            fallback_sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item()\n                                     for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(fallback_sample):\n                return fallback_sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dir_norm\n        q_new_pos = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new = Vertex(Point.from_tensor(q_new_pos))\n        return q_new\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n\n        path: List[Vertex] = [goal_v]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n        path.pop()  # remove the root start vertex itself added extra\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist = 15.0\n        iterations = 10000\n        max_radius = 40.0\n        lambda_rrt_star = 40.0\n        dimension = self._get_grid().size.n_dim\n\n        start_time = time()\n\n        for _ in range(iterations):\n\n            elapsed = time() - start_time\n            if elapsed > self._max_planning_time:\n                # Mark failure by skipping path extraction and returning\n                return\n\n            q_sample: Point = self._get_random_sample()\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = float(self._graph.size + 1)\n            log_card_v = max(1.0, torch.log(torch.tensor(card_v)).item())\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent with minimal cost + collision free\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            for q_near in Q_near:\n                line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if new path is better and collision free\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if cost_new_to_near < q_near.cost:\n                    # Remove old parent edge\n                    old_parent = next(iter(q_near.parents), None)\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = None\n                    # Add new edge and update cost\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm": "This algorithm is a hybrid sampling-based planner inspired by RRT, RRT-Connect, and informed RRT* approaches. \n    It builds two trees: one from the start and one from the goal, attempts to connect them efficiently, and incrementally rewires \n    nodes to improve path cost and smoothness. A heuristic-informed sampling bias around the current best path and goal region \n    guides the growth for faster convergence and better path quality. It also implements early stopping upon success or after 60s timeout \n    to ensure robustness and timely termination.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _timeout: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_cyclic_graph(self._services, \n                                       Vertex(self._get_grid().agent.position), \n                                       Vertex(self._get_grid().goal.position), \n                                       [])\n        self._graph.edges_removable = True  # Allow rewiring for improving path quality\n        self._max_dist = 12.0\n        self._iterations = 15000\n        self._timeout = 60.0  # seconds\n        self._init_displays()\n\n    def _get_random_sample(self, best_path: Optional[List[Vertex]]=None) -> Point:\n        # Heuristic informed bias sampling to improve efficiency:\n        # 70% chance sample uniformly in free space,\n        # 20% sample near the goal area,\n        # 10% sample near current best path nodes (local refinement).\n        grid = self._get_grid()\n        rand_val = np.random.rand()\n        if best_path and len(best_path) > 2 and rand_val > 0.8:\n            # Sampling near best path vertex chosen randomly\n            path_vertex = best_path[np.random.randint(0, len(best_path))]\n            radius = self._max_dist * 1.5\n            attempt = 0\n            while attempt < 10:\n                offset = np.random.uniform(-radius, radius, grid.size.n_dim)\n                sample_coords = path_vertex.position.to_tensor().numpy() + offset\n                # Clamp coordinates inside the map grid size\n                sample_coords = np.clip(sample_coords, 0, np.array(grid.size.values) - 1)\n                sample_point = Point(*sample_coords.astype(int))\n                if grid.is_agent_valid_pos(sample_point):\n                    return sample_point\n                attempt += 1\n        elif rand_val > 0.6:\n            # Sample near goal within radius max_dist*2\n            goal = grid.goal.position\n            radius = self._max_dist * 2\n            attempt = 0\n            while attempt < 20:\n                offset = np.random.uniform(-radius, radius, grid.size.n_dim)\n                sample_coords = goal.to_tensor().numpy() + offset\n                sample_coords = np.clip(sample_coords, 0, np.array(grid.size.values) - 1)\n                sample_point = Point(*sample_coords.astype(int))\n                if grid.is_agent_valid_pos(sample_point):\n                    return sample_point\n                attempt += 1\n        # Default uniform random sampling\n        attempt = 0\n        while True:\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n            attempt += 1\n            if attempt > 50:  # fallback in case no positions found - unlikely\n                return grid.agent.position\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_tensor)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_tensor / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _line_is_valid(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _get_vertices_near(self, root_vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(root_vertices, point, radius)\n\n    def _choose_parent(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> Optional[Vertex]:\n        # Choose the parent from near vertices that minimizes cost + edge cost and is collision free\n        min_cost = float('inf')\n        best_parent = None\n        grid = self._get_grid()\n        for v in near_vertices:\n            if self._line_is_valid(v.position, new_vertex.position):\n                cost = (v.cost if v.cost is not None else 0.0) + grid.get_movement_cost(v.position, new_vertex.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = v\n        if best_parent:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> None:\n        # Attempt to improve path costs by rewiring near vertices through new_vertex if better\n        grid = self._get_grid()\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex.parents or near_vertex == new_vertex:\n                continue\n            if self._line_is_valid(new_vertex.position, near_vertex.position):\n                cost_through_new = new_vertex.cost + grid.get_movement_cost(new_vertex.position, near_vertex.position)\n                if near_vertex.cost is None or cost_through_new < near_vertex.cost:\n                    # Remove old parent edges\n                    for p in near_vertex.parents.copy():\n                        self._graph.remove_edge(p, near_vertex)\n                    # Add edge from new_vertex\n                    self._graph.add_edge(new_vertex, near_vertex)\n                    near_vertex.cost = cost_through_new\n\n    def _extract_path(self, connecting_vertex_start: Vertex, connecting_vertex_goal: Vertex) -> List[Vertex]:\n        # Trace back from connecting vertices to start and goal roots respectively, build full path\n        path_start = [connecting_vertex_start]\n        while len(path_start[-1].parents) != 0:\n            parents = list(path_start[-1].parents)\n            path_start.append(parents[0])\n\n        path_goal = [connecting_vertex_goal]\n        while len(path_goal[-1].parents) != 0:\n            parents = list(path_goal[-1].parents)\n            path_goal.append(parents[0])\n\n        path_start.reverse()\n        full_path = path_start + path_goal\n\n        # Visualize path\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n        return full_path\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        \n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n        \n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n\n        best_path: Optional[List[Vertex]] = None\n        best_cost = float('inf')\n\n        start_time = time.time()\n        for iteration in range(self._iterations):\n            # Timeout check\n            if (time.time() - start_time) > self._timeout:\n                # Fail: timeout exceeded\n                break\n\n            # Alternate growth: sample and expand from start tree, then goal tree\n            for tree_roots, tree_vertices, other_tree_roots, other_tree_vertices in [\n                (self._graph.root_vertex_start, tree_start, self._graph.root_vertex_goal, tree_goal),\n                (self._graph.root_vertex_goal, tree_goal, self._graph.root_vertex_start, tree_start)\n            ]:\n                q_rand = self._get_random_sample(best_path)\n                q_near = self._graph.get_nearest_vertex([tree_roots], q_rand)\n\n                q_new = self._get_new_vertex(q_near, q_rand, self._max_dist)\n\n                # Check if line is valid before connecting\n                if not self._line_is_valid(q_near.position, q_new.position):\n                    continue\n\n                # Find near vertices within a radius for rewiring and better parent choosing\n                radius = max(self._max_dist * 1.5, 15.0)\n                near_vertices = self._get_vertices_near([tree_roots], q_new.position, radius)\n                parent = self._choose_parent(q_new, near_vertices)\n                if parent is None:\n                    continue\n\n                self._graph.add_edge(parent, q_new)\n                tree_vertices.append(q_new)\n\n                self._rewire(q_new, near_vertices)\n\n                # Try to connect q_new in this tree to the nearest vertex in the other tree\n                q_near_other = self._graph.get_nearest_vertex([other_tree_roots], q_new.position)\n                # Move towards q_near_other from q_new up to max_dist\n                q_connect = self._get_new_vertex(q_new, q_near_other.position, self._max_dist)\n                if self._line_is_valid(q_new.position, q_connect.position):\n                    # Add edge in the other tree\n                    # Find near vertices in other tree for connection parent search\n                    near_others = self._get_vertices_near([other_tree_roots], q_connect.position, radius)\n                    parent_other = self._choose_parent(q_connect, near_others)\n                    if parent_other is not None:\n                        self._graph.add_edge(parent_other, q_connect)\n                        if q_connect not in other_tree_vertices:\n                            other_tree_vertices.append(q_connect)\n\n                        # Check if trees connected directly\n                        if q_connect.position == q_near_other.position:\n                            # Trees connected: form path\n                            path = self._extract_path(q_new, q_connect)\n                            # Compute cost for the path's last vertex (sum of costs)\n                            final_cost = path[-1].cost if path[-1].cost is not None else float('inf')\n                            if final_cost < best_cost:\n                                best_cost = final_cost\n                                best_path = path\n                            # Success: finish planning\n                            return\n                        else:\n                            # Attempt to extend connection further in other tree\n                            extended = True\n                            current_vertex = q_connect\n                            while extended:\n                                q_extend = self._get_new_vertex(current_vertex, q_near_other.position, self._max_dist)\n                                if q_extend.position == current_vertex.position:\n                                    break\n                                if self._line_is_valid(current_vertex.position, q_extend.position):\n                                    near_extend = self._get_vertices_near([other_tree_roots], q_extend.position, radius)\n                                    parent_extend = self._choose_parent(q_extend, near_extend)\n                                    if parent_extend is None:\n                                        break\n                                    self._graph.add_edge(parent_extend, q_extend)\n                                    if q_extend not in other_tree_vertices:\n                                        other_tree_vertices.append(q_extend)\n                                    current_vertex = q_extend\n                                    if q_extend.position == q_near_other.position:\n                                        # Connected fully\n                                        path = self._extract_path(q_new, q_extend)\n                                        final_cost = path[-1].cost if path[-1].cost is not None else float('inf')\n                                        if final_cost < best_cost:\n                                            best_cost = final_cost\n                                            best_path = path\n                                        return\n                                else:\n                                    extended = False\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This algorithm is a hybrid advanced sample-based planner named Adaptive Informed RRT* (AIRRT*), combining adaptive sampling \n    with a focus on an informed ellipsoidal subset around the current best solution. \n    It improves planning efficiency by sampling mostly in the promising region (informed subset) shrinking as better paths \n    are discovered, drastically reducing unnecessary exploration.\n    It builds a forest with rewiring like RRT*, but adds heuristics:\n     - Adaptive dynamic informed sampling based on current best cost (path length).\n     - Early pruning by ignoring samples outside the informed ellipsoidal region.\n     - Biased rewiring selecting parents and children by cost+heuristic.\n     - Path smoothing post-processing using shortcut attempts.\n    The planner also monitors elapsed time and fails gracefully if exceeding 60 seconds.\n    This results in higher success rate, shorter smoother paths, reduced search time, and improved robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: Optional[float]\n    _best_goal_vertex: Optional[Vertex]\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._dimension = self._get_grid().size.n_dim\n        self._max_dist = float(max(self._get_grid().size.values)) / 10.0  # max step length scaled by map size\n        self._lambda_rrt_star = 40.0  # constant for radius calculation\n        self._max_radius = max(self._get_grid().size.values) / 3  # max radius for rewiring neighbors\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._start_time = 0.0\n        self._timeout = 60.0  # seconds time limit\n        self._best_cost = None  # best cost found so far\n        self._best_goal_vertex = None\n\n        self._init_displays()\n\n    # Helper: Get Euclidean distance between points\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    # Helper: Sample uniformly in informed ellipsoid subset if best_cost known, else whole space\n    def _informed_sample(self) -> Point:\n        # If no best solution yet, sample uniformly over map\n        if self._best_cost is None:\n            return self._uniform_sample()\n        else:\n            return self._ellipsoidal_sample()\n\n    def _uniform_sample(self) -> Point:\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _ellipsoidal_sample(self) -> Point:\n        \"\"\"\n        Samples within an n-D ellipsoid defined by start and goal and radius equal to current best cost.\n        Algorithm briefly:\n          1) Construct ellipsoid in Cartesian coordinates where foci = start and goal positions.\n          2) Generate random point inside unit n-ball, scale and rotate to fit ellipsoid.\n          3) Translate to center between foci.\n        \"\"\"\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        c_best = torch.tensor(self._best_cost)\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best < c_min:\n            c_best = c_min + 1e-3  # prevent numerical error\n\n        # Compute center and unit vector from start to goal (ellipse major axis)\n        center = (start + goal) / 2.0\n        foci_vec = (goal - start)\n        e_axis = foci_vec / torch.norm(foci_vec)\n\n        # Build orthonormal basis (rotation matrix) for the ellipsoid\n        # For 2D or 3D only; general n-D could be extended if needed\n        if self._dimension == 2:\n            # Rotate unit vector to get perpendicular vector\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])  # perpendicular in 2D\n        elif self._dimension == 3:\n            # Use Gram-Schmidt for basis vectors\n            # First axis is e_axis\n            z_axis = e_axis\n            # Pick arbitrary vector not colinear with z_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)  # 3x3 matrix\n        else:\n            # For higher dimensions fallback to uniform sampling (rare)\n            return self._uniform_sample()\n\n        # Length of ellipsoid axes\n        r1 = c_best / 2.0  # major axis radius\n        r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0  # minor axis radius\n\n        # Construct diagonal scaling matrix for ellipsoid axis lengths\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        elif self._dimension == 3:\n            # assume rotationally symmetric about major axis for simplicity\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n        else:\n            # fallback\n            return self._uniform_sample()\n\n        # Sample random point inside unit n-ball\n        while True:\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u > 1e-6:\n                break\n        unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n\n        # Map sample into ellipsoid coordinate frame: center + rotation * L * unit_ball_sample\n        sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n\n        # Round and clamp to grid bounds\n        sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, self._get_grid().size[i] - 1).round())) for i in range(self._dimension)]\n        sample_point = Point(*sample_coords)\n\n        if self._get_grid().is_agent_valid_pos(sample_point):\n            return sample_point\n        else:\n            # Fallback to uniform when invalid sample in ellipsoid region\n            return self._uniform_sample()\n\n    # Rewiring radius calculation (adaptive)\n    def _calc_rewire_radius(self) -> float:\n        card_v = torch.tensor(float(self._graph.size + 1))\n        log_card_v = torch.log(card_v)\n        radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1.0 / self._dimension)), self._max_radius)\n        return radius.item()\n\n    # Given a new vertex, select best parent from neighbors minimizing cost+heuristic\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Tuple[Optional[Vertex], float]:\n        c_min = float('inf')\n        q_min = None\n        for q_near in neighbors:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost = q_near.cost + self._dist(q_near.position, q_new.position)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n        return q_min, c_min\n\n    # Attempt shortcut smoothing of path by trying to connect nonconsecutive vertices in path directly\n    def _shortcut_path(self, path: List[Vertex], max_attempts=30) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = self._get_grid().get_line_sequence(p_i, p_j)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                # Remove intermediates and link directly\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    # Extract final path from goal vertex back to start and smooth it\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            # pick parent with lowest cost (usually only one)\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # shortcut smoothing\n        path = self._shortcut_path(path, max_attempts=40)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n\n        max_iterations = 15000\n        radius = self._calc_rewire_radius()\n\n        for iter in range(max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Path search failed due to timeout\n                return\n\n            q_sample = self._informed_sample()\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                # fallback: connect to nearest vertex directly\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors for potential cost reduction\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                if cost_through_new < q_near.cost:\n                    # Remove previous edge(s)\n                    for p in q_near.parents:\n                        self._graph.remove_edge(p, q_near)\n                    # Add edge from new vertex\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if q_new reaches goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if (self._best_cost is None) or (possible_cost < self._best_cost):\n                    # Update best cost and attach goal vertex\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    for p in goal_vertex.parents:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()\n\n    # Method from existing samples to generate intermediate point toward sample (same as RRT_Star and SPRM style)\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*[int(round(float(c))) for c in new_pos_tensor])\n        return Vertex(new_pos)",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm": "This improved path planning algorithm implements an adaptive and informed RRT*-inspired planner \n    that balances exploration and exploitation by using heuristic-guided sampling within an ellipse \n    between start and goal, dynamic neighborhood radius based on vertex count and dimension, and \n    progressive rewiring for improved path quality and robustness. It terminates successfully once \n    the agent reaches the goal radius or fails if planning time exceeds 60 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_planning_time = 60  # seconds\n        self._init_displays()\n\n    def _dist(self, a: Point, b: Point) -> float:\n        return torch.norm(a.to_tensor() - b.to_tensor()).item()\n\n    def _get_random_sample(self) -> Point:\n        start = self._graph.root_vertex_start.position\n        goal = self._graph.root_vertex_goal.position\n        dim = self._get_grid().size.n_dim\n\n        c_min = self._dist(start, goal)\n        best_cost = self._graph.root_vertex_goal.cost\n        if best_cost is None or best_cost == float('inf'):\n            c_best = c_min * 2.0\n        else:\n            c_best = max(best_cost, c_min * 1.1)\n\n        # Goal bias 5%\n        if torch.rand(1).item() < 0.05:\n            candidate = goal\n            if self._get_grid().is_agent_valid_pos(candidate):\n                return candidate\n\n        center = (start.to_tensor() + goal.to_tensor()) / 2\n        e1_vec = goal.to_tensor() - start.to_tensor()\n        norm_e1 = torch.norm(e1_vec)\n        if norm_e1 < 1e-8:\n            e1_vec = torch.zeros(dim)\n            e1_vec[0] = 1.0\n            norm_e1 = 1.0\n        e1 = e1_vec / norm_e1\n\n        a1 = c_best / 2\n        a2 = (a1 ** 2 - (c_min / 2) ** 2) ** 0.5 if a1 > (c_min / 2) else a1 * 0.1\n\n        # Sample inside unit ball efficiently (2D assumed)\n        if dim == 2:\n            while True:\n                sample_unit = torch.rand(2) * 2 - 1\n                if sample_unit.norm() <= 1.0:\n                    break\n            sample_ellipse = torch.zeros(2)\n            sample_ellipse[0] = sample_unit[0] * a1\n            sample_ellipse[1] = sample_unit[1] * a2\n\n            angle = torch.atan2(e1[1], e1[0])\n            c, s = torch.cos(angle), torch.sin(angle)\n            rot = torch.tensor([[c, -s], [s, c]])\n            sample_rotated = rot.matmul(sample_ellipse)\n            sample_point = center[:2] + sample_rotated\n\n            coords = []\n            for i in range(dim):\n                val = float(sample_point[i]) if i < 2 else torch.randint(0, self._get_grid().size[i], (1,)).item()\n                val = max(0, min(self._get_grid().size[i] - 1, val))\n                coords.append(int(round(val)))\n            candidate = Point(*coords)\n        else:\n            # For nD, fallback: uniform random sample on valid grid\n            while True:\n                candidate = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(dim)])\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    break\n\n        if self._get_grid().is_agent_valid_pos(candidate):\n            return candidate\n\n        # fallback uniform sample if ellipse sample invalid\n        while True:\n            candidate = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(dim)])\n            if self._get_grid().is_agent_valid_pos(candidate):\n                return candidate\n\n    def _get_nearest_vertex(self, sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, sample)\n\n    def _get_neighbors_in_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _steer(self, from_v: Vertex, to_p: Point, max_extend_length: float) -> Vertex:\n        direction = to_p.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_extend_length:\n            return Vertex(to_p)\n        direction = direction / dist\n        new_pos_tensor = from_v.position.to_tensor() + max_extend_length * direction\n        new_pos = Point(*[int(round(v.item())) for v in new_pos_tensor])\n        return Vertex(new_pos)\n\n    def _extract_path(self, end_vertex: Vertex) -> None:\n        path = [end_vertex]\n        current = end_vertex\n        while current.parents:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n\n        if path[-1] == self._graph.root_vertex_start:\n            path.pop()  # remove start if appended redundantly\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_extend_length = 15.0\n        lambda_rrt_star = 30.0\n        max_radius = 40.0\n        dimension = self._get_grid().size.n_dim\n        max_iterations = 10000\n\n        import time\n        start_time = time.time()\n\n        for _ in range(max_iterations):\n            if time.time() - start_time > self._max_planning_time:\n                return  # Failed due to timeout\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._steer(q_nearest, q_sample, max_extend_length)\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            card = float(self._graph.size + 1)\n            log_card = max(1.0, torch.log(torch.tensor(card)).item())\n            radius = min(lambda_rrt_star * ((log_card / card) ** (1 / dimension)), max_radius)\n\n            neighbors = self._get_neighbors_in_radius(q_new, radius)\n\n            # Choose best parent minimizing cost + collision free edge\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._dist(q_nearest.position, q_new.position)\n            for q_near in neighbors:\n                line_seq_n = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_n):\n                    continue\n                cost = q_near.cost + self._dist(q_near.position, q_new.position)\n                if cost < c_min:\n                    q_min = q_near\n                    c_min = cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors with improved cost through q_new\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_r = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_r):\n                    continue\n                new_cost = q_new.cost + self._dist(q_new.position, q_near.position)\n                if new_cost < q_near.cost:\n                    old_parent = next(iter(q_near.parents), None)\n                    if old_parent:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm": "\"Hybrid Adaptive RRT*-PRM Approach with Anytime Enhancement:\\n\"\n    \"This algorithm combines features from RRT* (asynchronous tree growth, rewiring for optimal paths),\\n\"\n    \"and Probabilistic Roadmap (PRM) for local roadmap building in promising areas.\\n\"\n    \"It introduces an adaptive search radius tuned with a heuristic estimation of remaining cost,\\n\"\n    \"performs local roadmap refinement around new vertices to boost connectivity and robustness,\\n\"\n    \"and applies anytime path improvement techniques by rewiring edges and pruning.\\n\"\n    \"Search terminates on goal reach or after 60 seconds, reporting failure if not found.\\n\"\n    \"Overall it aims for better path quality, smoother trajectories, faster convergence,\\n\"\n    \"higher success rates, and reduced search time compared to baseline RRT*.\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\n    \"Hybrid Adaptive RRT*-PRM Approach with Anytime Enhancement:\\n\"\n    \"This algorithm combines features from RRT* (asynchronous tree growth, rewiring for optimal paths),\\n\"\n    \"and Probabilistic Roadmap (PRM) for local roadmap building in promising areas.\\n\"\n    \"It introduces an adaptive search radius tuned with a heuristic estimation of remaining cost,\\n\"\n    \"performs local roadmap refinement around new vertices to boost connectivity and robustness,\\n\"\n    \"and applies anytime path improvement techniques by rewiring edges and pruning.\\n\"\n    \"Search terminates on goal reach or after 60 seconds, reporting failure if not found.\\n\"\n    \"Overall it aims for better path quality, smoother trajectories, faster convergence,\\n\"\n    \"higher success rates, and reduced search time compared to baseline RRT*.\"\n    }\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = Forest(start_vertex, goal_vertex, [])\n        self._init_displays()\n        self._max_dist = 12.0             # Max extension distance - tuned for faster progress\n        self._max_radius = 40.0           # Upper bound on neighbor radius\n        self._lambda_rrt_star = 40.0      # Scaling factor for radius calculation\n        self._dimension = self._get_grid().size.n_dim\n        self._max_time = 60.0             # Maximum allowed search time in seconds\n        self._prm_local_radius = 8.0      # Radius for local PRM connections near new vertex\n\n    def _get_random_sample(self) -> Vertex:\n        while True:\n            rand_pos = tuple(np.random.uniform(0, s) for s in self._get_grid().size.values)\n            sample = Vertex(Point(*rand_pos))\n            if self._get_grid().is_agent_valid_pos(sample.position):\n                return sample\n\n    def _get_nearest_vertex(self, vertex_list: List[Vertex], point: Point) -> Vertex:\n        \"\"\"Return nearest vertex in vertex_list to point.\"\"\"\n        return self._graph.get_nearest_vertex(vertex_list, point)\n\n    def _get_vertices_within_radius(self, vertex_list: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(vertex_list, point, radius)\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_dist: float) -> Optional[Vertex]:\n        direction = to_point.to_tensor() - from_vertex.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            return Vertex(to_point)\n        else:\n            direction_normalized = direction / dist\n            new_pos_tensor = from_vertex.position.to_tensor() + max_dist * direction_normalized\n            new_pos = Point.from_tensor(new_pos_tensor)\n            return Vertex(new_pos)\n\n    def _is_path_collision_free(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        \"\"\"Compute cost from frm to to; fall back on distance.\"\"\"\n        return self._get_grid().get_movement_cost(frm.position, to.position)\n\n    def _heuristic(self, point: Point) -> float:\n        \"\"\"Euclidean distance heuristic to goal.\"\"\"\n        return Map.get_distance(point, self._get_grid().goal.position)\n\n    def _local_prm_connect(self, v_new: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"Try connecting v_new to neighbors via collision-free edges, update graph edges optimizing cost.\"\"\"\n        for v_near in neighbors:\n            if v_near == v_new:\n                continue\n            if self._is_path_collision_free(v_new.position, v_near.position):\n                cost_to_new = v_near.cost + self._cost(v_near, v_new) if v_near.cost is not None else None\n                cost_from_new = v_new.cost + self._cost(v_new, v_near) if v_new.cost is not None else None\n\n                # Add edge v_near->v_new if better\n                if cost_to_new is not None and (v_new.cost is None or cost_to_new < v_new.cost):\n                    # Remove old parents edges from v_new if needed\n                    for p in list(v_new.parents):\n                        self._graph.remove_edge(p, v_new)\n                    v_new.cost = cost_to_new\n                    self._graph.add_edge(v_near, v_new)\n\n                # Add edge v_new->v_near if better (rewiring)\n                if cost_from_new is not None and (v_near.cost is None or cost_from_new < v_near.cost):\n                    for p in list(v_near.parents):\n                        self._graph.remove_edge(p, v_near)\n                    v_near.cost = cost_from_new\n                    self._graph.add_edge(v_new, v_near)\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        path = [goal_vertex]\n        current = goal_vertex\n        while current.parents:\n            # Choose parent with lowest cost\n            current = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            path.append(current)\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid = self._get_grid()\n            from algorithms.configuration.maps.ros_map import RosMap\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        iter_limit = 100000  # Large iterations limit, almost no cap except time\n\n        root_vertices = [self._graph.root_vertex_start]\n        self._graph.root_vertices = root_vertices\n\n        # Initialize start vertex cost\n        self._graph.root_vertex_start.cost = 0\n\n        for i in range(iter_limit):\n            if time.time() - start_time > self._max_time:\n                # Time limit exceeded - fail safe\n                break\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(root_vertices, q_sample.position)\n            if q_nearest.position == q_sample.position:\n                continue\n\n            q_new = self._steer(q_nearest, q_sample.position, self._max_dist)\n            if q_new is None:\n                continue\n            if not self._is_path_collision_free(q_nearest.position, q_new.position):\n                continue\n\n            # Compute adaptive radius based on current graph size and heuristic\n            n = max(self._graph.size, 1)\n            radius = min(self._lambda_rrt_star * ((np.log(n) / n) ** (1 / self._dimension)), self._max_radius)\n            # Bias radius adaptive by heuristic (smaller radius as closer to goal)\n            goal_dist = self._heuristic(q_new.position)\n            radius *= max(0.5, min(1.0, goal_dist / self._get_grid().size.width))\n\n            nearby_vertices = self._get_vertices_within_radius(root_vertices, q_new.position, radius)\n\n            # Choose best parent from neighbors or nearest\n            c_min = float('inf')\n            q_min = None\n            for near_v in nearby_vertices:\n                if not self._is_path_collision_free(near_v.position, q_new.position):\n                    continue\n                new_cost = near_v.cost + self._cost(near_v, q_new) if near_v.cost is not None else float('inf')\n                if new_cost < c_min:\n                    c_min = new_cost\n                    q_min = near_v\n\n            # If no suitable parent, connect to nearest vertex if valid\n            if q_min is None:\n                if not self._is_path_collision_free(q_nearest.position, q_new.position):\n                    continue\n                q_min = q_nearest\n                c_min = q_min.cost + self._cost(q_min, q_new)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n            root_vertices.append(q_new)\n\n            # Local PRM connections around new vertex for robustness and smoothness\n            prm_neighbors = self._get_vertices_within_radius(root_vertices, q_new.position, self._prm_local_radius)\n            prm_neighbors = [v for v in prm_neighbors if v != q_new]\n            self._local_prm_connect(q_new, prm_neighbors)\n\n            # Anytime rewiring with neighbors\n            for near_v in prm_neighbors:\n                if near_v == q_new:\n                    continue\n                if not self._is_path_collision_free(q_new.position, near_v.position):\n                    continue\n                cost_thru_new = q_new.cost + self._cost(q_new, near_v)\n                if cost_thru_new < near_v.cost:\n                    # Rewire neighbor\n                    # Remove old parent edges of near_v\n                    for p in list(near_v.parents):\n                        self._graph.remove_edge(p, near_v)\n                    near_v.cost = cost_thru_new\n                    self._graph.add_edge(q_new, near_v)\n\n            # Check if goal reached with radius check (to avoid missing radius)\n            if self._get_grid().is_agent_in_goal_radius(q_new.position):\n                # Attach goal vertex if needed\n                goal_vertex = self._graph.root_vertex_goal\n                if self._is_path_collision_free(q_new.position, goal_vertex.position):\n                    goal_vertex.cost = q_new.cost + Map.get_distance(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    self._extract_path(goal_vertex)\n                    return\n            # Key frame every iteration to record progress/animation\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm": "Improved hybrid bi-directional sampling-based path planner combining RRT*, RRT-Connect, and informed sampling.\n    It utilizes dual trees rooted at start and goal, adaptive heuristic-based sampling focused on the current best path\n    and goal region, and aggressive rewiring for path optimality and smoothness. Dynamic radius for rewiring promotes\n    efficient local connectivity. Early stopping upon path discovery or 60s timeout provides robustness.\n    The algorithm balances exploration and exploitation to improve planning speed, success rates, and path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_dist: float\n    _iterations: int\n    _timeout: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_cyclic_graph(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # Allow rewiring for path improvement\n\n        self._max_dist = 12.0\n        self._iterations = 15000\n        self._timeout = 60.0\n        self._init_displays()\n\n    def _get_random_sample(self, best_path: list = None) -> Point:\n        grid = self._get_grid()\n        rand_val = np.random.rand()\n\n        # 70% uniform free space\n        # 20% near goal region\n        # 10% near best path (local refinement)\n        if best_path and len(best_path) > 2 and rand_val > 0.8:\n            # Sample near random best path node\n            chosen_vertex = best_path[np.random.randint(0, len(best_path))]\n            radius = self._max_dist * 1.5\n            attempts = 0\n            while attempts < 15:\n                offset = np.random.uniform(-radius, radius, grid.size.n_dim)\n                coords = chosen_vertex.position.to_tensor().numpy() + offset\n                coords = np.clip(coords, 0, np.array(grid.size.values) - 1)\n                pt = Point(*coords.astype(int))\n                if grid.is_agent_valid_pos(pt):\n                    return pt\n                attempts += 1\n\n        elif rand_val > 0.6:\n            # Sample near goal area\n            goal = grid.goal.position\n            radius = self._max_dist * 2.0\n            attempts = 0\n            while attempts < 30:\n                offset = np.random.uniform(-radius, radius, grid.size.n_dim)\n                coords = goal.to_tensor().numpy() + offset\n                coords = np.clip(coords, 0, np.array(grid.size.values) - 1)\n                pt = Point(*coords.astype(int))\n                if grid.is_agent_valid_pos(pt):\n                    return pt\n                attempts += 1\n\n        # Uniform random sample fallback\n        attempts = 0\n        while True:\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            pt = Point(*rand_pos)\n            if grid.is_agent_valid_pos(pt):\n                return pt\n            attempts += 1\n            if attempts > 50:\n                return grid.agent.position\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        v_near = q_near.position.to_tensor()\n        v_sample = q_sample.to_tensor()\n        dir_vec = v_sample - v_near\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        direction = dir_vec / dist\n        new_pos_tensor = v_near + max_dist * direction\n        new_pos = Point(*new_pos_tensor.numpy().astype(int))\n        return Vertex(new_pos)\n\n    def _line_is_valid(self, start: Point, end: Point) -> bool:\n        line = self._get_grid().get_line_sequence(start, end)\n        return self._get_grid().is_valid_line_sequence(line)\n\n    def _choose_parent(self, new_vertex: Vertex, near_vertices: list) -> Vertex | None:\n        grid = self._get_grid()\n        best_parent = None\n        min_cost = float(\"inf\")\n        for vertex in near_vertices:\n            if not self._line_is_valid(vertex.position, new_vertex.position):\n                continue\n            parent_cost = vertex.cost if vertex.cost is not None else 0.0\n            edge_cost = grid.get_movement_cost(vertex.position, new_vertex.position)\n            cost = parent_cost + edge_cost\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = vertex\n        if best_parent is not None:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: list) -> None:\n        grid = self._get_grid()\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex or near_vertex in new_vertex.parents:\n                continue\n            if near_vertex.cost is None:\n                continue\n            if self._line_is_valid(new_vertex.position, near_vertex.position):\n                cost_through_new = new_vertex.cost + grid.get_movement_cost(new_vertex.position, near_vertex.position)\n                if cost_through_new < near_vertex.cost:\n                    # Remove old parents edges\n                    for p in near_vertex.parents.copy():\n                        self._graph.remove_edge(p, near_vertex)\n                    # Connect through new_vertex\n                    self._graph.add_edge(new_vertex, near_vertex)\n                    near_vertex.cost = cost_through_new\n\n    def _extract_path(self, start_vertex: Vertex, goal_vertex: Vertex) -> list:\n        # Backtrack start path\n        path_start = [start_vertex]\n        while len(path_start[-1].parents) != 0:\n            p = next(iter(path_start[-1].parents))\n            path_start.append(p)\n        path_start.reverse()\n\n        # Backtrack goal path\n        path_goal = [goal_vertex]\n        while len(path_goal[-1].parents) != 0:\n            p = next(iter(path_goal[-1].parents))\n            path_goal.append(p)\n\n        full_path = path_start + path_goal  # concatenation\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n        return full_path\n\n    def _connect_trees(self, q_new: Vertex, other_roots: Vertex, other_tree_vertices: list) -> bool:\n        grid = self._get_grid()\n        radius = max(self._max_dist * 1.5, 15.0)\n\n        q_near_other = self._graph.get_nearest_vertex([other_roots], q_new.position)\n        q_connect = self._get_new_vertex(q_new, q_near_other.position, self._max_dist)\n\n        if not self._line_is_valid(q_new.position, q_connect.position):\n            return False\n\n        near_vertices = self._graph.get_vertices_within_radius([other_roots], q_connect.position, radius)\n        parent_other = self._choose_parent(q_connect, near_vertices)\n        if parent_other is None:\n            return False\n\n        self._graph.add_edge(parent_other, q_connect)\n        if q_connect not in other_tree_vertices:\n            other_tree_vertices.append(q_connect)\n\n        if q_connect.position == q_near_other.position:\n            # Trees connected directly\n            path = self._extract_path(q_new, q_connect)\n            return True\n\n        # Extend toward connection vertex greedily\n        current_vertex = q_connect\n        extended = True\n        while extended:\n            q_extend = self._get_new_vertex(current_vertex, q_near_other.position, self._max_dist)\n            if q_extend.position == current_vertex.position:\n                break\n            if not self._line_is_valid(current_vertex.position, q_extend.position):\n                break\n            near_ext = self._graph.get_vertices_within_radius([other_roots], q_extend.position, radius)\n            parent_ext = self._choose_parent(q_extend, near_ext)\n            if parent_ext is None:\n                break\n            self._graph.add_edge(parent_ext, q_extend)\n            if q_extend not in other_tree_vertices:\n                other_tree_vertices.append(q_extend)\n            current_vertex = q_extend\n            if q_extend.position == q_near_other.position:\n                path = self._extract_path(q_new, q_extend)\n                return True\n        return False\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start_v = self._graph.root_vertex_start\n        goal_v = self._graph.root_vertex_goal\n\n        start_v.cost = 0.0\n        goal_v.cost = 0.0\n\n        tree_from_start = [start_v]\n        tree_from_goal = [goal_v]\n\n        best_path = None\n        best_cost = float(\"inf\")\n        start_time = time.time()\n\n        for iteration in range(self._iterations):\n            if (time.time() - start_time) > self._timeout:\n                # Fail due to timeout\n                break\n\n            # Alternate expanding start tree and goal tree\n            for curr_root, curr_tree, other_root, other_tree in [\n                (start_v, tree_from_start, goal_v, tree_from_goal),\n                (goal_v, tree_from_goal, start_v, tree_from_start),\n            ]:\n                # Sample with informed bias based on current best path\n                q_rand = self._get_random_sample(best_path)\n\n                # Find nearest vertex in current tree\n                q_near = self._graph.get_nearest_vertex([curr_root], q_rand)\n\n                # Propose a new vertex in direction toward sample up to max_dist\n                q_new = self._get_new_vertex(q_near, q_rand, self._max_dist)\n\n                # Validate path segment collision-free\n                if not self._line_is_valid(q_near.position, q_new.position):\n                    continue\n\n                # Dynamic radius for near neighbors in rewiring (increases with number of vertices)\n                n_vertices = len(curr_tree) + 1\n                gamma_rrt_star = 50.0  # chosen constant for radius scaling\n                radius = min(gamma_rrt_star * (np.log(n_vertices) / n_vertices) ** (1 / grid.size.n_dim), self._max_dist * 2)\n\n                near_vertices = self._graph.get_vertices_within_radius([curr_root], q_new.position, radius)\n                parent = self._choose_parent(q_new, near_vertices)\n                if parent is None:\n                    continue\n\n                # Add to tree and connect with best parent found\n                self._graph.add_edge(parent, q_new)\n                curr_tree.append(q_new)\n\n                # Rewire neighbors if we can reduce their costs via q_new\n                self._rewire(q_new, near_vertices)\n\n                # Attempt to connect q_new to other tree\n                connected = self._connect_trees(q_new, other_root, other_tree)\n                if connected:\n                    # Extracted path inside _connect_trees returns upon success\n                    # Stop planning, path found\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm": "Improved bi-directional hybrid sampling-based planner inspired by RRT*, RRT-Connect, and Informed RRT*.\n    Key improvements:\n    - Adaptive max extension distance based on current best path cost for balanced exploration/exploitation.\n    - Enhanced heuristic informed sampling incorporating ellipsoidal region around start-goal with goal bias.\n    - Radius for nearest neighbor search grows with iteration count, promoting early broad search then refined rewiring.\n    - Early stopping on timeout (60s) or successful connection with path cost improvement.\n    - Tighter parent choosing with cost + line validity + connectivity checks for better path quality.\n    - Rewiring selectively done only when improvement is detected to cut unnecessary rewires.\n    - Path extraction ensures smooth concatenation of start and goal trees.\n    - Maintains robustness and path smoothness with controlled sampling and exploration heuristics.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    \n    _graph: Forest\n    _initial_max_dist: float\n    _iterations: int\n    _timeout: float\n    \n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._initial_max_dist = max(self._get_grid().size.width, self._get_grid().size.height) / 5.0\n        self._iterations = 20000\n        self._timeout = 60.0\n        self._init_displays()\n    \n    def _adaptive_max_dist(self, best_cost: Optional[float]) -> float:\n        # Adaptive max extension distance shrinks as path improves to refine solution\n        grid_diag = ((self._get_grid().size.width ** 2) + (self._get_grid().size.height ** 2)) ** 0.5\n        if best_cost is None or best_cost == float('inf'):\n            return self._initial_max_dist\n        # Max dist scales between initial max dist and 1/10 grid diagonal, inversely proportional to best cost\n        scaled = max(self._initial_max_dist * 0.1, min(self._initial_max_dist, (best_cost / grid_diag) * self._initial_max_dist))\n        return scaled\n    \n    def _heuristic_informed_sample(self, best_path: Optional[List[Vertex]] = None) -> Point:\n        grid = self._get_grid()\n        rand_val = np.random.rand()\n        max_dim = np.array(grid.size.values)\n        start = grid.agent.position.to_tensor().numpy()\n        goal = grid.goal.position.to_tensor().numpy()\n        \n        # Goal-bias probability 25%\n        if rand_val < 0.25:\n            radius = self._initial_max_dist * 1.5\n            attempt = 0\n            while attempt < 20:\n                offset = np.random.uniform(-radius, radius, grid.size.n_dim)\n                sample_coords = goal + offset\n                sample_coords = np.clip(sample_coords, 0, max_dim - 1)\n                sample_point = Point(*sample_coords.astype(int))\n                if grid.is_agent_valid_pos(sample_point):\n                    return sample_point\n                attempt += 1\n        \n        # Informed set sampling (50% chance if best_path available and sufficiently long)\n        if best_path and len(best_path) > 2 and rand_val < 0.75:\n            c_min = np.linalg.norm(goal - start)\n            best_cost = best_path[-1].cost if best_path[-1].cost is not None else float('inf')\n            if best_cost < float('inf'):\n                # Define ellipsoidal informed sampling using start-goal frame\n                center = (start + goal) / 2\n                diff = goal - start\n                angle = np.arctan2(diff[1], diff[0])\n                \n                def sample_in_unit_ball(n_dim):\n                    while True:\n                        p = np.random.uniform(-1, 1, n_dim)\n                        if np.linalg.norm(p) <= 1:\n                            return p\n                \n                sample_unit = sample_in_unit_ball(grid.size.n_dim)\n                # Scale ellipsoid radii\n                r1 = best_cost / 2.0\n                r_rest = ((best_cost ** 2) - (c_min ** 2)) ** 0.5 / 2 if best_cost > c_min else 0.0\n                radii = np.array([r1] + [r_rest] * (grid.size.n_dim - 1))\n                # Rotation matrix for 2D\n                c, s = np.cos(angle), np.sin(angle)\n                rot_matrix = np.eye(grid.size.n_dim)\n                if grid.size.n_dim >= 2:\n                    rot_matrix[:2, :2] = np.array([[c, -s], [s, c]])\n                sample_scaled = np.dot(rot_matrix, sample_unit * radii) + center\n                sample_scaled = np.clip(sample_scaled, 0, max_dim - 1)\n                sample_point = Point(*sample_scaled.astype(int))\n                if grid.is_agent_valid_pos(sample_point):\n                    return sample_point\n        \n        # Local refined sampling near best path vertices - 15%\n        if best_path and len(best_path) > 2 and rand_val < 0.9:\n            radius = self._initial_max_dist * 1.2\n            attempt = 0\n            for _ in range(10):\n                path_vertex = best_path[np.random.randint(0, len(best_path))]\n                offset = np.random.uniform(-radius, radius, grid.size.n_dim)\n                sample_coords = path_vertex.position.to_tensor().numpy() + offset\n                sample_coords = np.clip(sample_coords, 0, max_dim - 1)\n                sample_point = Point(*sample_coords.astype(int))\n                if grid.is_agent_valid_pos(sample_point):\n                    return sample_point\n                attempt += 1\n        \n        # Uniform random sampling (10%)\n        attempt = 0\n        while attempt < 50:\n            rand_pos = np.random.randint(0, max_dim, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n            attempt += 1\n        \n        # Fallback\n        return grid.agent.position\n    \n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_tensor)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        if dist == 0:\n            return Vertex(q_near.position)\n        dir_normalized = dir_tensor / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*torch.clamp(new_pos_tensor, 0, self._get_grid().size.width - 1).int().tolist())\n        return Vertex(new_pos)\n    \n    def _line_is_valid(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n    \n    def _get_vertices_near(self, root_vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(root_vertices, point, radius)\n    \n    def _choose_parent(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> Vertex | None:\n        grid = self._get_grid()\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            if v == new_vertex or new_vertex.position == v.position:\n                continue\n            if self._line_is_valid(v.position, new_vertex.position):\n                cost_to_new = (v.cost if v.cost is not None else 0.0) + grid.get_movement_cost(v.position, new_vertex.position)\n                if cost_to_new < min_cost:\n                    min_cost = cost_to_new\n                    best_parent = v\n        if best_parent:\n            new_vertex.cost = min_cost\n        return best_parent\n    \n    def _rewire(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> None:\n        grid = self._get_grid()\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex or near_vertex == new_vertex.parents:\n                continue\n            if self._line_is_valid(new_vertex.position, near_vertex.position):\n                new_cost = new_vertex.cost + grid.get_movement_cost(new_vertex.position, near_vertex.position)\n                if near_vertex.cost is None or new_cost < near_vertex.cost:\n                    # Remove old parents edges\n                    for p in set(near_vertex.parents):\n                        self._graph.remove_edge(p, near_vertex)\n                    self._graph.add_edge(new_vertex, near_vertex)\n                    near_vertex.cost = new_cost\n    \n    def _extract_path(self, connecting_vertex_start: Vertex, connecting_vertex_goal: Vertex) -> list[Vertex]:\n        # Trace parents to root start\n        path_start = []\n        node = connecting_vertex_start\n        while node is not None:\n            path_start.append(node)\n            if not node.parents:\n                break\n            node = next(iter(node.parents))\n        path_start.reverse()\n        \n        # Trace parents to root goal\n        path_goal = []\n        node = connecting_vertex_goal\n        while node is not None:\n            path_goal.append(node)\n            if not node.parents:\n                break\n            node = next(iter(node.parents))\n        \n        full_path = path_start + path_goal\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n        return full_path\n    \n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        \n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n        \n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n        \n        best_path = None\n        best_cost = float('inf')\n        \n        start_time = time.time()\n        \n        for iteration in range(self._iterations):\n            if (time.time() - start_time) > self._timeout:\n                # Timeout/fail condition\n                break\n            \n            # Update adaptive max distance based on current best cost\n            max_dist = self._adaptive_max_dist(best_cost)\n            # Increase radius for near vertex search progressively (min 10 max 30)\n            radius = min(max(10.0, iteration ** 0.4), 30.0)\n            \n            # Alternate tree growth: first start tree, then goal tree\n            for roots_grow, tree_grow, roots_goal, tree_goal_list in [\n                (self._graph.root_vertex_start, tree_start, self._graph.root_vertex_goal, tree_goal),\n                (self._graph.root_vertex_goal, tree_goal, self._graph.root_vertex_start, tree_start)\n            ]:\n                q_rand = self._heuristic_informed_sample(best_path)\n                \n                q_near = self._graph.get_nearest_vertex([roots_grow], q_rand)\n                q_new = self._get_new_vertex(q_near, q_rand, max_dist)\n                \n                if not self._line_is_valid(q_near.position, q_new.position):\n                    continue\n                \n                near_vertices = self._get_vertices_near([roots_grow], q_new.position, radius)\n                parent = self._choose_parent(q_new, near_vertices)\n                if not parent:\n                    continue\n                \n                self._graph.add_edge(parent, q_new)\n                tree_grow.append(q_new)\n                \n                self._rewire(q_new, near_vertices)\n                \n                # Try to connect q_new to nearest vertex in other tree\n                q_near_other = self._graph.get_nearest_vertex([roots_goal], q_new.position)\n                if q_near_other is None:\n                    continue\n                \n                q_connect = self._get_new_vertex(q_new, q_near_other.position, max_dist)\n                if self._line_is_valid(q_new.position, q_connect.position):\n                    near_others = self._get_vertices_near([roots_goal], q_connect.position, radius)\n                    parent_other = self._choose_parent(q_connect, near_others)\n                    if parent_other:\n                        self._graph.add_edge(parent_other, q_connect)\n                        if q_connect not in tree_goal_list:\n                            tree_goal_list.append(q_connect)\n                        \n                        # Check if trees connected by position equality\n                        if q_connect.position == q_near_other.position:\n                            path = self._extract_path(q_new, q_connect)\n                            final_cost = path[-1].cost if path[-1].cost is not None else float('inf')\n                            if final_cost < best_cost:\n                                best_cost = final_cost\n                                best_path = path\n                            return  # Successful planning, terminate\n                        \n                        # Attempt to extend the other tree towards goal vertex fully\n                        current_vertex = q_connect\n                        extended = True\n                        while extended:\n                            q_extend = self._get_new_vertex(current_vertex, q_near_other.position, max_dist)\n                            if q_extend.position == current_vertex.position:\n                                break\n                            if self._line_is_valid(current_vertex.position, q_extend.position):\n                                near_ext = self._get_vertices_near([roots_goal], q_extend.position, radius)\n                                parent_ext = self._choose_parent(q_extend, near_ext)\n                                if parent_ext is None:\n                                    break\n                                self._graph.add_edge(parent_ext, q_extend)\n                                if q_extend not in tree_goal_list:\n                                    tree_goal_list.append(q_extend)\n                                current_vertex = q_extend\n                                if q_extend.position == q_near_other.position:\n                                    path = self._extract_path(q_new, q_extend)\n                                    final_cost = path[-1].cost if path[-1].cost is not None else float('inf')\n                                    if final_cost < best_cost:\n                                        best_cost = final_cost\n                                        best_path = path\n                                    return\n                            else:\n                                extended = False\n                \n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This improved path planning algorithm combines a bidirectional RRT* backbone with adaptive informed sampling and dynamic path smoothing.\n    It maintains two trees initialized at the start and goal, grows them by connecting sampled points constrained by a variable radius,\n    rewires vertices locally to improve cost efficiently, and uses heuristic-biased sampling around the minimum-cost ellipse between start and goal\n    for faster convergence. The algorithm employs a local path smoothing step periodically on the best found path, improving smoothness and path length.\n    It uses early stopping on success or timeout after 60 seconds. Robust collision checks and cost-based rewiring ensure high-quality, smooth, and efficient paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    \n    _graph: CyclicGraph\n    _max_dist: float\n    _iterations: int\n    _timeout: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_cyclic_graph(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True  # Allow rewiring to improve path\n        self._max_dist = 15.0\n        self._iterations = 20000\n        self._timeout = 60.0\n        self._init_displays()\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return float(torch.norm(p1.to_tensor() - p2.to_tensor()))\n\n    def _sample_in_ellipse(self, c_min: float, c_best: float, start: Point, goal: Point) -> Point:\n        # Adaptive informed sampling inside a prolate hyperspheroid (ellipse in 2D)\n        # If no best path found yet or c_best infinite, uniform sample in entire map\n        grid = self._get_grid()\n        dims = grid.size.n_dim\n        \n        if c_best == float('inf') or c_best <= c_min:\n            # No informed sampling, uniform random\n            for _ in range(50):\n                coords = np.random.randint(0, grid.size.values, dims)\n                p = Point(*coords)\n                if grid.is_agent_valid_pos(p):\n                    return p\n            return start  # fallback\n        \n        center_tensor = (start.to_tensor() + goal.to_tensor()) / 2\n        \n        # Rotation matrix aligning x-axis with line from start to goal\n        diff = goal.to_tensor() - start.to_tensor()\n        norm_diff = torch.norm(diff)\n        if norm_diff < 1e-8:\n            # Start == Goal (edge case)\n            return start\n        \n        # Unit vector along line start->goal\n        e1 = diff / norm_diff\n        \n        # For 2D, we can build a rotation matrix easily:\n        if dims == 2:\n            rotation = torch.eye(2)\n            rotation[0] = e1\n            rotation[1] = torch.tensor([-e1[1], e1[0]])\n        else:\n            # For n-dimensions, approximate by identity (fallback)\n            rotation = torch.eye(dims)\n        \n        # Ellipse radii: \n        r1 = c_best / 2.0        # major axis length half\n        # others: sqrt(c_best^2 - c_min^2)/2 or smaller axes\n        r_other = np.sqrt(c_best**2 - c_min**2) / 2.0\n        \n        radii = np.array([r1] + [r_other]*(dims-1))\n        \n        for _ in range(50):\n            # Sample random point in unit ball\n            sample = np.random.normal(0, 1, dims)\n            length = np.linalg.norm(sample)\n            if length > 1e-8:\n                sample = sample / length * (np.random.uniform(0,1) ** (1/dims))\n            else:\n                sample = np.zeros(dims)\n            # Scale by ellipse axes\n            sample_scaled = radii * sample\n            \n            # Map to world frame using rotation and center\n            sample_tensor = torch.tensor(sample_scaled, dtype=torch.float32)\n            \n            mapped = center_tensor + rotation.T @ sample_tensor\n            \n            # Clamp mapped point to grid limits\n            coords = mapped.numpy()\n            coords = np.clip(coords, 0, np.array(grid.size.values) - 1)\n            p = Point(*coords.astype(int))\n            if grid.is_agent_valid_pos(p):\n                return p\n        \n        # fallback\n        return start\n\n    def _get_random_sample(self, best_path: list = None) -> Point:\n        grid = self._get_grid()\n        start = self._graph.root_vertex_start.position\n        goal = self._graph.root_vertex_goal.position\n        \n        c_min = self._distance(start, goal)\n        c_best = float('inf')\n        if best_path and len(best_path) > 0:\n            # Compute current best path cost sum of edges\n            cost = 0.0\n            for i in range(len(best_path)-1):\n                cost += grid.get_movement_cost(best_path[i].position, best_path[i+1].position)\n            c_best = cost\n        \n        # With 70% chance do ellipse sampling, else uniform random in map\n        if np.random.rand() < 0.7:\n            return self._sample_in_ellipse(c_min, c_best, start, goal)\n        else:\n            for _ in range(50):\n                coords = np.random.randint(0, grid.size.values, grid.size.n_dim)\n                p = Point(*coords)\n                if grid.is_agent_valid_pos(p):\n                    return p\n            return start\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_tensor)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_tensor / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*new_pos_tensor.numpy())\n        return Vertex(new_pos)\n\n    def _line_is_valid(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _get_vertices_near(self, root_vertices: list, point: Point, radius: float) -> list:\n        return self._graph.get_vertices_within_radius(root_vertices, point, radius)\n\n    def _choose_parent(self, new_vertex: Vertex, near_vertices: list) -> Vertex:\n        grid = self._get_grid()\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            if self._line_is_valid(v.position, new_vertex.position):\n                cost = (v.cost if v.cost is not None else 0.0) + grid.get_movement_cost(v.position, new_vertex.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = v\n        if best_parent:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: list) -> None:\n        grid = self._get_grid()\n        for v in near_vertices:\n            if v == new_vertex or v in new_vertex.parents:\n                continue\n            if self._line_is_valid(new_vertex.position, v.position):\n                cost_through_new = new_vertex.cost + grid.get_movement_cost(new_vertex.position, v.position)\n                if v.cost is None or cost_through_new < v.cost:\n                    # Remove old edges from parents\n                    for p in v.parents.copy():\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(new_vertex, v)\n                    v.cost = cost_through_new\n\n    def _extract_path(self, start_vertex: Vertex, goal_vertex: Vertex) -> list:\n        path_start = [start_vertex]\n        while path_start[-1].parents:\n            path_start.append(next(iter(path_start[-1].parents)))\n        path_goal = [goal_vertex]\n        while path_goal[-1].parents:\n            path_goal.append(next(iter(path_goal[-1].parents)))\n        path_start.reverse()\n        full_path = path_start + path_goal\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n        return full_path\n\n    def _smooth_path(self, path: list, smooth_iterations: int = 20) -> list:\n        # Simple path smoothing by shortcutting random pairs along path if line valid and cost reduces\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        path_positions = [v.position for v in path]\n        for _ in range(smooth_iterations):\n            if len(path_positions) < 3:\n                break\n            i = np.random.randint(0, len(path_positions) - 2)\n            j = np.random.randint(i + 2, len(path_positions))\n            p1, p2 = path_positions[i], path_positions[j]\n            if self._line_is_valid(p1, p2):\n                # Remove intermediate nodes if shortcut is valid\n                path_positions = path_positions[:i+1] + path_positions[j:]\n        # Convert positions back to vertices for visualization, dummy vertices without parents/children\n        smoothed_path = [Vertex(pos) for pos in path_positions]\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n        return smoothed_path\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        \n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n        \n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n        \n        best_path = None\n        best_cost = float('inf')\n\n        start_time = time.time()\n        \n        for iteration in range(self._iterations):\n            if (time.time() - start_time) > self._timeout:\n                # Failed due to timeout\n                break\n            \n            # Alternate growth: start tree first, then goal tree\n            for tree_root, tree_vertices, other_root, other_vertices in [\n                (self._graph.root_vertex_start, tree_start, self._graph.root_vertex_goal, tree_goal),\n                (self._graph.root_vertex_goal, tree_goal, self._graph.root_vertex_start, tree_start)\n            ]:\n                q_rand = self._get_random_sample(best_path)\n                q_near = self._graph.get_nearest_vertex([tree_root], q_rand)\n                q_new = self._get_new_vertex(q_near, q_rand, self._max_dist)\n                if not self._line_is_valid(q_near.position, q_new.position):\n                    continue\n                \n                radius = max(self._max_dist * 2.0, 20.0)\n                near_vertices = self._get_vertices_near([tree_root], q_new.position, radius)\n                parent = self._choose_parent(q_new, near_vertices)\n                if parent is None:\n                    continue\n\n                self._graph.add_edge(parent, q_new)\n                tree_vertices.append(q_new)\n                self._rewire(q_new, near_vertices)\n\n                # Try connecting q_new to nearest vertex in the other tree\n                q_near_other = self._graph.get_nearest_vertex([other_root], q_new.position)\n                q_connect = self._get_new_vertex(q_new, q_near_other.position, self._max_dist)\n                if self._line_is_valid(q_new.position, q_connect.position):\n                    near_others = self._get_vertices_near([other_root], q_connect.position, radius)\n                    parent_other = self._choose_parent(q_connect, near_others)\n                    if parent_other:\n                        self._graph.add_edge(parent_other, q_connect)\n                        if q_connect not in other_vertices:\n                            other_vertices.append(q_connect)\n\n                        if q_connect.position == q_near_other.position:\n                            # Trees connected - path found\n                            path = self._extract_path(q_new, q_connect)\n                            # Calculate cost sum\n                            final_cost = 0.0\n                            for i in range(len(path)-1):\n                                final_cost += grid.get_movement_cost(path[i].position, path[i+1].position)\n                            if final_cost < best_cost:\n                                best_cost = final_cost\n                                best_path = path\n                                # Smooth the path for smoother execution\n                                best_path = self._smooth_path(best_path)\n                            return  # Path found: terminate\n\n                        # Attempt to extend connection further in other tree\n                        current_vertex = q_connect\n                        extended = True\n                        while extended:\n                            q_extend = self._get_new_vertex(current_vertex, q_near_other.position, self._max_dist)\n                            if q_extend.position == current_vertex.position:\n                                break\n                            if self._line_is_valid(current_vertex.position, q_extend.position):\n                                near_extend = self._get_vertices_near([other_root], q_extend.position, radius)\n                                parent_extend = self._choose_parent(q_extend, near_extend)\n                                if parent_extend is None:\n                                    break\n                                self._graph.add_edge(parent_extend, q_extend)\n                                if q_extend not in other_vertices:\n                                    other_vertices.append(q_extend)\n                                current_vertex = q_extend\n                                if q_extend.position == q_near_other.position:\n                                    path = self._extract_path(q_new, q_extend)\n                                    final_cost = 0.0\n                                    for i in range(len(path)-1):\n                                        final_cost += grid.get_movement_cost(path[i].position, path[i+1].position)\n                                    if final_cost < best_cost:\n                                        best_cost = final_cost\n                                        best_path = path\n                                        best_path = self._smooth_path(best_path)\n                                    return\n                            else:\n                                extended = False\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm": "This algorithm is an improved sample-based planner combining adaptive informed sampling and anytime iterative path refinement.\n    It builds a forest like RRT*, focusing sample efforts in ellipsoidal informed subsets defined by the current best cost to minimize unnecessary exploration.\n    The algorithm performs dynamic rewiring with cost+heuristic parent selection, and integrates progressive path shortcut smoothing during planning.\n    Timeout handling ensures graceful failure beyond 60 seconds.\n    This approach improves planning efficiency, path quality, smoothness, robustness, and success rate while reducing search time and path lengths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: float | None\n    _best_goal_vertex: Vertex | None\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._dimension = self._get_grid().size.n_dim\n        max_map_dim = max(self._get_grid().size.values)\n        self._max_dist = max_map_dim / 10.0\n        self._lambda_rrt_star = 35.0\n        self._max_radius = max_map_dim / 3\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._start_time = 0.0\n        self._timeout = 60.0\n        self._best_cost = None\n        self._best_goal_vertex = None\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _uniform_sample(self) -> Point:\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            pt = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(pt):\n                return pt\n\n    def _ellipsoidal_sample(self) -> Point:\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        c_best = torch.tensor(self._best_cost)\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best < c_min:\n            c_best = c_min + 1e-6\n        center = (start + goal) / 2.0\n        foci_vec = (goal - start)\n        e_axis = foci_vec / torch.norm(foci_vec)\n\n        if self._dimension == 2:\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])\n        elif self._dimension == 3:\n            z_axis = e_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n        else:\n            return self._uniform_sample()\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0\n\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        elif self._dimension == 3:\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n        else:\n            return self._uniform_sample()\n\n        for _ in range(20):  # limit retries\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u < 1e-6:\n                continue\n            unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n            sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n            sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, self._get_grid().size[i] - 1).round())) for i in range(self._dimension)]\n            sample_point = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n        return self._uniform_sample()\n\n    def _informed_sample(self) -> Point:\n        if self._best_cost is None:\n            return self._uniform_sample()\n        return self._ellipsoidal_sample()\n\n    def _calc_rewire_radius(self) -> float:\n        n = float(self._graph.size + 1)\n        radius = self._lambda_rrt_star * ((torch.log(torch.tensor(n)) / n) ** (1.0 / self._dimension))\n        return min(radius.item(), self._max_radius)\n\n    def _choose_parent(self, neighbors: list[Vertex], q_new: Vertex) -> tuple[Vertex | None, float]:\n        c_min = float('inf')\n        q_min = None\n        for q_near in neighbors:\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = q_near.cost + self._dist(q_near.position, q_new.position)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n        return q_min, c_min\n\n    def _shortcut_path(self, path: list[Vertex], max_attempts: int = 40) -> list[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts and len(new_path) >= 3:\n            attempts += 1\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i, p_j = new_path[i].position, new_path[j].position\n            line_seq = self._get_grid().get_line_sequence(p_i, p_j)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = min(current.parents, key=lambda v: v.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n        path = self._shortcut_path(path, max_attempts=50)\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_coords = [int(round(float(c))) for c in new_pos_tensor]\n        new_point = Point(*new_coords)\n        return Vertex(new_point)\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n        max_iterations = 20000\n        radius = self._calc_rewire_radius()\n\n        for iteration in range(max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Timeout: path search failed\n                return\n\n            q_sample = self._informed_sample()\n\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors through q_new\n            for q_near in neighbors:\n                if q_near is q_min:\n                    continue\n                line_seq_back = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_back):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                if cost_through_new + 1e-8 < q_near.cost:\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if q_new reaches goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if (self._best_cost is None) or (possible_cost < self._best_cost):\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm": "Hybrid Enhanced Bi-directional Informed RRT*/SPRM Algorithm\n    \n    This path planning algorithm combines elements from RRT*, RRT-Connect, and SPRM sample-based planning into a\n    unified hybrid approach. It uses dual trees rooted at the start and goal vertices and maintains a cyclic graph with\n    informed sampling biased towards the current best path and goal vicinity, balancing exploration and exploitation.\n    \n    Key innovations include:\n    - Adaptive dynamic radius rewiring for efficient local improvements and path smoothness.\n    - Aggressive bi-directional tree expansion with iterative connection attempts to rapidly discover paths.\n    - Informed sampling combining uniform, goal-biased, and path-centric sampling distributions.\n    - Cyclic graph edges for richer connectivity allowing multiple alternate paths.\n    - Layered stepwise extension with progressive pruning for optimality and reduced search time.\n    - Early termination on path discovery or timeouts for robustness.\n    \n    Improved path quality, reduced path length, and robustness against complex obstacle configurations are primary gains.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: CyclicGraph\n    _max_dist: float\n    _iterations: int\n    _timeout: float\n    _max_radius: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        grid = self._get_grid()\n        start_vertex = Vertex(grid.agent.position, store_connectivity=True)\n        goal_vertex = Vertex(grid.goal.position, store_connectivity=True)\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True  # Allow rewiring and pruning\n        \n        self._max_dist = min(grid.size.width, grid.size.height) * 0.1 + 5.0\n        # Cap max distance with some heuristic relative to map size\n        self._max_radius = max(self._max_dist * 2, 15.0)\n        self._iterations = 15000\n        self._timeout = 60.0\n        \n        self._init_displays()\n\n    def _get_random_sample(self, best_path: list = None) -> Point:\n        grid = self._get_grid()\n        p_uniform = 0.65\n        p_goal = 0.20\n        p_path = 0.15\n        \n        rv = np.random.rand()\n        if best_path and len(best_path) > 2 and rv > (1 - p_path):\n            # Sample close to best path vertices\n            tries = 0\n            radius = self._max_dist * 1.5\n            while tries < 15:\n                chosen_vertex = best_path[np.random.randint(0, len(best_path))]\n                offset = np.random.uniform(-radius, radius, grid.size.n_dim)\n                coords = chosen_vertex.position.to_tensor().numpy() + offset\n                coords = np.clip(coords, 0, np.array(grid.size.values) - 1)\n                pt = Point(*coords.astype(int))\n                if grid.is_agent_valid_pos(pt):\n                    return pt\n                tries += 1\n\n        elif rv > p_uniform + p_goal:\n            # Bias sample near goal\n            tries = 0\n            radius = self._max_dist * 2\n            goal = grid.goal.position\n            while tries < 30:\n                offset = np.random.uniform(-radius, radius, grid.size.n_dim)\n                coords = goal.to_tensor().numpy() + offset\n                coords = np.clip(coords, 0, np.array(grid.size.values) - 1)\n                pt = Point(*coords.astype(int))\n                if grid.is_agent_valid_pos(pt):\n                    return pt\n                tries += 1\n\n        # Uniform sampling in free space\n        tries = 0\n        while tries < 60:\n            coords = np.random.randint(0, grid.size.values[0], size=grid.size.n_dim)\n            pt = Point(*coords)\n            if grid.is_agent_valid_pos(pt):\n                return pt\n            tries += 1\n\n        # fallback to agent start to prevent deadlock\n        return grid.agent.position\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        start = q_near.position.to_tensor()\n        target = q_sample.to_tensor()\n        direction = target - start\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        dir_norm = direction / dist\n        new_pos_tensor = start + max_dist * dir_norm\n        new_pos = Point(*new_pos_tensor.numpy().astype(int))\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _line_is_valid(self, start: Point, end: Point) -> bool:\n        line = self._get_grid().get_line_sequence(start, end)\n        return self._get_grid().is_valid_line_sequence(line)\n\n    def _choose_best_parent(self, new_vertex: Vertex, near_vertices: list) -> Vertex:\n        grid = self._get_grid()\n        best_parent = None\n        min_cost = float('inf')\n        for v in near_vertices:\n            if not self._line_is_valid(v.position, new_vertex.position):\n                continue\n            parent_cost = v.cost if v.cost is not None else 0.0\n            edge_cost = grid.get_movement_cost(v.position, new_vertex.position)\n            total_cost = parent_cost + edge_cost\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_parent = v\n        if best_parent is not None:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire_vertices(self, new_vertex: Vertex, near_vertices: list) -> None:\n        grid = self._get_grid()\n        for v in near_vertices:\n            if v == new_vertex or v in new_vertex.parents:\n                continue\n            if v.cost is None:\n                continue\n            if self._line_is_valid(new_vertex.position, v.position):\n                cost_through_new = new_vertex.cost + grid.get_movement_cost(new_vertex.position, v.position)\n                if cost_through_new < v.cost:\n                    # Remove old parents edges\n                    for p in v.parents.copy():\n                        self._graph.remove_edge(p, v)\n                    # Add new edge\n                    self._graph.add_edge(new_vertex, v)\n                    v.cost = cost_through_new\n\n    def _extract_path(self, start_vertex: Vertex, goal_vertex: Vertex) -> list:\n        path_start = [start_vertex]\n        while len(path_start[-1].parents) != 0:\n            p = next(iter(path_start[-1].parents))\n            path_start.append(p)\n        path_start.reverse()\n\n        path_goal = [goal_vertex]\n        # Because it's cyclic graph, the goal vertex might have multiple parents\n        # To avoid issues, limit backtrack steps (max 1000 steps safeguard)\n        max_backtrack = 1000\n        count = 0\n        current = goal_vertex\n        while len(current.parents) != 0 and count < max_backtrack:\n            p = next(iter(current.parents))\n            path_goal.append(p)\n            current = p\n            count += 1\n\n        path = path_start + path_goal\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n        return path\n\n    def _attempt_connection(self, vertex: Vertex, other_root: Vertex, other_tree_vertices: list) -> bool:\n        grid = self._get_grid()\n        radius = self._max_radius\n        q_near_other = self._graph.get_nearest_vertex([other_root], vertex.position)\n        q_new_other = self._get_new_vertex(vertex, q_near_other.position, self._max_dist)\n        if not self._line_is_valid(vertex.position, q_new_other.position):\n            return False\n        near_others = self._graph.get_vertices_within_radius([other_root], q_new_other.position, radius)\n        parent_other = self._choose_best_parent(q_new_other, near_others)\n        if parent_other is None:\n            return False\n        self._graph.add_edge(parent_other, q_new_other)\n        if q_new_other not in other_tree_vertices:\n            other_tree_vertices.append(q_new_other)\n\n        # Attempt to extend further greedily toward q_near_other\n        current_vertex = q_new_other\n        extended = True\n        while extended:\n            q_extend = self._get_new_vertex(current_vertex, q_near_other.position, self._max_dist)\n            if q_extend.position == current_vertex.position:\n                break\n            if not self._line_is_valid(current_vertex.position, q_extend.position):\n                break\n            near_extend = self._graph.get_vertices_within_radius([other_root], q_extend.position, radius)\n            parent_extend = self._choose_best_parent(q_extend, near_extend)\n            if parent_extend is None:\n                break\n            self._graph.add_edge(parent_extend, q_extend)\n            if q_extend not in other_tree_vertices:\n                other_tree_vertices.append(q_extend)\n            current_vertex = q_extend\n            if q_extend.position == q_near_other.position:\n                # Path connected\n                self._extract_path(vertex, q_extend)\n                return True\n\n        # If q_new_other's position == q_near_other.position, path connected too\n        if q_new_other.position == q_near_other.position:\n            self._extract_path(vertex, q_new_other)\n            return True\n\n        return False\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start_v = self._graph.root_vertex_start\n        goal_v = self._graph.root_vertex_goal\n\n        start_v.cost = 0.0\n        goal_v.cost = 0.0\n\n        tree_from_start = [start_v]\n        tree_from_goal = [goal_v]\n\n        best_path = None\n        best_cost = float(\"inf\")\n        start_time = time.time()\n\n        for iteration in range(self._iterations):\n            if (time.time() - start_time) > self._timeout:\n                # Timeout termination - planning failed\n                break\n\n            # Alternate between start and goal trees\n            for curr_root, curr_tree, other_root, other_tree in [\n                (start_v, tree_from_start, goal_v, tree_from_goal),\n                (goal_v, tree_from_goal, start_v, tree_from_start)\n            ]:\n                # Informed sample biased on current best path\n                q_rand = self._get_random_sample(best_path)\n\n                q_near = self._graph.get_nearest_vertex([curr_root], q_rand)\n                q_new = self._get_new_vertex(q_near, q_rand, self._max_dist)\n\n                if not self._line_is_valid(q_near.position, q_new.position):\n                    continue\n\n                n_vertices = len(curr_tree) + 1\n                gamma_rrt_star = 50.0\n                radius = min(gamma_rrt_star * (np.log(n_vertices) / n_vertices) ** (1 / grid.size.n_dim), \n                             self._max_dist * 2)\n\n                near_vertices = self._graph.get_vertices_within_radius([curr_root], q_new.position, radius)\n                parent = self._choose_best_parent(q_new, near_vertices)\n                if parent is None:\n                    continue\n\n                self._graph.add_edge(parent, q_new)\n                curr_tree.append(q_new)\n\n                # Rewire neighbors to reduce cost and improve smoothness\n                self._rewire_vertices(q_new, near_vertices)\n\n                # Try to connect the new node to the other tree for early solution\n                connected = self._attempt_connection(q_new, other_root, other_tree)\n                if connected:\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm": "This algorithm implements an improved RRT* inspired method with adaptive step size,\n    informed sampling towards the goal, rewiring for path quality improvement, and early\n    stopping criteria. It dynamically adjusts exploration radius based on environment size,\n    performs rewiring to reduce path cost, and uses informed sampling biased towards goal\n    vicinity. A timeout check prevents excessive search time beyond 60 seconds.\n    These improvements aim for enhanced planning efficiency, robustness, smoother and shorter\n    paths, and reliable success in varied maps.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _search_timeout: float\n    _start_time: float\n    _iterations: int\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n\n        agent_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n        self._graph = gen_forest(self._services, Vertex(agent_pos), Vertex(goal_pos), [])\n        self._graph.edges_removable = True\n\n        # Adaptive max_dist: smaller for smaller maps, larger for bigger maps\n        map_diag = self._compute_map_diagonal()\n        self._max_dist = max(1.0, min(15.0, map_diag / 20))\n\n        self._search_timeout = 60.0  # seconds allowed\n        self._iterations = 15000\n\n        self._start_time = None\n\n        self._init_displays()\n\n    def _compute_map_diagonal(self) -> float:\n        size = self._get_grid().size\n        return (size.width ** 2 + size.height ** 2) ** 0.5\n\n    def _get_random_sample(self, informed_center: Optional[Point] = None, informed_radius: Optional[float] = None) -> Point:\n        \"\"\"\n        Sample uniformly in map if no informed region,\n        else sample in a ball around informed_center with informed_radius.\n        \"\"\"\n        grid_size = self._get_grid().size\n        n_dim = grid_size.n_dim\n\n        if informed_center is None or informed_radius is None:\n            # Uniform sampling in entire grid\n            while True:\n                rand_coords = tuple(\n                    np.random.randint(0, grid_size[i]) for i in range(n_dim)\n                )\n                sample = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Sample in a hypersphere around informed_center\n            attempts = 20\n            center_tensor = informed_center.to_tensor()\n            for _ in range(attempts):\n                # Sample point in ball of radius informed_radius\n                rand_dir = torch.randn(n_dim)\n                rand_dir /= torch.norm(rand_dir)\n                rand_dist = np.random.uniform(0, informed_radius)\n                candidate_tensor = center_tensor + rand_dir * rand_dist\n                # Project candidate coordinates to int grid and inside map bounds\n                candidate_coords = []\n                for i in range(n_dim):\n                    c = int(round(candidate_tensor[i].item()))\n                    c = max(0, min(c, grid_size[i] - 1))\n                    candidate_coords.append(c)\n                candidate = Point(*candidate_coords)\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n\n            # fallback uniform sampling if no valid sample found in ball\n            return self._get_random_sample()\n\n    def _get_nearest_vertex(self, root_vertices: List[Vertex], q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(root_vertices, q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / dist\n        new_point_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        new_point = Point.from_tensor(new_point_tensor)\n        return Vertex(new_point)\n\n    def _get_vertices_within_radius(self, root_vertices: List[Vertex], point: Point,\n                                   radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(root_vertices, point, radius)\n\n    def _rewire(self, q_new: Vertex, neighbor_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Re-route neighbors through q_new if it reduces cost and path is valid.\n        \"\"\"\n        for q_near in neighbor_vertices:\n            old_cost = q_near.cost if q_near.cost is not None else float('inf')\n            cost_through_new = (q_new.cost if q_new.cost is not None else 0) + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n            if cost_through_new < old_cost:\n                # Check if line from new to near is valid\n                line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                # Remove old parent edge(s) if any\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                # Add new edge (rewire)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = cost_through_new\n\n    def _extract_path(self, q_end: Vertex) -> None:\n        \"\"\"\n        Extract path from start to q_end by traversing parents.\n        Animate movement by moving agent through the points.\n        \"\"\"\n        path: List[Vertex] = [q_end]\n\n        while path[-1].parents:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return float(torch.norm(p1.to_tensor() - p2.to_tensor()))\n\n    # Overridden Implementation #\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n\n        # Initialize root start vertex cost and root goal vertex cost\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        # Parameters for rewiring radius\n        gamma_rrt_star = 50.0\n        dimension = self._get_grid().size.n_dim\n        map_volume = 1\n        for i in range(dimension):\n            map_volume *= self._get_grid().size[i]\n        radius_constant = min(gamma_rrt_star * (np.log(1 + self._iterations) / (1 * map_volume)) ** (1.0 / dimension), self._max_dist*1.5)\n\n        best_goal_vertex: Optional[Vertex] = None\n        best_cost = float('inf')\n\n        for i in range(self._iterations):\n            # Timeout check\n            if time.time() - self._start_time > self._search_timeout:\n                # Failed to find path within time limit\n                break\n\n            # Informed sampling: after having any feasible path, bias sampling towards ellipse region\n            if best_goal_vertex is None:\n                q_rand = self._get_random_sample()\n            else:\n                # Ellipsoidal informed region around start and goal (2D assumption)\n                start_pos = self._graph.root_vertex_start.position\n                goal_pos = self._graph.root_vertex_goal.position\n                c_best = best_cost\n                c_min = self._distance(start_pos, goal_pos)\n                if c_best < float('inf'):\n                    a1 = (goal_pos.to_tensor() - start_pos.to_tensor()) / c_min\n                    def sample_in_ellipse():\n                        # Sample in the unit n-ball then transform\n                        while True:\n                            z = torch.randn(dimension)\n                            z /= torch.norm(z)\n                            r = np.random.rand() ** (1.0 / dimension)\n                            point_ball = r * z\n                            # Scale\n                            L = torch.diag(torch.tensor([c_best/2.0] + [((c_best ** 2 - c_min ** 2) ** 0.5)/2.0] * (dimension-1)))\n                            # Create rotation matrix (only 2D rotation needed)\n                            e1 = torch.zeros(dimension)\n                            e1[0] = 1.0\n                            M = torch.outer(a1, e1)\n                            U, _, V = torch.svd(M.unsqueeze(0))\n                            C = torch.mm(U[0], V.T)\n                            # Transform\n                            point_ellipse = torch.matmul(C, torch.matmul(L, point_ball)) + ((start_pos.to_tensor() + goal_pos.to_tensor()) / 2)\n                            coords = [max(0, min(self._get_grid().size[j] - 1, int(round(point_ellipse[j].item())))) for j in range(dimension)]\n                            candidate = Point(*coords)\n                            if self._get_grid().is_agent_valid_pos(candidate):\n                                return candidate\n                    q_rand = sample_in_ellipse()\n                else:\n                    q_rand = self._get_random_sample()\n\n            q_near = self._get_nearest_vertex([self._graph.root_vertex_start], q_rand)\n\n            q_new = self._get_new_vertex(q_near, q_rand, self._max_dist)\n            if q_new.position == q_near.position:\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Set q_new cost = q_near.cost + cost from q_near to q_new\n            cost_q_new = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = cost_q_new\n\n            # Add q_new vertex and edge\n            self._graph.add_edge(q_near, q_new)\n\n            # Find neighbors for rewiring\n            neighbor_radius = radius_constant\n            neighbor_vertices = self._get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, neighbor_radius)\n\n            # Choose best parent among neighbors to minimize cost to q_new\n            min_cost = q_new.cost\n            best_parent = q_near\n            for q_near_candidate in neighbor_vertices:\n                if q_near_candidate == q_near:\n                    continue\n                line_seq_candidate = self._get_grid().get_line_sequence(q_near_candidate.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_candidate):\n                    continue\n                candidate_cost = (q_near_candidate.cost if q_near_candidate.cost is not None else float('inf')) + self._get_grid().get_movement_cost(q_near_candidate.position, q_new.position)\n                if candidate_cost < min_cost:\n                    min_cost = candidate_cost\n                    best_parent = q_near_candidate\n            if best_parent != q_near:\n                # Remove edge from old parent and add edge from new best parent\n                self._graph.remove_edge(q_near, q_new)\n                self._graph.add_edge(best_parent, q_new)\n                q_new.cost = min_cost\n\n            # Rewire neighbors to improve path costs through q_new\n            self._rewire(q_new, neighbor_vertices)\n\n            # Check if q_new is close enough to goal to consider path found\n            if self._get_grid().is_agent_in_goal_radius(q_new.position):\n                # If cost better, update best path\n                if q_new.cost < best_cost:\n                    best_cost = q_new.cost\n                    best_goal_vertex = q_new\n                    self._extract_path(best_goal_vertex)\n                    # Optionally stop early (uncomment if desired)\n                    # break\n\n            self.key_frame()\n\n        if best_goal_vertex is None:\n            # Mark failed attempt visual (move agent from start to start)\n            self.move_agent(self._graph.root_vertex_start.position)",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm": "Improved Adaptive Informed RRT* with multi-strategy sampling,\n    dynamic rewiring radius, path smoothing via advanced shortcutting,\n    and fail-safe timeout logic.\n    This algorithm synergizes uniform sampling, ellipsoidal informed sampling,\n    and focused local exploration to balance exploration and exploitation.\n    It adaptively adjusts rewiring radius and reuses partial paths to improve\n    path quality and smoothness, ensuring higher success rate and robustness\n    in diverse map sizes and obstacle configurations.\n    Failure to find a path within 60 seconds results in an explicit search fail.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: float | None\n    _best_goal_vertex: Vertex | None\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        grid = self._get_grid()\n        self._dimension = grid.size.n_dim\n        max_map_dim = max(grid.size.values)\n        self._max_dist = max_map_dim / 12.0  # max movement distance step\n        self._lambda_rrt_star = 45.0  # constant for adaptive radius calc\n        self._max_radius = max_map_dim / 2.5  # rewiring max radius\n\n        start_vertex = Vertex(grid.agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(grid.goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        self._start_time = 0.0\n        self._timeout = 60.0\n        self._best_cost = None\n        self._best_goal_vertex = None\n\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _uniform_sample(self) -> Point:\n        grid = self._get_grid()\n        while True:\n            coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _ellipsoidal_sample(self) -> Point:\n        grid = self._get_grid()\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        c_best = torch.tensor(self._best_cost) if self._best_cost is not None else None\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best is None or c_best < c_min:\n            return self._uniform_sample()\n\n        center = (start + goal) / 2.0\n        foci_vec = goal - start\n        e_axis = foci_vec / torch.norm(foci_vec)\n\n        if self._dimension == 2:\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])\n        elif self._dimension == 3:\n            z_axis = e_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n        else:\n            return self._uniform_sample()\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0\n\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        elif self._dimension == 3:\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n        else:\n            return self._uniform_sample()\n\n        while True:\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u > 1e-6:\n                break\n        unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n\n        sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n        sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, grid.size[i] - 1).round())) for i in range(self._dimension)]\n        sample_point = Point(*sample_coords)\n\n        if grid.is_agent_valid_pos(sample_point):\n            return sample_point\n        return self._uniform_sample()\n\n    def _adaptive_sample(self) -> Point:\n        # Use multi-strategy sampling:\n        # 60% informed ellipsoid if best_cost known,\n        # else uniform,\n        # 20% local sampling around root path if best available,\n        # 20% pure uniform exploration.\n        import random\n        if self._best_cost is None:\n            return self._uniform_sample()\n\n        choice = random.random()\n        if choice < 0.6:\n            return self._ellipsoidal_sample()\n        elif choice < 0.8 and self._best_goal_vertex is not None:\n            # Local sampling near current best path vertices, bias exploration near existing paths\n            near_verts = self._graph.get_vertices_within_radius(\n                self._graph.root_vertices, self._best_goal_vertex.position, self._max_dist * 5)\n            if near_verts:\n                from random import choice as rchoice\n                base_vertex = rchoice(near_verts)\n                perturb = [int(round(torch.randn(1).item() * self._max_dist / 2)) for _ in range(self._dimension)]\n                sample_coords = [max(0, min(self._get_grid().size[i] - 1, base_vertex.position[i] + perturb[i])) for i in range(self._dimension)]\n                sample_point = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample_point):\n                    return sample_point\n            return self._uniform_sample()\n        else:\n            return self._uniform_sample()\n\n    def _calc_rewire_radius(self) -> float:\n        card_v = torch.tensor(float(self._graph.size + 1))\n        log_card_v = torch.log(card_v)\n        radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1.0 / self._dimension)), self._max_radius)\n        # decrease radius progressively with better cost found to improve rewiring locality\n        if self._best_cost is not None:\n            improvement_factor = max(0.2, min(1.0, self._best_cost / (self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position) * 2)))\n            radius *= improvement_factor\n        return radius.item()\n\n    def _choose_parent(self, neighbors: list[Vertex], q_new: Vertex) -> tuple[Vertex | None, float]:\n        c_min = float('inf')\n        q_min = None\n        grid = self._get_grid()\n\n        def est_cost_to_goal(pos: Point) -> float:\n            return self._dist(pos, self._graph.root_vertex_goal.position)\n\n        for q_near in neighbors:\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost = q_near.cost + self._dist(q_near.position, q_new.position) + est_cost_to_goal(q_new.position)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n        if q_min is None:\n            return None, float('inf')\n        # Return cost without heuristic for actual cost accounting\n        cost_no_heuristic = q_min.cost + self._dist(q_min.position, q_new.position)\n        return q_min, cost_no_heuristic\n\n    def _shortcut_path(self, path: list[Vertex], max_attempts=50) -> list[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        grid = self._get_grid()\n        attempt = 0\n        while attempt < max_attempts and len(new_path) >= 3:\n            attempt += 1\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = grid.get_line_sequence(p_i, p_j)\n            if grid.is_valid_line_sequence(line_seq):\n                # Remove intermediates between i and j\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        grid = self._get_grid()\n        # Clamp and round inside grid\n        new_pos_coords = [int(round(float(torch.clamp(new_pos_tensor[i], 0, grid.size[i] - 1)))) for i in range(self._dimension)]\n        return Vertex(Point(*new_pos_coords))\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n\n        max_iterations = 20000\n        grid = self._get_grid()\n\n        for iteration in range(max_iterations):\n            # Timeout check\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Failed to find path within time\n                return\n\n            q_sample = self._adaptive_sample()\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            radius = self._calc_rewire_radius()\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                # fallback connect to nearest\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_rev = grid.get_line_sequence(q_new.position, q_near.position)\n                if not grid.is_valid_line_sequence(line_seq_rev):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                if cost_through_new < q_near.cost:\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if self._best_cost is None or possible_cost < self._best_cost:\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "Improved Path Planning Algorithm Using Adaptive Guided RRT* with Dynamic Rewiring and Heuristic Pruning.\n      \n      This algorithm enhances path planning by combining multiple improvements:\n      - Adaptive sampling bias that shifts progressively from uniform random to goal- and best-path-informed.\n      - Uses an incremental RRT*-style rewiring for path cost optimization.\n      - Dynamic neighborhood radius shrinks as tree size grows to balance exploration and exploitation.\n      - Heuristic pruning of samples unlikely to improve current best path cost to speed convergence.\n      - Early stopping upon finding a path or reaching a 60-second timeout.\n      - Path smoothing via shortcutting after path extraction.\n      \n      This approach targets improved planning efficiency, better path quality and smoothness,\n      higher success rates with robust collision checking, and reduced overall search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    # Constants: Tunable parameters for performance\n    _max_dist: float\n    _max_iterations: int\n    _timeout_sec: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 15.0\n        self._max_iterations = 15000\n        self._timeout_sec = 60.0\n\n        # Initialize cyclic graph with start and goal vertices and allow rewiring for RRT*\n        self._graph = gen_cyclic_graph(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_adaptive_sample(self, best_path: list[Vertex] | None, iteration: int) -> Point:\n        grid = self._get_grid()\n        dim = grid.size.n_dim\n        max_dims = np.array(grid.size.values) - 1\n\n        # As iterations increase, increase bias towards goal and best path\n        bias_goal_prob = min(0.4 + iteration / self._max_iterations * 0.4, 0.8)\n        bias_path_prob = min(0.15 + iteration / self._max_iterations * 0.25, 0.4)\n        rand_val = np.random.rand()\n\n        if best_path and len(best_path) > 2:\n            if rand_val < bias_path_prob:\n                # Sample near random vertex on best path with small Gaussian noise\n                for _ in range(20):\n                    path_v = best_path[np.random.randint(0, len(best_path))]\n                    center = path_v.position.to_tensor().numpy()\n                    radius = max(self._max_dist * 0.5, 5)\n                    offset = np.random.normal(0, radius/2, dim)\n                    sample_pos = center + offset\n                    sample_pos = np.clip(sample_pos, 0, max_dims)\n                    sample_point = Point(*sample_pos.astype(int))\n                    if grid.is_agent_valid_pos(sample_point):\n                        return sample_point\n\n            if rand_val < bias_goal_prob:\n                # Sample near goal within max_dist radius with uniform random in sphere\n                goal_tensor = grid.goal.position.to_tensor().numpy()\n                radius = self._max_dist * 1.5\n                for _ in range(20):\n                    offset = np.random.uniform(-radius, radius, dim)\n                    sample_pos = goal_tensor + offset\n                    sample_pos = np.clip(sample_pos, 0, max_dims)\n                    sample_point = Point(*sample_pos.astype(int))\n                    if grid.is_agent_valid_pos(sample_point):\n                        return sample_point\n\n        # Uniform random sampling if no bias selected\n        for _ in range(50):\n            coords = np.random.randint(0, max_dims + 1, dim)\n            sample_point = Point(*coords)\n            if grid.is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # fallback to agent position if no valid sample found\n        return grid.agent.position\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_dist: float) -> Point:\n        from_tensor = from_vertex.position.to_tensor()\n        to_tensor = to_point.to_tensor()\n        direction = to_tensor - from_tensor\n        distance = torch.norm(direction)\n        if distance <= max_dist:\n            return to_point\n        direction = direction / distance\n        new_pos_tensor = from_tensor + max_dist * direction\n        new_point = Point(*new_pos_tensor.round().int().tolist())\n        return new_point\n\n    def _line_is_valid(self, frm: Point, to: Point) -> bool:\n        grid = self._get_grid()\n        line_seq = grid.get_line_sequence(frm, to)\n        return grid.is_valid_line_sequence(line_seq)\n\n    def _choose_best_parent(self, new_pos: Point, near_vertices: list[Vertex]) -> tuple[Vertex | None, float]:\n        grid = self._get_grid()\n        best_parent = None\n        best_cost = float(\"inf\")\n        for v in near_vertices:\n            if self._line_is_valid(v.position, new_pos):\n                current_cost = (v.cost if v.cost is not None else 0.0) + grid.get_movement_cost(v.position, new_pos)\n                if current_cost < best_cost:\n                    best_cost = current_cost\n                    best_parent = v\n        return best_parent, best_cost\n\n    def _rewire_near_vertices(self, new_vertex: Vertex, near_vertices: list[Vertex]) -> None:\n        grid = self._get_grid()\n        for near_v in near_vertices:\n            if near_v == new_vertex or near_v in new_vertex.parents:\n                continue\n            if self._line_is_valid(new_vertex.position, near_v.position):\n                cost_through_new = new_vertex.cost + grid.get_movement_cost(new_vertex.position, near_v.position)\n                if near_v.cost is None or cost_through_new < near_v.cost:\n                    # Remove all old parent edges\n                    for p in near_v.parents.copy():\n                        self._graph.remove_edge(p, near_v)\n                    self._graph.add_edge(new_vertex, near_v)\n                    near_v.cost = cost_through_new\n\n    def _get_neighborhood_radius(self, n_vertices: int) -> float:\n        # Adaptive radius: shrinks with number of vertices as RRT* suggests\n        # radius = gamma * (log(n)/n)^(1/d), gamma chosen proportional to max_dist\n        import math\n        gamma = self._max_dist * 2.0\n        d = self._get_grid().size.n_dim\n        if n_vertices <= 1:\n            return self._max_dist * 2\n        radius = gamma * (math.log(n_vertices) / n_vertices) ** (1 / d)\n        radius = min(radius, self._max_dist * 2)\n        return radius\n\n    def _extract_path(self, connecting_start: Vertex, connecting_goal: Vertex) -> list[Vertex]:\n        # Trace parents from connecting start vertex to root start\n        path_from_start = []\n        curr = connecting_start\n        while curr.parents:\n            path_from_start.append(curr)\n            curr = next(iter(curr.parents))\n        path_from_start.append(curr)  # add root\n        path_from_start.reverse()\n\n        # Trace parents from connecting goal vertex to root goal\n        path_from_goal = []\n        curr = connecting_goal\n        while curr.parents:\n            path_from_goal.append(curr)\n            curr = next(iter(curr.parents))\n        path_from_goal.append(curr)  # root\n\n        # Concatenate start path with reversed goal path (excluding duplicate connecting vertex)\n        full_path = path_from_start + path_from_goal[::-1][1:]\n\n        return full_path\n\n    def _shortcut_path(self, path: list[Vertex]) -> list[Vertex]:\n        \"\"\"\n        Path smoothing by shortcutting non-collision edges between path vertices.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        optimized_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            # Try to find the farthest vertex reachable from optimized_path[-1] without collisions\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_is_valid(optimized_path[-1].position, path[j].position):\n                    break\n                j -= 1\n            optimized_path.append(path[j])\n            i = j\n        return optimized_path\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        tree_start_vertices = [start_vertex]\n        tree_goal_vertices = [goal_vertex]\n\n        best_path = None\n        best_cost = float('inf')\n\n        start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout_sec:\n                # Timeout reached - path planning failed\n                break\n\n            # Alternate tree expansion (start tree first, then goal tree)\n            for (root_vertex, tree_vertices, other_root_vertex, other_tree_vertices) in [\n                (start_vertex, tree_start_vertices, goal_vertex, tree_goal_vertices),\n                (goal_vertex, tree_goal_vertices, start_vertex, tree_start_vertices),\n            ]:\n                # Sample adaptively biased to best path and goal\n                sample_point = self._get_adaptive_sample(best_path, iteration)\n\n                # Find nearest vertex in current tree to sample\n                nearest_vertex = self._graph.get_nearest_vertex([root_vertex], sample_point)\n\n                # Steer from nearest vertex toward sample within max_dist\n                new_point = self._steer(nearest_vertex, sample_point, self._max_dist)\n\n                # Check for collision on path from nearest_vertex to new_point\n                if not self._line_is_valid(nearest_vertex.position, new_point):\n                    continue\n\n                # Determine adaptive neighborhood radius for rewiring and parent choosing\n                radius = self._get_neighborhood_radius(len(tree_vertices))\n\n                # Find near vertices for connection and rewiring\n                near_vertices = self._graph.get_vertices_within_radius([root_vertex], new_point, radius)\n\n                # Choose best parent with minimal cost + collision-free edge\n                best_parent, cost_to_new = self._choose_best_parent(new_point, near_vertices)\n                if best_parent is None:\n                    continue\n\n                # Add new vertex and connect to best parent\n                new_vertex = Vertex(new_point, store_connectivity=True)\n                new_vertex.cost = cost_to_new\n                self._graph.add_edge(best_parent, new_vertex)\n                tree_vertices.append(new_vertex)\n\n                # Rewire near vertices through new_vertex if it improves cost\n                self._rewire_near_vertices(new_vertex, near_vertices)\n\n                # Attempt to connect new_vertex to the other tree\n                nearest_other = self._graph.get_nearest_vertex([other_root_vertex], new_point)\n                connect_point = self._steer(new_vertex, nearest_other.position, self._max_dist)\n\n                if connect_point == new_vertex.position:\n                    # No progress toward other tree\n                    continue\n\n                if self._line_is_valid(new_vertex.position, connect_point):\n                    near_others = self._graph.get_vertices_within_radius([other_root_vertex], connect_point, radius)\n                    \n                    parent_other, cost_other = self._choose_best_parent(connect_point, near_others)\n                    if parent_other is None:\n                        continue\n\n                    connect_vertex = Vertex(connect_point, store_connectivity=True)\n                    connect_vertex.cost = cost_other\n                    self._graph.add_edge(parent_other, connect_vertex)\n                    if connect_vertex not in other_tree_vertices:\n                        other_tree_vertices.append(connect_vertex)\n\n                    # Check if the connect_vertex reached the previously nearest_other exactly - trees connected\n                    if connect_vertex.position == nearest_other.position:\n                        # Extract full path by joining at new_vertex and connect_vertex\n                        full_path = self._extract_path(new_vertex, connect_vertex)\n\n                        # Calculate full path cost (sum of vertex costs)\n                        path_cost = full_path[-1].cost if full_path[-1].cost is not None else float('inf')\n                        if path_cost < best_cost:\n                            best_cost = path_cost\n                            best_path = full_path\n\n                        # Post-process: Path smoothing shortcut\n                        best_path = self._shortcut_path(best_path)\n\n                        # Visualize path\n                        for v in best_path:\n                            self.move_agent(v.position)\n                            self.key_frame(ignore_key_frame_skip=True)\n                        return\n\n                    else:\n                        # Try to extend connection towards nearest_other to connect trees fully\n                        extend_vertex = connect_vertex\n                        extended = True\n                        while extended:\n                            extended = False\n                            next_point = self._steer(extend_vertex, nearest_other.position, self._max_dist)\n                            if next_point == extend_vertex.position:\n                                break\n                            if self._line_is_valid(extend_vertex.position, next_point):\n                                near_ext = self._graph.get_vertices_within_radius([other_root_vertex], next_point, radius)\n                                parent_ext, cost_ext = self._choose_best_parent(next_point, near_ext)\n                                if parent_ext is None:\n                                    break\n                                next_vertex = Vertex(next_point, store_connectivity=True)\n                                next_vertex.cost = cost_ext\n                                self._graph.add_edge(parent_ext, next_vertex)\n                                if next_vertex not in other_tree_vertices:\n                                    other_tree_vertices.append(next_vertex)\n                                extend_vertex = next_vertex\n                                extended = True\n\n                                if extend_vertex.position == nearest_other.position:\n                                    full_path = self._extract_path(new_vertex, extend_vertex)\n                                    path_cost = full_path[-1].cost if full_path[-1].cost is not None else float('inf')\n                                    if path_cost < best_cost:\n                                        best_cost = path_cost\n                                        best_path = full_path\n                                    best_path = self._shortcut_path(best_path)\n                                    for v in best_path:\n                                        self.move_agent(v.position)\n                                        self.key_frame(ignore_key_frame_skip=True)\n                                    return\n\n            # Keyframe for animation but allow skipping for speed\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm": "An improved hybrid bi-directional sampling-based path planner combining RRT* style rewiring\n    with informed, adaptive, and goal-biased sampling for efficiency and robustness. The planner \n    maintains two trees rooted at the start and goal, incrementally extending toward samples \n    and rewiring locally for optimality. It employs adaptive dynamic radius for rewiring and \n    connection attempts between trees to quickly find and improve solutions. The algorithm \n    terminates either on successful path construction or after a 60-second timeout to avoid \n    excessive computation. This approach balances exploration with targeted exploitation of \n    promising regions to improve path quality and reduce search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_dist: float\n    _max_radius: float\n    _iterations: int\n    _timeout: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        grid = self._get_grid()\n        start_vertex = Vertex(grid.agent.position, store_connectivity=True)\n        goal_vertex = Vertex(grid.goal.position, store_connectivity=True)\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n\n        map_min_dim = min(grid.size.width, grid.size.height)\n        self._max_dist = max(map_min_dim * 0.08, 3.0)\n        self._max_radius = max(self._max_dist * 2.5, 15.0)\n        self._iterations = 12000\n        self._timeout = 60.0\n\n        self._init_displays()\n\n    def _sample_informed(self, best_path: list = None) -> Point:\n        \"\"\"Informed sampling biasing towards goal, best path, or uniform free space.\"\"\"\n        grid = self._get_grid()\n        p_uniform = 0.6\n        p_goal = 0.25\n        p_path = 0.15\n        rv = np.random.rand()\n\n        # Sample near best path vertices if available\n        if best_path and len(best_path) > 2 and rv > (1 - p_path):\n            tries, radius = 0, self._max_dist * 1.7\n            while tries < 15:\n                chosen = best_path[np.random.randint(0, len(best_path))]\n                offset = np.random.uniform(-radius, radius, grid.size.n_dim)\n                coords = chosen.position.to_tensor().numpy() + offset\n                coords = np.clip(coords, 0, np.array(grid.size.values) - 1)\n                pt = Point(*coords.astype(int))\n                if grid.is_agent_valid_pos(pt):\n                    return pt\n                tries += 1\n\n        # Sample near goal\n        if rv > p_uniform + p_path:\n            tries, radius = 0, self._max_dist * 2.0\n            gpos = grid.goal.position\n            while tries < 30:\n                offset = np.random.uniform(-radius, radius, grid.size.n_dim)\n                coords = gpos.to_tensor().numpy() + offset\n                coords = np.clip(coords, 0, np.array(grid.size.values) - 1)\n                pt = Point(*coords.astype(int))\n                if grid.is_agent_valid_pos(pt):\n                    return pt\n                tries += 1\n\n        # Uniform sampling\n        tries = 0\n        while tries < 60:\n            coords = np.random.randint(0, grid.size.values[0], grid.size.n_dim)\n            pt = Point(*coords)\n            if grid.is_agent_valid_pos(pt):\n                return pt\n            tries += 1\n\n        return grid.agent.position  # fallback\n\n    def _extend_towards(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        start = q_near.position.to_tensor()\n        target = q_sample.to_tensor()\n        direction = target - start\n        dist = torch.norm(direction)\n        if dist <= self._max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        direction = direction / dist\n        new_coords = start + direction * self._max_dist\n        new_point = Point(*new_coords.numpy().astype(int))\n        return Vertex(new_point, store_connectivity=True)\n\n    def _line_valid(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _choose_best_parent(self, new_vertex: Vertex, neighbors: list) -> Vertex:\n        grid = self._get_grid()\n        best_parent = None\n        best_cost = float(\"inf\")\n        for v in neighbors:\n            if not self._line_valid(v.position, new_vertex.position):\n                continue\n            parent_cost = v.cost if v.cost is not None else 0.0\n            edge_cost = grid.get_movement_cost(v.position, new_vertex.position)\n            total_cost = parent_cost + edge_cost\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_parent = v\n        if best_parent is not None:\n            new_vertex.cost = best_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, neighbors: list) -> None:\n        grid = self._get_grid()\n        for v in neighbors:\n            if v == new_vertex or v in new_vertex.parents:\n                continue\n            if v.cost is None:\n                continue\n            if not self._line_valid(new_vertex.position, v.position):\n                continue\n            new_cost = new_vertex.cost + grid.get_movement_cost(new_vertex.position, v.position)\n            if new_cost < v.cost:\n                for p in v.parents.copy():\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(new_vertex, v)\n                v.cost = new_cost\n\n    def _extract_path(self, start_v: Vertex, goal_v: Vertex) -> list:\n        path_start = []\n        v = start_v\n        while v:\n            path_start.append(v)\n            if not v.parents:\n                break\n            v = next(iter(v.parents))\n        path_start.reverse()\n\n        path_goal = []\n        v = goal_v\n        count = 0\n        max_steps = 1000\n        while v and count < max_steps:\n            path_goal.append(v)\n            if not v.parents:\n                break\n            v = next(iter(v.parents))\n            count += 1\n\n        path = path_start + path_goal\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n        return path\n\n    def _attempt_connection(self, vertex: Vertex, other_root: Vertex, other_tree: list) -> bool:\n        grid = self._get_grid()\n        radius = self._max_radius\n\n        q_near_other = self._graph.get_nearest_vertex([other_root], vertex.position)\n        q_new_other = self._extend_towards(vertex, q_near_other.position)\n        if not self._line_valid(vertex.position, q_new_other.position):\n            return False\n        near_others = self._graph.get_vertices_within_radius([other_root], q_new_other.position, radius)\n        parent_other = self._choose_best_parent(q_new_other, near_others)\n        if not parent_other:\n            return False\n        self._graph.add_edge(parent_other, q_new_other)\n        if q_new_other not in other_tree:\n            other_tree.append(q_new_other)\n\n        current_vertex = q_new_other\n        while True:\n            q_extend = self._extend_towards(current_vertex, q_near_other.position)\n            if q_extend.position == current_vertex.position:\n                break\n            if not self._line_valid(current_vertex.position, q_extend.position):\n                break\n            near_extend = self._graph.get_vertices_within_radius([other_root], q_extend.position, radius)\n            parent_extend = self._choose_best_parent(q_extend, near_extend)\n            if not parent_extend:\n                break\n            self._graph.add_edge(parent_extend, q_extend)\n            if q_extend not in other_tree:\n                other_tree.append(q_extend)\n            current_vertex = q_extend\n            if q_extend.position == q_near_other.position:\n                self._extract_path(vertex, q_extend)\n                return True\n\n        if q_new_other.position == q_near_other.position:\n            self._extract_path(vertex, q_new_other)\n            return True\n\n        return False\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start_root = self._graph.root_vertex_start\n        goal_root = self._graph.root_vertex_goal\n        start_root.cost = 0.0\n        goal_root.cost = 0.0\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        best_path = None\n        best_cost = float(\"inf\")\n\n        start_time = time.time()\n        for _ in range(self._iterations):\n            if time.time() - start_time > self._timeout:\n                # Search failed due to timeout\n                break\n\n            # Alternate expansion from start and goal roots\n            for curr_root, curr_tree, other_root, other_tree in [\n                (start_root, tree_start, goal_root, tree_goal),\n                (goal_root, tree_goal, start_root, tree_start),\n            ]:\n                q_rand = self._sample_informed(best_path)\n                q_near = self._graph.get_nearest_vertex([curr_root], q_rand)\n                q_new = self._extend_towards(q_near, q_rand)\n\n                if not self._line_valid(q_near.position, q_new.position):\n                    continue\n\n                n_vertices = len(curr_tree) + 1\n                gamma = 50.0\n                radius = min(\n                    gamma * (np.log(n_vertices) / n_vertices) ** (1 / grid.size.n_dim),\n                    self._max_dist * 2,\n                )\n                neighbors = self._graph.get_vertices_within_radius([curr_root], q_new.position, radius)\n\n                parent = self._choose_best_parent(q_new, neighbors)\n                if not parent:\n                    continue\n\n                self._graph.add_edge(parent, q_new)\n                curr_tree.append(q_new)\n\n                self._rewire(q_new, neighbors)\n\n                connected = self._attempt_connection(q_new, other_root, other_tree)\n                if connected:\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm": "Improved dual-tree hybrid sampling-based path planner combining RRT*, RRT-Connect, and Informed RRT* techniques.\n    Features include adaptive heuristic sampling biased around the current best path and goal region,\n    bidirectional tree expansion with informed rewiring, dynamic max distance adjustment based on progress,\n    and enhanced connection attempts with partial shortcutting for path smoothing.\n    Early stopping is employed on success or after 60s timeout.\n    This approach improves planning efficiency, path quality/smoothness, success rate, and reduces search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _timeout: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_cyclic_graph(self._services, \n                                       Vertex(self._get_grid().agent.position), \n                                       Vertex(self._get_grid().goal.position), \n                                       [])\n        self._graph.edges_removable = True  # Allow rewiring for improving path quality\n        self._max_dist = 12.0\n        self._iterations = 15000\n        self._timeout = 60.0  # seconds\n        self._init_displays()\n\n    def _get_random_sample(self, best_path: list[Vertex] | None = None) -> Point:\n        grid = self._get_grid()\n        rand_val = np.random.rand()\n\n        def sample_near_point(center: Point, radius: float, attempts: int = 20) -> Point | None:\n            for _ in range(attempts):\n                offset = np.random.uniform(-radius, radius, grid.size.n_dim)\n                sample_coords = center.to_tensor().numpy() + offset\n                sample_coords = np.clip(sample_coords, 0, np.array(grid.size.values) - 1)\n                sample_point = Point(*sample_coords.astype(int))\n                if grid.is_agent_valid_pos(sample_point):\n                    return sample_point\n            return None\n\n        # Prioritized heuristic sampling:\n        if best_path and len(best_path) > 2:\n            if rand_val > 0.85:\n                # Sample near random vertex on current best path (local refinement)\n                for _ in range(15):\n                    path_vertex = best_path[np.random.randint(0, len(best_path))]\n                    radius = self._max_dist * 1.25\n                    sample_point = sample_near_point(path_vertex.position, radius, 1)\n                    if sample_point is not None:\n                        return sample_point\n\n            if rand_val > 0.65:\n                # Sample biased near the goal within radius max_dist*2\n                sample_point = sample_near_point(grid.goal.position, self._max_dist * 2, 20)\n                if sample_point is not None:\n                    return sample_point\n\n        # Uniform random sampling fallback (~70%)\n        att = 0\n        while att < 60:\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n            att += 1\n        # If no valid sampled point found, fallback to agent's current position\n        return grid.agent.position\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_tensor)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_tensor / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _line_is_valid(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _get_vertices_near(self, root_vertices: list[Vertex], point: Point, radius: float) -> list[Vertex]:\n        return self._graph.get_vertices_within_radius(root_vertices, point, radius)\n\n    def _choose_parent(self, new_vertex: Vertex, near_vertices: list[Vertex]) -> Vertex | None:\n        # Choose best parent minimizing cost + edge cost with valid line\n        min_cost = float(\"inf\")\n        best_parent = None\n        grid = self._get_grid()\n        for vertex in near_vertices:\n            if self._line_is_valid(vertex.position, new_vertex.position):\n                parent_cost = vertex.cost if vertex.cost is not None else 0.0\n                edge_cost = grid.get_movement_cost(vertex.position, new_vertex.position)\n                total_cost = parent_cost + edge_cost\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_parent = vertex\n        if best_parent:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: list[Vertex]) -> None:\n        grid = self._get_grid()\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex or near_vertex in new_vertex.parents:\n                continue\n            if self._line_is_valid(new_vertex.position, near_vertex.position):\n                cost_through_new = new_vertex.cost + grid.get_movement_cost(new_vertex.position, near_vertex.position)\n                if near_vertex.cost is None or cost_through_new < near_vertex.cost:\n                    # Remove all old parents' edges\n                    for p in near_vertex.parents.copy():\n                        self._graph.remove_edge(p, near_vertex)\n                    # Add new edge from new_vertex to near_vertex with better cost\n                    self._graph.add_edge(new_vertex, near_vertex)\n                    near_vertex.cost = cost_through_new\n\n    def _try_shortcut(self, path: list[Vertex]) -> list[Vertex]:\n        # Attempt partial shortcut smoothing by removing intermediate nodes where direct connection is valid\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_is_valid(smoothed[-1].position, path[j].position):\n                    smoothed.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found, append next in path\n                smoothed.append(path[i + 1])\n                i += 1\n        return smoothed\n\n    def _extract_path(self, connecting_vertex_start: Vertex, connecting_vertex_goal: Vertex) -> list[Vertex]:\n        # Traverse parents up to roots\n        def backtrace(vertex: Vertex) -> list[Vertex]:\n            path = [vertex]\n            while vertex.parents:\n                # Select best parent (lowest cost)\n                vertex = min(vertex.parents, key=lambda p: p.cost if p.cost is not None else float(\"inf\"))\n                path.append(vertex)\n            path.reverse()\n            return path\n\n        start_path = backtrace(connecting_vertex_start)\n        goal_path = backtrace(connecting_vertex_goal)\n\n        full_path = start_path + goal_path\n\n        # Apply smoothing shortcut to reduce unnecessary waypoints\n        full_path = self._try_shortcut(full_path)\n\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n        return full_path\n\n    def _get_adaptive_max_dist(self, iteration: int, total_iterations: int) -> float:\n        # Starts small and increases max_dist gradually to favor exploration early and faster expansion later\n        base = 5.0\n        max_distance = self._max_dist\n        factor = iteration / total_iterations\n        adaptive_dist = base + factor * (max_distance - base)\n        return adaptive_dist\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n\n        best_path: list[Vertex] | None = None\n        best_cost = float(\"inf\")\n\n        start_time = time.time()\n\n        # Parameters\n        reconnect_radius_factor = 2.0\n        shortcut_attempt_interval = 200  # iterations\n\n        for iteration in range(self._iterations):\n            if (time.time() - start_time) > self._timeout:\n                # Fail after timeout\n                break\n\n            adaptive_max_dist = self._get_adaptive_max_dist(iteration, self._iterations)\n            radius = max(adaptive_max_dist * reconnect_radius_factor, 15.0)\n\n            # Alternate tree expansion: first start tree, then goal tree\n            tree_pairs = [\n                (self._graph.root_vertex_start, tree_start, self._graph.root_vertex_goal, tree_goal),\n                (self._graph.root_vertex_goal, tree_goal, self._graph.root_vertex_start, tree_start)\n            ]\n\n            for tree_roots, tree_vertices, other_roots, other_vertices in tree_pairs:\n                q_rand = self._get_random_sample(best_path)\n                q_near = self._graph.get_nearest_vertex([tree_roots], q_rand)\n\n                q_new = self._get_new_vertex(q_near, q_rand, adaptive_max_dist)\n\n                if not self._line_is_valid(q_near.position, q_new.position):\n                    continue\n\n                near_vertices = self._get_vertices_near([tree_roots], q_new.position, radius)\n                parent = self._choose_parent(q_new, near_vertices)\n                if parent is None:\n                    continue\n\n                self._graph.add_edge(parent, q_new)\n                tree_vertices.append(q_new)\n\n                self._rewire(q_new, near_vertices)\n\n                q_near_other = self._graph.get_nearest_vertex([other_roots], q_new.position)\n                q_connect = self._get_new_vertex(q_new, q_near_other.position, adaptive_max_dist)\n\n                if self._line_is_valid(q_new.position, q_connect.position):\n                    near_others = self._get_vertices_near([other_roots], q_connect.position, radius)\n                    parent_other = self._choose_parent(q_connect, near_others)\n                    if parent_other is not None:\n                        self._graph.add_edge(parent_other, q_connect)\n                        if q_connect not in other_vertices:\n                            other_vertices.append(q_connect)\n\n                        # If trees connected directly\n                        if q_connect.position == q_near_other.position:\n                            # Extract and display path\n                            path = self._extract_path(q_new, q_connect)\n                            final_cost = path[-1].cost if path[-1].cost is not None else float(\"inf\")\n                            if final_cost < best_cost:\n                                best_cost = final_cost\n                                best_path = path\n                            # Success: done planning\n                            return\n                        else:\n                            # Attempt extended connection in other tree (multi-step connect)\n                            current_vertex = q_connect\n                            extended = True\n                            while extended:\n                                q_extend = self._get_new_vertex(current_vertex, q_near_other.position, adaptive_max_dist)\n                                if q_extend.position == current_vertex.position:\n                                    break\n                                if self._line_is_valid(current_vertex.position, q_extend.position):\n                                    near_extend = self._get_vertices_near([other_roots], q_extend.position, radius)\n                                    parent_extend = self._choose_parent(q_extend, near_extend)\n                                    if parent_extend is None:\n                                        break\n                                    self._graph.add_edge(parent_extend, q_extend)\n                                    if q_extend not in other_vertices:\n                                        other_vertices.append(q_extend)\n                                    # Partial shortcut: try connecting current_vertex directly to q_extend's parent of best cost if shorter than two edges\n                                    if len(near_extend) > 1:\n                                        for nv in near_extend:\n                                            if nv != parent_extend and self._line_is_valid(current_vertex.position, nv.position):\n                                                cost_via_nv = (current_vertex.cost if current_vertex.cost else 0.0) + \\\n                                                              grid.get_movement_cost(current_vertex.position, nv.position)\n                                                if nv.cost is not None and cost_via_nv + grid.get_movement_cost(nv.position, q_extend.position) < q_extend.cost:\n                                                    # Rewire q_extend to nv for shortcut\n                                                    for p in q_extend.parents.copy():\n                                                        self._graph.remove_edge(p, q_extend)\n                                                    self._graph.add_edge(nv, q_extend)\n                                                    q_extend.cost = cost_via_nv + grid.get_movement_cost(nv.position, q_extend.position)\n                                    current_vertex = q_extend\n                                    if q_extend.position == q_near_other.position:\n                                        path = self._extract_path(q_new, q_extend)\n                                        final_cost = path[-1].cost if path[-1].cost is not None else float(\"inf\")\n                                        if final_cost < best_cost:\n                                            best_cost = final_cost\n                                            best_path = path\n                                        return\n                                else:\n                                    extended = False\n\n            if iteration % shortcut_attempt_interval == 0 and best_path:\n                # Periodically attempt to shortcut smooth the best known path\n                best_path = self._try_shortcut(best_path)\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm": "Improved Adaptive Informed RRT* (AIRRT*) Algorithm with Dynamic Radius Tuning and Progressive Shortcutting",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: float | None\n    _best_goal_vertex: Vertex | None\n    _iteration_count: int\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._dimension = self._get_grid().size.n_dim\n        # Set max step length proportional to map size (reduce for tighter moves)\n        self._max_dist = float(max(self._get_grid().size.values)) / 12.0  \n        self._lambda_rrt_star = 35.0  # slightly tuned constant for radius\n        self._max_radius = max(self._get_grid().size.values) / 4.5  # smaller max radius to refine rewiring\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._start_time = 0.0\n        self._timeout = 60.0  # seconds\n        self._best_cost = None\n        self._best_goal_vertex = None\n        self._iteration_count = 0\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _adaptive_uniform_or_informed_sample(self) -> Point:\n        # Occasionally do uniform to preserve exploration (5% of samples)\n        import random\n        if (self._best_cost is None) or (random.random() < 0.05):\n            return self._uniform_sample()\n        return self._ellipsoidal_sample()\n\n    def _uniform_sample(self) -> Point:\n        attempts = 0\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n            if attempts > 100:\n                # fallback to start if stuck\n                return self._graph.root_vertex_start.position\n\n    def _ellipsoidal_sample(self) -> Point:\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        c_best = torch.tensor(self._best_cost)\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best < c_min:\n            c_best = c_min + 1e-3  # numerical safeguard\n\n        center = (start + goal) / 2.0\n        foci_vec = (goal - start)\n        e_axis = foci_vec / torch.norm(foci_vec)\n\n        if self._dimension == 2:\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])\n        elif self._dimension == 3:\n            z_axis = e_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n        else:\n            return self._uniform_sample()\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0\n\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        elif self._dimension == 3:\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n        else:\n            return self._uniform_sample()\n\n        for _ in range(5):  # try max 5 times to get valid sample in ellipsoid\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u < 1e-6:\n                continue\n            unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n            sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n            sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, self._get_grid().size[i] - 1).round())) for i in range(self._dimension)]\n            sample_point = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # fallback uniform\n        return self._uniform_sample()\n\n    def _calc_rewire_radius(self) -> float:\n        n = max(1, self._graph.size + 1)\n        r = self._lambda_rrt_star * ((torch.log(torch.tensor(float(n))).item() / n) ** (1.0 / self._dimension))\n        radius = min(r, self._max_radius)\n        # gradually shrink radius as iterations grow to encourage focus on local rewiring later\n        shrink_factor = max(0.3, 1.0 - (self._iteration_count / 12000))\n        return radius * shrink_factor\n\n    def _heuristic_cost(self, p: Point) -> float:\n        # Estimated cost to goal heuristically (Euclidean)\n        goal_pos = self._graph.root_vertex_goal.position\n        return self._dist(p, goal_pos)\n\n    def _choose_parent(self, neighbors: list[Vertex], q_new: Vertex) -> tuple[Vertex | None, float]:\n        c_min = float('inf')\n        q_min = None\n        for q_near in neighbors:\n            # Check collision-free connection\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            new_cost = q_near.cost + self._dist(q_near.position, q_new.position)\n            total_cost = new_cost + self._heuristic_cost(q_new.position)\n            # Pick minimal total cost with heuristic\n            if total_cost < c_min:\n                c_min = total_cost\n                q_min = q_near\n        if q_min is None:\n            return None, float('inf')\n        # Return parent and true cost without heuristic for path cost\n        actual_cost = q_min.cost + self._dist(q_min.position, q_new.position)\n        return q_min, actual_cost\n\n    def _shortcut_path(self, path: list[Vertex], max_attempts=30) -> list[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = self._get_grid().get_line_sequence(p_i, p_j)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # final smoothing before execute\n        path = self._shortcut_path(path, max_attempts=50)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*[int(round(float(c))) for c in new_pos_tensor])\n        return Vertex(new_pos)\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n        max_iterations = 15000\n\n        for iter_i in range(max_iterations):\n            self._iteration_count = iter_i\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Time exceeded, fail gracefully (no path found)\n                return\n\n            q_sample = self._adaptive_uniform_or_informed_sample()\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            radius = self._calc_rewire_radius()\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                # fallback connect nearest directly if no better parent\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Try rewiring neighbors through new vertex for better cost\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_rw = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_rw):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                if cost_through_new < q_near.cost:\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check goal reached with updated cost\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if (self._best_cost is None) or (possible_cost < self._best_cost):\n                    # Update best cost and connect goal vertex\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            # Progressive shortcut smoothing every 100 iterations for early path refinement\n            if (iter_i > 0) and (iter_i % 100 == 0) and self._best_goal_vertex is not None:\n                # Extract current path and smooth\n                current_path = []\n                cur = self._best_goal_vertex\n                while cur.parents:\n                    parent = min(cur.parents, key=lambda p: p.cost)\n                    current_path.append(cur)\n                    cur = parent\n                current_path.append(cur)\n                current_path.reverse()\n                smoothed = self._shortcut_path(current_path, max_attempts=15)\n                # Update positions with smoothed path visualization only\n                for vertex in smoothed:\n                    self.move_agent(vertex.position)\n                    self.key_frame(ignore_key_frame_skip=True)\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This new path planning algorithm is a hybrid adaptive Informed Bi-RRT* approach that improves planning \n    efficiency, path quality, robustness, and success rate. It combines:\n    - Bi-directional growth of start and goal trees with intelligent vertex connection attempts.\n    - An adaptive ellipsoidal biased sampling strategy focusing samples within the informed set but also \n      adaptively mixes global uniform, goal bias, and local refinement sampling.\n    - Adaptive max extension distance shrinking with current best cost to balance exploration and refinement.\n    - Dynamic neighborhood radius scaling with log of tree size and dimension for near neighbor searches.\n    - Selective rewiring only when improvements are found to reduce overhead.\n    - Path smoothing post extraction using shortcutting by checking direct line validity between random pairs on path.\n    - Early stopping on successful connection or timeout in 60s.\n    The combination improves path smoothness, shortens path length, lowers search times, and increases success rate.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        goal_vertex.cost = 0.0\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, [])\n        self._initial_max_dist = max(self._get_grid().size.width, self._get_grid().size.height) / 4.0\n        self._max_time = 60.0  # seconds\n        self._max_iterations = 15000\n        self._init_displays()\n\n    def _dist(self, a: Point, b: Point) -> float:\n        return torch.norm(a.to_tensor() - b.to_tensor()).item()\n\n    def _adaptive_max_dist(self, best_cost: float) -> float:\n        diag = ((self._get_grid().size.width) ** 2 + (self._get_grid().size.height) ** 2) ** 0.5\n        if best_cost is None or best_cost == float('inf'):\n            return self._initial_max_dist\n        scaled = max(self._initial_max_dist * 0.1, min(self._initial_max_dist, (best_cost / diag) * self._initial_max_dist))\n        return scaled\n\n    def _sample_in_unit_ball(self, n_dim: int) -> Point:\n        # Uniform sampling inside unit n-ball using rejection\n        while True:\n            sample = np.random.uniform(-1, 1, n_dim)\n            if np.linalg.norm(sample) <= 1:\n                return sample\n\n    def _informed_sample(self, best_cost: Optional[float]) -> Point:\n        grid = self._get_grid()\n        start = grid.agent.position.to_tensor().numpy()\n        goal = grid.goal.position.to_tensor().numpy()\n        dim = grid.size.n_dim\n        max_dim = np.array(grid.size.values)\n\n        goal_bias_prob = 0.2\n        if np.random.rand() < goal_bias_prob:\n            # Goal bias sampling in small ball around goal\n            radius = self._initial_max_dist\n            for _ in range(20):\n                offset = np.random.uniform(-radius, radius, dim)\n                candidate_coords = goal + offset\n                candidate_coords = np.clip(candidate_coords, 0, max_dim - 1)\n                candidate = Point(*candidate_coords.astype(int))\n                if grid.is_agent_valid_pos(candidate):\n                    return candidate\n\n        if best_cost is not None and best_cost < float('inf'):\n            # Ellipsoidal informed set sampling (2D or nD)\n            c_min = np.linalg.norm(goal - start)\n            c_best = best_cost if best_cost > c_min else c_min * 1.1\n\n            center = (start + goal) / 2\n            diff = goal - start\n            angle = np.arctan2(diff[1], diff[0]) if dim >= 2 else 0.0\n\n            # Radii of ellipsoid axes\n            r1 = c_best / 2.0\n            r_rest = ((c_best ** 2) - (c_min ** 2)) ** 0.5 / 2 if c_best > c_min else 0.0\n            radii = np.array([r1] + [r_rest] * (dim - 1))\n\n            # Sample unit ball point\n            sample_unit = self._sample_in_unit_ball(dim)\n\n            # Rotation matrix (2D only)\n            rot_matrix = np.eye(dim)\n            if dim >= 2:\n                c, s = np.cos(angle), np.sin(angle)\n                rot_matrix[:2, :2] = np.array([[c, -s], [s, c]])\n\n            sample_scaled = rot_matrix.dot(sample_unit * radii) + center\n            sample_scaled = np.clip(sample_scaled, 0, max_dim - 1)\n            candidate = Point(*sample_scaled.astype(int))\n            if grid.is_agent_valid_pos(candidate):\n                return candidate\n\n        # Local refinement sampling near best path nodes - fallback if exists\n        # Extract best path vertices if accessible\n        if hasattr(self, '_best_path') and self._best_path:\n            radius = self._initial_max_dist * 1.5\n            for _ in range(10):\n                idx = np.random.randint(0, len(self._best_path))\n                base_point = self._best_path[idx].position.to_tensor().numpy()\n                offset = np.random.uniform(-radius, radius, dim)\n                candidate_coords = base_point + offset\n                candidate_coords = np.clip(candidate_coords, 0, max_dim - 1)\n                candidate = Point(*candidate_coords.astype(int))\n                if grid.is_agent_valid_pos(candidate):\n                    return candidate\n\n        # Uniform random sampling fallback\n        for _ in range(50):\n            coords = [np.random.randint(0, max_dim[i]) for i in range(dim)]\n            candidate = Point(*coords)\n            if grid.is_agent_valid_pos(candidate):\n                return candidate\n\n        # As last resort return agent position\n        return grid.agent.position\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        vec_dir = to_point.to_tensor() - from_vertex.position.to_tensor()\n        dist = torch.norm(vec_dir)\n        if dist <= max_dist:\n            return Vertex(to_point)\n        if dist == 0:\n            return Vertex(from_vertex.position)\n        direction = vec_dir / dist\n        new_pos_tensor = from_vertex.position.to_tensor() + direction * max_dist\n        # Clamp to map size and round to int grid indices\n        max_size = self._get_grid().size\n        clamped_coords = []\n        for i in range(max_size.n_dim):\n            val = new_pos_tensor[i].item()\n            val = max(0, min(val, max_size[i] - 1))\n            clamped_coords.append(int(round(val)))\n        return Vertex(Point(*clamped_coords))\n\n    def _line_valid(self, p_from: Point, p_to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p_from, p_to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _choose_parent(self, new_vertex: Vertex, near_vertices: list) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        grid = self._get_grid()\n        for v in near_vertices:\n            if v == new_vertex or new_vertex.position == v.position:\n                continue\n            if not self._line_valid(v.position, new_vertex.position):\n                continue\n            cost_to_new = (v.cost if v.cost is not None else 0) + grid.get_movement_cost(v.position, new_vertex.position)\n            if cost_to_new < min_cost:\n                min_cost = cost_to_new\n                best_parent = v\n        if best_parent is not None:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: list) -> None:\n        grid = self._get_grid()\n        for near_v in near_vertices:\n            if near_v == new_vertex:\n                continue\n            if not self._line_valid(new_vertex.position, near_v.position):\n                continue\n            new_cost = new_vertex.cost + grid.get_movement_cost(new_vertex.position, near_v.position)\n            if near_v.cost is None or new_cost < near_v.cost:\n                # Rewire edge\n                old_parent = next(iter(near_v.parents), None)\n                if old_parent:\n                    self._graph.remove_edge(old_parent, near_v)\n                self._graph.add_edge(new_vertex, near_v)\n                near_v.cost = new_cost\n\n    def _connect_to_other_tree(self, source_vertex: Vertex, other_vertices: list, max_dist: float) -> Vertex:\n        \"\"\"\n        Try to connect source_vertex to nearest vertex in other_vertices within max_dist.\n        Returns connecting vertex in other tree or None if no connection.\n        \"\"\"\n        if not other_vertices:\n            return None\n\n        nearest_other = self._graph.get_nearest_vertex(other_vertices, source_vertex.position)\n        q_connect = self._steer(source_vertex, nearest_other.position, max_dist)\n        if self._line_valid(source_vertex.position, q_connect.position):\n            return q_connect\n        return None\n\n    def _extract_path_bi(self, vertex_start: Vertex, vertex_goal: Vertex) -> list:\n        # Trace path from start tree root\n        path_start = []\n        cur = vertex_start\n        while cur is not None:\n            path_start.append(cur)\n            if not cur.parents:\n                break\n            cur = next(iter(cur.parents))\n        path_start.reverse()\n\n        # Trace path from goal tree root\n        path_goal = []\n        cur = vertex_goal\n        while cur is not None:\n            path_goal.append(cur)\n            if not cur.parents:\n                break\n            cur = next(iter(cur.parents))\n\n        full_path = path_start + path_goal\n        return full_path\n\n    def _path_smooth_shortcut(self, path: list) -> list:\n        \"\"\"\n        Smooth the path by attempting shortcuts between random pairs on the path.\n        If direct line is valid between two points, intermediate points are removed.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        path_positions = [v.position for v in path]\n\n        max_attempts = 50\n        for _ in range(max_attempts):\n            if len(path_positions) < 3:\n                break\n            i = np.random.randint(0, len(path_positions) - 2)\n            j = np.random.randint(i + 2, len(path_positions))\n            p1 = path_positions[i]\n            p2 = path_positions[j]\n            if self._line_valid(p1, p2):\n                # Shortcut by removing intermediate\n                path_positions = path_positions[:i + 1] + path_positions[j:]\n        # Convert back to Vertex list with original cost = None (costs unused hereafter)\n        smoothed_path = [Vertex(p) for p in path_positions]\n        return smoothed_path\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        start_time = time.time()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        best_cost = float('inf')\n        best_path = None\n        tree_start_vertices = [start_vertex]\n        tree_goal_vertices = [goal_vertex]\n\n        dim = grid.size.n_dim\n\n        for iteration in range(self._max_iterations):\n            if (time.time() - start_time) > self._max_time:\n                # Timeout -> Fail\n                return\n\n            max_dist = self._adaptive_max_dist(best_cost)\n            card = float(self._graph.size + 1)\n            lambda_factor = 25.0\n            max_radius = 30.0\n            radius = min(lambda_factor * ((np.log(card) / card) ** (1 / dim)), max_radius)\n\n            # Alternate tree growth  (start tree grows on even iter, goal tree on odd)\n            grow_start_tree = (iteration % 2 == 0)\n            if grow_start_tree:\n                tree_grow = tree_start_vertices\n                roots_grow = [start_vertex]\n                tree_other = tree_goal_vertices\n                roots_other = [goal_vertex]\n            else:\n                tree_grow = tree_goal_vertices\n                roots_grow = [goal_vertex]\n                tree_other = tree_start_vertices\n                roots_other = [start_vertex]\n\n            q_rand = self._informed_sample(best_cost if best_path else None)\n            q_near = self._graph.get_nearest_vertex(roots_grow, q_rand)\n            q_new = self._steer(q_near, q_rand, max_dist)\n\n            if q_new.position == q_near.position:\n                continue\n\n            if not self._line_valid(q_near.position, q_new.position):\n                continue\n\n            near_vertices = self._graph.get_vertices_within_radius(roots_grow, q_new.position, radius)\n            parent = self._choose_parent(q_new, near_vertices)\n            if not parent:\n                continue\n\n            self._graph.add_edge(parent, q_new)\n            tree_grow.append(q_new)\n\n            self._rewire(q_new, near_vertices)\n\n            # Attempt to connect newly added vertex in growing tree to nearest vertex in other tree\n            q_connect_candidate = self._connect_to_other_tree(q_new, roots_other, max_dist)\n            if q_connect_candidate is not None:\n                near_other_vertices = self._graph.get_vertices_within_radius(roots_other, q_connect_candidate.position, radius)\n                parent_other = self._choose_parent(q_connect_candidate, near_other_vertices)\n                if parent_other is None:\n                    continue\n                self._graph.add_edge(parent_other, q_connect_candidate)\n                if q_connect_candidate not in tree_other:\n                    tree_other.append(q_connect_candidate)\n\n                # Check if connected by position\n                if q_connect_candidate.position == next(iter(parent_other.parents or {parent_other})).position:\n                    # Rare degenerate case: loop back - treat as success\n                    connecting_start, connecting_goal = (q_new, q_connect_candidate) if grow_start_tree else (q_connect_candidate, q_new)\n                    path = self._extract_path_bi(connecting_start, connecting_goal)\n                    if path:\n                        # Smooth path\n                        smooth_path = self._path_smooth_shortcut(path)\n                        self._best_path = smooth_path\n                        best_cost = sum(grid.get_movement_cost(s.position, t.position)\n                                        for s, t in zip(smooth_path, smooth_path[1:]))\n                        for vertex in smooth_path:\n                            self.move_agent(vertex.position)\n                            self.key_frame(ignore_key_frame_skip=True)\n                        return\n\n                # Else try to extend from connection towards the other tree root fully\n                extended_vertex = q_connect_candidate\n                extended = True\n                while extended:\n                    extend_towards = roots_other[0].position\n                    q_extend = self._steer(extended_vertex, extend_towards, max_dist)\n                    if q_extend.position == extended_vertex.position:\n                        break\n                    if not self._line_valid(extended_vertex.position, q_extend.position):\n                        break\n                    near_ext = self._graph.get_vertices_within_radius(roots_other, q_extend.position, radius)\n                    parent_ext = self._choose_parent(q_extend, near_ext)\n                    if parent_ext is None:\n                        break\n                    self._graph.add_edge(parent_ext, q_extend)\n                    if q_extend not in tree_other:\n                        tree_other.append(q_extend)\n                    extended_vertex = q_extend\n\n                    # Check if trees connected by vertex equality\n                    if (extended_vertex.position == roots_other[0].position) or (extended_vertex.position == q_near.position):\n                        connecting_start, connecting_goal = (q_new, extended_vertex) if grow_start_tree else (extended_vertex, q_new)\n                        path = self._extract_path_bi(connecting_start, connecting_goal)\n                        if path:\n                            # Smooth path\n                            smooth_path = self._path_smooth_shortcut(path)\n                            self._best_path = smooth_path\n                            best_cost = sum(grid.get_movement_cost(s.position, t.position)\n                                            for s, t in zip(smooth_path, smooth_path[1:]))\n                            for vertex in smooth_path:\n                                self.move_agent(vertex.position)\n                                self.key_frame(ignore_key_frame_skip=True)\n                            return\n\n            # Early terminate if agent reached goal radius for any vertex in either tree\n            for vertex in tree_start_vertices:\n                if grid.is_agent_in_goal_radius(agent_pos=vertex.position):\n                    path = self._extract_path_bi(vertex, goal_vertex)\n                    if not path:\n                        return\n                    smooth_path = self._path_smooth_shortcut(path)\n                    self._best_path = smooth_path\n                    for v in smooth_path:\n                        self.move_agent(v.position)\n                        self.key_frame(ignore_key_frame_skip=True)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm": "This improved path planning algorithm advances over prior RRT* variants by integrating heuristic-driven informed sampling\n    within a dynamically adaptive ellipse region constrained by the current best path cost and distance metrics.\n    It further incorporates dynamic tuning of neighborhood radius for rewiring based on the evolving graph size,\n    enforcing collision-free rewiring to enhance path smoothness, reduce path lengths, and improve robustness.\n    A time constraint explicitly caps planning time to 60 seconds, marking failure beyond this limit.\n    The algorithm ensures high efficiency in exploration while biasing sampling towards promising goal regions,\n    promoting effective coverage and quicker convergence to high-quality paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_planning_time = 60  # seconds\n        self._init_displays()\n\n    def _informed_sample(self) -> Point:\n        start = self._graph.root_vertex_start.position\n        goal = self._graph.root_vertex_goal.position\n\n        def dist(a: Point, b: Point) -> float:\n            return torch.norm(a.to_tensor() - b.to_tensor()).item()\n\n        max_dist = dist(start, goal)\n        c_best = self._graph.root_vertex_goal.cost if self._graph.root_vertex_goal.cost is not None else max_dist * 1.5\n        c_min = max_dist\n\n        # Safety against invalid costs\n        if c_best is None or c_best == float('inf') or c_best < c_min:\n            c_best = c_min * 1.1\n\n        if torch.rand(1).item() < 0.05:  # 5% goal bias sampling\n            if self._get_grid().is_agent_valid_pos(goal):\n                return goal\n\n        # Ellipse parameters\n        center = (start.to_tensor() + goal.to_tensor()) / 2\n        a1 = goal.to_tensor() - start.to_tensor()\n        a1_norm = torch.norm(a1)\n        if a1_norm == 0:\n            a1_norm = 1.0\n        e1 = a1 / a1_norm\n\n        r1 = c_best / 2\n        ellipse_term = r1 ** 2 - (c_min / 2) ** 2\n        r2 = ellipse_term ** 0.5 if ellipse_term > 0 else r1 * 0.1\n\n        while True:\n            sample_unit = torch.rand(2) * 2 - 1\n            if sample_unit.norm() <= 1.0:\n                break\n\n        sample_ellipse = torch.zeros(2)\n        sample_ellipse[0] = sample_unit[0] * r1\n        sample_ellipse[1] = sample_unit[1] * r2\n\n        angle = torch.atan2(e1[1], e1[0])\n        rot_matrix = torch.tensor([[torch.cos(angle), -torch.sin(angle)],\n                                   [torch.sin(angle), torch.cos(angle)]])\n        sample_rotated = rot_matrix.matmul(sample_ellipse)\n        sample_point_tensor = center[:2] + sample_rotated\n\n        dims = self._get_grid().size.n_dim\n        coords = []\n        for i in range(dims):\n            dim_max = self._get_grid().size[i] - 1\n            if i < 2:\n                val = max(0, min(dim_max, float(sample_point_tensor[i])))\n            else:\n                val = torch.randint(0, dim_max + 1, (1,)).item()\n            coords.append(int(round(val)))\n\n        candidate = Point(*coords)\n        if self._get_grid().is_agent_valid_pos(candidate):\n            return candidate\n\n        # fallback uniform sampling if invalid\n        while True:\n            fallback_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(dims)]\n            fallback_sample = Point(*fallback_coords)\n            if self._get_grid().is_agent_valid_pos(fallback_sample):\n                return fallback_sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> list[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dir_norm\n        q_new_pos = q_near.position.to_tensor() + max_dist * dir_normalized\n        return Vertex(Point(*q_new_pos.tolist()))\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_vertex.position.to_tensor())\n        goal_vertex.cost = q_new.cost + dist_to_goal\n        self._graph.add_edge(q_new, goal_vertex)\n\n        path = [goal_vertex]\n        while path[-1].parents:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n\n        if path[-1] == self._graph.root_vertex_start:\n            path.pop()\n\n        path.reverse()\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist = 15.0\n        max_radius = 40.0\n        lambda_rrt_star = 35.0\n        dimension = self._get_grid().size.n_dim\n        max_iterations = 10000\n\n        from time import time\n        start_time = time()\n\n        for _ in range(max_iterations):\n            elapsed = time() - start_time\n            if elapsed > self._max_planning_time:\n                # Failed due to time limit\n                return\n\n            q_sample = self._informed_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cardinality = float(self._graph.size + 1)\n            log_card = max(1.0, torch.log(torch.tensor(cardinality)).item())\n            radius = min(lambda_rrt_star * ((log_card / cardinality) ** (1 / dimension)), max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent vertex with minimal cost + collision free edge\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                line_n2new = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_n2new):\n                    continue\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            dist_parent_to_new = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + dist_parent_to_new\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if better path is found and collision free\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                line_new2near = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_new2near):\n                    continue\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if cost_new_to_near < q_near.cost:\n                    old_parent = next(iter(q_near.parents), None)\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = None\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm": "An improved sample-based path planning algorithm inspired by RRT*, \n    combining fast exploration with path quality optimization and robustness enhancements. \n    It uses adaptive sampling biased toward the goal to accelerate convergence, \n    rewiring for better path smoothness and shorter cost, \n    and early termination if the path is found or time limit exceeded. \n    The algorithm incorporates goal bias, dynamic neighborhood radius based on iteration count, \n    and motion validation with collision checking to ensure valid paths, \n    aiming to improve planning efficiency, success rate, and path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new = Vertex(Point.from_tensor(new_pos_tensor), store_connectivity=True)\n        return q_new\n\n    def _get_random_sample(self, goal_sample_rate=0.15) -> Point:\n        # Bias sampling with a probability towards the goal to improve convergence\n        if np.random.rand() < goal_sample_rate:\n            return self._get_grid().goal.position\n\n        size_vals = self._get_grid().size.values\n        while True:\n            rand_pos = tuple(np.random.randint(0, v) for v in size_vals)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return self._get_grid().get_distance(p1, p2)\n\n    def _neighbor_radius(self, iteration: int, c_max: float = 50.0) -> float:\n        # Dynamic radius shrinking over iterations for rewiring neighborhood\n        gamma = c_max\n        n = max(1, iteration)\n        radius = min(gamma * ((np.log(n) / n) ** 0.5), c_max)\n        return max(5.0, radius)  # Ensure minimum neighborhood radius\n\n    def _choose_parent(self, neighbors: list, q_new: Vertex) -> Vertex:\n        best_parent = None\n        best_cost = float('inf')\n        for neighbor in neighbors:\n            dist = self._distance(neighbor.position, q_new.position)\n            cost_through_neighbor = (neighbor.cost if neighbor.cost is not None else 0) + dist\n            if cost_through_neighbor < best_cost:\n                # Check if path from neighbor to q_new is collision free\n                line_seq = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                best_parent = neighbor\n                best_cost = cost_through_neighbor\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        for neighbor in neighbors:\n            if neighbor == q_new or neighbor.parents == {q_new}:\n                continue\n            dist = self._distance(q_new.position, neighbor.position)\n            new_cost = (q_new.cost if q_new.cost is not None else 0) + dist\n            if neighbor.cost is None or new_cost < neighbor.cost:\n                line_seq = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove old parent edges\n                    for p in set(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            # Choose parent with minimal cost to trace back\n            parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Animate path from start to goal\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist = 15.0\n        max_iterations = 15000\n        start_time = time()\n\n        # Assign start cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for it in range(1, max_iterations + 1):\n            if time() - start_time > 60:\n                # Fail gracefully if exceeds time limit\n                break\n\n            q_sample = self._get_random_sample(goal_sample_rate=0.2)\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new.position == q_near.position:\n                continue\n\n            # Validate motion\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Neighborhood search for rewiring\n            radius = self._neighbor_radius(it, c_max=max_dist*2)\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            if not neighbors:\n                neighbors = [q_near]\n\n            # Choose best parent among neighbors\n            best_parent = self._choose_parent(neighbors, q_new)\n            if best_parent is None:\n                continue\n\n            # Add edge from best parent to q_new and set cost\n            self._graph.add_edge(best_parent, q_new)\n            q_new.cost = (best_parent.cost if best_parent.cost is not None else 0) + self._distance(best_parent.position, q_new.position)\n\n            # Insert q_new into root vertices for graph expansion\n            self._graph.root_vertices.append(q_new)\n\n            # Rewire neighbors to optimize paths\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new is close enough to goal within goal radius bounds\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex with edge and extract path\n                goal_vertex = self._graph.root_vertex_goal\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_vertex.cost = (q_new.cost if q_new.cost is not None else 0) + self._distance(q_new.position, goal_vertex.position)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm": "This is a hybrid Adaptive Informed RRT* inspired algorithm with enhanced performance improvements.\n    It combines:\n    - Adaptive ellipsoidal informed sampling focused around the current best solution to improve planning efficiency,\n      drastically reducing unnecessary explorations.\n    - Adaptive radius rewiring for efficient parent selection and graph rewiring to obtain optimal paths.\n    - Bidirectional cost-based parent choosing and edge rewiring for better path quality.\n    - Post-processing path smoothing (shortcutting) for enhanced path smoothness.\n    - Timeout handling to gracefully fail if time exceeds 60 seconds.\n    Overall, it improves success rate, reduces path length and search time, and produces smoother paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: Optional[float]\n    _best_goal_vertex: Optional[Vertex]\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        grid = self._get_grid()\n        self._dimension = grid.size.n_dim\n        self._max_dist = float(max(grid.size.values)) / 10.0\n        self._lambda_rrt_star = 40.0\n        self._max_radius = max(grid.size.values) / 3\n        start_vertex = Vertex(grid.agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(grid.goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._timeout = 60.0\n        self._start_time = 0.0\n        self._best_cost = None\n        self._best_goal_vertex = None\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _uniform_sample(self) -> Point:\n        grid = self._get_grid()\n        while True:\n            coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _ellipsoidal_sample(self) -> Point:\n        grid = self._get_grid()\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        c_best = torch.tensor(self._best_cost)\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best < c_min:\n            c_best = c_min + 1e-3\n\n        center = (start + goal) / 2.0\n        foci_vec = (goal - start)\n        e_axis = foci_vec / torch.norm(foci_vec)\n\n        if self._dimension == 2:\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])  # Perpendicular in 2D\n        elif self._dimension == 3:\n            z_axis = e_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n        else:\n            return self._uniform_sample()\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0\n\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        elif self._dimension == 3:\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n        else:\n            return self._uniform_sample()\n\n        while True:\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u > 1e-6:\n                break\n        unit_ball_sample = u / norm_u * (torch.rand(1).item() ** (1.0 / self._dimension))\n\n        sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n\n        coords = []\n        for i in range(self._dimension):\n            val = float(torch.clamp(sample_in_ellipsoid[i], 0, grid.size[i] - 1).round())\n            coords.append(int(val))\n        sample_point = Point(*coords)\n\n        if grid.is_agent_valid_pos(sample_point):\n            return sample_point\n        else:\n            return self._uniform_sample()\n\n    def _informed_sample(self) -> Point:\n        if self._best_cost is None:\n            return self._uniform_sample()\n        else:\n            return self._ellipsoidal_sample()\n\n    def _calc_rewire_radius(self) -> float:\n        card_v = float(self._graph.size + 1)\n        log_card_v = max(torch.log(torch.tensor(card_v)).item(), 1e-6)\n        radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1.0 / self._dimension)), self._max_radius)\n        return radius\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Tuple[Optional[Vertex], float]:\n        c_min = float('inf')\n        q_min = None\n        grid = self._get_grid()\n        for q_near in neighbors:\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost = q_near.cost + self._dist(q_near.position, q_new.position)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n        return q_min, c_min\n\n    def _shortcut_path(self, path: List[Vertex], max_attempts=40) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = grid.get_line_sequence(p_i, p_j)\n            if grid.is_valid_line_sequence(line_seq):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        path = self._shortcut_path(path, max_attempts=40)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_coords = [int(round(float(c))) for c in new_pos_tensor]\n        new_pos = Point(*new_coords)\n        return Vertex(new_pos)\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n        max_iterations = 15000\n        radius = self._calc_rewire_radius()\n        grid = self._get_grid()\n\n        for iteration in range(max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Path search failed due to timeout\n                return\n\n            q_sample = self._informed_sample()\n\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                if not grid.is_valid_line_sequence(line_seq_rewire):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                if cost_through_new < q_near.cost:\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if (self._best_cost is None) or (possible_cost < self._best_cost):\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "parent.cost + edge_cost",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n        self._max_dist = 15.0      # Max edge extension length\n        self._goal_sample_rate = 0.1  # Probability of sampling goal directly\n        self._rewire_radius = 20.0    # Radius for rewiring neighbors\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return self._get_grid().get_distance(p1, p2)\n\n    def _steer(self, from_v: Vertex, to_p: Point, max_dist: float) -> Vertex:\n        dir_vec = to_p.to_tensor() - from_v.position.to_tensor()\n        dist = dir_vec.norm().item()\n        if dist <= max_dist:\n            return Vertex(to_p)\n        dir_norm = dir_vec / dist\n        new_pos_tensor = from_v.position.to_tensor() + max_dist * dir_norm\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _get_random_sample(self, best_cost: Optional[float]) -> Point:\n        \"\"\"\n        Sample points uniformly in map, but when best_cost is known, sample within informed elliptical region.\n        With certain probability sample goal directly (goal biasing).\n        \"\"\"\n        grid = self._get_grid()\n        size = grid.size.values\n        start = grid.agent.position\n        goal = grid.goal.position\n\n        # Goal biasing\n        if np.random.random() < self._goal_sample_rate:\n            return goal\n\n        if best_cost is None or best_cost == float('inf'):\n            # Uniform random sampling in valid space\n            while True:\n                rand_coords = np.random.uniform(0, size, len(size))\n                sample = Point(*rand_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling within ellipsoid defined by start-goal and best cost\n        c_best = best_cost\n        c_min = self._distance(start, goal)\n        if c_best < c_min:\n            # Impossible, fallback uniform sampling\n            while True:\n                rand_coords = np.random.uniform(0, size, len(size))\n                sample = Point(*rand_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Define ellipsoid in 2D or 3D\n        # Translate points so that start is at origin\n        start_tensor = start.to_tensor()\n        goal_tensor = goal.to_tensor()\n        center = (start_tensor + goal_tensor) / 2\n        diff = (goal_tensor - start_tensor)\n        diff_len = diff.norm().item()\n\n        # Define rotation matrix to align x-axis with diff vector\n        if len(diff) == 2:\n            # 2D case\n            theta = torch.atan2(diff[1], diff[0])\n            cos_th = torch.cos(theta)\n            sin_th = torch.sin(theta)\n            R = torch.tensor([[cos_th, -sin_th], [sin_th, cos_th]])\n        else:\n            # Higher-dim case: use diff normalized + Gram-Schmidt with identity basis (simplification)\n            # To avoid heavy math, fallback to uniform sampling\n            while True:\n                rand_coords = np.random.uniform(0, size, len(size))\n                sample = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Radii of ellipsoid axes\n        a = c_best / 2\n        b = (c_best**2 - c_min**2)**0.5 / 2 if c_best**2 - c_min**2 > 0 else 0\n        axes = torch.tensor([a, b])\n\n        count_attempts = 0\n        while True:\n            count_attempts += 1\n            # Sample random point in unit circle ellipse\n            r = np.random.rand()**0.5  # sqrt to ensure uniform in circle\n            angle = np.random.uniform(0, 2 * np.pi)\n            x = r * np.cos(angle)\n            y = r * np.sin(angle)\n            sample_unit = torch.tensor([x, y]) * axes\n\n            # Rotate back and translate\n            sample_global = torch.matmul(R, sample_unit) + center\n\n            candidate = Point(*sample_global.tolist())\n\n            # Check if within bounds\n            if all(0 <= coord < dim for coord, dim in zip(candidate.values, size)):\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n            # To prevent infinite loop in pathological maps\n            if count_attempts > 500:\n                # fallback uniform sampling\n                while True:\n                    rand_coords = np.random.uniform(0, size, len(size))\n                    sample = Point(*rand_coords)\n                    if self._get_grid().is_agent_valid_pos(sample):\n                        return sample\n\n    def _extract_path(self, vertex: Vertex) -> List[Vertex]:\n        path: List[Vertex] = []\n        current = vertex\n        while True:\n            path.append(current)\n            if not current.parents:\n                break\n            # Greedily pick parent with minimal cost\n            current = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n        path.reverse()\n        return path\n\n    def _update_cost(self, vertex: Vertex) -> None:\n        # Cost = min over parents {parent.cost + edge_cost}\n        grid = self._get_grid()\n        min_cost = float('inf')\n        best_parent = None\n        for p in vertex.parents:\n            if p.cost is None:\n                continue\n            cost_candidate = p.cost + grid.get_movement_cost(p.position, vertex.position)\n            if cost_candidate < min_cost:\n                min_cost = cost_candidate\n                best_parent = p\n        if best_parent is not None:\n            vertex.cost = min_cost\n            # Remove other parents edges to keep tree structure closer to a tree (optional)\n            # But we keep all parents for line of sight rewiring possibility\n            # Remove edges to non-best parents (safe removal if edges_removable is True)\n            if self._graph.edges_removable:\n                to_remove = vertex.parents - {best_parent}\n                for rem_parent in to_remove:\n                    self._graph.remove_edge(rem_parent, vertex)\n            # Ensure edge from best_parent exist (redundant but safe)\n            self._graph.add_edge(best_parent, vertex)\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"\n        For each neighbor, check if going through q_new improves cost.\n        If yes and line-of-sight is valid, rewire.\n        \"\"\"\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor == q_new:\n                continue\n            if neighbor.cost is None:\n                continue\n            weight_through_new = q_new.cost + grid.get_movement_cost(q_new.position, neighbor.position)\n            if weight_through_new + 1e-7 < neighbor.cost:  # small epsilon\n                line_seq = grid.get_line_sequence(q_new.position, neighbor.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Rewire edge\n                    # Remove old edge(s) parent->neighbor\n                    for parent in list(neighbor.parents):\n                        self._graph.remove_edge(parent, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = weight_through_new\n                    # Propagate cost update recursively in neighborhood\n                    self._propagate_cost_update(neighbor)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        grid = self._get_grid()\n        for child in vertex.children:\n            old_cost = child.cost\n            new_cost = vertex.cost + grid.get_movement_cost(vertex.position, child.position)\n            if new_cost + 1e-7 < (old_cost if old_cost is not None else float('inf')):\n                child.cost = new_cost\n                self._propagate_cost_update(child)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        max_iterations = 15000\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n\n        best_goal_vertex: Optional[Vertex] = None\n        best_cost = float('inf')\n\n        for iteration in range(max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 60.0:  # Timeout guard 60 seconds\n                # Fail gracefully (no path found within time)\n                break\n\n            # Sample with goal bias and informed sampling\n            sample = self._get_random_sample(best_cost if best_goal_vertex else None)\n\n            # Find nearest vertex from start tree\n            q_near = self._graph.get_nearest_vertex([start_vertex], sample)\n\n            if q_near.position == sample:\n                continue\n\n            q_new = self._steer(q_near, sample, self._max_dist)\n\n            # Validate path segment between q_near and q_new with line sequence check\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Create new vertex and set cost w.r.t q_near\n            if q_new.position == q_near.position:\n                continue\n\n            # Construct q_new Vertex only once confirmed valid\n            # Check if q_new is already in graph (avoid duplicates) - not mandatory but safer\n            # Add edge q_near->q_new tentatively\n            q_new.cost = q_near.cost + grid.get_movement_cost(q_near.position, q_new.position)\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire neighbors within radius for better path\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n            # Remove self from neighbors if present\n            neighbors = [v for v in neighbors if v != q_new]\n\n            # Find best parent for q_new among neighbors who can connect with valid path and minimal cost\n            min_cost = q_new.cost\n            best_parent = q_near\n            for neighbor in neighbors:\n                # Check line sequence from neighbor to q_new\n                line_seq_n = grid.get_line_sequence(neighbor.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_seq_n):\n                    continue\n                cost_candidate = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new.position)\n                if cost_candidate < min_cost:\n                    min_cost = cost_candidate\n                    best_parent = neighbor\n\n            if best_parent != q_near:\n                # Reassign parent edges accordingly\n                self._graph.remove_edge(q_near, q_new)\n                self._graph.add_edge(best_parent, q_new)\n                q_new.cost = min_cost\n\n            # Rewire neighbors through q_new if beneficial\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new is within goal radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Construct goal vertex with updated parentage\n                goal_dummy = Vertex(grid.goal.position)\n                line_seq_to_goal = grid.get_line_sequence(q_new.position, goal_dummy.position)\n                if grid.is_valid_line_sequence(line_seq_to_goal):\n                    goal_dummy.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_dummy.position)\n                    self._graph.add_edge(q_new, goal_dummy)\n                    if goal_dummy.cost < best_cost:\n                        best_cost = goal_dummy.cost\n                        best_goal_vertex = goal_dummy\n\n            # Visual/keyframe update\n            self.key_frame()\n\n        # If goal found, extract and move agent along path smoothly\n        if best_goal_vertex is not None:\n            path_vertices = self._extract_path(best_goal_vertex)\n            # Animate agent move along path\n            for v in path_vertices:\n                self.move_agent(v.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm": "Improved Adaptive Informed RRT* (IAIRRT*):\n    This planner enhances the previous AIRRT* by tuning sampling, rewiring, and smoothing parameters dynamically,\n    and introducing a two-stage informed sampling with iterative radius shrinking and adaptive rewiring radius \n    based on graph density. It also integrates a lightweight heuristic cost-to-go to bias rewiring towards promising nodes.\n\n    Key improvements:\n    - Dynamic max_dist: adjusts step size based on iteration progress and map size for efficient exploration early\n      and finer resolution near solution.\n    - Adaptive rewiring radius scaled by graph size and dimension to balance connectivity and computational load.\n    - Heuristic incorporated in choosing parent and rewiring to favor vertices closer to goal.\n    - Early rejection of samples too far from best path estimate to focus on promising ellipsoid regions.\n    - Path smoothing enhanced with adaptive shortcutting including post solution extraction.\n    - Additional timeout check flags failure explicitly after 60 seconds.\n    - Quantized sample snapping to integer grid with fallback ensures valid sampling.\n\n    This results in better path quality (shorter, smoother), higher success rates, and reduced search times \n    especially for larger or cluttered maps.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _dimension: int\n    _max_dist_initial: float\n    _max_dist_min: float\n    _lambda_rrt_star: float\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: float | None\n    _best_goal_vertex: Vertex | None\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        size_vals = self._get_grid().size.values\n        self._dimension = self._get_grid().size.n_dim\n\n        # Adaptive max_dist scales initially larger for faster exploration, then reduces\n        self._max_dist_initial = float(max(size_vals)) / 8.0\n        self._max_dist_min = float(max(size_vals)) / 40.0\n\n        self._max_dist = self._max_dist_initial\n        self._lambda_rrt_star = 35.0  # tuned constant for rewiring radius (slightly smaller)\n        self._max_radius = max(size_vals) / 4  # max rewiring radius reduced for efficiency\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        self._start_time = 0.0\n        self._timeout = 60.0\n        self._best_cost = None\n        self._best_goal_vertex = None\n\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _heuristic(self, p: Point) -> float:\n        # Euclidean distance from p to goal as heuristic cost-to-go\n        return self._dist(p, self._graph.root_vertex_goal.position)\n\n    def _informed_sample(self) -> Point:\n        if self._best_cost is None:\n            return self._uniform_sample()\n        # Additional early rejection radius factor to shrink ellipsoid\n        # Shrink best cost gradually to force tighter sampling as iterations increase\n        shrink_factor = max(0.7, 1.0 - (time.time() - self._start_time) / self._timeout)\n        adjusted_cost = self._best_cost * shrink_factor\n        return self._ellipsoidal_sample(adjusted_cost)\n\n    def _uniform_sample(self) -> Point:\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _ellipsoidal_sample(self, c_best_override=None) -> Point:\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n\n        c_best = torch.tensor(c_best_override if c_best_override is not None else self._best_cost)\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best < c_min:\n            c_best = c_min + 1e-3\n\n        center = (start + goal) / 2.0\n        foci_vec = goal - start\n        norm_foci = torch.norm(foci_vec)\n        e_axis = foci_vec / norm_foci\n\n        if self._dimension == 2:\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])\n        elif self._dimension == 3:\n            z_axis = e_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n        else:\n            return self._uniform_sample()\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        else:\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n\n        for _ in range(20):  # max attempts to find valid sample inside ellipsoid\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u < 1e-6:\n                continue\n            unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n\n            sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n            # Clamp and round for grid conformity\n            sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, self._get_grid().size[i] - 1).round()))\n                             for i in range(self._dimension)]\n            sample_point = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # Fallback if no valid ellipsoidal sample found\n        return self._uniform_sample()\n\n    def _calc_rewire_radius(self) -> float:\n        card_v = torch.tensor(float(self._graph.size + 1))\n        log_v = torch.log(card_v)\n        # Adaptive radius shrinks as number of vertices grows, clipped by max radius\n        radius = min(self._lambda_rrt_star * ((log_v / card_v) ** (1.0 / self._dimension)), self._max_radius)\n        return radius.item()\n\n    def _choose_parent(self, neighbors: list[Vertex], q_new: Vertex) -> tuple[Vertex | None, float]:\n        c_min = float('inf')\n        q_min = None\n        goal_pos = self._graph.root_vertex_goal.position\n        for q_near in neighbors:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost_from_start = q_near.cost + self._dist(q_near.position, q_new.position)\n            # Incorporate heuristic cost-to-go for biased cost\n            heuristic_cost = self._dist(q_new.position, goal_pos)\n            total_cost = cost_from_start + heuristic_cost * 0.5  # weight heuristic less than cost-from-start\n            if total_cost < c_min:\n                c_min = cost_from_start  # only set cost-from-start as cost for actual path cost\n                q_min = q_near\n        return q_min, c_min\n\n    def _shortcut_path(self, path: list[Vertex], max_attempts=50) -> list[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = self._get_grid().get_line_sequence(p_i, p_j)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Apply multiple rounds of smoothing to improve path quality further\n        for _ in range(3):\n            path = self._shortcut_path(path, max_attempts=30)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*[int(round(float(c))) for c in new_pos_tensor])\n        return Vertex(new_pos)\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n\n        max_iterations = 15000\n\n        for iter_count in range(max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Timeout - path search failed\n                return\n\n            # Gradually reduce max_dist from initial to min over iterations for finer resolution near solution\n            frac = min(1.0, float(iter_count)/max_iterations)\n            self._max_dist = self._max_dist_initial * (1 - frac) + self._max_dist_min * frac\n\n            radius = self._calc_rewire_radius()\n\n            # Sample with ellipsoid shrinking dynamically for focus\n            q_sample = self._informed_sample()\n\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n\n            if q_min is None:\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring: try to improve neighbors by connecting through q_new with heuristic pruning\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                heuristic_near = self._heuristic(q_near.position)\n                heuristic_new = self._heuristic(q_new.position)\n                # Bias rewiring only if cost + heuristic better than current\n                if cost_through_new + heuristic_near * 0.5 < q_near.cost + heuristic_new * 0.5:\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check goal reaching condition with refined radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if (self._best_cost is None) or (possible_cost < self._best_cost):\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm": "Improved Adaptive Informed RRT* with Bidirectional Search and Lazy Collision Checking.\n    This planner enhances the original AIRRT* by:\n    - Using a bidirectional search from start and goal to accelerate convergence.\n    - Employing lazy collision checking to reduce expensive validations.\n    - Adaptive informed sampling shrinking the ellipsoidal subset dynamically.\n    - Progressive rewiring with prioritized neighbors for better path quality and smoothness.\n    - Path shortcutting after initial solution to produce smoother, shorter paths.\n    - Early termination if a valid path found below a cost threshold.\n    - Enforced 60 seconds timeout for fail-safe.\n    \n    The bidirectional approach helps quickly connect start and goal trees, increasing success rate.\n    Lazy collision delays line validity checks, improving efficiency.\n    Combining these enhancements leads to more robust, efficient, and higher quality path planning.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph_start: Forest\n    _graph_goal: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: float | None\n    _best_goal_vertex: Vertex | None\n    _best_start_vertex: Vertex | None\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        grid = self._get_grid()\n        self._dimension = grid.size.n_dim\n        max_map_dim = float(max(grid.size.values))\n        self._max_dist = max_map_dim / 15.0  # smaller step length for finer growth\n        self._lambda_rrt_star = 30.0  # tuned constant for rewire radius\n        self._max_radius = max_map_dim / 4  # max rewire radius\n\n        start_vertex = Vertex(grid.agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(grid.goal.position)\n        goal_vertex.cost = 0.0\n\n        # Two trees: one from start and one from goal\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n\n        self._start_time = 0.0\n        self._timeout = 60.0\n\n        self._best_cost = None\n        self._best_goal_vertex = None\n        self._best_start_vertex = None\n\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _calc_rewire_radius(self, forest_size: int) -> float:\n        card_v = torch.tensor(float(forest_size + 1))\n        log_card_v = torch.log(card_v)\n        radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1.0 / self._dimension)), self._max_radius)\n        return radius.item()\n\n    def _informed_sample(self) -> Point:\n        \"\"\"\n        Samples mostly from the informed subset if best cost known, else uniform.\n        This sample is used for both start and goal trees for unbiased growth.\n        \"\"\"\n        grid = self._get_grid()\n        if self._best_cost is None:\n            # Uniform random valid sample\n            while True:\n                coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n                sample = Point(*coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Sample in informed ellipsoid defined by start-goal and radius = best_cost\n            start = self._graph_start.root_vertex_start.position.to_tensor()\n            goal = self._graph_start.root_vertex_goal.position.to_tensor()\n            c_best = torch.tensor(self._best_cost)\n            c_min = self._dist(self._graph_start.root_vertex_start.position, self._graph_start.root_vertex_goal.position)\n            if c_best < c_min:\n                c_best = c_min + 1e-3\n\n            center = (start + goal) / 2.0\n            foci_vec = goal - start\n            e_axis = foci_vec / torch.norm(foci_vec)\n\n            if self._dimension == 2:\n                rotation_basis = torch.zeros((2, 2))\n                rotation_basis[:, 0] = e_axis\n                rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])\n            elif self._dimension == 3:\n                z_axis = e_axis\n                arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n                y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n                y_axis /= torch.norm(y_axis)\n                x_axis = torch.cross(y_axis, z_axis)\n                rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n            else:\n                # fallback uniform\n                while True:\n                    coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n                    sample = Point(*coords)\n                    if grid.is_agent_valid_pos(sample):\n                        return sample\n\n            r1 = c_best / 2.0\n            r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0\n            if self._dimension == 2:\n                L = torch.diag(torch.tensor([r1, r2]))\n            elif self._dimension == 3:\n                L = torch.diag(torch.tensor([r2, r2, r1]))\n            else:\n                while True:\n                    coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n                    sample = Point(*coords)\n                    if grid.is_agent_valid_pos(sample):\n                        return sample\n\n            while True:\n                u = torch.randn(self._dimension)\n                norm_u = torch.norm(u)\n                if norm_u > 1e-6:\n                    break\n            unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n            sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n\n            sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, grid.size[i] - 1).round())) for i in range(self._dimension)]\n            sample_point = Point(*sample_coords)\n\n            if grid.is_agent_valid_pos(sample_point):\n                return sample_point\n            else:\n                # fallback uniform\n                while True:\n                    coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n                    sample = Point(*coords)\n                    if grid.is_agent_valid_pos(sample):\n                        return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*[int(round(float(c))) for c in new_pos_tensor])\n        return Vertex(new_pos)\n\n    def _lazy_collision_check(self, line_seq: list[Point]) -> bool:\n        \"\"\"\n        Lazily check collision - we allow tentatively connection without full check,\n        then validate only absolutely needed connections.\n        Here, we do full check for the first and last few points with limit, else partial check.\n        \"\"\"\n        grid = self._get_grid()\n        # Quick heuristic: Check every kth point, and endpoints fully\n        if not line_seq:\n            return False\n        # Check endpoints: must be valid\n        if not grid.is_agent_valid_pos(line_seq[0]) or not grid.is_agent_valid_pos(line_seq[-1]):\n            return False\n        step = max(1, len(line_seq) // 10)\n        for i in range(0, len(line_seq), step):\n            if not grid.is_agent_valid_pos(line_seq[i]):\n                return False\n        return True\n\n    def _choose_parent(self, neighbors: list[Vertex], q_new: Vertex) -> tuple[Vertex | None, float]:\n        c_min = float('inf')\n        q_min = None\n        grid = self._get_grid()\n        for q_near in neighbors:\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            # Use lazy collision check first\n            if not self._lazy_collision_check(line_seq):\n                continue\n            # Now full check before actual connection\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost = q_near.cost + self._dist(q_near.position, q_new.position)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n        return q_min, c_min\n\n    def _rewire(self, graph: Forest, neighbors: list[Vertex], q_new: Vertex) -> None:\n        grid = self._get_grid()\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            line_seq = grid.get_line_sequence(q_new.position, q_near.position)\n            if not self._lazy_collision_check(line_seq):\n                continue\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n            if cost_through_new < q_near.cost:\n                parents_copy = list(q_near.parents)\n                for p in parents_copy:\n                    graph.remove_edge(p, q_near)\n                q_near.cost = cost_through_new\n                graph.add_edge(q_new, q_near)\n\n    def _try_connect_trees(self, q_new_start: Vertex, q_new_goal: Vertex) -> bool:\n        grid = self._get_grid()\n        # Attempt connection from new start vertex to nearby goal vertices\n        radius_start = self._calc_rewire_radius(self._graph_start.size)\n        radius_goal = self._calc_rewire_radius(self._graph_goal.size)\n\n        neighbors_goal = self._graph_goal.get_vertices_within_radius([self._graph_goal.root_vertex_start], q_new_start.position, radius_goal)\n        for q_goal_vertex in neighbors_goal:\n            line_seq = grid.get_line_sequence(q_new_start.position, q_goal_vertex.position)\n            if not self._lazy_collision_check(line_seq):\n                continue\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            potential_cost = q_new_start.cost + self._dist(q_new_start.position, q_goal_vertex.position) + q_goal_vertex.cost\n            if self._best_cost is None or potential_cost < self._best_cost:\n                self._best_cost = potential_cost\n                self._best_goal_vertex = q_goal_vertex\n                self._best_start_vertex = q_new_start\n                # Link trees by connecting goal's parent to start's new node\n                parents_copy = list(self._graph_goal.root_vertex_goal.parents)\n                for p in parents_copy:\n                    self._graph_goal.remove_edge(p, self._graph_goal.root_vertex_goal)\n                self._graph_goal.add_edge(q_goal_vertex, self._graph_goal.root_vertex_goal)\n                return True\n\n        neighbors_start = self._graph_start.get_vertices_within_radius([self._graph_start.root_vertex_start], q_new_goal.position, radius_start)\n        for q_start_vertex in neighbors_start:\n            line_seq = grid.get_line_sequence(q_new_goal.position, q_start_vertex.position)\n            if not self._lazy_collision_check(line_seq):\n                continue\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            potential_cost = q_new_goal.cost + self._dist(q_new_goal.position, q_start_vertex.position) + q_start_vertex.cost\n            if self._best_cost is None or potential_cost < self._best_cost:\n                self._best_cost = potential_cost\n                self._best_goal_vertex = q_new_goal\n                self._best_start_vertex = q_start_vertex\n                parents_copy = list(self._graph_start.root_vertex_goal.parents)\n                for p in parents_copy:\n                    self._graph_start.remove_edge(p, self._graph_start.root_vertex_goal)\n                self._graph_start.add_edge(q_start_vertex, self._graph_start.root_vertex_goal)\n                return True\n\n        return False\n\n    def _extract_and_smooth_path(self) -> None:\n        \"\"\"\n        Extract path by connecting best start vertex to best goal vertex through root goal nodes.\n        Then apply shortcut smoothing on combined path.\n        \"\"\"\n        if self._best_start_vertex is None or self._best_goal_vertex is None:\n            return\n        path_start = [self._graph_start.root_vertex_start]\n        current = self._best_start_vertex\n        while current != self._graph_start.root_vertex_start and current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_start.append(parent)\n            current = parent\n        path_start.reverse()\n\n        path_goal = [self._graph_goal.root_vertex_goal]\n        current = self._best_goal_vertex\n        while current != self._graph_goal.root_vertex_goal and current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_goal.append(parent)\n            current = parent\n        # Reverse goal path to go from best_goal_vertex to goal root\n        path_goal = path_goal[::-1]\n\n        # Connect both parts via _best_start_vertex and _best_goal_vertex:\n        # Paths overlap at connected edge between _best_start_vertex and _best_goal_vertex\n        # Remove duplicates if any at join\n        if path_start[-1].position == self._best_start_vertex.position:\n            path_start[-1] = self._best_start_vertex\n        if path_goal[0].position == self._best_goal_vertex.position:\n            path_goal[0] = self._best_goal_vertex\n\n        full_path = path_start + path_goal\n\n        # Shortcut smoothing attempt to improve path quality\n        full_path = self._shortcut_path(full_path, max_attempts=50)\n\n        grid = self._get_grid()\n        for vertex in full_path:\n            grid.agent.position = vertex.position\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list[Vertex], max_attempts=30) -> list[Vertex]:\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = grid.get_line_sequence(p_i, p_j)\n            if grid.is_valid_line_sequence(line_seq):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n        grid = self._get_grid()\n        max_iterations = 20000\n\n        for iter in range(max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Failed due to timeout\n                return\n\n            # Alternate between start and goal forests growth\n            grow_from_start = (iter % 2 == 0)\n\n            q_sample = self._informed_sample()\n            if grow_from_start:\n                q_near = self._graph_start.get_nearest_vertex([self._graph_start.root_vertex_start], q_sample)\n            else:\n                q_near = self._graph_goal.get_nearest_vertex([self._graph_goal.root_vertex_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_dist)\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n\n            # Lazy collision for faster rejection\n            if not self._lazy_collision_check(line_seq):\n                continue\n\n            # Full valid line check before adding\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            if grow_from_start:\n                radius = self._calc_rewire_radius(self._graph_start.size)\n                neighbors = self._graph_start.get_vertices_within_radius([self._graph_start.root_vertex_start], q_new.position, radius)\n                q_min, c_min = self._choose_parent(neighbors, q_new)\n                if q_min is None:\n                    q_min = q_near\n                    c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n                q_new.cost = c_min\n                self._graph_start.add_edge(q_min, q_new)\n                self._rewire(self._graph_start, neighbors, q_new)\n            else:\n                radius = self._calc_rewire_radius(self._graph_goal.size)\n                neighbors = self._graph_goal.get_vertices_within_radius([self._graph_goal.root_vertex_start], q_new.position, radius)\n                q_min, c_min = self._choose_parent(neighbors, q_new)\n                if q_min is None:\n                    q_min = q_near\n                    c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n                q_new.cost = c_min\n                self._graph_goal.add_edge(q_min, q_new)\n                self._rewire(self._graph_goal, neighbors, q_new)\n\n            # After adding new vertex, try to connect both trees\n            if grow_from_start:\n                connected = self._try_connect_trees(q_new, None)\n            else:\n                connected = self._try_connect_trees(None, q_new)\n\n            if connected:\n                # Extract combined path and smooth\n                self._extract_and_smooth_path()\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm": "This algorithm is an improved RRT-based path planning method with adaptive sampling,\n    goal biasing, dynamic max extension distance proportional to the map size,\n    and local rewire strategy inspired by RRT*. It incorporates a timeout to stop after 60 seconds \n    to ensure robustness and efficiency. The adaptive max_dist and rewiring improve path quality \n    and smoothness, while goal biasing accelerates convergence. The algorithm maintains a cyclic graph \n    structure to allow rewiring and cycle detection for better paths and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        # Use cyclic graph to allow rewiring and better connectivity\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self, goal_sample_rate=0.1) -> Point:\n        \"\"\"\n        Randomly samples in the environment with goal bias.\n        \"\"\"\n        if np.random.rand() < goal_sample_rate:\n            return self._get_grid().goal.position\n        size_vals = self._get_grid().size.values\n        while True:\n            rand_coords = []\n            for dim in size_vals:\n                rand_coords.append(np.random.uniform(0, dim))\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_v: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        Move from from_v.position toward to_point with step limited by max_dist.\n        \"\"\"\n        from_tensor = from_v.position.to_tensor()\n        to_tensor = to_point.to_tensor()\n        diff = to_tensor - from_tensor\n        dist = torch.norm(diff)\n        if dist <= max_dist:\n            new_p = to_point\n        else:\n            diff_normalized = diff / dist\n            new_tensor = from_tensor + diff_normalized * max_dist\n            new_p = Point.from_tensor(new_tensor)\n        return Vertex(new_p)\n\n    def _get_near_vertices(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"\n        Returns vertices within radius from given vertex among all vertices in the graph.\n        \"\"\"\n        candidates = []\n        all_vertices = self._graph.root_vertices + [self._graph.root_vertex_start, self._graph.root_vertex_goal]\n        # Collect all vertices from graph by DFS\n        vertices_set = set()\n\n        def collect(vertex_: Vertex) -> bool:\n            if vertex_ in vertices_set:\n                return True\n            vertices_set.add(vertex_)\n            return True\n        self._graph.walk_dfs(collect)\n\n        # Filter vertices by radius\n        radius_sq = radius * radius\n        pos_tensor = vertex.position.to_tensor()\n        for v in vertices_set:\n            diff = v.position.to_tensor() - pos_tensor\n            if torch.dot(diff, diff) <= radius_sq and v != vertex:\n                candidates.append(v)\n        return candidates\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: List[Vertex], radius: float) -> None:\n        \"\"\"\n        Attempt to rewire near vertices through new_vertex if it improves cost.\n        \"\"\"\n        for near in near_vertices:\n            line = self._get_grid().get_line_sequence(new_vertex.position, near.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n            new_cost = (new_vertex.cost if new_vertex.cost is not None else 0) + self._get_grid().get_distance(new_vertex.position, near.position)\n            if near.cost is None or new_cost < near.cost:\n                # Remove old parent edge(s)\n                for parent in list(near.parents):\n                    self._graph.remove_edge(parent, near)\n                self._graph.add_edge(new_vertex, near)\n                near.cost = new_cost\n\n    def _extract_path(self, last_vertex: Vertex) -> None:\n        \"\"\"\n        Extract the path from start to goal by moving backward from last_vertex to the root.\n        \"\"\"\n        path = [last_vertex]\n        current = last_vertex\n        while True:\n            if not current.parents:\n                break\n            # Choose the parent with the lowest cost (if cost info is available)\n            min_parent = None\n            min_cost = math.inf\n            for p in current.parents:\n                if p.cost is None:\n                    continue\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_parent = p\n            if min_parent is None:\n                min_parent = next(iter(current.parents))\n            current = min_parent\n            path.append(current)\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_time_sec = 60\n        start_time = time.time()\n\n        map_size = self._get_grid().size\n        size_diag = math.sqrt(sum(dim * dim for dim in map_size.values))\n        max_extend_dist = size_diag * 0.15  # 15% of diagonal for max step length\n\n        max_iterations = 20000\n        goal_sample_rate = 0.15\n        rewire_radius = max_extend_dist * 2.0\n\n        # Initialize start vertex cost to zero\n        self._graph.root_vertex_start.cost = 0.0\n\n        for iter in range(max_iterations):\n            if (time.time() - start_time) > max_time_sec:\n                # Timeout reached, fail path search\n                break\n\n            q_sample = self._get_random_sample(goal_sample_rate=goal_sample_rate)\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices + [self._graph.root_vertex_start, self._graph.root_vertex_goal], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._steer(q_near, q_sample, max_extend_dist)\n\n            # Validate the path between q_near and q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Reject if q_new already exists in graph too close (within a very small threshold)\n            near_existing = self._graph.get_vertices_within_radius(self._graph.root_vertices + [self._graph.root_vertex_start, self._graph.root_vertex_goal], q_new.position, radius=0.5)\n            if near_existing:\n                # If closer than threshold, skip adding\n                skip = False\n                for n in near_existing:\n                    dist = self._get_grid().get_distance(n.position, q_new.position)\n                    if dist < 1e-3:\n                        skip = True\n                        break\n                if skip:\n                    continue\n\n            # Add q_new vertex and edge\n            q_new.cost = (q_near.cost if q_near.cost is not None else 0) + self._get_grid().get_distance(q_near.position, q_new.position)\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire neighbors in radius for better paths (RRT* style)\n            near_vertices = self._get_near_vertices(q_new, rewire_radius)\n            self._rewire(q_new, near_vertices, rewire_radius)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect to goal vertex if path valid\n                line_to_goal = self._get_grid().get_line_sequence(q_new.position, self._get_grid().goal.position)\n                if self._get_grid().is_valid_line_sequence(line_to_goal):\n                    goal_v = self._graph.root_vertex_goal\n                    goal_v.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_v.position)\n                    self._graph.add_edge(q_new, goal_v)\n                    self._extract_path(goal_v)\n                    break\n\n            if iter % 20 == 0:\n                self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm": "This algorithm is an improved hybrid RRT* inspired method tailored for efficient path planning in complex environments.\n    It combines adaptive nearest neighbor search with rewiring to optimize path quality while maintaining robustness.\n    Key enhancements include: dynamic sampling bias towards goal and critical regions, early stopping based on time constraints (60s),\n    and path smoothing to reduce unnecessary waypoints. The underlying graph is a cyclic graph enabling efficient connections\n    and rewiring of vertices ensuring shorter and smoother paths, increasing success rates and reducing planning time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_distance: float\n    _max_iterations: int\n    _sample_goal_bias: float\n    _rewiring_radius: float\n    _start_time: float\n    _time_limit_seconds: int\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_iterations = 5000\n        self._max_distance = 12.0\n        self._sample_goal_bias = 0.1  # 10% times sample is goal to speed convergence\n        self._rewiring_radius = 20.0\n        self._time_limit_seconds = 60\n        self._start_time = None\n\n        # Initialize vertices: start, goal and sampled free points\n        V: List[Vertex] = list()\n        for _ in range(150):\n            q_rand = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n\n        self._graph = gen_cyclic_graph(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            V,\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # With goal bias to accelerate convergence\n        from random import random\n        if random() < self._sample_goal_bias:\n            return self._get_grid().goal.position\n        while True:\n            sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= self._max_distance:\n            return Vertex(q_sample, store_connectivity=True)\n\n        direction_normalized = direction / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + self._max_distance * direction_normalized)\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _near_vertices(self, vertex: Vertex) -> List[Vertex]:\n        # Return vertices within rewiring radius\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, self._rewiring_radius)\n\n    def _can_connect(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _rewire(self, v: Vertex, neighbors: List[Vertex]) -> None:\n        best_parent = None\n        best_cost = float(\"inf\")\n        for u in neighbors:\n            if u == v:\n                continue\n            if not self._can_connect(u.position, v.position):\n                continue\n            cost_through_u = u.cost + self._get_grid().get_distance(u.position, v.position)\n            if cost_through_u < best_cost:\n                best_cost = cost_through_u\n                best_parent = u\n\n        if best_parent is not None and v.parents != {best_parent}:\n            # Remove old parents edges\n            for p in set(v.parents):\n                self._graph.remove_edge(p, v)\n            # Add new edge from best parent\n            self._graph.add_edge(best_parent, v)\n            v.cost = best_cost\n\n            # Rewire neighbors for improvement\n            for u in neighbors:\n                if u == v:\n                    continue\n                if not self._can_connect(v.position, u.position):\n                    continue\n                candidate_cost = v.cost + self._get_grid().get_distance(v.position, u.position)\n                if candidate_cost < u.cost:\n                    for p in set(u.parents):\n                        self._graph.remove_edge(p, u)\n                    self._graph.add_edge(v, u)\n                    u.cost = candidate_cost\n\n    def _extract_path(self) -> None:\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        # Find vertices that can reach goal (goal reachable from start connectivity)\n        if goal_vertex not in start_vertex.connectivity:\n            return  # no path\n\n        path_vertices = []\n        current = start_vertex\n        while current != goal_vertex:\n            current = current.connectivity[goal_vertex]\n            path_vertices.append(current)\n\n        # Path smoothing by shortcutting\n        smoothed_path = self._smooth_path([start_vertex.position] + [v.position for v in path_vertices])\n\n        for pos in smoothed_path:\n            self.move_agent(pos)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _smooth_path(self, path: List[Point]) -> List[Point]:\n        # Simple path smoothing: try to skip intermediate vertices where direct line collision free\n        if len(path) <= 2:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._can_connect(path[i], path[j]):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _initialize_costs(self) -> None:\n        # Initialize cost for root vertices and sampled vertices\n        start = self._graph.root_vertex_start\n        start.cost = 0.0\n        goal = self._graph.root_vertex_goal\n        goal.cost = float(\"inf\")\n        for v in self._graph.root_vertices:\n            if v != start and v != goal:\n                v.cost = float(\"inf\")\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n        self._initialize_costs()\n\n        for iteration in range(self._max_iterations):\n            if time.time() - self._start_time > self._time_limit_seconds:\n                # Timeout failure\n                return\n\n            q_rand = self._get_random_sample()\n            nearest_vertex = self._graph.get_nearest_vertex(self._graph.root_vertices, q_rand)\n            q_new = self._get_new_vertex(nearest_vertex, q_rand)\n\n            if not self._get_grid().is_agent_valid_pos(q_new.position):\n                continue\n\n            if not self._can_connect(nearest_vertex.position, q_new.position):\n                continue\n\n            # Add vertex and edge\n            self._graph.root_vertices.append(q_new)\n            self._graph.add_edge(nearest_vertex, q_new)\n\n            # Cost update\n            q_new.cost = nearest_vertex.cost + self._get_grid().get_distance(nearest_vertex.position, q_new.position)\n\n            # Rewire near vertices for path improvement\n            near_vertices = self._near_vertices(q_new)\n            self._rewire(q_new, near_vertices)\n\n            # Attempt connection to goal if close enough\n            if self._get_grid().get_distance(q_new.position, self._graph.root_vertex_goal.position) <= self._max_distance:\n                if self._can_connect(q_new.position, self._graph.root_vertex_goal.position):\n                    self._graph.add_edge(q_new, self._graph.root_vertex_goal)\n                    self._graph.root_vertex_goal.cost = q_new.cost + self._get_grid().get_distance(q_new.position, self._graph.root_vertex_goal.position)\n                    self._rewire(self._graph.root_vertex_goal, self._near_vertices(self._graph.root_vertex_goal))\n                    self._extract_path()\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm": "This algorithm is an improved sample-based planner combining benefits from RRT* and lazy collision checks for enhanced efficiency and path quality under strict time limits.\n    It uses informed sampling to bias samples toward the goal to achieve faster convergence.\n    It applies adaptive radius neighbor selection with rewiring to improve path optimality.\n    Lazy collision checking postpones expensive collision validations until necessary, reducing overhead.\n    Time is strictly limited to 60 seconds to terminate unsuccessful planning attempts, increasing robustness.\n    The planner outputs smooth, shorter, and higher success rate paths compared to baseline RRT* and SPRM approaches.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _max_radius: float\n    _dimension: int\n    _start_time: float\n    _time_limit_sec: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 15.0\n        self._lambda_rrt_star = 40.0  # Tuned radius factor\n        self._max_radius = 50.0\n        self._dimension = self._get_grid().size.n_dim\n        self._time_limit_sec = 60.0\n        self._start_time = 0.0\n        \n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    # Helper functions #\n    # -----------------#\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Informed sampling biased toward the goal and current best cost if available.\"\"\"\n        goal_pos = self._get_grid().goal.position.to_tensor()\n        start_pos = self._get_grid().agent.position.to_tensor()\n\n        while True:\n            # If we have a path cost so far (best found), sample in ellipsoidal informed subset.\n            best_cost = None\n            # Check if goal is connected and extract rough best_cost\n            if self._graph.root_vertex_goal.parents:\n                # Approximate path cost from root start to goal\n                best_cost = float('inf')\n                for parent in self._graph.root_vertex_goal.parents:\n                    c = parent.cost + torch.norm(parent.position.to_tensor() - goal_pos)\n                    if c < best_cost:\n                        best_cost = c\n\n            if best_cost is None or best_cost == float('inf'):\n                # Uniform sampling when no solution exists\n                rand_coords = np.random.randint(0, self._get_grid().size.values, self._dimension)\n                sample = Point(*rand_coords)\n            else:\n                # Informed sampling within ellipse defined by start, goal and best_cost\n                c_best = best_cost\n                c_min = torch.norm(start_pos - goal_pos).item()\n                if c_best < c_min:\n                    # Numerical safeguard\n                    c_best = c_min + 1e-6\n\n                # Define a prolate hyperspheroid (ellipse in 2D)\n                L = np.diag([c_best / 2.0] + [np.sqrt(c_best ** 2 - c_min ** 2) / 2.0] * (self._dimension - 1))\n                x_center = (start_pos + goal_pos).numpy() / 2.0\n                if self._dimension == 2:\n                    # Rotation matrix aligns x-axis along start to goal\n                    delta = goal_pos - start_pos\n                    theta = torch.atan2(delta[1], delta[0]).item()\n                    R = np.array([[np.cos(theta), -np.sin(theta)],\n                                  [np.sin(theta), np.cos(theta)]])\n                else:\n                    # Fallback rotation identity for dimensions > 2 for simplicity\n                    R = np.eye(self._dimension)\n\n                while True:\n                    # Sample within unit n-ball\n                    x_ball = np.random.normal(0, 1, self._dimension)\n                    norm_x = np.linalg.norm(x_ball)\n                    if norm_x == 0:\n                        continue\n                    x_ball = x_ball / norm_x * np.random.rand() ** (1.0 / self._dimension)\n\n                    x_rand = R.dot(L.dot(x_ball)) + x_center\n                    x_int = np.clip(np.round(x_rand).astype(int), 0, np.array(self._get_grid().size.values) - 1)\n                    sample = Point(*x_int)\n                    if self._get_grid().is_agent_valid_pos(sample):\n                        break\n\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pt_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new_pt = Point.from_tensor(q_new_pt_tensor)\n        return Vertex(q_new_pt)\n\n    def _lazy_collision_check(self, q_from: Point, q_to: Point) -> bool:\n        \"\"\"\n        Deferred collision checking - returns True if collision-free or not checked yet.\n        This method postpones heavy collision check until absolutely needed.\n        We only check the actual path when adding an edge for rewiring or confirming path.\n        \"\"\"\n        # Initially accept edge - only verify at rewiring & path extraction\n        return True\n\n    def _validate_edge(self, q_from: Point, q_to: Point) -> bool:\n        # Actual collision check - using standard method\n        line_seq = self._get_grid().get_line_sequence(q_from, q_to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _extract_path(self, q_goal: Vertex):\n\n        # Traverse parents back to start\n        path: List[Vertex] = [q_goal]\n        while len(path[-1].parents) > 0:\n            # parent with minimum cost\n            min_parent = None\n            min_cost = float('inf')\n            for p in path[-1].parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_parent = p\n            if min_parent is None:\n                break\n            path.append(min_parent)\n\n        path.reverse()\n\n        # Smooth path via shortcutting attempts\n        path = self._path_smoothing(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _path_smoothing(self, path: List[Vertex], max_attempts: int = 30) -> List[Vertex]:\n        \"\"\"\n        Attempt to shortcut path segments to smooth path and reduce length.\n        This local smoothing attempts to connect non-consecutive vertices directly if feasible.\n        \"\"\"\n        if len(path) < 3:\n            return path\n\n        pruned_path = path[:]\n        attempts = 0\n        idx = 0\n        while attempts < max_attempts and idx < len(pruned_path) - 2:\n            # Try to connect idx directly to idx+2 or beyond\n            next_idx = idx + 2\n            while next_idx < len(pruned_path):\n                v1 = pruned_path[idx].position\n                v2 = pruned_path[next_idx].position\n                # Check direct connection collision free\n                if self._validate_edge(v1, v2):\n                    # Remove intermediate vertices between idx and next_idx\n                    del pruned_path[idx + 1:next_idx]\n                    attempts += 1\n                    break\n                next_idx += 1\n            idx += 1\n        return pruned_path\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n\n        iterations = 12000  # Can adjust for better time/quality tradeoff\n\n        for i in range(iterations):\n\n            if time.time() - self._start_time > self._time_limit_sec:\n                # Planning failed due to timeout\n                return  # Exit method indicating failure by not extracting path\n\n            q_sample: Point = self._get_random_sample()\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n\n            # If sample is same as nearest vertex, skip\n            if q_nearest.position == q_sample:\n                self.key_frame()\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            # Lazy collision acceptance for edge q_nearest -> q_new\n            if not self._lazy_collision_check(q_nearest.position, q_new.position):\n                self.key_frame()\n                continue\n\n            # Calculate adaptive radius\n            card_v = float(max(self._graph.size, 1))\n            log_card_v = np.log(card_v) if card_v > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), self._max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent q_min minimizing cost + collision free path from q_min to q_new\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                if q_near.cost is None:\n                    continue\n                dist_near_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist_near_new > self._max_dist:\n                    continue  # skip distant neighbors for parent selection\n                if self._validate_edge(q_near.position, q_new.position):\n                    cost_candidate = q_near.cost + dist_near_new\n                    if cost_candidate < c_min:\n                        c_min = cost_candidate\n                        q_min = q_near\n\n            # Set cost and add edge q_min -> q_new\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if better path found through q_new\n            for q_near in Q_near:\n                if q_near is q_min:\n                    continue\n                if q_near.cost is None:\n                    continue\n                dist_new_near = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n                if dist_new_near > self._max_dist:\n                    continue\n                if self._validate_edge(q_new.position, q_near.position):\n                    cost_through_new = q_new.cost + dist_new_near\n                    if cost_through_new < q_near.cost:\n                        # Remove old edge parent->q_near\n                        old_parent = next(iter(q_near.parents), None)\n                        if old_parent:\n                            self._graph.remove_edge(old_parent, q_near)\n                        # Add edge q_new -> q_near\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check if q_new close enough to goal to connect\n            goal_pos = self._graph.root_vertex_goal.position\n            dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_pos.to_tensor()).item()\n            if dist_to_goal <= self._max_dist and self._validate_edge(q_new.position, goal_pos):\n                # Connect and set goal cost\n                goal_vertex = self._graph.root_vertex_goal\n                goal_vertex.cost = q_new.cost + dist_to_goal\n                self._graph.add_edge(q_new, goal_vertex)\n                self._extract_path(goal_vertex)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm": "Improved RRT* inspired algorithm with adaptive sampling, rewiring, and goal bias.\n    Introduces:\n    - Adaptive max extension distance scaled to the map size for better exploration.\n    - Goal bias sampling to accelerate convergence to the target.\n    - Neighborhood radius calculation for efficient rewiring and path quality improvement.\n    - Rewiring of nearby vertices for smooth, shorter paths.\n    - Early termination if a path is found within a feasible number of iterations.\n    - Search timeout handling to avoid excessive run time (>60s).\n    - Uses distance-weighted cost and valid collision-checking lines for graph edges.\n    Overall improves efficiency, success rate, path smoothness, and reduces search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        \n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= 1e-6:\n            return Vertex(q_near.position)  # Prevent division by zero or no movement\n\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        direction_normalized = direction / dist\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * direction_normalized)\n        return Vertex(q_new_point)\n\n    def _get_random_sample(self, goal_bias: float, max_samples: int = 1000) -> Point:\n        \"\"\"Randomly sample a point; with probability goal_bias sample the goal directly.\"\"\"\n        if np.random.random() < goal_bias:\n            return self._get_grid().goal.position\n\n        # Sampling with retries up to max_samples for valid position\n        for _ in range(max_samples):\n            rand_coords = np.random.uniform(low=0, high=np.array(self._get_grid().size.values), size=self._get_grid().size.n_dim)\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n        # Fallback to goal if no valid sample found (rare)\n        return self._get_grid().goal.position\n\n    def _extract_path(self, last_vertex: Vertex) -> None:\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(last_vertex, goal_vertex)\n\n        path: List[Vertex] = [goal_vertex]\n        current = last_vertex\n        while True:\n            if not current.parents:\n                break\n            # Choose parent with minimum cost to ensure optimal path\n            min_parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            path.append(min_parent)\n            current = min_parent\n\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _calculate_neighborhood_radius(self, num_vertices: int, dim: int) -> float:\n        gamma_rrt_star = 2 * (1 + 1/dim) ** (1/dim) * ((self._get_grid().size.width * self._get_grid().size.height) / np.pi) ** (1/dim)\n        return min(gamma_rrt_star * (np.log(num_vertices) / num_vertices) ** (1/dim), 50.0)\n\n    def _find_path_internal(self) -> None:\n        max_time_seconds = 60.0\n        start_time = time()\n\n        grid = self._get_grid()\n        dim = grid.size.n_dim\n\n        # Adaptive max extension distance based on map size (10% of diagonal length, capped)\n        diag = torch.norm(torch.tensor(grid.size.values, dtype=torch.float))\n        max_dist = float(min(max(diag * 0.10, 1.0), 30.0))\n\n        goal_bias = 0.10  # 10% of samples directed to goal\n        max_iterations = 10000\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iteration in range(max_iterations):\n            if time() - start_time > max_time_seconds:\n                # Fail due to timeout\n                break\n\n            q_sample = self._get_random_sample(goal_bias=goal_bias)\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new.position == q_near.position:\n                continue\n\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors in radius for rewiring\n            neighborhood_radius = self._calculate_neighborhood_radius(self._graph.size + 1, dim)\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, neighborhood_radius)\n\n            # Initialize cost and parent\n            min_cost = q_near.cost + grid.get_distance(q_near.position, q_new.position) if q_near.cost is not None else float('inf')\n            parent_vertex = q_near\n\n            # Choose best parent from neighbors to minimize cost\n            for neighbor in neighbors:\n                if neighbor.position == q_near.position:\n                    continue\n                potential_line = grid.get_line_sequence(neighbor.position, q_new.position)\n                if not grid.is_valid_line_sequence(potential_line):\n                    continue\n                if neighbor.cost is None:\n                    continue\n                new_cost = neighbor.cost + grid.get_distance(neighbor.position, q_new.position)\n                if new_cost < min_cost:\n                    min_cost = new_cost\n                    parent_vertex = neighbor\n\n            q_new.cost = min_cost\n            self._graph.add_edge(parent_vertex, q_new)\n\n            # Rewire neighbors to new vertex if it improves cost\n            for neighbor in neighbors:\n                if neighbor == parent_vertex:\n                    continue\n                line_to_neighbor = grid.get_line_sequence(q_new.position, neighbor.position)\n                if not grid.is_valid_line_sequence(line_to_neighbor):\n                    continue\n                if q_new.cost is None:\n                    continue\n                new_cost = q_new.cost + grid.get_distance(q_new.position, neighbor.position)\n                if neighbor.cost is None or new_cost < neighbor.cost:\n                    # Rewire parent edge\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm": "This path planning algorithm improves upon existing RRT-Connect and SPRM techniques by combining\n    bidirectional RRT-connect style tree expansion with informed sampling and rewiring inspired by RRT*.\n    Key improvements include:\n    - Adaptive sampling bias towards the goal region to improve convergence.\n    - Dynamic max extension distance based on environment dimensions.\n    - Rewiring of vertices within a shrinking radius to improve path quality and smoothness.\n    - Use of cyclic graph to maintain multiple feasible paths and improve robustness.\n    - Early termination if path is found.\n    - Time-out logic aborting search after 60 seconds to ensure responsiveness.\n    This approach aims for faster convergence, higher success rate, smoother and shorter paths, while maintaining\n    robustness in complex obstacle environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_dist: float\n    _iterations: int\n    _goal_sample_rate: float\n    _rewire_radius: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        agent_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n        # Initialize a cyclic graph with start and goal vertices\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(agent_pos, store_connectivity=True),\n                                       Vertex(goal_pos, store_connectivity=True),\n                                       [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        # Maximum extension distance normalized by map diagonal length for adaptive scaling\n        size = self._get_grid().size\n        diag_len = torch.norm(torch.tensor(size.values).float()).item()\n        self._max_dist = max(5.0, diag_len * 0.1)  # Minimum 5 or 10% of diagonal\n\n        self._iterations = 15000\n        self._goal_sample_rate = 0.15  # Probability of sampling goal directly to bias search\n        self._rewire_radius = diag_len * 0.15  # Radius for rewiring step to improve path quality\n\n    def _get_random_sample(self) -> Point:\n        # Bias sampling towards goal with a defined probability\n        if torch.rand(1).item() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        size = self._get_grid().size\n        while True:\n            sample_coords = [torch.randint(0, size[i], (1,)).item() for i in range(size.n_dim)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, q_near: Vertex, q_rand: Point) -> Vertex:\n        # Return vertex extended towards q_rand with max distance limit\n        dir_vec = q_rand.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= self._max_dist:\n            return Vertex(q_rand, store_connectivity=True)\n        dir_normalized = dir_vec / dist\n        new_pt_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n        new_point = Point.from_tensor(new_pt_tensor)\n        return Vertex(new_point, store_connectivity=True)\n\n    def _nearest(self, points: List[Vertex], target: Point) -> Vertex:\n        # Find closest vertex in points to target\n        return min(points, key=lambda v: torch.norm(v.position.to_tensor() - target.to_tensor()).item())\n\n    def _rewire(self, new_vertex: Vertex, neighborhood: List[Vertex]) -> None:\n        # Attempt to improve path quality by rewiring connections\n        grid = self._get_grid()\n        for neighbor in neighborhood:\n            if neighbor == new_vertex:\n                continue\n            line_seq = grid.get_line_sequence(new_vertex.position, neighbor.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_new_to_neighbor = grid.get_movement_cost(new_vertex.position, neighbor.position)\n            new_cost = new_vertex.cost + cost_new_to_neighbor\n            if neighbor.cost is None or new_cost < neighbor.cost:\n                # Rewire connection in cyclic graph\n                # Remove old parents edges (if any) pointing to neighbor, add new edge from new_vertex to neighbor\n                for p in list(neighbor.parents):\n                    self._graph.remove_edge(p, neighbor)\n                self._graph.add_edge(new_vertex, neighbor)\n                neighbor.cost = new_cost\n                # Update connectivity map for path extraction\n                new_vertex.connectivity[neighbor] = neighbor\n\n    def _extract_path(self) -> None:\n        # Extract best path by following connectivity from start vertex to goal vertex\n        start_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n        path = []\n        current = start_vertex\n\n        # Build path by following connectivity towards goal\n        visited = set()\n        while current != goal_vertex:\n            visited.add(current)\n            if goal_vertex in current.connectivity:\n                nxt = current.connectivity[goal_vertex]\n            else:\n                # Fallback: pick nearest connectivity vertex to goal\n                candidates = [v for v in current.connectivity if v not in visited]\n                if not candidates:\n                    break\n                nxt = min(candidates, key=lambda v: torch.norm(v.position.to_tensor() - goal_vertex.position.to_tensor()).item())\n            path.append(nxt)\n            current = nxt\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        # Initialize root vertices costs\n        start_vertex.cost = 0.0\n        goal_vertex.cost = None\n\n        # Add start and goal vertices to root_vertices list to keep track\n        self._graph.root_vertices = [start_vertex, goal_vertex]\n\n        for i in range(self._iterations):\n            if time.time() - start_time > 60.0:\n                # Timeout: treat as failure\n                return\n\n            # Sample random point with goal bias\n            q_rand = self._get_random_sample()\n\n            # Pick which tree to extend: alternate between start and goal roots\n            tree_a, tree_b = self._graph.root_vertices\n            if i % 2 == 0:\n                src_tree = tree_a\n                tgt_tree = tree_b\n            else:\n                src_tree = tree_b\n                tgt_tree = tree_a\n\n            # Extend src_tree towards q_rand\n            near_vertex = self._nearest([src_tree], q_rand)\n            new_vertex = self._steer(near_vertex, q_rand)\n\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(near_vertex.position, new_vertex.position)):\n                continue\n\n            # Set cost to new_vertex\n            new_vertex.cost = (near_vertex.cost if near_vertex.cost is not None else 0) + grid.get_movement_cost(near_vertex.position, new_vertex.position)\n\n            # Add new_vertex to the graph and link it\n            self._graph.root_vertices.append(new_vertex)\n            self._graph.add_edge(near_vertex, new_vertex)\n\n            # Rewire neighbors to improve path quality\n            neighborhood = self._graph.get_vertices_within_radius(self._graph.root_vertices, new_vertex.position, self._rewire_radius)\n            self._rewire(new_vertex, neighborhood)\n\n            # Try to connect new_vertex to opposite tree within max_dist\n            near_vertex_opposite = self._nearest([tgt_tree], new_vertex.position)\n            line_seq_connect = grid.get_line_sequence(new_vertex.position, near_vertex_opposite.position)\n\n            dist_connect = torch.norm(new_vertex.position.to_tensor() - near_vertex_opposite.position.to_tensor()).item()\n            if dist_connect <= self._max_dist and grid.is_valid_line_sequence(line_seq_connect):\n                # Connect both trees\n                new_vertex.cost += grid.get_movement_cost(new_vertex.position, near_vertex_opposite.position)\n                self._graph.add_edge(new_vertex, near_vertex_opposite)\n                self._graph.add_edge(near_vertex_opposite, new_vertex)\n                # Reconstruct path and exit\n                self._extract_path()\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "PathPlanning Algorithm: An improved sample-based path planning algorithm that combines the strengths of RRT* and informed sampling,\n    with a bidirectional search and path smoothing. It grows two trees, one from the start (agent) and one from the goal, expanding towards\n    random samples confined inside an ellipsoidal informed sampling region after an initial solution is found to accelerate convergence.\n    Rewiring within neighborhoods ensures path quality improvements. The bidirectional approach increases success rate and reduces search time.\n    Finally, a post-processing smoothing step improves path smoothness and reduces unnecessary detours.\n    The entire search is bounded by a 60-second timeout to guarantee robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _tree_start: Forest\n    _tree_goal: Forest\n    _max_extend_dist: float\n    _max_iterations: int\n    _search_timeout: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n\n        self._max_extend_dist = 12.0\n        self._max_iterations = 15000\n        self._search_timeout = 60.0  # 60 seconds timeout\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        # Use Forest graphs representing bidirectional trees\n        self._tree_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._tree_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n\n        self._init_displays()\n\n    # Helper for get random samples, optionally within ellipsoid informed region\n    def _get_random_sample(self, c_best: Optional[float], c_min: float,\n                           start: Point, goal: Point) -> Point:\n        # If no solution found yet, sample uniformly from full space\n        grid_size = self._get_grid().size.values\n        if c_best is None:\n            while True:\n                sample = Point(*[torch.randint(0, dim, (1,)).item() for dim in grid_size])\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling inside ellipsoid that bounds current best path length\n        c_best = max(c_best, c_min)\n        center = torch.tensor([(start.x + goal.x) * 0.5, (start.y + goal.y) * 0.5])\n        diff = torch.tensor([goal.x - start.x, goal.y - start.y])\n        e1 = diff / torch.norm(diff)\n        # Compute rotation matrix to align ellipsoid with the line start-goal\n        M = torch.tensor([[0.0, -1.0], [1.0, 0.0]])\n        e2 = M @ e1\n        # Radii of ellipsoid\n        a1 = c_best * 0.5\n        b1 = torch.sqrt(torch.tensor(c_best ** 2 - c_min ** 2)) * 0.5\n        tries = 0\n        max_tries = 1000\n        while tries < max_tries:\n            # Sample unit circle point\n            r = torch.sqrt(torch.rand(1))\n            theta = 2 * torch.pi * torch.rand(1)\n            x_ball = r * torch.cos(theta)\n            y_ball = r * torch.sin(theta)\n            # Scale point by ellipsoid radii\n            sample_point = center + a1 * e1 * x_ball + b1 * e2 * y_ball\n            pt_int = Point(int(sample_point[0].item()), int(sample_point[1].item()))\n            if self._get_grid().is_agent_valid_pos(pt_int):\n                return pt_int\n            tries += 1\n        # Fallback uniform sampling if ellipsoid sampling fails repeatedly\n        while True:\n            sample = Point(*[torch.randint(0, dim, (1,)).item() for dim in grid_size])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, tree: Forest, q_sample: Point) -> Vertex:\n        return tree.get_nearest_vertex(tree.root_vertices, q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pt = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pt)\n\n    def _is_collision_free(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _get_vertices_within_radius(self, tree: Forest, vertex: Vertex, radius: float) -> List[Vertex]:\n        return tree.get_vertices_within_radius(tree.root_vertices, vertex.position, radius)\n\n    def _rewire(self, tree: Forest, q_new: Vertex, neighbors: List[Vertex]):\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            if self._is_collision_free(q_new.position, q_near.position):\n                cost_through_new = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if q_near.cost is None or cost_through_new < q_near.cost:\n                    # Remove old parent edge\n                    old_parents = list(q_near.parents)\n                    for old_p in old_parents:\n                        tree.remove_edge(old_p, q_near)\n\n                    # Add new edge q_new -> q_near\n                    q_near.cost = cost_through_new\n                    tree.add_edge(q_new, q_near)\n\n    def _construct_path(self, vertex_start: Vertex, vertex_goal: Vertex) -> List[Point]:\n        # Trace back from start tree root vertex\n        path_start = []\n        v = vertex_start\n        while True:\n            path_start.append(v.position)\n            if len(v.parents) == 0:\n                break\n            v = next(iter(v.parents))\n        path_start.reverse()\n\n        # Trace back from goal tree root vertex\n        path_goal = []\n        v = vertex_goal\n        while True:\n            path_goal.append(v.position)\n            if len(v.parents) == 0:\n                break\n            v = next(iter(v.parents))\n\n        return path_start + path_goal\n\n    def _smooth_path(self, path: List[Point], max_iter=50) -> List[Point]:\n        if len(path) < 3:\n            return path\n\n        for _ in range(max_iter):\n            if len(path) <= 2:\n                break\n            i = torch.randint(0, len(path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(path), (1,)).item()\n\n            p_i = path[i]\n            p_j = path[j]\n\n            if self._is_collision_free(p_i, p_j):\n                # Remove intermediate points between i and j\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _find_path_internal(self) -> None:\n\n        start_time = time.time()\n        grid = self._get_grid()\n        start_pos = grid.agent.position\n        goal_pos = grid.goal.position\n        dimension = grid.size.n_dim\n        c_min = Map.get_distance(start_pos, goal_pos)  # minimum possible distance start-goal\n        c_best = None\n\n        radius_const = 50.0  # For neighbor circle in rewire, depends on dimension and graph size\n\n        # Initialize root vertices cost\n        self._tree_start.root_vertex_start.cost = 0.0\n        self._tree_goal.root_vertex_start.cost = 0.0\n\n        for i in range(self._max_iterations):\n\n            if time.time() - start_time > self._search_timeout:\n                # Fail if time exceeds 60 seconds\n                return\n\n            # Sample point, informed if solution found, else uniform\n            q_sample = self._get_random_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Extend tree from start\n            q_near_start = self._get_nearest_vertex(self._tree_start, q_sample)\n            q_new_start = self._get_new_vertex(q_near_start, q_sample, self._max_extend_dist)\n            if not self._is_collision_free(q_near_start.position, q_new_start.position):\n                self.key_frame()\n                continue\n\n            # Calculate cost to new node\n            cost_to_new_start = q_near_start.cost + torch.norm(q_near_start.position.to_tensor() - q_new_start.position.to_tensor())\n            q_new_start.cost = cost_to_new_start\n            self._tree_start.add_edge(q_near_start, q_new_start)\n            neighbors_start = self._get_vertices_within_radius(self._tree_start, q_new_start, radius_const)\n            self._rewire(self._tree_start, q_new_start, neighbors_start)\n\n            # Extend tree from goal towards new_start sample\n            q_near_goal = self._get_nearest_vertex(self._tree_goal, q_new_start.position)\n            q_new_goal = self._get_new_vertex(q_near_goal, q_new_start.position, self._max_extend_dist)\n            if not self._is_collision_free(q_near_goal.position, q_new_goal.position):\n                self.key_frame()\n                continue\n\n            cost_to_new_goal = q_near_goal.cost + torch.norm(q_near_goal.position.to_tensor() - q_new_goal.position.to_tensor())\n            q_new_goal.cost = cost_to_new_goal\n            self._tree_goal.add_edge(q_near_goal, q_new_goal)\n            neighbors_goal = self._get_vertices_within_radius(self._tree_goal, q_new_goal, radius_const)\n            self._rewire(self._tree_goal, q_new_goal, neighbors_goal)\n\n            # Check if connection between two trees is possible\n            dist_start_goal = torch.norm(q_new_start.position.to_tensor() - q_new_goal.position.to_tensor())\n            if dist_start_goal <= self._max_extend_dist:\n                # Check collision free connection\n                if self._is_collision_free(q_new_start.position, q_new_goal.position):\n                    # Connect trees\n                    self._tree_start.add_edge(q_new_start, q_new_goal)\n                    self._tree_goal.add_edge(q_new_goal, q_new_start)\n\n                    # Calculate total cost of this path\n                    total_cost = q_new_start.cost + dist_start_goal + q_new_goal.cost\n                    if c_best is None or total_cost < c_best:\n                        c_best = total_cost\n                        # Construct full path\n                        path = self._construct_path(q_new_start, q_new_goal)\n                        # Smooth path for better quality\n                        smooth_path = self._smooth_path(path)\n                        # Move agent through path\n                        for p in smooth_path:\n                            self.move_agent(p)\n                            self.key_frame(ignore_key_frame_skip=True)\n                        return\n\n            self.key_frame()\n\n        # If no path found in max iterations, no result\n        return",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm": "This algorithm is an enhanced RRT* variant with adaptive sampling bias inspired by goal-biased RRT*, \n    integration of dynamic neighborhood radius, and early stopping criterion to improve planning efficiency, \n    path quality, and robustness. It uses informed sampling near the current best path to refine the solution, \n    rewires efficiently using a dynamically computed radius based on RRT* theory, and terminates if no path \n    improvement is observed within a fixed budget or after 60 seconds. Path smoothness and lengths are improved \n    by performing post-processing shortcutting on the extracted path before execution. \n    This implementation balances exploration with exploitation, significantly reducing search time and increasing success rate.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _max_radius_cap: float\n    _dimension: int\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_dist = 12.0  # maximum extend distance in one step (adjusted for smoother steps)\n        self._lambda_rrt_star = 50.0  # constant for radius calculation in rewiring\n        self._max_radius_cap = 60.0  # maximum radius for neighbor search/re-wiring\n        self._dimension = self._get_grid().size.n_dim\n        self._init_displays()\n\n    def _get_random_sample_informed(self, best_cost: Optional[float]) -> Point:\n        \"\"\"\n        Generate random samples biased toward the ellipsoidal informed subset if best_cost is known,\n        otherwise uniform sampling.\n        \"\"\"\n        if best_cost is None:\n            # Regular uniform random sampling\n            return self._get_random_sample_uniform()\n\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        c_min = torch.norm(start - goal).item()\n\n        if best_cost <= c_min:\n            # No improvement possible; fallback to uniform sample\n            return self._get_random_sample_uniform()\n\n        # Ellipsoidal sampling (Informed RRT*) in 2D or higher dimension:\n        c_best = best_cost\n        center = (start + goal) / 2\n        a1 = (goal - start) / c_min\n        # Construct orthonormal basis using Householder matrix or Gram-Schmidt\n        # For simplicity: basis matrix where first column is a1\n        e = torch.eye(self._dimension)\n        e[:, 0] = a1\n        # Create diagonal scaling matrix for ellipsoid radii\n        r1 = c_best / 2\n        r2 = torch.sqrt(c_best**2 - c_min**2) / 2\n        radii = torch.ones(self._dimension) * r2\n        radii[0] = r1\n        # Sample a random point in unit n-ball\n        x_ball = self._sample_unit_n_ball(self._dimension)\n        # Scale and rotate to ellipsoid\n        rnd_point = center + (e @ (radii * x_ball))\n        p = Point.from_tensor(rnd_point)\n\n        # Ensure valid position, fallback to uniform sample if invalid\n        if not self._get_grid().is_agent_valid_pos(p):\n            return self._get_random_sample_uniform()\n\n        return p\n\n    def _sample_unit_n_ball(self, n: int) -> torch.Tensor:\n        \"\"\"\n        Sample a random point uniformly inside an n-dimensional unit ball.\n        \"\"\"\n        direction = torch.randn(n)\n        direction /= torch.norm(direction)\n        radius = torch.rand(1).pow(1 / n)\n        return direction * radius\n\n    def _get_random_sample_uniform(self) -> Point:\n        \"\"\"\n        Uniform random sample inside map boundaries that is valid for the agent.\n        \"\"\"\n        size = self._get_grid().size\n        while True:\n            sample_coords = [np.random.randint(0, size[i]) for i in range(size.n_dim)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        \"\"\"\n        Find nearest vertex in tree to the sample.\n        \"\"\"\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"\n        Returns list of vertices within the radius of given vertex.\n        \"\"\"\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        Create a new vertex extending from q_near toward q_sample by max_dist.\n        \"\"\"\n        delta = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(delta)\n        if dist <= max_dist:\n            new_pos = q_sample\n        else:\n            direction = delta / dist\n            new_pos = Point.from_tensor(q_near.position.to_tensor() + direction * max_dist)\n        return Vertex(new_pos)\n\n    def _rewire(self, q_new: Vertex, Q_near: List[Vertex]) -> None:\n        \"\"\"\n        Attempts to rewire neighbors vertices to q_new when beneficial.\n        \"\"\"\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            # Check if edge from q_new -> q_near is collision free\n            line = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            valid_edge = self._get_grid().is_valid_line_sequence(line)\n            new_cost = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n            if valid_edge and new_cost < q_near.cost:\n                # Remove old edge(s) from parent(s)\n                parents = list(q_near.parents)\n                for p in parents:\n                    self._graph.remove_edge(p, q_near)\n                # Update cost\n                q_near.cost = new_cost\n                # Add new edge from q_new to q_near\n                self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Vertex]:\n        \"\"\"\n        Extract path from start to goal by traversing parent links.\n        \"\"\"\n        path = []\n        v = goal_vertex\n        while v is not None and len(v.parents) > 0:\n            path.append(v)\n            # Grab any one parent (since paths are trees)\n            v = next(iter(v.parents))\n        if v is not None:\n            path.append(v)  # add start\n        path.reverse()\n        return path\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Performs path smoothing by attempting to shortcut between non-consecutive nodes.\n        \"\"\"\n        if len(path) < 3:\n            return path\n\n        new_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line = self._get_grid().get_line_sequence(new_path[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    new_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # no shortcut found, add next vertex\n                new_path.append(path[i + 1])\n                i += 1\n        return new_path\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 15000\n        start_time = time.time()\n        max_no_improve_iters = 1000\n\n        best_goal_cost = None\n        best_goal_vertex = None\n        no_improve_counter = 0\n\n        while True:\n\n            elapsed = time.time() - start_time\n            if elapsed > 60:\n                # Fail due to timeout\n                return  # end without path found\n\n            # 1. Sample\n            q_sample = self._get_random_sample_informed(best_goal_cost)\n\n            # 2. Nearest vertex in tree\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # 3. New vertex in direction of sample (extend)\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            # 4. Collision check between q_nearest and q_new\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            # 5. Find neighbors for rewiring\n            n_vertices = max(self._graph.size, 1)\n            gamma_rrt_star = self._lambda_rrt_star\n            radius = min(gamma_rrt_star * ((torch.log(torch.tensor(n_vertices))/n_vertices)**(1/self._dimension)), self._max_radius_cap)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # 6. Choose parent with lowest cost + collision-free path\n            c_min = None\n            q_min = None\n            for q_near in Q_near:\n                if q_near.position == q_new.position:\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    continue\n                cost = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n                if c_min is None or cost < c_min:\n                    c_min = cost\n                    q_min = q_near\n\n            # If no suitable parent found, ignore q_new\n            if q_min is None:\n                # Could add q_new as isolated vertex, but skipping\n                continue\n\n            # 7. Add q_new with parent q_min\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # 8. Rewire neighbors through q_new if possible\n            self._rewire(q_new, Q_near)\n\n            # 9. Check if q_new reached goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Create goal vertex connected to q_new\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_vertex.position.to_tensor()).item()\n                goal_vertex.cost = q_new.cost + dist_to_goal\n                # Check collision between q_new and goal\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    # Update best goal if improved\n                    if best_goal_cost is None or goal_vertex.cost < best_goal_cost:\n                        best_goal_cost = goal_vertex.cost\n                        best_goal_vertex = goal_vertex\n                        no_improve_counter = 0\n                    else:\n                        no_improve_counter += 1\n                else:\n                    no_improve_counter += 1\n            else:\n                no_improve_counter += 1\n\n            # 10. Early stopping: no improvement for many iterations or time over\n            if no_improve_counter > max_no_improve_iters:\n                break\n\n            self.key_frame()\n\n            # Safety break for iterations (just to avoid infinite loop)\n            if self._graph.size > max_iterations:\n                break\n\n        # If a path was found, extract and smooth it, then move agent along path\n        if best_goal_vertex is not None:\n            path_vertices = self._extract_path(best_goal_vertex)\n            smooth_path = self._shortcut_path(path_vertices)\n            for vertex in smooth_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm": "Hybrid RRT* + RRT-Connect inspired path planning algorithm with adaptive rewiring and goal bias.\n    This algorithm grows two trees simultaneously: one from start and one from goal,\n    using a bidirectional sampling strategy with goal bias to boost convergence.\n    It improves path quality by rewiring vertices within a radius to reduce cost,\n    applies lazy collision checking to accelerate exploration,\n    and attempts direct connections between trees to quickly close the path.\n    Execution halts upon success or if runtime exceeds 60 seconds to guarantee bounded search time.\n    This design aims for better planning efficiency, improved success rate, smoother and \n    shorter paths, and overall path planning robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_dist: float\n    _iterations: int\n    _goal_sample_rate: float  # Probability of sampling the goal point\n    _rewire_radius_factor: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = CyclicGraph(start_vertex, goal_vertex, [start_vertex, goal_vertex])\n        self._max_dist = 15.0\n        self._iterations = 15000\n        self._goal_sample_rate = 0.1  # 10% chance to directly sample goal (goal bias)\n        self._rewire_radius_factor = 30.0  # radius to consider for rewiring, can be tuned\n        self._init_displays()\n\n    # Helper - Generate samples with goal bias\n    def _get_random_sample(self) -> Point:\n        import numpy as np\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        size = self._get_grid().size\n        while True:\n            rand_pos = np.random.randint(0, size.values, size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    # Helper - Steer towards sample, limited by max_dist\n    def _steer(self, from_vertex: Vertex, to_point: Point) -> Vertex:\n        from_pos_tensor = from_vertex.position.to_tensor()\n        to_pos_tensor = to_point.to_tensor()\n        direction = to_pos_tensor - from_pos_tensor\n        dist = torch.norm(direction)\n        if dist <= self._max_dist:\n            new_pos = to_point\n        else:\n            direction_normalized = direction / dist\n            new_pos_tensor = from_pos_tensor + direction_normalized * self._max_dist\n            new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos, store_connectivity=True)\n\n    # Helper - Find best parent for new vertex among vertices within radius, return best parent and cost\n    def _choose_parent(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> Tuple[Optional[Vertex], float]:\n        min_cost = float(\"inf\")\n        best_parent = None\n        for near_vertex in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(near_vertex.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = near_vertex.cost + self._get_grid().get_movement_cost(near_vertex.position, new_vertex.position) if near_vertex.cost is not None else self._get_grid().get_movement_cost(near_vertex.position, new_vertex.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = near_vertex\n        return best_parent, min_cost\n\n    # Helper - Rewire nearby vertices to the new vertex if cheaper\n    def _rewire(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> None:\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex:\n                continue\n            line_seq = self._get_grid().get_line_sequence(new_vertex.position, near_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, near_vertex.position)\n            if near_vertex.cost is None or new_cost < near_vertex.cost:\n                # Remove old parents' edges to near_vertex\n                for p in list(near_vertex.parents):\n                    self._graph.remove_edge(p, near_vertex)\n                # Add new edge from new_vertex\n                self._graph.add_edge(new_vertex, near_vertex)\n                near_vertex.cost = new_cost\n\n    # Helper - Compute Euclidean distance between two points\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return float(torch.norm(p1.to_tensor() - p2.to_tensor()))\n\n    # Helper - Extract path from start to goal by tracing parents\n    def _extract_path(self, connecting_vertex_start: Vertex, connecting_vertex_goal: Vertex) -> None:\n        # From connecting point to start\n        path_from_start = [connecting_vertex_start]\n        while len(path_from_start[-1].parents) != 0:\n            # We assume single parent for simplicity\n            for parent in path_from_start[-1].parents:\n                path_from_start.append(parent)\n                break\n        path_from_start.reverse()\n\n        # From connecting point to goal\n        path_from_goal = [connecting_vertex_goal]\n        while len(path_from_goal[-1].parents) != 0:\n            for parent in path_from_goal[-1].parents:\n                path_from_goal.append(parent)\n                break\n\n        full_path = path_from_start + path_from_goal\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Attempts connection between two trees from new_vertex_start to tree_goal, returns connecting vertex if successful else None\n    def _try_connect_trees(self, new_vertex_start: Vertex, tree_goal_root: Vertex) -> Optional[Tuple[Vertex, Vertex]]:\n        # Get nearest vertex in goal tree to new_vertex_start\n        nearest_goal_vertex = self._graph.get_nearest_vertex([tree_goal_root], new_vertex_start.position)\n        direction = nearest_goal_vertex.position.to_tensor() - new_vertex_start.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist == 0:\n            return None\n        direction_normalized = direction / dist\n        extend_len = min(self._max_dist, dist)\n        new_pos_tensor = new_vertex_start.position.to_tensor() + direction_normalized * extend_len\n        new_vertex_goal = Vertex(Point.from_tensor(new_pos_tensor), store_connectivity=True)\n\n        # Check collision\n        line_seq = self._get_grid().get_line_sequence(new_vertex_start.position, new_vertex_goal.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        # Add edge to goal tree\n        self._graph.add_edge(nearest_goal_vertex, new_vertex_goal)\n        new_vertex_goal.cost = nearest_goal_vertex.cost + self._get_grid().get_movement_cost(nearest_goal_vertex.position, new_vertex_goal.position) if nearest_goal_vertex.cost is not None else self._get_grid().get_movement_cost(nearest_goal_vertex.position, new_vertex_goal.position)\n\n        # Try to connect further until new_vertex_goal reaches nearest_goal_vertex (reached goal tree)\n        current_vertex = new_vertex_goal\n        while True:\n            dist_to_nearest = self._dist(current_vertex.position, nearest_goal_vertex.position)\n            if dist_to_nearest < 1e-5:\n                # Connection complete; set parents accordingly\n                return new_vertex_start, current_vertex\n            extend_len = min(self._max_dist, dist_to_nearest)\n            dir_vec = nearest_goal_vertex.position.to_tensor() - current_vertex.position.to_tensor()\n            dir_norm = dir_vec / torch.norm(dir_vec)\n            next_pos_tensor = current_vertex.position.to_tensor() + dir_norm * extend_len\n            next_vertex = Vertex(Point.from_tensor(next_pos_tensor), store_connectivity=True)\n            line_seq = self._get_grid().get_line_sequence(current_vertex.position, next_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                return None\n            self._graph.add_edge(current_vertex, next_vertex)\n            next_vertex.cost = current_vertex.cost + self._get_grid().get_movement_cost(current_vertex.position, next_vertex.position) if current_vertex.cost is not None else self._get_grid().get_movement_cost(current_vertex.position, next_vertex.position)\n            current_vertex = next_vertex\n\n    # Main search implementation\n    def _find_path_internal(self) -> None:\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = 0.0\n\n        start_tree = self._graph.root_vertex_start\n        goal_tree = self._graph.root_vertex_goal\n\n        start_vertices = [start_tree]\n        goal_vertices = [goal_tree]\n\n        start_tree.cost = 0.0\n        goal_tree.cost = 0.0\n\n        start_root_vertices = [start_tree]\n        goal_root_vertices = [goal_tree]\n        from random import shuffle\n\n        start_time = time()\n        for iteration in range(self._iterations):\n\n            # Time cutoff check\n            if time() - start_time > 60:\n                # Fail gracefully\n                break\n\n            # Alternate expanding trees or swap roots for bidirectional growth\n            if iteration % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            # Sample a point from the space\n            q_rand = self._get_random_sample()\n\n            # Find nearest vertex in tree_a to q_rand\n            q_near = self._graph.get_nearest_vertex([tree_a], q_rand)\n\n            # Steer from q_near toward q_rand\n            q_new = self._steer(q_near, q_rand)\n            if q_new.position == q_near.position:\n                continue\n\n            # Check collision for edge (q_near -> q_new)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find vertices near q_new within radius for rewiring and choosing best parent\n            radius = self._rewire_radius_factor * ((torch.log(torch.tensor(self._graph.size + 1))) / (iteration+1))**(1/self._get_grid().size.n_dim) \\\n                     if iteration > 0 else self._max_dist\n            if radius < self._max_dist:\n                radius = self._max_dist\n            near_vertices = self._graph.get_vertices_within_radius([tree_a], q_new.position, radius)\n\n            # Choose parent with minimum cost\n            best_parent, best_cost = self._choose_parent(q_new, near_vertices)\n            if best_parent is None:\n                # fallback: connect from q_near directly\n                best_parent = q_near\n                best_cost = (q_near.cost if q_near.cost is not None else 0.0) + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n\n            # Assign cost and add edge\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire nearby vertices via q_new if cheaper\n            self._rewire(q_new, near_vertices)\n\n            # Check if q_new in goal radius (if expanding start_tree) or start radius (if expanding goal_tree)\n            if tree_a is start_tree and self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Attempt to connect q_new directly to goal tree\n                connecting = self._try_connect_trees(q_new, goal_tree)\n                if connecting is not None:\n                    start_connect, goal_connect = connecting\n                    self._extract_path(start_connect, goal_connect)\n                    break\n\n            if tree_a is goal_tree and self._dist(q_new.position, start_tree.position) <= self._max_dist:\n                # Try connect to start tree\n                nearest_start_vertex = self._graph.get_nearest_vertex([start_tree], q_new.position)\n                line_seq = self._get_grid().get_line_sequence(nearest_start_vertex.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Connect edges and extract path\n                    self._graph.add_edge(nearest_start_vertex, q_new)\n                    q_new.cost = (nearest_start_vertex.cost if nearest_start_vertex.cost is not None else 0.0) + self._get_grid().get_movement_cost(nearest_start_vertex.position,q_new.position)\n                    self._extract_path(nearest_start_vertex, q_new)\n                    break\n\n            # Swap roots for next iteration to promote balanced tree growth\n            if iteration % 2 == 0:\n                start_tree, goal_tree = goal_tree, start_tree\n\n            # Visualization\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm": "This algorithm is an improved hybrid bidirectional RRT* variant with path smoothing.\n    It grows two trees from the agent and the goal, extends them towards random samples,\n    and attempts to connect them efficiently. Local rewiring optimizes path quality.\n    Once a path is found, a post-processing smoothing step reduces unnecessary waypoints.\n    The algorithm stops and returns failure if it exceeds 60 seconds for robust runtime control.\n    It balances efficient search, path quality, smoothness and timely termination.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n    _max_extend_dist: float\n    _max_iterations: int\n    _rewire_radius: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n\n        agent_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n        self._graph = gen_forest(self._services, Vertex(agent_pos), Vertex(goal_pos), [])\n        self._graph.edges_removable = True\n\n        self._max_extend_dist = max(self._get_grid().size.width, self._get_grid().size.height) * 0.1\n        self._max_iterations = 15000\n        self._rewire_radius = self._max_extend_dist * 2.5\n\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, root_vertices: List[Vertex], point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(root_vertices, point)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Optional[Vertex]:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist < 1e-6:\n            return None\n        if dist <= self._max_extend_dist:\n            new_pos = q_sample\n        else:\n            direction = dir_vec / dist\n            new_pos_tensor = q_near.position.to_tensor() + direction * self._max_extend_dist\n            new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _line_valid(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _extend_tree(self, tree_root: Vertex, point: Point) -> Optional[Vertex]:\n        nearest = self._get_nearest_vertex([tree_root], point)\n        new_vertex = self._get_new_vertex(nearest, point)\n        if new_vertex is None:\n            return None\n        if not self._line_valid(nearest.position, new_vertex.position):\n            return None\n        new_vertex.cost = nearest.cost + self._get_grid().get_movement_cost(nearest.position, new_vertex.position) if nearest.cost is not None else 0.0\n        self._graph.add_edge(nearest, new_vertex)\n        self._rewire(new_vertex, tree_root)\n        return new_vertex\n\n    def _rewire(self, new_vertex: Vertex, tree_root: Vertex) -> None:\n        neighbors = self._graph.get_vertices_within_radius([tree_root], new_vertex.position, self._rewire_radius)\n        for neighbor in neighbors:\n            if neighbor == new_vertex:\n                continue\n            if not self._line_valid(new_vertex.position, neighbor.position):\n                continue\n            new_cost = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, neighbor.position)\n            if neighbor.cost is None or new_cost < neighbor.cost:\n                # Remove old parents edges and add new one for best path\n                for parent in list(neighbor.parents):\n                    self._graph.remove_edge(parent, neighbor)\n                self._graph.add_edge(new_vertex, neighbor)\n                neighbor.cost = new_cost\n\n    def _connect_trees(self, v_start: Vertex, v_goal: Vertex) -> Optional[List[Vertex]]:\n        # Try to connect two trees\n        if not self._line_valid(v_start.position, v_goal.position):\n            return None\n        # Add connection edge if valid\n        self._graph.add_edge(v_start, v_goal)\n        self._graph.add_edge(v_goal, v_start)\n\n        # Extract path from start to goal following parents\n        path_start = []\n        current = v_start\n        while current.parents:\n            current = next(iter(current.parents))\n            path_start.append(current)\n        path_start = [v_start] + path_start\n        path_start.reverse()\n\n        path_goal = []\n        current = v_goal\n        while current.parents:\n            current = next(iter(current.parents))\n            path_goal.append(current)\n        path_goal = [v_goal] + path_goal\n\n        full_path = path_start + path_goal\n        return full_path\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_valid(smoothed[-1].position, path[j].position):\n                    smoothed.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                smoothed.append(path[i + 1])\n                i += 1\n        return smoothed\n\n    def _extract_path(self, connection_vertex_start: Vertex, connection_vertex_goal: Vertex) -> None:\n        path_vertices = self._connect_trees(connection_vertex_start, connection_vertex_goal)\n        if path_vertices is None:\n            return\n        path_vertices = self._smooth_path(path_vertices)\n\n        for vertex in path_vertices:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        # Initialize root vertices costs\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = 0.0\n\n        tree_start = self._graph.root_vertex_start\n        tree_goal = self._graph.root_vertex_goal\n\n        for it in range(self._max_iterations):\n            if time.time() - start_time > 60.0:\n                # Search timed out - no path found\n                return\n\n            q_rand = self._get_random_sample()\n\n            # Extend tree_start towards random sample\n            new_vertex_start = self._extend_tree(tree_start, q_rand)\n            if new_vertex_start:\n                # Try to connect tree_goal to new_vertex_start\n                new_vertex_goal = self._extend_tree(tree_goal, new_vertex_start.position)\n                if new_vertex_goal and new_vertex_goal.position == new_vertex_start.position:\n                    self._extract_path(new_vertex_start, new_vertex_goal)\n                    return\n\n            # Swap the trees to alternate extension from both sides\n            tree_start, tree_goal = tree_goal, tree_start\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm": "This PathPlanning algorithm is an enhanced RRT*-inspired planner that adapts dynamically to the map size,\n    improves sampling quality and efficiency by biasing sampling towards the goal with some randomness,\n    incorporates informed rewiring with tightened radius computation for robust path smoothing,\n    and integrates early termination on success or after 60 seconds timeout.\n    It also applies limited shortcut smoothing post path extraction to improve final path smoothness and length.\n    The improvements focus on planning efficiency, path quality, robustness, and reduced search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(\n            self._services, start_vertex, goal_vertex, []\n        )\n\n        self._dimension = self._get_grid().size.n_dim\n        self._max_dist = max(self._get_grid().size.values) * 0.05 + 1  # scale max extension relative to map\n        self._lambda_rrt_star = 30.0  # tuning param for neighborhood radius\n        self._max_radius = max(self._get_grid().size.values) * 0.25 + 5  # cap for radius neighborhood\n        self._timeout_seconds = 60.0\n        self._goal_sample_rate = 0.2  # probability to sample goal directly\n        self._smooth_iterations = 20  # smoothing attempts post path extraction\n\n        self._init_displays()\n\n    # Helper functions #\n\n    def _get_random_sample(self) -> Point:\n        # Bias random sampling with goal_sample_rate towards the goal to improve goal reaching speed\n        import numpy as np\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_coords = [\n                    int(np.random.randint(0, self._get_grid().size[i])) for i in range(self._dimension)\n                ]\n                p = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(p):\n                    return p\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        from torch import norm\n\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_tensor = q_near.position.to_tensor() + dir_normalized * max_dist\n        return Vertex(Point.from_tensor(q_new_tensor))\n\n    def _collision_free(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Construct path from goal back to start\n        path: List[Vertex] = [Vertex(self._get_grid().goal.position)]\n        path[0].cost = q_new.cost + self._get_grid().get_distance(q_new.position, path[0].position)\n        self._graph.add_edge(q_new, path[0])\n\n        current = q_new\n        while current is not None and len(current.parents) > 0:\n            # pick one parent (ideally the one on shortest path)\n            for p in current.parents:\n                path.append(p)\n                current = p\n                break\n        if current is None or current.position != self._graph.root_vertex_start.position:\n            # no valid path found (should not occur if algorithm reached goal)\n            return\n\n        path.reverse()\n\n        # Apply shortcut smoothing to improve path length and smoothness\n        self._shortcut_smooth_path(path)\n\n        # Move agent along the path and keyframe\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_smooth_path(self, path: List[Vertex]) -> None:\n        # Attempt to shortcut edges in path by checking for direct collision-free segments\n        length = len(path)\n        import random\n        for _ in range(self._smooth_iterations):\n            if length < 3:\n                break\n            i = random.randint(0, length - 3)\n            j = random.randint(i + 2, length - 1)\n            p_i = path[i].position\n            p_j = path[j].position\n            if self._collision_free(p_i, p_j):\n                # Remove intermediate vertices between i and j\n                del path[i + 1 : j]\n\n                length = len(path)\n\n    # Main path planning loop #\n\n    def _find_path_internal(self) -> None:\n        import torch\n\n        start_time = time()\n        iter_limit = 15000  # cap on iterations - can be adjusted\n        iteration = 0\n\n        while iteration < iter_limit:\n            iteration += 1\n\n            if time() - start_time > self._timeout_seconds:\n                # Search failed due to timeout\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            if not self._collision_free(q_nearest.position, q_new.position):\n                continue\n\n            # Compute radius for neighbor search\n            card_v = torch.tensor(float(self._graph.size))\n            if card_v <= 1:\n                radius = self._max_radius\n            else:\n                log_card_v = torch.log(card_v)\n                radius = min(\n                    self._lambda_rrt_star\n                    * ((log_card_v / card_v) ** (1.0 / self._dimension)),\n                    self._max_radius,\n                )\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with minimum cost to new vertex\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._get_grid().get_distance(q_nearest.position, q_new.position)\n\n            for q_near in Q_near:\n                if self._collision_free(q_near.position, q_new.position):\n                    candidate_cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n                    if candidate_cost < c_min:\n                        q_min = q_near\n                        c_min = candidate_cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire nearby vertices to potentially improve their cost\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                if self._collision_free(q_new.position, q_near.position):\n                    candidate_cost = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n                    if candidate_cost < q_near.cost:\n                        # Remove old parent edge\n                        old_parents = list(q_near.parents)\n                        for old_parent in old_parents:\n                            self._graph.remove_edge(old_parent, q_near)\n\n                        q_near.cost = candidate_cost\n                        self._graph.add_edge(q_new, q_near)\n\n            # Early goal check: if new vertex is within goal radius, extract path\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm": "Improved path planning algorithm based on a tuned and optimized RRT* variant with adaptive sampling bias,\n    radius-based rewiring for path smoothing, and time-limited search. It balances exploration and exploitation \n    by sampling near the goal with an increasing probability and rewiring the tree locally to improve path quality. \n    The algorithm terminates success if the agent reaches the goal region or fails if the planning exceeds 60 seconds.\n    Key improvements:\n    - Adaptive sampling with goal bias to increase convergence speed\n    - Radius-based rewiring of nearby vertices to reduce path length and smoothness\n    - Tuned maximum extension distance based on map size\n    - Early failure termination after 60 seconds to improve robustness\n    - Uses cost metric and rewiring to improve path quality",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True  # allow edge removals for rewiring\n        self._init_displays()\n\n    def _get_distance(self, p1: Point, p2: Point) -> float:\n        return float((p1.to_tensor() - p2.to_tensor()).norm().item())\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction).item()\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n\n        direction_normalized = direction / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _get_random_sample(self, goal_sample_rate: float) -> Point:\n        \"\"\"\n        With probability goal_sample_rate, return goal position,\n        otherwise return a valid random sample in the map.\n        \"\"\"\n        if np.random.rand() < goal_sample_rate:\n            return self._get_grid().goal.position\n\n        while True:\n            # Sample uniformly within grid size bounds\n            rand_coords = [\n                np.random.uniform(0, dim_size) for dim_size in self._get_grid().size.values\n            ]\n            rand_coords_int = [int(math.floor(c)) for c in rand_coords]\n            sample = Point(*rand_coords_int)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_vertices_within_radius(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        result = []\n        for v in vertices:\n            if self._get_distance(v.position, point) < radius:\n                result.append(v)\n        return result\n\n    def _choose_best_parent(self, near_vertices: List[Vertex], new_vertex: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        Select the best parent vertex to connect to the new_vertex by minimizing cost.\n        Returns None if no valid parent found.\n        \"\"\"\n        best_parent = None\n        best_cost = math.inf\n        line_cache = None\n\n        for vertex in near_vertices:\n            # Check if line from vertex to new_vertex is valid\n            line = self._get_grid().get_line_sequence(vertex.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n\n            cost = (vertex.cost if vertex.cost is not None else 0) + self._get_grid().get_movement_cost(vertex.position, new_vertex.position)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = vertex\n                line_cache = line\n\n        if best_parent is not None:\n            new_vertex.cost = best_cost\n            self._graph.add_edge(best_parent, new_vertex)\n        else:\n            # No valid parent - treat cost as infinity. We'll discard this vertex later.\n            new_vertex.cost = math.inf\n\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], new_vertex: Vertex) -> None:\n        \"\"\"\n        Rewire the vertices in near_vertices to connect optimally through new_vertex.\n        \"\"\"\n        for vertex in near_vertices:\n            if vertex == new_vertex:\n                continue\n\n            line = self._get_grid().get_line_sequence(new_vertex.position, vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n\n            new_cost = (new_vertex.cost if new_vertex.cost is not None else 0) + self._get_grid().get_movement_cost(new_vertex.position, vertex.position)\n            if vertex.cost is None or new_cost < vertex.cost:\n                # Remove old edge(s) to vertex\n                parents_to_remove = list(vertex.parents)\n                for p in parents_to_remove:\n                    self._graph.remove_edge(p, vertex)\n                # Add new edge from new_vertex\n                self._graph.add_edge(new_vertex, vertex)\n                vertex.cost = new_cost\n\n    def _extract_path(self, end_vertex: Vertex) -> None:\n        path: List[Vertex] = [end_vertex]\n\n        while len(path[-1].parents) != 0:\n            # Select parent with minimum cost\n            min_parent = None\n            min_cost = math.inf\n            for parent in path[-1].parents:\n                if parent.cost is not None and parent.cost < min_cost:\n                    min_cost = parent.cost\n                    min_parent = parent\n            if min_parent is None:\n                break\n            path.append(min_parent)\n\n        path.reverse()\n\n        # Animate path tracing from start to goal\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n\n    def _find_path_internal(self) -> None:\n        max_time_sec = 60.0\n        start_time = time.time()\n\n        grid = self._get_grid()\n        max_dist = max(5.0, min(grid.size.width, grid.size.height) * 0.1)  # 10% of smaller map dimension, minimum 5 units\n        iterations = 20000\n\n        # Initialize root start vertex cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for i in range(iterations):\n\n            elapsed = time.time() - start_time\n            if elapsed > max_time_sec:\n                # Fail gracefully if timeout exceeded\n                break\n\n            # Increase goal bias progressively after 30% iterations\n            goal_bias = 0.05 + 0.90 * min(i / (iterations * 0.7), 1.0)\n\n            q_sample = self._get_random_sample(goal_bias)\n\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Build line sequence between neighbor and new\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute cost and choose best parent from nearby vertices\n            all_vertices = self._graph.root_vertices + list(self._graph.root_vertex_start.children)  # broad list for rewire & parent selection\n            radius = max_dist * 2.5  # neighborhood radius for rewiring\n            near_vertices = self._get_vertices_within_radius(all_vertices, q_new.position, radius)\n\n            parent = self._choose_best_parent(near_vertices + [q_near], q_new)\n            if parent is None or q_new.cost == math.inf:\n                continue  # no valid parent, discard q_new\n\n            # Add new vertex to root vertices for search\n            self._graph.root_vertices.append(q_new)\n\n            # Rewire the tree for better paths\n            near_vertices_for_rewire = self._get_vertices_within_radius(all_vertices, q_new.position, radius)\n            self._rewire(near_vertices_for_rewire, q_new)\n\n            # Check if agent reached goal radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex for path extraction\n                goal_vertex = Vertex(grid.goal.position, store_connectivity=True)\n                goal_vertex.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_vertex.position)\n                self._graph.add_edge(q_new, goal_vertex)\n                self._extract_path(goal_vertex)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This algorithm is a hybrid informed RRT* variant with adaptive sampling and smoothing.\n    It improves planning efficiency and path quality by guiding the search within an \n    ellipsoidal informed subset of the space (informed sampling), dynamically adjusting \n    the search radius based on vertex density, and applying iterative smoothing when \n    the goal is reached. It uses a best-first priority queue expansion to favor low-cost \n    vertices, combined with rewiring for optimality. A timeout of 60 seconds is enforced \n    with failure notification. This balances robustness, success rate, path smoothness, \n    search time, and path length improvements.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _max_radius: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_time_sec: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 12.0\n        self._max_radius = 30.0\n        self._lambda_rrt_star = 50.0\n        self._dimension = self._get_grid().size.n_dim\n        self._max_time_sec = 60.0  # maximum allowed time in seconds\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    def _get_random_sample_informed(self, c_best: Optional[float]) -> Point:\n        \"\"\"\n        Informed sampling inside an ellipsoid defined by start, goal, and current best cost.\n        If no path found yet (c_best is None), sample uniformly.\n        \"\"\"\n        agent_pos = self._get_grid().agent.position.to_tensor()\n        goal_pos = self._get_grid().goal.position.to_tensor()\n\n        if c_best is None:\n            # Uniform sampling until a valid sample is found\n            while True:\n                coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n                sample = Point(*coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Informed sampling inside ellipsoid\n            c_min = torch.norm(goal_pos - agent_pos)\n            if c_best < c_min:\n                # rare case, fall back to uniform sampling\n                return self._get_random_sample_uniform()\n\n            # Center of ellipse\n            center = (agent_pos + goal_pos) / 2.0\n            a1 = (goal_pos - agent_pos) / c_min  # unit vector from start to goal\n\n            # Create orthonormal basis via SVD\n            U, _, _ = torch.svd(torch.eye(self._dimension) - a1.unsqueeze(1) @ a1.unsqueeze(0), some=True)\n            C = torch.cat([a1.unsqueeze(1), U[:, 1:].contiguous()], dim=1)\n\n            # Radius in each dimension\n            r1 = c_best / 2.0\n            r2 = torch.sqrt(c_best**2 - c_min**2) / 2.0\n\n            radii = torch.ones(self._dimension)\n            radii[0] = r1\n            radii[1:] = r2\n\n            for _ in range(1000):  # max attempts for valid sample\n                # Sample inside unit ball\n                direction = torch.randn(self._dimension)\n                direction /= torch.norm(direction)\n                radius = torch.rand(1).item() ** (1 / self._dimension)\n                rnd_ball = direction * radius\n\n                # Transform to ellipsoid space\n                sample_tensor = center + (C @ (radii * rnd_ball))\n\n                sample_point = Point(*[int(torch.clamp(x, 0, self._get_grid().size[i] - 1).item()) for i, x in enumerate(sample_tensor)])\n                if self._get_grid().is_agent_valid_pos(sample_point):\n                    return sample_point\n\n            # fallback uniform sample if fails\n            return self._get_random_sample_uniform()\n\n    def _get_random_sample_uniform(self) -> Point:\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        dir_vector = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vector)\n        if dist == 0:\n            return None  # Same position\n\n        if dist <= max_dist:\n            p = q_sample\n        else:\n            dir_norm = dir_vector / dist\n            new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_norm\n            coords = [int(torch.clamp(c, 0, self._get_grid().size[i] - 1).item()) for i, c in enumerate(new_pos_tensor)]\n            p = Point(*coords)\n\n        if not self._get_grid().is_agent_valid_pos(p):\n            return None\n\n        # Check path collision between q_near and p\n        line_seq = self._get_grid().get_line_sequence(q_near.position, p)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        return Vertex(p)\n\n    def _extract_path(self, last_vertex: Vertex):\n        # Reconstruct path from last_vertex to root\n        path = [last_vertex]\n        current = last_vertex\n        while current != self._graph.root_vertex_start and current.parents:\n            # Choose parent with lowest cost\n            current = min(current.parents, key=lambda v: v.cost if v.cost is not None else float('inf'))\n            path.append(current)\n        path.reverse()\n\n        # Smoothed path by shortcutting\n        smooth_path = self._short_cut_path(path)\n\n        for vertex in smooth_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _short_cut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Attempt to shortcut path segments to improve smoothness.\n        \"\"\"\n        if len(path) <= 2:\n            return path\n\n        new_path = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path\n\n    def _rewire(self, q_new: Vertex, Q_near: List[Vertex]) -> None:\n        for q_near in Q_near:\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cost_through_new = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            if q_near.cost is None or cost_through_new < q_near.cost:\n                # Remove old parent edge\n                for parent in q_near.parents:\n                    self._graph.remove_edge(parent, q_near)\n                # Add new parent edge\n                q_near.cost = cost_through_new\n                self._graph.add_edge(q_new, q_near)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        c_best = None  # best path cost found so far\n        best_last_vertex = None\n\n        priority_queue: List[Tuple[float, Vertex]] = []\n        heapq.heappush(priority_queue, (self._graph.root_vertex_start.cost, self._graph.root_vertex_start))\n\n        max_iterations = 15000\n        while time.time() - start_time < self._max_time_sec and max_iterations > 0:\n\n            max_iterations -= 1\n\n            # Sample informed or uniform depending on whether a path was found\n            q_sample = self._get_random_sample_informed(c_best)\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            if q_new is None:\n                continue\n\n            # Find neighbors within a radius adaptively\n            card_v = torch.tensor(float(self._graph.size + 1))\n            log_card = torch.log(card_v)\n            radius = min(self._lambda_rrt_star * torch.pow(log_card / card_v, 1 / self._dimension), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent that minimizes cost to q_new\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost_through_near = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if cost_through_near < c_min:\n                    q_min = q_near\n                    c_min = cost_through_near\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if it reduces cost\n            self._rewire(q_new, Q_near)\n\n            # Add q_new to priority queue for best-first expansion\n            heapq.heappush(priority_queue, (q_new.cost, q_new))\n\n            # Check goal proximity\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                if c_best is None or q_new.cost + torch.norm(q_new.position.to_tensor() - self._get_grid().goal.position.to_tensor()) < c_best:\n                    # Update best solution\n                    c_best = q_new.cost + torch.norm(q_new.position.to_tensor() - self._get_grid().goal.position.to_tensor())\n                    best_last_vertex = q_new\n\n            self.key_frame()\n\n        if best_last_vertex is not None:\n            self._extract_path(best_last_vertex)\n        else:\n            # No path found within time limit\n            # Optionally mark failure or halt gracefully here\n            # We do not move the agent\n            return",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm": "Hybrid Path Planning Algorithm combining RRT-Connect with Informed RRT* optimization and adaptive rewiring for improved path quality,\n    efficiency, and smoothness. The algorithm grows two trees from start and goal sampling biased regions, attempts to connect them efficiently,\n    and rewires vertices within dynamic radius. It uses adaptive sampling within elliptical informed subsets to reduce search space once initial path found,\n    incorporates collision checking with Bresenham's line, and terminates if no solution is found within 60 seconds to enhance robustness and reduce search time.\n    The extracted path is smoothed further for path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_dist: float\n    _iterations: int\n    _rewire_radius_const: float\n\n    def __init__(self, services: \"Services\", testing: \"BasicTesting\" = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._max_dist = 15.0\n        self._iterations = 15000\n        # Rewiring radius factor (heuristic)\n        self._rewire_radius_const = 50.0\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_random_sample(self, informed_subset: Optional[Tuple[Point, float, float]] = None) -> Point:\n        \"\"\"\n        Returns a random sample Point in the environment.\n        When informed_subset is given (center, c_best, c_min), sample inside an ellipse for focused search.\n        Else uniform random sampling within map boundaries.\n        \"\"\"\n        size = self._get_grid().size\n\n        if informed_subset is None:\n            # Uniform random valid sample\n            for _ in range(100):\n                rand_pos = np.random.uniform(low=0, high=[size.width, size.height], size=(size.n_dim,))\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n            # fallback uniform discrete\n            while True:\n                rand_pos = np.random.randint(0, size.values, size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            center, c_best, c_min = informed_subset\n            # Sampling inside ellipse in 2D only - ellipse parameters and rotation matrix aligned along start-goal line\n            start = self._graph.root_vertex_start.position.to_tensor()\n            goal = self._graph.root_vertex_goal.position.to_tensor()\n            dim = size.n_dim\n            if dim < 2:\n                # fallback uniform\n                return self._get_random_sample(None)\n\n            # Create a coordinate system aligned with the vector from start to goal\n            diff = goal - start\n            dist = torch.norm(diff).item()\n            if dist == 0:\n                dist = 1e-6\n\n            a1 = diff / dist  # unit vector along major axis\n\n            # Generate random sample inside unit ball in 2D\n            while True:\n                # Sample uniformly in unit circle with rejection sampling\n                sample_in_unit_circle = np.random.uniform(-1, 1, 2)\n                if sample_in_unit_circle[0]**2 + sample_in_unit_circle[1]**2 <= 1:\n                    break\n            u1, u2 = sample_in_unit_circle\n\n            # Lengths of ellipse axes\n            r1 = c_best / 2.0  # Major axis radius\n            r2 = math.sqrt(c_best**2 - c_min**2) / 2.0  # Minor axis radius\n\n            # Rotate sample to global coordinates\n            # The ellipse is aligned such that major axis aligns with a1 (along start-goal)\n            # Build orthonormal basis [a1, a2]\n            a2 = torch.zeros(dim)\n            # Generate an arbitrary vector orthogonal to a1 in 2D\n            if dim == 2:\n                a2[0] = -a1[1]\n                a2[1] = a1[0]\n            else:  # For 3D+, approximation (not very accurate but better than nothing)\n                a2[0] = -a1[1]\n                a2[1] = a1[0]\n                if dim > 2:\n                    a2[2:] = 0\n\n            sample_vec = r1 * u1 * a1 + r2 * u2 * a2\n            sample_point_tensor = center.to_tensor() + sample_vec\n\n            sample_point = Point.from_tensor(sample_point_tensor)\n\n            # Clamp sample inside map bounds and check validity\n            clamped_coords = []\n            for idx, coord in enumerate(sample_point.values):\n                val = max(0, min(coord, size.values[idx] - 1))\n                clamped_coords.append(val)\n            sample_point = Point(*clamped_coords)\n\n            # Validate and fallback if invalid\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n            # If failed, fallback to uniform sample\n            return self._get_random_sample(None)\n\n    def _get_nearest_vertex(self, root_vertices: List[Vertex], point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(root_vertices, point)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n\n        dir_normalized = dir / norm_dir\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos, store_connectivity=True)\n\n    def _get_vertices_within_radius(self, root_vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(root_vertices, point, radius)\n\n    def _calculate_rewire_radius(self) -> float:\n        # Calculate rewiring radius as heuristic based on environment size and nodes count\n        size = self._get_grid().size\n        n = max(1, self._graph.size)\n        volume = size.width * size.height  # approx for 2D\n        r = min(self._max_dist, self._rewire_radius_const * math.sqrt((math.log(n) / n)))\n        r = max(r, 5.0)\n        return r\n\n    def _collision_free(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _cost(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        return self._get_grid().get_distance(from_vertex.position, to_vertex.position)\n\n    def _choose_parent(self, new_vertex: Vertex, neighbors: List[Vertex]) -> Optional[Vertex]:\n        # Choose best parent in terms of cost + cost-to-new_vertex\n        min_cost = math.inf\n        best_parent = None\n        for neighbor in neighbors:\n            if self._collision_free(neighbor.position, new_vertex.position):\n                tentative_cost = neighbor.cost if neighbor.cost is not None else 0\n                tentative_cost += self._cost(neighbor, new_vertex)\n                if tentative_cost < min_cost:\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n        if best_parent:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, neighbors: List[Vertex]) -> None:\n        new_cost = new_vertex.cost if new_vertex.cost is not None else 0\n        for neighbor in neighbors:\n            if neighbor is new_vertex:\n                continue\n            if self._collision_free(new_vertex.position, neighbor.position):\n                cost_through_new = new_cost + self._cost(new_vertex, neighbor)\n                if neighbor.cost is None or cost_through_new < neighbor.cost:\n                    # Rewire: remove old parent edges, add new edge\n                    # Remove previous parent edges\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(new_vertex, neighbor)\n                    neighbor.cost = cost_through_new\n\n    def _extract_path(self, connecting_vertex: Vertex) -> None:\n        # Trace back path from connecting_vertex to start and to goal\n        path_start = []\n        v = connecting_vertex\n        while v is not None:\n            path_start.append(v)\n            if len(v.parents) == 0:\n                break\n            v = next(iter(v.parents))  # one parent (tree structure)\n\n        path_goal = []\n        # goal root vertex\n        goal_vertex = self._graph.root_vertex_goal\n        # We find path from connecting_vertex to goal by DFS or backwards\n        # Walk from goal root downwards to connecting_vertex:\n        # As graph is cyclic, to find goal path we do upwards from goal root\n        # Instead traverse parents from goal root to connecting_vertex via children recursively\n\n        # We find the path from goal to connecting_vertex backwards (via DFS)\n        # Because in cyclic graph children and parents exist, but we enforce edges start->child as direction\n\n        def dfs_find_path(current: Vertex, target: Vertex, visited: Set[Vertex]) -> Optional[List[Vertex]]:\n            if current == target:\n                return [current]\n            visited.add(current)\n            for child in current.children:\n                if child in visited:\n                    continue\n                sub_path = dfs_find_path(child, target, visited)\n                if sub_path:\n                    return [current] + sub_path\n            return None\n\n        path_goal = dfs_find_path(goal_vertex, connecting_vertex, set()) or []\n\n        # Combine paths (path_start reversed is from start to connecting_vertex)\n        path_start.reverse()\n        if len(path_goal) > 0 and path_goal[0] == connecting_vertex:\n            path_goal = path_goal[1:]  # avoid duplicate vertex\n\n        full_path = path_start + path_goal\n\n        # Smooth the path to improve quality\n        smooth_path = self._smooth_path([v.position for v in full_path])\n\n        for pos in smooth_path:\n            self.move_agent(pos)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _smooth_path(self, path_points: List[Point]) -> List[Point]:\n        # Simple path smoothing by shortcutting over unnecessary vertices if collision free\n        if len(path_points) < 3:\n            return path_points\n\n        smooth_path = [path_points[0]]\n        i = 0\n        while i < len(path_points) - 1:\n            j = len(path_points) - 1\n            while j > i + 1:\n                if self._collision_free(path_points[i], path_points[j]):\n                    smooth_path.append(path_points[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # no shortcut found, advance by one\n                smooth_path.append(path_points[i + 1])\n                i += 1\n        return smooth_path\n\n    # Main Algorithm Loop #\n    # --------------------#\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        # Initialization\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        trees = [start_vertex, goal_vertex]  # root vertices for two trees\n        # Two vertex sets for easy access\n        start_tree_vertices = [start_vertex]\n        goal_tree_vertices = [goal_vertex]\n\n        path_found = False\n        best_path_cost = math.inf\n        best_connecting_vertex = None\n\n        # Constants\n        c_min = self._get_grid().get_distance(start_vertex.position, goal_vertex.position)\n        c_best = math.inf\n\n        for iter_idx in range(self._iterations):\n\n            if time.time() - start_time > 60:  # timeout 60 seconds\n                # Fail gracefully\n                break\n\n            # Determine if informed sampling is possible (after path found)\n            informed_subset = None\n            if path_found and best_connecting_vertex is not None and best_path_cost < math.inf:\n                center = Point(*np.array(start_vertex.position.values) + np.array(goal_vertex.position.values)) / 2\n                informed_subset = (center, best_path_cost, c_min)\n\n            # Sample randomly using informed sampling if available\n            q_rand = self._get_random_sample(informed_subset)\n\n            # Alternate tree to extend: 0 or 1\n            tree_idx = iter_idx % 2\n            curr_tree_root = trees[tree_idx]\n            other_tree_root = trees[1 - tree_idx]\n\n            # Extend current tree towards q_rand\n            q_near = self._get_nearest_vertex([curr_tree_root], q_rand)\n            q_new = self._get_new_vertex(q_near, q_rand, self._max_dist)\n\n            # Check collision along edge q_near->q_new\n            if not self._collision_free(q_near.position, q_new.position):\n                self.key_frame()\n                continue\n\n            # Get neighbors for rewiring (both trees)\n            neighbors_radius = self._calculate_rewire_radius()\n            neighbors = self._get_vertices_within_radius([curr_tree_root], q_new.position, neighbors_radius)\n\n            # Choose parent among neighbors\n            best_parent = self._choose_parent(q_new, neighbors)\n            if best_parent is None:\n                # No valid parent found, discard q_new\n                self.key_frame()\n                continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors for better path\n            self._rewire(q_new, neighbors)\n\n            # Add q_new to proper tree vertices list\n            if tree_idx == 0:\n                start_tree_vertices.append(q_new)\n            else:\n                goal_tree_vertices.append(q_new)\n\n            # Try to connect other_tree to q_new by extending towards it\n            q_near_other = self._get_nearest_vertex([other_tree_root], q_new.position)\n            q_new_other = self._get_new_vertex(q_near_other, q_new.position, self._max_dist)\n\n            if self._collision_free(q_near_other.position, q_new_other.position):\n                self._graph.add_edge(q_near_other, q_new_other)\n\n                # Check if connection possible between q_new and q_new_other\n                if self._collision_free(q_new.position, q_new_other.position):\n                    # Connect q_new with q_new_other and form path\n                    self._graph.add_edge(q_new, q_new_other)\n\n                    # Compute path cost for potential solution\n                    total_cost = (q_new.cost if q_new.cost else 0) + \\\n                                 self._get_grid().get_distance(q_new.position, q_new_other.position) + \\\n                                 (q_new_other.cost if q_new_other.cost else 0)\n\n                    if total_cost < best_path_cost:\n                        best_path_cost = total_cost\n                        best_connecting_vertex = q_new\n\n                    path_found = True\n                    # Once connected, break early: extract path\n                    self._extract_path(best_connecting_vertex)\n                    break\n\n            self.key_frame()\n\n        if not path_found:\n            # Mark failure as required (no path found)\n            # If desired, could raise an exception or signal failure here.\n            return",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm": "Improved sampling-based path planning algorithm that combines adaptive sampling \n    focusing near the goal with an anytime rewiring strategy inspired by RRT*.\n\n    Key features:\n    - Adaptive goal-bias sampling with dynamically adjusted radius to focus exploration efficiently.\n    - Anytime rewiring of the graph within a shrinking radius improving path quality progressively.\n    - Early pruning of costly connections based on incremental cost evaluation.\n    - Integration of time limit (60 sec) to abort search if no solution found.\n    - Uses cyclic graph structure enabling better edge manipulations and path smoothness.\n    - Balances exploration and exploitation dynamically based on iteration and search status.\n\n    The method aims for improved planning efficiency, path quality, robustness, and reduced search times.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: \"CyclicGraph\"\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n        start_v = Vertex(start_pos)\n        start_v.cost = 0\n        goal_v = Vertex(goal_pos)\n        self._graph = gen_cyclic_graph(self._services, start_v, goal_v, [])\n        self._init_displays()\n\n    def _get_random_sample(self, goal_bias=0.15, goal_sample_radius=15.0) -> Point:\n        \"\"\"Sample with bias: mostly uniform random, sometimes near goal within a radius.\"\"\"\n\n        grid = self._get_grid()\n        # Bias towards sampling near the goal position\n        if np.random.random() < goal_bias:\n            attempts = 0\n            while True:\n                # Sample in a circle around the goal (for 2D)\n                angle = np.random.uniform(0, 2 * np.pi)\n                radius = np.random.uniform(0, goal_sample_radius)\n                dx = radius * math.cos(angle)\n                dy = radius * math.sin(angle)\n                gp = grid.goal.position\n                candidate = Point(int(gp.x + dx), int(gp.y + dy))\n                attempts += 1\n                if grid.is_agent_valid_pos(candidate):\n                    return candidate\n                if attempts > 100:  # fallback to global random sampling\n                    break\n\n        # Uniform random sample in the entire map size\n        max_dims = grid.size.values\n        while True:\n            rand_pos = np.random.randint(0, max_dims, len(max_dims))\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_v: Vertex, to_p: Point, max_dist: float) -> Vertex:\n        \"\"\"Return a new vertex in the direction from from_v to to_p with max step length max_dist.\"\"\"\n        dir_vec = to_p.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(to_p)\n        dir_norm = dir_vec / dist\n        new_pos_tensor = from_v.position.to_tensor() + dir_norm * max_dist\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _get_nearest_vertex(self, point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, point)\n\n    def _get_nearby_vertices(self, vertex: Vertex, radius: float) -> list[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _cost(self, from_v: Vertex, to_v: Vertex) -> float:\n        return from_v.cost + self._get_grid().get_distance(from_v.position, to_v.position)\n\n    def _extract_path(self, last_vertex: Vertex) -> None:\n        # Goal vertex that references last vertex\n        goal_v = Vertex(self._get_grid().goal.position)\n        child_parent_dist = self._get_grid().get_distance(last_vertex.position, goal_v.position)\n        goal_v.cost = last_vertex.cost + child_parent_dist\n        self._graph.add_edge(last_vertex, goal_v)\n        path = [goal_v]\n\n        while path[-1].parents:\n            for p in path[-1].parents:\n                path.append(p)\n                break\n\n        path.pop()  # remove the root with no parents\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n\n        max_dist = 10.0\n        max_iter = 10000\n        dimension = grid.size.n_dim\n        max_time_sec = 60\n\n        start_time = time.time()\n\n        # Constants for radius calculation (RRT* inspired)\n        gamma_rrt_star = 50.0\n        goal_sample_radius = max(15.0, max_dist * 2)\n\n        # Initialize the start vertex cost (done in __init__)\n\n        for iter_count in range(max_iter):\n\n            if time.time() - start_time > max_time_sec:\n                # Treat search as failed after 60seconds\n                break\n\n            # Adaptive decreasing goal bias and radius for goal sampling\n            elapsed_ratio = iter_count / max_iter\n            goal_bias = max(0.1, 0.3 * (1.0 - elapsed_ratio))\n            adaptive_goal_radius = max(goal_sample_radius * (1.0 - elapsed_ratio), max_dist)\n\n            q_sample = self._get_random_sample(goal_bias=goal_bias, goal_sample_radius=adaptive_goal_radius)\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._steer(q_nearest, q_sample, max_dist)\n\n            # Check path between nearest and new is valid\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Radius for neighbors for rewiring, shrinking as tree grows\n            card_V = max(1, float(self._graph.size))\n            radius = min(\n                gamma_rrt_star * ((math.log(card_V) / card_V) ** (1 / dimension)),\n                max_dist * 3,\n            )\n\n            nearby_vertices = self._get_nearby_vertices(q_new, radius)\n\n            # Choose parent that minimizes cost and is collision free\n            q_min = q_nearest\n            c_min = self._cost(q_nearest, q_new)\n\n            for near_v in nearby_vertices:\n                # Edge collision check\n                if grid.is_valid_line_sequence(grid.get_line_sequence(near_v.position, q_new.position)):\n                    cost_through_near = self._cost(near_v, q_new)\n                    if cost_through_near < c_min:\n                        q_min = near_v\n                        c_min = cost_through_near\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if a cheaper path via q_new is found\n            for near_v in nearby_vertices:\n                if near_v == q_min:\n                    continue\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, near_v.position)):\n                    cost_via_new = q_new.cost + grid.get_distance(q_new.position, near_v.position)\n                    if cost_via_new < near_v.cost:\n                        # Remove old parent edge (assumption: one parent per vertex in this graph)\n                        old_parent = None\n                        for p in near_v.parents:\n                            old_parent = p\n                            break\n                        if old_parent:\n                            self._graph.remove_edge(old_parent, near_v)\n                        near_v.cost = None\n                        near_v.cost = cost_via_new\n                        self._graph.add_edge(q_new, near_v)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm": "Improved bidirectional RRT* inspired algorithm combining adaptive sampling,\n    informed radius rewiring, and goal biasing for faster convergence and better path quality.\n    Features:\n    - Bidirectional growth from start and goal for efficiency and robustness.\n    - Adaptive connection radius based on graph size and dimension for optimal rewiring.\n    - Goal biasing to guide sampling towards the goal region without sacrificing exploration.\n    - Max step size adaptively tuned to map size for smoother incremental expansion.\n    - Time limit (60s) to terminate early on failure.\n    - Post-path extraction smoothing by shortcutting feasible line segments to reduce path length.\n    This approach produces shorter, smoother paths, improves success rate in cluttered maps,\n    and balances exploration vs exploitation to reduce search time while maintaining robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: \"CyclicGraph\"\n    _max_dist: float\n    _iterations: int\n    _goal_sample_rate: float  # probability to sample goal to bias tree growth\n    _time_start: float\n    _time_limit: float = 60.0  # seconds\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        # Using a cyclic graph for flexible rewiring in both directions\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n\n        # Adaptive max step based on map diagonal length\n        diagonal = float(np.linalg.norm(np.array(self._get_grid().size.values)))\n        self._max_dist = max(5.0, diagonal * 0.05)  # 5 or 5% of diagonal\n\n        self._iterations = 12000\n        self._goal_sample_rate = 0.15  # 15% chance to sample goal directly\n\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # With goal biasing\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, roots: List[Vertex], q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(roots, q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_norm = dir_vec / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + dir_norm * max_dist)\n        return Vertex(new_pos)\n\n    def _get_vertices_within_radius(self, root_vertices: List[Vertex], q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(root_vertices, q_new.position, radius)\n\n    def _reconnect(self, q_new: Vertex, Q_near: List[Vertex], roots: List[Vertex]) -> None:\n        \"\"\"Rewire tree edges to improve path costs with collision check.\"\"\"\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n            cost_through_new = q_new.cost + dist\n            if cost_through_new >= q_near.cost:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Remove old edge\n            parent_to_remove = None\n            for p in q_near.parents:\n                parent_to_remove = p\n                break\n            if parent_to_remove is not None:\n                self._graph.remove_edge(parent_to_remove, q_near)\n\n            # Add new edge and update cost\n            q_near.cost = cost_through_new\n            self._graph.add_edge(q_new, q_near)\n\n            # Propagate cost changes downstream\n            self._propagate_cost(q_near, roots)\n\n    def _propagate_cost(self, vertex: Vertex, roots: List[Vertex]) -> None:\n        \"\"\"Update cost values recursively for descendants.\"\"\"\n        for child in vertex.children:\n            parent_cost = vertex.cost if vertex.cost is not None else float('inf')\n            dist = torch.norm(vertex.position.to_tensor() - child.position.to_tensor())\n            new_cost = parent_cost + dist\n            if child.cost is None or new_cost < child.cost:\n                child.cost = new_cost\n                self._propagate_cost(child, roots)\n\n    def _extract_path(self, q_meet: Vertex) -> None:\n        \"\"\"Extract path from start to goal through q_meet and then smooth it.\"\"\"\n        start_root = [self._graph.root_vertex_start]\n        goal_root = [self._graph.root_vertex_goal]\n\n        # Trace path start -> q_meet\n        path_start = []\n        v = q_meet\n        while True:\n            path_start.append(v)\n            if v in start_root:\n                break\n            if not v.parents:\n                break\n            # Pick parent with min cost (could be multiple parents)\n            v = min(v.parents, key=lambda x: x.cost if x.cost is not None else float('inf'))\n        path_start.reverse()\n\n        # Trace path q_meet -> goal\n        path_goal = []\n        v = q_meet\n        while True:\n            path_goal.append(v)\n            if v in goal_root:\n                break\n            if not v.children:\n                break\n            v = min(v.children, key=lambda x: x.cost if x.cost is not None else float('inf'))\n\n        full_path = path_start + path_goal[1:]\n\n        # Positions only\n        raw_points = [v.position for v in full_path]\n\n        # Smooth path by trying to shortcut segments directly if collision-free\n        smoothed_points = self._short_cut_path(raw_points)\n\n        for pos in smoothed_points:\n            self.move_agent(pos)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _short_cut_path(self, path_points: List[Point]) -> List[Point]:\n        \"\"\"Attempt to smooth path by shortcutting via valid direct lines.\"\"\"\n        if len(path_points) <= 2:\n            return path_points\n        smoothed = [path_points[0]]\n        i = 0\n        while i < len(path_points) - 1:\n            j = len(path_points) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path_points[i], path_points[j])\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed.append(path_points[j])\n            i = j\n        return smoothed\n\n    def _find_path_internal(self) -> None:\n        dimension = self._get_grid().size.n_dim\n        max_radius = max(self._get_grid().size.width, self._get_grid().size.height) * 0.2\n        lambda_rrt_star = 30.0\n\n        self._time_start = time.perf_counter()\n\n        # Roots for both trees\n        roots_start = [self._graph.root_vertex_start]\n        roots_goal = [self._graph.root_vertex_goal]\n\n        for i in range(self._iterations):\n\n            # Time limit check\n            if time.perf_counter() - self._time_start > self._time_limit:\n                # Failed due to timeout\n                break\n\n            # Alternate between growing start and goal trees\n            if i % 2 == 0:\n                tree_roots = roots_start\n                other_roots = roots_goal\n            else:\n                tree_roots = roots_goal\n                other_roots = roots_start\n\n            q_rand = self._get_random_sample()\n            q_near = self._get_nearest_vertex(tree_roots, q_rand)\n            if q_near.position == q_rand:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_rand, self._max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute adaptive radius\n            card_v = torch.tensor(float(self._graph.size))\n            if card_v <= 1:\n                radius = max_radius\n            else:\n                radius = min(lambda_rrt_star * ((torch.log(card_v) / card_v) ** (1 / dimension)), max_radius)\n\n            # Find neighbors within radius\n            Q_near = self._get_vertices_within_radius(tree_roots, q_new, radius)\n\n            # Choose parent with min cost + dist and valid path\n            q_min = q_near\n            c_min = (q_near.cost if q_near.cost is not None else float('inf')) + torch.norm(\n                q_near.position.to_tensor() - q_new.position.to_tensor())\n            for q_near_cand in Q_near:\n                dist_to_new = torch.norm(q_near_cand.position.to_tensor() - q_new.position.to_tensor())\n                cost_cand = (q_near_cand.cost if q_near_cand.cost is not None else float('inf')) + dist_to_new\n                if cost_cand < c_min:\n                    line_seq_cand = self._get_grid().get_line_sequence(q_near_cand.position, q_new.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq_cand):\n                        q_min = q_near_cand\n                        c_min = cost_cand\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors where cost can be improved via q_new\n            self._reconnect(q_new, Q_near, tree_roots)\n\n            # Try to connect the other tree to this new vertex\n            q_new_other_near = self._get_nearest_vertex(other_roots, q_new.position)\n            while True:\n                q_new_other = self._get_new_vertex(q_new_other_near, q_new.position, self._max_dist)\n                line_seq_other = self._get_grid().get_line_sequence(q_new_other_near.position, q_new_other.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_other):\n                    break\n                self._graph.add_edge(q_new_other_near, q_new_other)\n                q_new_other.cost = (q_new_other_near.cost if q_new_other_near.cost is not None else 0) + \\\n                                   torch.norm(q_new_other.position.to_tensor() - q_new_other_near.position.to_tensor())\n                if q_new_other.position == q_new.position:\n                    # Trees connected, path found\n                    self._extract_path(q_new)\n                    return\n                q_new_other_near = q_new_other\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm": "An improved sample-based path planning algorithm combining advantages of RRT* and SPRM:\n    - Uses adaptive sampling biased towards unexplored and goal regions.\n    - Employs incremental connection radius adjustment for efficient graph construction.\n    - Uses a cyclic graph to allow multiple paths and rewiring for path smoothing.\n    - Utilizes a heuristic guided nearest neighbor selection to improve planning efficiency.\n    - Continuously checks for goal reachability and extracts path early.\n    - Limits search duration to 60 seconds for robustness against infinite loops.\n    - Post-processes the found path for smoothing using shortcutting heuristics.\n    - Aimed to improve path quality, reduce search time, increase success rate and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_vertices: int\n    _max_radius: float\n    _max_dist: float\n    _timeout_seconds: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_vertices = 500\n        self._max_radius = 20.0\n        self._max_dist = 10.0\n        self._timeout_seconds = 60.0\n        initial_agent_v = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        initial_agent_v.cost = 0.0\n        initial_goal_v = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        initial_goal_v.cost = float('inf')\n        vertices = [initial_agent_v]\n        # Start with initial vertex only; vertices will be added dynamically\n        self._graph = gen_cyclic_graph(self._services, initial_agent_v, initial_goal_v, vertices)\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\" Sample points mostly avoiding obstacles and biased toward goal region 10% \"\"\"\n        grid = self._get_grid()\n        size_vals = grid.size.values\n        goal_pos = grid.goal.position\n        # 10% samples directly on/near goal, 90% uniform random in map\n        if np.random.rand() < 0.1:\n            # Gaussian sampling near goal within radius 5, clipped inside map\n            goal_radius = 5\n            coords = []\n            for i, dim_len in enumerate(size_vals):\n                val = int(np.clip(\n                    np.random.normal(loc=goal_pos[i], scale=goal_radius), 0, dim_len - 1\n                ))\n                coords.append(val)\n            sample = Point(*coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n        # Uniform sampling in free space until valid\n        while True:\n            coords = [np.random.randint(0, dim_len) for dim_len in size_vals]\n            sample = Point(*coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _heuristic_nearest(self, candidates: List[Vertex], sample: Point) -> Optional[Vertex]:\n        \"\"\"Return nearest vertex to sample biased by cost + distance heuristic.\"\"\"\n        if not candidates:\n            return None\n        s_tensor = sample.to_tensor()\n        min_score = float('inf')\n        best_vertex = None\n        for v in candidates:\n            dist = torch.norm(v.position.to_tensor() - s_tensor).item()\n            score = v.cost + dist  # Combined cost-to-come + heuristic distance\n            if score < min_score:\n                min_score = score\n                best_vertex = v\n        return best_vertex\n\n    def _new_vertex_from_direction(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec).item()\n        if norm <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        dir_normalized = dir_vec / norm\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _vertices_within_radius(self, center: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, center, radius)\n\n    def _connect_vertices(self, v_from: Vertex, v_to: Vertex) -> bool:\n        \"\"\"Try connecting two vertices if path valid and update costs, return success.\"\"\"\n        grid = self._get_grid()\n        if v_from.position == v_to.position:\n            return False\n        line = grid.get_line_sequence(v_from.position, v_to.position)\n        if not grid.is_valid_line_sequence(line):\n            return False\n\n        dist = torch.norm(v_from.position.to_tensor() - v_to.position.to_tensor()).item()\n        new_cost = v_from.cost + dist\n\n        # Connect v_from -> v_to if better cost found or no parents (v_to.cost initialization might be inf)\n        if v_to.cost is None or new_cost < v_to.cost:\n            # Remove old edges to v_to\n            for parent in list(v_to.parents):\n                self._graph.remove_edge(parent, v_to)\n            # Add new edge\n            self._graph.add_edge(v_from, v_to)\n            # Update cost recursively downstream\n            self._update_descendants_cost(v_to)\n            return True\n        return False\n\n    def _update_descendants_cost(self, vertex: Vertex) -> None:\n        \"\"\"Recursively update costs of vertex descendants.\"\"\"\n        queue = [vertex]\n        while queue:\n            current = queue.pop()\n            for child in current.children:\n                dist = torch.norm(current.position.to_tensor() - child.position.to_tensor()).item()\n                updated_cost = current.cost + dist\n                if child.cost is None or updated_cost < child.cost:\n                    child.cost = updated_cost\n                    queue.append(child)\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        \"\"\"Extract best path from start to goal vertex and move agent along it.\"\"\"\n        # Backtrack parents to start\n        path_vertices = []\n        current = goal_vertex\n        while current.parents:\n            path_vertices.append(current)\n            # Choose parent with minimum cost\n            parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            current = parent\n            if current == self._graph.root_vertex_start:\n                path_vertices.append(current)\n                break\n        path_vertices.reverse()\n\n        # Post-process path smoothing by shortcutting\n        smoothed_path = self._shortcut_path(path_vertices)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path_vertices: List[Vertex]) -> List[Vertex]:\n        \"\"\"Shortcut path by checking direct connections between non-consecutive vertices.\"\"\"\n        if len(path_vertices) < 3:\n            return path_vertices\n        grid = self._get_grid()\n        smoothed_path = [path_vertices[0]]\n        idx = 0\n        while idx < len(path_vertices) - 1:\n            # Try to find farthest reachable vertex ahead (greedy shortcut)\n            far_idx = len(path_vertices) - 1\n            while far_idx > idx + 1:\n                line = grid.get_line_sequence(path_vertices[idx].position, path_vertices[far_idx].position)\n                if grid.is_valid_line_sequence(line):\n                    break\n                far_idx -= 1\n            smoothed_path.append(path_vertices[far_idx])\n            idx = far_idx\n        return smoothed_path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        goal_vertex = self._graph.root_vertex_goal\n        goal_reached = False\n\n        # Dynamic vertex list for graph growth\n        vertex_list = [start_vertex]\n        self._graph.root_vertices = vertex_list + [goal_vertex]\n\n        iteration = 0\n        while iteration < self._max_vertices:\n            iteration += 1\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout_seconds:\n                # FAIL path search due to timeout\n                return\n\n            q_sample = self._get_random_sample()\n            # Select nearest vertex biased by cost and heuristic\n            q_near = self._heuristic_nearest(vertex_list, q_sample)\n            if q_near is None or q_near.position == q_sample:\n                continue\n\n            q_new = self._new_vertex_from_direction(q_near, q_sample, self._max_dist)\n            # Check path from q_near to q_new\n            line = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line):\n                continue\n\n            # Prepare q_new cost estimate: tentative cost from q_near + dist\n            dist_near_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = q_near.cost + dist_near_new\n\n            # Find neighborhood radius adapting to n^(1/d) * some constant (RRT* inspired)\n            n = len(vertex_list) + 1\n            d = grid.size.n_dim\n            gamma = self._max_radius\n            radius = min(gamma * ((np.log(n) / n) ** (1/d)), self._max_radius)\n\n            neighbors = self._vertices_within_radius(q_new.position, radius)\n\n            # Choose best parent to minimize cost and ensure path validity\n            c_min = float('inf')\n            q_min = None\n            for neighbor in neighbors:\n                if neighbor.position == q_new.position:\n                    continue\n                line_n_new = grid.get_line_sequence(neighbor.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_n_new):\n                    continue\n                dist_n_new = torch.norm(neighbor.position.to_tensor() - q_new.position.to_tensor()).item()\n                cost = neighbor.cost + dist_n_new\n                if cost < c_min:\n                    c_min = cost\n                    q_min = neighbor\n\n            if q_min is None:\n                q_min = q_near\n                c_min = q_min.cost + dist_near_new\n\n            q_new.cost = c_min\n            # Add new vertex to graph and vertex list\n            vertex_list.append(q_new)\n            self._graph.root_vertices.insert(-1, q_new)  # Before goal vertex\n            self._graph.add_edge(q_min, q_new)\n\n            # Optimize connection of neighbors to q_new (rewiring)\n            for neighbor in neighbors:\n                if neighbor == q_min or neighbor == q_new:\n                    continue\n                dist_new_n = torch.norm(q_new.position.to_tensor() - neighbor.position.to_tensor()).item()\n                cost_through_new = q_new.cost + dist_new_n\n                if cost_through_new < neighbor.cost:\n                    line_new_n = grid.get_line_sequence(q_new.position, neighbor.position)\n                    if grid.is_valid_line_sequence(line_new_n):\n                        self._graph.remove_edge(next(iter(neighbor.parents)), neighbor)\n                        self._graph.add_edge(q_new, neighbor)\n                        neighbor.cost = cost_through_new\n                        self._update_descendants_cost(neighbor)\n\n            # Attempt connection to goal\n            line_to_goal = grid.get_line_sequence(q_new.position, goal_vertex.position)\n            dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_vertex.position.to_tensor()).item()\n            if grid.is_valid_line_sequence(line_to_goal):\n                cost_to_goal = q_new.cost + dist_to_goal\n                if cost_to_goal < goal_vertex.cost:\n                    # Connect q_new -> goal\n                    for p in list(goal_vertex.parents):\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_vertex.cost = cost_to_goal\n                    goal_reached = True\n\n            self.key_frame()\n\n            if goal_reached:\n                self._extract_path(goal_vertex)\n                return",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an improved sample-based planner called \"Adaptive Informed RRT*\" \n    (A-Informed RRT*). It combines informed sampling within an ellipsoidal heuristic \n    sampling space to efficiently steer the search towards promising regions and uses \n    adaptive radius updates for rewiring, improving path quality and reducing search time. \n    The algorithm maintains a tree rooted at the start vertex and iteratively attempts to \n    connect towards random samples constrained inside an informed ellipse once an initial \n    feasible path is found. It performs rewiring in the neighborhood adaptively to improve \n    path cost and ensures robustness by validating edges along the proposed motion. \n    The search halts at success or after 60 seconds (treating any longer search as failure).",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_extend_dist = 12.0  # max edge length when extending tree\n        self._max_radius = 40.0  # max rewiring radius\n        self._min_radius = 5.0   # min rewiring radius\n        self._dimension = self._get_grid().size.n_dim\n        self._iteration_limit = 10000\n        self._goal_sample_rate = 0.1  # Probability to sample goal directly to bias search\n        self._init_displays()\n\n    def _get_distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _get_random_sample(self, c_best: Optional[float] = None) -> Point:\n        \"\"\"Informed sampling: if c_best is known, sample inside ellipsoidal region, else uniform.\"\"\"\n        if c_best is None or c_best == float(\"inf\"):\n            # Uniform sampling inside the map\n            grid_size = self._get_grid().size\n            while True:\n                sample_coords = [np.random.randint(0, grid_size[i]) for i in range(grid_size.n_dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Ellipsoidal informed sampling inside heuristic ellipse\n            start_pos = self._graph.root_vertex_start.position.to_tensor()\n            goal_pos = self._graph.root_vertex_goal.position.to_tensor()\n            c_min = self._get_distance(self._graph.root_vertex_start.position,\n                                       self._graph.root_vertex_goal.position)\n\n            # Define transformation to unit ball and back to ellipse in workspace\n            # Compute center and rotation\n            center = (start_pos + goal_pos) / 2\n            direction = (goal_pos - start_pos)\n            direction_norm = torch.norm(direction)\n            if direction_norm == 0:\n                # Start == goal, trivial\n                return self._graph.root_vertex_start.position\n\n            # Unit vector from start to goal\n            e1 = direction / direction_norm\n\n            # Build a rotation matrix to transform samples from unit ball to ellipse\n            def rotation_matrix_to_align_vector(vec: torch.Tensor):\n                # For 2D or 3D only\n                d = vec.shape[0]\n                if d == 2:\n                    theta = torch.atan2(vec[1], vec[0])\n                    c = torch.cos(theta)\n                    s = torch.sin(theta)\n                    R = torch.tensor([[c, -s], [s, c]], dtype=torch.float)\n                    return R\n                elif d == 3:\n                    # Use Rodrigues rotation formula to align x-axis to e1\n                    x_axis = torch.tensor([1.0, 0.0, 0.0])\n                    v = torch.cross(x_axis, vec)\n                    s = torch.norm(v)\n                    c = torch.dot(x_axis, vec)\n                    if s == 0:\n                        return torch.eye(3)\n                    vx = torch.tensor([[0, -v[2], v[1]],\n                                       [v[2], 0, -v[0]],\n                                       [-v[1], v[0], 0]])\n                    R = torch.eye(3) + vx + vx @ vx * ((1 - c) / (s ** 2))\n                    return R\n                else:\n                    # Higher dimensional not supported, fallback to uniform sampling\n                    return None\n\n            R = rotation_matrix_to_align_vector(e1)\n            if R is None:\n                return self._get_random_sample(None)\n\n            # Sampling inside unit n-ball\n            while True:\n                dir_sample = torch.randn(self._dimension)\n                r = torch.rand(1).pow(1 / self._dimension)\n                dir_sample = dir_sample / torch.norm(dir_sample) * r\n\n                # Scale samples according to ellipse radii using c_best and c_min\n                # Axis lengths of ellipse - major axis c_best/2, minor axes sqrt(c_best^2 - c_min^2)/2\n                a1 = c_best / 2\n                if c_best ** 2 - c_min ** 2 < 0:\n                    # numerical stability fallback\n                    r_minor = 0.0\n                else:\n                    r_minor = torch.sqrt(c_best ** 2 - c_min ** 2) / 2\n\n                r_minor = max(r_minor.item(), 0.001)\n                scale = torch.ones(self._dimension)\n                scale[0] = a1\n                if self._dimension > 1:\n                    scale[1:] = r_minor\n\n                local_sample = dir_sample * scale\n\n                # Rotate & translate back to world frame\n                world_sample = R @ local_sample + center\n                coords = [int(torch.clamp(world_sample[i], 0, self._get_grid().size[i] - 1).item())\n                          for i in range(self._dimension)]\n                sample = Point(*coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dir_norm\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n\n        return Vertex(q_new_pos)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Backtrack from q_new to root start\n        path = [q_new]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        c_best = float(\"inf\")\n        found_path = False\n\n        for i in range(self._iteration_limit):\n            if time.time() - start_time > 60:\n                # Time limit reached, fail search\n                return\n\n            # Bias sampling towards goal with probability goal_sample_rate\n            if np.random.rand() < self._goal_sample_rate:\n                q_sample = self._graph.root_vertex_goal.position\n            else:\n                q_sample = self._get_random_sample(c_best if found_path else None)\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_extend_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Cost to reach q_new via q_nearest\n            dist_near_to_new = self._get_distance(q_nearest.position, q_new.position)\n            q_new.cost = q_nearest.cost + dist_near_to_new\n\n            # Dynamic rewiring radius (shrinks as graph grows to approximate RRT* theoretical radius)\n            card_v = max(1, self._graph.size)\n            radius = min(self._max_radius,\n                         max(self._min_radius,\n                             50 * ((torch.log(torch.tensor(card_v, dtype=torch.float)) / card_v) ** (1 / self._dimension))))\n            \n            # Find neighbors for rewiring\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent from neighbors\n            q_min = q_nearest\n            c_min = q_new.cost\n            for q_near in neighbors:\n                if q_near == q_nearest:\n                    continue\n                line_seq_neighbor = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_neighbor):\n                    continue\n                cost_through_neighbor = q_near.cost + self._get_distance(q_near.position, q_new.position)\n                if cost_through_neighbor < c_min:\n                    q_min = q_near\n                    c_min = cost_through_neighbor\n            \n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if better\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n\n                line_seq_neighbor = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_neighbor):\n                    continue\n\n                new_cost = q_new.cost + self._get_distance(q_new.position, q_near.position)\n                if new_cost < q_near.cost:\n                    # Remove old edge and add new edge with q_new as parent\n                    old_parent = None\n                    for parent in q_near.parents:\n                        old_parent = parent\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if new vertex reached goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Attempt to connect q_new directly to goal vertex\n                goal_v = self._graph.root_vertex_goal\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    dist_to_goal = self._get_distance(q_new.position, goal_v.position)\n                    goal_v.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, goal_v)\n\n                    c_best = goal_v.cost\n                    found_path = True\n                    self._extract_path(goal_v)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm": "Hybrid PathPlanning algorithm combining RRT-Connect bidirectional strategy with informed sampling and local rewiring \n    inspired by RRT* for improved path quality, robustness, and search efficiency.\n    Features:\n    - Bidirectional tree growth connecting start and goal for faster exploration.\n    - Informed sampling within an ellipse defined by start-goal distance and best cost to bias samples towards promising regions.\n    - Local rewiring (like RRT*) to improve path quality and smoothness dynamically.\n    - Early stopping if no improvement or goal reached.\n    - Timeout safeguard to fail if planning exceeds 60 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _best_goal_vertex: Optional[Vertex]\n    _start_vertex: Vertex\n    _goal_vertex: Vertex\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        # Start a forest with start and goal as roots\n        self._graph = Forest(self._start_vertex, self._goal_vertex, root_vertices=[])\n        self._graph.edges_removable = True\n        self._init_displays()\n        self._max_dist = 12.0\n        self._iterations = 12000\n        self._best_goal_vertex = None\n\n    def _get_random_sample(self, c_best: float = float(\"inf\")) -> Point:\n        \"\"\"\n        Perform informed sampling inside an ellipse between start and goal based on current best cost (c_best).\n        If no best cost known, sample uniformly.\n        \"\"\"\n        if np.isinf(c_best):\n            # No best path found yet. Uniform sampling.\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Informed Sampling ellipse parameters\n            start = self._start_vertex.position.to_tensor()\n            goal = self._goal_vertex.position.to_tensor()\n            c_min = torch.norm(goal - start).item()\n            if c_min == 0.0:\n                return Point(*start.tolist())\n\n            # ellipse parameters\n            center = (start + goal) / 2\n            a1 = (goal - start) / c_min  # unit vector from start to goal\n            dim = start.shape[0]\n\n            # Rotation matrix for ellipse aligned with a1 (only for 2D or 3D)\n            # We'll generate samples in unit ball, then transform to ellipse using rotation and scaling.\n            # Build orthogonal basis\n            def unit_vector(t):\n                return t / torch.norm(t)\n\n            basis = [a1]\n            if dim == 2:  # 2D case\n                b = torch.tensor([-a1[1], a1[0]])\n                basis.append(b)\n            elif dim >= 3:\n                # Gram-Schmidt to find orthonormal basis (dim-1 directions)\n                basis_vectors = [a1]\n                for i in range(1, dim):\n                    # Generate random vector and orthogonalize it w.r.t basis vectors\n                    v = torch.zeros(dim)\n                    v[i] = 1.0\n                    for bvec in basis_vectors:\n                        v -= torch.dot(v, bvec) * bvec\n                    v = unit_vector(v)\n                    basis_vectors.append(v)\n                basis = basis_vectors\n            else:\n                # fallback to uniform sampling if dim < 2 (unlikely)\n                while True:\n                    rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                    sample = Point(*rand_pos)\n                    if self._get_grid().is_agent_valid_pos(sample):\n                        return sample\n\n            C = torch.stack(basis, dim=1)  # rotation matrix\n\n            # sampling in unit n-ball\n            while True:\n                # sample from unit n-ball\n                direction = torch.randn(dim)\n                direction = direction / torch.norm(direction)\n                radius = np.random.rand() ** (1.0 / dim)  # uniform in volume\n                local_sample = radius * direction\n\n                # ellipse radius along main axis is c_best/2, perpendicular axes sqrt(c_best^2 - c_min^2)/2\n                if dim == 2:\n                    L = torch.diag(torch.tensor([c_best / 2.0, np.sqrt(c_best ** 2 - c_min ** 2) / 2.0]))\n                elif dim >= 3:\n                    perp_radius = np.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n                    diag_vals = [c_best / 2.0] + [perp_radius] * (dim - 1)\n                    L = torch.diag(torch.tensor(diag_vals))\n                else:\n                    L = torch.diag(torch.tensor([c_best / 2.0]))\n\n                sample_tensor = C @ (L @ local_sample) + center\n                # round sample to nearest int grid location\n                coords = torch.round(sample_tensor).int()\n                coords = coords.tolist()\n                if all(0 <= coords[i] < self._get_grid().size[i] for i in range(dim)):\n                    candidate = Point(*coords)\n                    if self._get_grid().is_agent_valid_pos(candidate):\n                        return candidate\n\n    def _steer(self, q_near: Vertex, q_target: Point) -> Vertex:\n        dir_vec = q_target.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= self._max_dist:\n            q_new_pt = q_target\n        else:\n            dir_unit = dir_vec / dist\n            new_pos_tensor = q_near.position.to_tensor() + dir_unit * self._max_dist\n            q_new_pt = Point.from_tensor(new_pos_tensor)\n        return Vertex(q_new_pt)\n\n    def _line_valid(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _get_nearest_vertex(self, vertices: List[Vertex], p: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(vertices, p)\n\n    def _get_near_vertices(self, vertices: List[Vertex], p: Point, radius: float) -> List[Vertex]:\n        # Return all vertices within radius of p from given vertices\n        return self._graph.get_vertices_within_radius(vertices, p, radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        # Choose best parent for q_new based on cost + movement cost and valid line\n        min_cost = float(\"inf\")\n        best_parent = None\n\n        for v in near_vertices:\n            cost_to_new = v.cost if v.cost is not None else 0\n            move_cost = self._get_grid().get_movement_cost(v.position, q_new.position)\n            c_total = cost_to_new + move_cost\n            if c_total < min_cost and self._line_valid(v.position, q_new.position):\n                min_cost = c_total\n                best_parent = v\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        # Attempt to improve costs of near vertices by connecting through q_new\n        c_new = q_new.cost if q_new.cost is not None else 0\n        for v in near_vertices:\n            if v == q_new:\n                continue\n            move_cost = self._get_grid().get_movement_cost(q_new.position, v.position)\n            new_cost = c_new + move_cost\n            if v.cost is None or new_cost < v.cost:\n                if self._line_valid(q_new.position, v.position):\n                    # Rewire edge: remove old parents, add q_new as parent\n                    # We assume one parent for simplification, else handle multi parents carefully\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = new_cost\n\n    def _build_path(self, goal_vertex: Vertex) -> List[Vertex]:\n        path = [goal_vertex]\n        current = goal_vertex\n        while current.parents:\n            # pick the parent with minimum cost if multiple\n            current = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            path.append(current)\n        path.reverse()\n        return path\n\n    def _extract_path_and_animate(self, goal_vertex: Vertex) -> None:\n        path = self._build_path(goal_vertex)\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _extend(self, root_vertex: Vertex, q_sample: Point) -> Tuple[str, Optional[Vertex]]:\n        q_near = self._get_nearest_vertex([root_vertex], q_sample)\n        q_new = self._steer(q_near, q_sample)\n        if not self._line_valid(q_near.position, q_new.position):\n            return 'trapped', None\n        # Find near vertices for rewiring radius (using radius from RRT* theory)\n        dimension = self._get_grid().size.n_dim\n        gamma_rrt_star = 30.0  # adjustable constant (usually set empirically)\n        radius = min(self._max_dist * 2.5, \n                     gamma_rrt_star * ((np.log(self._graph.size + 1) / (self._graph.size + 1)) ** (1/dimension)))\n        near_vertices = self._get_near_vertices([root_vertex] + self._graph.root_vertices, q_new.position, radius)\n\n        # Choose best parent among near vertices\n        best_parent = self._choose_parent(near_vertices, q_new)\n        if best_parent is None:\n            best_parent = q_near  # fallback\n        q_new.cost = (best_parent.cost if best_parent.cost is not None else 0) + \\\n            self._get_grid().get_movement_cost(best_parent.position, q_new.position)\n        self._graph.add_edge(best_parent, q_new)\n        self._rewire(near_vertices, q_new)\n\n        if q_new.position == q_sample:\n            return 'reached', q_new\n        else:\n            return 'advanced', q_new\n\n    def _connect(self, root_vertex: Vertex, q_target: Vertex) -> str:\n        status = 'advanced'\n        last_vertex = None\n        while status == 'advanced':\n            status, q_new = self._extend(root_vertex, q_target.position)\n            if q_new is not None:\n                last_vertex = q_new\n            else:\n                break\n            if status == 'reached':\n                break\n        return status\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        self._start_vertex.cost = 0\n        self._goal_vertex.cost = float(\"inf\")\n\n        # Keep root vertices list: start tree and goal tree\n        if self._graph.root_vertices == []:\n            self._graph.root_vertices = [self._start_vertex, self._goal_vertex]\n\n        # Bidirectional RRT* with informed sampling and rewiring\n        for _ in range(self._iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 60:\n                # Fail due to timeout\n                break\n\n            # Current best cost for informed sampling\n            c_best = self._best_goal_vertex.cost if self._best_goal_vertex is not None else float('inf')\n\n            # Sample point biased inside informed ellipse\n            q_rand = self._get_random_sample(c_best)\n\n            # Extend start tree towards q_rand\n            status_start, q_new_start = self._extend(self._graph.root_vertex_start, q_rand)\n            if status_start != 'trapped' and q_new_start is not None:\n                # Try connecting goal tree to q_new_start\n                status_goal = self._connect(self._graph.root_vertex_goal, q_new_start)\n                if status_goal == 'reached':\n                    # A connection made - update best path if shorter\n                    # Find connecting vertex between trees\n                    connecting_vertex_goal = self._graph.get_nearest_vertex([self._graph.root_vertex_goal], q_new_start.position)\n                    total_cost = q_new_start.cost if q_new_start.cost is not None else float('inf')\n                    if connecting_vertex_goal.cost is not None:\n                        total_cost += connecting_vertex_goal.cost + \\\n                                      self._get_grid().get_movement_cost(connecting_vertex_goal.position, q_new_start.position)\n                    if self._best_goal_vertex is None or total_cost < self._best_goal_vertex.cost:\n                        # Construct unified path: link q_new_start and connecting_vertex_goal\n                        self._graph.add_edge(q_new_start, connecting_vertex_goal)\n                        self._best_goal_vertex = connecting_vertex_goal\n                    # Extract and animate best path and finish\n                    if self._best_goal_vertex is not None:\n                        self._extract_path_and_animate(self._best_goal_vertex)\n                        break\n\n            # Swap roots for balanced growth\n            self._graph.reverse_root_vertices()\n\n            # Visual key frame/animation update\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm": "Improved sample-based path planning algorithm combining benefits of RRT* and SPRM features:\n    - Uses an adaptive radius for neighborhood search based on vertex count and map size to enhance rewiring and path smoothness.\n    - Incorporates cost optimization while rewiring to ensure better path quality.\n    - Uses informed sampling centered around the current best path to improve planning efficiency.\n    - Limits search time to 60 seconds to ensure robustness by failing gracefully if no solution is found.\n    - Utilizes cyclic graph to avoid tree structure limitations and enable richer connectivity.\n    - Implements path smoothing by shortcutting edges when possible, improving path length and smoothness.\n    - Produces more optimal and robust paths with balanced exploration and exploitation.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n    _max_edge_len: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        self._V_size = 250\n        # Maximum edge length per extension step, scaled to map size\n        grid_size_sum = sum(self._get_grid().size.values)\n        self._max_edge_len = max(5, grid_size_sum / 20)\n        self._max_radius = max(10, grid_size_sum / 10)\n\n        V: List[Vertex] = []\n        for _ in range(self._V_size):\n            sample = self._get_random_sample()\n            V.append(Vertex(sample, store_connectivity=True))\n\n        self._graph = gen_cyclic_graph(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            V,\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Informed sampling within a heuristic ellipsoidal region to focus search near best path.\"\"\"\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n\n        c_best = float(\"inf\")\n        path_vertices = self._get_current_best_path_vertices()\n        if path_vertices:\n            c_best = sum(\n                self._get_grid().get_distance(path_vertices[i].position, path_vertices[i + 1].position)\n                for i in range(len(path_vertices) - 1)\n            )\n        else:\n            # If no path known, set to grid diagonal length * 2 to search broadly\n            c_best = (self._get_grid().size.to_tensor().float().norm()) * 2\n\n        while True:\n            # Uniform random sample in configuration space\n            random_sample = Point(\n                *[\n                    self._services.rng.uniform(0, self._get_grid().size[i])\n                    for i in range(self._get_grid().size.n_dim)\n                ]\n            )\n\n            # Reject samples outside informed ellipsoid (if path known) to focus search:\n            # Ellipsoid defined by foci start and goal and path cost c_best\n            dist_start_sample = (random_sample.to_tensor() - start).norm()\n            dist_sample_goal = (random_sample.to_tensor() - goal).norm()\n            if dist_start_sample + dist_sample_goal <= c_best + self._max_edge_len:\n                if self._get_grid().is_agent_valid_pos(random_sample):\n                    return random_sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = direction.norm()\n        if norm_dir <= max_dist:\n            q_new = q_sample\n        else:\n            q_new_tensor = q_near.position.to_tensor() + (direction / norm_dir) * max_dist\n            q_new = Point.from_tensor(q_new_tensor)\n        return Vertex(q_new, store_connectivity=True)\n\n    def _near(self, vertex: Vertex, radius: Optional[float] = None) -> List[Vertex]:\n        # Use adaptive radius if none specified\n        if radius is None:\n            n = max(1, len(self._graph.root_vertices))\n            # RRT* radius formula scaled to environment - robust and efficient\n            unit_ball_volume = 3.14  # Approximation for 2D; in higher dims could tune\n            gamma_rrt_star = 2 * (1 + 1 / self._get_grid().size.n_dim) ** (1 / self._get_grid().size.n_dim) * (\n                self._get_grid().size.width * self._get_grid().size.height\n            ) ** (1 / self._get_grid().size.n_dim)\n            radius = min(self._max_radius, gamma_rrt_star * (math.log(n) / n) ** (1 / self._get_grid().size.n_dim))\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _choose_parent_and_rewire(self, q_new: Vertex, q_near_list: List[Vertex]) -> None:\n        # Choose best parent based on total cost to q_new through neighbor and rewire neighbors if better path found\n        best_parent = None\n        best_cost = float(\"inf\")\n        for q_near in q_near_list:\n            if q_near.position == q_new.position:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            tentative_cost = (\n                getattr(q_near, \"cost\", 0) + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            )\n            if tentative_cost < best_cost:\n                best_parent = q_near\n                best_cost = tentative_cost\n        if best_parent:\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n            # Rewire neighbors if going through q_new offers a better cost\n            for q_near in q_near_list:\n                if q_near == best_parent or q_near == q_new:\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    continue\n                cost_through_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n                current_cost = getattr(q_near, \"cost\", float(\"inf\"))\n                if cost_through_new < current_cost:\n                    # Remove old edge(s) from parents\n                    for parent in list(q_near.parents):\n                        self._graph.remove_edge(parent, q_near)\n                    self._graph.add_edge(q_new, q_near)\n                    q_near.cost = cost_through_new\n\n    def _get_current_best_path_vertices(self) -> List[Vertex]:\n        # Try to recover current best path from start to goal if connected\n        start = self._graph.root_vertex_start\n        goal = self._graph.root_vertex_goal\n        if goal not in start.connectivity:\n            return []\n\n        path = []\n        current = start\n        while current != goal:\n            children = list(current.connectivity)\n            if not children:\n                break\n            # Choose child with lowest cost if available (heuristic)\n            if hasattr(current, \"cost\"):\n                children = sorted(children, key=lambda c: getattr(c, \"cost\", float(\"inf\")))\n            current = children[0]\n            path.append(current)\n            if current == goal:\n                break\n        return path\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Path shortcutting to improve smoothness: tries to connect non-adjacent points directly if possible\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[next_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                next_idx -= 1\n            shortcut_path.append(path[next_idx])\n            idx = next_idx\n        return shortcut_path\n\n    def _extract_path_and_animate(self, q_goal: Vertex) -> None:\n        # Extracts path from the goal vertex back to start and animates movement\n        path = [q_goal]\n        while path[-1].parents:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        path.reverse()\n\n        # Path shortcutting\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import math\n\n        start_time = time()\n        max_duration = 60  # seconds\n        max_iterations = 20000\n\n        # Initialize cost for root start and goal vertices\n        self._graph.root_vertex_start.cost = 0\n        self._graph.root_vertex_goal.cost = float(\"inf\")\n\n        for iteration in range(max_iterations):\n            if time() - start_time > max_duration:\n                # Fail gracefully if timeout reached\n                return\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_edge_len)\n\n            # Check feasibility of new edge\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Add the new vertex and find neighbors for rewiring\n            self._graph.root_vertices.append(q_new)\n            q_near_list = self._near(q_new, radius=self._max_radius)\n\n            # Choose parent and rewire neighbors to minimize cost\n            self._choose_parent_and_rewire(q_new, q_near_list)\n\n            # Check if new vertex reaches goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect goal vertex, update cost, extract path and exit\n                self._graph.add_edge(q_new, self._graph.root_vertex_goal)\n                self._graph.root_vertex_goal.cost = getattr(q_new, \"cost\", float(\"inf\")) + self._get_grid().get_movement_cost(q_new.position, self._graph.root_vertex_goal.position)\n                self._extract_path_and_animate(self._graph.root_vertex_goal)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm": "This is an enhanced anytime, asymptotically optimal sample-based path planning algorithm named\n    \"ANYTIME RRT*-SMART\" designed to improve planning efficiency, path quality, robustness,\n    success rate, path smoothness, and path length while reducing overall search time.\n\n    It uses a forest structure (similar to RRT*) and incorporates the following innovations:\n    - Adaptive sampling biased toward the goal and lower-cost vertices to improve convergence speed.\n    - Sample pruning to remove vertices unlikely to improve the path (focused search).\n    - A path shortcutting post-process on found paths to smooth and shorten the trajectory.\n    - A time-bound search with a hard limit of 60 seconds to guarantee responsiveness.\n    - Dynamic radius selection using RRT* radius scaling for rewiring.\n    - Cost-aware rewiring of the graph for asymptotic optimality.\n    - Early termination when a feasible path is found and improved sufficiently.\n\n    The algorithm maintains a forest rooted at start and goal and grows the graph iteratively.\n    Sampling is biased towards the goal and sampled vertices close to the current best path.\n\n    On success, the path is extracted and shortened with shortcuts to produce a smooth and\n    quality trajectory.\n\n    Overall, this approach aims to balance exploration and exploitation, quickly find feasible\n    paths, and continue improving them within a time budget.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        # Empty initial vertices, will build as we sample\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        self._max_dist = 12.0  # max extension step length\n        self._dim = self._get_grid().size.n_dim\n        self._goal_sample_rate = 0.1  # Probability of sampling the goal directly\n        self._max_runtime = 60.0  # seconds: hard stop for planning\n        self._lambda_rrt_star = 50.0  # constant for radius calculation\n\n        self._best_goal_vertex: Optional[Vertex] = None  # best vertex reaching goal\n        self._init_displays()\n\n    def _get_random_sample(self, bias_to_goal=False) -> Point:\n        \"\"\"\n        Samples a random valid point inside the grid.\n        If bias_to_goal is True, samples exactly the goal position.\n        \"\"\"\n        if bias_to_goal:\n            return self._get_grid().goal.position\n        while True:\n            # Sample uniformly in n dimensions within grid bounds\n            vals = [int(torch.randint(0, self._get_grid().size[i], (1,)).item()) for i in range(self._dim)]\n            p = Point(*vals)\n            if self._get_grid().is_agent_valid_pos(p):\n                return p\n\n    def _steer(self, q_near: Vertex, q_rand: Point, max_dist: float) -> Optional[Vertex]:\n        \"\"\"\n        Returns a new vertex in the direction of q_rand from q_near at distance max_dist if\n        q_rand is farther than max_dist; else returns new vertex at q_rand (if valid).\n        \"\"\"\n        vec = q_rand.to_tensor() - q_near.position.to_tensor()\n        dist = float(torch.norm(vec))\n        if dist == 0:\n            return None\n        if dist <= max_dist:\n            new_pos = q_rand\n        else:\n            direction = vec / dist\n            new_pos_t = q_near.position.to_tensor() + max_dist * direction\n            new_pos = Point.from_tensor(new_pos_t)\n\n        if not self._get_grid().is_agent_valid_pos(new_pos):\n            return None\n        # Verify line between q_near and new_pos is free\n        line_seq = self._get_grid().get_line_sequence(q_near.position, new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        return Vertex(new_pos)\n\n    def _get_neighbors(self, v: Vertex, radius: float) -> List[Vertex]:\n        # Return vertices within radius from v to consider for rewiring\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], v.position, radius)\n\n    def _cost(self, frm: Point, to: Point) -> float:\n        # Cost function = Euclidean distance (can be adjusted if needed)\n        return float(torch.norm(frm.to_tensor() - to.to_tensor()))\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> (Optional[Vertex], float):\n        \"\"\"\n        Choose the best parent for q_new among neighbors minimizing cost + edge cost,\n        and valid collision-free path.\n        \"\"\"\n        c_min = math.inf\n        q_min = None\n        for q_near in neighbors:\n            # Check line collision between q_near and q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cost = q_near.cost + self._cost(q_near.position, q_new.position)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n        return q_min, c_min\n\n    def _rewire(self, neighbors: List[Vertex], q_new: Vertex) -> None:\n        \"\"\"\n        For each neighbor, check if path cost can be reduced by rewiring through q_new.\n        \"\"\"\n        for q_near in neighbors:\n            if q_near is q_new.parents:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_new = q_new.cost + self._cost(q_new.position, q_near.position)\n            if cost_new < q_near.cost:\n                # Remove old edges\n                old_parents = list(q_near.parents)\n                for old_parent in old_parents:\n                    self._graph.remove_edge(old_parent, q_near)\n                # Add new edge\n                q_near.cost = cost_new\n                self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Point]:\n        \"\"\"\n        Extracts the path from start to the given goal vertex by parents chain.\n        Returns list of Points from start to goal.\n        \"\"\"\n        path_vertices = []\n        current = goal_vertex\n        while current:\n            path_vertices.append(current)\n            if len(current.parents) == 0:\n                break\n            # We choose one parent (e.g. first) since this is a tree\n            current = next(iter(current.parents))\n        path_vertices.reverse()\n        return [v.position for v in path_vertices]\n\n    def _shortcut_path(self, path: List[Point], max_iterations=50) -> List[Point]:\n        \"\"\"\n        Applies simple shortcutting heuristic by attempting to replace intermediate points with\n        direct edges if they are collision free, repeated max_iterations times.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        for _ in range(max_iterations):\n            if len(path) < 3:\n                break\n            # Pick two indices i,j with j>i+1\n            i = int(torch.randint(0, len(path) - 2, (1,)).item())\n            j = int(torch.randint(i + 2, len(path), (1,)).item())\n\n            if j >= len(path) or i < 0 or i >= j:\n                continue\n            start = path[i]\n            end = path[j]\n            line_seq = self._get_grid().get_line_sequence(start, end)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                # Remove intermediate points between i and j\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        iterations = 0\n        max_iterations = 20000  # Cap to prevent infinite loops if time runs long\n        found_path = False\n        best_cost = math.inf\n\n        while True:\n            elapsed = time.time() - start_time\n            if elapsed > self._max_runtime:\n                # Fail and stop search if time exceeded\n                break\n            if iterations >= max_iterations:\n                break\n\n            iterations += 1\n\n            # Sampling: With probability goal_sample_rate sample goal, otherwise random\n            sample_goal_bias = torch.rand(1).item() < self._goal_sample_rate\n            q_sample = self._get_random_sample(bias_to_goal=sample_goal_bias)\n\n            # Nearest vertex in tree to sample\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n            # Steer towards q_sample from q_nearest with max extension limit\n            q_new = self._steer(q_nearest, q_sample, self._max_dist)\n            if q_new is None:\n                continue\n\n            # Determine radius for neighbor search (RRT* formula)\n            card_v = float(self._graph.size + 1)  # +1 to avoid log(0)\n            radius = min(self._lambda_rrt_star * ((math.log(card_v) / card_v) ** (1 / self._dim)), self._max_dist * 5)\n\n            # Find neighbors in radius\n            neighbors = self._get_neighbors(q_new, radius)\n\n            # Choose best parent among neighbors\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                # If no suitable parent found, abandon q_new\n                continue\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors through q_new if better\n            self._rewire(neighbors, q_new)\n\n            # Add new vertex to roots to keep track\n            self._graph.root_vertices.append(q_new)\n\n            # Check if q_new can connect to goal directly and improve path cost\n            dist_to_goal = float(torch.norm(q_new.position.to_tensor() - self._graph.root_vertex_goal.position.to_tensor()))\n            if dist_to_goal <= self._max_dist:\n                # Check collision to goal\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, self._graph.root_vertex_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    cost_to_goal = q_new.cost + dist_to_goal\n                    if cost_to_goal < best_cost:\n                        best_cost = cost_to_goal\n                        goal_vertex = Vertex(self._graph.root_vertex_goal.position)\n                        goal_vertex.cost = cost_to_goal\n                        self._graph.add_edge(q_new, goal_vertex)\n                        self._best_goal_vertex = goal_vertex\n                        self._graph.root_vertices.append(goal_vertex)\n                        found_path = True\n\n                        # If path is found, optionally run keyframe for visualization\n                        self.key_frame()\n\n            self.key_frame()\n\n            # Early stop if a good enough path is found (e.g. cost < threshold)\n            if found_path and best_cost < self._max_dist * 4:\n                break\n\n        # If a path was found, extract and shortcut path, then follow it\n        if found_path and self._best_goal_vertex is not None:\n            path = self._extract_path(self._best_goal_vertex)\n            path = self._shortcut_path(path, max_iterations=100)\n            for p in path:\n                self.move_agent(p)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm": "This improved path planning algorithm is a hybrid sample-based planner that blends RRT* style incremental tree construction\n    with informed sampling and rewiring heuristics for path quality improvement. It uses dynamic radius computation based on the \n    current graph size and environment scale to maintain efficient exploration and exploitation balance.\n    \n    Key Features:\n    - Adaptive sampling domain focused near start-goal elliptical region for efficiency.\n    - Use of cost-to-come and cost-to-go estimates for vertex rewiring (improves path quality).\n    - Dynamic neighborhood radius adjustment (to balance connectivity and complexity).\n    - Time-bounded search: stops planning if >60 seconds to prevent excessive computation.\n    - Edge validation using Bresenham line and environment collision checks.\n    - Path extraction includes backward traversal from goal to start.\n    - Smooth path by rewiring existing vertices when a better parent is found.\n    - Pruned search on goal proximity: when a vertex is close enough, attempts connection to goal.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_iterations: int\n    _max_radius: float\n    _max_extend_length: float\n    _start_time: float\n    _time_limit_sec: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_iterations = 20000\n        self._time_limit_sec = 60.0  # 1 minute limit\n        size = self._get_grid().size\n        # Max extend length relative to grid diagonal, capped limits\n        self._max_extend_length = max(5.0, min(20.0, (size.width ** 2 + size.height ** 2) ** 0.5 / 20))\n        self._max_radius = max(10.0, min(25.0, (size.width ** 2 + size.height ** 2) ** 0.5 / 4))\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Use informed sampling within an ellipse around start and goal to accelerate convergence.\n        If no solution found yet, sample uniformly.\n        \"\"\"\n        grid = self._get_grid()\n        start = grid.agent.position.to_tensor()\n        goal = grid.goal.position.to_tensor()\n\n        if not hasattr(self, '_best_cost') or self._best_cost is None:\n            # Uniform sampling\n            while True:\n                coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        dist_start_goal = torch.norm(goal - start).item()\n        c_best = self._best_cost\n        if c_best == float('inf') or c_best < dist_start_goal:\n            c_best = dist_start_goal * 1.5\n\n        # Sample within ellipse between start and goal defined by c_best\n        while True:\n            # Sample random point in unit circle (2D)\n            r1 = torch.rand(1).item()\n            r2 = torch.rand(1).item()\n            angle = 2 * 3.141592653589793 * r2\n            radius = r1 ** 0.5\n            x = radius * torch.cos(torch.tensor(angle)).item()\n            y = radius * torch.sin(torch.tensor(angle)).item()\n\n            # Scale factors of ellipse axis\n            a = c_best / 2.0\n            b = (c_best ** 2 - dist_start_goal ** 2) ** 0.5 / 2.0\n\n            # Rotate and translate ellipse point to map frame\n            direction = goal - start\n            unit_dir = direction / dist_start_goal\n            rot_matrix = torch.tensor([[unit_dir[0], -unit_dir[1]],\n                                       [unit_dir[1],  unit_dir[0]]])\n\n            sample_local = torch.tensor([a * x, b * y])\n            sample_global = start[:2] + torch.matmul(rot_matrix, sample_local)\n\n            # Clamp to map bounds and round to nearest int point for grid index\n            sx = int(max(0, min(self._get_grid().size.width - 1, round(sample_global[0].item()))))\n            sy = int(max(0, min(self._get_grid().size.height - 1, round(sample_global[1].item()))))\n            sample_pt = Point(sx, sy)\n\n            if self._get_grid().is_agent_valid_pos(sample_pt):\n                return sample_pt\n\n    def _steer(self, q_near: Vertex, q_rand: Point) -> Vertex:\n        \"\"\"\n        Produce a new vertex in the direction from q_near to q_rand but limited by max_extend_length.\n        \"\"\"\n        dir_vec = q_rand.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= self._max_extend_length:\n            return Vertex(q_rand)\n        dir_unit = dir_vec / dist\n        new_pos = q_near.position.to_tensor() + self._max_extend_length * dir_unit\n        new_pt = Point.from_tensor(new_pos)\n        return Vertex(new_pt)\n\n    def _get_nearby_vertices(self, v: Vertex) -> List[Vertex]:\n        \"\"\"\n        Return the vertices within the dynamic radius for possible rewiring.\n        Radius adapts to node density: r = min(max_radius, gamma * (log(n)/n)^{1/d}),\n        here approximated by a constant max_radius for complexity.\n        \"\"\"\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, v.position, self._max_radius)\n\n    def _cost(self, v_from: Vertex, v_to: Vertex) -> float:\n        return self._get_grid().get_movement_cost(v_from.position, v_to.position)\n\n    def _choose_parent(self, q_new: Vertex, nearby_vertices: List[Vertex]) -> Optional[Vertex]:\n        \"\"\"\n        Choose a parent for new vertex from nearby vertices minimizing cost-to-come + cost edge.\n        \"\"\"\n        min_cost = float('inf')\n        best_parent = None\n        for v in nearby_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            new_cost = v.cost + self._cost(v, q_new)\n            if new_cost < min_cost:\n                min_cost = new_cost\n                best_parent = v\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, nearby_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Attempt to update the cost and parent of nearby vertices through q_new if it improves the cost-to-come.\n        \"\"\"\n        for v in nearby_vertices:\n            if v is q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            potential_cost = q_new.cost + self._cost(q_new, v)\n            if potential_cost < v.cost:\n                # Rewire: update parent link\n                # Remove old edges from parents and add new edges for consistency\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = potential_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        \"\"\"\n        Extract the best path by tracing backwards parents from goal vertex.\n        \"\"\"\n        path: List[Vertex] = [q_goal]\n        current = q_goal\n        while current.position != self._graph.root_vertex_start.position:\n            parents = list(current.parents)\n            if not parents:\n                break\n            # Since it's a tree, expect one parent\n            current = parents[0]\n            path.append(current)\n        path.reverse()\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _update_best_cost(self, q_new: Vertex) -> None:\n        \"\"\"\n        Update the global best cost if q_new improves the current value.\n        \"\"\"\n        dist_to_goal = Map.get_distance(q_new.position, self._graph.root_vertex_goal.position)\n        cost_estimate = q_new.cost + dist_to_goal\n        if not hasattr(self, '_best_cost') or cost_estimate < self._best_cost:\n            self._best_cost = cost_estimate\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n        root_start = self._graph.root_vertex_start\n        root_goal = self._graph.root_vertex_goal\n\n        root_start.cost = 0.0\n        root_goal.cost = float('inf')\n        self._best_cost = float('inf')\n\n        for iteration in range(self._max_iterations):\n\n            if time.time() - self._start_time > self._time_limit_sec:\n                # Planning failed due to time constraint\n                return\n\n            q_rand = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_rand)\n            q_new = self._steer(q_near, q_rand)\n\n            if q_new.position == q_near.position:\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find nearby vertices for parent selection and rewiring\n            neighbor_vertices = self._get_nearby_vertices(q_new)\n\n            parent = self._choose_parent(q_new, [q_near] + neighbor_vertices)\n            if parent is None:\n                continue\n\n            q_new.cost = parent.cost + self._cost(parent, q_new)\n            self._graph.add_edge(parent, q_new)\n\n            # Rewire nearby nodes for better paths\n            self._rewire(q_new, neighbor_vertices)\n\n            # Add the new vertex to root vertices for expanded search\n            self._graph.root_vertices.append(q_new)\n\n            # Check if goal can be connected/improved from q_new\n            dist_to_goal = Map.get_distance(q_new.position, root_goal.position)\n            if dist_to_goal <= self._max_extend_length:\n                line_to_goal = self._get_grid().get_line_sequence(q_new.position, root_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_to_goal):\n                    # Connect goal to q_new with an edge if better\n                    new_goal_cost = q_new.cost + self._cost(q_new, root_goal)\n                    if new_goal_cost < root_goal.cost:\n                        # Remove old parents of goal to keep single best\n                        for p in list(root_goal.parents):\n                            self._graph.remove_edge(p, root_goal)\n                        root_goal.cost = new_goal_cost\n                        self._graph.add_edge(q_new, root_goal)\n                        self._update_best_cost(root_goal)\n\n                        # Extract path and return success\n                        self._extract_path(root_goal)\n                        return\n\n            self._update_best_cost(q_new)\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm": "This algorithm integrates and improves upon sampling-based algorithms like RRT and SPRM,\n    combining efficient exploration with intelligent rewiring for optimal path quality.\n    It does the following:\n    - Uses informed sampling biased towards the goal to improve convergence speed.\n    - Uses a variable radius nearest neighbor search for rewiring to improve path quality.\n    - Employs a cost-to-come plus heuristic cost-to-go for vertex cost and prioritization.\n    - Uses early stopping when goal is reached.\n    - Uses a timestamp to terminate if planning exceeds 60 seconds.\n    - After finding the path, performs a path smoothing step to reduce sharp turns.\n    - Stores connectivity in a cyclic graph structure for rewiring edges.\n    - Supports 2D or higher dimensional maps.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius_init: float\n    _max_step: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._V_size = 300   # reasonable number of vertices\n        self._max_step = 12.0\n        self._max_radius_init = 20.0\n        V: List[Vertex] = list()\n\n        # start and goal vertices with connectivity info\n        start_v = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_v = Vertex(self._get_grid().goal.position, store_connectivity=True)\n\n        # Pre-fill samples biased toward goal region for informed exploration\n        for i in range(self._V_size):\n            V.append(self._sample_informed(goal_v.position))\n        self._graph = gen_cyclic_graph(self._services, start_v, goal_v, V)\n        self._graph.edges_removable = True  # allow rewiring for optimization\n\n        # Initialize cost of start vertex as 0, others as inf\n        start_v.cost = 0.0\n        for v in self._graph.root_vertices:\n            if v is not start_v:\n                v.cost = float('inf')\n\n        self._init_displays()\n\n    def _sample_informed(self, goal_pos: Point) -> Point:\n        \"\"\"Sample a point biased toward the goal, with fallback to uniform random if needed.\"\"\"\n        g = goal_pos\n        map_size = self._get_grid().size\n        for _ in range(10):\n            # Informed sampling: sample a point in an ellipse or near goal region\n            # For simplicity, here bias sampling toward goal +/- radius region\n            delta = 10\n            low = [max(0, g[i] - delta) for i in range(map_size.n_dim)]\n            high = [min(map_size[i] - 1, g[i] + delta) for i in range(map_size.n_dim)]\n\n            coords = []\n            for dim in range(map_size.n_dim):\n                val = int(torch.randint(low[dim], high[dim] + 1, (1,)).item())\n                coords.append(val)\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n        # fallback: uniform random valid sample\n        while True:\n            sample = Point(*[torch.randint(0, map_size[i], (1,)).item() for i in range(map_size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _get_nearest_vertex(self, vertices: List[Vertex], point: Point) -> Optional[Vertex]:\n        best_vertex = None\n        best_dist = float('inf')\n        for v in vertices:\n            dist = self._distance(v.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best_vertex = v\n        return best_vertex\n\n    def _get_near_vertices(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        near = []\n        for v in vertices:\n            if self._distance(v.position, point) <= radius:\n                near.append(v)\n        return near\n\n    def _steer(self, from_v: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        direction = to_point.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            return Vertex(to_point, store_connectivity=True)\n        direction_normalized = direction / dist\n        new_pos_tensor = from_v.position.to_tensor() + max_dist * direction_normalized\n        new_point = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_point, store_connectivity=True)\n\n    def _reconstruct_path(self, goal_vertex: Vertex) -> List[Vertex]:\n        path = []\n        current = goal_vertex\n        # Follow parents with minimal cost path backward to root start vertex\n        while True:\n            path.append(current)\n            if not current.parents or any(p.cost == 0 for p in current.parents):\n                break\n            # proceed to parent with lowest cost\n            min_parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            current = min_parent\n        path.reverse()\n        return path\n\n    def _line_collision_free(self, start: Point, end: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(start, end)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _path_smoothing(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"Attempt to smooth path by shortcutting between vertices skipping intermediates.\"\"\"\n        if len(path) <= 2:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_collision_free(path[i].position, path[j].position):\n                    smoothed.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # no shortcut found, just add next vertex\n                smoothed.append(path[i + 1])\n                i += 1\n        return smoothed\n\n    # Overridden implementation #\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        start_v = self._graph.root_vertex_start\n        goal_v = self._graph.root_vertex_goal\n\n        # Add start & goal to root_vertices if missing\n        if start_v not in self._graph.root_vertices:\n            self._graph.root_vertices.insert(0, start_v)\n        if goal_v not in self._graph.root_vertices:\n            self._graph.root_vertices.append(goal_v)\n\n        all_vertices = self._graph.root_vertices + self._graph.root_vertices[2:]  # start, goal + V\n\n        max_iter = 12000\n        radius_factor = 50.0  # controls rewiring radius scaling\n        dimension = self._get_grid().size.n_dim\n\n        for iter_idx in range(max_iter):\n\n            # Timeout fail check (60 seconds)\n            if time.time() - start_time > 60.0:\n                # Treat as fail: no path found in time\n                return\n\n            # Sample a point biased towards goal region\n            q_rand = self._sample_informed(goal_v.position)\n            # Find nearest vertex in graph\n            q_near = self._get_nearest_vertex(all_vertices, q_rand)\n            if q_near is None:\n                continue\n\n            # Steer toward sample with max step size\n            q_new = self._steer(q_near, q_rand, self._max_step)\n\n            # Check validity of path q_near to q_new\n            if not self._line_collision_free(q_near.position, q_new.position):\n                continue\n\n            # Calculate tentative cost to reach q_new through q_near\n            cost_to_q_new = (q_near.cost if q_near.cost is not None else float('inf')) + \\\n                            self._distance(q_near.position, q_new.position)\n            # If q_new already exists in graph (approximate), skip to avoid duplicates\n            overlap_vertices = [v for v in all_vertices if v.position == q_new.position]\n            if overlap_vertices:\n                # May try to rewire the vertex if this path better\n                existing_v = overlap_vertices[0]\n                if cost_to_q_new < (existing_v.cost if existing_v.cost is not None else float('inf')):\n                    existing_v.cost = cost_to_q_new\n                    # Change parents to q_near\n                    for p in list(existing_v.parents):\n                        existing_v.parents.remove(p)\n                        p.children.remove(existing_v)\n                    existing_v.add_parent(q_near)\n                    q_near.add_child(existing_v)\n                continue\n\n            # Assign cost & add q_new to graph connected from q_near\n            q_new.cost = cost_to_q_new\n            self._graph.root_vertices.append(q_new)\n            all_vertices.append(q_new)\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire neighbors within radius around q_new to possibly improve cost\n            radius = radius_factor * ( (np.log(len(all_vertices)) / len(all_vertices)) ** (1 / dimension) )\n            radius = max(radius, self._max_step)  # radius never below step size\n            near_vertices = self._get_near_vertices(all_vertices, q_new.position, radius)\n\n            for q_nearby in near_vertices:\n                if q_nearby is q_new or q_nearby is q_near:\n                    continue\n                # Check if edge q_new->q_nearby would improve cost and is feasible\n                if not self._line_collision_free(q_new.position, q_nearby.position):\n                    continue\n                cost_thru_q_new = q_new.cost + self._distance(q_new.position, q_nearby.position)\n                if cost_thru_q_new < (q_nearby.cost if q_nearby.cost is not None else float('inf')):\n                    # Rewire q_nearby parent from old parent to q_new\n                    # Remove old parent edges\n                    for p in list(q_nearby.parents):\n                        p.children.discard(q_nearby)\n                    q_nearby.parents.clear()\n                    q_nearby.cost = cost_thru_q_new\n                    q_nearby.add_parent(q_new)\n                    q_new.add_child(q_nearby)\n                    # If graph supports edges removal, remove old edges and add new edges\n                    try:\n                        self._graph.add_edge(q_new, q_nearby)\n                    except Exception:\n                        pass\n\n            # Try connecting q_new directly to goal if possible and update cost if better\n            if self._distance(q_new.position, goal_v.position) <= self._max_step:\n                if self._line_collision_free(q_new.position, goal_v.position):\n                    cost_to_goal_through_q_new = q_new.cost + self._distance(q_new.position, goal_v.position)\n                    if cost_to_goal_through_q_new < (goal_v.cost if goal_v.cost is not None else float('inf')):\n                        for p in list(goal_v.parents):\n                            p.children.discard(goal_v)\n                        goal_v.parents.clear()\n                        goal_v.cost = cost_to_goal_through_q_new\n                        goal_v.add_parent(q_new)\n                        q_new.add_child(goal_v)\n\n            # If goal reached and has a valid cost, extract and smooth path\n            if goal_v.cost is not None and goal_v.cost < float('inf') and len(goal_v.parents) > 0:\n                path = self._reconstruct_path(goal_v)\n                path = self._path_smoothing(path)\n\n                # Animate moving the agent along path\n                for v in path:\n                    self.move_agent(v.position)\n                    self.key_frame(ignore_key_frame_skip=True)\n                return\n\n            # key frame for display update per iteration\n            if iter_idx % 10 == 0:\n                self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm": "This algorithm is a hybrid path planner combining strengths of RRT-Connect and informed sampling methods for\n    improved efficiency, path quality, robustness, and success rate. It uses bidirectional trees growing towards sampled\n    points with adaptive pruning and rewiring inspired by RRT* concepts, ensuring smoother, shorter paths.\n    It employs heuristic informed sampling biased towards the goal neighborhood for faster convergence.\n    The planner dynamically shortens and smooths the path during extraction.\n    A 60-second timeout guards against excessive computation time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _timeout_sec: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n        self._max_dist = max(self._get_grid().size.width, self._get_grid().size.height) / 20.0\n        self._iterations = 15000\n        self._timeout_sec = 60.0\n\n    def _get_random_sample_informed(self, c_best: Optional[float]) -> Point:\n        \"\"\"Informed sampling within an ellipse bounded by current best path length c_best.\"\"\"\n        grid = self._get_grid()\n        start = grid.agent.position.to_tensor()\n        goal = grid.goal.position.to_tensor()\n        n_dim = start.shape[0]\n\n        if c_best is None or c_best >= float('inf'):\n            # Uniform sample in space\n            while True:\n                rand_pos = torch.tensor([np.random.randint(0, s) for s in grid.size.values], dtype=torch.float32)\n                sample = Point(*rand_pos.int().tolist())\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Sample inside prolate hyperspheroid ellipse biasing toward goal\n            c_min = (goal - start).norm().item()\n            if c_min < 1e-6:\n                return Point(*goal.int().tolist())\n\n            # Transformation matrix for unit ball to ellipse\n            a1 = (goal - start) / c_min  # unit vector from start to goal\n            I = torch.eye(n_dim)\n            M = a1.unsqueeze(1) @ a1.unsqueeze(0)\n            U = I - M  # orthogonal complement projection\n\n            # Radii of ellipse along axes\n            r1 = c_best / 2.\n            r2 = (c_best ** 2 - c_min ** 2) ** 0.5 / 2.\n\n            while True:\n                # Sample unit ball\n                direction = torch.randn(n_dim)\n                direction /= direction.norm()\n                radius = torch.rand(1).item() ** (1.0 / n_dim)\n                unit_ball_sample = radius * direction\n\n                # Map unit ball sample to ellipse sample\n                ellipse_sample = r1 * a1 + r2 * (U @ unit_ball_sample)\n                sample_pt = (ellipse_sample + (start + goal) / 2.)\n                sample_int = Point(*sample_pt.round().int().tolist())\n\n                if all(0 <= sample_int[i] < s for i, s in enumerate(self._get_grid().size.values)) and grid.is_agent_valid_pos(sample_int):\n                    return sample_int\n\n    def _get_nearest_vertex(self, root_vertices: List[Vertex], point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(root_vertices, point)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Optional[Vertex]:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = dir_vec.norm().item()\n        if dist < 1e-6:\n            return None\n\n        if dist <= self._max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / dist\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_pos_int = Point(*new_pos_tensor.round().int().tolist())\n            q_new_pos = new_pos_int\n\n        if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new_pos)):\n            return None\n\n        return Vertex(q_new_pos)\n\n    def _add_vertex_with_rewiring(self, q_new: Vertex, root_vertices: List[Vertex]) -> None:\n        \"\"\"Add vertex and connect with minimal cost parent within radius; rewire neighbors for better paths.\"\"\"\n        grid = self._get_grid()\n        neighborhood_radius = self._max_dist * 2.5\n\n        # Find neighbors within radius\n        neighbors = self._graph.get_vertices_within_radius(root_vertices, q_new.position, neighborhood_radius)\n        if not neighbors:\n            # Connect to nearest vertex if no neighbors\n            q_near = self._get_nearest_vertex(root_vertices, q_new.position)\n            self._graph.add_edge(q_near, q_new)\n            q_new.cost = (q_near.cost if q_near.cost is not None else 0) + grid.get_movement_cost(q_near.position, q_new.position)\n            return\n\n        # Find best parent from neighbors minimizing cost+distance\n        best_parent = None\n        best_cost = float('inf')\n        cost_from_start = float('inf')\n        for neighbor in neighbors:\n            if neighbor.cost is None:\n                continue\n            tentative_cost = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new.position)\n            if tentative_cost < best_cost and self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position)):\n                best_cost = tentative_cost\n                best_parent = neighbor\n\n        if best_parent is None:\n            # fallback connect to nearest\n            q_near = self._get_nearest_vertex(root_vertices, q_new.position)\n            self._graph.add_edge(q_near, q_new)\n            q_new.cost = (q_near.cost if q_near.cost is not None else 0) + grid.get_movement_cost(q_near.position, q_new.position)\n            return\n\n        # Add edge from best parent\n        self._graph.add_edge(best_parent, q_new)\n        q_new.cost = best_cost\n\n        # Rewire neighbors if better through q_new\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            if neighbor.cost is None:\n                continue\n            cost_through_qnew = q_new.cost + grid.get_movement_cost(q_new.position, neighbor.position)\n            if cost_through_qnew < neighbor.cost and self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                # Remove old parent edges\n                for p in list(neighbor.parents):\n                    self._graph.remove_edge(p, neighbor)\n                # Add new better parent edge\n                self._graph.add_edge(q_new, neighbor)\n                neighbor.cost = cost_through_qnew\n\n    def _try_connect_trees(self) -> Optional[Tuple[Vertex, Vertex]]:\n        \"\"\"Try to connect root vertices of the two trees to form path, return connected vertices or None.\"\"\"\n        start_roots = [self._graph.root_vertex_start]\n        goal_roots = [self._graph.root_vertex_goal]\n\n        for sv in list(start_roots):\n            for gv in list(goal_roots):\n                if Map.get_distance(sv.position, gv.position) <= self._max_dist:\n                    # Check if can connect directly\n                    line_seq = self._get_grid().get_line_sequence(sv.position, gv.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        return sv, gv\n        return None\n\n    def _extract_path(self, connect_pair: Tuple[Vertex, Vertex]) -> None:\n        \"\"\"Extract and smooth path from start to goal through connected pair vertices, animate movement.\"\"\"\n        start_vertex, goal_vertex = connect_pair\n\n        # Trace backward from start vertex to root start\n        path_start = [start_vertex]\n        while len(path_start[-1].parents) != 0:\n            parent = next(iter(path_start[-1].parents))\n            path_start.append(parent)\n        path_start.reverse()\n\n        # Trace backward from goal vertex to root goal\n        path_goal = [goal_vertex]\n        while len(path_goal[-1].parents) != 0:\n            parent = next(iter(path_goal[-1].parents))\n            path_goal.append(parent)\n\n        # Combine paths\n        full_path = path_start + path_goal\n\n        # Attempt path smoothing by shortcutting intermediate points\n        smoothed_path = self._smooth_path(full_path)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"Attempt to shortcut path by checking if line between non-adjacent vertices is valid.\"\"\"\n        if len(path) < 3:\n            return path\n\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(path[i].position, path[j].position)):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _update_costs_on_root(self, root_vertex: Vertex) -> None:\n        \"\"\"Propagate costs from root vertex through children (BFS).\"\"\"\n        root_vertex.cost = 0\n        queue = [root_vertex]\n        while queue:\n            current = queue.pop(0)\n            for child in current.children:\n                cost = current.cost + self._get_grid().get_movement_cost(current.position, child.position)\n                if child.cost is None or cost < child.cost:\n                    child.cost = cost\n                    queue.append(child)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n\n        # Initialize costs for start and goal root vertices\n        self._graph.root_vertex_start.cost = 0\n        self._graph.root_vertex_goal.cost = 0\n\n        start_time = time.time()\n        best_path_cost = float('inf')\n        best_connect_pair = None\n\n        for i in range(self._iterations):\n            if time.time() - start_time > self._timeout_sec:\n                # Fail on timeout\n                break\n\n            c_best = best_path_cost if best_path_cost != float('inf') else None\n            # Sample point using informed sampling\n            q_rand = self._get_random_sample_informed(c_best)\n\n            # Select tree to extend (alternate or based on heuristic)\n            extend_tree_idx = i % 2\n            root_vertex = self._graph.root_vertices[extend_tree_idx]\n\n            q_near = self._get_nearest_vertex([root_vertex], q_rand)\n            q_new = self._get_new_vertex(q_near, q_rand)\n            if q_new is None:\n                self.key_frame()\n                continue\n\n            # Add vertex with rewiring to improve path quality in that tree\n            self._add_vertex_with_rewiring(q_new, [root_vertex])\n\n            # Update costs on this tree from root\n            self._update_costs_on_root(root_vertex)\n\n            # Try to connect the other tree to this newly added vertex\n            other_tree_root = self._graph.root_vertices[1 - extend_tree_idx]\n            q_near_other = self._get_nearest_vertex([other_tree_root], q_new.position)\n\n            dist = Map.get_distance(q_near_other.position, q_new.position)\n            if dist <= self._max_dist:\n                line_seq = grid.get_line_sequence(q_near_other.position, q_new.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Add connection edge\n                    self._graph.add_edge(q_near_other, q_new) if extend_tree_idx == 1 else self._graph.add_edge(q_new, q_near_other)\n\n                    # Update costs on other tree root after adding connection edge\n                    self._update_costs_on_root(other_tree_root)\n\n                    # Calculate combined path cost\n                    cost_start = self._graph.root_vertex_start.cost if self._graph.root_vertex_start.cost else 0\n                    cost_goal = self._graph.root_vertex_goal.cost if self._graph.root_vertex_goal.cost else 0\n                    total_cost = (q_new.cost if q_new.cost is not None else 0) + (q_near_other.cost if q_near_other.cost is not None else 0) + dist\n\n                    if total_cost < best_path_cost:\n                        best_path_cost = total_cost\n                        if extend_tree_idx == 0:\n                            best_connect_pair = (q_new, q_near_other)\n                        else:\n                            best_connect_pair = (q_near_other, q_new)\n\n                    # Extract and animate path\n                    if best_connect_pair:\n                        self._extract_path(best_connect_pair)\n                        break\n\n            # Alternate trees\n            self._graph.reverse_root_vertices()\n            self.key_frame()\n\n        # If no path found in time and best_connect_pair exists, extract it\n        if best_connect_pair:\n            self._extract_path(best_connect_pair)",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm": "This algorithm is a hybrid sample-based planner combining principles from SPRM and RRT*.\n    It enhances planning efficiency and path quality by:\n      - Using adaptive sampling biased towards the goal and unexplored regions\n      - Incrementally rewiring the graph for better paths (inspired by RRT*)\n      - Connecting vertices in a cyclic fashion and pruning longer edges to keep graph manageable\n      - Using radius-based near vertex search that adapts with vertex density to balance connectivity and performance\n      - Applying dynamic edge validation with bresenhamline to reduce invalid expansions\n      - Early termination after success or if path quality improvement stalls\n      - Active timeout management (stops if planning exceeds 60s)\n    This results in improved success rate, smoother and shorter paths, and reduced search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n    _max_extend_dist: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 300\n        self._max_radius = 12.0   # radius for near neighbors, tuned for connectivity\n        self._max_extend_dist = 6.0  # max distance to extend toward sampled point\n\n        V: List[Vertex] = list()\n        for _ in range(self._V_size):\n            q_rand: Point = self._biased_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n\n        self._graph = gen_cyclic_graph(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            V,\n        )\n        self._graph.edges_removable = True  # allow dynamic rewiring/removal for path quality\n        self._init_displays()\n\n    def _biased_sample(self) -> Point:\n        \"\"\"\n        Sampling strategy biased toward the goal or unexplored space.\n        Probability 0.2 to sample exactly the goal position.\n        Probability 0.8 sample uniformly valid anywhere else.\n        \"\"\"\n        if torch.rand(1).item() < 0.2:\n            return self._get_grid().goal.position\n        while True:\n            sample = Point(\n                *[\n                    torch.randint(0, self._get_grid().size[i], (1,)).item()\n                    for i in range(self._get_grid().size.n_dim)\n                ]\n            )\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _near(self, vertex: Vertex, radius: Optional[float] = None) -> List[Vertex]:\n        r = radius if radius is not None else self._max_radius\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, r)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / norm\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _is_edge_valid(self, from_pos: Point, to_pos: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _rewire(self, vertex: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"\n        Attempts to improve the existing path tree by rewiring neighbors to vertex if it reduces cost.\n        \"\"\"\n        for neighbor in neighbors:\n            if neighbor is vertex:\n                continue\n            if self._is_edge_valid(vertex.position, neighbor.position):\n                cost_current = neighbor.cost if neighbor.cost is not None else float(\"inf\")\n                cost_new = vertex.cost + self._get_grid().get_movement_cost(vertex.position, neighbor.position)\n                if cost_new < cost_current:\n                    # Remove other parents that produce higher cost edges if removable\n                    for parent in list(neighbor.parents):\n                        if self._graph.edges_removable:\n                            self._graph.remove_edge(parent, neighbor)\n                    # Add new edge from vertex to neighbor\n                    self._graph.add_edge(vertex, neighbor)\n                    neighbor.cost = cost_new\n\n    def _extract_path(self) -> None:\n        goal_vertex = self._graph.root_vertex_goal\n        agent_vertex = self._graph.root_vertex_start\n\n        # Reconstruct path in forward direction using connectivity dict index\n        if goal_vertex not in agent_vertex.connectivity:\n            return\n\n        current_vertex = agent_vertex\n        path: List[Vertex] = []\n        while current_vertex is not goal_vertex:\n            current_vertex = current_vertex.connectivity[goal_vertex]\n            path.append(current_vertex)\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _initialize_costs(self) -> None:\n        \"\"\"\n        Initialize costs for all vertices starting from agent position.\n        Uses Dijkstra-like propagation with BFS.\n        \"\"\"\n        INF = float(\"inf\")\n        for v in self._graph.root_vertices:\n            v.cost = INF\n        start = self._graph.root_vertex_start\n        start.cost = 0.0\n\n        # BFS queue for cost relaxation\n        queue: List[Vertex] = [start]\n        visited: Set[Vertex] = {start}\n        while queue:\n            current = queue.pop(0)\n            cur_cost = current.cost\n            neighbors = list(current.connectivity)\n            for neighbor in neighbors:\n                step_cost = self._get_grid().get_movement_cost(current.position, neighbor.position)\n                new_cost = cur_cost + step_cost\n                if neighbor.cost is None or neighbor.cost > new_cost:\n                    neighbor.cost = new_cost\n                    if neighbor not in visited:\n                        queue.append(neighbor)\n                        visited.add(neighbor)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        max_time = 60.0  # max allowed time in seconds\n\n        # Set initial cost and graph connectivity for start vertex\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n\n        # Attempt to incrementally connect graph for max iterations or until timeout\n        for iteration in range(self._V_size * 8):\n            if (time.time() - start_time) > max_time:\n                # Planning failed due to timeout\n                return\n\n            # Sample random point biased towards goal/unexplored\n            q_sample = self._biased_sample()\n\n            # Find nearest vertex to sample in graph\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n            # Steer towards sample with max extend distance\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_extend_dist)\n\n            # Check if position already sampled approximately (avoid duplicates)\n            near_to_new = self._near(Vertex(q_new))\n            if any(torch.dist(torch.tensor(q_new.values), torch.tensor(v.position.values)) < 1e-2 for v in near_to_new):\n                # Skip too close samples for efficiency\n                continue\n\n            # Validate edge from q_near to q_new (collision free?)\n            if not self._is_edge_valid(q_near.position, q_new):\n                continue\n\n            # Create vertex and add it to graph\n            v_new = Vertex(q_new, store_connectivity=True)\n            v_new.cost = float(\"inf\")  # initialize cost as infinity\n\n            # Add vertex to graph's root vertex list for connectivity queries\n            self._graph.root_vertices.append(v_new)\n\n            # Add edge from nearest vertex to new vertex\n            self._graph.add_edge(q_near, v_new)\n\n            # Update cost to new vertex\n            v_new.cost = q_near.cost + self._get_grid().get_movement_cost(q_near.position, v_new.position)\n\n            # Find neighbors within radius (adaptive based on exploration density)\n            neighbors = self._near(v_new)\n\n            # Connect/rewire neighbors if new connections are better (improves path cost)\n            for neighbor in neighbors:\n                if neighbor is v_new:\n                    continue\n                if self._is_edge_valid(v_new.position, neighbor.position):\n                    cost_through_new = v_new.cost + self._get_grid().get_movement_cost(v_new.position, neighbor.position)\n                    if neighbor.cost is None or cost_through_new < neighbor.cost:\n                        self._graph.add_edge(v_new, neighbor)\n                        self._graph.add_edge(neighbor, v_new)\n                        neighbor.cost = cost_through_new\n\n            self._rewire(v_new, neighbors)\n\n            self.key_frame()\n\n            # Check connectivity: if goal connected in start's connectivity map, path found\n            if goal_vertex in start_vertex.connectivity:\n                # Initialize cost estimates across graph for smooth extraction\n                self._initialize_costs()\n                self._extract_path()\n                return",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm": "This algorithm implements an enhanced RRT*-inspired bidirectional sampling approach combined with local\n    rewiring and path smoothing to improve planning efficiency, path quality, and robustness. It samples new points\n    from both the start and goal trees to rapidly explore the space, connects vertices using a radius-based neighborhood,\n    performs rewiring to optimize path cost, and includes a post-processing step that smooths the extracted path.\n    Designed to handle varying map sizes, the search fails if planning exceeds 60 seconds. The approach balances \n    exploration, exploitation, and refinement to produce shorter, smoother paths with improved success rates.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_iter: int = 10000\n    _max_dist: float\n    _rewire_radius: float\n    _start_vertex: Vertex\n    _goal_vertex: Vertex\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        agent_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n\n        # Initialize start and goal vertices with connectivity stored\n        self._start_vertex = Vertex(agent_pos, store_connectivity=True)\n        self._goal_vertex = Vertex(goal_pos, store_connectivity=True)\n\n        # Empty initial set of vertices: add start & goal as roots plus no samples yet\n        self._graph = gen_cyclic_graph(\n            self._services,\n            self._start_vertex,\n            self._goal_vertex,\n            []\n        )\n        self._graph.edges_removable = True\n\n        # Set parameters adaptive to map size (heuristic)\n        map_diag = torch.norm(torch.tensor(self._get_grid().size.values, dtype=torch.float))\n        self._max_dist = max(5.0, float(map_diag.item()) * 0.1)  # max extension distance ~10% map diag\n        self._rewire_radius = max(8.0, float(map_diag.item()) * 0.15)  # radius for near vertices rewiring\n\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Uniformly sample a random valid point in the map.\"\"\"\n        size = self._get_grid().size\n        while True:\n            coords = [np.random.randint(0, size[i]) for i in range(size.n_dim)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_v: Vertex, to_p: Point, max_dist: float) -> Vertex:\n        \"\"\"Generate a new vertex in direction from 'from_v' toward 'to_p' limited by max_dist.\"\"\"\n        from_tensor = from_v.position.to_tensor()\n        to_tensor = to_p.to_tensor()\n        direction = to_tensor - from_tensor\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            new_pos = to_p\n        else:\n            direction_normalized = direction / dist\n            new_pos = Point.from_tensor(from_tensor + max_dist * direction_normalized)\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _near_vertices(self, point: Point) -> List[Vertex]:\n        \"\"\"Get list of vertices within rewire radius from point in graph's root vertices.\"\"\"\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, point, self._rewire_radius)\n\n    def _is_collision_free(self, from_p: Point, to_p: Point) -> bool:\n        \"\"\"Check if path between from_p and to_p is free of obstacles.\"\"\"\n        line_seq = self._get_grid().get_line_sequence(from_p, to_p)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _choose_parent(self, near_vertices: List[Vertex], new_vertex: Vertex) -> Optional[Vertex]:\n        \"\"\"Choose best parent minimizing cost + movement cost among neighbors that are collision free.\"\"\"\n        min_cost = None\n        best_parent = None\n        for vertex in near_vertices:\n            if vertex.position == new_vertex.position:\n                continue\n            if not self._is_collision_free(vertex.position, new_vertex.position):\n                continue\n            cost_to_new = vertex.cost if vertex.cost is not None else 0.0\n            move_cost = self._get_grid().get_movement_cost(vertex.position, new_vertex.position)\n            total_cost = cost_to_new + move_cost\n            if (min_cost is None) or (total_cost < min_cost):\n                min_cost = total_cost\n                best_parent = vertex\n        if best_parent is not None:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], new_vertex: Vertex) -> None:\n        \"\"\"Try to shortcut existing vertices via new_vertex if cost improves and path is collision free.\"\"\"\n        for vertex in near_vertices:\n            if vertex == new_vertex:\n                continue\n            if vertex.cost is None:\n                continue\n            if not self._is_collision_free(new_vertex.position, vertex.position):\n                continue\n            move_cost = self._get_grid().get_movement_cost(new_vertex.position, vertex.position)\n            new_cost = new_vertex.cost + move_cost\n            if vertex.cost > new_cost:\n                # Remove old parent edge and add new edge from new_vertex\n                for parent in list(vertex.parents):\n                    self._graph.remove_edge(parent, vertex)\n                self._graph.add_edge(new_vertex, vertex)\n                vertex.cost = new_cost\n\n    def _extract_path(self) -> List[Vertex]:\n        \"\"\"Extract the path by walking from goal to start via parents with min cost.\"\"\"\n        path = []\n        current = self._goal_vertex\n        # If the goal vertex cost is None, treat it as infinity - no path found\n        if current.cost is None:\n            return path\n\n        # We trace the lowest cost parents backward to the start.\n        while current != self._start_vertex:\n            path.append(current)\n            if not current.parents:\n                break\n            # Among parents choose one with min cost\n            current = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n        path.append(self._start_vertex)\n        path.reverse()\n        return path\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"Smooth the path by shortcutting between non-consecutive vertices when collision free.\"\"\"\n        if not path or len(path) < 3:\n            return path\n        smooth_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            # Try to find farthest vertex shortcut reachable\n            for j in range(len(path) - 1, idx, -1):\n                if self._is_collision_free(path[idx].position, path[j].position):\n                    next_idx = j\n                    break\n            smooth_path.append(path[next_idx])\n            idx = next_idx\n        return smooth_path\n\n    def _bidirectional_sample(self) -> Point:\n        \"\"\"Generate a random sample choosing goal bias with probability 0.1 to speed convergence.\"\"\"\n        if np.random.rand() < 0.1:\n            return self._goal_vertex.position\n        else:\n            return self._get_random_sample()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        # Initialize root vertices cost to zero\n        self._start_vertex.cost = 0.0\n        self._goal_vertex.cost = None  # Goal cost unknown initially\n\n        # Vertices storage: start tree and goal tree roots plus sampled vertices\n        sampled_vertices: List[Vertex] = []\n\n        # Alternate between extending start and goal trees\n        extend_start = True\n\n        for iter_count in range(self._max_iter):\n            # Time check\n            elapsed = time.time() - start_time\n            if elapsed > 60.0:\n                # Failed to find path within time limit\n                return  # Exit _find_path_internal without path extraction\n\n            # Sample point\n            q_sample = self._bidirectional_sample()\n\n            if extend_start:\n                tree_root_list = [self._start_vertex] + sampled_vertices\n            else:\n                tree_root_list = [self._goal_vertex] + sampled_vertices\n\n            # Find nearest vertex in the current tree\n            q_near = self._graph.get_nearest_vertex(tree_root_list, q_sample)\n            if q_near.position == q_sample:\n                # Sampled same point, try next iteration\n                extend_start = not extend_start\n                self.key_frame()\n                continue\n\n            # Steer towards sample within max_dist\n            q_new = self._steer(q_near, q_sample, self._max_dist)\n\n            if q_new.position == q_near.position:\n                extend_start = not extend_start\n                self.key_frame()\n                continue\n\n            if not self._is_collision_free(q_near.position, q_new.position):\n                extend_start = not extend_start\n                self.key_frame()\n                continue\n\n            # Find nearby vertices for potential better parent and rewiring\n            near_vertices = self._near_vertices(q_new.position)\n            if not near_vertices:\n                # No nearby vertices, connect to nearest vertex only\n                q_new.cost = (q_near.cost if q_near.cost is not None else 0.0) + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n                self._graph.add_edge(q_near, q_new)\n            else:\n                # Choose best parent among near vertices\n                best_parent = self._choose_parent(near_vertices, q_new)\n                if best_parent is None:\n                    # fallback: connect to q_near directly if no better parent found\n                    q_new.cost = (q_near.cost if q_near.cost is not None else 0.0) + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n                    best_parent = q_near\n                self._graph.add_edge(best_parent, q_new)\n                # Attempt to rewire neighbors using new vertex\n                self._rewire(near_vertices, q_new)\n\n            sampled_vertices.append(q_new)\n\n            # Attempt connection to the opposite tree for bidirectional path completion\n            other_tree_roots = [self._goal_vertex] if extend_start else [self._start_vertex]\n            # Also consider sampled vertices for opposite tree\n            other_tree_roots += sampled_vertices\n\n            q_connect_candidates = self._graph.get_vertices_within_radius(other_tree_roots, q_new.position, self._max_dist)\n            connected = False\n            for q_other in q_connect_candidates:\n                if q_other == q_new:\n                    continue\n                if self._is_collision_free(q_new.position, q_other.position):\n                    # Connect trees by adding bidirectional edges\n                    self._graph.add_edge(q_new, q_other)\n                    self._graph.add_edge(q_other, q_new)\n                    # Update costs if possible\n                    if q_other.cost is None and q_new.cost is not None:\n                        q_other.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_other.position)\n                    elif q_new.cost is None and q_other.cost is not None:\n                        q_new.cost = q_other.cost + self._get_grid().get_movement_cost(q_other.position, q_new.position)\n\n                    connected = True\n                    break\n\n            # Check if start and goal are connected\n            if self._goal_vertex in self._start_vertex.connectivity:\n                path = self._extract_path()\n                if not path:\n                    # If extraction failed, continue searching\n                    extend_start = not extend_start\n                    self.key_frame()\n                    continue\n                # Smooth the extracted path\n                smooth_path = self._smooth_path(path)\n\n                # Animate movement along smooth path\n                for vertex in smooth_path:\n                    self.move_agent(vertex.position)\n                    self.key_frame(ignore_key_frame_skip=True)\n                return\n\n            extend_start = not extend_start\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm": "This algorithm implements an improved variant of the RRT* approach with bi-directional tree \n    growth and rewiring to optimize path quality and convergence speed. It samples points \n    intelligently within the map's valid regions, incrementally builds two trees rooted at \n    start and goal, attempts to connect them, and rewires nearby vertices to reduce overall \n    cost. The algorithm enforces collision-free checks along edges and stops if a path \n    connecting start and goal is found or if the 60-second time limit is exceeded. \n    It balances exploration and exploitation for improved efficiency, robustness, \n    better path quality, and smoother, shorter paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _rewire_radius: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        # Initialize Forest with start and goal vertices\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True  # allow rewiring edges\n        self._max_dist = 15.0                  # max extension distance (tuneable)\n        self._rewire_radius = 20.0             # radius for rewiring neighbors (tuneable)\n        self._iterations = 10000               # max number of iterations\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Sample random valid point inside map bounds and valid for agent position.\n        \"\"\"\n        grid = self._get_grid()\n        size = grid.size\n        while True:\n            rand_coords = []\n            for d in range(size.n_dim):\n                rand_coords.append(np.random.uniform(0, size[d]))\n            sample = Point(*rand_coords)\n            # Round coordinates to grid integers if grid is integer-based\n            # but keep float for smoothness\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _steer(self, from_v: Vertex, to_p: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        Returns a new vertex in direction from from_v to to_p\n        at distance max_dist or less if closer.\n        \"\"\"\n        direction = to_p.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            new_pos = to_p\n        else:\n            direction_normalized = direction / dist\n            new_tensor = from_v.position.to_tensor() + max_dist * direction_normalized\n            new_pos = Point.from_tensor(new_tensor)\n        return Vertex(new_pos)\n\n    def _near_vertices(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        \"\"\"\n        Returns all vertices within radius of given point.\n        \"\"\"\n        return [v for v in vertices if self._distance(v.position, point) <= radius]\n\n    def _cost(self, vertex: Vertex) -> float:\n        \"\"\"\n        Returns cost to reach vertex from root.\n        \"\"\"\n        return vertex.cost if vertex.cost is not None else float('inf')\n\n    def _line_valid(self, start: Point, end: Point) -> bool:\n        \"\"\"\n        Check if line between two points is valid (collision-free).\n        \"\"\"\n        line_points = self._get_grid().get_line_sequence(start, end)\n        return self._get_grid().is_valid_line_sequence(line_points)\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Attempt to update edges to reduce cost from new_vertex to nearby vertices.\n        \"\"\"\n        grid = self._get_grid()\n        for near_v in near_vertices:\n            if near_v == new_vertex or near_v == self._graph.root_vertex_start:\n                continue\n            cost_through_new = self._cost(new_vertex) + grid.get_movement_cost(new_vertex.position, near_v.position)\n            if cost_through_new < self._cost(near_v) and self._line_valid(new_vertex.position, near_v.position):\n                # Remove old parent edge\n                for parent in near_v.parents:\n                    self._graph.remove_edge(parent, near_v)\n                # Add edge new_vertex->near_v\n                self._graph.add_edge(new_vertex, near_v)\n                near_v.cost = cost_through_new\n\n    def _find_min_cost_parent(self, near_vertices: List[Vertex], new_vertex: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        Among near vertices, find the parent that offers minimum cost path to new_vertex.\n        \"\"\"\n        grid = self._get_grid()\n        min_cost = float('inf')\n        min_parent = None\n        for near_v in near_vertices:\n            if self._line_valid(near_v.position, new_vertex.position):\n                cost_through_near = self._cost(near_v) + grid.get_movement_cost(near_v.position, new_vertex.position)\n                if cost_through_near < min_cost:\n                    min_cost = cost_through_near\n                    min_parent = near_v\n        return min_parent\n\n    def _extract_path(self, connecting_vertex_start: Vertex, connecting_vertex_goal: Vertex) -> None:\n        \"\"\"\n        Trace back path from start to goal by joining found connecting vertices.\n        \"\"\"\n        path_from_start = [connecting_vertex_start]\n        while len(path_from_start[-1].parents) != 0:\n            for p in path_from_start[-1].parents:\n                path_from_start.append(p)\n                break\n        path_from_start.reverse()\n\n        path_from_goal = [connecting_vertex_goal]\n        while len(path_from_goal[-1].parents) != 0:\n            for p in path_from_goal[-1].parents:\n                path_from_goal.append(p)\n                break\n\n        full_path = path_from_start + path_from_goal\n\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _can_connect(self, v1: Vertex, v2: Vertex) -> bool:\n        \"\"\"\n        Check if edge between v1 and v2 is valid.\n        \"\"\"\n        return self._line_valid(v1.position, v2.position)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start_root = self._graph.root_vertex_start\n        goal_root = self._graph.root_vertex_goal\n\n        start_root.cost = 0.0\n        goal_root.cost = 0.0\n\n        start_vertices = [start_root]\n        goal_vertices = [goal_root]\n\n        all_vertices = start_vertices + goal_vertices\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        start_tree = True  # flag to switch trees for bi-directional growth\n\n        start_time = time.time()\n\n        for _ in range(self._iterations):\n\n            if time.time() - start_time > 60:\n                # Fail due to timeout\n                break\n\n            q_rand = self._get_random_sample()\n\n            active_tree = tree_start if start_tree else tree_goal\n            other_tree = tree_goal if start_tree else tree_start\n\n            # Find nearest vertex from active tree\n            q_near = min(active_tree, key=lambda v: self._distance(v.position, q_rand))\n\n            # Generate new vertex in direction of q_rand\n            q_new = self._steer(q_near, q_rand, self._max_dist)\n            if not self._line_valid(q_near.position, q_new.position):\n                # Cannot reach q_new from q_near\n                self.key_frame()\n                continue\n\n            # Identify neighbors for rewiring and parent selection\n            radius = self._rewire_radius\n            near_vertices = self._near_vertices(active_tree, q_new.position, radius)\n\n            # Choose parent with minimal cost\n            min_parent = self._find_min_cost_parent(near_vertices, q_new)\n            if min_parent is None:\n                # No valid parent found, skip\n                self.key_frame()\n                continue\n\n            # Set cost and add edge from best parent to new vertex\n            q_new.cost = self._cost(min_parent) + grid.get_movement_cost(min_parent.position, q_new.position)\n            self._graph.add_edge(min_parent, q_new)\n\n            # Add new vertex to active tree and all vertices list\n            active_tree.append(q_new)\n            all_vertices.append(q_new)\n\n            # Rewire nearby vertices if cheaper via q_new\n            self._rewire(q_new, near_vertices)\n\n            # Try to connect the other tree to q_new\n            q_near_other = min(other_tree, key=lambda v: self._distance(v.position, q_new.position))\n            if self._distance(q_near_other.position, q_new.position) <= self._max_dist and self._can_connect(q_near_other, q_new):\n                # Connect trees: add edge\n                if start_tree:\n                    self._graph.add_edge(q_new, q_near_other)\n                else:\n                    self._graph.add_edge(q_near_other, q_new)\n\n                # Extract path using q_new and q_near_other as connecting vertices\n                self._extract_path(q_new if start_tree else q_near_other, \n                                   q_near_other if start_tree else q_new)\n                break\n\n            # Switch trees\n            start_tree = not start_tree\n\n            self.key_frame()"{
     "operator": "e1",
     "algorithm": "This algorithm is inspired by the advantages of RRT* and PRM but introduces a hybrid approach called\n    Adaptive Batch Informed RRT* with Smoothing (ABIRRT*-S).\n\n    Key improvements:\n    - Adaptive sampling: samples are biased progressively towards the heuristic ellipsoidal informed region to speed up convergence.\n    - Batch processing: samples are inserted and rewired in batches, improving path quality and reducing per-iteration overhead.\n    - Cyclic graph usage: allows multiple paths and rewiring to enhance robustness and path shortening.\n    - Early stopping by path quality improvements and time limit (60 seconds).\n    - Post-processing smoothing of the resulting path to reduce sharp turns.\n    - Dynamic radius update based on vertex count and dimension for efficient neighbor querying.\n    - Uses torch tensors for efficient distance calculations.\n    - Planning stops when a path is found and converges to a near-optimal solution or timeout is reached.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    def _get_random_sample(self, informed_center: Optional[Point] = None, informed_radii: Optional[List[float]] = None) -> Point:\n        grid_size = self._get_grid().size\n        dim = grid_size.n_dim\n\n        if informed_center is None or informed_radii is None:\n            # Uniform sample within map\n            while True:\n                rand_pos = np.random.randint(0, grid_size.values, dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling within an n-dimensional ellipsoid around current best path\n        for _ in range(100):  # limit tries to find a valid point in ellipsoid\n            # Sample uniform point in unit n-ball using normal distribution method\n            x = np.random.normal(size=dim)\n            norm = np.linalg.norm(x)\n            x_unit = x / norm if norm > 0 else x\n            r = np.random.random() ** (1.0 / dim)  # radius proportional sampling\n            sample_scaled = x_unit * r\n\n            # Scale by ellipsoid radii and translate by center\n            sample_coords = informed_center.values + np.multiply(sample_scaled, informed_radii)\n            sample_point = Point(*np.round(sample_coords).astype(int))\n\n            # Clamp sample to map boundaries\n            clamped = []\n            for i, val in enumerate(sample_point.values):\n                low = 0\n                high = grid_size[i] - 1\n                clamped.append(min(max(val, low), high))\n            sample_point = Point(*clamped)\n\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # Fallback uniform sampling\n        return self._get_random_sample()\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        direction = to_point.to_tensor() - from_vertex.position.to_tensor()\n        dist = torch.norm(direction).item()\n        if dist <= max_dist:\n            return Vertex(to_point)\n        direction_normalized = direction / dist\n        new_pos_tensor = from_vertex.position.to_tensor() + max_dist * direction_normalized\n        new_pos = Point(*torch.round(new_pos_tensor).int().tolist())\n        return Vertex(new_pos)\n\n    def _get_nearest_vertex(self, point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, point)\n\n    def _get_near_vertices(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _collision_free(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Point]:\n        path = []\n        v = goal_vertex\n        while True:\n            path.append(v.position)\n            if len(v.parents) == 0:\n                break\n            # Pick min cost parent (support multiple parents)\n            min_parent = None\n            min_cost = float('inf')\n            for p in v.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_parent = p\n            v = min_parent\n        return path[::-1]\n\n    def _smooth_path(self, path: List[Point]) -> List[Point]:\n        # Simple path smoothing by shortcutting collidable-free segments\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._collision_free(path[i], path[j]):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _compute_informed_ellipse(self, start: Point, goal: Point, c_best: float) -> (Point, List[float]):\n        # Compute ellipsoid center & axes lengths for informed sampling\n        c_min = self._distance(start, goal)\n        if c_best < float('inf'):\n            center_t = (start.to_tensor() + goal.to_tensor()) / 2.0\n            center = Point(*center_t.tolist())\n            dim = start.n_dim\n            a1 = (goal.to_tensor() - start.to_tensor()) / self._distance(start, goal)\n            # Construct orthonormal basis via SVD or Gram-Schmidt (simplified here)\n            # Ellipsoid radii: [c_best/2, sqrt(c_best^2 - c_min^2)/2, ..., sqrt(c_best^2 - c_min^2)/2]\n            r1 = c_best / 2.0\n            rothers = np.sqrt(max(c_best ** 2 - c_min ** 2, 0)) / 2.0\n            radii = [r1] + [rothers] * (dim - 1)\n            return center, radii\n        else:\n            # No path found yet => sample entire space\n            return None, None\n\n    def _batch_rewire(self, new_vertex: Vertex, near_vertices: List[Vertex], max_dist: float) -> None:\n        # Find best parent from neighbors and rewire other neighbors if improves cost\n        best_parent = None\n        best_cost = float('inf')\n        for near in near_vertices:\n            if near.cost is None:\n                continue\n            dist_to_new = self._distance(near.position, new_vertex.position)\n            if dist_to_new > max_dist:\n                continue\n            if not self._collision_free(near.position, new_vertex.position):\n                continue\n            cost = near.cost + dist_to_new\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = near\n\n        if best_parent is None:\n            return\n\n        new_vertex.cost = best_cost\n        self._graph.add_edge(best_parent, new_vertex)\n\n        # Rewire neighbors\n        for near in near_vertices:\n            if near == best_parent or near.cost is None:\n                continue\n            dist_new_to_near = self._distance(new_vertex.position, near.position)\n            if dist_new_to_near > max_dist:\n                continue\n            if not self._collision_free(new_vertex.position, near.position):\n                continue\n\n            cost_through_new = new_vertex.cost + dist_new_to_near\n            if cost_through_new < near.cost:\n                # Remove old parent edge\n                old_parents = list(near.parents)\n                for old_p in old_parents:\n                    self._graph.remove_edge(old_p, near)\n                near.cost = cost_through_new\n                # Add new edge\n                self._graph.add_edge(new_vertex, near)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        max_iterations = 10000\n        max_dist = 15.0\n        dimension = self._get_grid().size.n_dim\n        max_radius = 50.0\n        lambda_rrt_star = 30.0\n\n        best_goal_cost = float('inf')\n        best_goal_vertex = None\n\n        batch_size = 15\n        samples: List[Point] = []\n\n        # Insert initial vertices\n        self.key_frame()\n\n        for iteration in range(max_iterations):\n\n            elapsed = time.time() - start_time\n            if elapsed > 60.0:  # timeout hard stop\n                break\n\n            # Compute informed sampling ellipsoid center and radii if path found\n            informed_center, informed_radii = self._compute_informed_ellipse(\n                self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position, best_goal_cost\n            )\n\n            # Sample multiple points (batch) using adaptive informed sampling\n            samples.clear()\n            for _ in range(batch_size):\n                sample = self._get_random_sample(informed_center, informed_radii)\n                samples.append(sample)\n\n            for sample in samples:\n                nearest = self._get_nearest_vertex(sample)\n                if nearest.position == sample:\n                    continue\n                new_vertex = self._steer(nearest, sample, max_dist)\n                if not self._collision_free(nearest.position, new_vertex.position):\n                    continue\n\n                # Compute radius for near vertices (adaptive)\n                card_v = float(self._graph.size) + 1e-6\n                radius = min(lambda_rrt_star * ((torch.log(torch.tensor(card_v)) / card_v) ** (1.0 / dimension)), max_radius)\n\n                near_vertices = self._get_near_vertices(new_vertex, radius)\n                self._batch_rewire(new_vertex, near_vertices, max_dist)\n\n                # Check goal reaching\n                if self._get_grid().is_agent_in_goal_radius(new_vertex.position):\n                    dist_to_goal = self._distance(new_vertex.position, self._graph.root_vertex_goal.position)\n                    path_cost = (new_vertex.cost if new_vertex.cost is not None else float('inf')) + dist_to_goal\n\n                    if path_cost < best_goal_cost:\n                        best_goal_cost = path_cost\n                        # Connect new_vertex to goal vertex for final path extraction\n                        goal_vertex = Vertex(self._graph.root_vertex_goal.position)\n                        goal_vertex.cost = path_cost\n                        self._graph.add_edge(new_vertex, goal_vertex)\n                        best_goal_vertex = goal_vertex\n\n            self.key_frame()\n\n            # Stop early if path cost converges sufficiently (small improvement threshold)\n            if best_goal_vertex is not None and iteration % 50 == 0:\n                # Extract, smooth, and re-set path for visualization\n                raw_path = self._extract_path(best_goal_vertex)\n                smooth_path = self._smooth_path(raw_path)\n                for p in smooth_path:\n                    self.move_agent(p)\n                    self.key_frame(ignore_key_frame_skip=True)\n                # Update best cost more conservatively\n                if best_goal_cost < float('inf'):\n                    break\n\n        # Final fallback: if path found, display smoothed path\n        if best_goal_vertex is not None:\n            final_raw_path = self._extract_path(best_goal_vertex)\n            final_path = self._smooth_path(final_raw_path)\n            for p in final_path:\n                self.move_agent(p)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
,
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm": "This algorithm is an enhanced sample-based path planner inspired by SPRM and RRT techniques.\n    It uses adaptive sampling density based on distance to goal, dynamically adjusts the connection radius,\n    and employs pruning to reduce graph complexity. The planner uses a cyclic graph structure with\n    improved rewiring to enhance path quality and robustness, while performing early goal checking.\n    A timeout mechanism is implemented to terminate the search after 60 seconds to ensure timely failure.\n    This design balances planning efficiency, path smoothness and success rate across varying map sizes.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n    _max_dist_edge: float\n    _timeout_sec: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        grid = self._get_grid()\n        # Sample size scales with map area to better manage large maps\n        area = grid.size.width * grid.size.height\n        self._V_size = min(max(int(area * 0.5), 150), 600)\n        # max radius adaptive to map size (20% of max dimension, clipped)\n        max_dim = max(grid.size.width, grid.size.height)\n        self._max_radius = min(max_dim * 0.25, 25)\n        self._max_dist_edge = min(max_dim * 0.15, 15)\n        self._timeout_sec = 60.0\n\n        V: List[Vertex] = []\n        for _ in range(self._V_size):\n            q_rand = self._get_informed_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n\n        start_vertex = Vertex(grid.agent.position, store_connectivity=True)\n        goal_vertex = Vertex(grid.goal.position, store_connectivity=True)\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, V)\n        self._graph.edges_removable = True  # allow pruning\n\n        self._init_displays()\n\n    def _get_informed_sample(self) -> Point:\n        \"\"\"\n        Informed sample biased towards goal region:\n        Sampling biased more closely near the line start-->goal to speed convergence.\n        \"\"\"\n        grid = self._get_grid()\n        start = grid.agent.position.to_tensor()\n        goal = grid.goal.position.to_tensor()\n        max_dim = max(grid.size.width, grid.size.height)\n        while True:\n            # Uniform random sample \n            sample_coords = torch.randint(0, grid.size.width, (grid.size.n_dim,), dtype=torch.float)\n            # Create a biased sample towards goal by linear interpolation with some noise\n            alpha = torch.rand(1).item()\n            informed = start + alpha * (goal - start)\n            noise = (torch.randn(grid.size.n_dim) * max_dim * 0.1).clamp(-max_dim * 0.15, max_dim * 0.15)\n            sample_pos = informed + noise\n            sample_pos = torch.clamp(sample_pos, min=0, max=torch.tensor(grid.size.values) - 1)\n            sample = Point.from_tensor(sample_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        delta = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(delta)\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        dir_normalized = delta / dist\n        new_pos = q_near.position.to_tensor() + dir_normalized * max_dist\n        q_new = Point.from_tensor(new_pos)\n        return Vertex(q_new, store_connectivity=True)\n\n    def _near(self, vertex: Vertex) -> List[Vertex]:\n        # Dynamically adjust radius based on graph size (smaller radius if graph bigger)\n        radius = self._max_radius * min(1.0, 300 / max(1, self._graph.size))\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # Try to improve graph paths by rewiring vertices to q_new if cost is lower and path is valid\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor is q_new:\n                continue\n            current_cost = neighbor.cost if neighbor.cost is not None else float('inf')\n            tentative_cost = (q_new.cost if q_new.cost is not None else 0) + grid.get_movement_cost(q_new.position, neighbor.position)\n            if tentative_cost < current_cost:\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, neighbor.position)):\n                    # Remove old parent's edge (choose one arbitrary parent)\n                    if neighbor.parents:\n                        for p in neighbor.parents:\n                            self._graph.remove_edge(p, neighbor)\n                    # Add new edge from q_new to neighbor\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = tentative_cost\n\n    def _extract_path(self, q_goal_conn: Vertex) -> None:\n        # Backtrack path from goal conn vertex to start using parents\n        path: List[Vertex] = []\n        current = q_goal_conn\n        while current.parents:\n            path.append(current)\n            parent = next(iter(current.parents))\n            current = parent\n        path.append(current)  # add root start\n        path.reverse()\n\n        # Smooth path by shortcutting\n        smooth_path = self._shortcut_path(path)\n\n        for vertex in smooth_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Simple shortcutting to reduce unnecessary waypoints in path by checking if \n        direct connections between non-adjacent vertices are valid.\n        \"\"\"\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path\n\n        shortened = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                # Check if direct connection valid: idx -> next_idx\n                line_seq = grid.get_line_sequence(path[idx].position, path[next_idx].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                next_idx -= 1\n            shortened.append(path[next_idx])\n            idx = next_idx\n        return shortened\n\n    # Overridden method #\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start_time = time.time()\n\n        # Initialize costs for root vertices\n        root_start, root_goal = self._graph.root_vertices\n        root_start.cost = 0.0\n        root_goal.cost = float('inf')\n\n        max_dist = self._max_dist_edge\n        iteration_limit = 15000\n\n        for iteration in range(iteration_limit):\n            if time.time() - start_time > self._timeout_sec:\n                # Planning failed due to timeout\n                return\n\n            q_sample = self._get_informed_sample()\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Assign cost to q_new if q_near has cost else default to inf\n            cost_to_q_new = (q_near.cost if q_near.cost is not None else 0) + grid.get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = cost_to_q_new\n\n            self._graph.add_edge(q_near, q_new)\n\n            neighbors = self._near(q_new)\n            self._rewire(q_new, neighbors)\n\n            # Early detection if q_new near goal and connects with valid edge for path extraction\n            dist_to_goal = torch.dist(torch.tensor(q_new.position.values), torch.tensor(root_goal.position.values))\n            if dist_to_goal <= self._max_dist_edge:\n                line_seq_to_goal = grid.get_line_sequence(q_new.position, root_goal.position)\n                if grid.is_valid_line_sequence(line_seq_to_goal):\n                    self._graph.add_edge(q_new, root_goal)\n                    root_goal.cost = q_new.cost + grid.get_movement_cost(q_new.position, root_goal.position)\n                    self._extract_path(q_new)\n                    return\n\n            # Periodically prune graph by removing vertices with no children (dead ends) and large cost\n            if iteration % 500 == 0 and self._graph.size > 200:\n                self._prune_graph()\n\n            self.key_frame()\n\n    def _prune_graph(self) -> None:\n        # Remove dead-end vertices with no children and high cost to reduce search complexity\n        to_remove = []\n        for v in self._graph.root_vertices:\n            if v is self._graph.root_vertex_start or v is self._graph.root_vertex_goal:\n                continue\n            if not v.children and (v.cost is None or v.cost > 1e5):\n                to_remove.append(v)\n        for v in to_remove:\n            for p in v.parents:\n                self._graph.remove_edge(p, v)\n            # Also remove from root vertices list if exists\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)",
     "objective": null,
     "other_inf": null
}
