Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0092,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.23
}
Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.009,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.23
}
Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0091,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.23
}
{
     "operator": "e1",
     "algorithm": "This is an improved bidirectional informed RRT* inspired sample-based path planner\n      designed to enhance planning efficiency, path quality, robustness, path smoothness,\n      and success rate while reducing search time and path length.\n\n      Key features:\n      - Bidirectional trees (start and goal)\n      - Informed sampling focused around an ellipsoidal subset for path improvement\n      - Asymptotic optimality with rewiring to improve path quality dynamically\n      - Early termination when goal reachable\n      - Smoothness promotion by limiting step length and rewiring better parents\n      - Time-limited search (10 seconds max) to avoid long runtimes",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _start_time: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 12.0\n        self._iterations = 15000\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n        self._random_generator = getattr(self._services, 'random', None)\n        if self._random_generator is None:\n            import random\n            self._random_generator = random\n\n    def _get_random_sample(self, c_best: Optional[float], c_min: float, x_center: Point, C: List[List[float]]) -> Point:\n        \"\"\"Generate informed sample within an ellipsoid if c_best < inf, otherwise uniform random.\"\"\"\n        dim = self._get_grid().size.n_dim\n        random_generator = self._random_generator  # Correct access to random generator\n        if c_best == math.inf or c_best == 0 or c_best is None:\n            while True:\n                sample_coords = [random_generator.randint(0, self._get_grid().size[i]-1) for i in range(dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling inside ellipsoid defined by c_best and transformation C\n        for _ in range(100):  # limited retries\n            # Sample unit n-ball\n            while True:\n                x_ball = [random_generator.normalvariate(0, 1) for _ in range(dim)]\n                s = sum(v*v for v in x_ball)\n                if s > 0:\n                    x_ball = [v / math.sqrt(s) for v in x_ball]\n                    break\n            r = random_generator.random() ** (1.0/dim)\n            x_ball = [r*v for v in x_ball]\n\n            # Scale by axis lengths\n            L = [c_best/2.0] + [math.sqrt(c_best*c_best - c_min*c_min)/2.0]*(dim-1)\n            x_scaled = [L[i] * x_ball[i] for i in range(dim)]\n\n            # Rotate and translate back to center\n            x_rotated = [sum(C[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim)]\n            sample_coords = [int(round(x_center[i] + x_rotated[i])) for i in range(dim)]\n            sample = Point(*sample_coords)\n\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n        # fallback uniform sample\n        while True:\n            sample_coords = [random_generator.randint(0, self._get_grid().size[i]-1) for i in range(dim)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([root_vertex], q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        else:\n            dir_normalized = vec / dist\n            new_pos = q_near.position.to_tensor() + max_dist * dir_normalized\n            q_new = Point.from_tensor(new_pos)\n            return Vertex(q_new)\n\n    def _get_vertices_near(self, root_vertex: Vertex, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([root_vertex], q_new.position, radius)\n\n    def _rewire(self, root_vertex: Vertex, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # Try to improve cost to q_new by rewiring from neighbors\n        best_cost = q_new.cost if hasattr(q_new, 'cost') else math.inf\n        best_parent = None\n        for neighbor in neighbors:\n            if neighbor is q_new:\n                continue\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position)):\n                cost = neighbor.cost if hasattr(neighbor, 'cost') else 0.0\n                cost += self._get_grid().get_movement_cost(neighbor.position, q_new.position)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_parent = neighbor\n\n        if best_parent is not None:\n            # Reassign parent and cost\n            for p in list(q_new.parents):\n                self._graph.remove_edge(p, q_new)\n\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Try to rewire neighbors for which q_new offers better cost\n            for neighbor in neighbors:\n                if neighbor is q_new or neighbor is best_parent:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                    neighbor_cost = neighbor.cost if hasattr(neighbor, 'cost') else math.inf\n                    new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n                    if new_cost < neighbor_cost:\n                        for p in list(neighbor.parents):\n                            self._graph.remove_edge(p, neighbor)\n                        neighbor.cost = new_cost\n                        self._graph.add_edge(q_new, neighbor)\n\n    def _path_to_start(self, vertex: Vertex) -> List[Vertex]:\n        path = []\n        curr = vertex\n        while curr is not None:\n            path.append(curr)\n            if len(curr.parents) == 0:\n                break\n            # Pick the parent with minimal cost (or first if cost undefined)\n            costs_and_parents = [(p.cost if hasattr(p, 'cost') else 0, p) for p in curr.parents]\n            costs_and_parents.sort(key=lambda x: x[0])\n            curr = costs_and_parents[0][1]\n        path.reverse()\n        return path\n\n    def _extract_path(self, meet_vertex_start: Vertex, meet_vertex_goal: Vertex) -> None:\n        path_start = self._path_to_start(meet_vertex_start)\n        path_goal = self._path_to_start(meet_vertex_goal)\n        path_goal.reverse()  # from meeting vertex to goal\n        # Merge paths excluding duplicated meeting vertex\n        full_path = path_start + path_goal[1:]\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _build_rotation_matrix(self, x_center: List[float], goal_center: List[float]) -> List[List[float]]:\n        # Create orthonormal basis with first axis in direction (start->goal)\n        dim = len(x_center)\n        dir_vector = [goal_center[i] - x_center[i] for i in range(dim)]\n        dist = math.sqrt(sum(d * d for d in dir_vector))\n        if dist == 0:\n            return [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]  # Identity matrix\n\n        e1 = [d / dist for d in dir_vector]\n        U = [e1]  # Base first vector\n\n        # Use Gram-Schmidt to generate remaining orthonormal basis vectors\n        for i in range(1, dim):\n            base_vector = [0]*dim\n            base_vector[i] = 1\n            proj = sum(base_vector[j]*e1[j] for j in range(dim))\n            orthogonal_vec = [base_vector[j]-proj*e1[j] for j in range(dim)]\n            norm_orth = math.sqrt(sum(x*x for x in orthogonal_vec))\n            if norm_orth < 1e-10:\n                # fallback vector orthogonal to e1\n                orthogonal_vec = [0]*dim\n                orthogonal_vec[(i)%dim] = 1\n                norm_orth = 1\n            orthonormal_vec = [x / norm_orth for x in orthogonal_vec]\n            U.append(orthonormal_vec)\n        return [list(col) for col in zip(*U)]  # transpose for rotation matrix\n\n    # Main function to find path #\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        self._start_time = start_time\n\n        dim = self._get_grid().size.n_dim\n        start_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n\n        # Initialize costs\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = 0.0\n\n        c_min = self._get_grid().get_distance(start_pos, goal_pos)  # minimum possible distance\n        c_best = math.inf\n\n        # Ellipsoid center and rotation matrix for informed sampling\n        x_center = [(start_pos[i] + goal_pos[i]) / 2.0 for i in range(dim)]\n        C = self._build_rotation_matrix(list(start_pos), list(goal_pos))\n\n        # Add roots to vertex lists\n        vertices_start = [self._graph.root_vertex_start]\n        vertices_goal = [self._graph.root_vertex_goal]\n\n        # Internal helper to grow tree towards q_target\n        def extend(root_vertex: Vertex, q_target: Point) -> Tuple[str, Optional[Vertex]]:\n            q_near = self._get_nearest_vertex(root_vertex, q_target)\n            q_new = self._get_new_vertex(q_near, q_target, self._max_dist)\n\n            # Reject if invalid line crossing obstacles\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                return 'trapped', None\n\n            # Compute cost to new vertex\n            cost_near = q_near.cost if hasattr(q_near, 'cost') else 0.0\n            move_cost = self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = cost_near + move_cost\n\n            # Find neighbors for rewiring\n            radius = min(self._max_dist * 2.0,\n                         self._max_dist * ((math.log(len(vertices_start)+len(vertices_goal)+1) / (len(vertices_start)+len(vertices_goal)+1))**(1/dim)))\n            near_vertices = self._get_vertices_near(root_vertex, q_new, radius)\n\n            # Pick best parent for q_new among near vertices to reduce cost\n            best_cost = q_new.cost\n            best_parent = q_near\n            for near_v in near_vertices:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(near_v.position, q_new.position)):\n                    cost = near_v.cost + self._get_grid().get_movement_cost(near_v.position, q_new.position) if hasattr(near_v, 'cost') else math.inf\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_parent = near_v\n            q_new.cost = best_cost\n\n            # Add q_new and connect best parent\n            self._graph.add_edge(best_parent, q_new)\n            vertices = vertices_start if root_vertex is self._graph.root_vertex_start else vertices_goal\n            vertices.append(q_new)\n\n            # Rewire neighbors to q_new if better\n            self._rewire(root_vertex, q_new, near_vertices)\n\n            if q_new.position == q_target:\n                return 'reached', q_new\n            else:\n                return 'advanced', q_new\n\n        # Bidirectional tree extension alternates between start and goal trees\n        for iter_count in range(self._iterations):\n            if time.time() - start_time > 10.0:\n                # Fail early on timeout\n                return\n\n            # Determine informed sampling radius (c_best)\n            if c_best == math.inf:\n                sample_point = self._get_random_sample(None, c_min, x_center, C)\n            else:\n                sample_point = self._get_random_sample(c_best, c_min, x_center, C)\n\n            # Alternate trees: even iter - start, odd iter - goal\n            tree_selector = iter_count % 2\n            tree_root = self._graph.root_vertex_start if tree_selector == 0 else self._graph.root_vertex_goal\n            other_tree_root = self._graph.root_vertex_goal if tree_selector == 0 else self._graph.root_vertex_start\n            tree_vertices = vertices_start if tree_selector == 0 else vertices_goal\n            other_tree_vertices = vertices_goal if tree_selector == 0 else vertices_start\n\n            outcome, q_new = extend(tree_root, sample_point)\n            if outcome == 'trapped' or q_new is None:\n                self.key_frame()\n                continue\n\n            # Try to connect the opposite tree towards q_new\n            outcome_connect, q_new_connect = 'advanced', None\n            q_target = q_new.position\n            while outcome_connect == 'advanced':\n                outcome_connect, q_new_connect = extend(other_tree_root, q_target)\n                if outcome_connect == 'reached':\n                    # Path found: extract\n                    v_from_tree = q_new if tree_selector == 0 else q_new_connect\n                    v_from_other = q_new_connect if tree_selector == 0 else q_new\n                    c_best = min(c_best, v_from_tree.cost + v_from_other.cost)\n\n                    self._extract_path(v_from_tree, v_from_other)\n                    return\n\n            self.key_frame()",
     "objective": 198.42,
     "other_inf": null,
     "results": {
          "goal_found_perc": 97.33,
          "average_steps": 14.51,
          "average_distance": 15.77,
          "average_smoothness": 0.44,
          "average_clearance": 2.23,
          "average_time": 0.0132,
          "average_distance_from_goal": 0.2,
          "average_original_distance_from_goal": 8.42,
          "average memory": 57.62,
          "goal_found_perc_improvement": 0.0,
          "average_steps_improvement": -58.75,
          "average_distance_improvement": -63.25,
          "average_smoothness_improvement": -69.23,
          "average_clearance_improvement": 11.5,
          "average_time_improvement": -45.05,
          "average_distance_from_goal_improvement": -0.0,
          "average_path_deviation": 6.109999999999999,
          "average_memory_improvement": -54.77
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an improved bidirectional hybrid bidirectional Smooth Informed RRT* planner\n    that combines advantages of heuristic-guided informed sampling, bidirectional exploration,\n    and adaptive dynamic pruning for efficiency gains.\n\n    Key Features:\n    - Bidirectional trees grown simultaneously from start and goal.\n    - Uses an adaptive informed sampling ellipsoid to focus search near best known path.\n    - Dynamic pruning of vertices outside the adaptive radius to maintain graph sparsity and efficiency.\n    - Smooth path promotion by limiting max step size and rewiring neighbors with cost improvements.\n    - Time-bounded search with 10 seconds max allowed runtime.\n    - Early path extraction on connection between trees.\n    - Uses auxiliary heuristics combining Euclidean and obstacle-penalty estimated cost.\n    - Robust connectivity attempts between the two trees to improve success rate.\n    - Incorporates a cost-to-go heuristic approximation to guide rewiring decisions.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 15.0\n        self._iterations = 12000\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n        import random\n        self._random_generator = getattr(self._services, 'random', random)\n        self._prune_threshold_factor = 1.5\n\n    def _get_random_informed_sample(self, c_best, c_min, x_center, C):\n        dim = self._get_grid().size.n_dim\n        random_generator = self._random_generator\n\n        if c_best == float('inf') or c_best == 0 or c_best is None:\n            # Uniform random sampling\n            while True:\n                sample_coords = [random_generator.randint(0, self._get_grid().size[i]-1) for i in range(dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Sample inside the prolate hyperspheroid (ellipsoid) for informed sampling:\n        for _ in range(100):\n            # Sample a random point in unit n-ball\n            while True:\n                x_ball = [random_generator.gauss(0, 1) for _ in range(dim)]\n                norm_sq = sum(x*x for x in x_ball)\n                if norm_sq > 0:\n                    norm = norm_sq ** 0.5\n                    x_ball = [v/norm for v in x_ball]\n                    break\n            r = random_generator.random() ** (1.0 / dim)\n            x_ball = [r * v for v in x_ball]\n\n            # Ellipsoid axis lengths\n            L = [c_best / 2.0] + [((c_best**2 - c_min**2) ** 0.5) / 2.0] * (dim - 1)\n            x_scaled = [L[i]*x_ball[i] for i in range(dim)]\n\n            # Rotate and translate back to original space\n            x_rotated = [sum(C[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim)]\n            sample_coords = [int(round(x_center[i] + x_rotated[i])) for i in range(dim)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n        # Fallback uniform sampling\n        while True:\n            sample_coords = [random_generator.randint(0, self._get_grid().size[i]-1) for i in range(dim)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([root_vertex], q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        else:\n            dir_normalized = vec / dist\n            new_pos = q_near.position.to_tensor() + max_dist * dir_normalized\n            q_new = Point.from_tensor(new_pos)\n            return Vertex(q_new)\n\n    def _get_nearby_vertices(self, root_vertices: List[Vertex], q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(root_vertices, q_new.position, radius)\n\n    def _rewire(self, root_vertices: List[Vertex], q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # Select better parent for q_new to minimize cost\n        best_cost = getattr(q_new, \"cost\", float('inf'))\n        best_parent = None\n\n        for neighbor in neighbors:\n            if neighbor is q_new:\n                continue\n            # Check connectivity and collision\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position)):\n                cost_to_neighbor = getattr(neighbor, \"cost\", 0.0)\n                cost_to_new = cost_to_neighbor + self._get_grid().get_movement_cost(neighbor.position, q_new.position)\n                if cost_to_new < best_cost:\n                    best_cost = cost_to_new\n                    best_parent = neighbor\n\n        if best_parent is not None:\n            # Remove old parents edges\n            for p in list(q_new.parents):\n                self._graph.remove_edge(p, q_new)\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Try to rewire neighbors via q_new for cost improvement\n            for neighbor in neighbors:\n                if neighbor is q_new or neighbor is best_parent:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                    current_cost = getattr(neighbor, \"cost\", float('inf'))\n                    new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n                    if new_cost < current_cost:\n                        for p in list(neighbor.parents):\n                            self._graph.remove_edge(p, neighbor)\n                        neighbor.cost = new_cost\n                        self._graph.add_edge(q_new, neighbor)\n\n    def _build_rotation_matrix(self, start: List[float], goal: List[float]) -> List[List[float]]:\n        # Creates orthonormal basis for ellipsoid rotation from start->goal vector\n        dim = len(start)\n        dir_vec = [goal[i] - start[i] for i in range(dim)]\n        dist = sum(d*d for d in dir_vec) ** 0.5\n        if dist == 0:\n            # Identity if zero distance\n            return [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]\n\n        e1 = [d / dist for d in dir_vec]\n        basis = [e1]\n\n        for i in range(1, dim):\n            v = [0]*dim\n            v[i] = 1\n            proj = sum(v[j]*e1[j] for j in range(dim))\n            orth_vec = [v[j] - proj*e1[j] for j in range(dim)]\n            norm_orth = sum(x*x for x in orth_vec) ** 0.5\n            if norm_orth < 1e-10:\n                # fallback orthogonal basis vector\n                orth_vec = [0]*dim\n                orth_vec[(i)%dim] = 1\n                norm_orth = 1\n            basis.append([x / norm_orth for x in orth_vec])\n\n        # Transpose matrix for rotation\n        rotation_matrix = [[basis[j][i] for j in range(dim)] for i in range(dim)]\n        return rotation_matrix\n\n    def _path_to_root(self, vertex: Vertex) -> List[Vertex]:\n        path = []\n        current = vertex\n        while current is not None:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            # Choose parent with lowest cost\n            parent_costs = [(p.cost if hasattr(p, \"cost\") else float('inf'), p) for p in current.parents]\n            parent_costs.sort(key=lambda x: x[0])\n            current = parent_costs[0][1]\n        path.reverse()\n        return path\n\n    def _extract_path(self, v_start: Vertex, v_goal: Vertex) -> None:\n        # Merge path from start root to meeting vertex and from goal root to meeting vertex (in reverse)\n        path_from_start = self._path_to_root(v_start)\n        path_from_goal = self._path_to_root(v_goal)\n        path_from_goal.reverse()\n        full_path = path_from_start + path_from_goal[1:]  # avoid duplicate meeting vertex\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _prune_graph(self, c_best: float, root_vertices_start: List[Vertex], root_vertices_goal: List[Vertex], c_min: float) -> None:\n        # Remove any vertices with cost-to-come + heuristic-to-go > prune threshold * c_best\n        prune_threshold = c_best * self._prune_threshold_factor\n        agent_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n\n        def heuristic_to_goal(pos: Point) -> float:\n            # Simple admissible heuristic: Euclidean distance to goal\n            return self._get_grid().get_distance(pos, goal_pos)\n\n        def should_prune(vertex: Vertex):\n            cost_come = getattr(vertex, \"cost\", float('inf'))\n            if cost_come == float('inf'):\n                return True\n            h_to_go = heuristic_to_goal(vertex.position)\n            return (cost_come + h_to_go) > prune_threshold\n\n        # Prune start tree vertices\n        vertices_to_remove = [v for v in root_vertices_start if should_prune(v) and v not in [self._graph.root_vertex_start]]\n        for v in vertices_to_remove:\n            # Remove edges and vertex from graph root list\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in root_vertices_start:\n                root_vertices_start.remove(v)\n\n        # Prune goal tree vertices similarly\n        vertices_to_remove_goal = [v for v in root_vertices_goal if should_prune(v) and v not in [self._graph.root_vertex_goal]]\n        for v in vertices_to_remove_goal:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            if v in root_vertices_goal:\n                root_vertices_goal.remove(v)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        dim = self._get_grid().size.n_dim\n        start_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = 0.0\n\n        c_min = self._get_grid().get_distance(start_pos, goal_pos)  # min achievable cost\n        c_best = float('inf')\n\n        x_center = [(start_pos[i] + goal_pos[i]) / 2.0 for i in range(dim)]\n        C = self._build_rotation_matrix(list(start_pos), list(goal_pos))\n\n        vertices_start = [self._graph.root_vertex_start]\n        vertices_goal = [self._graph.root_vertex_goal]\n\n        def extend_tree(root_vertex: Vertex, q_target: Point, vertices_list: List[Vertex]) -> (str, Vertex):\n            q_near = self._get_nearest_vertex(root_vertex, q_target)\n            q_new = self._get_new_vertex(q_near, q_target, self._max_dist)\n\n            # Collision check line from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                return 'trapped', None\n\n            cost_to_near = getattr(q_near, \"cost\", 0.0)\n            incremental_cost = self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = cost_to_near + incremental_cost\n\n            # Determine radius for rewiring\n            card_v = max(len(vertices_start) + len(vertices_goal), 1)\n            radius = min(self._max_dist * 2.0,\n                         self._max_dist * ((math.log(card_v) / card_v) ** (1 / dim)))\n\n            near_vertices = self._get_nearby_vertices([root_vertex], q_new, radius)\n\n            # Pick best parent to reduce cost\n            best_cost = q_new.cost\n            best_parent = q_near\n            for near_v in near_vertices:\n                if near_v is q_new:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(near_v.position, q_new.position)):\n                    near_cost = getattr(near_v, \"cost\", float('inf'))\n                    new_cost = near_cost + self._get_grid().get_movement_cost(near_v.position, q_new.position)\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_parent = near_v\n            q_new.cost = best_cost\n\n            self._graph.add_edge(best_parent, q_new)\n            vertices_list.append(q_new)\n\n            # Rewire neighbors for potential improvements\n            self._rewire([root_vertex], q_new, near_vertices)\n\n            if q_new.position == q_target:\n                return 'reached', q_new\n            else:\n                return 'advanced', q_new\n\n        for iteration in range(self._iterations):\n            if time.time() - start_time > 10.0:\n                # Fail and terminate search after 10 seconds\n                return\n\n            sample_point = self._get_random_informed_sample(c_best, c_min, x_center, C)\n            # Alternate trees\n            tree_selector = iteration % 2\n            if tree_selector == 0:\n                root_vertex = self._graph.root_vertex_start\n                other_root_vertex = self._graph.root_vertex_goal\n                vertices_this = vertices_start\n                vertices_other = vertices_goal\n            else:\n                root_vertex = self._graph.root_vertex_goal\n                other_root_vertex = self._graph.root_vertex_start\n                vertices_this = vertices_goal\n                vertices_other = vertices_start\n\n            status, q_new = extend_tree(root_vertex, sample_point, vertices_this)\n            if status == 'trapped' or not q_new:\n                self.key_frame()\n                continue\n\n            # Try connecting the other tree toward q_new repeatedly\n            connection_status = 'advanced'\n            q_other_new = None\n            q_target_pos = q_new.position\n            attempts = 0\n            while connection_status == 'advanced' and attempts < 5:\n                connection_status, q_other_new = extend_tree(other_root_vertex, q_target_pos, vertices_other)\n                if connection_status == 'reached':\n                    # Check cost and update c_best\n                    cost_sum = q_new.cost + q_other_new.cost\n                    if cost_sum < c_best:\n                        c_best = cost_sum\n                        # Update ellipsoid center and rotation matrix for refined informed sampling\n                        x_center = [(q_new.position[i] + q_other_new.position[i]) / 2.0 for i in range(dim)]\n                        C = self._build_rotation_matrix(list(q_new.position), list(q_other_new.position))\n\n                    self._extract_path(q_new if tree_selector == 0 else q_other_new,\n                                       q_other_new if tree_selector == 0 else q_new)\n                    return\n                elif connection_status == 'advanced' and q_other_new is not None:\n                    q_target_pos = q_other_new.position\n                    attempts += 1\n                else:\n                    break\n\n            # Prune graph periodically every 200 iterations to maintain efficiency\n            if iteration > 0 and iteration % 200 == 0 and c_best != float('inf'):\n                self._prune_graph(c_best, vertices_start, vertices_goal, c_min)\n\n            self.key_frame()",
     "objective": 151.48,
     "other_inf": null,
     "results": {
          "goal_found_perc": 97.33,
          "average_steps": 13.51,
          "average_distance": 14.69,
          "average_smoothness": 0.43,
          "average_clearance": 2.19,
          "average_time": 0.0151,
          "average_distance_from_goal": 0.2,
          "average_original_distance_from_goal": 8.42,
          "average memory": 47.58,
          "goal_found_perc_improvement": 0.0,
          "average_steps_improvement": -47.81,
          "average_distance_improvement": -52.07,
          "average_smoothness_improvement": -65.38,
          "average_clearance_improvement": 9.5,
          "average_time_improvement": -65.93,
          "average_distance_from_goal_improvement": -0.0,
          "average_path_deviation": 5.029999999999999,
          "average_memory_improvement": -27.8
     }
}
AstarAstar{
     "goal_found_perc": 100.0,
     "average_steps": 73.8,
     "average_distance": 82.24,
     "average_smoothness": 0.17,
     "average_clearance": 1.62,
     "average_time": 0.5174,
     "average_distance_from_goal": 0.0,
     "average_original_distance_from_goal": 51.94,
     "average memory": 1108.0
}
Astar{
     "goal_found_perc": 100.0,
     "average_steps": 165.0,
     "average_distance": 187.2,
     "average_smoothness": 0.15,
     "average_clearance": 1.45,
     "average_time": 1.9629,
     "average_distance_from_goal": 0.0,
     "average_original_distance_from_goal": 140.01,
     "average memory": 2555.21
}
Astar{
     "goal_found_perc": 100.0,
     "average_steps": 165.0,
     "average_distance": 187.2,
     "average_smoothness": 0.15,
     "average_clearance": 1.45,
     "average_time": 1.9215,
     "average_distance_from_goal": 0.0,
     "average_original_distance_from_goal": 140.01,
     "average memory": 2555.21
}
Astar{
     "goal_found_perc": 100.0,
     "average_steps": 165.0,
     "average_distance": 187.2,
     "average_smoothness": 0.15,
     "average_clearance": 1.45,
     "average_time": 1.9916,
     "average_distance_from_goal": 0.0,
     "average_original_distance_from_goal": 140.01,
     "average memory": 2555.21
}
Astar{
     "goal_found_perc": 100.0,
     "average_steps": 165.0,
     "average_distance": 187.2,
     "average_smoothness": 0.15,
     "average_clearance": 1.45,
     "average_time": 1.9443,
     "average_distance_from_goal": 0.0,
     "average_original_distance_from_goal": 140.01,
     "average memory": 2555.21
}
Astar{
     "goal_found_perc": 100.0,
     "average_steps": 165.0,
     "average_distance": 187.2,
     "average_smoothness": 0.15,
     "average_clearance": 1.45,
     "average_time": 1.975,
     "average_distance_from_goal": 0.0,
     "average_original_distance_from_goal": 140.01,
     "average memory": 2555.21
}
Astar{
     "goal_found_perc": 100.0,
     "average_steps": 165.0,
     "average_distance": 187.2,
     "average_smoothness": 0.15,
     "average_clearance": 1.45,
     "average_time": 1.8577,
     "average_distance_from_goal": 0.0,
     "average_original_distance_from_goal": 140.01,
     "average memory": 4144.77
}
Astar{
     "goal_found_perc": 100.0,
     "average_steps": 165.0,
     "average_distance": 187.2,
     "average_smoothness": 0.15,
     "average_clearance": 1.45,
     "average_time": 4.4053,
     "average_distance_from_goal": 0.0,
     "average_original_distance_from_goal": 140.01,
     "average memory": 4143.91
}
Astar{
     "goal_found_perc": 100.0,
     "average_steps": 165.0,
     "average_distance": 187.2,
     "average_smoothness": 0.15,
     "average_clearance": 1.45,
     "average_time": 1.8202,
     "average_distance_from_goal": 0.0,
     "average_original_distance_from_goal": 140.01,
     "average memory": 4144.37
}
