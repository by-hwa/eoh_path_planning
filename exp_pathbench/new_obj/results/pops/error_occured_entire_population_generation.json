{
     "operator": "e1",
     "algorithm": "PathPlanning is an improved sample-based path planning algorithm combining informed sampling,\n    efficient rewiring like RRT*, and shortcut smoothing of the final path to improve path length,\n    smoothness, success rate, and planning speed. The planner generates random samples biased inside \n    an ellipsoidal informed region to focus search near the optimal path corridor between agent and \n    goal, reducing exploration overhead. A forest graph rooted at agent and goal is incrementally \n    extended during iterative sampling. Vertices are rewired within neighborhoods to minimize cost,\n    improving solution quality continuously. Upon finding a feasible path within a 10-second time limit,\n    the path is extracted, then post-processed with line-of-sight shortcut smoothing to enhance smoothness \n    and reduce unnecessary vertices. The algorithm balances exploration and exploitation, ensuring rapid \n    convergence to high-quality, collision-free paths even in cluttered environments with robustness against \n    failures by early timeout.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _informed_sampling_enabled: bool\n    _max_radius: float\n    _elapsed_time_limit: float\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(*args, **kwargs)\n        self._max_dist = 15.0\n        self._max_radius = 50.0\n        self._elapsed_time_limit = 10.0  # seconds\n        self._informed_sampling_enabled = True\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    def _get_distance(self, frm: Point, to: Point) -> float:\n        return self._get_grid().get_distance(frm, to)\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Perform informed sampling: samples inside an ellipsoid defined by current best solution cost,\n        between start and goal positions, if available. Otherwise uniform random sampling.\n        \"\"\"\n        grid = self._get_grid()\n        start = grid.agent.position\n        goal = grid.goal.position\n\n        if not self._informed_sampling_enabled or self._graph.root_vertex_goal.cost is None or self._graph.root_vertex_goal.cost == float('inf'):\n            # Uniform random sample in grid boundaries:\n            while True:\n                sample_coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling ellipse parameters:\n        c_best = self._graph.root_vertex_goal.cost\n        c_min = self._get_distance(start, goal)\n        if c_best is None or c_best == float('inf'):\n            c_best = float('inf')\n        if c_min == 0:\n            # Start and goal are same position (corner case)\n            return start\n\n        # Sample inside prolate hyperspheroid (in 2D ellipse) around start and goal\n        while True:\n            # Draw random sample inside unit n-ball:\n            dim = grid.size.n_dim\n            sample_in_ball = self._sample_unit_n_ball(dim)\n            # Scale according to ellipse radii:\n            r1 = c_best / 2.0\n            r2 = (c_best**2 - c_min**2)**0.5 / 2.0 if c_best > c_min else 0.0\n\n            if dim == 2:\n                L = torch.eye(2)\n                # Rotate to align with start-goal vector:\n                sg_dir = (goal.to_tensor() - start.to_tensor())\n                sg_dir = sg_dir / torch.norm(sg_dir)\n                rot = torch.tensor([[sg_dir[0], -sg_dir[1]], [sg_dir[1], sg_dir[0]]])\n                L = rot @ torch.diag(torch.tensor([r1, r2]))\n            else:\n                # For general n-dimensions, use alignment rotation with SVD:\n                # Construct rotation matrix from vector unit direction\n                sg_dir = (goal.to_tensor() - start.to_tensor())\n                sg_dir = sg_dir / torch.norm(sg_dir)\n                # Complete orthonormal basis using SVD:\n                U, _, _ = torch.svd(sg_dir.unsqueeze(1))\n                L = U @ torch.diag(torch.tensor([r1] + [r2]*(dim-1)))\n\n            transformed = L @ sample_in_ball\n            center = (start.to_tensor() + goal.to_tensor()) / 2.0\n            sample_coords = transformed + center\n            sample_point = Point.from_tensor(sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _sample_unit_n_ball(self, dim: int) -> torch.Tensor:\n        \"\"\"\n        Uniformly sample from unit n-ball in R^dim\n        \"\"\"\n        vec = torch.randn(dim)\n        vec /= torch.norm(vec)\n        r = torch.rand(1).pow(1.0 / dim)\n        return vec * r\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(direction)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / norm\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        new_point = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_point)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Reconstruct path from goal to start along parents:\n        path: List[Vertex] = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n        # Path shortcut smoothing by removing unnecessary vertices along line of sight\n        path = self._shortcut_smooth(path)\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_smooth(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Attempt to shortcut path by removing intermediate vertices where straight \n        line between two vertices is collision free.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        new_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(new_path[-1].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        iterations = 20000\n        dim = grid.size.n_dim\n        lambda_rrt_star = 50.0\n        start_time = time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        goal_vertex.cost = float('inf')\n\n        for i in range(iterations):\n            elapsed = time() - start_time\n            if elapsed > self._elapsed_time_limit:\n                # Mark failure by setting goal cost to inf and return\n                goal_vertex.cost = float('inf')\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                self.key_frame()\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            is_valid = grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest.position, q_new.position))\n            if not is_valid:\n                self.key_frame()\n                continue\n\n            card_v = float(self._graph.size)\n            log_card_v = torch.log(torch.tensor(card_v)) if card_v > 1 else torch.tensor(0.0)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dim)), self._max_radius)\n\n            near_vertices = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._get_distance(q_nearest.position, q_new.position)\n\n            # Choose best parent with minimum cost and collision-free edge\n            for q_near in near_vertices:\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position))\n                cost = q_near.cost + self._get_distance(q_near.position, q_new.position)\n                if line_free and cost < c_min:\n                    q_min = q_near\n                    c_min = cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if cost improves their cost\n            for q_near in near_vertices:\n                if q_near == q_min:\n                    continue\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position))\n                cost_through_qnew = q_new.cost + self._get_distance(q_new.position, q_near.position)\n                if line_free and cost_through_qnew < q_near.cost:\n                    # Remove old edge, add new edge, update cost\n                    old_parents = list(q_near.parents)\n                    for old_parent in old_parents:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = cost_through_qnew\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if can connect to goal and update best cost if improved\n            dist_to_goal = self._get_distance(q_new.position, goal_vertex.position)\n            if dist_to_goal <= self._max_dist:\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position))\n                if line_free:\n                    goal_cost_candidate = q_new.cost + dist_to_goal\n                    if goal_cost_candidate < goal_vertex.cost:\n                        # Connect q_new to goal and update goal cost\n                        goal_vertex.cost = goal_cost_candidate\n                        self._graph.add_edge(q_new, goal_vertex)\n                        # Extract and smooth path\n                        self._extract_path(goal_vertex)\n                        return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 266, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 225, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 206, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 190, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "e1",
     "algorithm": "PathPlanning is an improved sample-based path planning algorithm combining informed sampling,\n    efficient rewiring like RRT*, and shortcut smoothing of the final path to improve path length,\n    smoothness, success rate, and planning speed. The planner generates random samples biased inside \n    an ellipsoidal informed region to focus search near the optimal path corridor between agent and \n    goal, reducing exploration overhead. A forest graph rooted at agent and goal is incrementally \n    extended during iterative sampling. Vertices are rewired within neighborhoods to minimize cost,\n    improving solution quality continuously. Upon finding a feasible path within a 10-second time limit,\n    the path is extracted, then post-processed with line-of-sight shortcut smoothing to enhance smoothness \n    and reduce unnecessary vertices. The algorithm balances exploration and exploitation, ensuring rapid \n    convergence to high-quality, collision-free paths even in cluttered environments with robustness against \n    failures by early timeout.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _informed_sampling_enabled: bool\n    _max_radius: float\n    _elapsed_time_limit: float\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(*args, **kwargs)\n        self._max_dist = 15.0\n        self._max_radius = 50.0\n        self._elapsed_time_limit = 10.0  # seconds\n        self._informed_sampling_enabled = True\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    def _get_distance(self, frm: 'Point', to: 'Point') -> float:\n        return self._get_grid().get_distance(frm, to)\n\n    def _get_random_sample(self) -> 'Point':\n        \"\"\"\n        Perform informed sampling: samples inside an ellipsoid defined by current best solution cost,\n        between start and goal positions, if available. Otherwise uniform random sampling.\n        \"\"\"\n        grid = self._get_grid()\n        start = grid.agent.position\n        goal = grid.goal.position\n\n        if not self._informed_sampling_enabled or self._graph.root_vertex_goal.cost is None or self._graph.root_vertex_goal.cost == float('inf'):\n            # Uniform random sample in grid boundaries:\n            while True:\n                sample_coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling ellipse parameters:\n        c_best = self._graph.root_vertex_goal.cost\n        c_min = self._get_distance(start, goal)\n        if c_best is None or c_best == float('inf'):\n            c_best = float('inf')\n        if c_min == 0:\n            # Start and goal are same position (corner case)\n            return start\n\n        # Sample inside prolate hyperspheroid (in 2D ellipse) around start and goal\n        while True:\n            # Draw random sample inside unit n-ball:\n            dim = grid.size.n_dim\n            sample_in_ball = self._sample_unit_n_ball(dim)\n            # Scale according to ellipse radii:\n            r1 = c_best / 2.0\n            r2 = (c_best**2 - c_min**2)**0.5 / 2.0 if c_best > c_min else 0.0\n\n            if dim == 2:\n                # 2D case\n                sg_dir = (goal.to_tensor() - start.to_tensor())\n                sg_dir_norm = torch.norm(sg_dir)\n                if sg_dir_norm == 0:\n                    # Avoid division by zero\n                    return start\n                sg_dir = sg_dir / sg_dir_norm\n                rot = torch.tensor([[sg_dir[0], -sg_dir[1]], [sg_dir[1], sg_dir[0]]])\n                L = rot @ torch.diag(torch.tensor([r1, r2]))\n            else:\n                # For general n-dimensions, use alignment rotation with SVD:\n                sg_dir = (goal.to_tensor() - start.to_tensor())\n                sg_dir_norm = torch.norm(sg_dir)\n                if sg_dir_norm == 0:\n                    return start\n                sg_dir = sg_dir / sg_dir_norm\n                U, _, _ = torch.svd(sg_dir.unsqueeze(1))\n                L = U @ torch.diag(torch.tensor([r1] + [r2]*(dim-1)))\n\n            transformed = L @ sample_in_ball\n            center = (start.to_tensor() + goal.to_tensor()) / 2.0\n            sample_coords = transformed + center\n            sample_point = Point.from_tensor(sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _sample_unit_n_ball(self, dim: int) -> torch.Tensor:\n        \"\"\"\n        Uniformly sample from unit n-ball in R^dim\n        \"\"\"\n        vec = torch.randn(dim)\n        vec /= torch.norm(vec)\n        r = torch.rand(1).pow(1.0 / dim)\n        return vec * r\n\n    def _get_nearest_vertex(self, q_sample: 'Point') -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: 'Point', max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(direction)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / norm\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        new_point = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_point)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Reconstruct path from goal to start along parents:\n        path: List[Vertex] = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n        # Path shortcut smoothing by removing unnecessary vertices along line of sight\n        path = self._shortcut_smooth(path)\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_smooth(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Attempt to shortcut path by removing intermediate vertices where straight \n        line between two vertices is collision free.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        new_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(new_path[-1].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        iterations = 20000\n        dim = grid.size.n_dim\n        lambda_rrt_star = 50.0\n        start_time = time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        goal_vertex.cost = float('inf')\n\n        for i in range(iterations):\n            elapsed = time() - start_time\n            if elapsed > self._elapsed_time_limit:\n                # Mark failure by setting goal cost to inf and return\n                goal_vertex.cost = float('inf')\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                self.key_frame()\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            is_valid = grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest.position, q_new.position))\n            if not is_valid:\n                self.key_frame()\n                continue\n\n            card_v = float(self._graph.size)\n            log_card_v = torch.log(torch.tensor(card_v)) if card_v > 1 else torch.tensor(0.0)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dim)), self._max_radius)\n\n            near_vertices = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._get_distance(q_nearest.position, q_new.position)\n\n            # Choose best parent with minimum cost and collision-free edge\n            for q_near in near_vertices:\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position))\n                cost = q_near.cost + self._get_distance(q_near.position, q_new.position)\n                if line_free and cost < c_min:\n                    q_min = q_near\n                    c_min = cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if cost improves their cost\n            for q_near in near_vertices:\n                if q_near == q_min:\n                    continue\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position))\n                cost_through_qnew = q_new.cost + self._get_distance(q_new.position, q_near.position)\n                if line_free and cost_through_qnew < q_near.cost:\n                    # Remove old edge, add new edge, update cost\n                    old_parents = list(q_near.parents)\n                    for old_parent in old_parents:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = cost_through_qnew\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if can connect to goal and update best cost if improved\n            dist_to_goal = self._get_distance(q_new.position, goal_vertex.position)\n            if dist_to_goal <= self._max_dist:\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position))\n                if line_free:\n                    goal_cost_candidate = q_new.cost + dist_to_goal\n                    if goal_cost_candidate < goal_vertex.cost:\n                        # Connect q_new to goal and update goal cost\n                        goal_vertex.cost = goal_cost_candidate\n                        self._graph.add_edge(q_new, goal_vertex)\n                        # Extract and smooth path\n                        self._extract_path(goal_vertex)\n                        return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 266, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 225, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 206, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 194, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "e1",
     "algorithm": "PathPlanning is an improved sample-based path planning algorithm combining informed sampling,\n    efficient rewiring like RRT*, and shortcut smoothing of the final path to improve path length,\n    smoothness, success rate, and planning speed. The planner generates random samples biased inside \n    an ellipsoidal informed region to focus search near the optimal path corridor between agent and \n    goal, reducing exploration overhead. A forest graph rooted at agent and goal is incrementally \n    extended during iterative sampling. Vertices are rewired within neighborhoods to minimize cost,\n    improving solution quality continuously. Upon finding a feasible path within a 10-second time limit,\n    the path is extracted, then post-processed with line-of-sight shortcut smoothing to enhance smoothness \n    and reduce unnecessary vertices. The algorithm balances exploration and exploitation, ensuring rapid \n    convergence to high-quality, collision-free paths even in cluttered environments with robustness against \n    failures by early timeout.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n    _max_dist: float\n    _informed_sampling_enabled: bool\n    _max_radius: float\n    _elapsed_time_limit: float\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(*args, **kwargs)\n        self._max_dist = 15.0\n        self._max_radius = 50.0\n        self._elapsed_time_limit = 10.0  # seconds\n        self._informed_sampling_enabled = True\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    def _get_distance(self, frm: 'Point', to: 'Point') -> float:\n        return self._get_grid().get_distance(frm, to)\n\n    def _get_random_sample(self) -> 'Point':\n        \"\"\"\n        Perform informed sampling: samples inside an ellipsoid defined by current best solution cost,\n        between start and goal positions, if available. Otherwise uniform random sampling.\n        \"\"\"\n        grid = self._get_grid()\n        start = grid.agent.position\n        goal = grid.goal.position\n\n        if not self._informed_sampling_enabled or self._graph.root_vertex_goal.cost is None or self._graph.root_vertex_goal.cost == float('inf'):\n            # Uniform random sample in grid boundaries:\n            while True:\n                sample_coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling ellipse parameters:\n        c_best = self._graph.root_vertex_goal.cost\n        c_min = self._get_distance(start, goal)\n        if c_best is None or c_best == float('inf'):\n            c_best = float('inf')\n        if c_min == 0:\n            # Start and goal are same position (corner case)\n            return start\n\n        # Sample inside prolate hyperspheroid (in 2D ellipse) around start and goal\n        while True:\n            # Draw random sample inside unit n-ball:\n            dim = grid.size.n_dim\n            sample_in_ball = self._sample_unit_n_ball(dim)\n            # Scale according to ellipse radii:\n            r1 = c_best / 2.0\n            r2 = (c_best**2 - c_min**2)**0.5 / 2.0 if c_best > c_min else 0.0\n\n            if dim == 2:\n                # 2D case\n                sg_dir = (goal.to_tensor() - start.to_tensor())\n                sg_dir_norm = torch.norm(sg_dir)\n                if sg_dir_norm == 0:\n                    # Avoid division by zero\n                    return start\n                sg_dir = sg_dir / sg_dir_norm\n                rot = torch.tensor([[sg_dir[0], -sg_dir[1]], [sg_dir[1], sg_dir[0]]])\n                L = rot @ torch.diag(torch.tensor([r1, r2]))\n            else:\n                # For general n-dimensions, use alignment rotation with SVD:\n                sg_dir = (goal.to_tensor() - start.to_tensor())\n                sg_dir_norm = torch.norm(sg_dir)\n                if sg_dir_norm == 0:\n                    return start\n                sg_dir = sg_dir / sg_dir_norm\n                U, _, _ = torch.svd(sg_dir.unsqueeze(1))\n                L = U @ torch.diag(torch.tensor([r1] + [r2]*(dim-1)))\n\n            transformed = L @ sample_in_ball\n            center = (start.to_tensor() + goal.to_tensor()) / 2.0\n            sample_coords = transformed + center\n            sample_point = Point.from_tensor(sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _sample_unit_n_ball(self, dim: int) -> torch.Tensor:\n        \"\"\"\n        Uniformly sample from unit n-ball in R^dim\n        \"\"\"\n        vec = torch.randn(dim)\n        vec /= torch.norm(vec)\n        r = torch.rand(1).pow(1.0 / dim)\n        return vec * r\n\n    def _get_nearest_vertex(self, q_sample: 'Point') -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: 'Point', max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(direction)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / norm\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        new_point = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_point)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Reconstruct path from goal to start along parents:\n        path: List[Vertex] = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n        # Path shortcut smoothing by removing unnecessary vertices along line of sight\n        path = self._shortcut_smooth(path)\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_smooth(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Attempt to shortcut path by removing intermediate vertices where straight \n        line between two vertices is collision free.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        new_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(new_path[-1].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        iterations = 20000\n        dim = grid.size.n_dim\n        lambda_rrt_star = 50.0\n        start_time = time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        goal_vertex.cost = float('inf')\n\n        for i in range(iterations):\n            elapsed = time() - start_time\n            if elapsed > self._elapsed_time_limit:\n                # Mark failure by setting goal cost to inf and return\n                goal_vertex.cost = float('inf')\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                self.key_frame()\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            is_valid = grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest.position, q_new.position))\n            if not is_valid:\n                self.key_frame()\n                continue\n\n            card_v = float(self._graph.size)\n            log_card_v = torch.log(torch.tensor(card_v)) if card_v > 1 else torch.tensor(0.0)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dim)), self._max_radius)\n\n            near_vertices = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._get_distance(q_nearest.position, q_new.position)\n\n            # Choose best parent with minimum cost and collision-free edge\n            for q_near in near_vertices:\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position))\n                cost = q_near.cost + self._get_distance(q_near.position, q_new.position)\n                if line_free and cost < c_min:\n                    q_min = q_near\n                    c_min = cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if cost improves their cost\n            for q_near in near_vertices:\n                if q_near == q_min:\n                    continue\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position))\n                cost_through_qnew = q_new.cost + self._get_distance(q_new.position, q_near.position)\n                if line_free and cost_through_qnew < q_near.cost:\n                    # Remove old edge, add new edge, update cost\n                    old_parents = list(q_near.parents)\n                    for old_parent in old_parents:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = cost_through_qnew\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if can connect to goal and update best cost if improved\n            dist_to_goal = self._get_distance(q_new.position, goal_vertex.position)\n            if dist_to_goal <= self._max_dist:\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position))\n                if line_free:\n                    goal_cost_candidate = q_new.cost + dist_to_goal\n                    if goal_cost_candidate < goal_vertex.cost:\n                        # Connect q_new to goal and update goal cost\n                        goal_vertex.cost = goal_cost_candidate\n                        self._graph.add_edge(q_new, goal_vertex)\n                        # Extract and smooth path\n                        self._extract_path(goal_vertex)\n                        return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 266, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 225, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 206, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 193, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "e1",
     "algorithm": "PathPlanning is an improved sample-based path planning algorithm combining informed sampling,\n    efficient rewiring like RRT*, and shortcut smoothing of the final path to improve path length,\n    smoothness, success rate, and planning speed. The planner generates random samples biased inside \n    an ellipsoidal informed region to focus search near the optimal path corridor between agent and \n    goal, reducing exploration overhead. A forest graph rooted at agent and goal is incrementally \n    extended during iterative sampling. Vertices are rewired within neighborhoods to minimize cost,\n    improving solution quality continuously. Upon finding a feasible path within a 10-second time limit,\n    the path is extracted, then post-processed with line-of-sight shortcut smoothing to enhance smoothness \n    and reduce unnecessary vertices. The algorithm balances exploration and exploitation, ensuring rapid \n    convergence to high-quality, collision-free paths even in cluttered environments with robustness against \n    failures by early timeout.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n    _max_dist: float\n    _informed_sampling_enabled: bool\n    _max_radius: float\n    _elapsed_time_limit: float\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(*args, **kwargs)\n        self._max_dist = 15.0\n        self._max_radius = 50.0\n        self._elapsed_time_limit = 10.0  # seconds\n        self._informed_sampling_enabled = True\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    def _get_distance(self, frm: 'Point', to: 'Point') -> float:\n        return self._get_grid().get_distance(frm, to)\n\n    def _get_random_sample(self) -> 'Point':\n        \"\"\"\n        Perform informed sampling: samples inside an ellipsoid defined by current best solution cost,\n        between start and goal positions, if available. Otherwise uniform random sampling.\n        \"\"\"\n        grid = self._get_grid()\n        start = grid.agent.position\n        goal = grid.goal.position\n\n        if not self._informed_sampling_enabled or self._graph.root_vertex_goal.cost is None or self._graph.root_vertex_goal.cost == float('inf'):\n            # Uniform random sample in grid boundaries:\n            while True:\n                sample_coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling ellipse parameters:\n        c_best = self._graph.root_vertex_goal.cost\n        c_min = self._get_distance(start, goal)\n        if c_best is None or c_best == float('inf'):\n            c_best = float('inf')\n        if c_min == 0:\n            # Start and goal are same position (corner case)\n            return start\n\n        # Sample inside prolate hyperspheroid (in 2D ellipse) around start and goal\n        while True:\n            # Draw random sample inside unit n-ball:\n            dim = grid.size.n_dim\n            sample_in_ball = self._sample_unit_n_ball(dim)\n            # Scale according to ellipse radii:\n            r1 = c_best / 2.0\n            r2 = (c_best**2 - c_min**2)**0.5 / 2.0 if c_best > c_min else 0.0\n\n            if dim == 2:\n                # 2D case\n                sg_dir = (goal.to_tensor() - start.to_tensor())\n                sg_dir_norm = torch.norm(sg_dir)\n                if sg_dir_norm == 0:\n                    # Avoid division by zero\n                    return start\n                sg_dir = sg_dir / sg_dir_norm\n                rot = torch.tensor([[sg_dir[0], -sg_dir[1]], [sg_dir[1], sg_dir[0]]])\n                L = rot @ torch.diag(torch.tensor([r1, r2]))\n            else:\n                # For general n-dimensions, use alignment rotation with SVD:\n                sg_dir = (goal.to_tensor() - start.to_tensor())\n                sg_dir_norm = torch.norm(sg_dir)\n                if sg_dir_norm == 0:\n                    return start\n                sg_dir = sg_dir / sg_dir_norm\n                # Use torch.linalg.svd to get U, S, Vh instead of deprecated torch.svd\n                U, _, _ = torch.linalg.svd(sg_dir.unsqueeze(1))\n                L = U @ torch.diag(torch.tensor([r1] + [r2]*(dim-1)))\n\n            transformed = L @ sample_in_ball\n            center = (start.to_tensor() + goal.to_tensor()) / 2.0\n            sample_coords = transformed + center\n            sample_point = Point.from_tensor(sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _sample_unit_n_ball(self, dim: int) -> torch.Tensor:\n        \"\"\"\n        Uniformly sample from unit n-ball in R^dim\n        \"\"\"\n        vec = torch.randn(dim)\n        vec /= torch.norm(vec)\n        r = torch.rand(1).pow(1.0 / dim)\n        return vec * r\n\n    def _get_nearest_vertex(self, q_sample: 'Point') -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: 'Point', max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(direction)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / norm\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        new_point = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_point)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Reconstruct path from goal to start along parents:\n        path: List[Vertex] = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n        # Path shortcut smoothing by removing unnecessary vertices along line of sight\n        path = self._shortcut_smooth(path)\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_smooth(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Attempt to shortcut path by removing intermediate vertices where straight \n        line between two vertices is collision free.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        new_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(new_path[-1].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        iterations = 20000\n        dim = grid.size.n_dim\n        lambda_rrt_star = 50.0\n        start_time = time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        goal_vertex.cost = float('inf')\n\n        for i in range(iterations):\n            elapsed = time() - start_time\n            if elapsed > self._elapsed_time_limit:\n                # Mark failure by setting goal cost to inf and return\n                goal_vertex.cost = float('inf')\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                self.key_frame()\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            is_valid = grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest.position, q_new.position))\n            if not is_valid:\n                self.key_frame()\n                continue\n\n            card_v = float(self._graph.size)\n            log_card_v = torch.log(torch.tensor(card_v)) if card_v > 1 else torch.tensor(0.0)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dim)), self._max_radius)\n\n            near_vertices = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._get_distance(q_nearest.position, q_new.position)\n\n            # Choose best parent with minimum cost and collision-free edge\n            for q_near in near_vertices:\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position))\n                cost = q_near.cost + self._get_distance(q_near.position, q_new.position)\n                if line_free and cost < c_min:\n                    q_min = q_near\n                    c_min = cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if cost improves their cost\n            for q_near in near_vertices:\n                if q_near == q_min:\n                    continue\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position))\n                cost_through_qnew = q_new.cost + self._get_distance(q_new.position, q_near.position)\n                if line_free and cost_through_qnew < q_near.cost:\n                    # Remove old edge, add new edge, update cost\n                    old_parents = list(q_near.parents)\n                    for old_parent in old_parents:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = cost_through_qnew\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if can connect to goal and update best cost if improved\n            dist_to_goal = self._get_distance(q_new.position, goal_vertex.position)\n            if dist_to_goal <= self._max_dist:\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position))\n                if line_free:\n                    goal_cost_candidate = q_new.cost + dist_to_goal\n                    if goal_cost_candidate < goal_vertex.cost:\n                        # Connect q_new to goal and update goal cost\n                        goal_vertex.cost = goal_cost_candidate\n                        self._graph.add_edge(q_new, goal_vertex)\n                        # Extract and smooth path\n                        self._extract_path(goal_vertex)\n                        return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 266, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 225, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 206, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 194, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This is an improved bidirectional informed RRT* inspired sample-based path planner\n      designed to enhance planning efficiency, path quality, robustness, path smoothness,\n      and success rate while reducing search time and path length.\n\n      Key features:\n      - Bidirectional trees (start and goal)\n      - Informed sampling focused around an ellipsoidal subset for path improvement\n      - Asymptotic optimality with rewiring to improve path quality dynamically\n      - Early termination when goal reachable\n      - Smoothness promotion by limiting step length and rewiring better parents\n      - Time-limited search (10 seconds max) to avoid long runtimes",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _start_time: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 12.0\n        self._iterations = 15000\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self, c_best: Optional[float], c_min: float, x_center: Point, C: List[List[float]]) -> Point:\n        \"\"\"Generate informed sample within an ellipsoid if c_best < inf, otherwise uniform random.\"\"\"\n        dim = self._get_grid().size.n_dim\n        if c_best == math.inf or c_best == 0 or c_best is None:\n            while True:\n                sample_coords = [self._services.get_random().randint(0, self._get_grid().size[i]-1) for i in range(dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling inside ellipsoid defined by c_best and transformation C\n        for _ in range(100):  # limited retries\n            # Sample unit n-ball\n            while True:\n                x_ball = [self._services.get_random().normalvariate(0, 1) for _ in range(dim)]\n                s = sum(v*v for v in x_ball)\n                if s > 0:\n                    x_ball = [v / math.sqrt(s) for v in x_ball]\n                    break\n            r = self._services.get_random().random() ** (1.0/dim)\n            x_ball = [r*v for v in x_ball]\n\n            # Scale by axis lengths\n            L = [c_best/2.0] + [math.sqrt(c_best*c_best - c_min*c_min)/2.0]*(dim-1)\n            x_scaled = [L[i] * x_ball[i] for i in range(dim)]\n\n            # Rotate and translate back to center\n            x_rotated = [sum(C[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim)]\n            sample_coords = [int(round(x_center[i] + x_rotated[i])) for i in range(dim)]\n            sample = Point(*sample_coords)\n\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n        # fallback uniform sample\n        while True:\n            sample_coords = [self._services.get_random().randint(0, self._get_grid().size[i]-1) for i in range(dim)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([root_vertex], q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        else:\n            dir_normalized = vec / dist\n            new_pos = q_near.position.to_tensor() + max_dist * dir_normalized\n            q_new = Point.from_tensor(new_pos)\n            return Vertex(q_new)\n\n    def _get_vertices_near(self, root_vertex: Vertex, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([root_vertex], q_new.position, radius)\n\n    def _rewire(self, root_vertex: Vertex, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # Try to improve cost to q_new by rewiring from neighbors\n        best_cost = q_new.cost if hasattr(q_new, 'cost') else math.inf\n        best_parent = None\n        for neighbor in neighbors:\n            if neighbor is q_new:\n                continue\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position)):\n                cost = neighbor.cost if hasattr(neighbor, 'cost') else 0.0\n                cost += self._get_grid().get_movement_cost(neighbor.position, q_new.position)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_parent = neighbor\n\n        if best_parent is not None:\n            # Reassign parent and cost\n            for p in list(q_new.parents):\n                self._graph.remove_edge(p, q_new)\n\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Try to rewire neighbors for which q_new offers better cost\n            for neighbor in neighbors:\n                if neighbor is q_new or neighbor is best_parent:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                    neighbor_cost = neighbor.cost if hasattr(neighbor, 'cost') else math.inf\n                    new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n                    if new_cost < neighbor_cost:\n                        for p in list(neighbor.parents):\n                            self._graph.remove_edge(p, neighbor)\n                        neighbor.cost = new_cost\n                        self._graph.add_edge(q_new, neighbor)\n\n    def _path_to_start(self, vertex: Vertex) -> List[Vertex]:\n        path = []\n        curr = vertex\n        while curr is not None:\n            path.append(curr)\n            if len(curr.parents) == 0:\n                break\n            # Pick the parent with minimal cost (or first if cost undefined)\n            costs_and_parents = [(p.cost if hasattr(p, 'cost') else 0, p) for p in curr.parents]\n            costs_and_parents.sort(key=lambda x: x[0])\n            curr = costs_and_parents[0][1]\n        path.reverse()\n        return path\n\n    def _extract_path(self, meet_vertex_start: Vertex, meet_vertex_goal: Vertex) -> None:\n        path_start = self._path_to_start(meet_vertex_start)\n        path_goal = self._path_to_start(meet_vertex_goal)\n        path_goal.reverse()  # from meeting vertex to goal\n        # Merge paths excluding duplicated meeting vertex\n        full_path = path_start + path_goal[1:]\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _build_rotation_matrix(self, x_center: List[float], goal_center: List[float]) -> List[List[float]]:\n        # Create orthonormal basis with first axis in direction (start->goal)\n        dim = len(x_center)\n        dir_vector = [goal_center[i] - x_center[i] for i in range(dim)]\n        dist = math.sqrt(sum(d * d for d in dir_vector))\n        if dist == 0:\n            return [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]  # Identity matrix\n\n        e1 = [d / dist for d in dir_vector]\n        U = [e1]  # Base first vector\n\n        # Use Gram-Schmidt to generate remaining orthonormal basis vectors\n        for i in range(1, dim):\n            base_vector = [0]*dim\n            base_vector[i] = 1\n            proj = sum(base_vector[j]*e1[j] for j in range(dim))\n            orthogonal_vec = [base_vector[j]-proj*e1[j] for j in range(dim)]\n            norm_orth = math.sqrt(sum(x*x for x in orthogonal_vec))\n            if norm_orth < 1e-10:\n                # fallback vector orthogonal to e1\n                orthogonal_vec = [0]*dim\n                orthogonal_vec[(i)%dim] = 1\n                norm_orth = 1\n            orthonormal_vec = [x / norm_orth for x in orthogonal_vec]\n            U.append(orthonormal_vec)\n        return [list(col) for col in zip(*U)]  # transpose for rotation matrix\n\n    # Main function to find path #\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        self._start_time = start_time\n\n        dim = self._get_grid().size.n_dim\n        start_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n\n        # Initialize costs\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = 0.0\n\n        c_min = self._get_grid().get_distance(start_pos, goal_pos)  # minimum possible distance\n        c_best = math.inf\n\n        # Ellipsoid center and rotation matrix for informed sampling\n        x_center = [(start_pos[i] + goal_pos[i]) / 2.0 for i in range(dim)]\n        C = self._build_rotation_matrix(list(start_pos), list(goal_pos))\n\n        # Add roots to vertex lists\n        vertices_start = [self._graph.root_vertex_start]\n        vertices_goal = [self._graph.root_vertex_goal]\n\n        # Internal helper to grow tree towards q_target\n        def extend(root_vertex: Vertex, q_target: Point) -> Tuple[str, Optional[Vertex]]:\n            q_near = self._get_nearest_vertex(root_vertex, q_target)\n            q_new = self._get_new_vertex(q_near, q_target, self._max_dist)\n\n            # Reject if invalid line crossing obstacles\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                return 'trapped', None\n\n            # Compute cost to new vertex\n            cost_near = q_near.cost if hasattr(q_near, 'cost') else 0.0\n            move_cost = self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = cost_near + move_cost\n\n            # Find neighbors for rewiring\n            radius = min(self._max_dist * 2.0, self._max_dist*((math.log(len(vertices_start)+len(vertices_goal)+1)/ (len(vertices_start)+len(vertices_goal)+1))**(1/dim)))\n            near_vertices = self._get_vertices_near(root_vertex, q_new, radius)\n\n            # Pick best parent for q_new among near vertices to reduce cost\n            best_cost = q_new.cost\n            best_parent = q_near\n            for near_v in near_vertices:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(near_v.position, q_new.position)):\n                    cost = near_v.cost + self._get_grid().get_movement_cost(near_v.position, q_new.position) if hasattr(near_v, 'cost') else math.inf\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_parent = near_v\n            q_new.cost = best_cost\n\n            # Add q_new and connect best parent\n            self._graph.add_edge(best_parent, q_new)\n            vertices = vertices_start if root_vertex is self._graph.root_vertex_start else vertices_goal\n            vertices.append(q_new)\n\n            # Rewire neighbors to q_new if better\n            self._rewire(root_vertex, q_new, near_vertices)\n\n            if q_new.position == q_target:\n                return 'reached', q_new\n            else:\n                return 'advanced', q_new\n\n        # Bidirectional tree extension alternates between start and goal trees\n        for iter_count in range(self._iterations):\n            if time.time() - start_time > 10.0:\n                # Fail early on timeout\n                return\n\n            # Determine informed sampling radius (c_best)\n            if c_best == math.inf:\n                sample_point = self._get_random_sample(None, c_min, x_center, C)\n            else:\n                sample_point = self._get_random_sample(c_best, c_min, x_center, C)\n\n            # Alternate trees: even iter - start, odd iter - goal\n            tree_selector = iter_count % 2\n            tree_root = self._graph.root_vertex_start if tree_selector == 0 else self._graph.root_vertex_goal\n            other_tree_root = self._graph.root_vertex_goal if tree_selector == 0 else self._graph.root_vertex_start\n            tree_vertices = vertices_start if tree_selector == 0 else vertices_goal\n            other_tree_vertices = vertices_goal if tree_selector == 0 else vertices_start\n\n            outcome, q_new = extend(tree_root, sample_point)\n            if outcome == 'trapped' or q_new is None:\n                self.key_frame()\n                continue\n\n            # Try to connect the opposite tree towards q_new\n            outcome_connect, q_new_connect = 'advanced', None\n            q_target = q_new.position\n            while outcome_connect == 'advanced':\n                outcome_connect, q_new_connect = extend(other_tree_root, q_target)\n                if outcome_connect == 'reached':\n                    # Path found: extract\n                    v_from_tree = q_new if tree_selector == 0 else q_new_connect\n                    v_from_other = q_new_connect if tree_selector == 0 else q_new\n                    c_best = min(c_best, v_from_tree.cost + v_from_other.cost)\n\n                    self._extract_path(v_from_tree, v_from_other)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 266, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 225, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 206, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 275, in _find_path_internal\n  File \"<string>\", line 62, in _get_random_sample\n  File \"<string>\", line 62, in <listcomp>\nAttributeError: 'Services' object has no attribute 'get_random'\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This is an improved bidirectional informed RRT* inspired sample-based path planner\n      designed to enhance planning efficiency, path quality, robustness, path smoothness,\n      and success rate while reducing search time and path length.\n\n      Key features:\n      - Bidirectional trees (start and goal)\n      - Informed sampling focused around an ellipsoidal subset for path improvement\n      - Asymptotic optimality with rewiring to improve path quality dynamically\n      - Early termination when goal reachable\n      - Smoothness promotion by limiting step length and rewiring better parents\n      - Time-limited search (10 seconds max) to avoid long runtimes",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _start_time: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 12.0\n        self._iterations = 15000\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self, c_best: Optional[float], c_min: float, x_center: Point, C: List[List[float]]) -> Point:\n        \"\"\"Generate informed sample within an ellipsoid if c_best < inf, otherwise uniform random.\"\"\"\n        dim = self._get_grid().size.n_dim\n        random_generator = self._services.random  # Correct access to random generator\n        if c_best == math.inf or c_best == 0 or c_best is None:\n            while True:\n                sample_coords = [random_generator.randint(0, self._get_grid().size[i]-1) for i in range(dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling inside ellipsoid defined by c_best and transformation C\n        for _ in range(100):  # limited retries\n            # Sample unit n-ball\n            while True:\n                x_ball = [random_generator.normalvariate(0, 1) for _ in range(dim)]\n                s = sum(v*v for v in x_ball)\n                if s > 0:\n                    x_ball = [v / math.sqrt(s) for v in x_ball]\n                    break\n            r = random_generator.random() ** (1.0/dim)\n            x_ball = [r*v for v in x_ball]\n\n            # Scale by axis lengths\n            L = [c_best/2.0] + [math.sqrt(c_best*c_best - c_min*c_min)/2.0]*(dim-1)\n            x_scaled = [L[i] * x_ball[i] for i in range(dim)]\n\n            # Rotate and translate back to center\n            x_rotated = [sum(C[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim)]\n            sample_coords = [int(round(x_center[i] + x_rotated[i])) for i in range(dim)]\n            sample = Point(*sample_coords)\n\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n        # fallback uniform sample\n        while True:\n            sample_coords = [random_generator.randint(0, self._get_grid().size[i]-1) for i in range(dim)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([root_vertex], q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        else:\n            dir_normalized = vec / dist\n            new_pos = q_near.position.to_tensor() + max_dist * dir_normalized\n            q_new = Point.from_tensor(new_pos)\n            return Vertex(q_new)\n\n    def _get_vertices_near(self, root_vertex: Vertex, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([root_vertex], q_new.position, radius)\n\n    def _rewire(self, root_vertex: Vertex, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # Try to improve cost to q_new by rewiring from neighbors\n        best_cost = q_new.cost if hasattr(q_new, 'cost') else math.inf\n        best_parent = None\n        for neighbor in neighbors:\n            if neighbor is q_new:\n                continue\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position)):\n                cost = neighbor.cost if hasattr(neighbor, 'cost') else 0.0\n                cost += self._get_grid().get_movement_cost(neighbor.position, q_new.position)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_parent = neighbor\n\n        if best_parent is not None:\n            # Reassign parent and cost\n            for p in list(q_new.parents):\n                self._graph.remove_edge(p, q_new)\n\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Try to rewire neighbors for which q_new offers better cost\n            for neighbor in neighbors:\n                if neighbor is q_new or neighbor is best_parent:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                    neighbor_cost = neighbor.cost if hasattr(neighbor, 'cost') else math.inf\n                    new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n                    if new_cost < neighbor_cost:\n                        for p in list(neighbor.parents):\n                            self._graph.remove_edge(p, neighbor)\n                        neighbor.cost = new_cost\n                        self._graph.add_edge(q_new, neighbor)\n\n    def _path_to_start(self, vertex: Vertex) -> List[Vertex]:\n        path = []\n        curr = vertex\n        while curr is not None:\n            path.append(curr)\n            if len(curr.parents) == 0:\n                break\n            # Pick the parent with minimal cost (or first if cost undefined)\n            costs_and_parents = [(p.cost if hasattr(p, 'cost') else 0, p) for p in curr.parents]\n            costs_and_parents.sort(key=lambda x: x[0])\n            curr = costs_and_parents[0][1]\n        path.reverse()\n        return path\n\n    def _extract_path(self, meet_vertex_start: Vertex, meet_vertex_goal: Vertex) -> None:\n        path_start = self._path_to_start(meet_vertex_start)\n        path_goal = self._path_to_start(meet_vertex_goal)\n        path_goal.reverse()  # from meeting vertex to goal\n        # Merge paths excluding duplicated meeting vertex\n        full_path = path_start + path_goal[1:]\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _build_rotation_matrix(self, x_center: List[float], goal_center: List[float]) -> List[List[float]]:\n        # Create orthonormal basis with first axis in direction (start->goal)\n        dim = len(x_center)\n        dir_vector = [goal_center[i] - x_center[i] for i in range(dim)]\n        dist = math.sqrt(sum(d * d for d in dir_vector))\n        if dist == 0:\n            return [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]  # Identity matrix\n\n        e1 = [d / dist for d in dir_vector]\n        U = [e1]  # Base first vector\n\n        # Use Gram-Schmidt to generate remaining orthonormal basis vectors\n        for i in range(1, dim):\n            base_vector = [0]*dim\n            base_vector[i] = 1\n            proj = sum(base_vector[j]*e1[j] for j in range(dim))\n            orthogonal_vec = [base_vector[j]-proj*e1[j] for j in range(dim)]\n            norm_orth = math.sqrt(sum(x*x for x in orthogonal_vec))\n            if norm_orth < 1e-10:\n                # fallback vector orthogonal to e1\n                orthogonal_vec = [0]*dim\n                orthogonal_vec[(i)%dim] = 1\n                norm_orth = 1\n            orthonormal_vec = [x / norm_orth for x in orthogonal_vec]\n            U.append(orthonormal_vec)\n        return [list(col) for col in zip(*U)]  # transpose for rotation matrix\n\n    # Main function to find path #\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        self._start_time = start_time\n\n        dim = self._get_grid().size.n_dim\n        start_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n\n        # Initialize costs\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = 0.0\n\n        c_min = self._get_grid().get_distance(start_pos, goal_pos)  # minimum possible distance\n        c_best = math.inf\n\n        # Ellipsoid center and rotation matrix for informed sampling\n        x_center = [(start_pos[i] + goal_pos[i]) / 2.0 for i in range(dim)]\n        C = self._build_rotation_matrix(list(start_pos), list(goal_pos))\n\n        # Add roots to vertex lists\n        vertices_start = [self._graph.root_vertex_start]\n        vertices_goal = [self._graph.root_vertex_goal]\n\n        # Internal helper to grow tree towards q_target\n        def extend(root_vertex: Vertex, q_target: Point) -> Tuple[str, Optional[Vertex]]:\n            q_near = self._get_nearest_vertex(root_vertex, q_target)\n            q_new = self._get_new_vertex(q_near, q_target, self._max_dist)\n\n            # Reject if invalid line crossing obstacles\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                return 'trapped', None\n\n            # Compute cost to new vertex\n            cost_near = q_near.cost if hasattr(q_near, 'cost') else 0.0\n            move_cost = self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = cost_near + move_cost\n\n            # Find neighbors for rewiring\n            radius = min(self._max_dist * 2.0, self._max_dist*((math.log(len(vertices_start)+len(vertices_goal)+1)/ (len(vertices_start)+len(vertices_goal)+1))**(1/dim)))\n            near_vertices = self._get_vertices_near(root_vertex, q_new, radius)\n\n            # Pick best parent for q_new among near vertices to reduce cost\n            best_cost = q_new.cost\n            best_parent = q_near\n            for near_v in near_vertices:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(near_v.position, q_new.position)):\n                    cost = near_v.cost + self._get_grid().get_movement_cost(near_v.position, q_new.position) if hasattr(near_v, 'cost') else math.inf\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_parent = near_v\n            q_new.cost = best_cost\n\n            # Add q_new and connect best parent\n            self._graph.add_edge(best_parent, q_new)\n            vertices = vertices_start if root_vertex is self._graph.root_vertex_start else vertices_goal\n            vertices.append(q_new)\n\n            # Rewire neighbors to q_new if better\n            self._rewire(root_vertex, q_new, near_vertices)\n\n            if q_new.position == q_target:\n                return 'reached', q_new\n            else:\n                return 'advanced', q_new\n\n        # Bidirectional tree extension alternates between start and goal trees\n        for iter_count in range(self._iterations):\n            if time.time() - start_time > 10.0:\n                # Fail early on timeout\n                return\n\n            # Determine informed sampling radius (c_best)\n            if c_best == math.inf:\n                sample_point = self._get_random_sample(None, c_min, x_center, C)\n            else:\n                sample_point = self._get_random_sample(c_best, c_min, x_center, C)\n\n            # Alternate trees: even iter - start, odd iter - goal\n            tree_selector = iter_count % 2\n            tree_root = self._graph.root_vertex_start if tree_selector == 0 else self._graph.root_vertex_goal\n            other_tree_root = self._graph.root_vertex_goal if tree_selector == 0 else self._graph.root_vertex_start\n            tree_vertices = vertices_start if tree_selector == 0 else vertices_goal\n            other_tree_vertices = vertices_goal if tree_selector == 0 else vertices_start\n\n            outcome, q_new = extend(tree_root, sample_point)\n            if outcome == 'trapped' or q_new is None:\n                self.key_frame()\n                continue\n\n            # Try to connect the opposite tree towards q_new\n            outcome_connect, q_new_connect = 'advanced', None\n            q_target = q_new.position\n            while outcome_connect == 'advanced':\n                outcome_connect, q_new_connect = extend(other_tree_root, q_target)\n                if outcome_connect == 'reached':\n                    # Path found: extract\n                    v_from_tree = q_new if tree_selector == 0 else q_new_connect\n                    v_from_other = q_new_connect if tree_selector == 0 else q_new\n                    c_best = min(c_best, v_from_tree.cost + v_from_other.cost)\n\n                    self._extract_path(v_from_tree, v_from_other)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 266, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 225, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 206, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 276, in _find_path_internal\n  File \"<string>\", line 60, in _get_random_sample\nAttributeError: 'Services' object has no attribute 'random'\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an advanced sample-based planner combining adaptive hybrid sampling,\n    dynamic radius graph construction, and anytime path optimization.\n    It integrates:\n    - Hybrid sampling: mixes uniform and obstacle-informed guided samples (using obstacle boundaries)\n      to improve exploration efficiency and obstacle avoidance.\n    - Dynamic neighbor radius based on sampling density and iteration count for adaptive rewiring.\n    - Anytime incremental search: progressively refines path quality by rewiring and smoothing during planning.\n    - Lazy collision checking combined with incremental path validation for speed.\n    - Early termination if no improvement after some iterations or 10 seconds limit.\n    This approach improves path quality, success rate, and reduces planning time, while maintaining robustness and smooth paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        # Parameters (tunable)\n        self._max_dist = 10.0\n        self._max_radius = 35.0\n        self._lambda_rrt_star = 40.0\n        self._dimension = self._get_grid().size.n_dim\n\n        # For hybrid sampling\n        self._obstacle_boundaries = self._compute_obstacle_boundaries()\n\n        self._start_time = 0\n        self._max_time_sec = 10.0\n        self._samples_taken = 0\n\n        self._found_path = False\n        self._best_goal_vertex = None\n        self._best_cost = float('inf')\n\n        self._improvement_iter = 0  # Counts iterations without improvement for early stop\n        self._max_no_improve_iter = 300  # After these, terminate search early\n\n        self._init_displays()\n\n    def _compute_obstacle_boundaries(self) -> List[Point]:\n        \"\"\"\n        Compute boundary points of all obstacles to inform hybrid sampling.\n        Returns a combined list of obstacle boundary points.\n        \"\"\"\n        boundaries = []\n        visited = set()\n        for obs in self._get_grid().obstacles:\n            bound = self._get_grid().get_obstacle_bound(obs.position, visited)\n            boundaries.extend(bound)\n            visited.update(bound)\n        return boundaries\n\n    def _sample_from_obstacle_boundaries(self) -> Point:\n        \"\"\"\n        Sample near obstacle boundaries with Gaussian noise.\n        This encourages samples close but not inside obstacles.\n        \"\"\"\n        import random\n        import torch\n\n        if not self._obstacle_boundaries:\n            return self._get_random_sample_uniform()\n\n        # Choose random boundary point\n        base_pt = random.choice(self._obstacle_boundaries)\n\n        # Add small Gaussian offset to avoid exact obstacles and promote clearance\n        offset_scale = 3.0  # tunable\n        noise = []\n        for i in range(self._dimension):\n            noise.append(torch.normal(mean=0.0, std=offset_scale).item())\n        new_coords = []\n        grid_size = self._get_grid().size\n        for i in range(self._dimension):\n            c = base_pt[i] + noise[i]\n            c = max(0, min(c, grid_size[i] - 1))\n            new_coords.append(int(round(c)))\n\n        new_point = Point(*new_coords)\n        if self._get_grid().is_agent_valid_pos(new_point):\n            return new_point\n        else:\n            # Fallback uniform sample\n            return self._get_random_sample_uniform()\n\n    def _get_random_sample_uniform(self) -> Point:\n        \"\"\"Uniform random sample anywhere valid in workspace.\"\"\"\n        grid_size = self._get_grid().size\n        import torch\n        while True:\n            coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(self._dimension)]\n            p = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(p):\n                return p\n\n    def _get_hybrid_sample(self, p_obstacle_prob=0.3) -> Point:\n        \"\"\"\n        Hybrid sample: with probability p_obstacle_prob sample near obstacle boundaries,\n        else uniform random.\n        \"\"\"\n        import random\n        if random.random() < p_obstacle_prob:\n            return self._sample_from_obstacle_boundaries()\n        else:\n            return self._get_random_sample_uniform()\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        import torch\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec).item()\n        if length < 1e-6:\n            return None\n        if length <= self._max_dist:\n            new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / length\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_pos = Point.from_tensor(new_pos_tensor)\n\n        if not self._get_grid().is_agent_valid_pos(new_pos):\n            return None\n\n        return Vertex(new_pos)\n\n    def _line_collision_free_lazy(self, frm: Point, to: Point) -> bool:\n        \"\"\"\n        Lazy collision check: quickly reject invalid edges by stepping over line points.\n        Early exit on first invalid point.\n        \"\"\"\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        for p in line_seq:\n            if not self._get_grid().is_agent_valid_pos(p):\n                return False\n        return True\n\n    def _rewire(self, q_new: Vertex, Q_near: List[Vertex]) -> None:\n        import torch\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n            if dist > self._max_dist:\n                continue\n            new_cost = q_new.cost + dist\n            if q_near.cost is None or new_cost < q_near.cost:\n                if self._line_collision_free_lazy(q_new.position, q_near.position):\n                    # Remove old parent edge\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    # Add new edge\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Vertex]:\n        path = [goal_vertex]\n        while len(path[-1].parents) > 0:\n            min_parent = None\n            min_cost = float('inf')\n            for parent in path[-1].parents:\n                if parent.cost is not None and parent.cost < min_cost:\n                    min_cost = parent.cost\n                    min_parent = parent\n            if min_parent is None:\n                break\n            path.append(min_parent)\n        path.reverse()\n        return path\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_collision_free_lazy(path[i].position, path[j].position):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _dynamic_radius(self, n_vertices: int) -> float:\n        import torch\n        if n_vertices <= 1:\n            return self._max_radius\n        log_n = torch.log(torch.tensor(float(n_vertices) + 1e-8))\n        radius = min(self._lambda_rrt_star * ((log_n / n_vertices) ** (1.0 / self._dimension)), self._max_radius)\n        return radius.item()\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        self._start_time = time.perf_counter()\n\n        start = self._graph.root_vertex_start\n        goal = self._graph.root_vertex_goal\n\n        start.cost = 0.0\n        self._found_path = False\n        self._best_goal_vertex = None\n        self._best_cost = float('inf')\n        self._improvement_iter = 0\n\n        max_iterations = 15000\n\n        for iteration in range(max_iterations):\n            if time.perf_counter() - self._start_time > self._max_time_sec:\n                # Time limit exceeded, fail gracefully\n                break\n\n            # Hybrid sampling improves exploration and obstacle avoidance\n            q_sample = self._get_hybrid_sample()\n\n            q_near = self._get_nearest_vertex(q_sample)\n            if q_near is None:\n                continue\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            if q_new is None:\n                continue\n\n            # Lazy collision check before further processing\n            if not self._line_collision_free_lazy(q_near.position, q_new.position):\n                continue\n\n            cost_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = cost_to_new\n\n            # Dynamic radius based on current graph size\n            radius = self._dynamic_radius(self._graph.size)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent from Q_near minimizing cost and collision-free\n            q_min = q_near\n            c_min_vertex = cost_to_new\n            for q_near_cand in Q_near:\n                if q_near_cand == q_new:\n                    continue\n                dist = torch.norm(q_near_cand.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist > self._max_dist:\n                    continue\n                cand_cost = q_near_cand.cost + dist\n                if q_near_cand.cost is not None and cand_cost < c_min_vertex:\n                    if self._line_collision_free_lazy(q_near_cand.position, q_new.position):\n                        q_min = q_near_cand\n                        c_min_vertex = cand_cost\n\n            q_new.cost = c_min_vertex\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors for improved paths\n            self._rewire(q_new, Q_near)\n\n            # Insert new vertex into graph root vertices so it expands graph size\n            self._graph.root_vertices.append(q_new)\n\n            # Check goal proximity\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Evaluate path cost including cost to goal point\n                dist_goal = torch.norm(q_new.position.to_tensor() - goal.position.to_tensor()).item()\n                total_cost = q_new.cost + dist_goal\n                if total_cost + 1e-6 < self._best_cost:  # Allow tiny improvement tolerance\n                    self._best_cost = total_cost\n                    self._best_goal_vertex = q_new\n                    self._found_path = True\n                    self._improvement_iter = 0  # reset no improvement count\n                else:\n                    self._improvement_iter += 1\n            else:\n                self._improvement_iter += 1\n\n            self.key_frame()\n\n            # Early stop if no improvement for too long\n            if self._improvement_iter > self._max_no_improve_iter:\n                break\n\n        # After main loop finishes\n        if self._found_path and self._best_goal_vertex is not None:\n            raw_path = self._extract_path(self._best_goal_vertex)\n            smooth_path = self._smooth_path(raw_path)\n            for vertex in smooth_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # Failed to find path within constraints\n            pass",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 233, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 214, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 256, in _find_path_internal\n  File \"<string>\", line 134, in _get_hybrid_sample\n  File \"<string>\", line 102, in _sample_from_obstacle_boundaries\nTypeError: normal() received an invalid combination of arguments - got (mean=float, std=float, ), but expected one of:\n * (Tensor mean, Tensor std, *, torch.Generator generator = None, Tensor out = None)\n * (Tensor mean, float std = 1, *, torch.Generator generator = None, Tensor out = None)\n * (float mean, Tensor std, *, torch.Generator generator = None, Tensor out = None)\n * (float mean, float std, tuple of ints size, *, torch.Generator generator = None, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)\n\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an improved sampling-based planner inspired by RRT* with informed sampling and lazy collision checking. \n    It maintains a forest graph and incrementally builds paths by sampling points biased towards the goal using ellipsoidal \n    informed sampling, connecting vertices within a neighborhood radius. It uses a rewiring step to improve path quality \n    continuously and performs lazy collision checking only when connecting edges to reduce computation. Search terminates \n    successfully when a valid path to the goal is found or fails if exceeding a 10-second time limit. The approach balances \n    efficient sampling, path quality, smoothness, and computational efficiency to improve over plain SPRM methods.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        self._V_size = 300                  # Larger sample size for better coverage\n        self._max_radius = 20.0             # Neighborhood search radius for rewiring\n        self._goal_bias_prob = 0.2          # Probability to sample the goal point directly\n        self._graph = None\n\n        V = []\n        for _ in range(self._V_size):\n            q_rand = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = True\n\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Samples a point in the grid with goal bias and informed ellipsoidal sampling \n        around the current best path for efficiency.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        agent_pos = grid.agent.position\n\n        # Sampling box bounds\n        bounds = [grid.size[i] for i in range(grid.size.n_dim)]\n\n        # Goal biasing: with some probability sample goal directly\n        if torch.rand(1).item() < self._goal_bias_prob:\n            return Point(*goal_pos)\n\n        # If no path found yet, uniform random sampling\n        if not hasattr(self, \"_best_cost\"):\n            while True:\n                sample_coords = [torch.randint(0, bounds[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed Ellipsoidal Sampling (hypersphere around start-goal)\n        dist_start_goal = Map.get_distance(agent_pos, goal_pos)\n        c_best = getattr(self, \"_best_cost\", float(\"inf\"))\n\n        # If no feasible path cost known, just uniform sampling\n        if not (c_best < float(\"inf\")):\n            while True:\n                sample_coords = [torch.randint(0, bounds[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        c_min = dist_start_goal\n        center = Point(*[(agent_pos[i] + goal_pos[i]) / 2.0 for i in range(agent_pos.n_dim)])\n\n        # Define lengths of ellipse axes - major axis = c_best/2, others = sqrt(c_best\u00b2 - c_min\u00b2)/2\n        r1 = c_best / 2.0\n        if agent_pos.n_dim == 2:\n            r2 = ( (c_best**2 - c_min**2) ** 0.5 ) / 2.0 if c_best > c_min else 0.0\n            # Sample in unit circle then scale into ellipse\n            while True:\n                theta = 2 * 3.14159265359 * torch.rand(1).item()\n                rad = torch.rand(1).item() ** 0.5\n                x = rad * torch.cos(torch.tensor(theta))\n                y = rad * torch.sin(torch.tensor(theta))\n                sample_x = center.x + r1 * x.item()\n                sample_y = center.y + r2 * y.item()\n                sample_pt = Point(int(round(sample_x)), int(round(sample_y)))\n                if 0 <= sample_pt.x < bounds[0] and 0 <= sample_pt.y < bounds[1]:\n                    if grid.is_agent_valid_pos(sample_pt):\n                        return sample_pt\n        else:\n            # For n_dim > 2 uniform sampling inside hyperellipsoid (approximate)\n            while True:\n                rand_dir = torch.randn(agent_pos.n_dim)\n                rand_dir = rand_dir / torch.norm(rand_dir)\n                mag = torch.rand(1).item() ** (1.0 / agent_pos.n_dim)\n                scaled_dir = rand_dir * mag\n                # Scale major axis only along first dimension (approximation)\n                scaled_dir[0] = scaled_dir[0] * r1\n                # For other dims, scale to radius sqrt(c_best\u00b2 - c_min\u00b2)/2\n                scale_minor = ((c_best ** 2 - c_min ** 2) ** 0.5 / 2.0) if c_best > c_min else 0.0\n                for i in range(1, agent_pos.n_dim):\n                    scaled_dir[i] *= scale_minor\n                sample_coords = [center[i] + scaled_dir[i].item() for i in range(agent_pos.n_dim)]\n                sample_coords_int = [int(round(x)) for x in sample_coords]\n                sample_pt = Point(*sample_coords_int)\n                if all(0 <= sample_pt[i] < bounds[i] for i in range(agent_pos.n_dim)):\n                    if grid.is_agent_valid_pos(sample_pt):\n                        return sample_pt\n\n    def _get_near_vertices(self, position: Point) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, position, self._max_radius)\n\n    def _get_cost(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        return self._get_grid().get_movement_cost(from_vertex.position, to_vertex.position)\n\n    def _can_connect(self, p1: Point, p2: Point) -> bool:\n        \"\"\"Lazy collision check via Bresenham line with grid validation.\"\"\"\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Rewires the graph to improve path costs by connecting new_vertex to better parents,\n        and potentially reconnect children to new_vertex if beneficial.\n        \"\"\"\n        improved_parents = []\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex:\n                continue\n            if self._can_connect(near_vertex.position, new_vertex.position):\n                new_cost = near_vertex.cost + self._get_cost(near_vertex, new_vertex)\n                if new_cost < new_vertex.cost:\n                    new_vertex.parents.clear()\n                    new_vertex.cost = new_cost\n                    new_vertex.add_parent(near_vertex)\n                    near_vertex.add_child(new_vertex)\n                    improved_parents.append(near_vertex)\n\n        # Rewire children\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex:\n                continue\n            if self._can_connect(new_vertex.position, near_vertex.position):\n                new_cost = new_vertex.cost + self._get_cost(new_vertex, near_vertex)\n                if new_cost < near_vertex.cost:\n                    for p in list(near_vertex.parents):\n                        p.children.discard(near_vertex)\n                        near_vertex.parents.discard(p)\n                    near_vertex.cost = new_cost\n                    near_vertex.add_parent(new_vertex)\n                    new_vertex.add_child(near_vertex)\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Extracts the best path from the start vertex to the goal vertex using BFS \n        along parents with lowest cost, and moves the agent stepwise along it.\n        \"\"\"\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        # BFS from goal to start by walking parents to build path backward\n        path = deque()\n        current = goal_vertex\n        if current.cost == float(\"inf\"):\n            # No path exists\n            return\n        while current != start_vertex:\n            path.appendleft(current)\n            # Choose the lowest cost parent\n            parents_sorted = sorted(current.parents, key=lambda v: v.cost)\n            if not parents_sorted:\n                # Disconnected, no valid path\n                return\n            current = parents_sorted[0]\n        path.appendleft(start_vertex)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _initialize_costs(self) -> None:\n        \"\"\"Initialize vertex costs: zero for start, infinity else.\"\"\"\n        for v in self._graph.root_vertices:\n            v.cost = float(\"inf\")\n            v.parents.clear()\n            v.children.clear()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n    def _find_path_internal(self) -> None:\n        \"\"\"\n        Main function implementing RRT*-style informed path planning with time limit.\n        Samples, connects, rewires, and updates best path dynamically.\n        \"\"\"\n        grid = self._get_grid()\n        start_time = time()\n        max_duration = 10.0  # seconds timeout\n\n        self._initialize_costs()\n\n        # Insert edges from start and goal roots to their neighbors initially\n        for root in self._graph.root_vertices:\n            near_vertices = self._get_near_vertices(root.position)\n            for near_v in near_vertices:\n                if near_v == root:\n                    continue\n                if self._can_connect(root.position, near_v.position):\n                    cost_edge = self._get_cost(root, near_v)\n                    if root.cost + cost_edge < near_v.cost:\n                        near_v.cost = root.cost + cost_edge\n                        near_v.parents.clear()\n                        near_v.add_parent(root)\n                        root.add_child(near_v)\n\n        vertices = list(self._graph.root_vertices)\n\n        # Main iterative sampling, connecting, rewiring loop\n        while True:\n            if (time() - start_time) > max_duration:\n                return  # timeout/failure\n\n            # Sample new point\n            q_rand = self._get_random_sample()\n\n            # Find nearest vertex to the sampled point\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_rand)\n\n            # Steer towards q_rand with maximum step limited by max_radius (step size)\n            direction = q_rand.to_tensor() - q_near.position.to_tensor()\n            dist = torch.norm(direction).item()\n            if dist == 0:\n                continue\n            if dist > self._max_radius:\n                direction = direction / dist * self._max_radius\n                q_new_pt = Point.from_tensor(q_near.position.to_tensor() + direction)\n            else:\n                q_new_pt = q_rand\n\n            if not grid.is_agent_valid_pos(q_new_pt):\n                continue\n\n            if not self._can_connect(q_near.position, q_new_pt):\n                continue\n\n            q_new = Vertex(q_new_pt, store_connectivity=True)\n            # Cost from start to q_new through q_near\n            tentative_cost = q_near.cost + self._get_cost(q_near, q_new)\n\n            # Find near vertices for rewiring\n            near_vertices = self._get_near_vertices(q_new.position)\n\n            # Choose the best parent for q_new\n            min_cost = tentative_cost\n            best_parent = q_near\n            for near_v in near_vertices:\n                if near_v == q_near:\n                    continue\n                if self._can_connect(near_v.position, q_new.position):\n                    cost_through_near = near_v.cost + self._get_cost(near_v, q_new)\n                    if cost_through_near < min_cost:\n                        min_cost = cost_through_near\n                        best_parent = near_v\n\n            q_new.cost = min_cost\n            q_new.add_parent(best_parent)\n            best_parent.add_child(q_new)\n\n            # Add q_new to vertices and graph root vertices list to maintain structure\n            self._graph.root_vertices.append(q_new)\n            vertices.append(q_new)\n\n            # Rewire neighbors to improve paths\n            self._rewire(q_new, near_vertices)\n\n            # Check if can connect q_new to goal root vertex (possibly shortcut)\n            goal_vertex = self._graph.root_vertex_goal\n            if self._can_connect(q_new.position, goal_vertex.position):\n                cost_to_goal = q_new.cost + self._get_cost(q_new, goal_vertex)\n                if cost_to_goal < goal_vertex.cost:\n                    for p in list(goal_vertex.parents):\n                        p.children.discard(goal_vertex)\n                    goal_vertex.parents.clear()\n                    goal_vertex.cost = cost_to_goal\n                    goal_vertex.add_parent(q_new)\n                    q_new.add_child(goal_vertex)\n\n                    # Update best known cost for informed sampling\n                    self._best_cost = cost_to_goal\n\n                    # Extract and follow path\n                    self._extract_path()\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 233, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 214, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 224, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an improved sampling-based planner inspired by RRT* with informed sampling and lazy collision checking. \n    It maintains a forest graph and incrementally builds paths by sampling points biased towards the goal using ellipsoidal \n    informed sampling, connecting vertices within a neighborhood radius. It uses a rewiring step to improve path quality \n    continuously and performs lazy collision checking only when connecting edges to reduce computation. Search terminates \n    successfully when a valid path to the goal is found or fails if exceeding a 10-second time limit. The approach balances \n    efficient sampling, path quality, smoothness, and computational efficiency to improve over plain SPRM methods.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        self._V_size = 300                  # Larger sample size for better coverage\n        self._max_radius = 20.0             # Neighborhood search radius for rewiring\n        self._goal_bias_prob = 0.2          # Probability to sample the goal point directly\n        self._graph = None\n\n        V = []\n        for _ in range(self._V_size):\n            q_rand = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = True\n\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Samples a point in the grid with goal bias and informed ellipsoidal sampling \n        around the current best path for efficiency.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        agent_pos = grid.agent.position\n\n        # Sampling box bounds\n        bounds = [grid.size[i] for i in range(grid.size.n_dim)]\n\n        # Goal biasing: with some probability sample goal directly\n        if torch.rand(1).item() < self._goal_bias_prob:\n            return Point(*goal_pos)\n\n        # If no path found yet, uniform random sampling\n        if not hasattr(self, \"_best_cost\"):\n            while True:\n                sample_coords = [torch.randint(0, bounds[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed Ellipsoidal Sampling (hypersphere around start-goal)\n        dist_start_goal = Map.get_distance(agent_pos, goal_pos)\n        c_best = getattr(self, \"_best_cost\", float(\"inf\"))\n\n        # If no feasible path cost known, just uniform sampling\n        if not (c_best < float(\"inf\")):\n            while True:\n                sample_coords = [torch.randint(0, bounds[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        c_min = dist_start_goal\n        center = Point(*[(agent_pos[i] + goal_pos[i]) / 2.0 for i in range(agent_pos.n_dim)])\n\n        # Define lengths of ellipse axes - major axis = c_best/2, others = sqrt(c_best\u00b2 - c_min\u00b2)/2\n        r1 = c_best / 2.0\n        if agent_pos.n_dim == 2:\n            r2 = ((c_best**2 - c_min**2) ** 0.5) / 2.0 if c_best > c_min else 0.0\n            # Sample in unit circle then scale into ellipse\n            while True:\n                theta = 2 * 3.14159265359 * torch.rand(1).item()\n                rad = torch.rand(1).item() ** 0.5\n                x = rad * torch.cos(torch.tensor(theta))\n                y = rad * torch.sin(torch.tensor(theta))\n                sample_x = center.x + r1 * x.item()\n                sample_y = center.y + r2 * y.item()\n                sample_pt = Point(int(round(sample_x)), int(round(sample_y)))\n                if 0 <= sample_pt.x < bounds[0] and 0 <= sample_pt.y < bounds[1]:\n                    if grid.is_agent_valid_pos(sample_pt):\n                        return sample_pt\n        else:\n            # For n_dim > 2 uniform sampling inside hyperellipsoid (approximate)\n            while True:\n                rand_dir = torch.randn(agent_pos.n_dim)\n                rand_dir = rand_dir / torch.norm(rand_dir)\n                mag = torch.rand(1).item() ** (1.0 / agent_pos.n_dim)\n                scaled_dir = rand_dir * mag\n                # Scale major axis only along first dimension (approximation)\n                scaled_dir[0] = scaled_dir[0] * r1\n                # For other dims, scale to radius sqrt(c_best\u00b2 - c_min\u00b2)/2\n                scale_minor = ((c_best ** 2 - c_min ** 2) ** 0.5 / 2.0) if c_best > c_min else 0.0\n                for i in range(1, agent_pos.n_dim):\n                    scaled_dir[i] *= scale_minor\n                sample_coords = [center[i] + scaled_dir[i].item() for i in range(agent_pos.n_dim)]\n                sample_coords_int = [int(round(x)) for x in sample_coords]\n                sample_pt = Point(*sample_coords_int)\n                if all(0 <= sample_pt[i] < bounds[i] for i in range(agent_pos.n_dim)):\n                    if grid.is_agent_valid_pos(sample_pt):\n                        return sample_pt\n\n    def _get_near_vertices(self, position: Point) -> list[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, position, self._max_radius)\n\n    def _get_cost(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        return self._get_grid().get_movement_cost(from_vertex.position, to_vertex.position)\n\n    def _can_connect(self, p1: Point, p2: Point) -> bool:\n        \"\"\"Lazy collision check via Bresenham line with grid validation.\"\"\"\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: list[Vertex]) -> None:\n        \"\"\"\n        Rewires the graph to improve path costs by connecting new_vertex to better parents,\n        and potentially reconnect children to new_vertex if beneficial.\n        \"\"\"\n        improved_parents = []\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex:\n                continue\n            if self._can_connect(near_vertex.position, new_vertex.position):\n                new_cost = near_vertex.cost + self._get_cost(near_vertex, new_vertex)\n                if new_cost < new_vertex.cost:\n                    new_vertex.parents.clear()\n                    new_vertex.cost = new_cost\n                    new_vertex.add_parent(near_vertex)\n                    near_vertex.add_child(new_vertex)\n                    improved_parents.append(near_vertex)\n\n        # Rewire children\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex:\n                continue\n            if self._can_connect(new_vertex.position, near_vertex.position):\n                new_cost = new_vertex.cost + self._get_cost(new_vertex, near_vertex)\n                if new_cost < near_vertex.cost:\n                    for p in list(near_vertex.parents):\n                        p.children.discard(near_vertex)\n                        near_vertex.parents.discard(p)\n                    near_vertex.cost = new_cost\n                    near_vertex.add_parent(new_vertex)\n                    new_vertex.add_child(near_vertex)\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Extracts the best path from the start vertex to the goal vertex using BFS \n        along parents with lowest cost, and moves the agent stepwise along it.\n        \"\"\"\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        # BFS from goal to start by walking parents to build path backward\n        path = deque()\n        current = goal_vertex\n        if current.cost == float(\"inf\"):\n            # No path exists\n            return\n        while current != start_vertex:\n            path.appendleft(current)\n            # Choose the lowest cost parent\n            parents_sorted = sorted(current.parents, key=lambda v: v.cost)\n            if not parents_sorted:\n                # Disconnected, no valid path\n                return\n            current = parents_sorted[0]\n        path.appendleft(start_vertex)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _initialize_costs(self) -> None:\n        \"\"\"Initialize vertex costs: zero for start, infinity else.\"\"\"\n        for v in self._graph.root_vertices:\n            v.cost = float(\"inf\")\n            v.parents.clear()\n            v.children.clear()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n    def _find_path_internal(self) -> None:\n        \"\"\"\n        Main function implementing RRT*-style informed path planning with time limit.\n        Samples, connects, rewires, and updates best path dynamically.\n        \"\"\"\n        grid = self._get_grid()\n        start_time = time.time()\n        max_duration = 10.0  # seconds timeout\n\n        self._initialize_costs()\n\n        # Insert edges from start and goal roots to their neighbors initially\n        for root in self._graph.root_vertices:\n            near_vertices = self._get_near_vertices(root.position)\n            for near_v in near_vertices:\n                if near_v == root:\n                    continue\n                if self._can_connect(root.position, near_v.position):\n                    cost_edge = self._get_cost(root, near_v)\n                    if root.cost + cost_edge < near_v.cost:\n                        near_v.cost = root.cost + cost_edge\n                        near_v.parents.clear()\n                        near_v.add_parent(root)\n                        root.add_child(near_v)\n\n        vertices = list(self._graph.root_vertices)\n\n        # Main iterative sampling, connecting, rewiring loop\n        while True:\n            if (time.time() - start_time) > max_duration:\n                return  # timeout/failure\n\n            # Sample new point\n            q_rand = self._get_random_sample()\n\n            # Find nearest vertex to the sampled point\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_rand)\n\n            # Steer towards q_rand with maximum step limited by max_radius (step size)\n            direction = q_rand.to_tensor() - q_near.position.to_tensor()\n            dist = torch.norm(direction).item()\n            if dist == 0:\n                continue\n            if dist > self._max_radius:\n                direction = direction / dist * self._max_radius\n                q_new_pt = Point.from_tensor(q_near.position.to_tensor() + direction)\n            else:\n                q_new_pt = q_rand\n\n            if not grid.is_agent_valid_pos(q_new_pt):\n                continue\n\n            if not self._can_connect(q_near.position, q_new_pt):\n                continue\n\n            q_new = Vertex(q_new_pt, store_connectivity=True)\n            # Cost from start to q_new through q_near\n            tentative_cost = q_near.cost + self._get_cost(q_near, q_new)\n\n            # Find near vertices for rewiring\n            near_vertices = self._get_near_vertices(q_new.position)\n\n            # Choose the best parent for q_new\n            min_cost = tentative_cost\n            best_parent = q_near\n            for near_v in near_vertices:\n                if near_v == q_near:\n                    continue\n                if self._can_connect(near_v.position, q_new.position):\n                    cost_through_near = near_v.cost + self._get_cost(near_v, q_new)\n                    if cost_through_near < min_cost:\n                        min_cost = cost_through_near\n                        best_parent = near_v\n\n            q_new.cost = min_cost\n            q_new.add_parent(best_parent)\n            best_parent.add_child(q_new)\n\n            # Add q_new to vertices and graph root vertices list to maintain structure\n            self._graph.root_vertices.append(q_new)\n            vertices.append(q_new)\n\n            # Rewire neighbors to improve paths\n            self._rewire(q_new, near_vertices)\n\n            # Check if can connect q_new to goal root vertex (possibly shortcut)\n            goal_vertex = self._graph.root_vertex_goal\n            if self._can_connect(q_new.position, goal_vertex.position):\n                cost_to_goal = q_new.cost + self._get_cost(q_new, goal_vertex)\n                if cost_to_goal < goal_vertex.cost:\n                    for p in list(goal_vertex.parents):\n                        p.children.discard(goal_vertex)\n                    goal_vertex.parents.clear()\n                    goal_vertex.cost = cost_to_goal\n                    goal_vertex.add_parent(q_new)\n                    q_new.add_child(goal_vertex)\n\n                    # Update best known cost for informed sampling\n                    self._best_cost = cost_to_goal\n\n                    # Extract and follow path\n                    self._extract_path()\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 269, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 137, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an improved sampling-based planner integrating RRT*-style rewiring, \n    adaptive informed sampling, bidirectional search, and path smoothing. \n    \n    Key improvements:\n    1. Bidirectional tree growth from start and goal, reducing convergence time and improving success rate.\n    2. Adaptive informed sampling ellipsoids from both directions after initial connection, focusing search.\n    3. RRT* rewiring in both trees for path quality improvement.\n    4. Lazy collision checking with early abandon for efficiency.\n    5. Dynamic radius for rewiring based on vertex count and dimensionality.\n    6. After connection, smooth shortcutting path to improve path smoothness and length.\n    7. Strict 10 seconds timeout to fail gracefully.\n\n    The algorithm grows two forests (from start and goal), tries to connect them efficiently, extracts best path, smooths it,\n    and moves the agent along the final planned trajectory.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._max_dist = 12.0\n        self._max_radius = 40.0\n        self._lambda_rrt_star = 40.0\n        self._dimension = self._get_grid().size.n_dim\n        self._start_time = 0\n        self._samples_taken = 0\n        self._found_path = False\n        self._best_start_vertex: Vertex = None\n        self._best_goal_vertex: Vertex = None\n        self._best_cost = float('inf')\n        self._init_displays()\n\n    def _get_random_sample(self, informed_ball_start: tuple = None, informed_ball_goal: tuple = None) -> Point:\n        \"\"\"\n        Samples a point either uniformly or inside combined ellipsoids from start and goal informed sampling.\n        If informed balls for both trees are provided, probabilistically sample from one or uniform.\n        Otherwise uniform sampling.\n        \"\"\"\n        grid_size = self._get_grid().size\n        # Simple logic: 40% from start ellipsoid, 40% from goal ellipsoid, 20% uniform if informed balls exist\n        import random\n        prob = random.random()\n\n        def sample_ellipsoid(center: Point, c_best: float, c_min: float) -> Point:\n            if grid_size.n_dim != 2:\n                # fallback to uniform\n                return None\n            a1 = c_best / 2\n            try:\n                a2 = (c_best**2 - c_min**2)**0.5 / 2\n            except Exception:\n                return None\n            for _ in range(200):\n                rx = torch.FloatTensor(1).uniform_(-1,1).item()\n                ry = torch.FloatTensor(1).uniform_(-1,1).item()\n                norm = (rx**2 + ry**2)**0.5\n                if norm > 1e-5:\n                    break\n            else:\n                return None\n            rx /= norm\n            ry /= norm\n            r = torch.FloatTensor(1).uniform_(0,1).item() ** (1 / 2)\n            x = r * a1 * rx\n            y = r * a2 * ry\n            # Rotation: along vector start -> goal\n            start = self._graph_start.root_vertex_start.position\n            goal = self._graph_start.root_vertex_goal.position\n            delta = torch.tensor([goal.x - start.x, goal.y - start.y])\n            angle = torch.atan2(delta[1], delta[0]).item()\n            cos_ang = torch.cos(torch.tensor(angle))\n            sin_ang = torch.sin(torch.tensor(angle))\n            rot_x = cos_ang * x - sin_ang * y\n            rot_y = sin_ang * x + cos_ang * y\n            sample_x = int(round(center.x + rot_x))\n            sample_y = int(round(center.y + rot_y))\n            sample_x = max(0, min(sample_x, grid_size[0] - 1))\n            sample_y = max(0, min(sample_y, grid_size[1] - 1))\n            sample = Point(sample_x, sample_y)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            return None\n\n        if informed_ball_start and informed_ball_goal:\n            if prob < 0.4:\n                s = sample_ellipsoid(*informed_ball_start)\n                if s is not None:\n                    return s\n            elif prob < 0.8:\n                s = sample_ellipsoid(*informed_ball_goal)\n                if s is not None:\n                    return s\n            # fallback uniform\n        elif informed_ball_start:\n            s = sample_ellipsoid(*informed_ball_start)\n            if s is not None:\n                return s\n        elif informed_ball_goal:\n            s = sample_ellipsoid(*informed_ball_goal)\n            if s is not None:\n                return s\n\n        # uniform sampling fallback\n        attempts = 0\n        while attempts < 500:\n            rand_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(grid_size.n_dim)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n        # As a last resort fallback to agent's position to prevent error\n        return self._get_grid().agent.position\n\n    def _get_nearest_vertex(self, graph: Forest, q_sample: Point) -> Vertex:\n        return graph.get_nearest_vertex(graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, graph: Forest, position: Point, radius: float) -> list:\n        return graph.get_vertices_within_radius(graph.root_vertices, position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec)\n        if length < 1e-6:\n            return None\n        if length <= self._max_dist:\n            new_vertex_pos = q_sample\n        else:\n            dir_normalized = dir_vec / length\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_vertex_pos = Point.from_tensor(new_pos_tensor)\n        if not self._get_grid().is_agent_valid_pos(new_vertex_pos):\n            return None\n        return Vertex(new_vertex_pos)\n\n    def _line_collision_free_lazy(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        for pt in line_seq:\n            if not self._get_grid().is_agent_valid_pos(pt):\n                return False\n        return True\n\n    def _rewire(self, graph: Forest, q_new: Vertex, Q_near: list) -> None:\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n            if dist > self._max_dist:\n                continue\n            new_cost = q_new.cost + dist\n            if new_cost < q_near.cost:\n                if self._line_collision_free_lazy(q_new.position, q_near.position):\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    graph.add_edge(q_new, q_near)\n\n    def _connect_trees(self, v_start: Vertex, v_goal: Vertex) -> (Vertex, Vertex, float):\n        \"\"\"\n        Attempts to connect two vertices from start and goal trees directly if collision-free.\n        Returns tuple (start_vertex, goal_vertex, cost) if successful; else None.\n        \"\"\"\n        if not self._line_collision_free_lazy(v_start.position, v_goal.position):\n            return None\n        dist = torch.norm(v_start.position.to_tensor() - v_goal.position.to_tensor()).item()\n        total_cost = v_start.cost + dist + v_goal.cost\n        return (v_start, v_goal, total_cost)\n\n    def _extract_bidirectional_path(self, start_vertex: Vertex, goal_vertex: Vertex) -> list:\n        \"\"\"\n        Extract path from start vertex in start tree and from goal vertex in goal tree,\n        concatenating paths at meeting point.\n        \"\"\"\n        path_start = []\n        cur = start_vertex\n        while cur is not None:\n            path_start.append(cur)\n            if not cur.parents:\n                break\n            # Choose parent with minimal cost (should usually be one)\n            min_cost = float('inf')\n            min_p = None\n            for p in cur.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_p = p\n            cur = min_p\n        path_start.reverse()\n\n        path_goal = []\n        cur = goal_vertex\n        while cur is not None:\n            path_goal.append(cur)\n            if not cur.parents:\n                break\n            min_cost = float('inf')\n            min_p = None\n            for p in cur.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_p = p\n            cur = min_p\n\n        # Reverse path_goal for correct direction\n        path_goal.reverse()\n        # Remove duplicate meeting vertex at join\n        if len(path_goal) > 0 and len(path_start) > 0 and path_start[-1].position == path_goal[0].position:\n            path_goal = path_goal[1:]\n\n        return path_start + path_goal\n\n    def _smooth_path(self, path: list) -> list:\n        \"\"\"\n        Shortcut smoothing removing unnecessary vertices by connecting farther apart vertices directly.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_collision_free_lazy(path[i].position, path[j].position):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.perf_counter()\n        max_time_sec = 10.0\n        max_iterations = 15000\n\n        start_tree = self._graph_start\n        goal_tree = self._graph_goal\n\n        start_root = start_tree.root_vertex_start\n        goal_root = goal_tree.root_vertex_start\n\n        start_root.cost = 0.0\n        goal_root.cost = 0.0\n\n        self._found_path = False\n        self._best_cost = float('inf')\n        self._best_start_vertex = None\n        self._best_goal_vertex = None\n\n        for iteration in range(max_iterations):\n            if time.perf_counter() - self._start_time > max_time_sec:\n                # timeout -> fail gracefully\n                break\n\n            # Setup informed sampling ellipsoids if path found\n            informed_start = None\n            informed_goal = None\n            if self._found_path and self._best_cost < float('inf'):\n                c_min = torch.norm(start_root.position.to_tensor() - goal_root.position.to_tensor()).item()\n                c_best = self._best_cost\n                center_start = Point((start_root.position.x + goal_root.position.x) / 2,\n                                     (start_root.position.y + goal_root.position.y) / 2)\n                informed_start = (center_start, c_best, c_min)\n                informed_goal = (center_start, c_best, c_min)\n\n            # Alternate tree growth: odd iteration grow start tree, even grow goal tree\n            growing_start_tree = (iteration % 2 == 0)\n            graph = start_tree if growing_start_tree else goal_tree\n            other_graph = goal_tree if growing_start_tree else start_tree\n            root_vertex = graph.root_vertex_start\n\n            q_sample = self._get_random_sample(informed_ball_start=informed_start, informed_ball_goal=informed_goal)\n            q_near = self._get_nearest_vertex(graph, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            if not q_new:\n                continue\n\n            if not self._line_collision_free_lazy(q_near.position, q_new.position):\n                continue\n\n            dist = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = q_near.cost + dist\n\n            card_V = max(1, graph.size)\n            log_card_V = torch.log(torch.tensor(float(card_V) + 1e-8))\n            radius = min(self._lambda_rrt_star * ((log_card_V / card_V) ** (1.0 / self._dimension)), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(graph, q_new.position, radius)\n\n            # Choose parent with minimum cost + collision free\n            q_min = q_near\n            c_min_vertex = q_near.cost\n            for q_near_candidate in Q_near:\n                if q_near_candidate == q_new:\n                    continue\n                dist_candidate = torch.norm(q_near_candidate.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist_candidate > self._max_dist:\n                    continue\n                cost_candidate = q_near_candidate.cost + dist_candidate\n                if cost_candidate < c_min_vertex:\n                    if self._line_collision_free_lazy(q_near_candidate.position, q_new.position):\n                        q_min = q_near_candidate\n                        c_min_vertex = cost_candidate\n            q_new.cost = c_min_vertex\n            graph.add_edge(q_min, q_new)\n            self._rewire(graph, q_new, Q_near)\n\n            # Try to connect the other tree's nearest vertex to q_new\n            q_near_other = self._get_nearest_vertex(other_graph, q_new.position)\n\n            connection = self._connect_trees(q_new, q_near_other)\n            if connection is not None:\n                (start_v, goal_v, total_cost) = connection\n                if total_cost < self._best_cost:\n                    self._best_cost = total_cost\n                    if growing_start_tree:\n                        self._best_start_vertex = start_v\n                        self._best_goal_vertex = goal_v\n                    else:\n                        self._best_start_vertex = goal_v\n                        self._best_goal_vertex = start_v\n                    self._found_path = True\n\n            self.key_frame()\n\n        if self._found_path and self._best_start_vertex and self._best_goal_vertex:\n            path_vertices = self._extract_bidirectional_path(self._best_start_vertex, self._best_goal_vertex)\n            smoothed_path = self._smooth_path(path_vertices)\n            for vertex in smoothed_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # fail silently\n            pass",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 233, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 210, in __run_simulation\n    sim: Simulator = Simulator(Services(config))\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 40, in __init__\n    self.__setup(config)\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 68, in __setup\n    self.__algorithm_runner.reset_algorithm()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\algorithm_runner.py\", line 59, in reset_algorithm\n    self.__algorithm = self.__algorithm_type(self._services, testing, *self.__algorithm_parameters[0],\n  File \"<string>\", line 59, in __init__\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\sample_based_algorithm.py\", line 11, in _init_displays\n    self.__map_displays = [GraphMapDisplay(self._services, self._graph)]\nAttributeError: 'PathPlanning' object has no attribute '_graph'\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an improved sampling-based planner integrating RRT*-style rewiring, \n    adaptive informed sampling, bidirectional search, and path smoothing. \n    \n    Key improvements:\n    1. Bidirectional tree growth from start and goal, reducing convergence time and improving success rate.\n    2. Adaptive informed sampling ellipsoids from both directions after initial connection, focusing search.\n    3. RRT* rewiring in both trees for path quality improvement.\n    4. Lazy collision checking with early abandon for efficiency.\n    5. Dynamic radius for rewiring based on vertex count and dimensionality.\n    6. After connection, smooth shortcutting path to improve path smoothness and length.\n    7. Strict 10 seconds timeout to fail gracefully.\n\n    The algorithm grows two forests (from start and goal), tries to connect them efficiently, extracts best path, smooths it,\n    and moves the agent along the final planned trajectory.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._graph = self._graph_start  # Fix: define _graph to avoid AttributeError in _init_displays\n        self._max_dist = 12.0\n        self._max_radius = 40.0\n        self._lambda_rrt_star = 40.0\n        self._dimension = self._get_grid().size.n_dim\n        self._start_time = 0\n        self._samples_taken = 0\n        self._found_path = False\n        self._best_start_vertex: Vertex = None\n        self._best_goal_vertex: Vertex = None\n        self._best_cost = float('inf')\n        self._init_displays()\n\n    def _get_random_sample(self, informed_ball_start: tuple = None, informed_ball_goal: tuple = None) -> Point:\n        \"\"\"\n        Samples a point either uniformly or inside combined ellipsoids from start and goal informed sampling.\n        If informed balls for both trees are provided, probabilistically sample from one or uniform.\n        Otherwise uniform sampling.\n        \"\"\"\n        grid_size = self._get_grid().size\n        # Simple logic: 40% from start ellipsoid, 40% from goal ellipsoid, 20% uniform if informed balls exist\n        import random\n        prob = random.random()\n\n        def sample_ellipsoid(center: Point, c_best: float, c_min: float) -> Point:\n            if grid_size.n_dim != 2:\n                # fallback to uniform\n                return None\n            a1 = c_best / 2\n            try:\n                a2 = (c_best**2 - c_min**2)**0.5 / 2\n            except Exception:\n                return None\n            for _ in range(200):\n                rx = torch.FloatTensor(1).uniform_(-1,1).item()\n                ry = torch.FloatTensor(1).uniform_(-1,1).item()\n                norm = (rx**2 + ry**2)**0.5\n                if norm > 1e-5:\n                    break\n            else:\n                return None\n            rx /= norm\n            ry /= norm\n            r = torch.FloatTensor(1).uniform_(0,1).item() ** (1 / 2)\n            x = r * a1 * rx\n            y = r * a2 * ry\n            # Rotation: along vector start -> goal\n            start = self._graph_start.root_vertex_start.position\n            goal = self._graph_start.root_vertex_goal.position\n            delta = torch.tensor([goal.x - start.x, goal.y - start.y])\n            angle = torch.atan2(delta[1], delta[0]).item()\n            cos_ang = torch.cos(torch.tensor(angle))\n            sin_ang = torch.sin(torch.tensor(angle))\n            rot_x = cos_ang * x - sin_ang * y\n            rot_y = sin_ang * x + cos_ang * y\n            sample_x = int(round(center.x + rot_x))\n            sample_y = int(round(center.y + rot_y))\n            sample_x = max(0, min(sample_x, grid_size[0] - 1))\n            sample_y = max(0, min(sample_y, grid_size[1] - 1))\n            sample = Point(sample_x, sample_y)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            return None\n\n        if informed_ball_start and informed_ball_goal:\n            if prob < 0.4:\n                s = sample_ellipsoid(*informed_ball_start)\n                if s is not None:\n                    return s\n            elif prob < 0.8:\n                s = sample_ellipsoid(*informed_ball_goal)\n                if s is not None:\n                    return s\n            # fallback uniform\n        elif informed_ball_start:\n            s = sample_ellipsoid(*informed_ball_start)\n            if s is not None:\n                return s\n        elif informed_ball_goal:\n            s = sample_ellipsoid(*informed_ball_goal)\n            if s is not None:\n                return s\n\n        # uniform sampling fallback\n        attempts = 0\n        while attempts < 500:\n            rand_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(grid_size.n_dim)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n        # As a last resort fallback to agent's position to prevent error\n        return self._get_grid().agent.position\n\n    def _get_nearest_vertex(self, graph: Forest, q_sample: Point) -> Vertex:\n        return graph.get_nearest_vertex(graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, graph: Forest, position: Point, radius: float) -> list:\n        return graph.get_vertices_within_radius(graph.root_vertices, position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec)\n        if length < 1e-6:\n            return None\n        if length <= self._max_dist:\n            new_vertex_pos = q_sample\n        else:\n            dir_normalized = dir_vec / length\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_vertex_pos = Point.from_tensor(new_pos_tensor)\n        if not self._get_grid().is_agent_valid_pos(new_vertex_pos):\n            return None\n        return Vertex(new_vertex_pos)\n\n    def _line_collision_free_lazy(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        for pt in line_seq:\n            if not self._get_grid().is_agent_valid_pos(pt):\n                return False\n        return True\n\n    def _rewire(self, graph: Forest, q_new: Vertex, Q_near: list) -> None:\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n            if dist > self._max_dist:\n                continue\n            new_cost = q_new.cost + dist\n            if new_cost < q_near.cost:\n                if self._line_collision_free_lazy(q_new.position, q_near.position):\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    graph.add_edge(q_new, q_near)\n\n    def _connect_trees(self, v_start: Vertex, v_goal: Vertex) -> (Vertex, Vertex, float):\n        \"\"\"\n        Attempts to connect two vertices from start and goal trees directly if collision-free.\n        Returns tuple (start_vertex, goal_vertex, cost) if successful; else None.\n        \"\"\"\n        if not self._line_collision_free_lazy(v_start.position, v_goal.position):\n            return None\n        dist = torch.norm(v_start.position.to_tensor() - v_goal.position.to_tensor()).item()\n        total_cost = v_start.cost + dist + v_goal.cost\n        return (v_start, v_goal, total_cost)\n\n    def _extract_bidirectional_path(self, start_vertex: Vertex, goal_vertex: Vertex) -> list:\n        \"\"\"\n        Extract path from start vertex in start tree and from goal vertex in goal tree,\n        concatenating paths at meeting point.\n        \"\"\"\n        path_start = []\n        cur = start_vertex\n        while cur is not None:\n            path_start.append(cur)\n            if not cur.parents:\n                break\n            # Choose parent with minimal cost (should usually be one)\n            min_cost = float('inf')\n            min_p = None\n            for p in cur.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_p = p\n            cur = min_p\n        path_start.reverse()\n\n        path_goal = []\n        cur = goal_vertex\n        while cur is not None:\n            path_goal.append(cur)\n            if not cur.parents:\n                break\n            min_cost = float('inf')\n            min_p = None\n            for p in cur.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_p = p\n            cur = min_p\n\n        # Reverse path_goal for correct direction\n        path_goal.reverse()\n        # Remove duplicate meeting vertex at join\n        if len(path_goal) > 0 and len(path_start) > 0 and path_start[-1].position == path_goal[0].position:\n            path_goal = path_goal[1:]\n\n        return path_start + path_goal\n\n    def _smooth_path(self, path: list) -> list:\n        \"\"\"\n        Shortcut smoothing removing unnecessary vertices by connecting farther apart vertices directly.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_collision_free_lazy(path[i].position, path[j].position):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.perf_counter()\n        max_time_sec = 10.0\n        max_iterations = 15000\n\n        start_tree = self._graph_start\n        goal_tree = self._graph_goal\n\n        start_root = start_tree.root_vertex_start\n        goal_root = goal_tree.root_vertex_start\n\n        start_root.cost = 0.0\n        goal_root.cost = 0.0\n\n        self._found_path = False\n        self._best_cost = float('inf')\n        self._best_start_vertex = None\n        self._best_goal_vertex = None\n\n        for iteration in range(max_iterations):\n            if time.perf_counter() - self._start_time > max_time_sec:\n                # timeout -> fail gracefully\n                break\n\n            # Setup informed sampling ellipsoids if path found\n            informed_start = None\n            informed_goal = None\n            if self._found_path and self._best_cost < float('inf'):\n                c_min = torch.norm(start_root.position.to_tensor() - goal_root.position.to_tensor()).item()\n                c_best = self._best_cost\n                center_start = Point((start_root.position.x + goal_root.position.x) / 2,\n                                     (start_root.position.y + goal_root.position.y) / 2)\n                informed_start = (center_start, c_best, c_min)\n                informed_goal = (center_start, c_best, c_min)\n\n            # Alternate tree growth: odd iteration grow start tree, even grow goal tree\n            growing_start_tree = (iteration % 2 == 0)\n            graph = start_tree if growing_start_tree else goal_tree\n            other_graph = goal_tree if growing_start_tree else start_tree\n            root_vertex = graph.root_vertex_start\n\n            q_sample = self._get_random_sample(informed_ball_start=informed_start, informed_ball_goal=informed_goal)\n            q_near = self._get_nearest_vertex(graph, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            if not q_new:\n                continue\n\n            if not self._line_collision_free_lazy(q_near.position, q_new.position):\n                continue\n\n            dist = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = q_near.cost + dist\n\n            card_V = max(1, graph.size)\n            log_card_V = torch.log(torch.tensor(float(card_V) + 1e-8))\n            radius = min(self._lambda_rrt_star * ((log_card_V / card_V) ** (1.0 / self._dimension)), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(graph, q_new.position, radius)\n\n            # Choose parent with minimum cost + collision free\n            q_min = q_near\n            c_min_vertex = q_near.cost\n            for q_near_candidate in Q_near:\n                if q_near_candidate == q_new:\n                    continue\n                dist_candidate = torch.norm(q_near_candidate.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist_candidate > self._max_dist:\n                    continue\n                cost_candidate = q_near_candidate.cost + dist_candidate\n                if cost_candidate < c_min_vertex:\n                    if self._line_collision_free_lazy(q_near_candidate.position, q_new.position):\n                        q_min = q_near_candidate\n                        c_min_vertex = cost_candidate\n            q_new.cost = c_min_vertex\n            graph.add_edge(q_min, q_new)\n            self._rewire(graph, q_new, Q_near)\n\n            # Try to connect the other tree's nearest vertex to q_new\n            q_near_other = self._get_nearest_vertex(other_graph, q_new.position)\n\n            connection = self._connect_trees(q_new, q_near_other)\n            if connection is not None:\n                (start_v, goal_v, total_cost) = connection\n                if total_cost < self._best_cost:\n                    self._best_cost = total_cost\n                    if growing_start_tree:\n                        self._best_start_vertex = start_v\n                        self._best_goal_vertex = goal_v\n                    else:\n                        self._best_start_vertex = goal_v\n                        self._best_goal_vertex = start_v\n                    self._found_path = True\n\n            self.key_frame()\n\n        if self._found_path and self._best_start_vertex and self._best_goal_vertex:\n            path_vertices = self._extract_bidirectional_path(self._best_start_vertex, self._best_goal_vertex)\n            smoothed_path = self._smooth_path(path_vertices)\n            for vertex in smoothed_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # fail silently\n            pass",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 233, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 214, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 303, in _find_path_internal\n  File \"<string>\", line 118, in _get_random_sample\n  File \"<string>\", line 103, in sample_ellipsoid\nTypeError: type Tensor doesn't define __round__ method\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an improved sampling-based planner integrating RRT*-style rewiring, \n    adaptive informed sampling, bidirectional search, and path smoothing. \n    \n    Key improvements:\n    1. Bidirectional tree growth from start and goal, reducing convergence time and improving success rate.\n    2. Adaptive informed sampling ellipsoids from both directions after initial connection, focusing search.\n    3. RRT* rewiring in both trees for path quality improvement.\n    4. Lazy collision checking with early abandon for efficiency.\n    5. Dynamic radius for rewiring based on vertex count and dimensionality.\n    6. After connection, smooth shortcutting path to improve path smoothness and length.\n    7. Strict 10 seconds timeout to fail gracefully.\n\n    The algorithm grows two forests (from start and goal), tries to connect them efficiently, extracts best path, smooths it,\n    and moves the agent along the final planned trajectory.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._graph = self._graph_start  # Fix: define _graph to avoid AttributeError in _init_displays\n        self._max_dist = 12.0\n        self._max_radius = 40.0\n        self._lambda_rrt_star = 40.0\n        self._dimension = self._get_grid().size.n_dim\n        self._start_time = 0\n        self._samples_taken = 0\n        self._found_path = False\n        self._best_start_vertex: Vertex = None\n        self._best_goal_vertex: Vertex = None\n        self._best_cost = float('inf')\n        self._init_displays()\n\n    def _get_random_sample(self, informed_ball_start: tuple = None, informed_ball_goal: tuple = None) -> Point:\n        \"\"\"\n        Samples a point either uniformly or inside combined ellipsoids from start and goal informed sampling.\n        If informed balls for both trees are provided, probabilistically sample from one or uniform.\n        Otherwise uniform sampling.\n        \"\"\"\n        grid_size = self._get_grid().size\n        # Simple logic: 40% from start ellipsoid, 40% from goal ellipsoid, 20% uniform if informed balls exist\n        import random\n        prob = random.random()\n\n        def sample_ellipsoid(center: Point, c_best: float, c_min: float) -> Point:\n            if grid_size.n_dim != 2:\n                # fallback to uniform\n                return None\n            a1 = c_best / 2\n            try:\n                a2 = (c_best**2 - c_min**2)**0.5 / 2\n            except Exception:\n                return None\n            for _ in range(200):\n                rx = torch.FloatTensor(1).uniform_(-1,1).item()\n                ry = torch.FloatTensor(1).uniform_(-1,1).item()\n                norm = (rx**2 + ry**2)**0.5\n                if norm > 1e-5:\n                    break\n            else:\n                return None\n            rx /= norm\n            ry /= norm\n            r = torch.FloatTensor(1).uniform_(0,1).item() ** (1 / 2)\n            x = r * a1 * rx\n            y = r * a2 * ry\n            # Rotation: along vector start -> goal\n            start = self._graph_start.root_vertex_start.position\n            goal = self._graph_start.root_vertex_goal.position\n            delta = torch.tensor([goal.x - start.x, goal.y - start.y])\n            angle = torch.atan2(delta[1], delta[0]).item()\n            cos_ang = torch.cos(torch.tensor(angle))\n            sin_ang = torch.sin(torch.tensor(angle))\n            rot_x = cos_ang * x - sin_ang * y\n            rot_y = sin_ang * x + cos_ang * y\n            sample_x = int(round(float(center.x) + rot_x))\n            sample_y = int(round(float(center.y) + rot_y))\n            sample_x = max(0, min(sample_x, grid_size[0] - 1))\n            sample_y = max(0, min(sample_y, grid_size[1] - 1))\n            sample = Point(sample_x, sample_y)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            return None\n\n        if informed_ball_start and informed_ball_goal:\n            if prob < 0.4:\n                s = sample_ellipsoid(*informed_ball_start)\n                if s is not None:\n                    return s\n            elif prob < 0.8:\n                s = sample_ellipsoid(*informed_ball_goal)\n                if s is not None:\n                    return s\n            # fallback uniform\n        elif informed_ball_start:\n            s = sample_ellipsoid(*informed_ball_start)\n            if s is not None:\n                return s\n        elif informed_ball_goal:\n            s = sample_ellipsoid(*informed_ball_goal)\n            if s is not None:\n                return s\n\n        # uniform sampling fallback\n        attempts = 0\n        while attempts < 500:\n            rand_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(grid_size.n_dim)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n        # As a last resort fallback to agent's position to prevent error\n        return self._get_grid().agent.position\n\n    def _get_nearest_vertex(self, graph: Forest, q_sample: Point) -> Vertex:\n        return graph.get_nearest_vertex(graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, graph: Forest, position: Point, radius: float) -> list:\n        return graph.get_vertices_within_radius(graph.root_vertices, position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec)\n        if length < 1e-6:\n            return None\n        if length <= self._max_dist:\n            new_vertex_pos = q_sample\n        else:\n            dir_normalized = dir_vec / length\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_vertex_pos = Point.from_tensor(new_pos_tensor)\n        if not self._get_grid().is_agent_valid_pos(new_vertex_pos):\n            return None\n        return Vertex(new_vertex_pos)\n\n    def _line_collision_free_lazy(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        for pt in line_seq:\n            if not self._get_grid().is_agent_valid_pos(pt):\n                return False\n        return True\n\n    def _rewire(self, graph: Forest, q_new: Vertex, Q_near: list) -> None:\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n            if dist > self._max_dist:\n                continue\n            new_cost = q_new.cost + dist\n            if new_cost < q_near.cost:\n                if self._line_collision_free_lazy(q_new.position, q_near.position):\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    graph.add_edge(q_new, q_near)\n\n    def _connect_trees(self, v_start: Vertex, v_goal: Vertex) -> (Vertex, Vertex, float):\n        \"\"\"\n        Attempts to connect two vertices from start and goal trees directly if collision-free.\n        Returns tuple (start_vertex, goal_vertex, cost) if successful; else None.\n        \"\"\"\n        if not self._line_collision_free_lazy(v_start.position, v_goal.position):\n            return None\n        dist = torch.norm(v_start.position.to_tensor() - v_goal.position.to_tensor()).item()\n        total_cost = v_start.cost + dist + v_goal.cost\n        return (v_start, v_goal, total_cost)\n\n    def _extract_bidirectional_path(self, start_vertex: Vertex, goal_vertex: Vertex) -> list:\n        \"\"\"\n        Extract path from start vertex in start tree and from goal vertex in goal tree,\n        concatenating paths at meeting point.\n        \"\"\"\n        path_start = []\n        cur = start_vertex\n        while cur is not None:\n            path_start.append(cur)\n            if not cur.parents:\n                break\n            # Choose parent with minimal cost (should usually be one)\n            min_cost = float('inf')\n            min_p = None\n            for p in cur.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_p = p\n            cur = min_p\n        path_start.reverse()\n\n        path_goal = []\n        cur = goal_vertex\n        while cur is not None:\n            path_goal.append(cur)\n            if not cur.parents:\n                break\n            min_cost = float('inf')\n            min_p = None\n            for p in cur.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_p = p\n            cur = min_p\n\n        # Reverse path_goal for correct direction\n        path_goal.reverse()\n        # Remove duplicate meeting vertex at join\n        if len(path_goal) > 0 and len(path_start) > 0 and path_start[-1].position == path_goal[0].position:\n            path_goal = path_goal[1:]\n\n        return path_start + path_goal\n\n    def _smooth_path(self, path: list) -> list:\n        \"\"\"\n        Shortcut smoothing removing unnecessary vertices by connecting farther apart vertices directly.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_collision_free_lazy(path[i].position, path[j].position):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.perf_counter()\n        max_time_sec = 10.0\n        max_iterations = 15000\n\n        start_tree = self._graph_start\n        goal_tree = self._graph_goal\n\n        start_root = start_tree.root_vertex_start\n        goal_root = goal_tree.root_vertex_start\n\n        start_root.cost = 0.0\n        goal_root.cost = 0.0\n\n        self._found_path = False\n        self._best_cost = float('inf')\n        self._best_start_vertex = None\n        self._best_goal_vertex = None\n\n        for iteration in range(max_iterations):\n            if time.perf_counter() - self._start_time > max_time_sec:\n                # timeout -> fail gracefully\n                break\n\n            # Setup informed sampling ellipsoids if path found\n            informed_start = None\n            informed_goal = None\n            if self._found_path and self._best_cost < float('inf'):\n                c_min = torch.norm(start_root.position.to_tensor() - goal_root.position.to_tensor()).item()\n                c_best = self._best_cost\n                center_start = Point((start_root.position.x + goal_root.position.x) / 2,\n                                     (start_root.position.y + goal_root.position.y) / 2)\n                informed_start = (center_start, c_best, c_min)\n                informed_goal = (center_start, c_best, c_min)\n\n            # Alternate tree growth: odd iteration grow start tree, even grow goal tree\n            growing_start_tree = (iteration % 2 == 0)\n            graph = start_tree if growing_start_tree else goal_tree\n            other_graph = goal_tree if growing_start_tree else start_tree\n            root_vertex = graph.root_vertex_start\n\n            q_sample = self._get_random_sample(informed_ball_start=informed_start, informed_ball_goal=informed_goal)\n            q_near = self._get_nearest_vertex(graph, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            if not q_new:\n                continue\n\n            if not self._line_collision_free_lazy(q_near.position, q_new.position):\n                continue\n\n            dist = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = q_near.cost + dist\n\n            card_V = max(1, graph.size)\n            log_card_V = torch.log(torch.tensor(float(card_V) + 1e-8))\n            radius = min(self._lambda_rrt_star * ((log_card_V / card_V) ** (1.0 / self._dimension)), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(graph, q_new.position, radius)\n\n            # Choose parent with minimum cost + collision free\n            q_min = q_near\n            c_min_vertex = q_near.cost\n            for q_near_candidate in Q_near:\n                if q_near_candidate == q_new:\n                    continue\n                dist_candidate = torch.norm(q_near_candidate.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist_candidate > self._max_dist:\n                    continue\n                cost_candidate = q_near_candidate.cost + dist_candidate\n                if cost_candidate < c_min_vertex:\n                    if self._line_collision_free_lazy(q_near_candidate.position, q_new.position):\n                        q_min = q_near_candidate\n                        c_min_vertex = cost_candidate\n            q_new.cost = c_min_vertex\n            graph.add_edge(q_min, q_new)\n            self._rewire(graph, q_new, Q_near)\n\n            # Try to connect the other tree's nearest vertex to q_new\n            q_near_other = self._get_nearest_vertex(other_graph, q_new.position)\n\n            connection = self._connect_trees(q_new, q_near_other)\n            if connection is not None:\n                (start_v, goal_v, total_cost) = connection\n                if total_cost < self._best_cost:\n                    self._best_cost = total_cost\n                    if growing_start_tree:\n                        self._best_start_vertex = start_v\n                        self._best_goal_vertex = goal_v\n                    else:\n                        self._best_start_vertex = goal_v\n                        self._best_goal_vertex = start_v\n                    self._found_path = True\n\n            self.key_frame()\n\n        if self._found_path and self._best_start_vertex and self._best_goal_vertex:\n            path_vertices = self._extract_bidirectional_path(self._best_start_vertex, self._best_goal_vertex)\n            smoothed_path = self._smooth_path(path_vertices)\n            for vertex in smoothed_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # fail silently\n            pass",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 233, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 214, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 303, in _find_path_internal\n  File \"<string>\", line 114, in _get_random_sample\n  File \"<string>\", line 103, in sample_ellipsoid\nTypeError: type Tensor doesn't define __round__ method\n"
     }
}
{
     "operator": "e1",
     "algorithm": "Improved Path Planning Algorithm based on an enhanced RRT* concept with informed sampling and rewiring:\n    - Uses goal-biased sampling to focus exploration towards goal, improving planning efficiency.\n    - Applies rewiring to locally optimize path connections, improving path quality and smoothness.\n    - Uses adaptive neighborhood radius for rewiring to balance exploration vs. exploitation.\n    - Employs early termination if path to goal found, minimizing search time.\n    - Integrates timeout check ensuring search fails if exceeding 10 seconds for robustness.\n    - Uses precise collision checking via line validation for robustness.\n    - Maintains a forest graph structure for flexible path representations and fast nearest neighbor queries.\n    - Overall, this approach improves success rate, reduces path length, and smooths the resulting trajectory.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = Forest(\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n        )\n        self._graph.edges_removable = True\n        self._max_extend_dist = 12.0\n        self._rewire_radius_factor = 30.0  # factor to scale radius adaptively\n        self._goal_sample_rate = 0.2  # probability to sample goal directly\n        self._timeout_seconds = 10.0\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling with probability self._goal_sample_rate\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        dim = self._get_grid().size.n_dim\n        while True:\n            rand_coords = np.random.randint(0, self._get_grid().size, dim)\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_v: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        dir_vec = to_point.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            new_pos = to_point\n        else:\n            dir_norm = dir_vec / dist\n            new_pos_tensor = from_v.position.to_tensor() + max_dist * dir_norm\n            new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _collision_free(self, from_point: Point, to_point: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(from_point, to_point)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _near_vertices(self, new_vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], new_vertex.position, radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], new_vertex: Vertex) -> Optional[Vertex]:\n        min_cost = float('inf')\n        best_parent = None\n        for near_v in near_vertices:\n            if self._collision_free(near_v.position, new_vertex.position):\n                cost = near_v.cost + self._get_grid().get_movement_cost(near_v.position, new_vertex.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = near_v\n        if best_parent is not None:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> None:\n        for near_v in near_vertices:\n            if near_v == new_vertex:\n                continue\n            if self._collision_free(new_vertex.position, near_v.position):\n                new_cost = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, near_v.position)\n                if new_cost < near_v.cost:\n                    # Remove old edge(s) leading to near_v and add new edge from new_vertex\n                    for p in list(near_v.parents):\n                        self._graph.remove_edge(p, near_v)\n                    self._graph.add_edge(new_vertex, near_v)\n                    near_v.cost = new_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        # Extract path backward from goal to start via parents\n        path: List[Vertex] = [goal_vertex]\n        current = goal_vertex\n        while current.position != self._graph.root_vertex_start.position:\n            if not current.parents:\n                # No path to start\n                break\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Animate path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n\n        start_time = time()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        max_iter = 20000\n        found_goal = False\n\n        for iter_count in range(max_iter):\n            if time() - start_time > self._timeout_seconds:\n                # Treat as failed search due to timeout\n                break\n\n            q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._steer(q_near, q_sample, self._max_extend_dist)\n\n            if not self._collision_free(q_near.position, q_new.position):\n                continue\n\n            # Adaptive radius for rewiring (RRT* style): gamma * (log(n)/n)^(1/d)\n            n_vertices = self._graph.size + 1\n            dim = self._get_grid().size.n_dim\n            gamma = self._rewire_radius_factor\n            radius = gamma * (np.log(n_vertices) / n_vertices) ** (1.0 / dim)\n            radius = max(radius, self._max_extend_dist)\n\n            near_vertices = self._near_vertices(q_new, radius)\n            parent = self._choose_parent(near_vertices, q_new)\n            if parent is None:\n                parent = q_near\n                q_new.cost = parent.cost + self._get_grid().get_movement_cost(parent.position, q_new.position)\n\n            self._graph.add_edge(parent, q_new)\n\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex explicitly and extract path\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                goal_vertex.cost = float('inf')\n                if self._collision_free(q_new.position, goal_vertex.position):\n                    cost_to_goal = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    found_goal = True\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()\n\n        if not found_goal:\n            # No path found within constraints and timeout\n            pass  # Could raise or log failure if needed",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 233, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 210, in __run_simulation\n    sim: Simulator = Simulator(Services(config))\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 40, in __init__\n    self.__setup(config)\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 68, in __setup\n    self.__algorithm_runner.reset_algorithm()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\algorithm_runner.py\", line 59, in reset_algorithm\n    self.__algorithm = self.__algorithm_type(self._services, testing, *self.__algorithm_parameters[0],\n  File \"<string>\", line 46, in __init__\nTypeError: __init__() missing 1 required positional argument: 'root_vertices'\n"
     }
}
{
     "operator": "e1",
     "algorithm": "Improved Path Planning Algorithm based on an enhanced RRT* concept with informed sampling and rewiring:\n    - Uses goal-biased sampling to focus exploration towards goal, improving planning efficiency.\n    - Applies rewiring to locally optimize path connections, improving path quality and smoothness.\n    - Uses adaptive neighborhood radius for rewiring to balance exploration vs. exploitation.\n    - Employs early termination if path to goal found, minimizing search time.\n    - Integrates timeout check ensuring search fails if exceeding 10 seconds for robustness.\n    - Uses precise collision checking via line validation for robustness.\n    - Maintains a forest graph structure for flexible path representations and fast nearest neighbor queries.\n    - Overall, this approach improves success rate, reduces path length, and smooths the resulting trajectory.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = Forest(\n            root_vertices=[\n                Vertex(self._get_grid().agent.position),\n                Vertex(self._get_grid().goal.position),\n            ]\n        )\n        self._graph.edges_removable = True\n        self._max_extend_dist = 12.0\n        self._rewire_radius_factor = 30.0  # factor to scale radius adaptively\n        self._goal_sample_rate = 0.2  # probability to sample goal directly\n        self._timeout_seconds = 10.0\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling with probability self._goal_sample_rate\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        dim = self._get_grid().size.n_dim\n        while True:\n            rand_coords = np.random.randint(0, self._get_grid().size, dim)\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_v: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        dir_vec = to_point.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            new_pos = to_point\n        else:\n            dir_norm = dir_vec / dist\n            new_pos_tensor = from_v.position.to_tensor() + max_dist * dir_norm\n            new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _collision_free(self, from_point: Point, to_point: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(from_point, to_point)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _near_vertices(self, new_vertex: Vertex, radius: float) -> list[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertices[0]], new_vertex.position, radius)\n\n    def _choose_parent(self, near_vertices: list[Vertex], new_vertex: Vertex) -> Vertex | None:\n        min_cost = float(\"inf\")\n        best_parent = None\n        for near_v in near_vertices:\n            if self._collision_free(near_v.position, new_vertex.position):\n                cost = near_v.cost + self._get_grid().get_movement_cost(near_v.position, new_vertex.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = near_v\n        if best_parent is not None:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: list[Vertex]) -> None:\n        for near_v in near_vertices:\n            if near_v == new_vertex:\n                continue\n            if self._collision_free(new_vertex.position, near_v.position):\n                new_cost = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, near_v.position)\n                if new_cost < near_v.cost:\n                    # Remove old edge(s) leading to near_v and add new edge from new_vertex\n                    for p in list(near_v.parents):\n                        self._graph.remove_edge(p, near_v)\n                    self._graph.add_edge(new_vertex, near_v)\n                    near_v.cost = new_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        # Extract path backward from goal to start via parents\n        path: list[Vertex] = [goal_vertex]\n        current = goal_vertex\n        while current.position != self._graph.root_vertices[0].position:\n            if not current.parents:\n                # No path to start\n                break\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Animate path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n\n        start_time = time()\n        start_vertex = self._graph.root_vertices[0]\n        start_vertex.cost = 0.0\n\n        max_iter = 20000\n        found_goal = False\n\n        for iter_count in range(max_iter):\n            if time() - start_time > self._timeout_seconds:\n                # Treat as failed search due to timeout\n                break\n\n            q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._steer(q_near, q_sample, self._max_extend_dist)\n\n            if not self._collision_free(q_near.position, q_new.position):\n                continue\n\n            # Adaptive radius for rewiring (RRT* style): gamma * (log(n)/n)^(1/d)\n            n_vertices = self._graph.size + 1\n            dim = self._get_grid().size.n_dim\n            gamma = self._rewire_radius_factor\n            radius = gamma * (np.log(n_vertices) / n_vertices) ** (1.0 / dim)\n            radius = max(radius, self._max_extend_dist)\n\n            near_vertices = self._near_vertices(q_new, radius)\n            parent = self._choose_parent(near_vertices, q_new)\n            if parent is None:\n                parent = q_near\n                q_new.cost = parent.cost + self._get_grid().get_movement_cost(parent.position, q_new.position)\n\n            self._graph.add_edge(parent, q_new)\n\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex explicitly and extract path\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                goal_vertex.cost = float(\"inf\")\n                if self._collision_free(q_new.position, goal_vertex.position):\n                    cost_to_goal = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    found_goal = True\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()\n\n        if not found_goal:\n            # No path found within constraints and timeout\n            pass  # Could raise or log failure if needed",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 269, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 84, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "e1",
     "algorithm": "Improved Path Planning Algorithm based on an enhanced RRT* concept with informed sampling and rewiring:\n    - Uses goal-biased sampling to focus exploration towards goal, improving planning efficiency.\n    - Applies rewiring to locally optimize path connections, improving path quality and smoothness.\n    - Uses adaptive neighborhood radius for rewiring to balance exploration vs. exploitation.\n    - Employs early termination if path to goal found, minimizing search time.\n    - Integrates timeout check ensuring search fails if exceeding 10 seconds for robustness.\n    - Uses precise collision checking via line validation for robustness.\n    - Maintains a forest graph structure for flexible path representations and fast nearest neighbor queries.\n    - Overall, this approach improves success rate, reduces path length, and smooths the resulting trajectory.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = Forest(\n            root_vertices=[\n                Vertex(self._get_grid().agent.position),\n                Vertex(self._get_grid().goal.position),\n            ]\n        )\n        self._graph.edges_removable = True\n        self._max_extend_dist = 12.0\n        self._rewire_radius_factor = 30.0  # factor to scale radius adaptively\n        self._goal_sample_rate = 0.2  # probability to sample goal directly\n        self._timeout_seconds = 10.0\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling with probability self._goal_sample_rate\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        dim = self._get_grid().size.n_dim\n        while True:\n            rand_coords = np.random.randint(0, self._get_grid().size, dim)\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_v: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        dir_vec = to_point.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            new_pos = to_point\n        else:\n            dir_norm = dir_vec / dist\n            new_pos_tensor = from_v.position.to_tensor() + max_dist * dir_norm\n            new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _collision_free(self, from_point: Point, to_point: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(from_point, to_point)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _near_vertices(self, new_vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertices[0]], new_vertex.position, radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], new_vertex: Vertex) -> Optional[Vertex]:\n        min_cost = float(\"inf\")\n        best_parent = None\n        for near_v in near_vertices:\n            if self._collision_free(near_v.position, new_vertex.position):\n                cost = near_v.cost + self._get_grid().get_movement_cost(near_v.position, new_vertex.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = near_v\n        if best_parent is not None:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> None:\n        for near_v in near_vertices:\n            if near_v == new_vertex:\n                continue\n            if self._collision_free(new_vertex.position, near_v.position):\n                new_cost = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, near_v.position)\n                if new_cost < near_v.cost:\n                    # Remove old edge(s) leading to near_v and add new edge from new_vertex\n                    for p in list(near_v.parents):\n                        self._graph.remove_edge(p, near_v)\n                    self._graph.add_edge(new_vertex, near_v)\n                    near_v.cost = new_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        # Extract path backward from goal to start via parents\n        path: List[Vertex] = [goal_vertex]\n        current = goal_vertex\n        while current.position != self._graph.root_vertices[0].position:\n            if not current.parents:\n                # No path to start\n                break\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Animate path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n\n        start_time = time()\n        start_vertex = self._graph.root_vertices[0]\n        start_vertex.cost = 0.0\n\n        max_iter = 20000\n        found_goal = False\n\n        for iter_count in range(max_iter):\n            if time() - start_time > self._timeout_seconds:\n                # Treat as failed search due to timeout\n                break\n\n            q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._steer(q_near, q_sample, self._max_extend_dist)\n\n            if not self._collision_free(q_near.position, q_new.position):\n                continue\n\n            # Adaptive radius for rewiring (RRT* style): gamma * (log(n)/n)^(1/d)\n            n_vertices = self._graph.size + 1\n            dim = self._get_grid().size.n_dim\n            gamma = self._rewire_radius_factor\n            radius = gamma * (np.log(n_vertices) / n_vertices) ** (1.0 / dim)\n            radius = max(radius, self._max_extend_dist)\n\n            near_vertices = self._near_vertices(q_new, radius)\n            parent = self._choose_parent(near_vertices, q_new)\n            if parent is None:\n                parent = q_near\n                q_new.cost = parent.cost + self._get_grid().get_movement_cost(parent.position, q_new.position)\n\n            self._graph.add_edge(parent, q_new)\n\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex explicitly and extract path\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                goal_vertex.cost = float(\"inf\")\n                if self._collision_free(q_new.position, goal_vertex.position):\n                    cost_to_goal = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    found_goal = True\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()\n\n        if not found_goal:\n            # No path found within constraints and timeout\n            pass  # Could raise or log failure if needed",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 233, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 210, in __run_simulation\n    sim: Simulator = Simulator(Services(config))\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 40, in __init__\n    self.__setup(config)\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 68, in __setup\n    self.__algorithm_runner.reset_algorithm()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\algorithm_runner.py\", line 59, in reset_algorithm\n    self.__algorithm = self.__algorithm_type(self._services, testing, *self.__algorithm_parameters[0],\n  File \"<string>\", line 45, in __init__\nTypeError: __init__() missing 2 required positional arguments: 'start_pos' and 'goal_pos'\n"
     }
}
{
     "operator": "e1",
     "algorithm": "Improved Path Planning Algorithm based on an enhanced RRT* concept with informed sampling and rewiring:\n    - Uses goal-biased sampling to focus exploration towards goal, improving planning efficiency.\n    - Applies rewiring to locally optimize path connections, improving path quality and smoothness.\n    - Uses adaptive neighborhood radius for rewiring to balance exploration vs. exploitation.\n    - Employs early termination if path to goal found, minimizing search time.\n    - Integrates timeout check ensuring search fails if exceeding 10 seconds for robustness.\n    - Uses precise collision checking via line validation for robustness.\n    - Maintains a forest graph structure for flexible path representations and fast nearest neighbor queries.\n    - Overall, this approach improves success rate, reduces path length, and smooths the resulting trajectory.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    _graph: Forest\n\n    def __init__(self, services, testing=None, start_pos=None, goal_pos=None):\n        super().__init__(services, testing)\n        # Use provided start_pos and goal_pos if given, else fallback to grid agent/goal positions\n        start_position = start_pos if start_pos is not None else self._get_grid().agent.position\n        goal_position = goal_pos if goal_pos is not None else self._get_grid().goal.position\n\n        self._graph = Forest(\n            root_vertices=[\n                Vertex(start_position),\n                Vertex(goal_position),\n            ]\n        )\n        self._graph.edges_removable = True\n        self._max_extend_dist = 12.0\n        self._rewire_radius_factor = 30.0  # factor to scale radius adaptively\n        self._goal_sample_rate = 0.2  # probability to sample goal directly\n        self._timeout_seconds = 10.0\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling with probability self._goal_sample_rate\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        dim = self._get_grid().size.n_dim\n        while True:\n            rand_coords = np.random.randint(0, self._get_grid().size, dim)\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_v: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        dir_vec = to_point.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            new_pos = to_point\n        else:\n            dir_norm = dir_vec / dist\n            new_pos_tensor = from_v.position.to_tensor() + max_dist * dir_norm\n            new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _collision_free(self, from_point: Point, to_point: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(from_point, to_point)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _near_vertices(self, new_vertex: Vertex, radius: float) -> list[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertices[0]], new_vertex.position, radius)\n\n    def _choose_parent(self, near_vertices: list[Vertex], new_vertex: Vertex) -> Vertex | None:\n        min_cost = float(\"inf\")\n        best_parent = None\n        for near_v in near_vertices:\n            if self._collision_free(near_v.position, new_vertex.position):\n                cost = near_v.cost + self._get_grid().get_movement_cost(near_v.position, new_vertex.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = near_v\n        if best_parent is not None:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: list[Vertex]) -> None:\n        for near_v in near_vertices:\n            if near_v == new_vertex:\n                continue\n            if self._collision_free(new_vertex.position, near_v.position):\n                new_cost = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, near_v.position)\n                if new_cost < near_v.cost:\n                    # Remove old edge(s) leading to near_v and add new edge from new_vertex\n                    for p in list(near_v.parents):\n                        self._graph.remove_edge(p, near_v)\n                    self._graph.add_edge(new_vertex, near_v)\n                    near_v.cost = new_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        # Extract path backward from goal to start via parents\n        path: list[Vertex] = [goal_vertex]\n        current = goal_vertex\n        while current.position != self._graph.root_vertices[0].position:\n            if not current.parents:\n                # No path to start\n                break\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Animate path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n\n        start_time = time()\n        start_vertex = self._graph.root_vertices[0]\n        start_vertex.cost = 0.0\n\n        max_iter = 20000\n        found_goal = False\n\n        for iter_count in range(max_iter):\n            if time() - start_time > self._timeout_seconds:\n                # Treat as failed search due to timeout\n                break\n\n            q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._steer(q_near, q_sample, self._max_extend_dist)\n\n            if not self._collision_free(q_near.position, q_new.position):\n                continue\n\n            # Adaptive radius for rewiring (RRT* style): gamma * (log(n)/n)^(1/d)\n            n_vertices = self._graph.size + 1\n            dim = self._get_grid().size.n_dim\n            gamma = self._rewire_radius_factor\n            radius = gamma * (np.log(n_vertices) / n_vertices) ** (1.0 / dim)\n            radius = max(radius, self._max_extend_dist)\n\n            near_vertices = self._near_vertices(q_new, radius)\n            parent = self._choose_parent(near_vertices, q_new)\n            if parent is None:\n                parent = q_near\n                q_new.cost = parent.cost + self._get_grid().get_movement_cost(parent.position, q_new.position)\n\n            self._graph.add_edge(parent, q_new)\n\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex explicitly and extract path\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                goal_vertex.cost = float(\"inf\")\n                if self._collision_free(q_new.position, goal_vertex.position):\n                    cost_to_goal = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    found_goal = True\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()\n\n        if not found_goal:\n            # No path found within constraints and timeout\n            pass  # Could raise or log failure if needed",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 269, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 88, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "m1",
     "algorithm": "This improved path planning algorithm combines the adaptive radius selection of RRT* with informed sampling \n    and dynamic rewiring to improve planning efficiency, path quality, and robustness. \n    It employs a heuristic-guided sampling biased towards the goal region (informed sampling ellipse), \n    dynamically adjusts the neighborhood radius based on the number of vertices, \n    and enforces collision-free rewiring to shorten paths and improve smoothness.\n    The algorithm terminates successfully when the agent reaches the goal radius or fails if it exceeds 60 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_planning_time = 60  # seconds\n\n        self._init_displays()\n\n    # --- Helper functions --- #\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Uses informed sampling with an ellipse defined by start, goal, and current best path length.\n        Bias sampling towards goal with 5% chance to jump directly.\n        \"\"\"\n        start: Point = self._graph.root_vertex_start.position\n        goal: Point = self._graph.root_vertex_goal.position\n\n        def dist(a: Point, b: Point) -> float:\n            return (a.to_tensor() - b.to_tensor()).norm().item()\n\n        max_dist = dist(start, goal)\n        best_goal_dist = None\n        # Try to estimate current best solution length from graph if possible\n        # fallback to direct start-goal dist if no path found yet\n        goal_vertex = self._graph.root_vertex_goal\n        if goal_vertex.cost is not None:\n            best_goal_dist = goal_vertex.cost\n        else:\n            best_goal_dist = max_dist * 1.5  # heuristic buffer\n\n        # Ellipse parameters for informed sampling\n        c_best = best_goal_dist\n        if c_best == float('inf') or c_best is None:\n            c_best = max_dist * 2.0\n\n        c_min = max_dist\n\n        # If the heuristic fails or no informative ellipse, uniformly sample\n        if c_best < c_min:\n            c_best = c_min * 1.1\n\n        # Sample roughly with 5% probability the goal directly (goal bias)\n        if torch.rand(1).item() < 0.05:\n            candidate = goal\n            if self._get_grid().is_agent_valid_pos(candidate):\n                return candidate\n\n        # Informed sampling ellipse centered between start and goal:\n        center_tensor = (start.to_tensor() + goal.to_tensor()) / 2\n        a1 = (goal.to_tensor() - start.to_tensor())\n        a1_norm = torch.norm(a1)\n        if a1_norm == 0:\n            a1_norm = 1.0\n        e1 = a1 / a1_norm\n        # radii of ellipse\n        r1 = c_best / 2\n        r2 = (r1 ** 2 - (c_min / 2) ** 2) ** 0.5 if r1 > (c_min / 2) else r1 * 0.1\n\n        while True:\n            # sample in unit circle (2D assumed)\n            sample_unit = torch.rand(2) * 2 - 1\n            if sample_unit.norm() <= 1.0:\n                break\n\n        # scale to ellipse\n        sample_ellipse = torch.zeros(2)\n        sample_ellipse[0] = sample_unit[0] * r1\n        sample_ellipse[1] = sample_unit[1] * r2\n\n        # rotation to align ellipse axis to start-goal line\n        # rotation matrix in 2D:\n        angle = torch.atan2(e1[1], e1[0])\n        rot_matrix = torch.tensor([[torch.cos(angle), -torch.sin(angle)],\n                                   [torch.sin(angle), torch.cos(angle)]])\n        sample_rotated = rot_matrix.matmul(sample_ellipse)\n\n        sample_point_tensor = center_tensor[:2] + sample_rotated\n\n        # Clamp sample_point_tensor to map bounds\n        dims = self._get_grid().size.n_dim\n        coords = []\n        for i in range(dims):\n            dim_max = self._get_grid().size[i] - 1\n            val = float(sample_point_tensor[i]) if i < 2 else torch.randint(0, dim_max + 1, (1,)).item()\n            val = max(0, min(dim_max, val))\n            coords.append(int(round(val)))  # sample discrete grid point (int)\n        candidate = Point(*coords)\n\n        # Validate sample position\n        if self._get_grid().is_agent_valid_pos(candidate):\n            return candidate\n        # fallback to uniform random sampling in rare invalid case\n        while True:\n            fallback_sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item()\n                                     for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(fallback_sample):\n                return fallback_sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dir_norm\n        q_new_pos = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new = Vertex(Point.from_tensor(q_new_pos))\n        return q_new\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n\n        path: List[Vertex] = [goal_v]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n        path.pop()  # remove the root start vertex itself added extra\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist = 15.0\n        iterations = 10000\n        max_radius = 40.0\n        lambda_rrt_star = 40.0\n        dimension = self._get_grid().size.n_dim\n\n        start_time = time()\n\n        for _ in range(iterations):\n\n            elapsed = time() - start_time\n            if elapsed > self._max_planning_time:\n                # Mark failure by skipping path extraction and returning\n                return\n\n            q_sample: Point = self._get_random_sample()\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = float(self._graph.size + 1)\n            log_card_v = max(1.0, torch.log(torch.tensor(card_v)).item())\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent with minimal cost + collision free\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            for q_near in Q_near:\n                line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if new path is better and collision free\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if cost_new_to_near < q_near.cost:\n                    # Remove old parent edge\n                    old_parent = next(iter(q_near.parents), None)\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = None\n                    # Add new edge and update cost\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 187, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is a hybrid advanced sample-based planner named Adaptive Informed RRT* (AIRRT*), combining adaptive sampling \n    with a focus on an informed ellipsoidal subset around the current best solution. \n    It improves planning efficiency by sampling mostly in the promising region (informed subset) shrinking as better paths \n    are discovered, drastically reducing unnecessary exploration.\n    It builds a forest with rewiring like RRT*, but adds heuristics:\n     - Adaptive dynamic informed sampling based on current best cost (path length).\n     - Early pruning by ignoring samples outside the informed ellipsoidal region.\n     - Biased rewiring selecting parents and children by cost+heuristic.\n     - Path smoothing post-processing using shortcut attempts.\n    The planner also monitors elapsed time and fails gracefully if exceeding 60 seconds.\n    This results in higher success rate, shorter smoother paths, reduced search time, and improved robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: Optional[float]\n    _best_goal_vertex: Optional[Vertex]\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._dimension = self._get_grid().size.n_dim\n        self._max_dist = float(max(self._get_grid().size.values)) / 10.0  # max step length scaled by map size\n        self._lambda_rrt_star = 40.0  # constant for radius calculation\n        self._max_radius = max(self._get_grid().size.values) / 3  # max radius for rewiring neighbors\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._start_time = 0.0\n        self._timeout = 60.0  # seconds time limit\n        self._best_cost = None  # best cost found so far\n        self._best_goal_vertex = None\n\n        self._init_displays()\n\n    # Helper: Get Euclidean distance between points\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    # Helper: Sample uniformly in informed ellipsoid subset if best_cost known, else whole space\n    def _informed_sample(self) -> Point:\n        # If no best solution yet, sample uniformly over map\n        if self._best_cost is None:\n            return self._uniform_sample()\n        else:\n            return self._ellipsoidal_sample()\n\n    def _uniform_sample(self) -> Point:\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _ellipsoidal_sample(self) -> Point:\n        \"\"\"\n        Samples within an n-D ellipsoid defined by start and goal and radius equal to current best cost.\n        Algorithm briefly:\n          1) Construct ellipsoid in Cartesian coordinates where foci = start and goal positions.\n          2) Generate random point inside unit n-ball, scale and rotate to fit ellipsoid.\n          3) Translate to center between foci.\n        \"\"\"\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        c_best = torch.tensor(self._best_cost)\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best < c_min:\n            c_best = c_min + 1e-3  # prevent numerical error\n\n        # Compute center and unit vector from start to goal (ellipse major axis)\n        center = (start + goal) / 2.0\n        foci_vec = (goal - start)\n        e_axis = foci_vec / torch.norm(foci_vec)\n\n        # Build orthonormal basis (rotation matrix) for the ellipsoid\n        # For 2D or 3D only; general n-D could be extended if needed\n        if self._dimension == 2:\n            # Rotate unit vector to get perpendicular vector\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])  # perpendicular in 2D\n        elif self._dimension == 3:\n            # Use Gram-Schmidt for basis vectors\n            # First axis is e_axis\n            z_axis = e_axis\n            # Pick arbitrary vector not colinear with z_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)  # 3x3 matrix\n        else:\n            # For higher dimensions fallback to uniform sampling (rare)\n            return self._uniform_sample()\n\n        # Length of ellipsoid axes\n        r1 = c_best / 2.0  # major axis radius\n        r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0  # minor axis radius\n\n        # Construct diagonal scaling matrix for ellipsoid axis lengths\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        elif self._dimension == 3:\n            # assume rotationally symmetric about major axis for simplicity\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n        else:\n            # fallback\n            return self._uniform_sample()\n\n        # Sample random point inside unit n-ball\n        while True:\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u > 1e-6:\n                break\n        unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n\n        # Map sample into ellipsoid coordinate frame: center + rotation * L * unit_ball_sample\n        sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n\n        # Round and clamp to grid bounds\n        sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, self._get_grid().size[i] - 1).round())) for i in range(self._dimension)]\n        sample_point = Point(*sample_coords)\n\n        if self._get_grid().is_agent_valid_pos(sample_point):\n            return sample_point\n        else:\n            # Fallback to uniform when invalid sample in ellipsoid region\n            return self._uniform_sample()\n\n    # Rewiring radius calculation (adaptive)\n    def _calc_rewire_radius(self) -> float:\n        card_v = torch.tensor(float(self._graph.size + 1))\n        log_card_v = torch.log(card_v)\n        radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1.0 / self._dimension)), self._max_radius)\n        return radius.item()\n\n    # Given a new vertex, select best parent from neighbors minimizing cost+heuristic\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Tuple[Optional[Vertex], float]:\n        c_min = float('inf')\n        q_min = None\n        for q_near in neighbors:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost = q_near.cost + self._dist(q_near.position, q_new.position)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n        return q_min, c_min\n\n    # Attempt shortcut smoothing of path by trying to connect nonconsecutive vertices in path directly\n    def _shortcut_path(self, path: List[Vertex], max_attempts=30) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = self._get_grid().get_line_sequence(p_i, p_j)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                # Remove intermediates and link directly\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    # Extract final path from goal vertex back to start and smooth it\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            # pick parent with lowest cost (usually only one)\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # shortcut smoothing\n        path = self._shortcut_path(path, max_attempts=40)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n\n        max_iterations = 15000\n        radius = self._calc_rewire_radius()\n\n        for iter in range(max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Path search failed due to timeout\n                return\n\n            q_sample = self._informed_sample()\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                # fallback: connect to nearest vertex directly\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors for potential cost reduction\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                if cost_through_new < q_near.cost:\n                    # Remove previous edge(s)\n                    for p in q_near.parents:\n                        self._graph.remove_edge(p, q_near)\n                    # Add edge from new vertex\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if q_new reaches goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if (self._best_cost is None) or (possible_cost < self._best_cost):\n                    # Update best cost and attach goal vertex\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    for p in goal_vertex.parents:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()\n\n    # Method from existing samples to generate intermediate point toward sample (same as RRT_Star and SPRM style)\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*[int(round(float(c))) for c in new_pos_tensor])\n        return Vertex(new_pos)",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 262, in _find_path_internal\nRuntimeError: Set changed size during iteration\n"
     }
}
{
     "operator": "m1",
     "algorithm": "This improved path planning algorithm combines the adaptive radius selection of RRT* with informed sampling \n    and dynamic rewiring to improve planning efficiency, path quality, and robustness. \n    It employs a heuristic-guided sampling biased towards the goal region (informed sampling ellipse), \n    dynamically adjusts the neighborhood radius based on the number of vertices, \n    and enforces collision-free rewiring to shorten paths and improve smoothness.\n    The algorithm terminates successfully when the agent reaches the goal radius or fails if it exceeds 60 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_planning_time = 60  # seconds\n\n        self._init_displays()\n\n    # --- Helper functions --- #\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Uses informed sampling with an ellipse defined by start, goal, and current best path length.\n        Bias sampling towards goal with 5% chance to jump directly.\n        \"\"\"\n        start: Point = self._graph.root_vertex_start.position\n        goal: Point = self._graph.root_vertex_goal.position\n\n        def dist(a: Point, b: Point) -> float:\n            return (a.to_tensor() - b.to_tensor()).norm().item()\n\n        max_dist = dist(start, goal)\n        best_goal_dist = None\n        # Try to estimate current best solution length from graph if possible\n        # fallback to direct start-goal dist if no path found yet\n        goal_vertex = self._graph.root_vertex_goal\n        if goal_vertex.cost is not None:\n            best_goal_dist = goal_vertex.cost\n        else:\n            best_goal_dist = max_dist * 1.5  # heuristic buffer\n\n        # Ellipse parameters for informed sampling\n        c_best = best_goal_dist\n        if c_best == float('inf') or c_best is None:\n            c_best = max_dist * 2.0\n\n        c_min = max_dist\n\n        # If the heuristic fails or no informative ellipse, uniformly sample\n        if c_best < c_min:\n            c_best = c_min * 1.1\n\n        # Sample roughly with 5% probability the goal directly (goal bias)\n        if torch.rand(1).item() < 0.05:\n            candidate = goal\n            if self._get_grid().is_agent_valid_pos(candidate):\n                return candidate\n\n        # Informed sampling ellipse centered between start and goal:\n        center_tensor = (start.to_tensor() + goal.to_tensor()) / 2\n        a1 = (goal.to_tensor() - start.to_tensor())\n        a1_norm = torch.norm(a1)\n        if a1_norm == 0:\n            a1_norm = 1.0\n        e1 = a1 / a1_norm\n        # radii of ellipse\n        r1 = c_best / 2\n        r2 = (r1 ** 2 - (c_min / 2) ** 2) ** 0.5 if r1 > (c_min / 2) else r1 * 0.1\n\n        while True:\n            # sample in unit circle (2D assumed)\n            sample_unit = torch.rand(2) * 2 - 1\n            if sample_unit.norm() <= 1.0:\n                break\n\n        # scale to ellipse\n        sample_ellipse = torch.zeros(2)\n        sample_ellipse[0] = sample_unit[0] * r1\n        sample_ellipse[1] = sample_unit[1] * r2\n\n        # rotation to align ellipse axis to start-goal line\n        # rotation matrix in 2D:\n        angle = torch.atan2(e1[1], e1[0])\n        rot_matrix = torch.tensor([[torch.cos(angle), -torch.sin(angle)],\n                                   [torch.sin(angle), torch.cos(angle)]])\n        sample_rotated = rot_matrix.matmul(sample_ellipse)\n\n        sample_point_tensor = center_tensor[:2] + sample_rotated\n\n        # Clamp sample_point_tensor to map bounds\n        dims = self._get_grid().size.n_dim\n        coords = []\n        for i in range(dims):\n            dim_max = self._get_grid().size[i] - 1\n            val = float(sample_point_tensor[i]) if i < 2 else torch.randint(0, dim_max + 1, (1,)).item()\n            val = max(0, min(dim_max, val))\n            coords.append(int(round(val)))  # sample discrete grid point (int)\n        candidate = Point(*coords)\n\n        # Validate sample position\n        if self._get_grid().is_agent_valid_pos(candidate):\n            return candidate\n        # fallback to uniform random sampling in rare invalid case\n        while True:\n            fallback_sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item()\n                                     for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(fallback_sample):\n                return fallback_sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dir_norm\n        q_new_pos = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new = Vertex(Point(*q_new_pos.tolist()))\n        return q_new\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n\n        path: List[Vertex] = [goal_v]\n        while path[-1].parents:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        # Remove possible addition of root start vertex if it appears last\n        if path[-1] == self._graph.root_vertex_start:\n            path.pop()\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist = 15.0\n        iterations = 10000\n        max_radius = 40.0\n        lambda_rrt_star = 40.0\n        dimension = self._get_grid().size.n_dim\n\n        start_time = time()\n\n        for _ in range(iterations):\n\n            elapsed = time() - start_time\n            if elapsed > self._max_planning_time:\n                # Mark failure by skipping path extraction and returning\n                return\n\n            q_sample: Point = self._get_random_sample()\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = float(self._graph.size + 1)\n            log_card_v = max(1.0, torch.log(torch.tensor(card_v)).item())\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent with minimal cost + collision free\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            for q_near in Q_near:\n                line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if new path is better and collision free\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if cost_new_to_near < q_near.cost:\n                    # Remove old parent edge\n                    old_parent = next(iter(q_near.parents), None)\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = None\n                    # Add new edge and update cost\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 187, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "m1",
     "algorithm": "This improved path planning algorithm combines the adaptive radius selection of RRT* with informed sampling \n    and dynamic rewiring to improve planning efficiency, path quality, and robustness. \n    It employs a heuristic-guided sampling biased towards the goal region (informed sampling ellipse), \n    dynamically adjusts the neighborhood radius based on the number of vertices, \n    and enforces collision-free rewiring to shorten paths and improve smoothness.\n    The algorithm terminates successfully when the agent reaches the goal radius or fails if it exceeds 60 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_planning_time = 60  # seconds\n\n        self._init_displays()\n\n    # --- Helper functions --- #\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Uses informed sampling with an ellipse defined by start, goal, and current best path length.\n        Bias sampling towards goal with 5% chance to jump directly.\n        \"\"\"\n        start: Point = self._graph.root_vertex_start.position\n        goal: Point = self._graph.root_vertex_goal.position\n\n        def dist(a: Point, b: Point) -> float:\n            return (a.to_tensor() - b.to_tensor()).norm().item()\n\n        max_dist = dist(start, goal)\n        best_goal_dist = None\n        # Try to estimate current best solution length from graph if possible\n        # fallback to direct start-goal dist if no path found yet\n        goal_vertex = self._graph.root_vertex_goal\n        if goal_vertex.cost is not None:\n            best_goal_dist = goal_vertex.cost\n        else:\n            best_goal_dist = max_dist * 1.5  # heuristic buffer\n\n        # Ellipse parameters for informed sampling\n        c_best = best_goal_dist\n        if c_best == float('inf') or c_best is None:\n            c_best = max_dist * 2.0\n\n        c_min = max_dist\n\n        # If the heuristic fails or no informative ellipse, uniformly sample\n        if c_best < c_min:\n            c_best = c_min * 1.1\n\n        # Sample roughly with 5% probability the goal directly (goal bias)\n        if torch.rand(1).item() < 0.05:\n            candidate = goal\n            if self._get_grid().is_agent_valid_pos(candidate):\n                return candidate\n\n        # Informed sampling ellipse centered between start and goal:\n        center_tensor = (start.to_tensor() + goal.to_tensor()) / 2\n        a1 = (goal.to_tensor() - start.to_tensor())\n        a1_norm = torch.norm(a1)\n        if a1_norm == 0:\n            a1_norm = 1.0\n        e1 = a1 / a1_norm\n        # radii of ellipse\n        r1 = c_best / 2\n        r2 = (r1 ** 2 - (c_min / 2) ** 2) ** 0.5 if r1 > (c_min / 2) else r1 * 0.1\n\n        while True:\n            # sample in unit circle (2D assumed)\n            sample_unit = torch.rand(2) * 2 - 1\n            if sample_unit.norm() <= 1.0:\n                break\n\n        # scale to ellipse\n        sample_ellipse = torch.zeros(2)\n        sample_ellipse[0] = sample_unit[0] * r1\n        sample_ellipse[1] = sample_unit[1] * r2\n\n        # rotation to align ellipse axis to start-goal line\n        # rotation matrix in 2D:\n        angle = torch.atan2(e1[1], e1[0])\n        rot_matrix = torch.tensor([[torch.cos(angle), -torch.sin(angle)],\n                                   [torch.sin(angle), torch.cos(angle)]])\n        sample_rotated = rot_matrix.matmul(sample_ellipse)\n\n        sample_point_tensor = center_tensor[:2] + sample_rotated\n\n        # Clamp sample_point_tensor to map bounds\n        dims = self._get_grid().size.n_dim\n        coords = []\n        for i in range(dims):\n            dim_max = self._get_grid().size[i] - 1\n            val = float(sample_point_tensor[i]) if i < 2 else torch.randint(0, dim_max + 1, (1,)).item()\n            val = max(0, min(dim_max, val))\n            coords.append(int(round(val)))  # sample discrete grid point (int)\n        candidate = Point(*coords)\n\n        # Validate sample position\n        if self._get_grid().is_agent_valid_pos(candidate):\n            return candidate\n        # fallback to uniform random sampling in rare invalid case\n        while True:\n            fallback_sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item()\n                                     for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(fallback_sample):\n                return fallback_sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dir_norm\n        q_new_pos = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new = Vertex(Point(*q_new_pos.tolist()))\n        return q_new\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n\n        path: List[Vertex] = [goal_v]\n        while path[-1].parents:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        # Remove possible addition of root start vertex if it appears last\n        if path[-1] == self._graph.root_vertex_start:\n            path.pop()\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist = 15.0\n        iterations = 10000\n        max_radius = 40.0\n        lambda_rrt_star = 40.0\n        dimension = self._get_grid().size.n_dim\n\n        start_time = time()\n\n        for _ in range(iterations):\n\n            elapsed = time() - start_time\n            if elapsed > self._max_planning_time:\n                # Mark failure by skipping path extraction and returning\n                return\n\n            q_sample: Point = self._get_random_sample()\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = float(self._graph.size + 1)\n            log_card_v = max(1.0, torch.log(torch.tensor(card_v)).item())\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent with minimal cost + collision free\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            for q_near in Q_near:\n                line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if new path is better and collision free\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if cost_new_to_near < q_near.cost:\n                    # Remove old parent edge\n                    old_parent = next(iter(q_near.parents), None)\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = None\n                    # Add new edge and update cost\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 187, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "m1",
     "algorithm": "This improved path planning algorithm combines the adaptive radius selection of RRT* with informed sampling \n    and dynamic rewiring to improve planning efficiency, path quality, and robustness. \n    It employs a heuristic-guided sampling biased towards the goal region (informed sampling ellipse), \n    dynamically adjusts the neighborhood radius based on the number of vertices, \n    and enforces collision-free rewiring to shorten paths and improve smoothness.\n    The algorithm terminates successfully when the agent reaches the goal radius or fails if it exceeds 60 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_planning_time = 60  # seconds\n\n        self._init_displays()\n\n    # --- Helper functions --- #\n\n    def _get_random_sample(self) -> \"Point\":\n        \"\"\"\n        Uses informed sampling with an ellipse defined by start, goal, and current best path length.\n        Bias sampling towards goal with 5% chance to jump directly.\n        \"\"\"\n        start: \"Point\" = self._graph.root_vertex_start.position\n        goal: \"Point\" = self._graph.root_vertex_goal.position\n\n        def dist(a: \"Point\", b: \"Point\") -> float:\n            return (a.to_tensor() - b.to_tensor()).norm().item()\n\n        max_dist = dist(start, goal)\n        best_goal_dist = None\n        # Try to estimate current best solution length from graph if possible\n        # fallback to direct start-goal dist if no path found yet\n        goal_vertex = self._graph.root_vertex_goal\n        if goal_vertex.cost is not None:\n            best_goal_dist = goal_vertex.cost\n        else:\n            best_goal_dist = max_dist * 1.5  # heuristic buffer\n\n        # Ellipse parameters for informed sampling\n        c_best = best_goal_dist\n        if c_best == float('inf') or c_best is None:\n            c_best = max_dist * 2.0\n\n        c_min = max_dist\n\n        # If the heuristic fails or no informative ellipse, uniformly sample\n        if c_best < c_min:\n            c_best = c_min * 1.1\n\n        # Sample roughly with 5% probability the goal directly (goal bias)\n        if torch.rand(1).item() < 0.05:\n            candidate = goal\n            if self._get_grid().is_agent_valid_pos(candidate):\n                return candidate\n\n        # Informed sampling ellipse centered between start and goal:\n        center_tensor = (start.to_tensor() + goal.to_tensor()) / 2\n        a1 = (goal.to_tensor() - start.to_tensor())\n        a1_norm = torch.norm(a1)\n        if a1_norm == 0:\n            a1_norm = 1.0\n        e1 = a1 / a1_norm\n        # radii of ellipse\n        r1 = c_best / 2\n        r2 = (r1 ** 2 - (c_min / 2) ** 2) ** 0.5 if r1 > (c_min / 2) else r1 * 0.1\n\n        while True:\n            # sample in unit circle (2D assumed)\n            sample_unit = torch.rand(2) * 2 - 1\n            if sample_unit.norm() <= 1.0:\n                break\n\n        # scale to ellipse\n        sample_ellipse = torch.zeros(2)\n        sample_ellipse[0] = sample_unit[0] * r1\n        sample_ellipse[1] = sample_unit[1] * r2\n\n        # rotation to align ellipse axis to start-goal line\n        # rotation matrix in 2D:\n        angle = torch.atan2(e1[1], e1[0])\n        rot_matrix = torch.tensor([[torch.cos(angle), -torch.sin(angle)],\n                                   [torch.sin(angle), torch.cos(angle)]])\n        sample_rotated = rot_matrix.matmul(sample_ellipse)\n\n        sample_point_tensor = center_tensor[:2] + sample_rotated\n\n        # Clamp sample_point_tensor to map bounds\n        dims = self._get_grid().size.n_dim\n        coords = []\n        for i in range(dims):\n            dim_max = self._get_grid().size[i] - 1\n            val = float(sample_point_tensor[i]) if i < 2 else torch.randint(0, dim_max + 1, (1,)).item()\n            val = max(0, min(dim_max, val))\n            coords.append(int(round(val)))  # sample discrete grid point (int)\n        candidate = Point(*coords)\n\n        # Validate sample position\n        if self._get_grid().is_agent_valid_pos(candidate):\n            return candidate\n        # fallback to uniform random sampling in rare invalid case\n        while True:\n            fallback_sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item()\n                                     for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(fallback_sample):\n                return fallback_sample\n\n    def _get_nearest_vertex(self, q_sample: \"Point\") -> \"Vertex\":\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, vertex: \"Vertex\", radius: float) -> List[\"Vertex\"]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: \"Vertex\", q_sample: \"Point\", max_dist: float) -> \"Vertex\":\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dir_norm\n        q_new_pos = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new = Vertex(Point(*q_new_pos.tolist()))\n        return q_new\n\n    def _extract_path(self, q_new: \"Vertex\") -> None:\n        goal_v: \"Vertex\" = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n\n        path: List[\"Vertex\"] = [goal_v]\n        while path[-1].parents:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        # Remove possible addition of root start vertex if it appears last\n        if path[-1] == self._graph.root_vertex_start:\n            path.pop()\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist = 15.0\n        iterations = 10000\n        max_radius = 40.0\n        lambda_rrt_star = 40.0\n        dimension = self._get_grid().size.n_dim\n\n        start_time = time()\n\n        for _ in range(iterations):\n\n            elapsed = time() - start_time\n            if elapsed > self._max_planning_time:\n                # Mark failure by skipping path extraction and returning\n                return\n\n            q_sample: \"Point\" = self._get_random_sample()\n            q_nearest: \"Vertex\" = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: \"Vertex\" = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = float(self._graph.size + 1)\n            log_card_v = max(1.0, torch.log(torch.tensor(card_v)).item())\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n\n            Q_near: List[\"Vertex\"] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent with minimal cost + collision free\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            for q_near in Q_near:\n                line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if new path is better and collision free\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if cost_new_to_near < q_near.cost:\n                    # Remove old parent edge\n                    old_parent = next(iter(q_near.parents), None)\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = None\n                    # Add new edge and update cost\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 187, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "m3",
     "algorithm": "This improved path planning algorithm implements an adaptive and informed RRT*-inspired planner \n    that balances exploration and exploitation by using heuristic-guided sampling within an ellipse \n    between start and goal, dynamic neighborhood radius based on vertex count and dimension, and \n    progressive rewiring for improved path quality and robustness. It terminates successfully once \n    the agent reaches the goal radius or fails if planning time exceeds 60 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_planning_time = 60  # seconds\n        self._init_displays()\n\n    def _dist(self, a: Point, b: Point) -> float:\n        return torch.norm(a.to_tensor() - b.to_tensor()).item()\n\n    def _get_random_sample(self) -> Point:\n        start = self._graph.root_vertex_start.position\n        goal = self._graph.root_vertex_goal.position\n        dim = self._get_grid().size.n_dim\n\n        c_min = self._dist(start, goal)\n        best_cost = self._graph.root_vertex_goal.cost\n        if best_cost is None or best_cost == float('inf'):\n            c_best = c_min * 2.0\n        else:\n            c_best = max(best_cost, c_min * 1.1)\n\n        # Goal bias 5%\n        if torch.rand(1).item() < 0.05:\n            candidate = goal\n            if self._get_grid().is_agent_valid_pos(candidate):\n                return candidate\n\n        center = (start.to_tensor() + goal.to_tensor()) / 2\n        e1_vec = goal.to_tensor() - start.to_tensor()\n        norm_e1 = torch.norm(e1_vec)\n        if norm_e1 < 1e-8:\n            e1_vec = torch.zeros(dim)\n            e1_vec[0] = 1.0\n            norm_e1 = 1.0\n        e1 = e1_vec / norm_e1\n\n        a1 = c_best / 2\n        a2 = (a1 ** 2 - (c_min / 2) ** 2) ** 0.5 if a1 > (c_min / 2) else a1 * 0.1\n\n        # Sample inside unit ball efficiently (2D assumed)\n        if dim == 2:\n            while True:\n                sample_unit = torch.rand(2) * 2 - 1\n                if sample_unit.norm() <= 1.0:\n                    break\n            sample_ellipse = torch.zeros(2)\n            sample_ellipse[0] = sample_unit[0] * a1\n            sample_ellipse[1] = sample_unit[1] * a2\n\n            angle = torch.atan2(e1[1], e1[0])\n            c, s = torch.cos(angle), torch.sin(angle)\n            rot = torch.tensor([[c, -s], [s, c]])\n            sample_rotated = rot.matmul(sample_ellipse)\n            sample_point = center[:2] + sample_rotated\n\n            coords = []\n            for i in range(dim):\n                val = float(sample_point[i]) if i < 2 else torch.randint(0, self._get_grid().size[i], (1,)).item()\n                val = max(0, min(self._get_grid().size[i] - 1, val))\n                coords.append(int(round(val)))\n            candidate = Point(*coords)\n        else:\n            # For nD, fallback: uniform random sample on valid grid\n            while True:\n                candidate = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(dim)])\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    break\n\n        if self._get_grid().is_agent_valid_pos(candidate):\n            return candidate\n\n        # fallback uniform sample if ellipse sample invalid\n        while True:\n            candidate = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(dim)])\n            if self._get_grid().is_agent_valid_pos(candidate):\n                return candidate\n\n    def _get_nearest_vertex(self, sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, sample)\n\n    def _get_neighbors_in_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _steer(self, from_v: Vertex, to_p: Point, max_extend_length: float) -> Vertex:\n        direction = to_p.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_extend_length:\n            return Vertex(to_p)\n        direction = direction / dist\n        new_pos_tensor = from_v.position.to_tensor() + max_extend_length * direction\n        new_pos = Point(*[int(round(v.item())) for v in new_pos_tensor])\n        return Vertex(new_pos)\n\n    def _extract_path(self, end_vertex: Vertex) -> None:\n        path = [end_vertex]\n        current = end_vertex\n        while current.parents:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n\n        if path[-1] == self._graph.root_vertex_start:\n            path.pop()  # remove start if appended redundantly\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_extend_length = 15.0\n        lambda_rrt_star = 30.0\n        max_radius = 40.0\n        dimension = self._get_grid().size.n_dim\n        max_iterations = 10000\n\n        import time\n        start_time = time.time()\n\n        for _ in range(max_iterations):\n            if time.time() - start_time > self._max_planning_time:\n                return  # Failed due to timeout\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._steer(q_nearest, q_sample, max_extend_length)\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            card = float(self._graph.size + 1)\n            log_card = max(1.0, torch.log(torch.tensor(card)).item())\n            radius = min(lambda_rrt_star * ((log_card / card) ** (1 / dimension)), max_radius)\n\n            neighbors = self._get_neighbors_in_radius(q_new, radius)\n\n            # Choose best parent minimizing cost + collision free edge\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._dist(q_nearest.position, q_new.position)\n            for q_near in neighbors:\n                line_seq_n = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_n):\n                    continue\n                cost = q_near.cost + self._dist(q_near.position, q_new.position)\n                if cost < c_min:\n                    q_min = q_near\n                    c_min = cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors with improved cost through q_new\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_r = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_r):\n                    continue\n                new_cost = q_new.cost + self._dist(q_new.position, q_near.position)\n                if new_cost < q_near.cost:\n                    old_parent = next(iter(q_near.parents), None)\n                    if old_parent:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 188, in _find_path_internal\nTypeError: unsupported operand type(s) for +: 'NoneType' and 'float'\n"
     }
}
{
     "operator": "e2",
     "algorithm": "\"Hybrid Adaptive RRT*-PRM Approach with Anytime Enhancement:\\n\"\n    \"This algorithm combines features from RRT* (asynchronous tree growth, rewiring for optimal paths),\\n\"\n    \"and Probabilistic Roadmap (PRM) for local roadmap building in promising areas.\\n\"\n    \"It introduces an adaptive search radius tuned with a heuristic estimation of remaining cost,\\n\"\n    \"performs local roadmap refinement around new vertices to boost connectivity and robustness,\\n\"\n    \"and applies anytime path improvement techniques by rewiring edges and pruning.\\n\"\n    \"Search terminates on goal reach or after 60 seconds, reporting failure if not found.\\n\"\n    \"Overall it aims for better path quality, smoother trajectories, faster convergence,\\n\"\n    \"higher success rates, and reduced search time compared to baseline RRT*.\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\n    \"Hybrid Adaptive RRT*-PRM Approach with Anytime Enhancement:\\n\"\n    \"This algorithm combines features from RRT* (asynchronous tree growth, rewiring for optimal paths),\\n\"\n    \"and Probabilistic Roadmap (PRM) for local roadmap building in promising areas.\\n\"\n    \"It introduces an adaptive search radius tuned with a heuristic estimation of remaining cost,\\n\"\n    \"performs local roadmap refinement around new vertices to boost connectivity and robustness,\\n\"\n    \"and applies anytime path improvement techniques by rewiring edges and pruning.\\n\"\n    \"Search terminates on goal reach or after 60 seconds, reporting failure if not found.\\n\"\n    \"Overall it aims for better path quality, smoother trajectories, faster convergence,\\n\"\n    \"higher success rates, and reduced search time compared to baseline RRT*.\"\n    }\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = Forest(start_vertex, goal_vertex, [])\n        self._init_displays()\n        self._max_dist = 12.0             # Max extension distance - tuned for faster progress\n        self._max_radius = 40.0           # Upper bound on neighbor radius\n        self._lambda_rrt_star = 40.0      # Scaling factor for radius calculation\n        self._dimension = self._get_grid().size.n_dim\n        self._max_time = 60.0             # Maximum allowed search time in seconds\n        self._prm_local_radius = 8.0      # Radius for local PRM connections near new vertex\n\n    def _get_random_sample(self) -> Vertex:\n        while True:\n            rand_pos = tuple(np.random.uniform(0, s) for s in self._get_grid().size.values)\n            sample = Vertex(Point(*rand_pos))\n            if self._get_grid().is_agent_valid_pos(sample.position):\n                return sample\n\n    def _get_nearest_vertex(self, vertex_list: List[Vertex], point: Point) -> Vertex:\n        \"\"\"Return nearest vertex in vertex_list to point.\"\"\"\n        return self._graph.get_nearest_vertex(vertex_list, point)\n\n    def _get_vertices_within_radius(self, vertex_list: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(vertex_list, point, radius)\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_dist: float) -> Optional[Vertex]:\n        direction = to_point.to_tensor() - from_vertex.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            return Vertex(to_point)\n        else:\n            direction_normalized = direction / dist\n            new_pos_tensor = from_vertex.position.to_tensor() + max_dist * direction_normalized\n            new_pos = Point.from_tensor(new_pos_tensor)\n            return Vertex(new_pos)\n\n    def _is_path_collision_free(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        \"\"\"Compute cost from frm to to; fall back on distance.\"\"\"\n        return self._get_grid().get_movement_cost(frm.position, to.position)\n\n    def _heuristic(self, point: Point) -> float:\n        \"\"\"Euclidean distance heuristic to goal.\"\"\"\n        return Map.get_distance(point, self._get_grid().goal.position)\n\n    def _local_prm_connect(self, v_new: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"Try connecting v_new to neighbors via collision-free edges, update graph edges optimizing cost.\"\"\"\n        for v_near in neighbors:\n            if v_near == v_new:\n                continue\n            if self._is_path_collision_free(v_new.position, v_near.position):\n                cost_to_new = v_near.cost + self._cost(v_near, v_new) if v_near.cost is not None else None\n                cost_from_new = v_new.cost + self._cost(v_new, v_near) if v_new.cost is not None else None\n\n                # Add edge v_near->v_new if better\n                if cost_to_new is not None and (v_new.cost is None or cost_to_new < v_new.cost):\n                    # Remove old parents edges from v_new if needed\n                    for p in list(v_new.parents):\n                        self._graph.remove_edge(p, v_new)\n                    v_new.cost = cost_to_new\n                    self._graph.add_edge(v_near, v_new)\n\n                # Add edge v_new->v_near if better (rewiring)\n                if cost_from_new is not None and (v_near.cost is None or cost_from_new < v_near.cost):\n                    for p in list(v_near.parents):\n                        self._graph.remove_edge(p, v_near)\n                    v_near.cost = cost_from_new\n                    self._graph.add_edge(v_new, v_near)\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        path = [goal_vertex]\n        current = goal_vertex\n        while current.parents:\n            # Choose parent with lowest cost\n            current = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            path.append(current)\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid = self._get_grid()\n            from algorithms.configuration.maps.ros_map import RosMap\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        iter_limit = 100000  # Large iterations limit, almost no cap except time\n\n        root_vertices = [self._graph.root_vertex_start]\n        self._graph.root_vertices = root_vertices\n\n        # Initialize start vertex cost\n        self._graph.root_vertex_start.cost = 0\n\n        for i in range(iter_limit):\n            if time.time() - start_time > self._max_time:\n                # Time limit exceeded - fail safe\n                break\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(root_vertices, q_sample.position)\n            if q_nearest.position == q_sample.position:\n                continue\n\n            q_new = self._steer(q_nearest, q_sample.position, self._max_dist)\n            if q_new is None:\n                continue\n            if not self._is_path_collision_free(q_nearest.position, q_new.position):\n                continue\n\n            # Compute adaptive radius based on current graph size and heuristic\n            n = max(self._graph.size, 1)\n            radius = min(self._lambda_rrt_star * ((np.log(n) / n) ** (1 / self._dimension)), self._max_radius)\n            # Bias radius adaptive by heuristic (smaller radius as closer to goal)\n            goal_dist = self._heuristic(q_new.position)\n            radius *= max(0.5, min(1.0, goal_dist / self._get_grid().size.width))\n\n            nearby_vertices = self._get_vertices_within_radius(root_vertices, q_new.position, radius)\n\n            # Choose best parent from neighbors or nearest\n            c_min = float('inf')\n            q_min = None\n            for near_v in nearby_vertices:\n                if not self._is_path_collision_free(near_v.position, q_new.position):\n                    continue\n                new_cost = near_v.cost + self._cost(near_v, q_new) if near_v.cost is not None else float('inf')\n                if new_cost < c_min:\n                    c_min = new_cost\n                    q_min = near_v\n\n            # If no suitable parent, connect to nearest vertex if valid\n            if q_min is None:\n                if not self._is_path_collision_free(q_nearest.position, q_new.position):\n                    continue\n                q_min = q_nearest\n                c_min = q_min.cost + self._cost(q_min, q_new)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n            root_vertices.append(q_new)\n\n            # Local PRM connections around new vertex for robustness and smoothness\n            prm_neighbors = self._get_vertices_within_radius(root_vertices, q_new.position, self._prm_local_radius)\n            prm_neighbors = [v for v in prm_neighbors if v != q_new]\n            self._local_prm_connect(q_new, prm_neighbors)\n\n            # Anytime rewiring with neighbors\n            for near_v in prm_neighbors:\n                if near_v == q_new:\n                    continue\n                if not self._is_path_collision_free(q_new.position, near_v.position):\n                    continue\n                cost_thru_new = q_new.cost + self._cost(q_new, near_v)\n                if cost_thru_new < near_v.cost:\n                    # Rewire neighbor\n                    # Remove old parent edges of near_v\n                    for p in list(near_v.parents):\n                        self._graph.remove_edge(p, near_v)\n                    near_v.cost = cost_thru_new\n                    self._graph.add_edge(q_new, near_v)\n\n            # Check if goal reached with radius check (to avoid missing radius)\n            if self._get_grid().is_agent_in_goal_radius(q_new.position):\n                # Attach goal vertex if needed\n                goal_vertex = self._graph.root_vertex_goal\n                if self._is_path_collision_free(q_new.position, goal_vertex.position):\n                    goal_vertex.cost = q_new.cost + Map.get_distance(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    self._extract_path(goal_vertex)\n                    return\n            # Key frame every iteration to record progress/animation\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 159, in _find_path_internal\n  File \"<string>\", line 70, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 149, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAssertionError: Can't look up a floating point Point in dense_map: Point(5.929869838504198, 8.414091694040726)\n"
     }
}
{
     "operator": "m1",
     "algorithm": "Improved hybrid bi-directional sampling-based path planner combining RRT*, RRT-Connect, and informed sampling.\n    It utilizes dual trees rooted at start and goal, adaptive heuristic-based sampling focused on the current best path\n    and goal region, and aggressive rewiring for path optimality and smoothness. Dynamic radius for rewiring promotes\n    efficient local connectivity. Early stopping upon path discovery or 60s timeout provides robustness.\n    The algorithm balances exploration and exploitation to improve planning speed, success rates, and path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_dist: float\n    _iterations: int\n    _timeout: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_cyclic_graph(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # Allow rewiring for path improvement\n\n        self._max_dist = 12.0\n        self._iterations = 15000\n        self._timeout = 60.0\n        self._init_displays()\n\n    def _get_random_sample(self, best_path: list = None) -> Point:\n        grid = self._get_grid()\n        rand_val = np.random.rand()\n\n        # 70% uniform free space\n        # 20% near goal region\n        # 10% near best path (local refinement)\n        if best_path and len(best_path) > 2 and rand_val > 0.8:\n            # Sample near random best path node\n            chosen_vertex = best_path[np.random.randint(0, len(best_path))]\n            radius = self._max_dist * 1.5\n            attempts = 0\n            while attempts < 15:\n                offset = np.random.uniform(-radius, radius, grid.size.n_dim)\n                coords = chosen_vertex.position.to_tensor().numpy() + offset\n                coords = np.clip(coords, 0, np.array(grid.size.values) - 1)\n                pt = Point(*coords.astype(int))\n                if grid.is_agent_valid_pos(pt):\n                    return pt\n                attempts += 1\n\n        elif rand_val > 0.6:\n            # Sample near goal area\n            goal = grid.goal.position\n            radius = self._max_dist * 2.0\n            attempts = 0\n            while attempts < 30:\n                offset = np.random.uniform(-radius, radius, grid.size.n_dim)\n                coords = goal.to_tensor().numpy() + offset\n                coords = np.clip(coords, 0, np.array(grid.size.values) - 1)\n                pt = Point(*coords.astype(int))\n                if grid.is_agent_valid_pos(pt):\n                    return pt\n                attempts += 1\n\n        # Uniform random sample fallback\n        attempts = 0\n        while True:\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            pt = Point(*rand_pos)\n            if grid.is_agent_valid_pos(pt):\n                return pt\n            attempts += 1\n            if attempts > 50:\n                return grid.agent.position\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        v_near = q_near.position.to_tensor()\n        v_sample = q_sample.to_tensor()\n        dir_vec = v_sample - v_near\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        direction = dir_vec / dist\n        new_pos_tensor = v_near + max_dist * direction\n        new_pos = Point(*new_pos_tensor.numpy().astype(int))\n        return Vertex(new_pos)\n\n    def _line_is_valid(self, start: Point, end: Point) -> bool:\n        line = self._get_grid().get_line_sequence(start, end)\n        return self._get_grid().is_valid_line_sequence(line)\n\n    def _choose_parent(self, new_vertex: Vertex, near_vertices: list) -> Vertex | None:\n        grid = self._get_grid()\n        best_parent = None\n        min_cost = float(\"inf\")\n        for vertex in near_vertices:\n            if not self._line_is_valid(vertex.position, new_vertex.position):\n                continue\n            parent_cost = vertex.cost if vertex.cost is not None else 0.0\n            edge_cost = grid.get_movement_cost(vertex.position, new_vertex.position)\n            cost = parent_cost + edge_cost\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = vertex\n        if best_parent is not None:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: list) -> None:\n        grid = self._get_grid()\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex or near_vertex in new_vertex.parents:\n                continue\n            if near_vertex.cost is None:\n                continue\n            if self._line_is_valid(new_vertex.position, near_vertex.position):\n                cost_through_new = new_vertex.cost + grid.get_movement_cost(new_vertex.position, near_vertex.position)\n                if cost_through_new < near_vertex.cost:\n                    # Remove old parents edges\n                    for p in near_vertex.parents.copy():\n                        self._graph.remove_edge(p, near_vertex)\n                    # Connect through new_vertex\n                    self._graph.add_edge(new_vertex, near_vertex)\n                    near_vertex.cost = cost_through_new\n\n    def _extract_path(self, start_vertex: Vertex, goal_vertex: Vertex) -> list:\n        # Backtrack start path\n        path_start = [start_vertex]\n        while len(path_start[-1].parents) != 0:\n            p = next(iter(path_start[-1].parents))\n            path_start.append(p)\n        path_start.reverse()\n\n        # Backtrack goal path\n        path_goal = [goal_vertex]\n        while len(path_goal[-1].parents) != 0:\n            p = next(iter(path_goal[-1].parents))\n            path_goal.append(p)\n\n        full_path = path_start + path_goal  # concatenation\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n        return full_path\n\n    def _connect_trees(self, q_new: Vertex, other_roots: Vertex, other_tree_vertices: list) -> bool:\n        grid = self._get_grid()\n        radius = max(self._max_dist * 1.5, 15.0)\n\n        q_near_other = self._graph.get_nearest_vertex([other_roots], q_new.position)\n        q_connect = self._get_new_vertex(q_new, q_near_other.position, self._max_dist)\n\n        if not self._line_is_valid(q_new.position, q_connect.position):\n            return False\n\n        near_vertices = self._graph.get_vertices_within_radius([other_roots], q_connect.position, radius)\n        parent_other = self._choose_parent(q_connect, near_vertices)\n        if parent_other is None:\n            return False\n\n        self._graph.add_edge(parent_other, q_connect)\n        if q_connect not in other_tree_vertices:\n            other_tree_vertices.append(q_connect)\n\n        if q_connect.position == q_near_other.position:\n            # Trees connected directly\n            path = self._extract_path(q_new, q_connect)\n            return True\n\n        # Extend toward connection vertex greedily\n        current_vertex = q_connect\n        extended = True\n        while extended:\n            q_extend = self._get_new_vertex(current_vertex, q_near_other.position, self._max_dist)\n            if q_extend.position == current_vertex.position:\n                break\n            if not self._line_is_valid(current_vertex.position, q_extend.position):\n                break\n            near_ext = self._graph.get_vertices_within_radius([other_roots], q_extend.position, radius)\n            parent_ext = self._choose_parent(q_extend, near_ext)\n            if parent_ext is None:\n                break\n            self._graph.add_edge(parent_ext, q_extend)\n            if q_extend not in other_tree_vertices:\n                other_tree_vertices.append(q_extend)\n            current_vertex = q_extend\n            if q_extend.position == q_near_other.position:\n                path = self._extract_path(q_new, q_extend)\n                return True\n        return False\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start_v = self._graph.root_vertex_start\n        goal_v = self._graph.root_vertex_goal\n\n        start_v.cost = 0.0\n        goal_v.cost = 0.0\n\n        tree_from_start = [start_v]\n        tree_from_goal = [goal_v]\n\n        best_path = None\n        best_cost = float(\"inf\")\n        start_time = time.time()\n\n        for iteration in range(self._iterations):\n            if (time.time() - start_time) > self._timeout:\n                # Fail due to timeout\n                break\n\n            # Alternate expanding start tree and goal tree\n            for curr_root, curr_tree, other_root, other_tree in [\n                (start_v, tree_from_start, goal_v, tree_from_goal),\n                (goal_v, tree_from_goal, start_v, tree_from_start),\n            ]:\n                # Sample with informed bias based on current best path\n                q_rand = self._get_random_sample(best_path)\n\n                # Find nearest vertex in current tree\n                q_near = self._graph.get_nearest_vertex([curr_root], q_rand)\n\n                # Propose a new vertex in direction toward sample up to max_dist\n                q_new = self._get_new_vertex(q_near, q_rand, self._max_dist)\n\n                # Validate path segment collision-free\n                if not self._line_is_valid(q_near.position, q_new.position):\n                    continue\n\n                # Dynamic radius for near neighbors in rewiring (increases with number of vertices)\n                n_vertices = len(curr_tree) + 1\n                gamma_rrt_star = 50.0  # chosen constant for radius scaling\n                radius = min(gamma_rrt_star * (np.log(n_vertices) / n_vertices) ** (1 / grid.size.n_dim), self._max_dist * 2)\n\n                near_vertices = self._graph.get_vertices_within_radius([curr_root], q_new.position, radius)\n                parent = self._choose_parent(q_new, near_vertices)\n                if parent is None:\n                    continue\n\n                # Add to tree and connect with best parent found\n                self._graph.add_edge(parent, q_new)\n                curr_tree.append(q_new)\n\n                # Rewire neighbors if we can reduce their costs via q_new\n                self._rewire(q_new, near_vertices)\n\n                # Attempt to connect q_new to other tree\n                connected = self._connect_trees(q_new, other_root, other_tree)\n                if connected:\n                    # Extracted path inside _connect_trees returns upon success\n                    # Stop planning, path found\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 125, in PathPlanning\nTypeError: unsupported operand type(s) for |: 'type' and 'NoneType'\n"
     }
}
{
     "operator": "m2",
     "algorithm": "Improved bi-directional hybrid sampling-based planner inspired by RRT*, RRT-Connect, and Informed RRT*.\n    Key improvements:\n    - Adaptive max extension distance based on current best path cost for balanced exploration/exploitation.\n    - Enhanced heuristic informed sampling incorporating ellipsoidal region around start-goal with goal bias.\n    - Radius for nearest neighbor search grows with iteration count, promoting early broad search then refined rewiring.\n    - Early stopping on timeout (60s) or successful connection with path cost improvement.\n    - Tighter parent choosing with cost + line validity + connectivity checks for better path quality.\n    - Rewiring selectively done only when improvement is detected to cut unnecessary rewires.\n    - Path extraction ensures smooth concatenation of start and goal trees.\n    - Maintains robustness and path smoothness with controlled sampling and exploration heuristics.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    \n    _graph: Forest\n    _initial_max_dist: float\n    _iterations: int\n    _timeout: float\n    \n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._initial_max_dist = max(self._get_grid().size.width, self._get_grid().size.height) / 5.0\n        self._iterations = 20000\n        self._timeout = 60.0\n        self._init_displays()\n    \n    def _adaptive_max_dist(self, best_cost: Optional[float]) -> float:\n        # Adaptive max extension distance shrinks as path improves to refine solution\n        grid_diag = ((self._get_grid().size.width ** 2) + (self._get_grid().size.height ** 2)) ** 0.5\n        if best_cost is None or best_cost == float('inf'):\n            return self._initial_max_dist\n        # Max dist scales between initial max dist and 1/10 grid diagonal, inversely proportional to best cost\n        scaled = max(self._initial_max_dist * 0.1, min(self._initial_max_dist, (best_cost / grid_diag) * self._initial_max_dist))\n        return scaled\n    \n    def _heuristic_informed_sample(self, best_path: Optional[List[Vertex]] = None) -> Point:\n        grid = self._get_grid()\n        rand_val = np.random.rand()\n        max_dim = np.array(grid.size.values)\n        start = grid.agent.position.to_tensor().numpy()\n        goal = grid.goal.position.to_tensor().numpy()\n        \n        # Goal-bias probability 25%\n        if rand_val < 0.25:\n            radius = self._initial_max_dist * 1.5\n            attempt = 0\n            while attempt < 20:\n                offset = np.random.uniform(-radius, radius, grid.size.n_dim)\n                sample_coords = goal + offset\n                sample_coords = np.clip(sample_coords, 0, max_dim - 1)\n                sample_point = Point(*sample_coords.astype(int))\n                if grid.is_agent_valid_pos(sample_point):\n                    return sample_point\n                attempt += 1\n        \n        # Informed set sampling (50% chance if best_path available and sufficiently long)\n        if best_path and len(best_path) > 2 and rand_val < 0.75:\n            c_min = np.linalg.norm(goal - start)\n            best_cost = best_path[-1].cost if best_path[-1].cost is not None else float('inf')\n            if best_cost < float('inf'):\n                # Define ellipsoidal informed sampling using start-goal frame\n                center = (start + goal) / 2\n                diff = goal - start\n                angle = np.arctan2(diff[1], diff[0])\n                \n                def sample_in_unit_ball(n_dim):\n                    while True:\n                        p = np.random.uniform(-1, 1, n_dim)\n                        if np.linalg.norm(p) <= 1:\n                            return p\n                \n                sample_unit = sample_in_unit_ball(grid.size.n_dim)\n                # Scale ellipsoid radii\n                r1 = best_cost / 2.0\n                r_rest = ((best_cost ** 2) - (c_min ** 2)) ** 0.5 / 2 if best_cost > c_min else 0.0\n                radii = np.array([r1] + [r_rest] * (grid.size.n_dim - 1))\n                # Rotation matrix for 2D\n                c, s = np.cos(angle), np.sin(angle)\n                rot_matrix = np.eye(grid.size.n_dim)\n                if grid.size.n_dim >= 2:\n                    rot_matrix[:2, :2] = np.array([[c, -s], [s, c]])\n                sample_scaled = np.dot(rot_matrix, sample_unit * radii) + center\n                sample_scaled = np.clip(sample_scaled, 0, max_dim - 1)\n                sample_point = Point(*sample_scaled.astype(int))\n                if grid.is_agent_valid_pos(sample_point):\n                    return sample_point\n        \n        # Local refined sampling near best path vertices - 15%\n        if best_path and len(best_path) > 2 and rand_val < 0.9:\n            radius = self._initial_max_dist * 1.2\n            attempt = 0\n            for _ in range(10):\n                path_vertex = best_path[np.random.randint(0, len(best_path))]\n                offset = np.random.uniform(-radius, radius, grid.size.n_dim)\n                sample_coords = path_vertex.position.to_tensor().numpy() + offset\n                sample_coords = np.clip(sample_coords, 0, max_dim - 1)\n                sample_point = Point(*sample_coords.astype(int))\n                if grid.is_agent_valid_pos(sample_point):\n                    return sample_point\n                attempt += 1\n        \n        # Uniform random sampling (10%)\n        attempt = 0\n        while attempt < 50:\n            rand_pos = np.random.randint(0, max_dim, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n            attempt += 1\n        \n        # Fallback\n        return grid.agent.position\n    \n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_tensor)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        if dist == 0:\n            return Vertex(q_near.position)\n        dir_normalized = dir_tensor / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*torch.clamp(new_pos_tensor, 0, self._get_grid().size.width - 1).int().tolist())\n        return Vertex(new_pos)\n    \n    def _line_is_valid(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n    \n    def _get_vertices_near(self, root_vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(root_vertices, point, radius)\n    \n    def _choose_parent(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> Vertex | None:\n        grid = self._get_grid()\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            if v == new_vertex or new_vertex.position == v.position:\n                continue\n            if self._line_is_valid(v.position, new_vertex.position):\n                cost_to_new = (v.cost if v.cost is not None else 0.0) + grid.get_movement_cost(v.position, new_vertex.position)\n                if cost_to_new < min_cost:\n                    min_cost = cost_to_new\n                    best_parent = v\n        if best_parent:\n            new_vertex.cost = min_cost\n        return best_parent\n    \n    def _rewire(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> None:\n        grid = self._get_grid()\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex or near_vertex == new_vertex.parents:\n                continue\n            if self._line_is_valid(new_vertex.position, near_vertex.position):\n                new_cost = new_vertex.cost + grid.get_movement_cost(new_vertex.position, near_vertex.position)\n                if near_vertex.cost is None or new_cost < near_vertex.cost:\n                    # Remove old parents edges\n                    for p in set(near_vertex.parents):\n                        self._graph.remove_edge(p, near_vertex)\n                    self._graph.add_edge(new_vertex, near_vertex)\n                    near_vertex.cost = new_cost\n    \n    def _extract_path(self, connecting_vertex_start: Vertex, connecting_vertex_goal: Vertex) -> list[Vertex]:\n        # Trace parents to root start\n        path_start = []\n        node = connecting_vertex_start\n        while node is not None:\n            path_start.append(node)\n            if not node.parents:\n                break\n            node = next(iter(node.parents))\n        path_start.reverse()\n        \n        # Trace parents to root goal\n        path_goal = []\n        node = connecting_vertex_goal\n        while node is not None:\n            path_goal.append(node)\n            if not node.parents:\n                break\n            node = next(iter(node.parents))\n        \n        full_path = path_start + path_goal\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n        return full_path\n    \n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        \n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n        \n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n        \n        best_path = None\n        best_cost = float('inf')\n        \n        start_time = time.time()\n        \n        for iteration in range(self._iterations):\n            if (time.time() - start_time) > self._timeout:\n                # Timeout/fail condition\n                break\n            \n            # Update adaptive max distance based on current best cost\n            max_dist = self._adaptive_max_dist(best_cost)\n            # Increase radius for near vertex search progressively (min 10 max 30)\n            radius = min(max(10.0, iteration ** 0.4), 30.0)\n            \n            # Alternate tree growth: first start tree, then goal tree\n            for roots_grow, tree_grow, roots_goal, tree_goal_list in [\n                (self._graph.root_vertex_start, tree_start, self._graph.root_vertex_goal, tree_goal),\n                (self._graph.root_vertex_goal, tree_goal, self._graph.root_vertex_start, tree_start)\n            ]:\n                q_rand = self._heuristic_informed_sample(best_path)\n                \n                q_near = self._graph.get_nearest_vertex([roots_grow], q_rand)\n                q_new = self._get_new_vertex(q_near, q_rand, max_dist)\n                \n                if not self._line_is_valid(q_near.position, q_new.position):\n                    continue\n                \n                near_vertices = self._get_vertices_near([roots_grow], q_new.position, radius)\n                parent = self._choose_parent(q_new, near_vertices)\n                if not parent:\n                    continue\n                \n                self._graph.add_edge(parent, q_new)\n                tree_grow.append(q_new)\n                \n                self._rewire(q_new, near_vertices)\n                \n                # Try to connect q_new to nearest vertex in other tree\n                q_near_other = self._graph.get_nearest_vertex([roots_goal], q_new.position)\n                if q_near_other is None:\n                    continue\n                \n                q_connect = self._get_new_vertex(q_new, q_near_other.position, max_dist)\n                if self._line_is_valid(q_new.position, q_connect.position):\n                    near_others = self._get_vertices_near([roots_goal], q_connect.position, radius)\n                    parent_other = self._choose_parent(q_connect, near_others)\n                    if parent_other:\n                        self._graph.add_edge(parent_other, q_connect)\n                        if q_connect not in tree_goal_list:\n                            tree_goal_list.append(q_connect)\n                        \n                        # Check if trees connected by position equality\n                        if q_connect.position == q_near_other.position:\n                            path = self._extract_path(q_new, q_connect)\n                            final_cost = path[-1].cost if path[-1].cost is not None else float('inf')\n                            if final_cost < best_cost:\n                                best_cost = final_cost\n                                best_path = path\n                            return  # Successful planning, terminate\n                        \n                        # Attempt to extend the other tree towards goal vertex fully\n                        current_vertex = q_connect\n                        extended = True\n                        while extended:\n                            q_extend = self._get_new_vertex(current_vertex, q_near_other.position, max_dist)\n                            if q_extend.position == current_vertex.position:\n                                break\n                            if self._line_is_valid(current_vertex.position, q_extend.position):\n                                near_ext = self._get_vertices_near([roots_goal], q_extend.position, radius)\n                                parent_ext = self._choose_parent(q_extend, near_ext)\n                                if parent_ext is None:\n                                    break\n                                self._graph.add_edge(parent_ext, q_extend)\n                                if q_extend not in tree_goal_list:\n                                    tree_goal_list.append(q_extend)\n                                current_vertex = q_extend\n                                if q_extend.position == q_near_other.position:\n                                    path = self._extract_path(q_new, q_extend)\n                                    final_cost = path[-1].cost if path[-1].cost is not None else float('inf')\n                                    if final_cost < best_cost:\n                                        best_cost = final_cost\n                                        best_path = path\n                                    return\n                            else:\n                                extended = False\n                \n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 164, in PathPlanning\nTypeError: unsupported operand type(s) for |: 'type' and 'NoneType'\n"
     }
}
{
     "operator": "e2",
     "algorithm": "\"Hybrid Adaptive RRT*-PRM Approach with Anytime Enhancement:\\n\"\n    \"This algorithm combines features from RRT* (asynchronous tree growth, rewiring for optimal paths),\\n\"\n    \"and Probabilistic Roadmap (PRM) for local roadmap building in promising areas.\\n\"\n    \"It introduces an adaptive search radius tuned with a heuristic estimation of remaining cost,\\n\"\n    \"performs local roadmap refinement around new vertices to boost connectivity and robustness,\\n\"\n    \"and applies anytime path improvement techniques by rewiring edges and pruning.\\n\"\n    \"Search terminates on goal reach or after 60 seconds, reporting failure if not found.\\n\"\n    \"Overall it aims for better path quality, smoother trajectories, faster convergence,\\n\"\n    \"higher success rates, and reduced search time compared to baseline RRT*.\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Hybrid Adaptive RRT*-PRM Approach with Anytime Enhancement:\n    This algorithm combines features from RRT* (asynchronous tree growth, rewiring for optimal paths),\n    and Probabilistic Roadmap (PRM) for local roadmap building in promising areas.\n    It introduces an adaptive search radius tuned with a heuristic estimation of remaining cost,\n    performs local roadmap refinement around new vertices to boost connectivity and robustness,\n    and applies anytime path improvement techniques by rewiring edges and pruning.\n    Search terminates on goal reach or after 60 seconds, reporting failure if not found.\n    Overall it aims for better path quality, smoother trajectories, faster convergence,\n    higher success rates, and reduced search time compared to baseline RRT*.\n    \"\"\"\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = Forest(start_vertex, goal_vertex, [])\n        self._init_displays()\n        self._max_dist = 12.0             # Max extension distance - tuned for faster progress\n        self._max_radius = 40.0           # Upper bound on neighbor radius\n        self._lambda_rrt_star = 40.0      # Scaling factor for radius calculation\n        self._dimension = self._get_grid().size.n_dim\n        self._max_time = 60.0             # Maximum allowed search time in seconds\n        self._prm_local_radius = 8.0      # Radius for local PRM connections near new vertex\n\n    def _get_random_sample(self) -> Vertex:\n        while True:\n            # Generate float sample, then floor to integer coordinates since map requires integer Points\n            rand_pos = tuple(int(np.floor(np.random.uniform(0, s))) for s in self._get_grid().size.values)\n            sample = Vertex(Point(*rand_pos))\n            if self._get_grid().is_agent_valid_pos(sample.position):\n                return sample\n\n    def _get_nearest_vertex(self, vertex_list: list, point: Point) -> Vertex:\n        \"\"\"Return nearest vertex in vertex_list to point.\"\"\"\n        return self._graph.get_nearest_vertex(vertex_list, point)\n\n    def _get_vertices_within_radius(self, vertex_list: list, point: Point, radius: float) -> list:\n        return self._graph.get_vertices_within_radius(vertex_list, point, radius)\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_dist: float) -> Vertex | None:\n        direction = to_point.to_tensor() - from_vertex.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            new_point = to_point\n        else:\n            direction_normalized = direction / dist\n            new_pos_tensor = from_vertex.position.to_tensor() + max_dist * direction_normalized\n            # Convert to integer Point by flooring coordinates\n            new_pos_int = tuple(int(np.floor(float(coord))) for coord in new_pos_tensor.tolist())\n            new_point = Point(*new_pos_int)\n        if not self._get_grid().is_agent_valid_pos(new_point):\n            return None\n        return Vertex(new_point)\n\n    def _is_path_collision_free(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        \"\"\"Compute cost from frm to to; fall back on distance.\"\"\"\n        return self._get_grid().get_movement_cost(frm.position, to.position)\n\n    def _heuristic(self, point: Point) -> float:\n        \"\"\"Euclidean distance heuristic to goal.\"\"\"\n        return Map.get_distance(point, self._get_grid().goal.position)\n\n    def _local_prm_connect(self, v_new: Vertex, neighbors: list) -> None:\n        \"\"\"Try connecting v_new to neighbors via collision-free edges, update graph edges optimizing cost.\"\"\"\n        for v_near in neighbors:\n            if v_near == v_new:\n                continue\n            if self._is_path_collision_free(v_new.position, v_near.position):\n                cost_to_new = v_near.cost + self._cost(v_near, v_new) if v_near.cost is not None else None\n                cost_from_new = v_new.cost + self._cost(v_new, v_near) if v_new.cost is not None else None\n\n                # Add edge v_near->v_new if better\n                if cost_to_new is not None and (v_new.cost is None or cost_to_new < v_new.cost):\n                    for p in list(v_new.parents):\n                        self._graph.remove_edge(p, v_new)\n                    v_new.cost = cost_to_new\n                    self._graph.add_edge(v_near, v_new)\n\n                # Add edge v_new->v_near if better (rewiring)\n                if cost_from_new is not None and (v_near.cost is None or cost_from_new < v_near.cost):\n                    for p in list(v_near.parents):\n                        self._graph.remove_edge(p, v_near)\n                    v_near.cost = cost_from_new\n                    self._graph.add_edge(v_new, v_near)\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        path = [goal_vertex]\n        current = goal_vertex\n        while current.parents:\n            # Choose parent with lowest cost\n            current = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            path.append(current)\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid = self._get_grid()\n            from algorithms.configuration.maps.ros_map import RosMap\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        iter_limit = 100000  # Large iterations limit, almost no cap except time\n\n        root_vertices = [self._graph.root_vertex_start]\n        self._graph.root_vertices = root_vertices\n\n        # Initialize start vertex cost\n        self._graph.root_vertex_start.cost = 0\n\n        for i in range(iter_limit):\n            if time.time() - start_time > self._max_time:\n                # Time limit exceeded - fail safe\n                break\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(root_vertices, q_sample.position)\n            if q_nearest.position == q_sample.position:\n                continue\n\n            q_new = self._steer(q_nearest, q_sample.position, self._max_dist)\n            if q_new is None:\n                continue\n            if not self._is_path_collision_free(q_nearest.position, q_new.position):\n                continue\n\n            # Compute adaptive radius based on current graph size and heuristic\n            n = max(self._graph.size, 1)\n            radius = min(self._lambda_rrt_star * ((np.log(n) / n) ** (1 / self._dimension)), self._max_radius)\n            # Bias radius adaptive by heuristic (smaller radius as closer to goal)\n            goal_dist = self._heuristic(q_new.position)\n            # Use size.width as denominator safely, cast float\n            width = float(self._get_grid().size.width) if self._get_grid().size.width != 0 else 1.0\n            radius *= max(0.5, min(1.0, goal_dist / width))\n\n            nearby_vertices = self._get_vertices_within_radius(root_vertices, q_new.position, radius)\n\n            # Choose best parent from neighbors or nearest\n            c_min = float('inf')\n            q_min = None\n            for near_v in nearby_vertices:\n                if not self._is_path_collision_free(near_v.position, q_new.position):\n                    continue\n                new_cost = near_v.cost + self._cost(near_v, q_new) if near_v.cost is not None else float('inf')\n                if new_cost < c_min:\n                    c_min = new_cost\n                    q_min = near_v\n\n            # If no suitable parent, connect to nearest vertex if valid\n            if q_min is None:\n                if not self._is_path_collision_free(q_nearest.position, q_new.position):\n                    continue\n                q_min = q_nearest\n                c_min = q_min.cost + self._cost(q_min, q_new)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n            root_vertices.append(q_new)\n\n            # Local PRM connections around new vertex for robustness and smoothness\n            prm_neighbors = self._get_vertices_within_radius(root_vertices, q_new.position, self._prm_local_radius)\n            prm_neighbors = [v for v in prm_neighbors if v != q_new]\n            self._local_prm_connect(q_new, prm_neighbors)\n\n            # Anytime rewiring with neighbors\n            for near_v in prm_neighbors:\n                if near_v == q_new:\n                    continue\n                if not self._is_path_collision_free(q_new.position, near_v.position):\n                    continue\n                cost_thru_new = q_new.cost + self._cost(q_new, near_v)\n                if cost_thru_new < near_v.cost:\n                    for p in list(near_v.parents):\n                        self._graph.remove_edge(p, near_v)\n                    near_v.cost = cost_thru_new\n                    self._graph.add_edge(q_new, near_v)\n\n            # Check if goal reached with radius check (to avoid missing radius)\n            if self._get_grid().is_agent_in_goal_radius(q_new.position):\n                # Attach goal vertex if needed\n                goal_vertex = self._graph.root_vertex_goal\n                if self._is_path_collision_free(q_new.position, goal_vertex.position):\n                    goal_vertex.cost = q_new.cost + Map.get_distance(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    self._extract_path(goal_vertex)\n                    return\n            # Key frame every iteration to record progress/animation\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 81, in PathPlanning\nTypeError: unsupported operand type(s) for |: 'type' and 'NoneType'\n"
     }
}
{
     "operator": "m3",
     "algorithm": "This algorithm is an improved sample-based planner combining adaptive informed sampling and anytime iterative path refinement.\n    It builds a forest like RRT*, focusing sample efforts in ellipsoidal informed subsets defined by the current best cost to minimize unnecessary exploration.\n    The algorithm performs dynamic rewiring with cost+heuristic parent selection, and integrates progressive path shortcut smoothing during planning.\n    Timeout handling ensures graceful failure beyond 60 seconds.\n    This approach improves planning efficiency, path quality, smoothness, robustness, and success rate while reducing search time and path lengths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: float | None\n    _best_goal_vertex: Vertex | None\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._dimension = self._get_grid().size.n_dim\n        max_map_dim = max(self._get_grid().size.values)\n        self._max_dist = max_map_dim / 10.0\n        self._lambda_rrt_star = 35.0\n        self._max_radius = max_map_dim / 3\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._start_time = 0.0\n        self._timeout = 60.0\n        self._best_cost = None\n        self._best_goal_vertex = None\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _uniform_sample(self) -> Point:\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            pt = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(pt):\n                return pt\n\n    def _ellipsoidal_sample(self) -> Point:\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        c_best = torch.tensor(self._best_cost)\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best < c_min:\n            c_best = c_min + 1e-6\n        center = (start + goal) / 2.0\n        foci_vec = (goal - start)\n        e_axis = foci_vec / torch.norm(foci_vec)\n\n        if self._dimension == 2:\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])\n        elif self._dimension == 3:\n            z_axis = e_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n        else:\n            return self._uniform_sample()\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0\n\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        elif self._dimension == 3:\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n        else:\n            return self._uniform_sample()\n\n        for _ in range(20):  # limit retries\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u < 1e-6:\n                continue\n            unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n            sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n            sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, self._get_grid().size[i] - 1).round())) for i in range(self._dimension)]\n            sample_point = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n        return self._uniform_sample()\n\n    def _informed_sample(self) -> Point:\n        if self._best_cost is None:\n            return self._uniform_sample()\n        return self._ellipsoidal_sample()\n\n    def _calc_rewire_radius(self) -> float:\n        n = float(self._graph.size + 1)\n        radius = self._lambda_rrt_star * ((torch.log(torch.tensor(n)) / n) ** (1.0 / self._dimension))\n        return min(radius.item(), self._max_radius)\n\n    def _choose_parent(self, neighbors: list[Vertex], q_new: Vertex) -> tuple[Vertex | None, float]:\n        c_min = float('inf')\n        q_min = None\n        for q_near in neighbors:\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = q_near.cost + self._dist(q_near.position, q_new.position)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n        return q_min, c_min\n\n    def _shortcut_path(self, path: list[Vertex], max_attempts: int = 40) -> list[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts and len(new_path) >= 3:\n            attempts += 1\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i, p_j = new_path[i].position, new_path[j].position\n            line_seq = self._get_grid().get_line_sequence(p_i, p_j)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = min(current.parents, key=lambda v: v.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n        path = self._shortcut_path(path, max_attempts=50)\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_coords = [int(round(float(c))) for c in new_pos_tensor]\n        new_point = Point(*new_coords)\n        return Vertex(new_point)\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n        max_iterations = 20000\n        radius = self._calc_rewire_radius()\n\n        for iteration in range(max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Timeout: path search failed\n                return\n\n            q_sample = self._informed_sample()\n\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors through q_new\n            for q_near in neighbors:\n                if q_near is q_min:\n                    continue\n                line_seq_back = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_back):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                if cost_through_new + 1e-8 < q_near.cost:\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if q_new reaches goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if (self._best_cost is None) or (possible_cost < self._best_cost):\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 49, in PathPlanning\nTypeError: unsupported operand type(s) for |: 'type' and 'NoneType'\n"
     }
}
{
     "operator": "m1",
     "algorithm": "Improved Adaptive Informed RRT* with multi-strategy sampling,\n    dynamic rewiring radius, path smoothing via advanced shortcutting,\n    and fail-safe timeout logic.\n    This algorithm synergizes uniform sampling, ellipsoidal informed sampling,\n    and focused local exploration to balance exploration and exploitation.\n    It adaptively adjusts rewiring radius and reuses partial paths to improve\n    path quality and smoothness, ensuring higher success rate and robustness\n    in diverse map sizes and obstacle configurations.\n    Failure to find a path within 60 seconds results in an explicit search fail.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: float | None\n    _best_goal_vertex: Vertex | None\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        grid = self._get_grid()\n        self._dimension = grid.size.n_dim\n        max_map_dim = max(grid.size.values)\n        self._max_dist = max_map_dim / 12.0  # max movement distance step\n        self._lambda_rrt_star = 45.0  # constant for adaptive radius calc\n        self._max_radius = max_map_dim / 2.5  # rewiring max radius\n\n        start_vertex = Vertex(grid.agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(grid.goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        self._start_time = 0.0\n        self._timeout = 60.0\n        self._best_cost = None\n        self._best_goal_vertex = None\n\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _uniform_sample(self) -> Point:\n        grid = self._get_grid()\n        while True:\n            coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _ellipsoidal_sample(self) -> Point:\n        grid = self._get_grid()\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        c_best = torch.tensor(self._best_cost) if self._best_cost is not None else None\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best is None or c_best < c_min:\n            return self._uniform_sample()\n\n        center = (start + goal) / 2.0\n        foci_vec = goal - start\n        e_axis = foci_vec / torch.norm(foci_vec)\n\n        if self._dimension == 2:\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])\n        elif self._dimension == 3:\n            z_axis = e_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n        else:\n            return self._uniform_sample()\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0\n\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        elif self._dimension == 3:\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n        else:\n            return self._uniform_sample()\n\n        while True:\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u > 1e-6:\n                break\n        unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n\n        sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n        sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, grid.size[i] - 1).round())) for i in range(self._dimension)]\n        sample_point = Point(*sample_coords)\n\n        if grid.is_agent_valid_pos(sample_point):\n            return sample_point\n        return self._uniform_sample()\n\n    def _adaptive_sample(self) -> Point:\n        # Use multi-strategy sampling:\n        # 60% informed ellipsoid if best_cost known,\n        # else uniform,\n        # 20% local sampling around root path if best available,\n        # 20% pure uniform exploration.\n        import random\n        if self._best_cost is None:\n            return self._uniform_sample()\n\n        choice = random.random()\n        if choice < 0.6:\n            return self._ellipsoidal_sample()\n        elif choice < 0.8 and self._best_goal_vertex is not None:\n            # Local sampling near current best path vertices, bias exploration near existing paths\n            near_verts = self._graph.get_vertices_within_radius(\n                self._graph.root_vertices, self._best_goal_vertex.position, self._max_dist * 5)\n            if near_verts:\n                from random import choice as rchoice\n                base_vertex = rchoice(near_verts)\n                perturb = [int(round(torch.randn(1).item() * self._max_dist / 2)) for _ in range(self._dimension)]\n                sample_coords = [max(0, min(self._get_grid().size[i] - 1, base_vertex.position[i] + perturb[i])) for i in range(self._dimension)]\n                sample_point = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample_point):\n                    return sample_point\n            return self._uniform_sample()\n        else:\n            return self._uniform_sample()\n\n    def _calc_rewire_radius(self) -> float:\n        card_v = torch.tensor(float(self._graph.size + 1))\n        log_card_v = torch.log(card_v)\n        radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1.0 / self._dimension)), self._max_radius)\n        # decrease radius progressively with better cost found to improve rewiring locality\n        if self._best_cost is not None:\n            improvement_factor = max(0.2, min(1.0, self._best_cost / (self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position) * 2)))\n            radius *= improvement_factor\n        return radius.item()\n\n    def _choose_parent(self, neighbors: list[Vertex], q_new: Vertex) -> tuple[Vertex | None, float]:\n        c_min = float('inf')\n        q_min = None\n        grid = self._get_grid()\n\n        def est_cost_to_goal(pos: Point) -> float:\n            return self._dist(pos, self._graph.root_vertex_goal.position)\n\n        for q_near in neighbors:\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost = q_near.cost + self._dist(q_near.position, q_new.position) + est_cost_to_goal(q_new.position)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n        if q_min is None:\n            return None, float('inf')\n        # Return cost without heuristic for actual cost accounting\n        cost_no_heuristic = q_min.cost + self._dist(q_min.position, q_new.position)\n        return q_min, cost_no_heuristic\n\n    def _shortcut_path(self, path: list[Vertex], max_attempts=50) -> list[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        grid = self._get_grid()\n        attempt = 0\n        while attempt < max_attempts and len(new_path) >= 3:\n            attempt += 1\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = grid.get_line_sequence(p_i, p_j)\n            if grid.is_valid_line_sequence(line_seq):\n                # Remove intermediates between i and j\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        grid = self._get_grid()\n        # Clamp and round inside grid\n        new_pos_coords = [int(round(float(torch.clamp(new_pos_tensor[i], 0, grid.size[i] - 1)))) for i in range(self._dimension)]\n        return Vertex(Point(*new_pos_coords))\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n\n        max_iterations = 20000\n        grid = self._get_grid()\n\n        for iteration in range(max_iterations):\n            # Timeout check\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Failed to find path within time\n                return\n\n            q_sample = self._adaptive_sample()\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            radius = self._calc_rewire_radius()\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                # fallback connect to nearest\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_rev = grid.get_line_sequence(q_new.position, q_near.position)\n                if not grid.is_valid_line_sequence(line_seq_rev):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                if cost_through_new < q_near.cost:\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if self._best_cost is None or possible_cost < self._best_cost:\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 49, in PathPlanning\nTypeError: unsupported operand type(s) for |: 'type' and 'NoneType'\n"
     }
}
{
     "operator": "e1",
     "algorithm": "Improved Path Planning Algorithm Using Adaptive Guided RRT* with Dynamic Rewiring and Heuristic Pruning.\n      \n      This algorithm enhances path planning by combining multiple improvements:\n      - Adaptive sampling bias that shifts progressively from uniform random to goal- and best-path-informed.\n      - Uses an incremental RRT*-style rewiring for path cost optimization.\n      - Dynamic neighborhood radius shrinks as tree size grows to balance exploration and exploitation.\n      - Heuristic pruning of samples unlikely to improve current best path cost to speed convergence.\n      - Early stopping upon finding a path or reaching a 60-second timeout.\n      - Path smoothing via shortcutting after path extraction.\n      \n      This approach targets improved planning efficiency, better path quality and smoothness,\n      higher success rates with robust collision checking, and reduced overall search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    # Constants: Tunable parameters for performance\n    _max_dist: float\n    _max_iterations: int\n    _timeout_sec: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 15.0\n        self._max_iterations = 15000\n        self._timeout_sec = 60.0\n\n        # Initialize cyclic graph with start and goal vertices and allow rewiring for RRT*\n        self._graph = gen_cyclic_graph(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_adaptive_sample(self, best_path: list[Vertex] | None, iteration: int) -> Point:\n        grid = self._get_grid()\n        dim = grid.size.n_dim\n        max_dims = np.array(grid.size.values) - 1\n\n        # As iterations increase, increase bias towards goal and best path\n        bias_goal_prob = min(0.4 + iteration / self._max_iterations * 0.4, 0.8)\n        bias_path_prob = min(0.15 + iteration / self._max_iterations * 0.25, 0.4)\n        rand_val = np.random.rand()\n\n        if best_path and len(best_path) > 2:\n            if rand_val < bias_path_prob:\n                # Sample near random vertex on best path with small Gaussian noise\n                for _ in range(20):\n                    path_v = best_path[np.random.randint(0, len(best_path))]\n                    center = path_v.position.to_tensor().numpy()\n                    radius = max(self._max_dist * 0.5, 5)\n                    offset = np.random.normal(0, radius/2, dim)\n                    sample_pos = center + offset\n                    sample_pos = np.clip(sample_pos, 0, max_dims)\n                    sample_point = Point(*sample_pos.astype(int))\n                    if grid.is_agent_valid_pos(sample_point):\n                        return sample_point\n\n            if rand_val < bias_goal_prob:\n                # Sample near goal within max_dist radius with uniform random in sphere\n                goal_tensor = grid.goal.position.to_tensor().numpy()\n                radius = self._max_dist * 1.5\n                for _ in range(20):\n                    offset = np.random.uniform(-radius, radius, dim)\n                    sample_pos = goal_tensor + offset\n                    sample_pos = np.clip(sample_pos, 0, max_dims)\n                    sample_point = Point(*sample_pos.astype(int))\n                    if grid.is_agent_valid_pos(sample_point):\n                        return sample_point\n\n        # Uniform random sampling if no bias selected\n        for _ in range(50):\n            coords = np.random.randint(0, max_dims + 1, dim)\n            sample_point = Point(*coords)\n            if grid.is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # fallback to agent position if no valid sample found\n        return grid.agent.position\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_dist: float) -> Point:\n        from_tensor = from_vertex.position.to_tensor()\n        to_tensor = to_point.to_tensor()\n        direction = to_tensor - from_tensor\n        distance = torch.norm(direction)\n        if distance <= max_dist:\n            return to_point\n        direction = direction / distance\n        new_pos_tensor = from_tensor + max_dist * direction\n        new_point = Point(*new_pos_tensor.round().int().tolist())\n        return new_point\n\n    def _line_is_valid(self, frm: Point, to: Point) -> bool:\n        grid = self._get_grid()\n        line_seq = grid.get_line_sequence(frm, to)\n        return grid.is_valid_line_sequence(line_seq)\n\n    def _choose_best_parent(self, new_pos: Point, near_vertices: list[Vertex]) -> tuple[Vertex | None, float]:\n        grid = self._get_grid()\n        best_parent = None\n        best_cost = float(\"inf\")\n        for v in near_vertices:\n            if self._line_is_valid(v.position, new_pos):\n                current_cost = (v.cost if v.cost is not None else 0.0) + grid.get_movement_cost(v.position, new_pos)\n                if current_cost < best_cost:\n                    best_cost = current_cost\n                    best_parent = v\n        return best_parent, best_cost\n\n    def _rewire_near_vertices(self, new_vertex: Vertex, near_vertices: list[Vertex]) -> None:\n        grid = self._get_grid()\n        for near_v in near_vertices:\n            if near_v == new_vertex or near_v in new_vertex.parents:\n                continue\n            if self._line_is_valid(new_vertex.position, near_v.position):\n                cost_through_new = new_vertex.cost + grid.get_movement_cost(new_vertex.position, near_v.position)\n                if near_v.cost is None or cost_through_new < near_v.cost:\n                    # Remove all old parent edges\n                    for p in near_v.parents.copy():\n                        self._graph.remove_edge(p, near_v)\n                    self._graph.add_edge(new_vertex, near_v)\n                    near_v.cost = cost_through_new\n\n    def _get_neighborhood_radius(self, n_vertices: int) -> float:\n        # Adaptive radius: shrinks with number of vertices as RRT* suggests\n        # radius = gamma * (log(n)/n)^(1/d), gamma chosen proportional to max_dist\n        import math\n        gamma = self._max_dist * 2.0\n        d = self._get_grid().size.n_dim\n        if n_vertices <= 1:\n            return self._max_dist * 2\n        radius = gamma * (math.log(n_vertices) / n_vertices) ** (1 / d)\n        radius = min(radius, self._max_dist * 2)\n        return radius\n\n    def _extract_path(self, connecting_start: Vertex, connecting_goal: Vertex) -> list[Vertex]:\n        # Trace parents from connecting start vertex to root start\n        path_from_start = []\n        curr = connecting_start\n        while curr.parents:\n            path_from_start.append(curr)\n            curr = next(iter(curr.parents))\n        path_from_start.append(curr)  # add root\n        path_from_start.reverse()\n\n        # Trace parents from connecting goal vertex to root goal\n        path_from_goal = []\n        curr = connecting_goal\n        while curr.parents:\n            path_from_goal.append(curr)\n            curr = next(iter(curr.parents))\n        path_from_goal.append(curr)  # root\n\n        # Concatenate start path with reversed goal path (excluding duplicate connecting vertex)\n        full_path = path_from_start + path_from_goal[::-1][1:]\n\n        return full_path\n\n    def _shortcut_path(self, path: list[Vertex]) -> list[Vertex]:\n        \"\"\"\n        Path smoothing by shortcutting non-collision edges between path vertices.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        optimized_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            # Try to find the farthest vertex reachable from optimized_path[-1] without collisions\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_is_valid(optimized_path[-1].position, path[j].position):\n                    break\n                j -= 1\n            optimized_path.append(path[j])\n            i = j\n        return optimized_path\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        tree_start_vertices = [start_vertex]\n        tree_goal_vertices = [goal_vertex]\n\n        best_path = None\n        best_cost = float('inf')\n\n        start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout_sec:\n                # Timeout reached - path planning failed\n                break\n\n            # Alternate tree expansion (start tree first, then goal tree)\n            for (root_vertex, tree_vertices, other_root_vertex, other_tree_vertices) in [\n                (start_vertex, tree_start_vertices, goal_vertex, tree_goal_vertices),\n                (goal_vertex, tree_goal_vertices, start_vertex, tree_start_vertices),\n            ]:\n                # Sample adaptively biased to best path and goal\n                sample_point = self._get_adaptive_sample(best_path, iteration)\n\n                # Find nearest vertex in current tree to sample\n                nearest_vertex = self._graph.get_nearest_vertex([root_vertex], sample_point)\n\n                # Steer from nearest vertex toward sample within max_dist\n                new_point = self._steer(nearest_vertex, sample_point, self._max_dist)\n\n                # Check for collision on path from nearest_vertex to new_point\n                if not self._line_is_valid(nearest_vertex.position, new_point):\n                    continue\n\n                # Determine adaptive neighborhood radius for rewiring and parent choosing\n                radius = self._get_neighborhood_radius(len(tree_vertices))\n\n                # Find near vertices for connection and rewiring\n                near_vertices = self._graph.get_vertices_within_radius([root_vertex], new_point, radius)\n\n                # Choose best parent with minimal cost + collision-free edge\n                best_parent, cost_to_new = self._choose_best_parent(new_point, near_vertices)\n                if best_parent is None:\n                    continue\n\n                # Add new vertex and connect to best parent\n                new_vertex = Vertex(new_point, store_connectivity=True)\n                new_vertex.cost = cost_to_new\n                self._graph.add_edge(best_parent, new_vertex)\n                tree_vertices.append(new_vertex)\n\n                # Rewire near vertices through new_vertex if it improves cost\n                self._rewire_near_vertices(new_vertex, near_vertices)\n\n                # Attempt to connect new_vertex to the other tree\n                nearest_other = self._graph.get_nearest_vertex([other_root_vertex], new_point)\n                connect_point = self._steer(new_vertex, nearest_other.position, self._max_dist)\n\n                if connect_point == new_vertex.position:\n                    # No progress toward other tree\n                    continue\n\n                if self._line_is_valid(new_vertex.position, connect_point):\n                    near_others = self._graph.get_vertices_within_radius([other_root_vertex], connect_point, radius)\n                    \n                    parent_other, cost_other = self._choose_best_parent(connect_point, near_others)\n                    if parent_other is None:\n                        continue\n\n                    connect_vertex = Vertex(connect_point, store_connectivity=True)\n                    connect_vertex.cost = cost_other\n                    self._graph.add_edge(parent_other, connect_vertex)\n                    if connect_vertex not in other_tree_vertices:\n                        other_tree_vertices.append(connect_vertex)\n\n                    # Check if the connect_vertex reached the previously nearest_other exactly - trees connected\n                    if connect_vertex.position == nearest_other.position:\n                        # Extract full path by joining at new_vertex and connect_vertex\n                        full_path = self._extract_path(new_vertex, connect_vertex)\n\n                        # Calculate full path cost (sum of vertex costs)\n                        path_cost = full_path[-1].cost if full_path[-1].cost is not None else float('inf')\n                        if path_cost < best_cost:\n                            best_cost = path_cost\n                            best_path = full_path\n\n                        # Post-process: Path smoothing shortcut\n                        best_path = self._shortcut_path(best_path)\n\n                        # Visualize path\n                        for v in best_path:\n                            self.move_agent(v.position)\n                            self.key_frame(ignore_key_frame_skip=True)\n                        return\n\n                    else:\n                        # Try to extend connection towards nearest_other to connect trees fully\n                        extend_vertex = connect_vertex\n                        extended = True\n                        while extended:\n                            extended = False\n                            next_point = self._steer(extend_vertex, nearest_other.position, self._max_dist)\n                            if next_point == extend_vertex.position:\n                                break\n                            if self._line_is_valid(extend_vertex.position, next_point):\n                                near_ext = self._graph.get_vertices_within_radius([other_root_vertex], next_point, radius)\n                                parent_ext, cost_ext = self._choose_best_parent(next_point, near_ext)\n                                if parent_ext is None:\n                                    break\n                                next_vertex = Vertex(next_point, store_connectivity=True)\n                                next_vertex.cost = cost_ext\n                                self._graph.add_edge(parent_ext, next_vertex)\n                                if next_vertex not in other_tree_vertices:\n                                    other_tree_vertices.append(next_vertex)\n                                extend_vertex = next_vertex\n                                extended = True\n\n                                if extend_vertex.position == nearest_other.position:\n                                    full_path = self._extract_path(new_vertex, extend_vertex)\n                                    path_cost = full_path[-1].cost if full_path[-1].cost is not None else float('inf')\n                                    if path_cost < best_cost:\n                                        best_cost = path_cost\n                                        best_path = full_path\n                                    best_path = self._shortcut_path(best_path)\n                                    for v in best_path:\n                                        self.move_agent(v.position)\n                                        self.key_frame(ignore_key_frame_skip=True)\n                                    return\n\n            # Keyframe for animation but allow skipping for speed\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 63, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "m3",
     "algorithm": "This algorithm is an improved sample-based planner combining adaptive informed sampling and anytime iterative path refinement.\n    It builds a forest like RRT*, focusing sample efforts in ellipsoidal informed subsets defined by the current best cost to minimize unnecessary exploration.\n    The algorithm performs dynamic rewiring with cost+heuristic parent selection, and integrates progressive path shortcut smoothing during planning.\n    Timeout handling ensures graceful failure beyond 60 seconds.\n    This approach improves planning efficiency, path quality, smoothness, robustness, and success rate while reducing search time and path lengths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: float  # Removed Optional from typing\n    _best_goal_vertex: Vertex  # Removed Optional from typing\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._dimension = self._get_grid().size.n_dim\n        max_map_dim = max(self._get_grid().size.values)\n        self._max_dist = max_map_dim / 10.0\n        self._lambda_rrt_star = 35.0\n        self._max_radius = max_map_dim / 3\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._start_time = 0.0\n        self._timeout = 60.0\n        self._best_cost = float('inf')  # Initialize to infinity instead of None\n        self._best_goal_vertex = None  # Still None, since no best goal yet\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _uniform_sample(self) -> Point:\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            pt = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(pt):\n                return pt\n\n    def _ellipsoidal_sample(self) -> Point:\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        c_best = torch.tensor(self._best_cost)\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best < c_min:\n            c_best = c_min + 1e-6\n        center = (start + goal) / 2.0\n        foci_vec = (goal - start)\n        e_axis = foci_vec / torch.norm(foci_vec)\n\n        if self._dimension == 2:\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])\n        elif self._dimension == 3:\n            z_axis = e_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n        else:\n            return self._uniform_sample()\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0\n\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        elif self._dimension == 3:\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n        else:\n            return self._uniform_sample()\n\n        for _ in range(20):  # limit retries\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u < 1e-6:\n                continue\n            unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n            sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n            sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, self._get_grid().size[i] - 1).round())) for i in range(self._dimension)]\n            sample_point = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n        return self._uniform_sample()\n\n    def _informed_sample(self) -> Point:\n        if self._best_cost == float('inf'):\n            return self._uniform_sample()\n        return self._ellipsoidal_sample()\n\n    def _calc_rewire_radius(self) -> float:\n        n = float(self._graph.size + 1)\n        radius = self._lambda_rrt_star * ((torch.log(torch.tensor(n)) / n) ** (1.0 / self._dimension))\n        return min(radius.item(), self._max_radius)\n\n    def _choose_parent(self, neighbors: list[Vertex], q_new: Vertex) -> tuple[Vertex | None, float]:\n        c_min = float('inf')\n        q_min = None\n        for q_near in neighbors:\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = q_near.cost + self._dist(q_near.position, q_new.position)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n        return q_min, c_min\n\n    def _shortcut_path(self, path: list[Vertex], max_attempts: int = 40) -> list[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts and len(new_path) >= 3:\n            attempts += 1\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i, p_j = new_path[i].position, new_path[j].position\n            line_seq = self._get_grid().get_line_sequence(p_i, p_j)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = min(current.parents, key=lambda v: v.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n        path = self._shortcut_path(path, max_attempts=50)\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_coords = [int(round(float(c))) for c in new_pos_tensor]\n        new_point = Point(*new_coords)\n        return Vertex(new_point)\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n        max_iterations = 20000\n        radius = self._calc_rewire_radius()\n\n        for iteration in range(max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Timeout: path search failed\n                return\n\n            q_sample = self._informed_sample()\n\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors through q_new\n            for q_near in neighbors:\n                if q_near is q_min:\n                    continue\n                line_seq_back = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_back):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                if cost_through_new + 1e-8 < q_near.cost:\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if q_new reaches goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if (self._best_cost is None) or (possible_cost < self._best_cost):\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 137, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "m1",
     "algorithm": "Improved Adaptive Informed RRT* with multi-strategy sampling,\n    dynamic rewiring radius, path smoothing via advanced shortcutting,\n    and fail-safe timeout logic.\n    This algorithm synergizes uniform sampling, ellipsoidal informed sampling,\n    and focused local exploration to balance exploration and exploitation.\n    It adaptively adjusts rewiring radius and reuses partial paths to improve\n    path quality and smoothness, ensuring higher success rate and robustness\n    in diverse map sizes and obstacle configurations.\n    Failure to find a path within 60 seconds results in an explicit search fail.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: float  # Removed '| None' for compatibility\n    _best_goal_vertex: Vertex  # Removed '| None' for compatibility\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        grid = self._get_grid()\n        self._dimension = grid.size.n_dim\n        max_map_dim = max(grid.size.values)\n        self._max_dist = max_map_dim / 12.0  # max movement distance step\n        self._lambda_rrt_star = 45.0  # constant for adaptive radius calc\n        self._max_radius = max_map_dim / 2.5  # rewiring max radius\n\n        start_vertex = Vertex(grid.agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(grid.goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        self._start_time = 0.0\n        self._timeout = 60.0\n        self._best_cost = None\n        self._best_goal_vertex = None\n\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _uniform_sample(self) -> Point:\n        grid = self._get_grid()\n        while True:\n            coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _ellipsoidal_sample(self) -> Point:\n        grid = self._get_grid()\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        c_best = torch.tensor(self._best_cost) if self._best_cost is not None else None\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best is None or c_best < c_min:\n            return self._uniform_sample()\n\n        center = (start + goal) / 2.0\n        foci_vec = goal - start\n        e_axis = foci_vec / torch.norm(foci_vec)\n\n        if self._dimension == 2:\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])\n        elif self._dimension == 3:\n            z_axis = e_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n        else:\n            return self._uniform_sample()\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0\n\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        elif self._dimension == 3:\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n        else:\n            return self._uniform_sample()\n\n        while True:\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u > 1e-6:\n                break\n        unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n\n        sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n        sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, grid.size[i] - 1).round())) for i in range(self._dimension)]\n        sample_point = Point(*sample_coords)\n\n        if grid.is_agent_valid_pos(sample_point):\n            return sample_point\n        return self._uniform_sample()\n\n    def _adaptive_sample(self) -> Point:\n        # Use multi-strategy sampling:\n        # 60% informed ellipsoid if best_cost known,\n        # else uniform,\n        # 20% local sampling around root path if best available,\n        # 20% pure uniform exploration.\n        import random\n        if self._best_cost is None:\n            return self._uniform_sample()\n\n        choice = random.random()\n        if choice < 0.6:\n            return self._ellipsoidal_sample()\n        elif choice < 0.8 and self._best_goal_vertex is not None:\n            # Local sampling near current best path vertices, bias exploration near existing paths\n            near_verts = self._graph.get_vertices_within_radius(\n                self._graph.root_vertices, self._best_goal_vertex.position, self._max_dist * 5)\n            if near_verts:\n                from random import choice as rchoice\n                base_vertex = rchoice(near_verts)\n                perturb = [int(round(torch.randn(1).item() * self._max_dist / 2)) for _ in range(self._dimension)]\n                sample_coords = [max(0, min(self._get_grid().size[i] - 1, base_vertex.position[i] + perturb[i])) for i in range(self._dimension)]\n                sample_point = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample_point):\n                    return sample_point\n            return self._uniform_sample()\n        else:\n            return self._uniform_sample()\n\n    def _calc_rewire_radius(self) -> float:\n        card_v = torch.tensor(float(self._graph.size + 1))\n        log_card_v = torch.log(card_v)\n        radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1.0 / self._dimension)), self._max_radius)\n        # decrease radius progressively with better cost found to improve rewiring locality\n        if self._best_cost is not None:\n            improvement_factor = max(0.2, min(1.0, self._best_cost / (self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position) * 2)))\n            radius *= improvement_factor\n        return radius.item()\n\n    def _choose_parent(self, neighbors: list[Vertex], q_new: Vertex) -> tuple[Vertex | None, float]:\n        c_min = float('inf')\n        q_min = None\n        grid = self._get_grid()\n\n        def est_cost_to_goal(pos: Point) -> float:\n            return self._dist(pos, self._graph.root_vertex_goal.position)\n\n        for q_near in neighbors:\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost = q_near.cost + self._dist(q_near.position, q_new.position) + est_cost_to_goal(q_new.position)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n        if q_min is None:\n            return None, float('inf')\n        # Return cost without heuristic for actual cost accounting\n        cost_no_heuristic = q_min.cost + self._dist(q_min.position, q_new.position)\n        return q_min, cost_no_heuristic\n\n    def _shortcut_path(self, path: list[Vertex], max_attempts=50) -> list[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        grid = self._get_grid()\n        attempt = 0\n        while attempt < max_attempts and len(new_path) >= 3:\n            attempt += 1\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = grid.get_line_sequence(p_i, p_j)\n            if grid.is_valid_line_sequence(line_seq):\n                # Remove intermediates between i and j\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        grid = self._get_grid()\n        # Clamp and round inside grid\n        new_pos_coords = [int(round(float(torch.clamp(new_pos_tensor[i], 0, grid.size[i] - 1)))) for i in range(self._dimension)]\n        return Vertex(Point(*new_pos_coords))\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n\n        max_iterations = 20000\n        grid = self._get_grid()\n\n        for iteration in range(max_iterations):\n            # Timeout check\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Failed to find path within time\n                return\n\n            q_sample = self._adaptive_sample()\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            radius = self._calc_rewire_radius()\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                # fallback connect to nearest\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_rev = grid.get_line_sequence(q_new.position, q_near.position)\n                if not grid.is_valid_line_sequence(line_seq_rev):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                if cost_through_new < q_near.cost:\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if self._best_cost is None or possible_cost < self._best_cost:\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 175, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "e1",
     "algorithm": "Improved Path Planning Algorithm Using Adaptive Guided RRT* with Dynamic Rewiring and Heuristic Pruning.\n      \n      This algorithm enhances path planning by combining multiple improvements:\n      - Adaptive sampling bias that shifts progressively from uniform random to goal- and best-path-informed.\n      - Uses an incremental RRT*-style rewiring for path cost optimization.\n      - Dynamic neighborhood radius shrinks as tree size grows to balance exploration and exploitation.\n      - Heuristic pruning of samples unlikely to improve current best path cost to speed convergence.\n      - Early stopping upon finding a path or reaching a 60-second timeout.\n      - Path smoothing via shortcutting after path extraction.\n      \n      This approach targets improved planning efficiency, better path quality and smoothness,\n      higher success rates with robust collision checking, and reduced overall search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    # Constants: Tunable parameters for performance\n    _max_dist: float\n    _max_iterations: int\n    _timeout_sec: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 15.0\n        self._max_iterations = 15000\n        self._timeout_sec = 60.0\n\n        # Initialize cyclic graph with start and goal vertices and allow rewiring for RRT*\n        self._graph = gen_cyclic_graph(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_adaptive_sample(self, best_path, iteration):  # Removed type hints to fix error\n        grid = self._get_grid()\n        dim = grid.size.n_dim\n        max_dims = np.array(grid.size.values) - 1\n\n        # As iterations increase, increase bias towards goal and best path\n        bias_goal_prob = min(0.4 + iteration / self._max_iterations * 0.4, 0.8)\n        bias_path_prob = min(0.15 + iteration / self._max_iterations * 0.25, 0.4)\n        rand_val = np.random.rand()\n\n        if best_path and len(best_path) > 2:\n            if rand_val < bias_path_prob:\n                # Sample near random vertex on best path with small Gaussian noise\n                for _ in range(20):\n                    path_v = best_path[np.random.randint(0, len(best_path))]\n                    center = path_v.position.to_tensor().numpy()\n                    radius = max(self._max_dist * 0.5, 5)\n                    offset = np.random.normal(0, radius/2, dim)\n                    sample_pos = center + offset\n                    sample_pos = np.clip(sample_pos, 0, max_dims)\n                    sample_point = Point(*sample_pos.astype(int))\n                    if grid.is_agent_valid_pos(sample_point):\n                        return sample_point\n\n            if rand_val < bias_goal_prob:\n                # Sample near goal within max_dist radius with uniform random in sphere\n                goal_tensor = grid.goal.position.to_tensor().numpy()\n                radius = self._max_dist * 1.5\n                for _ in range(20):\n                    offset = np.random.uniform(-radius, radius, dim)\n                    sample_pos = goal_tensor + offset\n                    sample_pos = np.clip(sample_pos, 0, max_dims)\n                    sample_point = Point(*sample_pos.astype(int))\n                    if grid.is_agent_valid_pos(sample_point):\n                        return sample_point\n\n        # Uniform random sampling if no bias selected\n        for _ in range(50):\n            coords = np.random.randint(0, max_dims + 1, dim)\n            sample_point = Point(*coords)\n            if grid.is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # fallback to agent position if no valid sample found\n        return grid.agent.position\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_dist: float) -> Point:\n        from_tensor = from_vertex.position.to_tensor()\n        to_tensor = to_point.to_tensor()\n        direction = to_tensor - from_tensor\n        distance = torch.norm(direction)\n        if distance <= max_dist:\n            return to_point\n        direction = direction / distance\n        new_pos_tensor = from_tensor + max_dist * direction\n        new_point = Point(*new_pos_tensor.round().int().tolist())\n        return new_point\n\n    def _line_is_valid(self, frm: Point, to: Point) -> bool:\n        grid = self._get_grid()\n        line_seq = grid.get_line_sequence(frm, to)\n        return grid.is_valid_line_sequence(line_seq)\n\n    def _choose_best_parent(self, new_pos: Point, near_vertices):\n        grid = self._get_grid()\n        best_parent = None\n        best_cost = float(\"inf\")\n        for v in near_vertices:\n            if self._line_is_valid(v.position, new_pos):\n                current_cost = (v.cost if v.cost is not None else 0.0) + grid.get_movement_cost(v.position, new_pos)\n                if current_cost < best_cost:\n                    best_cost = current_cost\n                    best_parent = v\n        return best_parent, best_cost\n\n    def _rewire_near_vertices(self, new_vertex: Vertex, near_vertices) -> None:\n        grid = self._get_grid()\n        for near_v in near_vertices:\n            if near_v == new_vertex or near_v in new_vertex.parents:\n                continue\n            if self._line_is_valid(new_vertex.position, near_v.position):\n                cost_through_new = new_vertex.cost + grid.get_movement_cost(new_vertex.position, near_v.position)\n                if near_v.cost is None or cost_through_new < near_v.cost:\n                    # Remove all old parent edges\n                    for p in near_v.parents.copy():\n                        self._graph.remove_edge(p, near_v)\n                    self._graph.add_edge(new_vertex, near_v)\n                    near_v.cost = cost_through_new\n\n    def _get_neighborhood_radius(self, n_vertices: int) -> float:\n        # Adaptive radius: shrinks with number of vertices as RRT* suggests\n        # radius = gamma * (log(n)/n)^(1/d), gamma chosen proportional to max_dist\n        import math\n        gamma = self._max_dist * 2.0\n        d = self._get_grid().size.n_dim\n        if n_vertices <= 1:\n            return self._max_dist * 2\n        radius = gamma * (math.log(n_vertices) / n_vertices) ** (1 / d)\n        radius = min(radius, self._max_dist * 2)\n        return radius\n\n    def _extract_path(self, connecting_start: Vertex, connecting_goal: Vertex) -> list[Vertex]:\n        # Trace parents from connecting start vertex to root start\n        path_from_start = []\n        curr = connecting_start\n        while curr.parents:\n            path_from_start.append(curr)\n            curr = next(iter(curr.parents))\n        path_from_start.append(curr)  # add root\n        path_from_start.reverse()\n\n        # Trace parents from connecting goal vertex to root goal\n        path_from_goal = []\n        curr = connecting_goal\n        while curr.parents:\n            path_from_goal.append(curr)\n            curr = next(iter(curr.parents))\n        path_from_goal.append(curr)  # root\n\n        # Concatenate start path with reversed goal path (excluding duplicate connecting vertex)\n        full_path = path_from_start + path_from_goal[::-1][1:]\n\n        return full_path\n\n    def _shortcut_path(self, path: list[Vertex]) -> list[Vertex]:\n        \"\"\"\n        Path smoothing by shortcutting non-collision edges between path vertices.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        optimized_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            # Try to find the farthest vertex reachable from optimized_path[-1] without collisions\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_is_valid(optimized_path[-1].position, path[j].position):\n                    break\n                j -= 1\n            optimized_path.append(path[j])\n            i = j\n        return optimized_path\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        tree_start_vertices = [start_vertex]\n        tree_goal_vertices = [goal_vertex]\n\n        best_path = None\n        best_cost = float('inf')\n\n        start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout_sec:\n                # Timeout reached - path planning failed\n                break\n\n            # Alternate tree expansion (start tree first, then goal tree)\n            for (root_vertex, tree_vertices, other_root_vertex, other_tree_vertices) in [\n                (start_vertex, tree_start_vertices, goal_vertex, tree_goal_vertices),\n                (goal_vertex, tree_goal_vertices, start_vertex, tree_start_vertices),\n            ]:\n                # Sample adaptively biased to best path and goal\n                sample_point = self._get_adaptive_sample(best_path, iteration)\n\n                # Find nearest vertex in current tree to sample\n                nearest_vertex = self._graph.get_nearest_vertex([root_vertex], sample_point)\n\n                # Steer from nearest vertex toward sample within max_dist\n                new_point = self._steer(nearest_vertex, sample_point, self._max_dist)\n\n                # Check for collision on path from nearest_vertex to new_point\n                if not self._line_is_valid(nearest_vertex.position, new_point):\n                    continue\n\n                # Determine adaptive neighborhood radius for rewiring and parent choosing\n                radius = self._get_neighborhood_radius(len(tree_vertices))\n\n                # Find near vertices for connection and rewiring\n                near_vertices = self._graph.get_vertices_within_radius([root_vertex], new_point, radius)\n\n                # Choose best parent with minimal cost + collision-free edge\n                best_parent, cost_to_new = self._choose_best_parent(new_point, near_vertices)\n                if best_parent is None:\n                    continue\n\n                # Add new vertex and connect to best parent\n                new_vertex = Vertex(new_point, store_connectivity=True)\n                new_vertex.cost = cost_to_new\n                self._graph.add_edge(best_parent, new_vertex)\n                tree_vertices.append(new_vertex)\n\n                # Rewire near vertices through new_vertex if it improves cost\n                self._rewire_near_vertices(new_vertex, near_vertices)\n\n                # Attempt to connect new_vertex to the other tree\n                nearest_other = self._graph.get_nearest_vertex([other_root_vertex], new_point)\n                connect_point = self._steer(new_vertex, nearest_other.position, self._max_dist)\n\n                if connect_point == new_vertex.position:\n                    # No progress toward other tree\n                    continue\n\n                if self._line_is_valid(new_vertex.position, connect_point):\n                    near_others = self._graph.get_vertices_within_radius([other_root_vertex], connect_point, radius)\n                    \n                    parent_other, cost_other = self._choose_best_parent(connect_point, near_others)\n                    if parent_other is None:\n                        continue\n\n                    connect_vertex = Vertex(connect_point, store_connectivity=True)\n                    connect_vertex.cost = cost_other\n                    self._graph.add_edge(parent_other, connect_vertex)\n                    if connect_vertex not in other_tree_vertices:\n                        other_tree_vertices.append(connect_vertex)\n\n                    # Check if the connect_vertex reached the previously nearest_other exactly - trees connected\n                    if connect_vertex.position == nearest_other.position:\n                        # Extract full path by joining at new_vertex and connect_vertex\n                        full_path = self._extract_path(new_vertex, connect_vertex)\n\n                        # Calculate full path cost (sum of vertex costs)\n                        path_cost = full_path[-1].cost if full_path[-1].cost is not None else float('inf')\n                        if path_cost < best_cost:\n                            best_cost = path_cost\n                            best_path = full_path\n\n                        # Post-process: Path smoothing shortcut\n                        best_path = self._shortcut_path(best_path)\n\n                        # Visualize path\n                        for v in best_path:\n                            self.move_agent(v.position)\n                            self.key_frame(ignore_key_frame_skip=True)\n                        return\n\n                    else:\n                        # Try to extend connection towards nearest_other to connect trees fully\n                        extend_vertex = connect_vertex\n                        extended = True\n                        while extended:\n                            extended = False\n                            next_point = self._steer(extend_vertex, nearest_other.position, self._max_dist)\n                            if next_point == extend_vertex.position:\n                                break\n                            if self._line_is_valid(extend_vertex.position, next_point):\n                                near_ext = self._graph.get_vertices_within_radius([other_root_vertex], next_point, radius)\n                                parent_ext, cost_ext = self._choose_best_parent(next_point, near_ext)\n                                if parent_ext is None:\n                                    break\n                                next_vertex = Vertex(next_point, store_connectivity=True)\n                                next_vertex.cost = cost_ext\n                                self._graph.add_edge(parent_ext, next_vertex)\n                                if next_vertex not in other_tree_vertices:\n                                    other_tree_vertices.append(next_vertex)\n                                extend_vertex = next_vertex\n                                extended = True\n\n                                if extend_vertex.position == nearest_other.position:\n                                    full_path = self._extract_path(new_vertex, extend_vertex)\n                                    path_cost = full_path[-1].cost if full_path[-1].cost is not None else float('inf')\n                                    if path_cost < best_cost:\n                                        best_cost = path_cost\n                                        best_path = full_path\n                                    best_path = self._shortcut_path(best_path)\n                                    for v in best_path:\n                                        self.move_agent(v.position)\n                                        self.key_frame(ignore_key_frame_skip=True)\n                                    return\n\n            # Keyframe for animation but allow skipping for speed\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 164, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "e2",
     "algorithm": "Improved dual-tree hybrid sampling-based path planner combining RRT*, RRT-Connect, and Informed RRT* techniques.\n    Features include adaptive heuristic sampling biased around the current best path and goal region,\n    bidirectional tree expansion with informed rewiring, dynamic max distance adjustment based on progress,\n    and enhanced connection attempts with partial shortcutting for path smoothing.\n    Early stopping is employed on success or after 60s timeout.\n    This approach improves planning efficiency, path quality/smoothness, success rate, and reduces search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _timeout: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_cyclic_graph(self._services, \n                                       Vertex(self._get_grid().agent.position), \n                                       Vertex(self._get_grid().goal.position), \n                                       [])\n        self._graph.edges_removable = True  # Allow rewiring for improving path quality\n        self._max_dist = 12.0\n        self._iterations = 15000\n        self._timeout = 60.0  # seconds\n        self._init_displays()\n\n    def _get_random_sample(self, best_path: list[Vertex] | None = None) -> Point:\n        grid = self._get_grid()\n        rand_val = np.random.rand()\n\n        def sample_near_point(center: Point, radius: float, attempts: int = 20) -> Point | None:\n            for _ in range(attempts):\n                offset = np.random.uniform(-radius, radius, grid.size.n_dim)\n                sample_coords = center.to_tensor().numpy() + offset\n                sample_coords = np.clip(sample_coords, 0, np.array(grid.size.values) - 1)\n                sample_point = Point(*sample_coords.astype(int))\n                if grid.is_agent_valid_pos(sample_point):\n                    return sample_point\n            return None\n\n        # Prioritized heuristic sampling:\n        if best_path and len(best_path) > 2:\n            if rand_val > 0.85:\n                # Sample near random vertex on current best path (local refinement)\n                for _ in range(15):\n                    path_vertex = best_path[np.random.randint(0, len(best_path))]\n                    radius = self._max_dist * 1.25\n                    sample_point = sample_near_point(path_vertex.position, radius, 1)\n                    if sample_point is not None:\n                        return sample_point\n\n            if rand_val > 0.65:\n                # Sample biased near the goal within radius max_dist*2\n                sample_point = sample_near_point(grid.goal.position, self._max_dist * 2, 20)\n                if sample_point is not None:\n                    return sample_point\n\n        # Uniform random sampling fallback (~70%)\n        att = 0\n        while att < 60:\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n            att += 1\n        # If no valid sampled point found, fallback to agent's current position\n        return grid.agent.position\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_tensor)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_tensor / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _line_is_valid(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _get_vertices_near(self, root_vertices: list[Vertex], point: Point, radius: float) -> list[Vertex]:\n        return self._graph.get_vertices_within_radius(root_vertices, point, radius)\n\n    def _choose_parent(self, new_vertex: Vertex, near_vertices: list[Vertex]) -> Vertex | None:\n        # Choose best parent minimizing cost + edge cost with valid line\n        min_cost = float(\"inf\")\n        best_parent = None\n        grid = self._get_grid()\n        for vertex in near_vertices:\n            if self._line_is_valid(vertex.position, new_vertex.position):\n                parent_cost = vertex.cost if vertex.cost is not None else 0.0\n                edge_cost = grid.get_movement_cost(vertex.position, new_vertex.position)\n                total_cost = parent_cost + edge_cost\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_parent = vertex\n        if best_parent:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: list[Vertex]) -> None:\n        grid = self._get_grid()\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex or near_vertex in new_vertex.parents:\n                continue\n            if self._line_is_valid(new_vertex.position, near_vertex.position):\n                cost_through_new = new_vertex.cost + grid.get_movement_cost(new_vertex.position, near_vertex.position)\n                if near_vertex.cost is None or cost_through_new < near_vertex.cost:\n                    # Remove all old parents' edges\n                    for p in near_vertex.parents.copy():\n                        self._graph.remove_edge(p, near_vertex)\n                    # Add new edge from new_vertex to near_vertex with better cost\n                    self._graph.add_edge(new_vertex, near_vertex)\n                    near_vertex.cost = cost_through_new\n\n    def _try_shortcut(self, path: list[Vertex]) -> list[Vertex]:\n        # Attempt partial shortcut smoothing by removing intermediate nodes where direct connection is valid\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_is_valid(smoothed[-1].position, path[j].position):\n                    smoothed.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found, append next in path\n                smoothed.append(path[i + 1])\n                i += 1\n        return smoothed\n\n    def _extract_path(self, connecting_vertex_start: Vertex, connecting_vertex_goal: Vertex) -> list[Vertex]:\n        # Traverse parents up to roots\n        def backtrace(vertex: Vertex) -> list[Vertex]:\n            path = [vertex]\n            while vertex.parents:\n                # Select best parent (lowest cost)\n                vertex = min(vertex.parents, key=lambda p: p.cost if p.cost is not None else float(\"inf\"))\n                path.append(vertex)\n            path.reverse()\n            return path\n\n        start_path = backtrace(connecting_vertex_start)\n        goal_path = backtrace(connecting_vertex_goal)\n\n        full_path = start_path + goal_path\n\n        # Apply smoothing shortcut to reduce unnecessary waypoints\n        full_path = self._try_shortcut(full_path)\n\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n        return full_path\n\n    def _get_adaptive_max_dist(self, iteration: int, total_iterations: int) -> float:\n        # Starts small and increases max_dist gradually to favor exploration early and faster expansion later\n        base = 5.0\n        max_distance = self._max_dist\n        factor = iteration / total_iterations\n        adaptive_dist = base + factor * (max_distance - base)\n        return adaptive_dist\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n\n        best_path: list[Vertex] | None = None\n        best_cost = float(\"inf\")\n\n        start_time = time.time()\n\n        # Parameters\n        reconnect_radius_factor = 2.0\n        shortcut_attempt_interval = 200  # iterations\n\n        for iteration in range(self._iterations):\n            if (time.time() - start_time) > self._timeout:\n                # Fail after timeout\n                break\n\n            adaptive_max_dist = self._get_adaptive_max_dist(iteration, self._iterations)\n            radius = max(adaptive_max_dist * reconnect_radius_factor, 15.0)\n\n            # Alternate tree expansion: first start tree, then goal tree\n            tree_pairs = [\n                (self._graph.root_vertex_start, tree_start, self._graph.root_vertex_goal, tree_goal),\n                (self._graph.root_vertex_goal, tree_goal, self._graph.root_vertex_start, tree_start)\n            ]\n\n            for tree_roots, tree_vertices, other_roots, other_vertices in tree_pairs:\n                q_rand = self._get_random_sample(best_path)\n                q_near = self._graph.get_nearest_vertex([tree_roots], q_rand)\n\n                q_new = self._get_new_vertex(q_near, q_rand, adaptive_max_dist)\n\n                if not self._line_is_valid(q_near.position, q_new.position):\n                    continue\n\n                near_vertices = self._get_vertices_near([tree_roots], q_new.position, radius)\n                parent = self._choose_parent(q_new, near_vertices)\n                if parent is None:\n                    continue\n\n                self._graph.add_edge(parent, q_new)\n                tree_vertices.append(q_new)\n\n                self._rewire(q_new, near_vertices)\n\n                q_near_other = self._graph.get_nearest_vertex([other_roots], q_new.position)\n                q_connect = self._get_new_vertex(q_new, q_near_other.position, adaptive_max_dist)\n\n                if self._line_is_valid(q_new.position, q_connect.position):\n                    near_others = self._get_vertices_near([other_roots], q_connect.position, radius)\n                    parent_other = self._choose_parent(q_connect, near_others)\n                    if parent_other is not None:\n                        self._graph.add_edge(parent_other, q_connect)\n                        if q_connect not in other_vertices:\n                            other_vertices.append(q_connect)\n\n                        # If trees connected directly\n                        if q_connect.position == q_near_other.position:\n                            # Extract and display path\n                            path = self._extract_path(q_new, q_connect)\n                            final_cost = path[-1].cost if path[-1].cost is not None else float(\"inf\")\n                            if final_cost < best_cost:\n                                best_cost = final_cost\n                                best_path = path\n                            # Success: done planning\n                            return\n                        else:\n                            # Attempt extended connection in other tree (multi-step connect)\n                            current_vertex = q_connect\n                            extended = True\n                            while extended:\n                                q_extend = self._get_new_vertex(current_vertex, q_near_other.position, adaptive_max_dist)\n                                if q_extend.position == current_vertex.position:\n                                    break\n                                if self._line_is_valid(current_vertex.position, q_extend.position):\n                                    near_extend = self._get_vertices_near([other_roots], q_extend.position, radius)\n                                    parent_extend = self._choose_parent(q_extend, near_extend)\n                                    if parent_extend is None:\n                                        break\n                                    self._graph.add_edge(parent_extend, q_extend)\n                                    if q_extend not in other_vertices:\n                                        other_vertices.append(q_extend)\n                                    # Partial shortcut: try connecting current_vertex directly to q_extend's parent of best cost if shorter than two edges\n                                    if len(near_extend) > 1:\n                                        for nv in near_extend:\n                                            if nv != parent_extend and self._line_is_valid(current_vertex.position, nv.position):\n                                                cost_via_nv = (current_vertex.cost if current_vertex.cost else 0.0) + \\\n                                                              grid.get_movement_cost(current_vertex.position, nv.position)\n                                                if nv.cost is not None and cost_via_nv + grid.get_movement_cost(nv.position, q_extend.position) < q_extend.cost:\n                                                    # Rewire q_extend to nv for shortcut\n                                                    for p in q_extend.parents.copy():\n                                                        self._graph.remove_edge(p, q_extend)\n                                                    self._graph.add_edge(nv, q_extend)\n                                                    q_extend.cost = cost_via_nv + grid.get_movement_cost(nv.position, q_extend.position)\n                                    current_vertex = q_extend\n                                    if q_extend.position == q_near_other.position:\n                                        path = self._extract_path(q_new, q_extend)\n                                        final_cost = path[-1].cost if path[-1].cost is not None else float(\"inf\")\n                                        if final_cost < best_cost:\n                                            best_cost = final_cost\n                                            best_path = path\n                                        return\n                                else:\n                                    extended = False\n\n            if iteration % shortcut_attempt_interval == 0 and best_path:\n                # Periodically attempt to shortcut smooth the best known path\n                best_path = self._try_shortcut(best_path)\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 59, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "m2",
     "algorithm": "Improved Adaptive Informed RRT* (AIRRT*) Algorithm with Dynamic Radius Tuning and Progressive Shortcutting",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: float | None\n    _best_goal_vertex: Vertex | None\n    _iteration_count: int\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._dimension = self._get_grid().size.n_dim\n        # Set max step length proportional to map size (reduce for tighter moves)\n        self._max_dist = float(max(self._get_grid().size.values)) / 12.0  \n        self._lambda_rrt_star = 35.0  # slightly tuned constant for radius\n        self._max_radius = max(self._get_grid().size.values) / 4.5  # smaller max radius to refine rewiring\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._start_time = 0.0\n        self._timeout = 60.0  # seconds\n        self._best_cost = None\n        self._best_goal_vertex = None\n        self._iteration_count = 0\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _adaptive_uniform_or_informed_sample(self) -> Point:\n        # Occasionally do uniform to preserve exploration (5% of samples)\n        import random\n        if (self._best_cost is None) or (random.random() < 0.05):\n            return self._uniform_sample()\n        return self._ellipsoidal_sample()\n\n    def _uniform_sample(self) -> Point:\n        attempts = 0\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n            if attempts > 100:\n                # fallback to start if stuck\n                return self._graph.root_vertex_start.position\n\n    def _ellipsoidal_sample(self) -> Point:\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        c_best = torch.tensor(self._best_cost)\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best < c_min:\n            c_best = c_min + 1e-3  # numerical safeguard\n\n        center = (start + goal) / 2.0\n        foci_vec = (goal - start)\n        e_axis = foci_vec / torch.norm(foci_vec)\n\n        if self._dimension == 2:\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])\n        elif self._dimension == 3:\n            z_axis = e_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n        else:\n            return self._uniform_sample()\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0\n\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        elif self._dimension == 3:\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n        else:\n            return self._uniform_sample()\n\n        for _ in range(5):  # try max 5 times to get valid sample in ellipsoid\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u < 1e-6:\n                continue\n            unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n            sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n            sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, self._get_grid().size[i] - 1).round())) for i in range(self._dimension)]\n            sample_point = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # fallback uniform\n        return self._uniform_sample()\n\n    def _calc_rewire_radius(self) -> float:\n        n = max(1, self._graph.size + 1)\n        r = self._lambda_rrt_star * ((torch.log(torch.tensor(float(n))).item() / n) ** (1.0 / self._dimension))\n        radius = min(r, self._max_radius)\n        # gradually shrink radius as iterations grow to encourage focus on local rewiring later\n        shrink_factor = max(0.3, 1.0 - (self._iteration_count / 12000))\n        return radius * shrink_factor\n\n    def _heuristic_cost(self, p: Point) -> float:\n        # Estimated cost to goal heuristically (Euclidean)\n        goal_pos = self._graph.root_vertex_goal.position\n        return self._dist(p, goal_pos)\n\n    def _choose_parent(self, neighbors: list[Vertex], q_new: Vertex) -> tuple[Vertex | None, float]:\n        c_min = float('inf')\n        q_min = None\n        for q_near in neighbors:\n            # Check collision-free connection\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            new_cost = q_near.cost + self._dist(q_near.position, q_new.position)\n            total_cost = new_cost + self._heuristic_cost(q_new.position)\n            # Pick minimal total cost with heuristic\n            if total_cost < c_min:\n                c_min = total_cost\n                q_min = q_near\n        if q_min is None:\n            return None, float('inf')\n        # Return parent and true cost without heuristic for path cost\n        actual_cost = q_min.cost + self._dist(q_min.position, q_new.position)\n        return q_min, actual_cost\n\n    def _shortcut_path(self, path: list[Vertex], max_attempts=30) -> list[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = self._get_grid().get_line_sequence(p_i, p_j)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # final smoothing before execute\n        path = self._shortcut_path(path, max_attempts=50)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*[int(round(float(c))) for c in new_pos_tensor])\n        return Vertex(new_pos)\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n        max_iterations = 15000\n\n        for iter_i in range(max_iterations):\n            self._iteration_count = iter_i\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Time exceeded, fail gracefully (no path found)\n                return\n\n            q_sample = self._adaptive_uniform_or_informed_sample()\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            radius = self._calc_rewire_radius()\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                # fallback connect nearest directly if no better parent\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Try rewiring neighbors through new vertex for better cost\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_rw = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_rw):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                if cost_through_new < q_near.cost:\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check goal reached with updated cost\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if (self._best_cost is None) or (possible_cost < self._best_cost):\n                    # Update best cost and connect goal vertex\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            # Progressive shortcut smoothing every 100 iterations for early path refinement\n            if (iter_i > 0) and (iter_i % 100 == 0) and self._best_goal_vertex is not None:\n                # Extract current path and smooth\n                current_path = []\n                cur = self._best_goal_vertex\n                while cur.parents:\n                    parent = min(cur.parents, key=lambda p: p.cost)\n                    current_path.append(cur)\n                    cur = parent\n                current_path.append(cur)\n                current_path.reverse()\n                smoothed = self._shortcut_path(current_path, max_attempts=15)\n                # Update positions with smoothed path visualization only\n                for vertex in smoothed:\n                    self.move_agent(vertex.position)\n                    self.key_frame(ignore_key_frame_skip=True)\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 49, in PathPlanning\nTypeError: unsupported operand type(s) for |: 'type' and 'NoneType'\n"
     }
}
{
     "operator": "e2",
     "algorithm": "Improved dual-tree hybrid sampling-based path planner combining RRT*, RRT-Connect, and Informed RRT* techniques.\n    Features include adaptive heuristic sampling biased around the current best path and goal region,\n    bidirectional tree expansion with informed rewiring, dynamic max distance adjustment based on progress,\n    and enhanced connection attempts with partial shortcutting for path smoothing.\n    Early stopping is employed on success or after 60s timeout.\n    This approach improves planning efficiency, path quality/smoothness, success rate, and reduces search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _timeout: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_cyclic_graph(self._services, \n                                       Vertex(self._get_grid().agent.position), \n                                       Vertex(self._get_grid().goal.position), \n                                       [])\n        self._graph.edges_removable = True  # Allow rewiring for improving path quality\n        self._max_dist = 12.0\n        self._iterations = 15000\n        self._timeout = 60.0  # seconds\n        self._init_displays()\n\n    def _get_random_sample(self, best_path=None) -> Point:\n        grid = self._get_grid()\n        rand_val = np.random.rand()\n\n        def sample_near_point(center: Point, radius: float, attempts: int = 20) -> Point | None:\n            for _ in range(attempts):\n                offset = np.random.uniform(-radius, radius, grid.size.n_dim)\n                sample_coords = center.to_tensor().numpy() + offset\n                sample_coords = np.clip(sample_coords, 0, np.array(grid.size.values) - 1)\n                sample_point = Point(*sample_coords.astype(int))\n                if grid.is_agent_valid_pos(sample_point):\n                    return sample_point\n            return None\n\n        # Prioritized heuristic sampling:\n        if best_path and len(best_path) > 2:\n            if rand_val > 0.85:\n                # Sample near random vertex on current best path (local refinement)\n                for _ in range(15):\n                    path_vertex = best_path[np.random.randint(0, len(best_path))]\n                    radius = self._max_dist * 1.25\n                    sample_point = sample_near_point(path_vertex.position, radius, 1)\n                    if sample_point is not None:\n                        return sample_point\n\n            if rand_val > 0.65:\n                # Sample biased near the goal within radius max_dist*2\n                sample_point = sample_near_point(grid.goal.position, self._max_dist * 2, 20)\n                if sample_point is not None:\n                    return sample_point\n\n        # Uniform random sampling fallback (~70%)\n        att = 0\n        while att < 60:\n            rand_pos = np.random.randint(0, grid.size.width, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n            att += 1\n        # If no valid sampled point found, fallback to agent's current position\n        return grid.agent.position\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_tensor)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_tensor / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*new_pos_tensor.tolist())\n        return Vertex(new_pos)\n\n    def _line_is_valid(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _get_vertices_near(self, root_vertices: list[Vertex], point: Point, radius: float) -> list[Vertex]:\n        return self._graph.get_vertices_within_radius(root_vertices, point, radius)\n\n    def _choose_parent(self, new_vertex: Vertex, near_vertices: list[Vertex]) -> Vertex | None:\n        # Choose best parent minimizing cost + edge cost with valid line\n        min_cost = float(\"inf\")\n        best_parent = None\n        grid = self._get_grid()\n        for vertex in near_vertices:\n            if self._line_is_valid(vertex.position, new_vertex.position):\n                parent_cost = vertex.cost if vertex.cost is not None else 0.0\n                edge_cost = grid.get_movement_cost(vertex.position, new_vertex.position)\n                total_cost = parent_cost + edge_cost\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_parent = vertex\n        if best_parent is not None:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: list[Vertex]) -> None:\n        grid = self._get_grid()\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex or near_vertex in new_vertex.parents:\n                continue\n            if self._line_is_valid(new_vertex.position, near_vertex.position):\n                cost_through_new = new_vertex.cost + grid.get_movement_cost(new_vertex.position, near_vertex.position)\n                if near_vertex.cost is None or cost_through_new < near_vertex.cost:\n                    # Remove all old parents' edges\n                    for p in near_vertex.parents.copy():\n                        self._graph.remove_edge(p, near_vertex)\n                    # Add new edge from new_vertex to near_vertex with better cost\n                    self._graph.add_edge(new_vertex, near_vertex)\n                    near_vertex.cost = cost_through_new\n\n    def _try_shortcut(self, path: list[Vertex]) -> list[Vertex]:\n        # Attempt partial shortcut smoothing by removing intermediate nodes where direct connection is valid\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_is_valid(smoothed[-1].position, path[j].position):\n                    smoothed.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found, append next in path\n                smoothed.append(path[i + 1])\n                i += 1\n        return smoothed\n\n    def _extract_path(self, connecting_vertex_start: Vertex, connecting_vertex_goal: Vertex) -> list[Vertex]:\n        # Traverse parents up to roots\n        def backtrace(vertex: Vertex) -> list[Vertex]:\n            path = [vertex]\n            while vertex.parents:\n                # Select best parent (lowest cost)\n                vertex = min(vertex.parents, key=lambda p: p.cost if p.cost is not None else float(\"inf\"))\n                path.append(vertex)\n            path.reverse()\n            return path\n\n        start_path = backtrace(connecting_vertex_start)\n        goal_path = backtrace(connecting_vertex_goal)\n\n        full_path = start_path + goal_path\n\n        # Apply smoothing shortcut to reduce unnecessary waypoints\n        full_path = self._try_shortcut(full_path)\n\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n        return full_path\n\n    def _get_adaptive_max_dist(self, iteration: int, total_iterations: int) -> float:\n        # Starts small and increases max_dist gradually to favor exploration early and faster expansion later\n        base = 5.0\n        max_distance = self._max_dist\n        factor = iteration / total_iterations\n        adaptive_dist = base + factor * (max_distance - base)\n        return adaptive_dist\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n\n        best_path = None\n        best_cost = float(\"inf\")\n\n        start_time = time.time()\n\n        # Parameters\n        reconnect_radius_factor = 2.0\n        shortcut_attempt_interval = 200  # iterations\n\n        for iteration in range(self._iterations):\n            if (time.time() - start_time) > self._timeout:\n                # Fail after timeout\n                break\n\n            adaptive_max_dist = self._get_adaptive_max_dist(iteration, self._iterations)\n            radius = max(adaptive_max_dist * reconnect_radius_factor, 15.0)\n\n            # Alternate tree expansion: first start tree, then goal tree\n            tree_pairs = [\n                (self._graph.root_vertex_start, tree_start, self._graph.root_vertex_goal, tree_goal),\n                (self._graph.root_vertex_goal, tree_goal, self._graph.root_vertex_start, tree_start)\n            ]\n\n            for tree_roots, tree_vertices, other_roots, other_vertices in tree_pairs:\n                q_rand = self._get_random_sample(best_path)\n                q_near = self._graph.get_nearest_vertex([tree_roots], q_rand)\n\n                q_new = self._get_new_vertex(q_near, q_rand, adaptive_max_dist)\n\n                if not self._line_is_valid(q_near.position, q_new.position):\n                    continue\n\n                near_vertices = self._get_vertices_near([tree_roots], q_new.position, radius)\n                parent = self._choose_parent(q_new, near_vertices)\n                if parent is None:\n                    continue\n\n                self._graph.add_edge(parent, q_new)\n                tree_vertices.append(q_new)\n\n                self._rewire(q_new, near_vertices)\n\n                q_near_other = self._graph.get_nearest_vertex([other_roots], q_new.position)\n                q_connect = self._get_new_vertex(q_new, q_near_other.position, adaptive_max_dist)\n\n                if self._line_is_valid(q_new.position, q_connect.position):\n                    near_others = self._get_vertices_near([other_roots], q_connect.position, radius)\n                    parent_other = self._choose_parent(q_connect, near_others)\n                    if parent_other is not None:\n                        self._graph.add_edge(parent_other, q_connect)\n                        if q_connect not in other_vertices:\n                            other_vertices.append(q_connect)\n\n                        # If trees connected directly\n                        if q_connect.position == q_near_other.position:\n                            # Extract and display path\n                            path = self._extract_path(q_new, q_connect)\n                            final_cost = path[-1].cost if path[-1].cost is not None else float(\"inf\")\n                            if final_cost < best_cost:\n                                best_cost = final_cost\n                                best_path = path\n                            # Success: done planning\n                            return\n                        else:\n                            # Attempt extended connection in other tree (multi-step connect)\n                            current_vertex = q_connect\n                            extended = True\n                            while extended:\n                                q_extend = self._get_new_vertex(current_vertex, q_near_other.position, adaptive_max_dist)\n                                if q_extend.position == current_vertex.position:\n                                    break\n                                if self._line_is_valid(current_vertex.position, q_extend.position):\n                                    near_extend = self._get_vertices_near([other_roots], q_extend.position, radius)\n                                    parent_extend = self._choose_parent(q_extend, near_extend)\n                                    if parent_extend is None:\n                                        break\n                                    self._graph.add_edge(parent_extend, q_extend)\n                                    if q_extend not in other_vertices:\n                                        other_vertices.append(q_extend)\n                                    # Partial shortcut: try connecting current_vertex directly to q_extend's parent of best cost if shorter than two edges\n                                    if len(near_extend) > 1:\n                                        for nv in near_extend:\n                                            if nv != parent_extend and self._line_is_valid(current_vertex.position, nv.position):\n                                                cost_via_nv = (current_vertex.cost if current_vertex.cost else 0.0) + \\\n                                                              grid.get_movement_cost(current_vertex.position, nv.position)\n                                                if nv.cost is not None and cost_via_nv + grid.get_movement_cost(nv.position, q_extend.position) < q_extend.cost:\n                                                    # Rewire q_extend to nv for shortcut\n                                                    for p in q_extend.parents.copy():\n                                                        self._graph.remove_edge(p, q_extend)\n                                                    self._graph.add_edge(nv, q_extend)\n                                                    q_extend.cost = cost_via_nv + grid.get_movement_cost(nv.position, q_extend.position)\n                                    current_vertex = q_extend\n                                    if q_extend.position == q_near_other.position:\n                                        path = self._extract_path(q_new, q_extend)\n                                        final_cost = path[-1].cost if path[-1].cost is not None else float(\"inf\")\n                                        if final_cost < best_cost:\n                                            best_cost = final_cost\n                                            best_path = path\n                                        return\n                                else:\n                                    extended = False\n\n            if iteration % shortcut_attempt_interval == 0 and best_path:\n                # Periodically attempt to shortcut smooth the best known path\n                best_path = self._try_shortcut(best_path)\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 115, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "m1",
     "algorithm": "This improved path planning algorithm advances over prior RRT* variants by integrating heuristic-driven informed sampling\n    within a dynamically adaptive ellipse region constrained by the current best path cost and distance metrics.\n    It further incorporates dynamic tuning of neighborhood radius for rewiring based on the evolving graph size,\n    enforcing collision-free rewiring to enhance path smoothness, reduce path lengths, and improve robustness.\n    A time constraint explicitly caps planning time to 60 seconds, marking failure beyond this limit.\n    The algorithm ensures high efficiency in exploration while biasing sampling towards promising goal regions,\n    promoting effective coverage and quicker convergence to high-quality paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_planning_time = 60  # seconds\n        self._init_displays()\n\n    def _informed_sample(self) -> Point:\n        start = self._graph.root_vertex_start.position\n        goal = self._graph.root_vertex_goal.position\n\n        def dist(a: Point, b: Point) -> float:\n            return torch.norm(a.to_tensor() - b.to_tensor()).item()\n\n        max_dist = dist(start, goal)\n        c_best = self._graph.root_vertex_goal.cost if self._graph.root_vertex_goal.cost is not None else max_dist * 1.5\n        c_min = max_dist\n\n        # Safety against invalid costs\n        if c_best is None or c_best == float('inf') or c_best < c_min:\n            c_best = c_min * 1.1\n\n        if torch.rand(1).item() < 0.05:  # 5% goal bias sampling\n            if self._get_grid().is_agent_valid_pos(goal):\n                return goal\n\n        # Ellipse parameters\n        center = (start.to_tensor() + goal.to_tensor()) / 2\n        a1 = goal.to_tensor() - start.to_tensor()\n        a1_norm = torch.norm(a1)\n        if a1_norm == 0:\n            a1_norm = 1.0\n        e1 = a1 / a1_norm\n\n        r1 = c_best / 2\n        ellipse_term = r1 ** 2 - (c_min / 2) ** 2\n        r2 = ellipse_term ** 0.5 if ellipse_term > 0 else r1 * 0.1\n\n        while True:\n            sample_unit = torch.rand(2) * 2 - 1\n            if sample_unit.norm() <= 1.0:\n                break\n\n        sample_ellipse = torch.zeros(2)\n        sample_ellipse[0] = sample_unit[0] * r1\n        sample_ellipse[1] = sample_unit[1] * r2\n\n        angle = torch.atan2(e1[1], e1[0])\n        rot_matrix = torch.tensor([[torch.cos(angle), -torch.sin(angle)],\n                                   [torch.sin(angle), torch.cos(angle)]])\n        sample_rotated = rot_matrix.matmul(sample_ellipse)\n        sample_point_tensor = center[:2] + sample_rotated\n\n        dims = self._get_grid().size.n_dim\n        coords = []\n        for i in range(dims):\n            dim_max = self._get_grid().size[i] - 1\n            if i < 2:\n                val = max(0, min(dim_max, float(sample_point_tensor[i])))\n            else:\n                val = torch.randint(0, dim_max + 1, (1,)).item()\n            coords.append(int(round(val)))\n\n        candidate = Point(*coords)\n        if self._get_grid().is_agent_valid_pos(candidate):\n            return candidate\n\n        # fallback uniform sampling if invalid\n        while True:\n            fallback_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(dims)]\n            fallback_sample = Point(*fallback_coords)\n            if self._get_grid().is_agent_valid_pos(fallback_sample):\n                return fallback_sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> list[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dir_norm\n        q_new_pos = q_near.position.to_tensor() + max_dist * dir_normalized\n        return Vertex(Point(*q_new_pos.tolist()))\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_vertex.position.to_tensor())\n        goal_vertex.cost = q_new.cost + dist_to_goal\n        self._graph.add_edge(q_new, goal_vertex)\n\n        path = [goal_vertex]\n        while path[-1].parents:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n\n        if path[-1] == self._graph.root_vertex_start:\n            path.pop()\n\n        path.reverse()\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist = 15.0\n        max_radius = 40.0\n        lambda_rrt_star = 35.0\n        dimension = self._get_grid().size.n_dim\n        max_iterations = 10000\n\n        from time import time\n        start_time = time()\n\n        for _ in range(max_iterations):\n            elapsed = time() - start_time\n            if elapsed > self._max_planning_time:\n                # Failed due to time limit\n                return\n\n            q_sample = self._informed_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cardinality = float(self._graph.size + 1)\n            log_card = max(1.0, torch.log(torch.tensor(cardinality)).item())\n            radius = min(lambda_rrt_star * ((log_card / cardinality) ** (1 / dimension)), max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent vertex with minimal cost + collision free edge\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                line_n2new = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_n2new):\n                    continue\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            dist_parent_to_new = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + dist_parent_to_new\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if better path is found and collision free\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                line_new2near = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_new2near):\n                    continue\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if cost_new_to_near < q_near.cost:\n                    old_parent = next(iter(q_near.parents), None)\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = None\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 123, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "m2",
     "algorithm": "Improved Adaptive Informed RRT* (AIRRT*) Algorithm with Dynamic Radius Tuning and Progressive Shortcutting",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: float  # removed union with None to avoid unsupported operand |\n    _best_goal_vertex: Vertex  # removed union with None to avoid unsupported operand |\n    _iteration_count: int\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._dimension = self._get_grid().size.n_dim\n        # Set max step length proportional to map size (reduce for tighter moves)\n        self._max_dist = float(max(self._get_grid().size.values)) / 12.0  \n        self._lambda_rrt_star = 35.0  # slightly tuned constant for radius\n        self._max_radius = max(self._get_grid().size.values) / 4.5  # smaller max radius to refine rewiring\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._start_time = 0.0\n        self._timeout = 60.0  # seconds\n        self._best_cost = None\n        self._best_goal_vertex = None\n        self._iteration_count = 0\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _adaptive_uniform_or_informed_sample(self) -> Point:\n        # Occasionally do uniform to preserve exploration (5% of samples)\n        import random\n        if (self._best_cost is None) or (random.random() < 0.05):\n            return self._uniform_sample()\n        return self._ellipsoidal_sample()\n\n    def _uniform_sample(self) -> Point:\n        attempts = 0\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n            if attempts > 100:\n                # fallback to start if stuck\n                return self._graph.root_vertex_start.position\n\n    def _ellipsoidal_sample(self) -> Point:\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        c_best = torch.tensor(self._best_cost)\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best < c_min:\n            c_best = c_min + 1e-3  # numerical safeguard\n\n        center = (start + goal) / 2.0\n        foci_vec = (goal - start)\n        e_axis = foci_vec / torch.norm(foci_vec)\n\n        if self._dimension == 2:\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])\n        elif self._dimension == 3:\n            z_axis = e_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n        else:\n            return self._uniform_sample()\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0\n\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        elif self._dimension == 3:\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n        else:\n            return self._uniform_sample()\n\n        for _ in range(5):  # try max 5 times to get valid sample in ellipsoid\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u < 1e-6:\n                continue\n            unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n            sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n            sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, self._get_grid().size[i] - 1).round())) for i in range(self._dimension)]\n            sample_point = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # fallback uniform\n        return self._uniform_sample()\n\n    def _calc_rewire_radius(self) -> float:\n        n = max(1, self._graph.size + 1)\n        r = self._lambda_rrt_star * ((torch.log(torch.tensor(float(n))).item() / n) ** (1.0 / self._dimension))\n        radius = min(r, self._max_radius)\n        # gradually shrink radius as iterations grow to encourage focus on local rewiring later\n        shrink_factor = max(0.3, 1.0 - (self._iteration_count / 12000))\n        return radius * shrink_factor\n\n    def _heuristic_cost(self, p: Point) -> float:\n        # Estimated cost to goal heuristically (Euclidean)\n        goal_pos = self._graph.root_vertex_goal.position\n        return self._dist(p, goal_pos)\n\n    def _choose_parent(self, neighbors: list[Vertex], q_new: Vertex) -> tuple[Vertex | None, float]:\n        c_min = float('inf')\n        q_min = None\n        for q_near in neighbors:\n            # Check collision-free connection\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            new_cost = q_near.cost + self._dist(q_near.position, q_new.position)\n            total_cost = new_cost + self._heuristic_cost(q_new.position)\n            # Pick minimal total cost with heuristic\n            if total_cost < c_min:\n                c_min = total_cost\n                q_min = q_near\n        if q_min is None:\n            return None, float('inf')\n        # Return parent and true cost without heuristic for path cost\n        actual_cost = q_min.cost + self._dist(q_min.position, q_new.position)\n        return q_min, actual_cost\n\n    def _shortcut_path(self, path: list[Vertex], max_attempts=30) -> list[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = self._get_grid().get_line_sequence(p_i, p_j)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # final smoothing before execute\n        path = self._shortcut_path(path, max_attempts=50)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*[int(round(float(c))) for c in new_pos_tensor])\n        return Vertex(new_pos)\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n        max_iterations = 15000\n\n        for iter_i in range(max_iterations):\n            self._iteration_count = iter_i\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Time exceeded, fail gracefully (no path found)\n                return\n\n            q_sample = self._adaptive_uniform_or_informed_sample()\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            radius = self._calc_rewire_radius()\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                # fallback connect nearest directly if no better parent\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Try rewiring neighbors through new vertex for better cost\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_rw = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_rw):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                if cost_through_new < q_near.cost:\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check goal reached with updated cost\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if (self._best_cost is None) or (possible_cost < self._best_cost):\n                    # Update best cost and connect goal vertex\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            # Progressive shortcut smoothing every 100 iterations for early path refinement\n            if (iter_i > 0) and (iter_i % 100 == 0) and self._best_goal_vertex is not None:\n                # Extract current path and smooth\n                current_path = []\n                cur = self._best_goal_vertex\n                while cur.parents:\n                    parent = min(cur.parents, key=lambda p: p.cost)\n                    current_path.append(cur)\n                    cur = parent\n                current_path.append(cur)\n                current_path.reverse()\n                smoothed = self._shortcut_path(current_path, max_attempts=15)\n                # Update positions with smoothed path visualization only\n                for vertex in smoothed:\n                    self.move_agent(vertex.position)\n                    self.key_frame(ignore_key_frame_skip=True)\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 157, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "m1",
     "algorithm": "This improved path planning algorithm advances over prior RRT* variants by integrating heuristic-driven informed sampling\n    within a dynamically adaptive ellipse region constrained by the current best path cost and distance metrics.\n    It further incorporates dynamic tuning of neighborhood radius for rewiring based on the evolving graph size,\n    enforcing collision-free rewiring to enhance path smoothness, reduce path lengths, and improve robustness.\n    A time constraint explicitly caps planning time to 60 seconds, marking failure beyond this limit.\n    The algorithm ensures high efficiency in exploration while biasing sampling towards promising goal regions,\n    promoting effective coverage and quicker convergence to high-quality paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_planning_time = 60  # seconds\n        self._init_displays()\n\n    def _informed_sample(self) -> Point:\n        start = self._graph.root_vertex_start.position\n        goal = self._graph.root_vertex_goal.position\n\n        def dist(a: Point, b: Point) -> float:\n            return torch.norm(a.to_tensor() - b.to_tensor()).item()\n\n        max_dist = dist(start, goal)\n        c_best = self._graph.root_vertex_goal.cost if self._graph.root_vertex_goal.cost is not None else max_dist * 1.5\n        c_min = max_dist\n\n        # Safety against invalid costs\n        if c_best is None or c_best == float('inf') or c_best < c_min:\n            c_best = c_min * 1.1\n\n        if torch.rand(1).item() < 0.05:  # 5% goal bias sampling\n            if self._get_grid().is_agent_valid_pos(goal):\n                return goal\n\n        # Ellipse parameters\n        center = (start.to_tensor() + goal.to_tensor()) / 2\n        a1 = goal.to_tensor() - start.to_tensor()\n        a1_norm = torch.norm(a1)\n        if a1_norm == 0:\n            a1_norm = 1.0\n        e1 = a1 / a1_norm\n\n        r1 = c_best / 2\n        ellipse_term = r1 ** 2 - (c_min / 2) ** 2\n        r2 = ellipse_term ** 0.5 if ellipse_term > 0 else r1 * 0.1\n\n        while True:\n            sample_unit = torch.rand(2) * 2 - 1\n            if sample_unit.norm() <= 1.0:\n                break\n\n        sample_ellipse = torch.zeros(2)\n        sample_ellipse[0] = sample_unit[0] * r1\n        sample_ellipse[1] = sample_unit[1] * r2\n\n        angle = torch.atan2(e1[1], e1[0])\n        rot_matrix = torch.tensor([[torch.cos(angle), -torch.sin(angle)],\n                                   [torch.sin(angle), torch.cos(angle)]])\n        sample_rotated = rot_matrix.matmul(sample_ellipse)\n        sample_point_tensor = center[:2] + sample_rotated\n\n        dims = self._get_grid().size.n_dim\n        coords = []\n        for i in range(dims):\n            dim_max = self._get_grid().size[i] - 1\n            if i < 2:\n                val = max(0, min(dim_max, float(sample_point_tensor[i])))\n            else:\n                val = torch.randint(0, dim_max + 1, (1,)).item()\n            coords.append(int(round(val)))\n\n        candidate = Point(*coords)\n        if self._get_grid().is_agent_valid_pos(candidate):\n            return candidate\n\n        # fallback uniform sampling if invalid\n        while True:\n            fallback_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(dims)]\n            fallback_sample = Point(*fallback_coords)\n            if self._get_grid().is_agent_valid_pos(fallback_sample):\n                return fallback_sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dir_norm\n        q_new_pos = q_near.position.to_tensor() + max_dist * dir_normalized\n        return Vertex(Point(*q_new_pos.tolist()))\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_vertex.position.to_tensor())\n        goal_vertex.cost = q_new.cost + dist_to_goal\n        self._graph.add_edge(q_new, goal_vertex)\n\n        path = [goal_vertex]\n        while path[-1].parents:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n\n        if path[-1] == self._graph.root_vertex_start:\n            path.pop()\n\n        path.reverse()\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist = 15.0\n        max_radius = 40.0\n        lambda_rrt_star = 35.0\n        dimension = self._get_grid().size.n_dim\n        max_iterations = 10000\n\n        from time import time\n        start_time = time()\n\n        for _ in range(max_iterations):\n            elapsed = time() - start_time\n            if elapsed > self._max_planning_time:\n                # Failed due to time limit\n                return\n\n            q_sample = self._informed_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cardinality = float(self._graph.size + 1)\n            log_card = max(1.0, torch.log(torch.tensor(cardinality)).item())\n            radius = min(lambda_rrt_star * ((log_card / cardinality) ** (1 / dimension)), max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent vertex with minimal cost + collision free edge\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                line_n2new = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_n2new):\n                    continue\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            dist_parent_to_new = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + dist_parent_to_new\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if better path is found and collision free\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                line_new2near = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_new2near):\n                    continue\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if cost_new_to_near < q_near.cost:\n                    old_parent = next(iter(q_near.parents), None)\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = None\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 170, in _find_path_internal\n  File \"<string>\", line 110, in _informed_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 149, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "e2",
     "algorithm": "Improved dual-tree hybrid sampling-based path planner combining RRT*, RRT-Connect, and Informed RRT* techniques.\n    Features include adaptive heuristic sampling biased around the current best path and goal region,\n    bidirectional tree expansion with informed rewiring, dynamic max distance adjustment based on progress,\n    and enhanced connection attempts with partial shortcutting for path smoothing.\n    Early stopping is employed on success or after 60s timeout.\n    This approach improves planning efficiency, path quality/smoothness, success rate, and reduces search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _timeout: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_cyclic_graph(self._services, \n                                       Vertex(self._get_grid().agent.position), \n                                       Vertex(self._get_grid().goal.position), \n                                       [])\n        self._graph.edges_removable = True  # Allow rewiring for improving path quality\n        self._max_dist = 12.0\n        self._iterations = 15000\n        self._timeout = 60.0  # seconds\n        self._init_displays()\n\n    def _get_random_sample(self, best_path=None) -> Point:\n        grid = self._get_grid()\n        rand_val = np.random.rand()\n\n        def sample_near_point(center: Point, radius: float, attempts: int = 20) -> Point or None:\n            for _ in range(attempts):\n                offset = np.random.uniform(-radius, radius, grid.size.n_dim)\n                sample_coords = center.to_tensor().numpy() + offset\n                sample_coords = np.clip(sample_coords, 0, np.array(grid.size.values) - 1)\n                sample_point = Point(*sample_coords.astype(int))\n                if grid.is_agent_valid_pos(sample_point):\n                    return sample_point\n            return None\n\n        # Prioritized heuristic sampling:\n        if best_path and len(best_path) > 2:\n            if rand_val > 0.85:\n                # Sample near random vertex on current best path (local refinement)\n                for _ in range(15):\n                    path_vertex = best_path[np.random.randint(0, len(best_path))]\n                    radius = self._max_dist * 1.25\n                    sample_point = sample_near_point(path_vertex.position, radius, 1)\n                    if sample_point is not None:\n                        return sample_point\n\n            if rand_val > 0.65:\n                # Sample biased near the goal within radius max_dist*2\n                sample_point = sample_near_point(grid.goal.position, self._max_dist * 2, 20)\n                if sample_point is not None:\n                    return sample_point\n\n        # Uniform random sampling fallback (~70%)\n        att = 0\n        while att < 60:\n            rand_pos = np.random.randint(0, grid.size.width, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n            att += 1\n        # If no valid sampled point found, fallback to agent's current position\n        return grid.agent.position\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_tensor)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_tensor / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*new_pos_tensor.tolist())\n        return Vertex(new_pos)\n\n    def _line_is_valid(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _get_vertices_near(self, root_vertices: list, point: Point, radius: float) -> list:\n        return self._graph.get_vertices_within_radius(root_vertices, point, radius)\n\n    def _choose_parent(self, new_vertex: Vertex, near_vertices: list) -> Vertex or None:\n        # Choose best parent minimizing cost + edge cost with valid line\n        min_cost = float(\"inf\")\n        best_parent = None\n        grid = self._get_grid()\n        for vertex in near_vertices:\n            if self._line_is_valid(vertex.position, new_vertex.position):\n                parent_cost = vertex.cost if vertex.cost is not None else 0.0\n                edge_cost = grid.get_movement_cost(vertex.position, new_vertex.position)\n                total_cost = parent_cost + edge_cost\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_parent = vertex\n        if best_parent is not None:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: list) -> None:\n        grid = self._get_grid()\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex or near_vertex in new_vertex.parents:\n                continue\n            if self._line_is_valid(new_vertex.position, near_vertex.position):\n                cost_through_new = new_vertex.cost + grid.get_movement_cost(new_vertex.position, near_vertex.position)\n                if near_vertex.cost is None or cost_through_new < near_vertex.cost:\n                    # Remove all old parents' edges\n                    for p in near_vertex.parents.copy():\n                        self._graph.remove_edge(p, near_vertex)\n                    # Add new edge from new_vertex to near_vertex with better cost\n                    self._graph.add_edge(new_vertex, near_vertex)\n                    near_vertex.cost = cost_through_new\n\n    def _try_shortcut(self, path: list) -> list:\n        # Attempt partial shortcut smoothing by removing intermediate nodes where direct connection is valid\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_is_valid(smoothed[-1].position, path[j].position):\n                    smoothed.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found, append next in path\n                smoothed.append(path[i + 1])\n                i += 1\n        return smoothed\n\n    def _extract_path(self, connecting_vertex_start: Vertex, connecting_vertex_goal: Vertex) -> list:\n        # Traverse parents up to roots\n        def backtrace(vertex: Vertex) -> list:\n            path = [vertex]\n            while vertex.parents:\n                # Select best parent (lowest cost)\n                vertex = min(vertex.parents, key=lambda p: p.cost if p.cost is not None else float(\"inf\"))\n                path.append(vertex)\n            path.reverse()\n            return path\n\n        start_path = backtrace(connecting_vertex_start)\n        goal_path = backtrace(connecting_vertex_goal)\n\n        full_path = start_path + goal_path\n\n        # Apply smoothing shortcut to reduce unnecessary waypoints\n        full_path = self._try_shortcut(full_path)\n\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n        return full_path\n\n    def _get_adaptive_max_dist(self, iteration: int, total_iterations: int) -> float:\n        # Starts small and increases max_dist gradually to favor exploration early and faster expansion later\n        base = 5.0\n        max_distance = self._max_dist\n        factor = iteration / total_iterations\n        adaptive_dist = base + factor * (max_distance - base)\n        return adaptive_dist\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n\n        best_path = None\n        best_cost = float(\"inf\")\n\n        start_time = time.time()\n\n        # Parameters\n        reconnect_radius_factor = 2.0\n        shortcut_attempt_interval = 200  # iterations\n\n        for iteration in range(self._iterations):\n            if (time.time() - start_time) > self._timeout:\n                # Fail after timeout\n                break\n\n            adaptive_max_dist = self._get_adaptive_max_dist(iteration, self._iterations)\n            radius = max(adaptive_max_dist * reconnect_radius_factor, 15.0)\n\n            # Alternate tree expansion: first start tree, then goal tree\n            tree_pairs = [\n                (self._graph.root_vertex_start, tree_start, self._graph.root_vertex_goal, tree_goal),\n                (self._graph.root_vertex_goal, tree_goal, self._graph.root_vertex_start, tree_start)\n            ]\n\n            for tree_roots, tree_vertices, other_roots, other_vertices in tree_pairs:\n                q_rand = self._get_random_sample(best_path)\n                q_near = self._graph.get_nearest_vertex([tree_roots], q_rand)\n\n                q_new = self._get_new_vertex(q_near, q_rand, adaptive_max_dist)\n\n                if not self._line_is_valid(q_near.position, q_new.position):\n                    continue\n\n                near_vertices = self._get_vertices_near([tree_roots], q_new.position, radius)\n                parent = self._choose_parent(q_new, near_vertices)\n                if parent is None:\n                    continue\n\n                self._graph.add_edge(parent, q_new)\n                tree_vertices.append(q_new)\n\n                self._rewire(q_new, near_vertices)\n\n                q_near_other = self._graph.get_nearest_vertex([other_roots], q_new.position)\n                q_connect = self._get_new_vertex(q_new, q_near_other.position, adaptive_max_dist)\n\n                if self._line_is_valid(q_new.position, q_connect.position):\n                    near_others = self._get_vertices_near([other_roots], q_connect.position, radius)\n                    parent_other = self._choose_parent(q_connect, near_others)\n                    if parent_other is not None:\n                        self._graph.add_edge(parent_other, q_connect)\n                        if q_connect not in other_vertices:\n                            other_vertices.append(q_connect)\n\n                        # If trees connected directly\n                        if q_connect.position == q_near_other.position:\n                            # Extract and display path\n                            path = self._extract_path(q_new, q_connect)\n                            final_cost = path[-1].cost if path[-1].cost is not None else float(\"inf\")\n                            if final_cost < best_cost:\n                                best_cost = final_cost\n                                best_path = path\n                            # Success: done planning\n                            return\n                        else:\n                            # Attempt extended connection in other tree (multi-step connect)\n                            current_vertex = q_connect\n                            extended = True\n                            while extended:\n                                q_extend = self._get_new_vertex(current_vertex, q_near_other.position, adaptive_max_dist)\n                                if q_extend.position == current_vertex.position:\n                                    break\n                                if self._line_is_valid(current_vertex.position, q_extend.position):\n                                    near_extend = self._get_vertices_near([other_roots], q_extend.position, radius)\n                                    parent_extend = self._choose_parent(q_extend, near_extend)\n                                    if parent_extend is None:\n                                        break\n                                    self._graph.add_edge(parent_extend, q_extend)\n                                    if q_extend not in other_vertices:\n                                        other_vertices.append(q_extend)\n                                    # Partial shortcut: try connecting current_vertex directly to q_extend's parent of best cost if shorter than two edges\n                                    if len(near_extend) > 1:\n                                        for nv in near_extend:\n                                            if nv != parent_extend and self._line_is_valid(current_vertex.position, nv.position):\n                                                cost_via_nv = (current_vertex.cost if current_vertex.cost else 0.0) + \\\n                                                              grid.get_movement_cost(current_vertex.position, nv.position)\n                                                if nv.cost is not None and cost_via_nv + grid.get_movement_cost(nv.position, q_extend.position) < q_extend.cost:\n                                                    # Rewire q_extend to nv for shortcut\n                                                    for p in q_extend.parents.copy():\n                                                        self._graph.remove_edge(p, q_extend)\n                                                    self._graph.add_edge(nv, q_extend)\n                                                    q_extend.cost = cost_via_nv + grid.get_movement_cost(nv.position, q_extend.position)\n                                    current_vertex = q_extend\n                                    if q_extend.position == q_near_other.position:\n                                        path = self._extract_path(q_new, q_extend)\n                                        final_cost = path[-1].cost if path[-1].cost is not None else float(\"inf\")\n                                        if final_cost < best_cost:\n                                            best_cost = final_cost\n                                            best_path = path\n                                        return\n                                else:\n                                    extended = False\n\n            if iteration % shortcut_attempt_interval == 0 and best_path:\n                # Periodically attempt to shortcut smooth the best known path\n                best_path = self._try_shortcut(best_path)\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 238, in _find_path_internal\n  File \"<string>\", line 95, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 149, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m2",
     "algorithm": "Improved Adaptive Informed RRT* (AIRRT*) Algorithm with Dynamic Radius Tuning and Progressive Shortcutting",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: float  # removed union with None to avoid unsupported operand |\n    _best_goal_vertex: Vertex  # removed union with None to avoid unsupported operand |\n    _iteration_count: int\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._dimension = self._get_grid().size.n_dim\n        # Set max step length proportional to map size (reduce for tighter moves)\n        self._max_dist = float(max(self._get_grid().size.values)) / 12.0  \n        self._lambda_rrt_star = 35.0  # slightly tuned constant for radius\n        self._max_radius = max(self._get_grid().size.values) / 4.5  # smaller max radius to refine rewiring\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._start_time = 0.0\n        self._timeout = 60.0  # seconds\n        self._best_cost = None\n        self._best_goal_vertex = None\n        self._iteration_count = 0\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _adaptive_uniform_or_informed_sample(self) -> Point:\n        # Occasionally do uniform to preserve exploration (5% of samples)\n        import random\n        if (self._best_cost is None) or (random.random() < 0.05):\n            return self._uniform_sample()\n        return self._ellipsoidal_sample()\n\n    def _uniform_sample(self) -> Point:\n        attempts = 0\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n            if attempts > 100:\n                # fallback to start if stuck\n                return self._graph.root_vertex_start.position\n\n    def _ellipsoidal_sample(self) -> Point:\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        c_best = torch.tensor(self._best_cost)\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best < c_min:\n            c_best = c_min + 1e-3  # numerical safeguard\n\n        center = (start + goal) / 2.0\n        foci_vec = (goal - start)\n        e_axis = foci_vec / torch.norm(foci_vec)\n\n        if self._dimension == 2:\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])\n        elif self._dimension == 3:\n            z_axis = e_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n        else:\n            return self._uniform_sample()\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0\n\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        elif self._dimension == 3:\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n        else:\n            return self._uniform_sample()\n\n        for _ in range(5):  # try max 5 times to get valid sample in ellipsoid\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u < 1e-6:\n                continue\n            unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n            sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n            sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, self._get_grid().size[i] - 1).round())) for i in range(self._dimension)]\n            sample_point = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # fallback uniform\n        return self._uniform_sample()\n\n    def _calc_rewire_radius(self) -> float:\n        n = max(1, self._graph.size + 1)\n        r = self._lambda_rrt_star * ((torch.log(torch.tensor(float(n))).item() / n) ** (1.0 / self._dimension))\n        radius = min(r, self._max_radius)\n        # gradually shrink radius as iterations grow to encourage focus on local rewiring later\n        shrink_factor = max(0.3, 1.0 - (self._iteration_count / 12000))\n        return radius * shrink_factor\n\n    def _heuristic_cost(self, p: Point) -> float:\n        # Estimated cost to goal heuristically (Euclidean)\n        goal_pos = self._graph.root_vertex_goal.position\n        return self._dist(p, goal_pos)\n\n    # Changed list[Vertex] to List[Vertex], and tuple[Vertex | None, float] to Tuple[Optional[Vertex], float]\n    from typing import List, Tuple, Optional\n    def _choose_parent(self, neighbors: 'List[Vertex]', q_new: Vertex) -> 'Tuple[Optional[Vertex], float]':\n        c_min = float('inf')\n        q_min = None\n        for q_near in neighbors:\n            # Check collision-free connection\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            new_cost = q_near.cost + self._dist(q_near.position, q_new.position)\n            total_cost = new_cost + self._heuristic_cost(q_new.position)\n            # Pick minimal total cost with heuristic\n            if total_cost < c_min:\n                c_min = total_cost\n                q_min = q_near\n        if q_min is None:\n            return None, float('inf')\n        # Return parent and true cost without heuristic for path cost\n        actual_cost = q_min.cost + self._dist(q_min.position, q_new.position)\n        return q_min, actual_cost\n\n    # Changed list[Vertex] to List[Vertex]\n    def _shortcut_path(self, path: 'List[Vertex]', max_attempts=30) -> 'List[Vertex]':\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = self._get_grid().get_line_sequence(p_i, p_j)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # final smoothing before execute\n        path = self._shortcut_path(path, max_attempts=50)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*[int(round(float(c))) for c in new_pos_tensor])\n        return Vertex(new_pos)\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n        max_iterations = 15000\n\n        for iter_i in range(max_iterations):\n            self._iteration_count = iter_i\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Time exceeded, fail gracefully (no path found)\n                return\n\n            q_sample = self._adaptive_uniform_or_informed_sample()\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            radius = self._calc_rewire_radius()\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                # fallback connect nearest directly if no better parent\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Try rewiring neighbors through new vertex for better cost\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_rw = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_rw):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                if cost_through_new < q_near.cost:\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check goal reached with updated cost\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if (self._best_cost is None) or (possible_cost < self._best_cost):\n                    # Update best cost and connect goal vertex\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            # Progressive shortcut smoothing every 100 iterations for early path refinement\n            if (iter_i > 0) and (iter_i % 100 == 0) and self._best_goal_vertex is not None:\n                # Extract current path and smooth\n                current_path = []\n                cur = self._best_goal_vertex\n                while cur.parents:\n                    parent = min(cur.parents, key=lambda p: p.cost)\n                    current_path.append(cur)\n                    cur = parent\n                current_path.append(cur)\n                current_path.reverse()\n                smoothed = self._shortcut_path(current_path, max_attempts=15)\n                # Update positions with smoothed path visualization only\n                for vertex in smoothed:\n                    self.move_agent(vertex.position)\n                    self.key_frame(ignore_key_frame_skip=True)\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 235, in _find_path_internal\n  File \"<string>\", line 78, in _adaptive_uniform_or_informed_sample\n  File \"<string>\", line 86, in _uniform_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 149, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m1",
     "algorithm": "This improved path planning algorithm advances over prior RRT* variants by integrating heuristic-driven informed sampling\n    within a dynamically adaptive ellipse region constrained by the current best path cost and distance metrics.\n    It further incorporates dynamic tuning of neighborhood radius for rewiring based on the evolving graph size,\n    enforcing collision-free rewiring to enhance path smoothness, reduce path lengths, and improve robustness.\n    A time constraint explicitly caps planning time to 60 seconds, marking failure beyond this limit.\n    The algorithm ensures high efficiency in exploration while biasing sampling towards promising goal regions,\n    promoting effective coverage and quicker convergence to high-quality paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_pos = self._get_grid().agent.position\n        if hasattr(start_pos, 'is_float'):\n            pass\n        else:\n            # Defensive: recreate Point to ensure attribute\n            start_pos = Point(*start_pos.values)  \n        start_vertex = Vertex(start_pos)\n        start_vertex.cost = 0\n        goal_pos = self._get_grid().goal.position\n        if hasattr(goal_pos, 'is_float'):\n            pass\n        else:\n            goal_pos = Point(*goal_pos.values)\n        goal_vertex = Vertex(goal_pos)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_planning_time = 60  # seconds\n        self._init_displays()\n\n    def _informed_sample(self) -> Point:\n        start = self._graph.root_vertex_start.position\n        goal = self._graph.root_vertex_goal.position\n\n        def dist(a: Point, b: Point) -> float:\n            return torch.norm(a.to_tensor() - b.to_tensor()).item()\n\n        max_dist = dist(start, goal)\n        c_best = self._graph.root_vertex_goal.cost if self._graph.root_vertex_goal.cost is not None else max_dist * 1.5\n        c_min = max_dist\n\n        # Safety against invalid costs\n        if c_best is None or c_best == float('inf') or c_best < c_min:\n            c_best = c_min * 1.1\n\n        if torch.rand(1).item() < 0.05:  # 5% goal bias sampling\n            if self._get_grid().is_agent_valid_pos(goal):\n                return goal\n\n        # Ellipse parameters\n        center = (start.to_tensor() + goal.to_tensor()) / 2\n        a1 = goal.to_tensor() - start.to_tensor()\n        a1_norm = torch.norm(a1)\n        if a1_norm == 0:\n            a1_norm = 1.0\n        e1 = a1 / a1_norm\n\n        r1 = c_best / 2\n        ellipse_term = r1 ** 2 - (c_min / 2) ** 2\n        r2 = ellipse_term ** 0.5 if ellipse_term > 0 else r1 * 0.1\n\n        while True:\n            sample_unit = torch.rand(2) * 2 - 1\n            if sample_unit.norm() <= 1.0:\n                break\n\n        sample_ellipse = torch.zeros(2)\n        sample_ellipse[0] = sample_unit[0] * r1\n        sample_ellipse[1] = sample_unit[1] * r2\n\n        angle = torch.atan2(e1[1], e1[0])\n        rot_matrix = torch.tensor([[torch.cos(angle), -torch.sin(angle)],\n                                   [torch.sin(angle), torch.cos(angle)]])\n        sample_rotated = rot_matrix.matmul(sample_ellipse)\n        sample_point_tensor = center[:2] + sample_rotated\n\n        dims = self._get_grid().size.n_dim\n        coords = []\n        for i in range(dims):\n            dim_max = self._get_grid().size[i] - 1\n            if i < 2:\n                val = max(0, min(dim_max, float(sample_point_tensor[i])))\n            else:\n                val = torch.randint(0, dim_max + 1, (1,)).item()\n            coords.append(int(round(val)))\n\n        candidate = Point(*coords)\n        if self._get_grid().is_agent_valid_pos(candidate):\n            return candidate\n\n        # fallback uniform sampling if invalid\n        while True:\n            fallback_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(dims)]\n            fallback_sample = Point(*fallback_coords)\n            if self._get_grid().is_agent_valid_pos(fallback_sample):\n                return fallback_sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            # Make sure Point coordinates are int here\n            pos_coords = [int(round(c)) for c in q_sample.to_tensor().tolist()]\n            return Vertex(Point(*pos_coords))\n        dir_normalized = dir / dir_norm\n        q_new_pos = q_near.position.to_tensor() + max_dist * dir_normalized\n        pos_coords = [int(round(c)) for c in q_new_pos.tolist()]\n        return Vertex(Point(*pos_coords))\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_vertex.position.to_tensor())\n        goal_vertex.cost = q_new.cost + dist_to_goal\n        self._graph.add_edge(q_new, goal_vertex)\n\n        path = [goal_vertex]\n        while path[-1].parents:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n\n        if path[-1] == self._graph.root_vertex_start:\n            path.pop()\n\n        path.reverse()\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist = 15.0\n        max_radius = 40.0\n        lambda_rrt_star = 35.0\n        dimension = self._get_grid().size.n_dim\n        max_iterations = 10000\n\n        from time import time\n        start_time = time()\n\n        for _ in range(max_iterations):\n            elapsed = time() - start_time\n            if elapsed > self._max_planning_time:\n                # Failed due to time limit\n                return\n\n            q_sample = self._informed_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cardinality = float(self._graph.size + 1)\n            log_card = max(1.0, torch.log(torch.tensor(cardinality)).item())\n            radius = min(lambda_rrt_star * ((log_card / cardinality) ** (1 / dimension)), max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent vertex with minimal cost + collision free edge\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                line_n2new = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_n2new):\n                    continue\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            dist_parent_to_new = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + dist_parent_to_new\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if better path is found and collision free\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                line_new2near = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_new2near):\n                    continue\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if cost_new_to_near < q_near.cost:\n                    old_parent = next(iter(q_near.parents), None)\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = None\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 184, in _find_path_internal\n  File \"<string>\", line 121, in _informed_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 149, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "e2",
     "algorithm": "Improved dual-tree hybrid sampling-based path planner combining RRT*, RRT-Connect, and Informed RRT* techniques.\n    Features include adaptive heuristic sampling biased around the current best path and goal region,\n    bidirectional tree expansion with informed rewiring, dynamic max distance adjustment based on progress,\n    and enhanced connection attempts with partial shortcutting for path smoothing.\n    Early stopping is employed on success or after 60s timeout.\n    This approach improves planning efficiency, path quality/smoothness, success rate, and reduces search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _timeout: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_cyclic_graph(self._services, \n                                       Vertex(self._get_grid().agent.position), \n                                       Vertex(self._get_grid().goal.position), \n                                       [])\n        self._graph.edges_removable = True  # Allow rewiring for improving path quality\n        self._max_dist = 12.0\n        self._iterations = 15000\n        self._timeout = 60.0  # seconds\n        self._init_displays()\n\n    def _get_random_sample(self, best_path=None) -> Point:\n        grid = self._get_grid()\n        rand_val = np.random.rand()\n\n        def sample_near_point(center: Point, radius: float, attempts: int = 20) -> Point or None:\n            for _ in range(attempts):\n                offset = np.random.uniform(-radius, radius, grid.size.n_dim)\n                sample_coords = center.to_tensor().numpy() + offset\n                sample_coords = np.clip(sample_coords, 0, np.array(grid.size.values) - 1)\n                sample_point = Point(*sample_coords.astype(int))\n                if grid.is_agent_valid_pos(sample_point):\n                    return sample_point\n            return None\n\n        # Prioritized heuristic sampling:\n        if best_path and len(best_path) > 2:\n            if rand_val > 0.85:\n                # Sample near random vertex on current best path (local refinement)\n                for _ in range(15):\n                    path_vertex = best_path[np.random.randint(0, len(best_path))]\n                    radius = self._max_dist * 1.25\n                    sample_point = sample_near_point(path_vertex.position, radius, 1)\n                    if sample_point is not None:\n                        return sample_point\n\n            if rand_val > 0.65:\n                # Sample biased near the goal within radius max_dist*2\n                sample_point = sample_near_point(grid.goal.position, self._max_dist * 2, 20)\n                if sample_point is not None:\n                    return sample_point\n\n        # Uniform random sampling fallback (~70%)\n        att = 0\n        while att < 60:\n            rand_pos = np.random.randint(0, grid.size.width, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n            att += 1\n        # If no valid sampled point found, fallback to agent's current position\n        return grid.agent.position\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_tensor)\n        if dist <= max_dist:\n            # Create integer coordinate Point to avoid float Points\n            pos_vals = q_sample.values\n            pos_int = tuple(int(round(v)) for v in pos_vals)\n            return Vertex(Point(*pos_int))\n        dir_normalized = dir_tensor / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        # Convert tensor to int Point to avoid float Points\n        new_pos_vals = [int(round(x.item())) for x in new_pos_tensor]\n        new_pos = Point(*new_pos_vals)\n        return Vertex(new_pos)\n\n    def _line_is_valid(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _get_vertices_near(self, root_vertices: list, point: Point, radius: float) -> list:\n        return self._graph.get_vertices_within_radius(root_vertices, point, radius)\n\n    def _choose_parent(self, new_vertex: Vertex, near_vertices: list) -> Vertex or None:\n        # Choose best parent minimizing cost + edge cost with valid line\n        min_cost = float(\"inf\")\n        best_parent = None\n        grid = self._get_grid()\n        for vertex in near_vertices:\n            if self._line_is_valid(vertex.position, new_vertex.position):\n                parent_cost = vertex.cost if vertex.cost is not None else 0.0\n                edge_cost = grid.get_movement_cost(vertex.position, new_vertex.position)\n                total_cost = parent_cost + edge_cost\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_parent = vertex\n        if best_parent is not None:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: list) -> None:\n        grid = self._get_grid()\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex or near_vertex in new_vertex.parents:\n                continue\n            if self._line_is_valid(new_vertex.position, near_vertex.position):\n                cost_through_new = new_vertex.cost + grid.get_movement_cost(new_vertex.position, near_vertex.position)\n                if near_vertex.cost is None or cost_through_new < near_vertex.cost:\n                    # Remove all old parents' edges\n                    for p in near_vertex.parents.copy():\n                        self._graph.remove_edge(p, near_vertex)\n                    # Add new edge from new_vertex to near_vertex with better cost\n                    self._graph.add_edge(new_vertex, near_vertex)\n                    near_vertex.cost = cost_through_new\n\n    def _try_shortcut(self, path: list) -> list:\n        # Attempt partial shortcut smoothing by removing intermediate nodes where direct connection is valid\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_is_valid(smoothed[-1].position, path[j].position):\n                    smoothed.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found, append next in path\n                smoothed.append(path[i + 1])\n                i += 1\n        return smoothed\n\n    def _extract_path(self, connecting_vertex_start: Vertex, connecting_vertex_goal: Vertex) -> list:\n        # Traverse parents up to roots\n        def backtrace(vertex: Vertex) -> list:\n            path = [vertex]\n            while vertex.parents:\n                # Select best parent (lowest cost)\n                vertex = min(vertex.parents, key=lambda p: p.cost if p.cost is not None else float(\"inf\"))\n                path.append(vertex)\n            path.reverse()\n            return path\n\n        start_path = backtrace(connecting_vertex_start)\n        goal_path = backtrace(connecting_vertex_goal)\n\n        full_path = start_path + goal_path\n\n        # Apply smoothing shortcut to reduce unnecessary waypoints\n        full_path = self._try_shortcut(full_path)\n\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n        return full_path\n\n    def _get_adaptive_max_dist(self, iteration: int, total_iterations: int) -> float:\n        # Starts small and increases max_dist gradually to favor exploration early and faster expansion later\n        base = 5.0\n        max_distance = self._max_dist\n        factor = iteration / total_iterations\n        adaptive_dist = base + factor * (max_distance - base)\n        return adaptive_dist\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n\n        best_path = None\n        best_cost = float(\"inf\")\n\n        start_time = time.time()\n\n        # Parameters\n        reconnect_radius_factor = 2.0\n        shortcut_attempt_interval = 200  # iterations\n\n        for iteration in range(self._iterations):\n            if (time.time() - start_time) > self._timeout:\n                # Fail after timeout\n                break\n\n            adaptive_max_dist = self._get_adaptive_max_dist(iteration, self._iterations)\n            radius = max(adaptive_max_dist * reconnect_radius_factor, 15.0)\n\n            # Alternate tree expansion: first start tree, then goal tree\n            tree_pairs = [\n                (self._graph.root_vertex_start, tree_start, self._graph.root_vertex_goal, tree_goal),\n                (self._graph.root_vertex_goal, tree_goal, self._graph.root_vertex_start, tree_start)\n            ]\n\n            for tree_roots, tree_vertices, other_roots, other_vertices in tree_pairs:\n                q_rand = self._get_random_sample(best_path)\n                q_near = self._graph.get_nearest_vertex([tree_roots], q_rand)\n\n                q_new = self._get_new_vertex(q_near, q_rand, adaptive_max_dist)\n\n                if not self._line_is_valid(q_near.position, q_new.position):\n                    continue\n\n                near_vertices = self._get_vertices_near([tree_roots], q_new.position, radius)\n                parent = self._choose_parent(q_new, near_vertices)\n                if parent is None:\n                    continue\n\n                self._graph.add_edge(parent, q_new)\n                tree_vertices.append(q_new)\n\n                self._rewire(q_new, near_vertices)\n\n                q_near_other = self._graph.get_nearest_vertex([other_roots], q_new.position)\n                q_connect = self._get_new_vertex(q_new, q_near_other.position, adaptive_max_dist)\n\n                if self._line_is_valid(q_new.position, q_connect.position):\n                    near_others = self._get_vertices_near([other_roots], q_connect.position, radius)\n                    parent_other = self._choose_parent(q_connect, near_others)\n                    if parent_other is not None:\n                        self._graph.add_edge(parent_other, q_connect)\n                        if q_connect not in other_vertices:\n                            other_vertices.append(q_connect)\n\n                        # If trees connected directly\n                        if q_connect.position == q_near_other.position:\n                            # Extract and display path\n                            path = self._extract_path(q_new, q_connect)\n                            final_cost = path[-1].cost if path[-1].cost is not None else float(\"inf\")\n                            if final_cost < best_cost:\n                                best_cost = final_cost\n                                best_path = path\n                            # Success: done planning\n                            return\n                        else:\n                            # Attempt extended connection in other tree (multi-step connect)\n                            current_vertex = q_connect\n                            extended = True\n                            while extended:\n                                q_extend = self._get_new_vertex(current_vertex, q_near_other.position, adaptive_max_dist)\n                                if q_extend.position == current_vertex.position:\n                                    break\n                                if self._line_is_valid(current_vertex.position, q_extend.position):\n                                    near_extend = self._get_vertices_near([other_roots], q_extend.position, radius)\n                                    parent_extend = self._choose_parent(q_extend, near_extend)\n                                    if parent_extend is None:\n                                        break\n                                    self._graph.add_edge(parent_extend, q_extend)\n                                    if q_extend not in other_vertices:\n                                        other_vertices.append(q_extend)\n                                    # Partial shortcut: try connecting current_vertex directly to q_extend's parent of best cost if shorter than two edges\n                                    if len(near_extend) > 1:\n                                        for nv in near_extend:\n                                            if nv != parent_extend and self._line_is_valid(current_vertex.position, nv.position):\n                                                cost_via_nv = (current_vertex.cost if current_vertex.cost else 0.0) + \\\n                                                              grid.get_movement_cost(current_vertex.position, nv.position)\n                                                if nv.cost is not None and cost_via_nv + grid.get_movement_cost(nv.position, q_extend.position) < q_extend.cost:\n                                                    # Rewire q_extend to nv for shortcut\n                                                    for p in q_extend.parents.copy():\n                                                        self._graph.remove_edge(p, q_extend)\n                                                    self._graph.add_edge(nv, q_extend)\n                                                    q_extend.cost = cost_via_nv + grid.get_movement_cost(nv.position, q_extend.position)\n                                    current_vertex = q_extend\n                                    if q_extend.position == q_near_other.position:\n                                        path = self._extract_path(q_new, q_extend)\n                                        final_cost = path[-1].cost if path[-1].cost is not None else float(\"inf\")\n                                        if final_cost < best_cost:\n                                            best_cost = final_cost\n                                            best_path = path\n                                        return\n                                else:\n                                    extended = False\n\n            if iteration % shortcut_attempt_interval == 0 and best_path:\n                # Periodically attempt to shortcut smooth the best known path\n                best_path = self._try_shortcut(best_path)\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 243, in _find_path_internal\n  File \"<string>\", line 95, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 149, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m2",
     "algorithm": "Improved Adaptive Informed RRT* (AIRRT*) Algorithm with Dynamic Radius Tuning and Progressive Shortcutting",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: float  # removed union with None to avoid unsupported operand |\n    _best_goal_vertex: Vertex  # removed union with None to avoid unsupported operand |\n    _iteration_count: int\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._dimension = self._get_grid().size.n_dim\n        # Set max step length proportional to map size (reduce for tighter moves)\n        self._max_dist = float(max(self._get_grid().size.values)) / 12.0  \n        self._lambda_rrt_star = 35.0  # slightly tuned constant for radius\n        self._max_radius = max(self._get_grid().size.values) / 4.5  # smaller max radius to refine rewiring\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._start_time = 0.0\n        self._timeout = 60.0  # seconds\n        self._best_cost = None\n        self._best_goal_vertex = None\n        self._iteration_count = 0\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _adaptive_uniform_or_informed_sample(self) -> Point:\n        # Occasionally do uniform to preserve exploration (5% of samples)\n        import random\n        if (self._best_cost is None) or (random.random() < 0.05):\n            return self._uniform_sample()\n        return self._ellipsoidal_sample()\n\n    def _uniform_sample(self) -> Point:\n        attempts = 0\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            # Ensure all coordinates are int, create Point explicitly with int values\n            int_coords = [int(c) for c in coords]\n            sample = Point(*int_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n            if attempts > 100:\n                # fallback to start if stuck\n                return self._graph.root_vertex_start.position\n\n    def _ellipsoidal_sample(self) -> Point:\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        c_best = torch.tensor(self._best_cost)\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best < c_min:\n            c_best = c_min + 1e-3  # numerical safeguard\n\n        center = (start + goal) / 2.0\n        foci_vec = (goal - start)\n        e_axis = foci_vec / torch.norm(foci_vec)\n\n        if self._dimension == 2:\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])\n        elif self._dimension == 3:\n            z_axis = e_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n        else:\n            return self._uniform_sample()\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0\n\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        elif self._dimension == 3:\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n        else:\n            return self._uniform_sample()\n\n        for _ in range(5):  # try max 5 times to get valid sample in ellipsoid\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u < 1e-6:\n                continue\n            unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n            sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n            sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, self._get_grid().size[i] - 1).round())) for i in range(self._dimension)]\n            sample_point = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # fallback uniform\n        return self._uniform_sample()\n\n    def _calc_rewire_radius(self) -> float:\n        n = max(1, self._graph.size + 1)\n        r = self._lambda_rrt_star * ((torch.log(torch.tensor(float(n))).item() / n) ** (1.0 / self._dimension))\n        radius = min(r, self._max_radius)\n        # gradually shrink radius as iterations grow to encourage focus on local rewiring later\n        shrink_factor = max(0.3, 1.0 - (self._iteration_count / 12000))\n        return radius * shrink_factor\n\n    def _heuristic_cost(self, p: Point) -> float:\n        # Estimated cost to goal heuristically (Euclidean)\n        goal_pos = self._graph.root_vertex_goal.position\n        return self._dist(p, goal_pos)\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Tuple[Optional[Vertex], float]:\n        c_min = float('inf')\n        q_min = None\n        for q_near in neighbors:\n            # Check collision-free connection\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            new_cost = q_near.cost + self._dist(q_near.position, q_new.position)\n            total_cost = new_cost + self._heuristic_cost(q_new.position)\n            # Pick minimal total cost with heuristic\n            if total_cost < c_min:\n                c_min = total_cost\n                q_min = q_near\n        if q_min is None:\n            return None, float('inf')\n        # Return parent and true cost without heuristic for path cost\n        actual_cost = q_min.cost + self._dist(q_min.position, q_new.position)\n        return q_min, actual_cost\n\n    def _shortcut_path(self, path: List[Vertex], max_attempts=30) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = self._get_grid().get_line_sequence(p_i, p_j)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # final smoothing before execute\n        path = self._shortcut_path(path, max_attempts=50)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*[int(round(float(c))) for c in new_pos_tensor])\n        return Vertex(new_pos)\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n        max_iterations = 15000\n\n        for iter_i in range(max_iterations):\n            self._iteration_count = iter_i\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Time exceeded, fail gracefully (no path found)\n                return\n\n            q_sample = self._adaptive_uniform_or_informed_sample()\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            radius = self._calc_rewire_radius()\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                # fallback connect nearest directly if no better parent\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Try rewiring neighbors through new vertex for better cost\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_rw = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_rw):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                if cost_through_new < q_near.cost:\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check goal reached with updated cost\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if (self._best_cost is None) or (possible_cost < self._best_cost):\n                    # Update best cost and connect goal vertex\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            # Progressive shortcut smoothing every 100 iterations for early path refinement\n            if (iter_i > 0) and (iter_i % 100 == 0) and self._best_goal_vertex is not None:\n                # Extract current path and smooth\n                current_path = []\n                cur = self._best_goal_vertex\n                while cur.parents:\n                    parent = min(cur.parents, key=lambda p: p.cost)\n                    current_path.append(cur)\n                    cur = parent\n                current_path.append(cur)\n                current_path.reverse()\n                smoothed = self._shortcut_path(current_path, max_attempts=15)\n                # Update positions with smoothed path visualization only\n                for vertex in smoothed:\n                    self.move_agent(vertex.position)\n                    self.key_frame(ignore_key_frame_skip=True)\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 233, in _find_path_internal\n  File \"<string>\", line 77, in _adaptive_uniform_or_informed_sample\n  File \"<string>\", line 87, in _uniform_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 149, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m1",
     "algorithm": "This improved path planning algorithm advances over prior RRT* variants by integrating heuristic-driven informed sampling\n    within a dynamically adaptive ellipse region constrained by the current best path cost and distance metrics.\n    It further incorporates dynamic tuning of neighborhood radius for rewiring based on the evolving graph size,\n    enforcing collision-free rewiring to enhance path smoothness, reduce path lengths, and improve robustness.\n    A time constraint explicitly caps planning time to 60 seconds, marking failure beyond this limit.\n    The algorithm ensures high efficiency in exploration while biasing sampling towards promising goal regions,\n    promoting effective coverage and quicker convergence to high-quality paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_pos = self._get_grid().agent.position\n        # Defensive: recreate Point to ensure attribute and consistency\n        start_pos = Point(*start_pos.values)  \n        start_vertex = Vertex(start_pos)\n        start_vertex.cost = 0\n        goal_pos = self._get_grid().goal.position\n        goal_pos = Point(*goal_pos.values)\n        goal_vertex = Vertex(goal_pos)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_planning_time = 60  # seconds\n        self._init_displays()\n\n    def _informed_sample(self) -> Point:\n        start = self._graph.root_vertex_start.position\n        goal = self._graph.root_vertex_goal.position\n\n        def dist(a: Point, b: Point) -> float:\n            return torch.norm(a.to_tensor() - b.to_tensor()).item()\n\n        max_dist = dist(start, goal)\n        c_best = self._graph.root_vertex_goal.cost if self._graph.root_vertex_goal.cost is not None else max_dist * 1.5\n        c_min = max_dist\n\n        # Safety against invalid costs\n        if c_best is None or c_best == float('inf') or c_best < c_min:\n            c_best = c_min * 1.1\n\n        if torch.rand(1).item() < 0.05:  # 5% goal bias sampling\n            if self._get_grid().is_agent_valid_pos(goal):\n                return goal\n\n        # Ellipse parameters\n        center = (start.to_tensor() + goal.to_tensor()) / 2\n        a1 = goal.to_tensor() - start.to_tensor()\n        a1_norm = torch.norm(a1)\n        if a1_norm == 0:\n            a1_norm = 1.0\n        e1 = a1 / a1_norm\n\n        r1 = c_best / 2\n        ellipse_term = r1 ** 2 - (c_min / 2) ** 2\n        r2 = ellipse_term ** 0.5 if ellipse_term > 0 else r1 * 0.1\n\n        while True:\n            sample_unit = torch.rand(2) * 2 - 1\n            if sample_unit.norm() <= 1.0:\n                break\n\n        sample_ellipse = torch.zeros(2)\n        sample_ellipse[0] = sample_unit[0] * r1\n        sample_ellipse[1] = sample_unit[1] * r2\n\n        angle = torch.atan2(e1[1], e1[0])\n        rot_matrix = torch.tensor([[torch.cos(angle), -torch.sin(angle)],\n                                   [torch.sin(angle), torch.cos(angle)]])\n        sample_rotated = rot_matrix.matmul(sample_ellipse)\n        sample_point_tensor = center[:2] + sample_rotated\n\n        dims = self._get_grid().size.n_dim\n        coords = []\n        for i in range(dims):\n            dim_max = self._get_grid().size[i] - 1\n            if i < 2:\n                val = max(0, min(dim_max, float(sample_point_tensor[i])))\n            else:\n                val = torch.randint(0, dim_max + 1, (1,)).item()\n            coords.append(int(round(val)))\n\n        candidate = Point(*coords)\n        if self._get_grid().is_agent_valid_pos(candidate):\n            return candidate\n\n        # fallback uniform sampling if invalid\n        while True:\n            fallback_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(dims)]\n            fallback_sample = Point(*fallback_coords)\n            if self._get_grid().is_agent_valid_pos(fallback_sample):\n                return fallback_sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            # Make sure Point coordinates are int here\n            pos_coords = [int(round(c)) for c in q_sample.to_tensor().tolist()]\n            return Vertex(Point(*pos_coords))\n        dir_normalized = dir / dir_norm\n        q_new_pos = q_near.position.to_tensor() + max_dist * dir_normalized\n        pos_coords = [int(round(c)) for c in q_new_pos.tolist()]\n        return Vertex(Point(*pos_coords))\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_vertex = Vertex(Point(*self._get_grid().goal.position.values))\n        dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_vertex.position.to_tensor())\n        goal_vertex.cost = q_new.cost + dist_to_goal\n        self._graph.add_edge(q_new, goal_vertex)\n\n        path = [goal_vertex]\n        while path[-1].parents:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n\n        if path[-1] == self._graph.root_vertex_start:\n            path.pop()\n\n        path.reverse()\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist = 15.0\n        max_radius = 40.0\n        lambda_rrt_star = 35.0\n        dimension = self._get_grid().size.n_dim\n        max_iterations = 10000\n\n        from time import time\n        start_time = time()\n\n        for _ in range(max_iterations):\n            elapsed = time() - start_time\n            if elapsed > self._max_planning_time:\n                # Failed due to time limit\n                return\n\n            q_sample = self._informed_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cardinality = float(self._graph.size + 1)\n            log_card = max(1.0, torch.log(torch.tensor(cardinality)).item())\n            radius = min(lambda_rrt_star * ((log_card / cardinality) ** (1 / dimension)), max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent vertex with minimal cost + collision free edge\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                line_n2new = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_n2new):\n                    continue\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            dist_parent_to_new = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + dist_parent_to_new\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if better path is found and collision free\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                line_new2near = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_new2near):\n                    continue\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if cost_new_to_near < q_near.cost:\n                    old_parent = next(iter(q_near.parents), None)\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = None\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 178, in _find_path_internal\n  File \"<string>\", line 65, in _informed_sample\n  File \"<string>\", line 63, in dist\nAttributeError: 'Point' object has no attribute 'to_tensor'\n"
     }
}
{
     "operator": "m3",
     "algorithm": "An improved sample-based path planning algorithm inspired by RRT*, \n    combining fast exploration with path quality optimization and robustness enhancements. \n    It uses adaptive sampling biased toward the goal to accelerate convergence, \n    rewiring for better path smoothness and shorter cost, \n    and early termination if the path is found or time limit exceeded. \n    The algorithm incorporates goal bias, dynamic neighborhood radius based on iteration count, \n    and motion validation with collision checking to ensure valid paths, \n    aiming to improve planning efficiency, success rate, and path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new = Vertex(Point.from_tensor(new_pos_tensor), store_connectivity=True)\n        return q_new\n\n    def _get_random_sample(self, goal_sample_rate=0.15) -> Point:\n        # Bias sampling with a probability towards the goal to improve convergence\n        if np.random.rand() < goal_sample_rate:\n            return self._get_grid().goal.position\n\n        size_vals = self._get_grid().size.values\n        while True:\n            rand_pos = tuple(np.random.randint(0, v) for v in size_vals)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return self._get_grid().get_distance(p1, p2)\n\n    def _neighbor_radius(self, iteration: int, c_max: float = 50.0) -> float:\n        # Dynamic radius shrinking over iterations for rewiring neighborhood\n        gamma = c_max\n        n = max(1, iteration)\n        radius = min(gamma * ((np.log(n) / n) ** 0.5), c_max)\n        return max(5.0, radius)  # Ensure minimum neighborhood radius\n\n    def _choose_parent(self, neighbors: list, q_new: Vertex) -> Vertex:\n        best_parent = None\n        best_cost = float('inf')\n        for neighbor in neighbors:\n            dist = self._distance(neighbor.position, q_new.position)\n            cost_through_neighbor = (neighbor.cost if neighbor.cost is not None else 0) + dist\n            if cost_through_neighbor < best_cost:\n                # Check if path from neighbor to q_new is collision free\n                line_seq = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                best_parent = neighbor\n                best_cost = cost_through_neighbor\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        for neighbor in neighbors:\n            if neighbor == q_new or neighbor.parents == {q_new}:\n                continue\n            dist = self._distance(q_new.position, neighbor.position)\n            new_cost = (q_new.cost if q_new.cost is not None else 0) + dist\n            if neighbor.cost is None or new_cost < neighbor.cost:\n                line_seq = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove old parent edges\n                    for p in set(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            # Choose parent with minimal cost to trace back\n            parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Animate path from start to goal\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist = 15.0\n        max_iterations = 15000\n        start_time = time()\n\n        # Assign start cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for it in range(1, max_iterations + 1):\n            if time() - start_time > 60:\n                # Fail gracefully if exceeds time limit\n                break\n\n            q_sample = self._get_random_sample(goal_sample_rate=0.2)\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new.position == q_near.position:\n                continue\n\n            # Validate motion\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Neighborhood search for rewiring\n            radius = self._neighbor_radius(it, c_max=max_dist*2)\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            if not neighbors:\n                neighbors = [q_near]\n\n            # Choose best parent among neighbors\n            best_parent = self._choose_parent(neighbors, q_new)\n            if best_parent is None:\n                continue\n\n            # Add edge from best parent to q_new and set cost\n            self._graph.add_edge(best_parent, q_new)\n            q_new.cost = (best_parent.cost if best_parent.cost is not None else 0) + self._distance(best_parent.position, q_new.position)\n\n            # Insert q_new into root vertices for graph expansion\n            self._graph.root_vertices.append(q_new)\n\n            # Rewire neighbors to optimize paths\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new is close enough to goal within goal radius bounds\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex with edge and extract path\n                goal_vertex = self._graph.root_vertex_goal\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_vertex.cost = (q_new.cost if q_new.cost is not None else 0) + self._distance(q_new.position, goal_vertex.position)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 133, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "e2",
     "algorithm": "This is a hybrid Adaptive Informed RRT* inspired algorithm with enhanced performance improvements.\n    It combines:\n    - Adaptive ellipsoidal informed sampling focused around the current best solution to improve planning efficiency,\n      drastically reducing unnecessary explorations.\n    - Adaptive radius rewiring for efficient parent selection and graph rewiring to obtain optimal paths.\n    - Bidirectional cost-based parent choosing and edge rewiring for better path quality.\n    - Post-processing path smoothing (shortcutting) for enhanced path smoothness.\n    - Timeout handling to gracefully fail if time exceeds 60 seconds.\n    Overall, it improves success rate, reduces path length and search time, and produces smoother paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: Optional[float]\n    _best_goal_vertex: Optional[Vertex]\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        grid = self._get_grid()\n        self._dimension = grid.size.n_dim\n        self._max_dist = float(max(grid.size.values)) / 10.0\n        self._lambda_rrt_star = 40.0\n        self._max_radius = max(grid.size.values) / 3\n        start_vertex = Vertex(grid.agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(grid.goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._timeout = 60.0\n        self._start_time = 0.0\n        self._best_cost = None\n        self._best_goal_vertex = None\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _uniform_sample(self) -> Point:\n        grid = self._get_grid()\n        while True:\n            coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _ellipsoidal_sample(self) -> Point:\n        grid = self._get_grid()\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        c_best = torch.tensor(self._best_cost)\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best < c_min:\n            c_best = c_min + 1e-3\n\n        center = (start + goal) / 2.0\n        foci_vec = (goal - start)\n        e_axis = foci_vec / torch.norm(foci_vec)\n\n        if self._dimension == 2:\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])  # Perpendicular in 2D\n        elif self._dimension == 3:\n            z_axis = e_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n        else:\n            return self._uniform_sample()\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0\n\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        elif self._dimension == 3:\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n        else:\n            return self._uniform_sample()\n\n        while True:\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u > 1e-6:\n                break\n        unit_ball_sample = u / norm_u * (torch.rand(1).item() ** (1.0 / self._dimension))\n\n        sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n\n        coords = []\n        for i in range(self._dimension):\n            val = float(torch.clamp(sample_in_ellipsoid[i], 0, grid.size[i] - 1).round())\n            coords.append(int(val))\n        sample_point = Point(*coords)\n\n        if grid.is_agent_valid_pos(sample_point):\n            return sample_point\n        else:\n            return self._uniform_sample()\n\n    def _informed_sample(self) -> Point:\n        if self._best_cost is None:\n            return self._uniform_sample()\n        else:\n            return self._ellipsoidal_sample()\n\n    def _calc_rewire_radius(self) -> float:\n        card_v = float(self._graph.size + 1)\n        log_card_v = max(torch.log(torch.tensor(card_v)).item(), 1e-6)\n        radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1.0 / self._dimension)), self._max_radius)\n        return radius\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Tuple[Optional[Vertex], float]:\n        c_min = float('inf')\n        q_min = None\n        grid = self._get_grid()\n        for q_near in neighbors:\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost = q_near.cost + self._dist(q_near.position, q_new.position)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n        return q_min, c_min\n\n    def _shortcut_path(self, path: List[Vertex], max_attempts=40) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = grid.get_line_sequence(p_i, p_j)\n            if grid.is_valid_line_sequence(line_seq):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        path = self._shortcut_path(path, max_attempts=40)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_coords = [int(round(float(c))) for c in new_pos_tensor]\n        new_pos = Point(*new_coords)\n        return Vertex(new_pos)\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n        max_iterations = 15000\n        radius = self._calc_rewire_radius()\n        grid = self._get_grid()\n\n        for iteration in range(max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Path search failed due to timeout\n                return\n\n            q_sample = self._informed_sample()\n\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                if not grid.is_valid_line_sequence(line_seq_rewire):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                if cost_through_new < q_near.cost:\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if (self._best_cost is None) or (possible_cost < self._best_cost):\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 221, in _find_path_internal\n  File \"<string>\", line 139, in _informed_sample\n  File \"<string>\", line 77, in _uniform_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 149, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "e1",
     "algorithm": "parent.cost + edge_cost",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n        self._max_dist = 15.0      # Max edge extension length\n        self._goal_sample_rate = 0.1  # Probability of sampling goal directly\n        self._rewire_radius = 20.0    # Radius for rewiring neighbors\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return self._get_grid().get_distance(p1, p2)\n\n    def _steer(self, from_v: Vertex, to_p: Point, max_dist: float) -> Vertex:\n        dir_vec = to_p.to_tensor() - from_v.position.to_tensor()\n        dist = dir_vec.norm().item()\n        if dist <= max_dist:\n            return Vertex(to_p)\n        dir_norm = dir_vec / dist\n        new_pos_tensor = from_v.position.to_tensor() + max_dist * dir_norm\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _get_random_sample(self, best_cost: Optional[float]) -> Point:\n        \"\"\"\n        Sample points uniformly in map, but when best_cost is known, sample within informed elliptical region.\n        With certain probability sample goal directly (goal biasing).\n        \"\"\"\n        grid = self._get_grid()\n        size = grid.size.values\n        start = grid.agent.position\n        goal = grid.goal.position\n\n        # Goal biasing\n        if np.random.random() < self._goal_sample_rate:\n            return goal\n\n        if best_cost is None or best_cost == float('inf'):\n            # Uniform random sampling in valid space\n            while True:\n                rand_coords = np.random.uniform(0, size, len(size))\n                sample = Point(*rand_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling within ellipsoid defined by start-goal and best cost\n        c_best = best_cost\n        c_min = self._distance(start, goal)\n        if c_best < c_min:\n            # Impossible, fallback uniform sampling\n            while True:\n                rand_coords = np.random.uniform(0, size, len(size))\n                sample = Point(*rand_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Define ellipsoid in 2D or 3D\n        # Translate points so that start is at origin\n        start_tensor = start.to_tensor()\n        goal_tensor = goal.to_tensor()\n        center = (start_tensor + goal_tensor) / 2\n        diff = (goal_tensor - start_tensor)\n        diff_len = diff.norm().item()\n\n        # Define rotation matrix to align x-axis with diff vector\n        if len(diff) == 2:\n            # 2D case\n            theta = torch.atan2(diff[1], diff[0])\n            cos_th = torch.cos(theta)\n            sin_th = torch.sin(theta)\n            R = torch.tensor([[cos_th, -sin_th], [sin_th, cos_th]])\n        else:\n            # Higher-dim case: use diff normalized + Gram-Schmidt with identity basis (simplification)\n            # To avoid heavy math, fallback to uniform sampling\n            while True:\n                rand_coords = np.random.uniform(0, size, len(size))\n                sample = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Radii of ellipsoid axes\n        a = c_best / 2\n        b = (c_best**2 - c_min**2)**0.5 / 2 if c_best**2 - c_min**2 > 0 else 0\n        axes = torch.tensor([a, b])\n\n        count_attempts = 0\n        while True:\n            count_attempts += 1\n            # Sample random point in unit circle ellipse\n            r = np.random.rand()**0.5  # sqrt to ensure uniform in circle\n            angle = np.random.uniform(0, 2 * np.pi)\n            x = r * np.cos(angle)\n            y = r * np.sin(angle)\n            sample_unit = torch.tensor([x, y]) * axes\n\n            # Rotate back and translate\n            sample_global = torch.matmul(R, sample_unit) + center\n\n            candidate = Point(*sample_global.tolist())\n\n            # Check if within bounds\n            if all(0 <= coord < dim for coord, dim in zip(candidate.values, size)):\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n            # To prevent infinite loop in pathological maps\n            if count_attempts > 500:\n                # fallback uniform sampling\n                while True:\n                    rand_coords = np.random.uniform(0, size, len(size))\n                    sample = Point(*rand_coords)\n                    if self._get_grid().is_agent_valid_pos(sample):\n                        return sample\n\n    def _extract_path(self, vertex: Vertex) -> List[Vertex]:\n        path: List[Vertex] = []\n        current = vertex\n        while True:\n            path.append(current)\n            if not current.parents:\n                break\n            # Greedily pick parent with minimal cost\n            current = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n        path.reverse()\n        return path\n\n    def _update_cost(self, vertex: Vertex) -> None:\n        # Cost = min over parents {parent.cost + edge_cost}\n        grid = self._get_grid()\n        min_cost = float('inf')\n        best_parent = None\n        for p in vertex.parents:\n            if p.cost is None:\n                continue\n            cost_candidate = p.cost + grid.get_movement_cost(p.position, vertex.position)\n            if cost_candidate < min_cost:\n                min_cost = cost_candidate\n                best_parent = p\n        if best_parent is not None:\n            vertex.cost = min_cost\n            # Remove other parents edges to keep tree structure closer to a tree (optional)\n            # But we keep all parents for line of sight rewiring possibility\n            # Remove edges to non-best parents (safe removal if edges_removable is True)\n            if self._graph.edges_removable:\n                to_remove = vertex.parents - {best_parent}\n                for rem_parent in to_remove:\n                    self._graph.remove_edge(rem_parent, vertex)\n            # Ensure edge from best_parent exist (redundant but safe)\n            self._graph.add_edge(best_parent, vertex)\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"\n        For each neighbor, check if going through q_new improves cost.\n        If yes and line-of-sight is valid, rewire.\n        \"\"\"\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor == q_new:\n                continue\n            if neighbor.cost is None:\n                continue\n            weight_through_new = q_new.cost + grid.get_movement_cost(q_new.position, neighbor.position)\n            if weight_through_new + 1e-7 < neighbor.cost:  # small epsilon\n                line_seq = grid.get_line_sequence(q_new.position, neighbor.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Rewire edge\n                    # Remove old edge(s) parent->neighbor\n                    for parent in list(neighbor.parents):\n                        self._graph.remove_edge(parent, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = weight_through_new\n                    # Propagate cost update recursively in neighborhood\n                    self._propagate_cost_update(neighbor)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        grid = self._get_grid()\n        for child in vertex.children:\n            old_cost = child.cost\n            new_cost = vertex.cost + grid.get_movement_cost(vertex.position, child.position)\n            if new_cost + 1e-7 < (old_cost if old_cost is not None else float('inf')):\n                child.cost = new_cost\n                self._propagate_cost_update(child)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        max_iterations = 15000\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n\n        best_goal_vertex: Optional[Vertex] = None\n        best_cost = float('inf')\n\n        for iteration in range(max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 60.0:  # Timeout guard 60 seconds\n                # Fail gracefully (no path found within time)\n                break\n\n            # Sample with goal bias and informed sampling\n            sample = self._get_random_sample(best_cost if best_goal_vertex else None)\n\n            # Find nearest vertex from start tree\n            q_near = self._graph.get_nearest_vertex([start_vertex], sample)\n\n            if q_near.position == sample:\n                continue\n\n            q_new = self._steer(q_near, sample, self._max_dist)\n\n            # Validate path segment between q_near and q_new with line sequence check\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Create new vertex and set cost w.r.t q_near\n            if q_new.position == q_near.position:\n                continue\n\n            # Construct q_new Vertex only once confirmed valid\n            # Check if q_new is already in graph (avoid duplicates) - not mandatory but safer\n            # Add edge q_near->q_new tentatively\n            q_new.cost = q_near.cost + grid.get_movement_cost(q_near.position, q_new.position)\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire neighbors within radius for better path\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n            # Remove self from neighbors if present\n            neighbors = [v for v in neighbors if v != q_new]\n\n            # Find best parent for q_new among neighbors who can connect with valid path and minimal cost\n            min_cost = q_new.cost\n            best_parent = q_near\n            for neighbor in neighbors:\n                # Check line sequence from neighbor to q_new\n                line_seq_n = grid.get_line_sequence(neighbor.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_seq_n):\n                    continue\n                cost_candidate = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new.position)\n                if cost_candidate < min_cost:\n                    min_cost = cost_candidate\n                    best_parent = neighbor\n\n            if best_parent != q_near:\n                # Reassign parent edges accordingly\n                self._graph.remove_edge(q_near, q_new)\n                self._graph.add_edge(best_parent, q_new)\n                q_new.cost = min_cost\n\n            # Rewire neighbors through q_new if beneficial\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new is within goal radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Construct goal vertex with updated parentage\n                goal_dummy = Vertex(grid.goal.position)\n                line_seq_to_goal = grid.get_line_sequence(q_new.position, goal_dummy.position)\n                if grid.is_valid_line_sequence(line_seq_to_goal):\n                    goal_dummy.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_dummy.position)\n                    self._graph.add_edge(q_new, goal_dummy)\n                    if goal_dummy.cost < best_cost:\n                        best_cost = goal_dummy.cost\n                        best_goal_vertex = goal_dummy\n\n            # Visual/keyframe update\n            self.key_frame()\n\n        # If goal found, extract and move agent along path smoothly\n        if best_goal_vertex is not None:\n            path_vertices = self._extract_path(best_goal_vertex)\n            # Animate agent move along path\n            for v in path_vertices:\n                self.move_agent(v.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 244, in _find_path_internal\n  File \"<string>\", line 85, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 149, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m3",
     "algorithm": "An improved sample-based path planning algorithm inspired by RRT*, \n    combining fast exploration with path quality optimization and robustness enhancements. \n    It uses adaptive sampling biased toward the goal to accelerate convergence, \n    rewiring for better path smoothness and shorter cost, \n    and early termination if the path is found or time limit exceeded. \n    The algorithm incorporates goal bias, dynamic neighborhood radius based on iteration count, \n    and motion validation with collision checking to ensure valid paths, \n    aiming to improve planning efficiency, success rate, and path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        # Convert float coordinates back to int coordinates to keep grid consistency\n        new_pos_tuple = tuple(int(round(v)) for v in new_pos_tensor.tolist())\n        q_new = Vertex(Point(*new_pos_tuple), store_connectivity=True)\n        return q_new\n\n    def _get_random_sample(self, goal_sample_rate=0.15) -> Point:\n        # Bias sampling with a probability towards the goal to improve convergence\n        if np.random.rand() < goal_sample_rate:\n            return self._get_grid().goal.position\n\n        size_vals = self._get_grid().size.values\n        while True:\n            rand_pos = tuple(np.random.randint(0, v) for v in size_vals)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return self._get_grid().get_distance(p1, p2)\n\n    def _neighbor_radius(self, iteration: int, c_max: float = 50.0) -> float:\n        # Dynamic radius shrinking over iterations for rewiring neighborhood\n        gamma = c_max\n        n = max(1, iteration)\n        radius = min(gamma * ((np.log(n) / n) ** 0.5), c_max)\n        return max(5.0, radius)  # Ensure minimum neighborhood radius\n\n    def _choose_parent(self, neighbors: list, q_new: Vertex) -> Vertex:\n        best_parent = None\n        best_cost = float('inf')\n        for neighbor in neighbors:\n            dist = self._distance(neighbor.position, q_new.position)\n            cost_through_neighbor = (neighbor.cost if neighbor.cost is not None else 0) + dist\n            if cost_through_neighbor < best_cost:\n                # Check if path from neighbor to q_new is collision free\n                line_seq = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                best_parent = neighbor\n                best_cost = cost_through_neighbor\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        for neighbor in neighbors:\n            if neighbor == q_new or neighbor.parents == {q_new}:\n                continue\n            dist = self._distance(q_new.position, neighbor.position)\n            new_cost = (q_new.cost if q_new.cost is not None else 0) + dist\n            if neighbor.cost is None or new_cost < neighbor.cost:\n                line_seq = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove old parent edges\n                    for p in set(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            # Choose parent with minimal cost to trace back\n            parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Animate path from start to goal\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist = 15.0\n        max_iterations = 15000\n        start_time = time()\n\n        # Assign start cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for it in range(1, max_iterations + 1):\n            if time() - start_time > 60:\n                # Fail gracefully if exceeds time limit\n                break\n\n            q_sample = self._get_random_sample(goal_sample_rate=0.2)\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new.position == q_near.position:\n                continue\n\n            # Validate motion\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Neighborhood search for rewiring\n            radius = self._neighbor_radius(it, c_max=max_dist*2)\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            if not neighbors:\n                neighbors = [q_near]\n\n            # Choose best parent among neighbors\n            best_parent = self._choose_parent(neighbors, q_new)\n            if best_parent is None:\n                continue\n\n            # Add edge from best parent to q_new and set cost\n            self._graph.add_edge(best_parent, q_new)\n            q_new.cost = (best_parent.cost if best_parent.cost is not None else 0) + self._distance(best_parent.position, q_new.position)\n\n            # Insert q_new into root vertices for graph expansion\n            self._graph.root_vertices.append(q_new)\n\n            # Rewire neighbors to optimize paths\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new is close enough to goal within goal radius bounds\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex with edge and extract path\n                goal_vertex = self._graph.root_vertex_goal\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_vertex.cost = (q_new.cost if q_new.cost is not None else 0) + self._distance(q_new.position, goal_vertex.position)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 134, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "e2",
     "algorithm": "This is a hybrid Adaptive Informed RRT* inspired algorithm with enhanced performance improvements.\n    It combines:\n    - Adaptive ellipsoidal informed sampling focused around the current best solution to improve planning efficiency,\n      drastically reducing unnecessary explorations.\n    - Adaptive radius rewiring for efficient parent selection and graph rewiring to obtain optimal paths.\n    - Bidirectional cost-based parent choosing and edge rewiring for better path quality.\n    - Post-processing path smoothing (shortcutting) for enhanced path smoothness.\n    - Timeout handling to gracefully fail if time exceeds 60 seconds.\n    Overall, it improves success rate, reduces path length and search time, and produces smoother paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: Optional[float]\n    _best_goal_vertex: Optional[Vertex]\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        grid = self._get_grid()\n        self._dimension = grid.size.n_dim\n        self._max_dist = float(max(grid.size.values)) / 10.0\n        self._lambda_rrt_star = 40.0\n        self._max_radius = max(grid.size.values) / 3\n        start_vertex = Vertex(grid.agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(grid.goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._timeout = 60.0\n        self._start_time = 0.0\n        self._best_cost = None\n        self._best_goal_vertex = None\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _uniform_sample(self) -> Point:\n        grid = self._get_grid()\n        while True:\n            coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n            # Ensure coords are int, no floats\n            coords_int = [int(c) for c in coords]\n            sample = Point(*coords_int)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _ellipsoidal_sample(self) -> Point:\n        grid = self._get_grid()\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        c_best = torch.tensor(self._best_cost)\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best < c_min:\n            c_best = c_min + 1e-3\n\n        center = (start + goal) / 2.0\n        foci_vec = (goal - start)\n        e_axis = foci_vec / torch.norm(foci_vec)\n\n        if self._dimension == 2:\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])  # Perpendicular in 2D\n        elif self._dimension == 3:\n            z_axis = e_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n        else:\n            return self._uniform_sample()\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0\n\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        elif self._dimension == 3:\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n        else:\n            return self._uniform_sample()\n\n        while True:\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u > 1e-6:\n                break\n        unit_ball_sample = u / norm_u * (torch.rand(1).item() ** (1.0 / self._dimension))\n\n        sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n\n        coords = []\n        for i in range(self._dimension):\n            val = float(torch.clamp(sample_in_ellipsoid[i], 0, grid.size[i] - 1).round())\n            coords.append(int(val))\n        sample_point = Point(*coords)\n\n        if grid.is_agent_valid_pos(sample_point):\n            return sample_point\n        else:\n            return self._uniform_sample()\n\n    def _informed_sample(self) -> Point:\n        if self._best_cost is None:\n            return self._uniform_sample()\n        else:\n            return self._ellipsoidal_sample()\n\n    def _calc_rewire_radius(self) -> float:\n        card_v = float(self._graph.size + 1)\n        log_card_v = max(torch.log(torch.tensor(card_v)).item(), 1e-6)\n        radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1.0 / self._dimension)), self._max_radius)\n        return radius\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Tuple[Optional[Vertex], float]:\n        c_min = float('inf')\n        q_min = None\n        grid = self._get_grid()\n        for q_near in neighbors:\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost = q_near.cost + self._dist(q_near.position, q_new.position)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n        return q_min, c_min\n\n    def _shortcut_path(self, path: List[Vertex], max_attempts=40) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = grid.get_line_sequence(p_i, p_j)\n            if grid.is_valid_line_sequence(line_seq):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        path = self._shortcut_path(path, max_attempts=40)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            # Ensure point coordinates are int\n            coords = [int(round(float(c))) for c in q_sample.values]\n            new_pos = Point(*coords)\n            return Vertex(new_pos)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_coords = [int(round(float(c))) for c in new_pos_tensor]\n        new_pos = Point(*new_coords)\n        return Vertex(new_pos)\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n        max_iterations = 15000\n        radius = self._calc_rewire_radius()\n        grid = self._get_grid()\n\n        for iteration in range(max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Path search failed due to timeout\n                return\n\n            q_sample = self._informed_sample()\n\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                if not grid.is_valid_line_sequence(line_seq_rewire):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                if cost_through_new < q_near.cost:\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if (self._best_cost is None) or (possible_cost < self._best_cost):\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 226, in _find_path_internal\n  File \"<string>\", line 141, in _informed_sample\n  File \"<string>\", line 79, in _uniform_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 149, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m3",
     "algorithm": "An improved sample-based path planning algorithm inspired by RRT*, \n    combining fast exploration with path quality optimization and robustness enhancements. \n    It uses adaptive sampling biased toward the goal to accelerate convergence, \n    rewiring for better path smoothness and shorter cost, \n    and early termination if the path is found or time limit exceeded. \n    The algorithm incorporates goal bias, dynamic neighborhood radius based on iteration count, \n    and motion validation with collision checking to ensure valid paths, \n    aiming to improve planning efficiency, success rate, and path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        # Convert float coordinates back to int coordinates to keep grid consistency\n        new_pos_tuple = tuple(int(round(v)) for v in new_pos_tensor.tolist())\n        q_new = Vertex(Point(*new_pos_tuple), store_connectivity=True)\n        return q_new\n\n    def _get_random_sample(self, goal_sample_rate=0.15) -> Point:\n        # Bias sampling with a probability towards the goal to improve convergence\n        if np.random.rand() < goal_sample_rate:\n            return self._get_grid().goal.position\n\n        size_vals = self._get_grid().size.values\n        while True:\n            rand_pos = tuple(np.random.randint(0, v) for v in size_vals)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return self._get_grid().get_distance(p1, p2)\n\n    def _neighbor_radius(self, iteration: int, c_max: float = 50.0) -> float:\n        # Dynamic radius shrinking over iterations for rewiring neighborhood\n        gamma = c_max\n        n = max(1, iteration)\n        radius = min(gamma * ((np.log(n) / n) ** 0.5), c_max)\n        return max(5.0, radius)  # Ensure minimum neighborhood radius\n\n    def _choose_parent(self, neighbors: list, q_new: Vertex) -> Vertex:\n        best_parent = None\n        best_cost = float('inf')\n        for neighbor in neighbors:\n            dist = self._distance(neighbor.position, q_new.position)\n            cost_through_neighbor = (neighbor.cost if neighbor.cost is not None else 0) + dist\n            if cost_through_neighbor < best_cost:\n                # Check if path from neighbor to q_new is collision free\n                line_seq = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                best_parent = neighbor\n                best_cost = cost_through_neighbor\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        for neighbor in neighbors:\n            if neighbor == q_new or neighbor.parents == {q_new}:\n                continue\n            dist = self._distance(q_new.position, neighbor.position)\n            new_cost = (q_new.cost if q_new.cost is not None else 0) + dist\n            if neighbor.cost is None or new_cost < neighbor.cost:\n                line_seq = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove old parent edges\n                    for p in set(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            # Choose parent with minimal cost to trace back\n            parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Animate path from start to goal\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist = 15.0\n        max_iterations = 15000\n        start_time = time()\n\n        # Assign start cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for it in range(1, max_iterations + 1):\n            if time() - start_time > 60:\n                # Fail gracefully if exceeds time limit\n                break\n\n            q_sample = self._get_random_sample(goal_sample_rate=0.2)\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new.position == q_near.position:\n                continue\n\n            # Validate motion\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Neighborhood search for rewiring\n            radius = self._neighbor_radius(it, c_max=max_dist*2)\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n            if not neighbors:\n                neighbors = [q_near]\n\n            # Choose best parent among neighbors\n            best_parent = self._choose_parent(neighbors, q_new)\n            if best_parent is None:\n                continue\n\n            # Add edge from best parent to q_new and set cost\n            self._graph.add_edge(best_parent, q_new)\n            q_new.cost = (best_parent.cost if best_parent.cost is not None else 0) + self._distance(best_parent.position, q_new.position)\n\n            # Insert q_new into root vertices for graph expansion\n            self._graph.root_vertices.append(q_new)\n\n            # Rewire neighbors to optimize paths\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new is close enough to goal within goal radius bounds\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex with edge and extract path\n                goal_vertex = self._graph.root_vertex_goal\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_vertex.cost = (q_new.cost if q_new.cost is not None else 0) + self._distance(q_new.position, goal_vertex.position)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 134, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "e1",
     "algorithm": "parent.cost + edge_cost",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n        self._max_dist = 15.0      # Max edge extension length\n        self._goal_sample_rate = 0.1  # Probability of sampling goal directly\n        self._rewire_radius = 20.0    # Radius for rewiring neighbors\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return self._get_grid().get_distance(p1, p2)\n\n    def _steer(self, from_v: Vertex, to_p: Point, max_dist: float) -> Vertex:\n        dir_vec = to_p.to_tensor() - from_v.position.to_tensor()\n        dist = dir_vec.norm().item()\n        if dist <= max_dist:\n            return Vertex(to_p)\n        dir_norm = dir_vec / dist\n        new_pos_tensor = from_v.position.to_tensor() + max_dist * dir_norm\n        # Convert tensor coordinates to integer for valid dense_map indexing\n        new_pos_int = [int(round(coord.item())) for coord in new_pos_tensor]\n        new_pos = Point(*new_pos_int)\n        return Vertex(new_pos)\n\n    def _get_random_sample(self, best_cost: Optional[float]) -> Point:\n        \"\"\"\n        Sample points uniformly in map, but when best_cost is known, sample within informed elliptical region.\n        With certain probability sample goal directly (goal biasing).\n        \"\"\"\n        grid = self._get_grid()\n        size = grid.size.values\n        start = grid.agent.position\n        goal = grid.goal.position\n\n        # Goal biasing\n        if np.random.random() < self._goal_sample_rate:\n            # Return integer position for goal\n            goal_int_pos = Point(int(round(goal.x)), int(round(goal.y))) if goal.n_dim == 2 else Point(*[int(round(c)) for c in goal.values])\n            return goal_int_pos\n\n        if best_cost is None or best_cost == float('inf'):\n            # Uniform random sampling in valid space\n            while True:\n                rand_coords = np.random.uniform(0, size, len(size))\n                # Convert to integers by rounding\n                rand_coords_int = [int(round(c)) for c in rand_coords]\n                sample = Point(*rand_coords_int)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling within ellipsoid defined by start-goal and best cost\n        c_best = best_cost\n        c_min = self._distance(start, goal)\n        if c_best < c_min:\n            # Impossible, fallback uniform sampling\n            while True:\n                rand_coords = np.random.uniform(0, size, len(size))\n                rand_coords_int = [int(round(c)) for c in rand_coords]\n                sample = Point(*rand_coords_int)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Define ellipsoid in 2D or 3D\n        # Translate points so that start is at origin\n        start_tensor = start.to_tensor()\n        goal_tensor = goal.to_tensor()\n        center = (start_tensor + goal_tensor) / 2\n        diff = (goal_tensor - start_tensor)\n        diff_len = diff.norm().item()\n\n        # Define rotation matrix to align x-axis with diff vector\n        if len(diff) == 2:\n            # 2D case\n            theta = torch.atan2(diff[1], diff[0])\n            cos_th = torch.cos(theta)\n            sin_th = torch.sin(theta)\n            R = torch.tensor([[cos_th, -sin_th], [sin_th, cos_th]])\n        else:\n            # Higher-dim case: use diff normalized + Gram-Schmidt with identity basis (simplification)\n            # To avoid heavy math, fallback to uniform sampling\n            while True:\n                rand_coords = np.random.uniform(0, size, len(size))\n                rand_coords_int = [int(round(c)) for c in rand_coords]\n                sample = Point(*rand_coords_int)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Radii of ellipsoid axes\n        a = c_best / 2\n        b = (c_best**2 - c_min**2)**0.5 / 2 if c_best**2 - c_min**2 > 0 else 0\n        axes = torch.tensor([a, b])\n\n        count_attempts = 0\n        while True:\n            count_attempts += 1\n            # Sample random point in unit circle ellipse\n            r = np.random.rand()**0.5  # sqrt to ensure uniform in circle\n            angle = np.random.uniform(0, 2 * np.pi)\n            x = r * np.cos(angle)\n            y = r * np.sin(angle)\n            sample_unit = torch.tensor([x, y]) * axes\n\n            # Rotate back and translate\n            sample_global = torch.matmul(R, sample_unit) + center\n\n            # Convert to integer coordinates for map indexing:\n            sample_int_coords = [int(round(coord.item())) for coord in sample_global]\n\n            # Clip coordinates to bounds\n            sample_int_coords = [max(0, min(sample_int_coords[i], size[i]-1)) for i in range(len(size))]\n\n            candidate = Point(*sample_int_coords)\n\n            # Check if within bounds\n            if all(0 <= coord < dim for coord, dim in zip(candidate.values, size)):\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n            # To prevent infinite loop in pathological maps\n            if count_attempts > 500:\n                # fallback uniform sampling\n                while True:\n                    rand_coords = np.random.uniform(0, size, len(size))\n                    rand_coords_int = [int(round(c)) for c in rand_coords]\n                    sample = Point(*rand_coords_int)\n                    if self._get_grid().is_agent_valid_pos(sample):\n                        return sample\n\n    def _extract_path(self, vertex: Vertex) -> List[Vertex]:\n        path: List[Vertex] = []\n        current = vertex\n        while True:\n            path.append(current)\n            if not current.parents:\n                break\n            # Greedily pick parent with minimal cost\n            current = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n        path.reverse()\n        return path\n\n    def _update_cost(self, vertex: Vertex) -> None:\n        # Cost = min over parents {parent.cost + edge_cost}\n        grid = self._get_grid()\n        min_cost = float('inf')\n        best_parent = None\n        for p in vertex.parents:\n            if p.cost is None:\n                continue\n            cost_candidate = p.cost + grid.get_movement_cost(p.position, vertex.position)\n            if cost_candidate < min_cost:\n                min_cost = cost_candidate\n                best_parent = p\n        if best_parent is not None:\n            vertex.cost = min_cost\n            # Remove other parents edges to keep tree structure closer to a tree (optional)\n            # But we keep all parents for line of sight rewiring possibility\n            # Remove edges to non-best parents (safe removal if edges_removable is True)\n            if self._graph.edges_removable:\n                to_remove = vertex.parents - {best_parent}\n                for rem_parent in to_remove:\n                    self._graph.remove_edge(rem_parent, vertex)\n            # Ensure edge from best_parent exist (redundant but safe)\n            self._graph.add_edge(best_parent, vertex)\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"\n        For each neighbor, check if going through q_new improves cost.\n        If yes and line-of-sight is valid, rewire.\n        \"\"\"\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor == q_new:\n                continue\n            if neighbor.cost is None:\n                continue\n            weight_through_new = q_new.cost + grid.get_movement_cost(q_new.position, neighbor.position)\n            if weight_through_new + 1e-7 < neighbor.cost:  # small epsilon\n                line_seq = grid.get_line_sequence(q_new.position, neighbor.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Rewire edge\n                    # Remove old edge(s) parent->neighbor\n                    for parent in list(neighbor.parents):\n                        self._graph.remove_edge(parent, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = weight_through_new\n                    # Propagate cost update recursively in neighborhood\n                    self._propagate_cost_update(neighbor)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        grid = self._get_grid()\n        for child in vertex.children:\n            old_cost = child.cost\n            new_cost = vertex.cost + grid.get_movement_cost(vertex.position, child.position)\n            if new_cost + 1e-7 < (old_cost if old_cost is not None else float('inf')):\n                child.cost = new_cost\n                self._propagate_cost_update(child)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        max_iterations = 15000\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n\n        best_goal_vertex: Optional[Vertex] = None\n        best_cost = float('inf')\n\n        for iteration in range(max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 60.0:  # Timeout guard 60 seconds\n                # Fail gracefully (no path found within time)\n                break\n\n            # Sample with goal bias and informed sampling\n            sample = self._get_random_sample(best_cost if best_goal_vertex else None)\n\n            # Find nearest vertex from start tree\n            q_near = self._graph.get_nearest_vertex([start_vertex], sample)\n\n            if q_near.position == sample:\n                continue\n\n            q_new = self._steer(q_near, sample, self._max_dist)\n\n            # Validate path segment between q_near and q_new with line sequence check\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Create new vertex and set cost w.r.t q_near\n            if q_new.position == q_near.position:\n                continue\n\n            # Construct q_new Vertex only once confirmed valid\n            # Check if q_new is already in graph (avoid duplicates) - not mandatory but safer\n            # Add edge q_near->q_new tentatively\n            q_new.cost = q_near.cost + grid.get_movement_cost(q_near.position, q_new.position)\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire neighbors within radius for better path\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n            # Remove self from neighbors if present\n            neighbors = [v for v in neighbors if v != q_new]\n\n            # Find best parent for q_new among neighbors who can connect with valid path and minimal cost\n            min_cost = q_new.cost\n            best_parent = q_near\n            for neighbor in neighbors:\n                # Check line sequence from neighbor to q_new\n                line_seq_n = grid.get_line_sequence(neighbor.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_seq_n):\n                    continue\n                cost_candidate = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new.position)\n                if cost_candidate < min_cost:\n                    min_cost = cost_candidate\n                    best_parent = neighbor\n\n            if best_parent != q_near:\n                # Reassign parent edges accordingly\n                self._graph.remove_edge(q_near, q_new)\n                self._graph.add_edge(best_parent, q_new)\n                q_new.cost = min_cost\n\n            # Rewire neighbors through q_new if beneficial\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new is within goal radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Construct goal vertex with updated parentage\n                goal_dummy = Vertex(grid.goal.position)\n                line_seq_to_goal = grid.get_line_sequence(q_new.position, goal_dummy.position)\n                if grid.is_valid_line_sequence(line_seq_to_goal):\n                    goal_dummy.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_dummy.position)\n                    self._graph.add_edge(q_new, goal_dummy)\n                    if goal_dummy.cost < best_cost:\n                        best_cost = goal_dummy.cost\n                        best_goal_vertex = goal_dummy\n\n            # Visual/keyframe update\n            self.key_frame()\n\n        # If goal found, extract and move agent along path smoothly\n        if best_goal_vertex is not None:\n            path_vertices = self._extract_path(best_goal_vertex)\n            # Animate agent move along path\n            for v in path_vertices:\n                self.move_agent(v.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 259, in _find_path_internal\n  File \"<string>\", line 91, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 149, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m2",
     "algorithm": "Improved Adaptive Informed RRT* (IAIRRT*):\n    This planner enhances the previous AIRRT* by tuning sampling, rewiring, and smoothing parameters dynamically,\n    and introducing a two-stage informed sampling with iterative radius shrinking and adaptive rewiring radius \n    based on graph density. It also integrates a lightweight heuristic cost-to-go to bias rewiring towards promising nodes.\n\n    Key improvements:\n    - Dynamic max_dist: adjusts step size based on iteration progress and map size for efficient exploration early\n      and finer resolution near solution.\n    - Adaptive rewiring radius scaled by graph size and dimension to balance connectivity and computational load.\n    - Heuristic incorporated in choosing parent and rewiring to favor vertices closer to goal.\n    - Early rejection of samples too far from best path estimate to focus on promising ellipsoid regions.\n    - Path smoothing enhanced with adaptive shortcutting including post solution extraction.\n    - Additional timeout check flags failure explicitly after 60 seconds.\n    - Quantized sample snapping to integer grid with fallback ensures valid sampling.\n\n    This results in better path quality (shorter, smoother), higher success rates, and reduced search times \n    especially for larger or cluttered maps.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _dimension: int\n    _max_dist_initial: float\n    _max_dist_min: float\n    _lambda_rrt_star: float\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: float | None\n    _best_goal_vertex: Vertex | None\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        size_vals = self._get_grid().size.values\n        self._dimension = self._get_grid().size.n_dim\n\n        # Adaptive max_dist scales initially larger for faster exploration, then reduces\n        self._max_dist_initial = float(max(size_vals)) / 8.0\n        self._max_dist_min = float(max(size_vals)) / 40.0\n\n        self._max_dist = self._max_dist_initial\n        self._lambda_rrt_star = 35.0  # tuned constant for rewiring radius (slightly smaller)\n        self._max_radius = max(size_vals) / 4  # max rewiring radius reduced for efficiency\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        self._start_time = 0.0\n        self._timeout = 60.0\n        self._best_cost = None\n        self._best_goal_vertex = None\n\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _heuristic(self, p: Point) -> float:\n        # Euclidean distance from p to goal as heuristic cost-to-go\n        return self._dist(p, self._graph.root_vertex_goal.position)\n\n    def _informed_sample(self) -> Point:\n        if self._best_cost is None:\n            return self._uniform_sample()\n        # Additional early rejection radius factor to shrink ellipsoid\n        # Shrink best cost gradually to force tighter sampling as iterations increase\n        shrink_factor = max(0.7, 1.0 - (time.time() - self._start_time) / self._timeout)\n        adjusted_cost = self._best_cost * shrink_factor\n        return self._ellipsoidal_sample(adjusted_cost)\n\n    def _uniform_sample(self) -> Point:\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _ellipsoidal_sample(self, c_best_override=None) -> Point:\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n\n        c_best = torch.tensor(c_best_override if c_best_override is not None else self._best_cost)\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best < c_min:\n            c_best = c_min + 1e-3\n\n        center = (start + goal) / 2.0\n        foci_vec = goal - start\n        norm_foci = torch.norm(foci_vec)\n        e_axis = foci_vec / norm_foci\n\n        if self._dimension == 2:\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])\n        elif self._dimension == 3:\n            z_axis = e_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n        else:\n            return self._uniform_sample()\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        else:\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n\n        for _ in range(20):  # max attempts to find valid sample inside ellipsoid\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u < 1e-6:\n                continue\n            unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n\n            sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n            # Clamp and round for grid conformity\n            sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, self._get_grid().size[i] - 1).round()))\n                             for i in range(self._dimension)]\n            sample_point = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # Fallback if no valid ellipsoidal sample found\n        return self._uniform_sample()\n\n    def _calc_rewire_radius(self) -> float:\n        card_v = torch.tensor(float(self._graph.size + 1))\n        log_v = torch.log(card_v)\n        # Adaptive radius shrinks as number of vertices grows, clipped by max radius\n        radius = min(self._lambda_rrt_star * ((log_v / card_v) ** (1.0 / self._dimension)), self._max_radius)\n        return radius.item()\n\n    def _choose_parent(self, neighbors: list[Vertex], q_new: Vertex) -> tuple[Vertex | None, float]:\n        c_min = float('inf')\n        q_min = None\n        goal_pos = self._graph.root_vertex_goal.position\n        for q_near in neighbors:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost_from_start = q_near.cost + self._dist(q_near.position, q_new.position)\n            # Incorporate heuristic cost-to-go for biased cost\n            heuristic_cost = self._dist(q_new.position, goal_pos)\n            total_cost = cost_from_start + heuristic_cost * 0.5  # weight heuristic less than cost-from-start\n            if total_cost < c_min:\n                c_min = cost_from_start  # only set cost-from-start as cost for actual path cost\n                q_min = q_near\n        return q_min, c_min\n\n    def _shortcut_path(self, path: list[Vertex], max_attempts=50) -> list[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = self._get_grid().get_line_sequence(p_i, p_j)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Apply multiple rounds of smoothing to improve path quality further\n        for _ in range(3):\n            path = self._shortcut_path(path, max_attempts=30)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*[int(round(float(c))) for c in new_pos_tensor])\n        return Vertex(new_pos)\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n\n        max_iterations = 15000\n\n        for iter_count in range(max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Timeout - path search failed\n                return\n\n            # Gradually reduce max_dist from initial to min over iterations for finer resolution near solution\n            frac = min(1.0, float(iter_count)/max_iterations)\n            self._max_dist = self._max_dist_initial * (1 - frac) + self._max_dist_min * frac\n\n            radius = self._calc_rewire_radius()\n\n            # Sample with ellipsoid shrinking dynamically for focus\n            q_sample = self._informed_sample()\n\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n\n            if q_min is None:\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring: try to improve neighbors by connecting through q_new with heuristic pruning\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                heuristic_near = self._heuristic(q_near.position)\n                heuristic_new = self._heuristic(q_new.position)\n                # Bias rewiring only if cost + heuristic better than current\n                if cost_through_new + heuristic_near * 0.5 < q_near.cost + heuristic_new * 0.5:\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check goal reaching condition with refined radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if (self._best_cost is None) or (possible_cost < self._best_cost):\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 50, in PathPlanning\nTypeError: unsupported operand type(s) for |: 'type' and 'NoneType'\n"
     }
}
{
     "operator": "m1",
     "algorithm": "Improved Adaptive Informed RRT* with Bidirectional Search and Lazy Collision Checking.\n    This planner enhances the original AIRRT* by:\n    - Using a bidirectional search from start and goal to accelerate convergence.\n    - Employing lazy collision checking to reduce expensive validations.\n    - Adaptive informed sampling shrinking the ellipsoidal subset dynamically.\n    - Progressive rewiring with prioritized neighbors for better path quality and smoothness.\n    - Path shortcutting after initial solution to produce smoother, shorter paths.\n    - Early termination if a valid path found below a cost threshold.\n    - Enforced 60 seconds timeout for fail-safe.\n    \n    The bidirectional approach helps quickly connect start and goal trees, increasing success rate.\n    Lazy collision delays line validity checks, improving efficiency.\n    Combining these enhancements leads to more robust, efficient, and higher quality path planning.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph_start: Forest\n    _graph_goal: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: float | None\n    _best_goal_vertex: Vertex | None\n    _best_start_vertex: Vertex | None\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        grid = self._get_grid()\n        self._dimension = grid.size.n_dim\n        max_map_dim = float(max(grid.size.values))\n        self._max_dist = max_map_dim / 15.0  # smaller step length for finer growth\n        self._lambda_rrt_star = 30.0  # tuned constant for rewire radius\n        self._max_radius = max_map_dim / 4  # max rewire radius\n\n        start_vertex = Vertex(grid.agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(grid.goal.position)\n        goal_vertex.cost = 0.0\n\n        # Two trees: one from start and one from goal\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n\n        self._start_time = 0.0\n        self._timeout = 60.0\n\n        self._best_cost = None\n        self._best_goal_vertex = None\n        self._best_start_vertex = None\n\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _calc_rewire_radius(self, forest_size: int) -> float:\n        card_v = torch.tensor(float(forest_size + 1))\n        log_card_v = torch.log(card_v)\n        radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1.0 / self._dimension)), self._max_radius)\n        return radius.item()\n\n    def _informed_sample(self) -> Point:\n        \"\"\"\n        Samples mostly from the informed subset if best cost known, else uniform.\n        This sample is used for both start and goal trees for unbiased growth.\n        \"\"\"\n        grid = self._get_grid()\n        if self._best_cost is None:\n            # Uniform random valid sample\n            while True:\n                coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n                sample = Point(*coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Sample in informed ellipsoid defined by start-goal and radius = best_cost\n            start = self._graph_start.root_vertex_start.position.to_tensor()\n            goal = self._graph_start.root_vertex_goal.position.to_tensor()\n            c_best = torch.tensor(self._best_cost)\n            c_min = self._dist(self._graph_start.root_vertex_start.position, self._graph_start.root_vertex_goal.position)\n            if c_best < c_min:\n                c_best = c_min + 1e-3\n\n            center = (start + goal) / 2.0\n            foci_vec = goal - start\n            e_axis = foci_vec / torch.norm(foci_vec)\n\n            if self._dimension == 2:\n                rotation_basis = torch.zeros((2, 2))\n                rotation_basis[:, 0] = e_axis\n                rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])\n            elif self._dimension == 3:\n                z_axis = e_axis\n                arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n                y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n                y_axis /= torch.norm(y_axis)\n                x_axis = torch.cross(y_axis, z_axis)\n                rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n            else:\n                # fallback uniform\n                while True:\n                    coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n                    sample = Point(*coords)\n                    if grid.is_agent_valid_pos(sample):\n                        return sample\n\n            r1 = c_best / 2.0\n            r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0\n            if self._dimension == 2:\n                L = torch.diag(torch.tensor([r1, r2]))\n            elif self._dimension == 3:\n                L = torch.diag(torch.tensor([r2, r2, r1]))\n            else:\n                while True:\n                    coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n                    sample = Point(*coords)\n                    if grid.is_agent_valid_pos(sample):\n                        return sample\n\n            while True:\n                u = torch.randn(self._dimension)\n                norm_u = torch.norm(u)\n                if norm_u > 1e-6:\n                    break\n            unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n            sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n\n            sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, grid.size[i] - 1).round())) for i in range(self._dimension)]\n            sample_point = Point(*sample_coords)\n\n            if grid.is_agent_valid_pos(sample_point):\n                return sample_point\n            else:\n                # fallback uniform\n                while True:\n                    coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n                    sample = Point(*coords)\n                    if grid.is_agent_valid_pos(sample):\n                        return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*[int(round(float(c))) for c in new_pos_tensor])\n        return Vertex(new_pos)\n\n    def _lazy_collision_check(self, line_seq: list[Point]) -> bool:\n        \"\"\"\n        Lazily check collision - we allow tentatively connection without full check,\n        then validate only absolutely needed connections.\n        Here, we do full check for the first and last few points with limit, else partial check.\n        \"\"\"\n        grid = self._get_grid()\n        # Quick heuristic: Check every kth point, and endpoints fully\n        if not line_seq:\n            return False\n        # Check endpoints: must be valid\n        if not grid.is_agent_valid_pos(line_seq[0]) or not grid.is_agent_valid_pos(line_seq[-1]):\n            return False\n        step = max(1, len(line_seq) // 10)\n        for i in range(0, len(line_seq), step):\n            if not grid.is_agent_valid_pos(line_seq[i]):\n                return False\n        return True\n\n    def _choose_parent(self, neighbors: list[Vertex], q_new: Vertex) -> tuple[Vertex | None, float]:\n        c_min = float('inf')\n        q_min = None\n        grid = self._get_grid()\n        for q_near in neighbors:\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            # Use lazy collision check first\n            if not self._lazy_collision_check(line_seq):\n                continue\n            # Now full check before actual connection\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost = q_near.cost + self._dist(q_near.position, q_new.position)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n        return q_min, c_min\n\n    def _rewire(self, graph: Forest, neighbors: list[Vertex], q_new: Vertex) -> None:\n        grid = self._get_grid()\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            line_seq = grid.get_line_sequence(q_new.position, q_near.position)\n            if not self._lazy_collision_check(line_seq):\n                continue\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n            if cost_through_new < q_near.cost:\n                parents_copy = list(q_near.parents)\n                for p in parents_copy:\n                    graph.remove_edge(p, q_near)\n                q_near.cost = cost_through_new\n                graph.add_edge(q_new, q_near)\n\n    def _try_connect_trees(self, q_new_start: Vertex, q_new_goal: Vertex) -> bool:\n        grid = self._get_grid()\n        # Attempt connection from new start vertex to nearby goal vertices\n        radius_start = self._calc_rewire_radius(self._graph_start.size)\n        radius_goal = self._calc_rewire_radius(self._graph_goal.size)\n\n        neighbors_goal = self._graph_goal.get_vertices_within_radius([self._graph_goal.root_vertex_start], q_new_start.position, radius_goal)\n        for q_goal_vertex in neighbors_goal:\n            line_seq = grid.get_line_sequence(q_new_start.position, q_goal_vertex.position)\n            if not self._lazy_collision_check(line_seq):\n                continue\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            potential_cost = q_new_start.cost + self._dist(q_new_start.position, q_goal_vertex.position) + q_goal_vertex.cost\n            if self._best_cost is None or potential_cost < self._best_cost:\n                self._best_cost = potential_cost\n                self._best_goal_vertex = q_goal_vertex\n                self._best_start_vertex = q_new_start\n                # Link trees by connecting goal's parent to start's new node\n                parents_copy = list(self._graph_goal.root_vertex_goal.parents)\n                for p in parents_copy:\n                    self._graph_goal.remove_edge(p, self._graph_goal.root_vertex_goal)\n                self._graph_goal.add_edge(q_goal_vertex, self._graph_goal.root_vertex_goal)\n                return True\n\n        neighbors_start = self._graph_start.get_vertices_within_radius([self._graph_start.root_vertex_start], q_new_goal.position, radius_start)\n        for q_start_vertex in neighbors_start:\n            line_seq = grid.get_line_sequence(q_new_goal.position, q_start_vertex.position)\n            if not self._lazy_collision_check(line_seq):\n                continue\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            potential_cost = q_new_goal.cost + self._dist(q_new_goal.position, q_start_vertex.position) + q_start_vertex.cost\n            if self._best_cost is None or potential_cost < self._best_cost:\n                self._best_cost = potential_cost\n                self._best_goal_vertex = q_new_goal\n                self._best_start_vertex = q_start_vertex\n                parents_copy = list(self._graph_start.root_vertex_goal.parents)\n                for p in parents_copy:\n                    self._graph_start.remove_edge(p, self._graph_start.root_vertex_goal)\n                self._graph_start.add_edge(q_start_vertex, self._graph_start.root_vertex_goal)\n                return True\n\n        return False\n\n    def _extract_and_smooth_path(self) -> None:\n        \"\"\"\n        Extract path by connecting best start vertex to best goal vertex through root goal nodes.\n        Then apply shortcut smoothing on combined path.\n        \"\"\"\n        if self._best_start_vertex is None or self._best_goal_vertex is None:\n            return\n        path_start = [self._graph_start.root_vertex_start]\n        current = self._best_start_vertex\n        while current != self._graph_start.root_vertex_start and current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_start.append(parent)\n            current = parent\n        path_start.reverse()\n\n        path_goal = [self._graph_goal.root_vertex_goal]\n        current = self._best_goal_vertex\n        while current != self._graph_goal.root_vertex_goal and current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_goal.append(parent)\n            current = parent\n        # Reverse goal path to go from best_goal_vertex to goal root\n        path_goal = path_goal[::-1]\n\n        # Connect both parts via _best_start_vertex and _best_goal_vertex:\n        # Paths overlap at connected edge between _best_start_vertex and _best_goal_vertex\n        # Remove duplicates if any at join\n        if path_start[-1].position == self._best_start_vertex.position:\n            path_start[-1] = self._best_start_vertex\n        if path_goal[0].position == self._best_goal_vertex.position:\n            path_goal[0] = self._best_goal_vertex\n\n        full_path = path_start + path_goal\n\n        # Shortcut smoothing attempt to improve path quality\n        full_path = self._shortcut_path(full_path, max_attempts=50)\n\n        grid = self._get_grid()\n        for vertex in full_path:\n            grid.agent.position = vertex.position\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list[Vertex], max_attempts=30) -> list[Vertex]:\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = grid.get_line_sequence(p_i, p_j)\n            if grid.is_valid_line_sequence(line_seq):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n        grid = self._get_grid()\n        max_iterations = 20000\n\n        for iter in range(max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Failed due to timeout\n                return\n\n            # Alternate between start and goal forests growth\n            grow_from_start = (iter % 2 == 0)\n\n            q_sample = self._informed_sample()\n            if grow_from_start:\n                q_near = self._graph_start.get_nearest_vertex([self._graph_start.root_vertex_start], q_sample)\n            else:\n                q_near = self._graph_goal.get_nearest_vertex([self._graph_goal.root_vertex_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_dist)\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n\n            # Lazy collision for faster rejection\n            if not self._lazy_collision_check(line_seq):\n                continue\n\n            # Full valid line check before adding\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            if grow_from_start:\n                radius = self._calc_rewire_radius(self._graph_start.size)\n                neighbors = self._graph_start.get_vertices_within_radius([self._graph_start.root_vertex_start], q_new.position, radius)\n                q_min, c_min = self._choose_parent(neighbors, q_new)\n                if q_min is None:\n                    q_min = q_near\n                    c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n                q_new.cost = c_min\n                self._graph_start.add_edge(q_min, q_new)\n                self._rewire(self._graph_start, neighbors, q_new)\n            else:\n                radius = self._calc_rewire_radius(self._graph_goal.size)\n                neighbors = self._graph_goal.get_vertices_within_radius([self._graph_goal.root_vertex_start], q_new.position, radius)\n                q_min, c_min = self._choose_parent(neighbors, q_new)\n                if q_min is None:\n                    q_min = q_near\n                    c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n                q_new.cost = c_min\n                self._graph_goal.add_edge(q_min, q_new)\n                self._rewire(self._graph_goal, neighbors, q_new)\n\n            # After adding new vertex, try to connect both trees\n            if grow_from_start:\n                connected = self._try_connect_trees(q_new, None)\n            else:\n                connected = self._try_connect_trees(None, q_new)\n\n            if connected:\n                # Extract combined path and smooth\n                self._extract_and_smooth_path()\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 50, in PathPlanning\nTypeError: unsupported operand type(s) for |: 'type' and 'NoneType'\n"
     }
}
{
     "operator": "m3",
     "algorithm": "An improved sample-based path planning algorithm inspired by RRT*, \n    combining fast exploration with path quality optimization and robustness enhancements. \n    It uses adaptive sampling biased toward the goal to accelerate convergence, \n    rewiring for better path smoothness and shorter cost, \n    and early termination if the path is found or time limit exceeded. \n    The algorithm incorporates goal bias, dynamic neighborhood radius based on iteration count, \n    and motion validation with collision checking to ensure valid paths, \n    aiming to improve planning efficiency, success rate, and path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: 'Point', max_dist: float) -> 'Vertex':\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        # Convert float coordinates back to int coordinates to keep grid consistency\n        new_pos_tuple = tuple(int(round(v)) for v in new_pos_tensor.tolist())\n        q_new = Vertex(Point(*new_pos_tuple), store_connectivity=True)\n        return q_new\n\n    def _get_random_sample(self, goal_sample_rate=0.15) -> 'Point':\n        # Bias sampling with a probability towards the goal to improve convergence\n        if np.random.rand() < goal_sample_rate:\n            return self._get_grid().goal.position\n\n        size_vals = self._get_grid().size.values\n        while True:\n            rand_pos = tuple(np.random.randint(0, v) for v in size_vals)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _distance(self, p1: 'Point', p2: 'Point') -> float:\n        return self._get_grid().get_distance(p1, p2)\n\n    def _neighbor_radius(self, iteration: int, c_max: float = 50.0) -> float:\n        # Dynamic radius shrinking over iterations for rewiring neighborhood\n        gamma = c_max\n        n = max(1, iteration)\n        radius = min(gamma * ((np.log(n) / n) ** 0.5), c_max)\n        return max(5.0, radius)  # Ensure minimum neighborhood radius\n\n    def _choose_parent(self, neighbors: list, q_new: 'Vertex') -> 'Vertex':\n        best_parent = None\n        best_cost = float('inf')\n        for neighbor in neighbors:\n            dist = self._distance(neighbor.position, q_new.position)\n            cost_through_neighbor = (neighbor.cost if neighbor.cost is not None else 0) + dist\n            if cost_through_neighbor < best_cost:\n                # Check if path from neighbor to q_new is collision free\n                line_seq = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                best_parent = neighbor\n                best_cost = cost_through_neighbor\n        return best_parent\n\n    def _rewire(self, q_new: 'Vertex', neighbors: list) -> None:\n        for neighbor in neighbors:\n            if neighbor == q_new or neighbor.parents == {q_new}:\n                continue\n            dist = self._distance(q_new.position, neighbor.position)\n            new_cost = (q_new.cost if q_new.cost is not None else 0) + dist\n            if neighbor.cost is None or new_cost < neighbor.cost:\n                line_seq = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove old parent edges\n                    for p in set(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n    def _extract_path(self, q_goal: 'Vertex') -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            # Choose parent with minimal cost to trace back\n            parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Animate path from start to goal\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist = 15.0\n        max_iterations = 15000\n        start_time = time()\n\n        # Assign start cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for it in range(1, max_iterations + 1):\n            if time() - start_time > 60:\n                # Fail gracefully if exceeds time limit\n                break\n\n            q_sample = self._get_random_sample(goal_sample_rate=0.2)\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new.position == q_near.position:\n                continue\n\n            # Validate motion\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Neighborhood search for rewiring\n            radius = self._neighbor_radius(it, c_max=max_dist*2)\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n            if not neighbors:\n                neighbors = [q_near]\n\n            # Choose best parent among neighbors\n            best_parent = self._choose_parent(neighbors, q_new)\n            if best_parent is None:\n                continue\n\n            # Add edge from best parent to q_new and set cost\n            self._graph.add_edge(best_parent, q_new)\n            q_new.cost = (best_parent.cost if best_parent.cost is not None else 0) + self._distance(best_parent.position, q_new.position)\n\n            # Insert q_new into root vertices for graph expansion\n            self._graph.root_vertices.append(q_new)\n\n            # Rewire neighbors to optimize paths\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new is close enough to goal within goal radius bounds\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex with edge and extract path\n                goal_vertex = self._graph.root_vertex_goal\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_vertex.cost = (q_new.cost if q_new.cost is not None else 0) + self._distance(q_new.position, goal_vertex.position)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 134, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "e2",
     "algorithm": "This is a hybrid Adaptive Informed RRT* inspired algorithm with enhanced performance improvements.\n    It combines:\n    - Adaptive ellipsoidal informed sampling focused around the current best solution to improve planning efficiency,\n      drastically reducing unnecessary explorations.\n    - Adaptive radius rewiring for efficient parent selection and graph rewiring to obtain optimal paths.\n    - Bidirectional cost-based parent choosing and edge rewiring for better path quality.\n    - Post-processing path smoothing (shortcutting) for enhanced path smoothness.\n    - Timeout handling to gracefully fail if time exceeds 60 seconds.\n    Overall, it improves success rate, reduces path length and search time, and produces smoother paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: Optional[float]\n    _best_goal_vertex: Optional[Vertex]\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        grid = self._get_grid()\n        self._dimension = grid.size.n_dim\n        self._max_dist = float(max(grid.size.values)) / 10.0\n        self._lambda_rrt_star = 40.0\n        self._max_radius = max(grid.size.values) / 3\n        start_vertex = Vertex(grid.agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(grid.goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._timeout = 60.0\n        self._start_time = 0.0\n        self._best_cost = None\n        self._best_goal_vertex = None\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _uniform_sample(self) -> Point:\n        grid = self._get_grid()\n        while True:\n            coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n            # Make sure coords are int\n            coords_int = [int(c) for c in coords]\n            sample = Point(*coords_int)\n            # Explicitly set is_float attribute to False to avoid AttributeError\n            if not hasattr(sample, 'is_float'):\n                sample.is_float = False\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _ellipsoidal_sample(self) -> Point:\n        grid = self._get_grid()\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        c_best = torch.tensor(self._best_cost)\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best < c_min:\n            c_best = c_min + 1e-3\n\n        center = (start + goal) / 2.0\n        foci_vec = (goal - start)\n        e_axis = foci_vec / torch.norm(foci_vec)\n\n        if self._dimension == 2:\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])  # Perpendicular in 2D\n        elif self._dimension == 3:\n            z_axis = e_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n        else:\n            return self._uniform_sample()\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0\n\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        elif self._dimension == 3:\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n        else:\n            return self._uniform_sample()\n\n        while True:\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u > 1e-6:\n                break\n        unit_ball_sample = u / norm_u * (torch.rand(1).item() ** (1.0 / self._dimension))\n\n        sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n\n        coords = []\n        for i in range(self._dimension):\n            val = float(torch.clamp(sample_in_ellipsoid[i], 0, grid.size[i] - 1).round())\n            coords.append(int(val))\n        sample_point = Point(*coords)\n        if not hasattr(sample_point, 'is_float'):\n            sample_point.is_float = False\n\n        if grid.is_agent_valid_pos(sample_point):\n            return sample_point\n        else:\n            return self._uniform_sample()\n\n    def _informed_sample(self) -> Point:\n        if self._best_cost is None:\n            return self._uniform_sample()\n        else:\n            return self._ellipsoidal_sample()\n\n    def _calc_rewire_radius(self) -> float:\n        card_v = float(self._graph.size + 1)\n        log_card_v = max(torch.log(torch.tensor(card_v)).item(), 1e-6)\n        radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1.0 / self._dimension)), self._max_radius)\n        return radius\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Tuple[Optional[Vertex], float]:\n        c_min = float('inf')\n        q_min = None\n        grid = self._get_grid()\n        for q_near in neighbors:\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost = q_near.cost + self._dist(q_near.position, q_new.position)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n        return q_min, c_min\n\n    def _shortcut_path(self, path: List[Vertex], max_attempts=40) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = grid.get_line_sequence(p_i, p_j)\n            if grid.is_valid_line_sequence(line_seq):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        path = self._shortcut_path(path, max_attempts=40)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            coords = [int(round(float(c))) for c in q_sample.values]\n            new_pos = Point(*coords)\n            if not hasattr(new_pos, 'is_float'):\n                new_pos.is_float = False\n            return Vertex(new_pos)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_coords = [int(round(float(c))) for c in new_pos_tensor]\n        new_pos = Point(*new_coords)\n        if not hasattr(new_pos, 'is_float'):\n            new_pos.is_float = False\n        return Vertex(new_pos)\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n        max_iterations = 15000\n        radius = self._calc_rewire_radius()\n        grid = self._get_grid()\n\n        for iteration in range(max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                return\n\n            q_sample = self._informed_sample()\n\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                if not grid.is_valid_line_sequence(line_seq_rewire):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                if cost_through_new < q_near.cost:\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if (self._best_cost is None) or (possible_cost < self._best_cost):\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 233, in _find_path_internal\n  File \"<string>\", line 146, in _informed_sample\n  File \"<string>\", line 81, in _uniform_sample\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "e1",
     "algorithm": "parent.cost + edge_cost",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n        self._max_dist = 15.0      # Max edge extension length\n        self._goal_sample_rate = 0.1  # Probability of sampling goal directly\n        self._rewire_radius = 20.0    # Radius for rewiring neighbors\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return self._get_grid().get_distance(p1, p2)\n\n    def _steer(self, from_v: Vertex, to_p: Point, max_dist: float) -> Vertex:\n        dir_vec = to_p.to_tensor() - from_v.position.to_tensor()\n        dist = dir_vec.norm().item()\n        if dist <= max_dist:\n            # Ensure integer coordinates for dense map indexing\n            coords_int = [int(round(c)) for c in to_p.values]\n            new_pos = Point(*coords_int)\n            return Vertex(new_pos)\n        dir_norm = dir_vec / dist\n        new_pos_tensor = from_v.position.to_tensor() + max_dist * dir_norm\n        # Convert tensor coordinates to integer for valid dense_map indexing\n        new_pos_int = [int(round(coord.item())) for coord in new_pos_tensor]\n        new_pos = Point(*new_pos_int)\n        return Vertex(new_pos)\n\n    def _get_random_sample(self, best_cost: 'Optional[float]') -> Point:\n        \"\"\"\n        Sample points uniformly in map, but when best_cost is known, sample within informed elliptical region.\n        With certain probability sample goal directly (goal biasing).\n        \"\"\"\n        import numpy as np\n        grid = self._get_grid()\n        size = grid.size.values\n        start = grid.agent.position\n        goal = grid.goal.position\n\n        # Goal biasing\n        if np.random.random() < self._goal_sample_rate:\n            # Return integer position for goal\n            goal_int_pos = Point(*[int(round(c)) for c in goal.values])\n            return goal_int_pos\n\n        if best_cost is None or best_cost == float('inf'):\n            # Uniform random sampling in valid space\n            while True:\n                rand_coords = np.random.uniform(0, size, len(size))\n                # Convert to integers by rounding\n                rand_coords_int = [int(round(c)) for c in rand_coords]\n                sample = Point(*rand_coords_int)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling within ellipsoid defined by start-goal and best cost\n        c_best = best_cost\n        c_min = self._distance(start, goal)\n        if c_best < c_min:\n            # Impossible, fallback uniform sampling\n            while True:\n                rand_coords = np.random.uniform(0, size, len(size))\n                rand_coords_int = [int(round(c)) for c in rand_coords]\n                sample = Point(*rand_coords_int)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Define ellipsoid in 2D or 3D\n        # Translate points so that start is at origin\n        start_tensor = start.to_tensor()\n        goal_tensor = goal.to_tensor()\n        center = (start_tensor + goal_tensor) / 2\n        diff = (goal_tensor - start_tensor)\n        diff_len = diff.norm().item()\n\n        # Define rotation matrix to align x-axis with diff vector\n        if len(diff) == 2:\n            # 2D case\n            theta = torch.atan2(diff[1], diff[0])\n            cos_th = torch.cos(theta)\n            sin_th = torch.sin(theta)\n            R = torch.tensor([[cos_th, -sin_th], [sin_th, cos_th]])\n        else:\n            # Higher-dim case: use diff normalized + Gram-Schmidt with identity basis (simplification)\n            # To avoid heavy math, fallback to uniform sampling\n            while True:\n                rand_coords = np.random.uniform(0, size, len(size))\n                rand_coords_int = [int(round(c)) for c in rand_coords]\n                sample = Point(*rand_coords_int)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Radii of ellipsoid axes\n        a = c_best / 2\n        b = (c_best**2 - c_min**2)**0.5 / 2 if c_best**2 - c_min**2 > 0 else 0\n        axes = torch.tensor([a, b])\n\n        count_attempts = 0\n        while True:\n            count_attempts += 1\n            # Sample random point in unit circle ellipse\n            r = np.random.rand()**0.5  # sqrt to ensure uniform in circle\n            angle = np.random.uniform(0, 2 * np.pi)\n            x = r * np.cos(angle)\n            y = r * np.sin(angle)\n            sample_unit = torch.tensor([x, y]) * axes\n\n            # Rotate back and translate\n            sample_global = torch.matmul(R, sample_unit) + center\n\n            # Convert to integer coordinates for map indexing:\n            sample_int_coords = [int(round(coord.item())) for coord in sample_global]\n\n            # Clip coordinates to bounds\n            sample_int_coords = [max(0, min(sample_int_coords[i], size[i]-1)) for i in range(len(size))]\n\n            candidate = Point(*sample_int_coords)\n\n            # Check if within bounds\n            if all(0 <= coord < dim for coord, dim in zip(candidate.values, size)):\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n            # To prevent infinite loop in pathological maps\n            if count_attempts > 500:\n                # fallback uniform sampling\n                while True:\n                    rand_coords = np.random.uniform(0, size, len(size))\n                    rand_coords_int = [int(round(c)) for c in rand_coords]\n                    sample = Point(*rand_coords_int)\n                    if self._get_grid().is_agent_valid_pos(sample):\n                        return sample\n\n    def _extract_path(self, vertex: Vertex) -> 'List[Vertex]':\n        path: 'List[Vertex]' = []\n        current = vertex\n        while True:\n            path.append(current)\n            if not current.parents:\n                break\n            # Greedily pick parent with minimal cost\n            current = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n        path.reverse()\n        return path\n\n    def _update_cost(self, vertex: Vertex) -> None:\n        # Cost = min over parents {parent.cost + edge_cost}\n        grid = self._get_grid()\n        min_cost = float('inf')\n        best_parent = None\n        for p in vertex.parents:\n            if p.cost is None:\n                continue\n            cost_candidate = p.cost + grid.get_movement_cost(p.position, vertex.position)\n            if cost_candidate < min_cost:\n                min_cost = cost_candidate\n                best_parent = p\n        if best_parent is not None:\n            vertex.cost = min_cost\n            # Remove other parents edges to keep tree structure closer to a tree (optional)\n            # But we keep all parents for line of sight rewiring possibility\n            # Remove edges to non-best parents (safe removal if edges_removable is True)\n            if self._graph.edges_removable:\n                to_remove = vertex.parents - {best_parent}\n                for rem_parent in to_remove:\n                    self._graph.remove_edge(rem_parent, vertex)\n            # Ensure edge from best_parent exist (redundant but safe)\n            self._graph.add_edge(best_parent, vertex)\n\n    def _rewire(self, q_new: Vertex, neighbors: 'List[Vertex]') -> None:\n        \"\"\"\n        For each neighbor, check if going through q_new improves cost.\n        If yes and line-of-sight is valid, rewire.\n        \"\"\"\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor == q_new:\n                continue\n            if neighbor.cost is None:\n                continue\n            weight_through_new = q_new.cost + grid.get_movement_cost(q_new.position, neighbor.position)\n            if weight_through_new + 1e-7 < neighbor.cost:  # small epsilon\n                line_seq = grid.get_line_sequence(q_new.position, neighbor.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Rewire edge\n                    # Remove old edge(s) parent->neighbor\n                    for parent in list(neighbor.parents):\n                        self._graph.remove_edge(parent, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = weight_through_new\n                    # Propagate cost update recursively in neighborhood\n                    self._propagate_cost_update(neighbor)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        grid = self._get_grid()\n        for child in vertex.children:\n            old_cost = child.cost\n            new_cost = vertex.cost + grid.get_movement_cost(vertex.position, child.position)\n            if new_cost + 1e-7 < (old_cost if old_cost is not None else float('inf')):\n                child.cost = new_cost\n                self._propagate_cost_update(child)\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        max_iterations = 15000\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n\n        best_goal_vertex: 'Optional[Vertex]' = None\n        best_cost = float('inf')\n\n        for iteration in range(max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 60.0:  # Timeout guard 60 seconds\n                # Fail gracefully (no path found within time)\n                break\n\n            # Sample with goal bias and informed sampling\n            sample = self._get_random_sample(best_cost if best_goal_vertex else None)\n\n            # Find nearest vertex from start tree\n            q_near = self._graph.get_nearest_vertex([start_vertex], sample)\n\n            if q_near.position == sample:\n                continue\n\n            q_new = self._steer(q_near, sample, self._max_dist)\n\n            # Validate path segment between q_near and q_new with line sequence check\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Skip if q_new same as q_near (no movement)\n            if q_new.position == q_near.position:\n                continue\n\n            # Set cost w.r.t q_near\n            q_new.cost = q_near.cost + grid.get_movement_cost(q_near.position, q_new.position)\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire neighbors within radius for better path\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n            # Remove self from neighbors if present\n            neighbors = [v for v in neighbors if v != q_new]\n\n            # Find best parent for q_new among neighbors who can connect with valid path and minimal cost\n            min_cost = q_new.cost\n            best_parent = q_near\n            for neighbor in neighbors:\n                # Check line sequence from neighbor to q_new\n                line_seq_n = grid.get_line_sequence(neighbor.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_seq_n):\n                    continue\n                cost_candidate = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new.position)\n                if cost_candidate < min_cost:\n                    min_cost = cost_candidate\n                    best_parent = neighbor\n\n            if best_parent != q_near:\n                # Reassign parent edges accordingly\n                self._graph.remove_edge(q_near, q_new)\n                self._graph.add_edge(best_parent, q_new)\n                q_new.cost = min_cost\n\n            # Rewire neighbors through q_new if beneficial\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new is within goal radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Construct goal vertex with updated parentage\n                goal_dummy = Vertex(Point(*[int(round(c)) for c in grid.goal.position.values]))\n                line_seq_to_goal = grid.get_line_sequence(q_new.position, goal_dummy.position)\n                if grid.is_valid_line_sequence(line_seq_to_goal):\n                    goal_dummy.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_dummy.position)\n                    self._graph.add_edge(q_new, goal_dummy)\n                    if goal_dummy.cost < best_cost:\n                        best_cost = goal_dummy.cost\n                        best_goal_vertex = goal_dummy\n\n            # Visual/keyframe update\n            self.key_frame()\n\n        # If goal found, extract and move agent along path smoothly\n        if best_goal_vertex is not None:\n            path_vertices = self._extract_path(best_goal_vertex)\n            # Animate agent move along path\n            for v in path_vertices:\n                self.move_agent(v.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 264, in _find_path_internal\n  File \"<string>\", line 95, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 149, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m1",
     "algorithm": "Improved Adaptive Informed RRT* with Bidirectional Search and Lazy Collision Checking.\n    This planner enhances the original AIRRT* by:\n    - Using a bidirectional search from start and goal to accelerate convergence.\n    - Employing lazy collision checking to reduce expensive validations.\n    - Adaptive informed sampling shrinking the ellipsoidal subset dynamically.\n    - Progressive rewiring with prioritized neighbors for better path quality and smoothness.\n    - Path shortcutting after initial solution to produce smoother, shorter paths.\n    - Early termination if a valid path found below a cost threshold.\n    - Enforced 60 seconds timeout for fail-safe.\n    \n    The bidirectional approach helps quickly connect start and goal trees, increasing success rate.\n    Lazy collision delays line validity checks, improving efficiency.\n    Combining these enhancements leads to more robust, efficient, and higher quality path planning.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph_start: Forest\n    _graph_goal: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: Optional[float]\n    _best_goal_vertex: Optional[Vertex]\n    _best_start_vertex: Optional[Vertex]\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        grid = self._get_grid()\n        self._dimension = grid.size.n_dim\n        max_map_dim = float(max(grid.size.values))\n        self._max_dist = max_map_dim / 15.0  # smaller step length for finer growth\n        self._lambda_rrt_star = 30.0  # tuned constant for rewire radius\n        self._max_radius = max_map_dim / 4  # max rewire radius\n\n        start_vertex = Vertex(grid.agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(grid.goal.position)\n        goal_vertex.cost = 0.0\n\n        # Two trees: one from start and one from goal\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n\n        self._start_time = 0.0\n        self._timeout = 60.0\n\n        self._best_cost = None\n        self._best_goal_vertex = None\n        self._best_start_vertex = None\n\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _calc_rewire_radius(self, forest_size: int) -> float:\n        card_v = torch.tensor(float(forest_size + 1))\n        log_card_v = torch.log(card_v)\n        radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1.0 / self._dimension)), self._max_radius)\n        return radius.item()\n\n    def _informed_sample(self) -> Point:\n        \"\"\"\n        Samples mostly from the informed subset if best cost known, else uniform.\n        This sample is used for both start and goal trees for unbiased growth.\n        \"\"\"\n        grid = self._get_grid()\n        if self._best_cost is None:\n            # Uniform random valid sample\n            while True:\n                coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n                sample = Point(*coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Sample in informed ellipsoid defined by start-goal and radius = best_cost\n            start = self._graph_start.root_vertex_start.position.to_tensor()\n            goal = self._graph_start.root_vertex_goal.position.to_tensor()\n            c_best = torch.tensor(self._best_cost)\n            c_min = self._dist(self._graph_start.root_vertex_start.position, self._graph_start.root_vertex_goal.position)\n            if c_best < c_min:\n                c_best = c_min + 1e-3\n\n            center = (start + goal) / 2.0\n            foci_vec = goal - start\n            e_axis = foci_vec / torch.norm(foci_vec)\n\n            if self._dimension == 2:\n                rotation_basis = torch.zeros((2, 2))\n                rotation_basis[:, 0] = e_axis\n                rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])\n            elif self._dimension == 3:\n                z_axis = e_axis\n                arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n                y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n                y_axis /= torch.norm(y_axis)\n                x_axis = torch.cross(y_axis, z_axis)\n                rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n            else:\n                # fallback uniform\n                while True:\n                    coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n                    sample = Point(*coords)\n                    if grid.is_agent_valid_pos(sample):\n                        return sample\n\n            r1 = c_best / 2.0\n            r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0\n            if self._dimension == 2:\n                L = torch.diag(torch.tensor([r1, r2]))\n            elif self._dimension == 3:\n                L = torch.diag(torch.tensor([r2, r2, r1]))\n            else:\n                while True:\n                    coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n                    sample = Point(*coords)\n                    if grid.is_agent_valid_pos(sample):\n                        return sample\n\n            while True:\n                u = torch.randn(self._dimension)\n                norm_u = torch.norm(u)\n                if norm_u > 1e-6:\n                    break\n            unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n            sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n\n            sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, grid.size[i] - 1).round())) for i in range(self._dimension)]\n            sample_point = Point(*sample_coords)\n\n            if grid.is_agent_valid_pos(sample_point):\n                return sample_point\n            else:\n                # fallback uniform\n                while True:\n                    coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n                    sample = Point(*coords)\n                    if grid.is_agent_valid_pos(sample):\n                        return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*[int(round(float(c))) for c in new_pos_tensor])\n        return Vertex(new_pos)\n\n    def _lazy_collision_check(self, line_seq: List[Point]) -> bool:\n        \"\"\"\n        Lazily check collision - we allow tentatively connection without full check,\n        then validate only absolutely needed connections.\n        Here, we do full check for the first and last few points with limit, else partial check.\n        \"\"\"\n        grid = self._get_grid()\n        # Quick heuristic: Check every kth point, and endpoints fully\n        if not line_seq:\n            return False\n        # Check endpoints: must be valid\n        if not grid.is_agent_valid_pos(line_seq[0]) or not grid.is_agent_valid_pos(line_seq[-1]):\n            return False\n        step = max(1, len(line_seq) // 10)\n        for i in range(0, len(line_seq), step):\n            if not grid.is_agent_valid_pos(line_seq[i]):\n                return False\n        return True\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Tuple[Optional[Vertex], float]:\n        c_min = float('inf')\n        q_min = None\n        grid = self._get_grid()\n        for q_near in neighbors:\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            # Use lazy collision check first\n            if not self._lazy_collision_check(line_seq):\n                continue\n            # Now full check before actual connection\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost = q_near.cost + self._dist(q_near.position, q_new.position)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n        return q_min, c_min\n\n    def _rewire(self, graph: Forest, neighbors: List[Vertex], q_new: Vertex) -> None:\n        grid = self._get_grid()\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            line_seq = grid.get_line_sequence(q_new.position, q_near.position)\n            if not self._lazy_collision_check(line_seq):\n                continue\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n            if cost_through_new < q_near.cost:\n                parents_copy = list(q_near.parents)\n                for p in parents_copy:\n                    graph.remove_edge(p, q_near)\n                q_near.cost = cost_through_new\n                graph.add_edge(q_new, q_near)\n\n    def _try_connect_trees(self, q_new_start: Optional[Vertex], q_new_goal: Optional[Vertex]) -> bool:\n        grid = self._get_grid()\n        # Attempt connection from new start vertex to nearby goal vertices\n        radius_start = self._calc_rewire_radius(self._graph_start.size)\n        radius_goal = self._calc_rewire_radius(self._graph_goal.size)\n\n        if q_new_start is not None:\n            neighbors_goal = self._graph_goal.get_vertices_within_radius([self._graph_goal.root_vertex_start], q_new_start.position, radius_goal)\n            for q_goal_vertex in neighbors_goal:\n                line_seq = grid.get_line_sequence(q_new_start.position, q_goal_vertex.position)\n                if not self._lazy_collision_check(line_seq):\n                    continue\n                if not grid.is_valid_line_sequence(line_seq):\n                    continue\n                potential_cost = q_new_start.cost + self._dist(q_new_start.position, q_goal_vertex.position) + q_goal_vertex.cost\n                if self._best_cost is None or potential_cost < self._best_cost:\n                    self._best_cost = potential_cost\n                    self._best_goal_vertex = q_goal_vertex\n                    self._best_start_vertex = q_new_start\n                    # Link trees by connecting goal's parent to start's new node\n                    parents_copy = list(self._graph_goal.root_vertex_goal.parents)\n                    for p in parents_copy:\n                        self._graph_goal.remove_edge(p, self._graph_goal.root_vertex_goal)\n                    self._graph_goal.add_edge(q_goal_vertex, self._graph_goal.root_vertex_goal)\n                    return True\n\n        if q_new_goal is not None:\n            neighbors_start = self._graph_start.get_vertices_within_radius([self._graph_start.root_vertex_start], q_new_goal.position, radius_start)\n            for q_start_vertex in neighbors_start:\n                line_seq = grid.get_line_sequence(q_new_goal.position, q_start_vertex.position)\n                if not self._lazy_collision_check(line_seq):\n                    continue\n                if not grid.is_valid_line_sequence(line_seq):\n                    continue\n                potential_cost = q_new_goal.cost + self._dist(q_new_goal.position, q_start_vertex.position) + q_start_vertex.cost\n                if self._best_cost is None or potential_cost < self._best_cost:\n                    self._best_cost = potential_cost\n                    self._best_goal_vertex = q_new_goal\n                    self._best_start_vertex = q_start_vertex\n                    parents_copy = list(self._graph_start.root_vertex_goal.parents)\n                    for p in parents_copy:\n                        self._graph_start.remove_edge(p, self._graph_start.root_vertex_goal)\n                    self._graph_start.add_edge(q_start_vertex, self._graph_start.root_vertex_goal)\n                    return True\n\n        return False\n\n    def _extract_and_smooth_path(self) -> None:\n        \"\"\"\n        Extract path by connecting best start vertex to best goal vertex through root goal nodes.\n        Then apply shortcut smoothing on combined path.\n        \"\"\"\n        if self._best_start_vertex is None or self._best_goal_vertex is None:\n            return\n        path_start = [self._graph_start.root_vertex_start]\n        current = self._best_start_vertex\n        while current != self._graph_start.root_vertex_start and current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_start.append(parent)\n            current = parent\n        path_start.reverse()\n\n        path_goal = [self._graph_goal.root_vertex_goal]\n        current = self._best_goal_vertex\n        while current != self._graph_goal.root_vertex_goal and current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_goal.append(parent)\n            current = parent\n        # Reverse goal path to go from best_goal_vertex to goal root\n        path_goal = path_goal[::-1]\n\n        # Connect both parts via _best_start_vertex and _best_goal_vertex:\n        # Paths overlap at connected edge between _best_start_vertex and _best_goal_vertex\n        # Remove duplicates if any at join\n        if path_start[-1].position == self._best_start_vertex.position:\n            path_start[-1] = self._best_start_vertex\n        if path_goal[0].position == self._best_goal_vertex.position:\n            path_goal[0] = self._best_goal_vertex\n\n        full_path = path_start + path_goal\n\n        # Shortcut smoothing attempt to improve path quality\n        full_path = self._shortcut_path(full_path, max_attempts=50)\n\n        grid = self._get_grid()\n        for vertex in full_path:\n            grid.agent.position = vertex.position\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex], max_attempts=30) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = grid.get_line_sequence(p_i, p_j)\n            if grid.is_valid_line_sequence(line_seq):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n        grid = self._get_grid()\n        max_iterations = 20000\n\n        for iter in range(max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Failed due to timeout\n                return\n\n            # Alternate between start and goal forests growth\n            grow_from_start = (iter % 2 == 0)\n\n            q_sample = self._informed_sample()\n            if grow_from_start:\n                q_near = self._graph_start.get_nearest_vertex([self._graph_start.root_vertex_start], q_sample)\n            else:\n                q_near = self._graph_goal.get_nearest_vertex([self._graph_goal.root_vertex_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_dist)\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n\n            # Lazy collision for faster rejection\n            if not self._lazy_collision_check(line_seq):\n                continue\n\n            # Full valid line check before adding\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            if grow_from_start:\n                radius = self._calc_rewire_radius(self._graph_start.size)\n                neighbors = self._graph_start.get_vertices_within_radius([self._graph_start.root_vertex_start], q_new.position, radius)\n                q_min, c_min = self._choose_parent(neighbors, q_new)\n                if q_min is None:\n                    q_min = q_near\n                    c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n                q_new.cost = c_min\n                self._graph_start.add_edge(q_min, q_new)\n                self._rewire(self._graph_start, neighbors, q_new)\n            else:\n                radius = self._calc_rewire_radius(self._graph_goal.size)\n                neighbors = self._graph_goal.get_vertices_within_radius([self._graph_goal.root_vertex_start], q_new.position, radius)\n                q_min, c_min = self._choose_parent(neighbors, q_new)\n                if q_min is None:\n                    q_min = q_near\n                    c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n                q_new.cost = c_min\n                self._graph_goal.add_edge(q_min, q_new)\n                self._rewire(self._graph_goal, neighbors, q_new)\n\n            # After adding new vertex, try to connect both trees\n            if grow_from_start:\n                connected = self._try_connect_trees(q_new, None)\n            else:\n                connected = self._try_connect_trees(None, q_new)\n\n            if connected:\n                # Extract combined path and smooth\n                self._extract_and_smooth_path()\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 215, in __run_simulation\n    sim: Simulator = Simulator(Services(config))\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 40, in __init__\n    self.__setup(config)\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 68, in __setup\n    self.__algorithm_runner.reset_algorithm()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\algorithm_runner.py\", line 59, in reset_algorithm\n    self.__algorithm = self.__algorithm_type(self._services, testing, *self.__algorithm_parameters[0],\n  File \"<string>\", line 79, in __init__\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\sample_based_algorithm.py\", line 11, in _init_displays\n    self.__map_displays = [GraphMapDisplay(self._services, self._graph)]\nAttributeError: 'PathPlanning' object has no attribute '_graph'\n"
     }
}
{
     "operator": "e2",
     "algorithm": "This is a hybrid Adaptive Informed RRT* inspired algorithm with enhanced performance improvements.\n    It combines:\n    - Adaptive ellipsoidal informed sampling focused around the current best solution to improve planning efficiency,\n      drastically reducing unnecessary explorations.\n    - Adaptive radius rewiring for efficient parent selection and graph rewiring to obtain optimal paths.\n    - Bidirectional cost-based parent choosing and edge rewiring for better path quality.\n    - Post-processing path smoothing (shortcutting) for enhanced path smoothness.\n    - Timeout handling to gracefully fail if time exceeds 60 seconds.\n    Overall, it improves success rate, reduces path length and search time, and produces smoother paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: Optional[float]\n    _best_goal_vertex: Optional[Vertex]\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        grid = self._get_grid()\n        self._dimension = grid.size.n_dim\n        self._max_dist = float(max(grid.size.values)) / 10.0\n        self._lambda_rrt_star = 40.0\n        self._max_radius = max(grid.size.values) / 3\n        start_vertex = Vertex(grid.agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(grid.goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._timeout = 60.0\n        self._start_time = 0.0\n        self._best_cost = None\n        self._best_goal_vertex = None\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _uniform_sample(self) -> Point:\n        grid = self._get_grid()\n        while True:\n            coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n            # Use int values directly\n            sample = Point(*coords)\n            # Remove setting is_float attribute; Point always has it\n            if not sample.is_float and grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _ellipsoidal_sample(self) -> Point:\n        grid = self._get_grid()\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n        c_best = torch.tensor(self._best_cost)\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best < c_min:\n            c_best = c_min + 1e-3\n\n        center = (start + goal) / 2.0\n        foci_vec = (goal - start)\n        e_axis = foci_vec / torch.norm(foci_vec)\n\n        if self._dimension == 2:\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])  # Perpendicular in 2D\n        elif self._dimension == 3:\n            z_axis = e_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n        else:\n            return self._uniform_sample()\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0\n\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        elif self._dimension == 3:\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n        else:\n            return self._uniform_sample()\n\n        while True:\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u > 1e-6:\n                break\n        unit_ball_sample = u / norm_u * (torch.rand(1).item() ** (1.0 / self._dimension))\n\n        sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n\n        coords = []\n        for i in range(self._dimension):\n            val = float(torch.clamp(sample_in_ellipsoid[i], 0, grid.size[i] - 1).round())\n            coords.append(int(val))\n        sample_point = Point(*coords)\n        # Remove setting is_float attribute; Point has it by default\n\n        if grid.is_agent_valid_pos(sample_point):\n            return sample_point\n        else:\n            return self._uniform_sample()\n\n    def _informed_sample(self) -> Point:\n        if self._best_cost is None:\n            return self._uniform_sample()\n        else:\n            return self._ellipsoidal_sample()\n\n    def _calc_rewire_radius(self) -> float:\n        card_v = float(self._graph.size + 1)\n        log_card_v = max(torch.log(torch.tensor(card_v)).item(), 1e-6)\n        radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1.0 / self._dimension)), self._max_radius)\n        return radius\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Tuple[Optional[Vertex], float]:\n        c_min = float('inf')\n        q_min = None\n        grid = self._get_grid()\n        for q_near in neighbors:\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost = q_near.cost + self._dist(q_near.position, q_new.position)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n        return q_min, c_min\n\n    def _shortcut_path(self, path: List[Vertex], max_attempts=40) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = grid.get_line_sequence(p_i, p_j)\n            if grid.is_valid_line_sequence(line_seq):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        path = self._shortcut_path(path, max_attempts=40)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            coords = [int(round(float(c))) for c in q_sample.values]\n            new_pos = Point(*coords)\n            # Removed setting is_float attribute; Point has it\n            return Vertex(new_pos)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_coords = [int(round(float(c))) for c in new_pos_tensor]\n        new_pos = Point(*new_coords)\n        # Removed setting is_float attribute; Point has it by default\n        return Vertex(new_pos)\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n        max_iterations = 15000\n        radius = self._calc_rewire_radius()\n        grid = self._get_grid()\n\n        for iteration in range(max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                return\n\n            q_sample = self._informed_sample()\n\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                if not grid.is_valid_line_sequence(line_seq_rewire):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                if cost_through_new < q_near.cost:\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if (self._best_cost is None) or (possible_cost < self._best_cost):\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 227, in _find_path_internal\n  File \"<string>\", line 142, in _informed_sample\n  File \"<string>\", line 79, in _uniform_sample\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "e1",
     "algorithm": "parent.cost + edge_cost",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n        self._max_dist = 15.0      # Max edge extension length\n        self._goal_sample_rate = 0.1  # Probability of sampling goal directly\n        self._rewire_radius = 20.0    # Radius for rewiring neighbors\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return self._get_grid().get_distance(p1, p2)\n\n    def _steer(self, from_v: Vertex, to_p: Point, max_dist: float) -> Vertex:\n        dir_vec = to_p.to_tensor() - from_v.position.to_tensor()\n        dist = dir_vec.norm().item()\n        if dist <= max_dist:\n            # Ensure integer coordinates for dense map indexing\n            coords_int = [int(round(c)) for c in to_p.values]\n            new_pos = Point(*coords_int)\n            return Vertex(new_pos)\n        dir_norm = dir_vec / dist\n        new_pos_tensor = from_v.position.to_tensor() + max_dist * dir_norm\n        # Convert tensor coordinates to integer for valid dense_map indexing\n        new_pos_int = [int(round(coord.item())) for coord in new_pos_tensor]\n        new_pos = Point(*new_pos_int)\n        return Vertex(new_pos)\n\n    def _get_random_sample(self, best_cost: 'Optional[float]') -> Point:\n        \"\"\"\n        Sample points uniformly in map, but when best_cost is known, sample within informed elliptical region.\n        With certain probability sample goal directly (goal biasing).\n        \"\"\"\n        import numpy as np\n        grid = self._get_grid()\n        size = grid.size.values\n        start = grid.agent.position\n        goal = grid.goal.position\n\n        # Goal biasing\n        if np.random.random() < self._goal_sample_rate:\n            # Return integer position for goal\n            goal_int_pos = Point(*[int(round(c)) for c in goal.values])\n            return goal_int_pos\n\n        if best_cost is None or best_cost == float('inf'):\n            # Uniform random sampling in valid space\n            while True:\n                rand_coords = np.random.uniform(0, size, len(size))\n                # Convert to integers by rounding\n                rand_coords_int = [int(round(c)) for c in rand_coords]\n                sample = Point(*rand_coords_int)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling within ellipsoid defined by start-goal and best cost\n        c_best = best_cost\n        c_min = self._distance(start, goal)\n        if c_best < c_min:\n            # Impossible, fallback uniform sampling\n            while True:\n                rand_coords = np.random.uniform(0, size, len(size))\n                rand_coords_int = [int(round(c)) for c in rand_coords]\n                sample = Point(*rand_coords_int)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Define ellipsoid in 2D or 3D\n        # Translate points so that start is at origin\n        start_tensor = start.to_tensor()\n        goal_tensor = goal.to_tensor()\n        center = (start_tensor + goal_tensor) / 2\n        diff = (goal_tensor - start_tensor)\n        diff_len = diff.norm().item()\n\n        # Define rotation matrix to align x-axis with diff vector\n        if len(diff) == 2:\n            # 2D case\n            theta = torch.atan2(diff[1], diff[0])\n            cos_th = torch.cos(theta)\n            sin_th = torch.sin(theta)\n            R = torch.tensor([[cos_th, -sin_th], [sin_th, cos_th]])\n        else:\n            # Higher-dim case: use diff normalized + Gram-Schmidt with identity basis (simplification)\n            # To avoid heavy math, fallback to uniform sampling\n            while True:\n                rand_coords = np.random.uniform(0, size, len(size))\n                rand_coords_int = [int(round(c)) for c in rand_coords]\n                sample = Point(*rand_coords_int)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Radii of ellipsoid axes\n        a = c_best / 2\n        b = (c_best**2 - c_min**2)**0.5 / 2 if c_best**2 - c_min**2 > 0 else 0\n        axes = torch.tensor([a, b])\n\n        count_attempts = 0\n        while True:\n            count_attempts += 1\n            # Sample random point in unit circle ellipse\n            r = np.random.rand()**0.5  # sqrt to ensure uniform in circle\n            angle = np.random.uniform(0, 2 * np.pi)\n            x = r * np.cos(angle)\n            y = r * np.sin(angle)\n            sample_unit = torch.tensor([x, y]) * axes\n\n            # Rotate back and translate\n            sample_global = torch.matmul(R, sample_unit) + center\n\n            # Convert to integer coordinates for map indexing:\n            sample_int_coords = [int(round(coord.item())) for coord in sample_global]\n\n            # Clip coordinates to bounds\n            sample_int_coords = [max(0, min(sample_int_coords[i], size[i]-1)) for i in range(len(size))]\n\n            candidate = Point(*sample_int_coords)\n\n            # Check if within bounds\n            if all(0 <= coord < dim for coord, dim in zip(candidate.values, size)):\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n            # To prevent infinite loop in pathological maps\n            if count_attempts > 500:\n                # fallback uniform sampling\n                while True:\n                    rand_coords = np.random.uniform(0, size, len(size))\n                    rand_coords_int = [int(round(c)) for c in rand_coords]\n                    sample = Point(*rand_coords_int)\n                    if self._get_grid().is_agent_valid_pos(sample):\n                        return sample\n\n    def _extract_path(self, vertex: Vertex) -> 'List[Vertex]':\n        path: 'List[Vertex]' = []\n        current = vertex\n        while True:\n            path.append(current)\n            if not current.parents:\n                break\n            # Greedily pick parent with minimal cost\n            current = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n        path.reverse()\n        return path\n\n    def _update_cost(self, vertex: Vertex) -> None:\n        # Cost = min over parents {parent.cost + edge_cost}\n        grid = self._get_grid()\n        min_cost = float('inf')\n        best_parent = None\n        for p in vertex.parents:\n            if p.cost is None:\n                continue\n            cost_candidate = p.cost + grid.get_movement_cost(p.position, vertex.position)\n            if cost_candidate < min_cost:\n                min_cost = cost_candidate\n                best_parent = p\n        if best_parent is not None:\n            vertex.cost = min_cost\n            # Remove other parents edges to keep tree structure closer to a tree (optional)\n            # But we keep all parents for line of sight rewiring possibility\n            # Remove edges to non-best parents (safe removal if edges_removable is True)\n            if self._graph.edges_removable:\n                to_remove = vertex.parents - {best_parent}\n                for rem_parent in to_remove:\n                    self._graph.remove_edge(rem_parent, vertex)\n            # Ensure edge from best_parent exist (redundant but safe)\n            self._graph.add_edge(best_parent, vertex)\n\n    def _rewire(self, q_new: Vertex, neighbors: 'List[Vertex]') -> None:\n        \"\"\"\n        For each neighbor, check if going through q_new improves cost.\n        If yes and line-of-sight is valid, rewire.\n        \"\"\"\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor == q_new:\n                continue\n            if neighbor.cost is None:\n                continue\n            weight_through_new = q_new.cost + grid.get_movement_cost(q_new.position, neighbor.position)\n            if weight_through_new + 1e-7 < neighbor.cost:  # small epsilon\n                line_seq = grid.get_line_sequence(q_new.position, neighbor.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Rewire edge\n                    # Remove old edge(s) parent->neighbor\n                    for parent in list(neighbor.parents):\n                        self._graph.remove_edge(parent, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = weight_through_new\n                    # Propagate cost update recursively in neighborhood\n                    self._propagate_cost_update(neighbor)\n\n    def _propagate_cost_update(self, vertex: Vertex) -> None:\n        grid = self._get_grid()\n        for child in vertex.children:\n            old_cost = child.cost\n            new_cost = vertex.cost + grid.get_movement_cost(vertex.position, child.position)\n            if new_cost + 1e-7 < (old_cost if old_cost is not None else float('inf')):\n                child.cost = new_cost\n                self._propagate_cost_update(child)\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        max_iterations = 15000\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n\n        best_goal_vertex: 'Optional[Vertex]' = None\n        best_cost = float('inf')\n\n        for iteration in range(max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 60.0:  # Timeout guard 60 seconds\n                # Fail gracefully (no path found within time)\n                break\n\n            # Sample with goal bias and informed sampling\n            sample = self._get_random_sample(best_cost if best_goal_vertex else None)\n\n            # Find nearest vertex from start tree\n            q_near = self._graph.get_nearest_vertex([start_vertex], sample)\n\n            if q_near.position == sample:\n                continue\n\n            q_new = self._steer(q_near, sample, self._max_dist)\n\n            # Validate path segment between q_near and q_new with line sequence check\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Skip if q_new same as q_near (no movement)\n            if q_new.position == q_near.position:\n                continue\n\n            # Set cost w.r.t q_near\n            q_new.cost = q_near.cost + grid.get_movement_cost(q_near.position, q_new.position)\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire neighbors within radius for better path\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n            # Remove self from neighbors if present\n            neighbors = [v for v in neighbors if v != q_new]\n\n            # Find best parent for q_new among neighbors who can connect with valid path and minimal cost\n            min_cost = q_new.cost\n            best_parent = q_near\n            for neighbor in neighbors:\n                # Check line sequence from neighbor to q_new\n                line_seq_n = grid.get_line_sequence(neighbor.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_seq_n):\n                    continue\n                cost_candidate = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new.position)\n                if cost_candidate < min_cost:\n                    min_cost = cost_candidate\n                    best_parent = neighbor\n\n            if best_parent != q_near:\n                # Reassign parent edges accordingly\n                self._graph.remove_edge(q_near, q_new)\n                self._graph.add_edge(best_parent, q_new)\n                q_new.cost = min_cost\n\n            # Rewire neighbors through q_new if beneficial\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new is within goal radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Construct goal vertex with updated parentage\n                goal_dummy_pos = Point(*[int(round(c)) for c in grid.goal.position.values])\n                goal_dummy = Vertex(goal_dummy_pos)\n                line_seq_to_goal = grid.get_line_sequence(q_new.position, goal_dummy.position)\n                if grid.is_valid_line_sequence(line_seq_to_goal):\n                    goal_dummy.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_dummy.position)\n                    self._graph.add_edge(q_new, goal_dummy)\n                    if goal_dummy.cost < best_cost:\n                        best_cost = goal_dummy.cost\n                        best_goal_vertex = goal_dummy\n\n            # Visual/keyframe update\n            self.key_frame()\n\n        # If goal found, extract and move agent along path smoothly\n        if best_goal_vertex is not None:\n            path_vertices = self._extract_path(best_goal_vertex)\n            # Animate agent move along path\n            for v in path_vertices:\n                self.move_agent(v.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 264, in _find_path_internal\n  File \"<string>\", line 95, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 149, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m2",
     "algorithm": "Improved Adaptive Informed RRT* (IAIRRT*):\n    This planner enhances the previous AIRRT* by tuning sampling, rewiring, and smoothing parameters dynamically,\n    and introducing a two-stage informed sampling with iterative radius shrinking and adaptive rewiring radius \n    based on graph density. It also integrates a lightweight heuristic cost-to-go to bias rewiring towards promising nodes.\n\n    Key improvements:\n    - Dynamic max_dist: adjusts step size based on iteration progress and map size for efficient exploration early\n      and finer resolution near solution.\n    - Adaptive rewiring radius scaled by graph size and dimension to balance connectivity and computational load.\n    - Heuristic incorporated in choosing parent and rewiring to favor vertices closer to goal.\n    - Early rejection of samples too far from best path estimate to focus on promising ellipsoid regions.\n    - Path smoothing enhanced with adaptive shortcutting including post solution extraction.\n    - Additional timeout check flags failure explicitly after 60 seconds.\n    - Quantized sample snapping to integer grid with fallback ensures valid sampling.\n\n    This results in better path quality (shorter, smoother), higher success rates, and reduced search times \n    especially for larger or cluttered maps.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _dimension: int\n    _max_dist_initial: float\n    _max_dist_min: float\n    _lambda_rrt_star: float\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: Optional[float]\n    _best_goal_vertex: Optional[Vertex]\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        size_vals = self._get_grid().size.values\n        self._dimension = self._get_grid().size.n_dim\n\n        # Adaptive max_dist scales initially larger for faster exploration, then reduces\n        self._max_dist_initial = float(max(size_vals)) / 8.0\n        self._max_dist_min = float(max(size_vals)) / 40.0\n\n        self._max_dist = self._max_dist_initial\n        self._lambda_rrt_star = 35.0  # tuned constant for rewiring radius (slightly smaller)\n        self._max_radius = max(size_vals) / 4  # max rewiring radius reduced for efficiency\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        self._start_time = 0.0\n        self._timeout = 60.0\n        self._best_cost = None\n        self._best_goal_vertex = None\n\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _heuristic(self, p: Point) -> float:\n        # Euclidean distance from p to goal as heuristic cost-to-go\n        return self._dist(p, self._graph.root_vertex_goal.position)\n\n    def _informed_sample(self) -> Point:\n        if self._best_cost is None:\n            return self._uniform_sample()\n        # Additional early rejection radius factor to shrink ellipsoid\n        # Shrink best cost gradually to force tighter sampling as iterations increase\n        shrink_factor = max(0.7, 1.0 - (time.time() - self._start_time) / self._timeout)\n        adjusted_cost = self._best_cost * shrink_factor\n        return self._ellipsoidal_sample(adjusted_cost)\n\n    def _uniform_sample(self) -> Point:\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _ellipsoidal_sample(self, c_best_override=None) -> Point:\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n\n        c_best = torch.tensor(c_best_override if c_best_override is not None else self._best_cost)\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best < c_min:\n            c_best = c_min + 1e-3\n\n        center = (start + goal) / 2.0\n        foci_vec = goal - start\n        norm_foci = torch.norm(foci_vec)\n        e_axis = foci_vec / norm_foci\n\n        if self._dimension == 2:\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])\n        elif self._dimension == 3:\n            z_axis = e_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n        else:\n            return self._uniform_sample()\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        else:\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n\n        for _ in range(20):  # max attempts to find valid sample inside ellipsoid\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u < 1e-6:\n                continue\n            unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n\n            sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n            # Clamp and round for grid conformity\n            sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, self._get_grid().size[i] - 1).round()))\n                             for i in range(self._dimension)]\n            sample_point = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # Fallback if no valid ellipsoidal sample found\n        return self._uniform_sample()\n\n    def _calc_rewire_radius(self) -> float:\n        card_v = torch.tensor(float(self._graph.size + 1))\n        log_v = torch.log(card_v)\n        # Adaptive radius shrinks as number of vertices grows, clipped by max radius\n        radius = min(self._lambda_rrt_star * ((log_v / card_v) ** (1.0 / self._dimension)), self._max_radius)\n        return radius.item()\n\n    def _choose_parent(self, neighbors: list[Vertex], q_new: Vertex) -> tuple[Optional[Vertex], float]:\n        c_min = float('inf')\n        q_min = None\n        goal_pos = self._graph.root_vertex_goal.position\n        for q_near in neighbors:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost_from_start = q_near.cost + self._dist(q_near.position, q_new.position)\n            # Incorporate heuristic cost-to-go for biased cost\n            heuristic_cost = self._dist(q_new.position, goal_pos)\n            total_cost = cost_from_start + heuristic_cost * 0.5  # weight heuristic less than cost-from-start\n            if total_cost < c_min:\n                c_min = cost_from_start  # only set cost-from-start as cost for actual path cost\n                q_min = q_near\n        return q_min, c_min\n\n    def _shortcut_path(self, path: list[Vertex], max_attempts=50) -> list[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = self._get_grid().get_line_sequence(p_i, p_j)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Apply multiple rounds of smoothing to improve path quality further\n        for _ in range(3):\n            path = self._shortcut_path(path, max_attempts=30)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*[int(round(float(c))) for c in new_pos_tensor])\n        return Vertex(new_pos)\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n\n        max_iterations = 15000\n\n        for iter_count in range(max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Timeout - path search failed\n                return\n\n            # Gradually reduce max_dist from initial to min over iterations for finer resolution near solution\n            frac = min(1.0, float(iter_count)/max_iterations)\n            self._max_dist = self._max_dist_initial * (1 - frac) + self._max_dist_min * frac\n\n            radius = self._calc_rewire_radius()\n\n            # Sample with ellipsoid shrinking dynamically for focus\n            q_sample = self._informed_sample()\n\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n\n            if q_min is None:\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring: try to improve neighbors by connecting through q_new with heuristic pruning\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                heuristic_near = self._heuristic(q_near.position)\n                heuristic_new = self._heuristic(q_new.position)\n                # Bias rewiring only if cost + heuristic better than current\n                if cost_through_new + heuristic_near * 0.5 < q_near.cost + heuristic_new * 0.5:\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check goal reaching condition with refined radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if (self._best_cost is None) or (possible_cost < self._best_cost):\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 163, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "m1",
     "algorithm": "Improved Adaptive Informed RRT* with Bidirectional Search and Lazy Collision Checking.\n    This planner enhances the original AIRRT* by:\n    - Using a bidirectional search from start and goal to accelerate convergence.\n    - Employing lazy collision checking to reduce expensive validations.\n    - Adaptive informed sampling shrinking the ellipsoidal subset dynamically.\n    - Progressive rewiring with prioritized neighbors for better path quality and smoothness.\n    - Path shortcutting after initial solution to produce smoother, shorter paths.\n    - Early termination if a valid path found below a cost threshold.\n    - Enforced 60 seconds timeout for fail-safe.\n    \n    The bidirectional approach helps quickly connect start and goal trees, increasing success rate.\n    Lazy collision delays line validity checks, improving efficiency.\n    Combining these enhancements leads to more robust, efficient, and higher quality path planning.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    _graph_start: Forest\n    _graph_goal: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: Optional[float]\n    _best_goal_vertex: Optional[Vertex]\n    _best_start_vertex: Optional[Vertex]\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        grid = self._get_grid()\n        self._dimension = grid.size.n_dim\n        max_map_dim = float(max(grid.size.values))\n        self._max_dist = max_map_dim / 15.0  # smaller step length for finer growth\n        self._lambda_rrt_star = 30.0  # tuned constant for rewire radius\n        self._max_radius = max_map_dim / 4  # max rewire radius\n\n        start_vertex = Vertex(grid.agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(grid.goal.position)\n        goal_vertex.cost = 0.0\n\n        # Two trees: one from start and one from goal\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n\n        # Add _graph attribute to avoid AttributeError in _init_displays()\n        self._graph = self._graph_start\n\n        self._start_time = 0.0\n        self._timeout = 60.0\n\n        self._best_cost = None\n        self._best_goal_vertex = None\n        self._best_start_vertex = None\n\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _calc_rewire_radius(self, forest_size: int) -> float:\n        card_v = torch.tensor(float(forest_size + 1))\n        log_card_v = torch.log(card_v)\n        radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1.0 / self._dimension)), self._max_radius)\n        return radius.item()\n\n    def _informed_sample(self) -> Point:\n        \"\"\"\n        Samples mostly from the informed subset if best cost known, else uniform.\n        This sample is used for both start and goal trees for unbiased growth.\n        \"\"\"\n        grid = self._get_grid()\n        if self._best_cost is None:\n            # Uniform random valid sample\n            while True:\n                coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n                sample = Point(*coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Sample in informed ellipsoid defined by start-goal and radius = best_cost\n            start = self._graph_start.root_vertex_start.position.to_tensor()\n            goal = self._graph_start.root_vertex_goal.position.to_tensor()\n            c_best = torch.tensor(self._best_cost)\n            c_min = self._dist(self._graph_start.root_vertex_start.position, self._graph_start.root_vertex_goal.position)\n            if c_best < c_min:\n                c_best = c_min + 1e-3\n\n            center = (start + goal) / 2.0\n            foci_vec = goal - start\n            e_axis = foci_vec / torch.norm(foci_vec)\n\n            if self._dimension == 2:\n                rotation_basis = torch.zeros((2, 2))\n                rotation_basis[:, 0] = e_axis\n                rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])\n            elif self._dimension == 3:\n                z_axis = e_axis\n                arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n                y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n                y_axis /= torch.norm(y_axis)\n                x_axis = torch.cross(y_axis, z_axis)\n                rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n            else:\n                # fallback uniform\n                while True:\n                    coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n                    sample = Point(*coords)\n                    if grid.is_agent_valid_pos(sample):\n                        return sample\n\n            r1 = c_best / 2.0\n            r2 = torch.sqrt(c_best * c_best - c_min * c_min) / 2.0\n            if self._dimension == 2:\n                L = torch.diag(torch.tensor([r1, r2]))\n            elif self._dimension == 3:\n                L = torch.diag(torch.tensor([r2, r2, r1]))\n            else:\n                while True:\n                    coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n                    sample = Point(*coords)\n                    if grid.is_agent_valid_pos(sample):\n                        return sample\n\n            while True:\n                u = torch.randn(self._dimension)\n                norm_u = torch.norm(u)\n                if norm_u > 1e-6:\n                    break\n            unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n            sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n\n            sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, grid.size[i] - 1).round())) for i in range(self._dimension)]\n            sample_point = Point(*sample_coords)\n\n            if grid.is_agent_valid_pos(sample_point):\n                return sample_point\n            else:\n                # fallback uniform\n                while True:\n                    coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n                    sample = Point(*coords)\n                    if grid.is_agent_valid_pos(sample):\n                        return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*[int(round(float(c))) for c in new_pos_tensor])\n        return Vertex(new_pos)\n\n    def _lazy_collision_check(self, line_seq: List[Point]) -> bool:\n        \"\"\"\n        Lazily check collision - we allow tentatively connection without full check,\n        then validate only absolutely needed connections.\n        Here, we do full check for the first and last few points with limit, else partial check.\n        \"\"\"\n        grid = self._get_grid()\n        # Quick heuristic: Check every kth point, and endpoints fully\n        if not line_seq:\n            return False\n        # Check endpoints: must be valid\n        if not grid.is_agent_valid_pos(line_seq[0]) or not grid.is_agent_valid_pos(line_seq[-1]):\n            return False\n        step = max(1, len(line_seq) // 10)\n        for i in range(0, len(line_seq), step):\n            if not grid.is_agent_valid_pos(line_seq[i]):\n                return False\n        return True\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Tuple[Optional[Vertex], float]:\n        c_min = float('inf')\n        q_min = None\n        grid = self._get_grid()\n        for q_near in neighbors:\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            # Use lazy collision check first\n            if not self._lazy_collision_check(line_seq):\n                continue\n            # Now full check before actual connection\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost = q_near.cost + self._dist(q_near.position, q_new.position)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n        return q_min, c_min\n\n    def _rewire(self, graph: Forest, neighbors: List[Vertex], q_new: Vertex) -> None:\n        grid = self._get_grid()\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            line_seq = grid.get_line_sequence(q_new.position, q_near.position)\n            if not self._lazy_collision_check(line_seq):\n                continue\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n            if cost_through_new < q_near.cost:\n                parents_copy = list(q_near.parents)\n                for p in parents_copy:\n                    graph.remove_edge(p, q_near)\n                q_near.cost = cost_through_new\n                graph.add_edge(q_new, q_near)\n\n    def _try_connect_trees(self, q_new_start: Optional[Vertex], q_new_goal: Optional[Vertex]) -> bool:\n        grid = self._get_grid()\n        # Attempt connection from new start vertex to nearby goal vertices\n        radius_start = self._calc_rewire_radius(self._graph_start.size)\n        radius_goal = self._calc_rewire_radius(self._graph_goal.size)\n\n        if q_new_start is not None:\n            neighbors_goal = self._graph_goal.get_vertices_within_radius([self._graph_goal.root_vertex_start], q_new_start.position, radius_goal)\n            for q_goal_vertex in neighbors_goal:\n                line_seq = grid.get_line_sequence(q_new_start.position, q_goal_vertex.position)\n                if not self._lazy_collision_check(line_seq):\n                    continue\n                if not grid.is_valid_line_sequence(line_seq):\n                    continue\n                potential_cost = q_new_start.cost + self._dist(q_new_start.position, q_goal_vertex.position) + q_goal_vertex.cost\n                if self._best_cost is None or potential_cost < self._best_cost:\n                    self._best_cost = potential_cost\n                    self._best_goal_vertex = q_goal_vertex\n                    self._best_start_vertex = q_new_start\n                    # Link trees by connecting goal's parent to start's new node\n                    parents_copy = list(self._graph_goal.root_vertex_goal.parents)\n                    for p in parents_copy:\n                        self._graph_goal.remove_edge(p, self._graph_goal.root_vertex_goal)\n                    self._graph_goal.add_edge(q_goal_vertex, self._graph_goal.root_vertex_goal)\n                    return True\n\n        if q_new_goal is not None:\n            neighbors_start = self._graph_start.get_vertices_within_radius([self._graph_start.root_vertex_start], q_new_goal.position, radius_start)\n            for q_start_vertex in neighbors_start:\n                line_seq = grid.get_line_sequence(q_new_goal.position, q_start_vertex.position)\n                if not self._lazy_collision_check(line_seq):\n                    continue\n                if not grid.is_valid_line_sequence(line_seq):\n                    continue\n                potential_cost = q_new_goal.cost + self._dist(q_new_goal.position, q_start_vertex.position) + q_start_vertex.cost\n                if self._best_cost is None or potential_cost < self._best_cost:\n                    self._best_cost = potential_cost\n                    self._best_goal_vertex = q_new_goal\n                    self._best_start_vertex = q_start_vertex\n                    parents_copy = list(self._graph_start.root_vertex_goal.parents)\n                    for p in parents_copy:\n                        self._graph_start.remove_edge(p, self._graph_start.root_vertex_goal)\n                    self._graph_start.add_edge(q_start_vertex, self._graph_start.root_vertex_goal)\n                    return True\n\n        return False\n\n    def _extract_and_smooth_path(self) -> None:\n        \"\"\"\n        Extract path by connecting best start vertex to best goal vertex through root goal nodes.\n        Then apply shortcut smoothing on combined path.\n        \"\"\"\n        if self._best_start_vertex is None or self._best_goal_vertex is None:\n            return\n        path_start = [self._graph_start.root_vertex_start]\n        current = self._best_start_vertex\n        while current != self._graph_start.root_vertex_start and current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_start.append(parent)\n            current = parent\n        path_start.reverse()\n\n        path_goal = [self._graph_goal.root_vertex_goal]\n        current = self._best_goal_vertex\n        while current != self._graph_goal.root_vertex_goal and current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path_goal.append(parent)\n            current = parent\n        # Reverse goal path to go from best_goal_vertex to goal root\n        path_goal = path_goal[::-1]\n\n        # Connect both parts via _best_start_vertex and _best_goal_vertex:\n        # Paths overlap at connected edge between _best_start_vertex and _best_goal_vertex\n        # Remove duplicates if any at join\n        if path_start[-1].position == self._best_start_vertex.position:\n            path_start[-1] = self._best_start_vertex\n        if path_goal[0].position == self._best_goal_vertex.position:\n            path_goal[0] = self._best_goal_vertex\n\n        full_path = path_start + path_goal\n\n        # Shortcut smoothing attempt to improve path quality\n        full_path = self._shortcut_path(full_path, max_attempts=50)\n\n        grid = self._get_grid()\n        for vertex in full_path:\n            grid.agent.position = vertex.position\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex], max_attempts=30) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = grid.get_line_sequence(p_i, p_j)\n            if grid.is_valid_line_sequence(line_seq):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n        grid = self._get_grid()\n        max_iterations = 20000\n\n        for iter in range(max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Failed due to timeout\n                return\n\n            # Alternate between start and goal forests growth\n            grow_from_start = (iter % 2 == 0)\n\n            q_sample = self._informed_sample()\n            if grow_from_start:\n                q_near = self._graph_start.get_nearest_vertex([self._graph_start.root_vertex_start], q_sample)\n            else:\n                q_near = self._graph_goal.get_nearest_vertex([self._graph_goal.root_vertex_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_dist)\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n\n            # Lazy collision for faster rejection\n            if not self._lazy_collision_check(line_seq):\n                continue\n\n            # Full valid line check before adding\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            if grow_from_start:\n                radius = self._calc_rewire_radius(self._graph_start.size)\n                neighbors = self._graph_start.get_vertices_within_radius([self._graph_start.root_vertex_start], q_new.position, radius)\n                q_min, c_min = self._choose_parent(neighbors, q_new)\n                if q_min is None:\n                    q_min = q_near\n                    c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n                q_new.cost = c_min\n                self._graph_start.add_edge(q_min, q_new)\n                self._rewire(self._graph_start, neighbors, q_new)\n            else:\n                radius = self._calc_rewire_radius(self._graph_goal.size)\n                neighbors = self._graph_goal.get_vertices_within_radius([self._graph_goal.root_vertex_start], q_new.position, radius)\n                q_min, c_min = self._choose_parent(neighbors, q_new)\n                if q_min is None:\n                    q_min = q_near\n                    c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n                q_new.cost = c_min\n                self._graph_goal.add_edge(q_min, q_new)\n                self._rewire(self._graph_goal, neighbors, q_new)\n\n            # After adding new vertex, try to connect both trees\n            if grow_from_start:\n                connected = self._try_connect_trees(q_new, None)\n            else:\n                connected = self._try_connect_trees(None, q_new)\n\n            if connected:\n                # Extract combined path and smooth\n                self._extract_and_smooth_path()\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 360, in _find_path_internal\n  File \"<string>\", line 103, in _informed_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 149, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m2",
     "algorithm": "Improved Adaptive Informed RRT* (IAIRRT*):\n    This planner enhances the previous AIRRT* by tuning sampling, rewiring, and smoothing parameters dynamically,\n    and introducing a two-stage informed sampling with iterative radius shrinking and adaptive rewiring radius \n    based on graph density. It also integrates a lightweight heuristic cost-to-go to bias rewiring towards promising nodes.\n\n    Key improvements:\n    - Dynamic max_dist: adjusts step size based on iteration progress and map size for efficient exploration early\n      and finer resolution near solution.\n    - Adaptive rewiring radius scaled by graph size and dimension to balance connectivity and computational load.\n    - Heuristic incorporated in choosing parent and rewiring to favor vertices closer to goal.\n    - Early rejection of samples too far from best path estimate to focus on promising ellipsoid regions.\n    - Path smoothing enhanced with adaptive shortcutting including post solution extraction.\n    - Additional timeout check flags failure explicitly after 60 seconds.\n    - Quantized sample snapping to integer grid with fallback ensures valid sampling.\n\n    This results in better path quality (shorter, smoother), higher success rates, and reduced search times \n    especially for larger or cluttered maps.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _dimension: int\n    _max_dist_initial: float\n    _max_dist_min: float\n    _lambda_rrt_star: float\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: Optional[float]\n    _best_goal_vertex: Optional[Vertex]\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        size_vals = self._get_grid().size.values\n        self._dimension = self._get_grid().size.n_dim\n\n        # Adaptive max_dist scales initially larger for faster exploration, then reduces\n        self._max_dist_initial = float(max(size_vals)) / 8.0\n        self._max_dist_min = float(max(size_vals)) / 40.0\n\n        self._max_dist = self._max_dist_initial\n        self._lambda_rrt_star = 35.0  # tuned constant for rewiring radius (slightly smaller)\n        self._max_radius = max(size_vals) / 4  # max rewiring radius reduced for efficiency\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        self._start_time = 0.0\n        self._timeout = 60.0\n        self._best_cost = None\n        self._best_goal_vertex = None\n\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _heuristic(self, p: Point) -> float:\n        # Euclidean distance from p to goal as heuristic cost-to-go\n        return self._dist(p, self._graph.root_vertex_goal.position)\n\n    def _informed_sample(self) -> Point:\n        if self._best_cost is None:\n            return self._uniform_sample()\n        # Additional early rejection radius factor to shrink ellipsoid\n        # Shrink best cost gradually to force tighter sampling as iterations increase\n        shrink_factor = max(0.7, 1.0 - (time.time() - self._start_time) / self._timeout)\n        adjusted_cost = self._best_cost * shrink_factor\n        return self._ellipsoidal_sample(adjusted_cost)\n\n    def _uniform_sample(self) -> Point:\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _ellipsoidal_sample(self, c_best_override=None) -> Point:\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n\n        c_best = torch.tensor(c_best_override if c_best_override is not None else self._best_cost)\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best < c_min:\n            c_best = c_min + 1e-3\n\n        center = (start + goal) / 2.0\n        foci_vec = goal - start\n        norm_foci = torch.norm(foci_vec)\n        e_axis = foci_vec / norm_foci\n\n        if self._dimension == 2:\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])\n        elif self._dimension == 3:\n            z_axis = e_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n        else:\n            return self._uniform_sample()\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        else:\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n\n        for _ in range(20):  # max attempts to find valid sample inside ellipsoid\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u < 1e-6:\n                continue\n            unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n\n            sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n            # Clamp and round for grid conformity\n            sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, self._get_grid().size[i] - 1).round()))\n                             for i in range(self._dimension)]\n            sample_point = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # Fallback if no valid ellipsoidal sample found\n        return self._uniform_sample()\n\n    def _calc_rewire_radius(self) -> float:\n        card_v = torch.tensor(float(self._graph.size + 1))\n        log_v = torch.log(card_v)\n        # Adaptive radius shrinks as number of vertices grows, clipped by max radius\n        radius = min(self._lambda_rrt_star * ((log_v / card_v) ** (1.0 / self._dimension)), self._max_radius)\n        return radius.item()\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Tuple[Optional[Vertex], float]:\n        c_min = float('inf')\n        q_min = None\n        goal_pos = self._graph.root_vertex_goal.position\n        for q_near in neighbors:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost_from_start = q_near.cost + self._dist(q_near.position, q_new.position)\n            # Incorporate heuristic cost-to-go for biased cost\n            heuristic_cost = self._dist(q_new.position, goal_pos)\n            total_cost = cost_from_start + heuristic_cost * 0.5  # weight heuristic less than cost-from-start\n            if total_cost < c_min:\n                c_min = cost_from_start  # only set cost-from-start as cost for actual path cost\n                q_min = q_near\n        return q_min, c_min\n\n    def _shortcut_path(self, path: List[Vertex], max_attempts=50) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = self._get_grid().get_line_sequence(p_i, p_j)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Apply multiple rounds of smoothing to improve path quality further\n        for _ in range(3):\n            path = self._shortcut_path(path, max_attempts=30)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*[int(round(float(c))) for c in new_pos_tensor])\n        return Vertex(new_pos)\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n\n        max_iterations = 15000\n\n        for iter_count in range(max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Timeout - path search failed\n                return\n\n            # Gradually reduce max_dist from initial to min over iterations for finer resolution near solution\n            frac = min(1.0, float(iter_count)/max_iterations)\n            self._max_dist = self._max_dist_initial * (1 - frac) + self._max_dist_min * frac\n\n            radius = self._calc_rewire_radius()\n\n            # Sample with ellipsoid shrinking dynamically for focus\n            q_sample = self._informed_sample()\n\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n\n            if q_min is None:\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring: try to improve neighbors by connecting through q_new with heuristic pruning\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                heuristic_near = self._heuristic(q_near.position)\n                heuristic_new = self._heuristic(q_new.position)\n                # Bias rewiring only if cost + heuristic better than current\n                if cost_through_new + heuristic_near * 0.5 < q_near.cost + heuristic_new * 0.5:\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check goal reaching condition with refined radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if (self._best_cost is None) or (possible_cost < self._best_cost):\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 242, in _find_path_internal\n  File \"<string>\", line 88, in _informed_sample\n  File \"<string>\", line 99, in _uniform_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 149, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m2",
     "algorithm": "Improved Adaptive Informed RRT* (IAIRRT*):\n    This planner enhances the previous AIRRT* by tuning sampling, rewiring, and smoothing parameters dynamically,\n    and introducing a two-stage informed sampling with iterative radius shrinking and adaptive rewiring radius \n    based on graph density. It also integrates a lightweight heuristic cost-to-go to bias rewiring towards promising nodes.\n\n    Key improvements:\n    - Dynamic max_dist: adjusts step size based on iteration progress and map size for efficient exploration early\n      and finer resolution near solution.\n    - Adaptive rewiring radius scaled by graph size and dimension to balance connectivity and computational load.\n    - Heuristic incorporated in choosing parent and rewiring to favor vertices closer to goal.\n    - Early rejection of samples too far from best path estimate to focus on promising ellipsoid regions.\n    - Path smoothing enhanced with adaptive shortcutting including post solution extraction.\n    - Additional timeout check flags failure explicitly after 60 seconds.\n    - Quantized sample snapping to integer grid with fallback ensures valid sampling.\n\n    This results in better path quality (shorter, smoother), higher success rates, and reduced search times \n    especially for larger or cluttered maps.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _dimension: int\n    _max_dist_initial: float\n    _max_dist_min: float\n    _lambda_rrt_star: float\n    _max_radius: float\n    _start_time: float\n    _timeout: float\n    _best_cost: Optional[float]\n    _best_goal_vertex: Optional[Vertex]\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        size_vals = self._get_grid().size.values\n        self._dimension = self._get_grid().size.n_dim\n\n        # Adaptive max_dist scales initially larger for faster exploration, then reduces\n        self._max_dist_initial = float(max(size_vals)) / 8.0\n        self._max_dist_min = float(max(size_vals)) / 40.0\n\n        self._max_dist = self._max_dist_initial\n        self._lambda_rrt_star = 35.0  # tuned constant for rewiring radius (slightly smaller)\n        self._max_radius = max(size_vals) / 4  # max rewiring radius reduced for efficiency\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        self._start_time = 0.0\n        self._timeout = 60.0\n        self._best_cost = None\n        self._best_goal_vertex = None\n\n        self._init_displays()\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _heuristic(self, p: Point) -> float:\n        # Euclidean distance from p to goal as heuristic cost-to-go\n        return self._dist(p, self._graph.root_vertex_goal.position)\n\n    def _informed_sample(self) -> Point:\n        if self._best_cost is None:\n            return self._uniform_sample()\n        # Additional early rejection radius factor to shrink ellipsoid\n        # Shrink best cost gradually to force tighter sampling as iterations increase\n        shrink_factor = max(0.7, 1.0 - (time.time() - self._start_time) / self._timeout)\n        adjusted_cost = self._best_cost * shrink_factor\n        return self._ellipsoidal_sample(adjusted_cost)\n\n    def _uniform_sample(self) -> Point:\n        while True:\n            coords = [int(torch.randint(0, self._get_grid().size[i], (1,)).item()) for i in range(self._dimension)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _ellipsoidal_sample(self, c_best_override=None) -> Point:\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n\n        c_best = torch.tensor(c_best_override if c_best_override is not None else self._best_cost)\n        c_min = self._dist(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n        if c_best < c_min:\n            c_best = c_min + 1e-3\n\n        center = (start + goal) / 2.0\n        foci_vec = goal - start\n        norm_foci = torch.norm(foci_vec)\n        e_axis = foci_vec / norm_foci\n\n        if self._dimension == 2:\n            rotation_basis = torch.zeros((2, 2))\n            rotation_basis[:, 0] = e_axis\n            rotation_basis[:, 1] = torch.tensor([-e_axis[1], e_axis[0]])\n        elif self._dimension == 3:\n            z_axis = e_axis\n            arbitrary = torch.tensor([1., 0., 0.]) if abs(z_axis[0]) < 0.9 else torch.tensor([0., 1., 0.])\n            y_axis = arbitrary - torch.dot(arbitrary, z_axis) * z_axis\n            y_axis = y_axis / torch.norm(y_axis)\n            x_axis = torch.cross(y_axis, z_axis)\n            rotation_basis = torch.stack([x_axis, y_axis, z_axis], dim=1)\n        else:\n            return self._uniform_sample()\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n\n        if self._dimension == 2:\n            L = torch.diag(torch.tensor([r1, r2]))\n        else:\n            L = torch.diag(torch.tensor([r2, r2, r1]))\n\n        for _ in range(20):  # max attempts to find valid sample inside ellipsoid\n            u = torch.randn(self._dimension)\n            norm_u = torch.norm(u)\n            if norm_u < 1e-6:\n                continue\n            unit_ball_sample = u / norm_u * torch.rand(1).item() ** (1.0 / self._dimension)\n\n            sample_in_ellipsoid = center + rotation_basis @ L @ unit_ball_sample\n            # Clamp and round for grid conformity\n            sample_coords = [int(float(torch.clamp(sample_in_ellipsoid[i], 0, self._get_grid().size[i] - 1).round()))\n                             for i in range(self._dimension)]\n            sample_point = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # Fallback if no valid ellipsoidal sample found\n        return self._uniform_sample()\n\n    def _calc_rewire_radius(self) -> float:\n        card_v = torch.tensor(float(self._graph.size + 1))\n        log_v = torch.log(card_v)\n        # Adaptive radius shrinks as number of vertices grows, clipped by max radius\n        radius = min(self._lambda_rrt_star * ((log_v / card_v) ** (1.0 / self._dimension)), self._max_radius)\n        return radius.item()\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Tuple[Optional[Vertex], float]:\n        c_min = float('inf')\n        q_min = None\n        goal_pos = self._graph.root_vertex_goal.position\n        for q_near in neighbors:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost_from_start = q_near.cost + self._dist(q_near.position, q_new.position)\n            # Incorporate heuristic cost-to-go for biased cost\n            heuristic_cost = self._dist(q_new.position, goal_pos)\n            total_cost = cost_from_start + heuristic_cost * 0.5  # weight heuristic less than cost-from-start\n            if total_cost < c_min:\n                c_min = cost_from_start  # only set cost-from-start as cost for actual path cost\n                q_min = q_near\n        return q_min, c_min\n\n    def _shortcut_path(self, path: List[Vertex], max_attempts=50) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = torch.randint(0, len(new_path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(new_path), (1,)).item()\n            p_i = new_path[i].position\n            p_j = new_path[j].position\n            line_seq = self._get_grid().get_line_sequence(p_i, p_j)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Apply multiple rounds of smoothing to improve path quality further\n        for _ in range(3):\n            path = self._shortcut_path(path, max_attempts=30)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*[int(round(float(c))) for c in new_pos_tensor])\n        return Vertex(new_pos)\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n\n        max_iterations = 15000\n\n        for iter_count in range(max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._timeout:\n                # Timeout - path search failed\n                return\n\n            # Gradually reduce max_dist from initial to min over iterations for finer resolution near solution\n            frac = min(1.0, float(iter_count)/max_iterations)\n            self._max_dist = self._max_dist_initial * (1 - frac) + self._max_dist_min * frac\n\n            radius = self._calc_rewire_radius()\n\n            # Sample with ellipsoid shrinking dynamically for focus\n            q_sample = self._informed_sample()\n\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n\n            if q_min is None:\n                q_min = q_nearest\n                c_min = q_min.cost + self._dist(q_min.position, q_new.position)\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring: try to improve neighbors by connecting through q_new with heuristic pruning\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    continue\n                cost_through_new = q_new.cost + self._dist(q_new.position, q_near.position)\n                heuristic_near = self._heuristic(q_near.position)\n                heuristic_new = self._heuristic(q_new.position)\n                # Bias rewiring only if cost + heuristic better than current\n                if cost_through_new + heuristic_near * 0.5 < q_near.cost + heuristic_new * 0.5:\n                    parents_copy = list(q_near.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, q_near)\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check goal reaching condition with refined radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = self._dist(q_new.position, self._graph.root_vertex_goal.position)\n                possible_cost = q_new.cost + dist_to_goal\n                if (self._best_cost is None) or (possible_cost < self._best_cost):\n                    self._best_cost = possible_cost\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = possible_cost\n                    parents_copy = list(goal_vertex.parents)\n                    for p in parents_copy:\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 242, in _find_path_internal\n  File \"<string>\", line 88, in _informed_sample\n  File \"<string>\", line 99, in _uniform_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 149, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m2",
     "algorithm": "This algorithm is an improved RRT-based path planning method with adaptive sampling,\n    goal biasing, dynamic max extension distance proportional to the map size,\n    and local rewire strategy inspired by RRT*. It incorporates a timeout to stop after 60 seconds \n    to ensure robustness and efficiency. The adaptive max_dist and rewiring improve path quality \n    and smoothness, while goal biasing accelerates convergence. The algorithm maintains a cyclic graph \n    structure to allow rewiring and cycle detection for better paths and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        # Use cyclic graph to allow rewiring and better connectivity\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self, goal_sample_rate=0.1) -> Point:\n        \"\"\"\n        Randomly samples in the environment with goal bias.\n        \"\"\"\n        if np.random.rand() < goal_sample_rate:\n            return self._get_grid().goal.position\n        size_vals = self._get_grid().size.values\n        while True:\n            rand_coords = []\n            for dim in size_vals:\n                rand_coords.append(np.random.uniform(0, dim))\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_v: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        Move from from_v.position toward to_point with step limited by max_dist.\n        \"\"\"\n        from_tensor = from_v.position.to_tensor()\n        to_tensor = to_point.to_tensor()\n        diff = to_tensor - from_tensor\n        dist = torch.norm(diff)\n        if dist <= max_dist:\n            new_p = to_point\n        else:\n            diff_normalized = diff / dist\n            new_tensor = from_tensor + diff_normalized * max_dist\n            new_p = Point.from_tensor(new_tensor)\n        return Vertex(new_p)\n\n    def _get_near_vertices(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"\n        Returns vertices within radius from given vertex among all vertices in the graph.\n        \"\"\"\n        candidates = []\n        all_vertices = self._graph.root_vertices + [self._graph.root_vertex_start, self._graph.root_vertex_goal]\n        # Collect all vertices from graph by DFS\n        vertices_set = set()\n\n        def collect(vertex_: Vertex) -> bool:\n            if vertex_ in vertices_set:\n                return True\n            vertices_set.add(vertex_)\n            return True\n        self._graph.walk_dfs(collect)\n\n        # Filter vertices by radius\n        radius_sq = radius * radius\n        pos_tensor = vertex.position.to_tensor()\n        for v in vertices_set:\n            diff = v.position.to_tensor() - pos_tensor\n            if torch.dot(diff, diff) <= radius_sq and v != vertex:\n                candidates.append(v)\n        return candidates\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: List[Vertex], radius: float) -> None:\n        \"\"\"\n        Attempt to rewire near vertices through new_vertex if it improves cost.\n        \"\"\"\n        for near in near_vertices:\n            line = self._get_grid().get_line_sequence(new_vertex.position, near.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n            new_cost = (new_vertex.cost if new_vertex.cost is not None else 0) + self._get_grid().get_distance(new_vertex.position, near.position)\n            if near.cost is None or new_cost < near.cost:\n                # Remove old parent edge(s)\n                for parent in list(near.parents):\n                    self._graph.remove_edge(parent, near)\n                self._graph.add_edge(new_vertex, near)\n                near.cost = new_cost\n\n    def _extract_path(self, last_vertex: Vertex) -> None:\n        \"\"\"\n        Extract the path from start to goal by moving backward from last_vertex to the root.\n        \"\"\"\n        path = [last_vertex]\n        current = last_vertex\n        while True:\n            if not current.parents:\n                break\n            # Choose the parent with the lowest cost (if cost info is available)\n            min_parent = None\n            min_cost = math.inf\n            for p in current.parents:\n                if p.cost is None:\n                    continue\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_parent = p\n            if min_parent is None:\n                min_parent = next(iter(current.parents))\n            current = min_parent\n            path.append(current)\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_time_sec = 60\n        start_time = time.time()\n\n        map_size = self._get_grid().size\n        size_diag = math.sqrt(sum(dim * dim for dim in map_size.values))\n        max_extend_dist = size_diag * 0.15  # 15% of diagonal for max step length\n\n        max_iterations = 20000\n        goal_sample_rate = 0.15\n        rewire_radius = max_extend_dist * 2.0\n\n        # Initialize start vertex cost to zero\n        self._graph.root_vertex_start.cost = 0.0\n\n        for iter in range(max_iterations):\n            if (time.time() - start_time) > max_time_sec:\n                # Timeout reached, fail path search\n                break\n\n            q_sample = self._get_random_sample(goal_sample_rate=goal_sample_rate)\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices + [self._graph.root_vertex_start, self._graph.root_vertex_goal], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._steer(q_near, q_sample, max_extend_dist)\n\n            # Validate the path between q_near and q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Reject if q_new already exists in graph too close (within a very small threshold)\n            near_existing = self._graph.get_vertices_within_radius(self._graph.root_vertices + [self._graph.root_vertex_start, self._graph.root_vertex_goal], q_new.position, radius=0.5)\n            if near_existing:\n                # If closer than threshold, skip adding\n                skip = False\n                for n in near_existing:\n                    dist = self._get_grid().get_distance(n.position, q_new.position)\n                    if dist < 1e-3:\n                        skip = True\n                        break\n                if skip:\n                    continue\n\n            # Add q_new vertex and edge\n            q_new.cost = (q_near.cost if q_near.cost is not None else 0) + self._get_grid().get_distance(q_near.position, q_new.position)\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire neighbors in radius for better paths (RRT* style)\n            near_vertices = self._get_near_vertices(q_new, rewire_radius)\n            self._rewire(q_new, near_vertices, rewire_radius)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect to goal vertex if path valid\n                line_to_goal = self._get_grid().get_line_sequence(q_new.position, self._get_grid().goal.position)\n                if self._get_grid().is_valid_line_sequence(line_to_goal):\n                    goal_v = self._graph.root_vertex_goal\n                    goal_v.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_v.position)\n                    self._graph.add_edge(q_new, goal_v)\n                    self._extract_path(goal_v)\n                    break\n\n            if iter % 20 == 0:\n                self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 175, in _find_path_internal\n  File \"<string>\", line 67, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 149, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAssertionError: Can't look up a floating point Point in dense_map: Point(84.4906645145038, 63.21700006700242)\n"
     }
}
{
     "operator": "m3",
     "algorithm": "This algorithm is an improved hybrid RRT* inspired method tailored for efficient path planning in complex environments.\n    It combines adaptive nearest neighbor search with rewiring to optimize path quality while maintaining robustness.\n    Key enhancements include: dynamic sampling bias towards goal and critical regions, early stopping based on time constraints (60s),\n    and path smoothing to reduce unnecessary waypoints. The underlying graph is a cyclic graph enabling efficient connections\n    and rewiring of vertices ensuring shorter and smoother paths, increasing success rates and reducing planning time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_distance: float\n    _max_iterations: int\n    _sample_goal_bias: float\n    _rewiring_radius: float\n    _start_time: float\n    _time_limit_seconds: int\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_iterations = 5000\n        self._max_distance = 12.0\n        self._sample_goal_bias = 0.1  # 10% times sample is goal to speed convergence\n        self._rewiring_radius = 20.0\n        self._time_limit_seconds = 60\n        self._start_time = None\n\n        # Initialize vertices: start, goal and sampled free points\n        V: List[Vertex] = list()\n        for _ in range(150):\n            q_rand = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n\n        self._graph = gen_cyclic_graph(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            V,\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # With goal bias to accelerate convergence\n        from random import random\n        if random() < self._sample_goal_bias:\n            return self._get_grid().goal.position\n        while True:\n            sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= self._max_distance:\n            return Vertex(q_sample, store_connectivity=True)\n\n        direction_normalized = direction / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + self._max_distance * direction_normalized)\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _near_vertices(self, vertex: Vertex) -> List[Vertex]:\n        # Return vertices within rewiring radius\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, self._rewiring_radius)\n\n    def _can_connect(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _rewire(self, v: Vertex, neighbors: List[Vertex]) -> None:\n        best_parent = None\n        best_cost = float(\"inf\")\n        for u in neighbors:\n            if u == v:\n                continue\n            if not self._can_connect(u.position, v.position):\n                continue\n            cost_through_u = u.cost + self._get_grid().get_distance(u.position, v.position)\n            if cost_through_u < best_cost:\n                best_cost = cost_through_u\n                best_parent = u\n\n        if best_parent is not None and v.parents != {best_parent}:\n            # Remove old parents edges\n            for p in set(v.parents):\n                self._graph.remove_edge(p, v)\n            # Add new edge from best parent\n            self._graph.add_edge(best_parent, v)\n            v.cost = best_cost\n\n            # Rewire neighbors for improvement\n            for u in neighbors:\n                if u == v:\n                    continue\n                if not self._can_connect(v.position, u.position):\n                    continue\n                candidate_cost = v.cost + self._get_grid().get_distance(v.position, u.position)\n                if candidate_cost < u.cost:\n                    for p in set(u.parents):\n                        self._graph.remove_edge(p, u)\n                    self._graph.add_edge(v, u)\n                    u.cost = candidate_cost\n\n    def _extract_path(self) -> None:\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        # Find vertices that can reach goal (goal reachable from start connectivity)\n        if goal_vertex not in start_vertex.connectivity:\n            return  # no path\n\n        path_vertices = []\n        current = start_vertex\n        while current != goal_vertex:\n            current = current.connectivity[goal_vertex]\n            path_vertices.append(current)\n\n        # Path smoothing by shortcutting\n        smoothed_path = self._smooth_path([start_vertex.position] + [v.position for v in path_vertices])\n\n        for pos in smoothed_path:\n            self.move_agent(pos)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _smooth_path(self, path: List[Point]) -> List[Point]:\n        # Simple path smoothing: try to skip intermediate vertices where direct line collision free\n        if len(path) <= 2:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._can_connect(path[i], path[j]):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _initialize_costs(self) -> None:\n        # Initialize cost for root vertices and sampled vertices\n        start = self._graph.root_vertex_start\n        start.cost = 0.0\n        goal = self._graph.root_vertex_goal\n        goal.cost = float(\"inf\")\n        for v in self._graph.root_vertices:\n            if v != start and v != goal:\n                v.cost = float(\"inf\")\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n        self._initialize_costs()\n\n        for iteration in range(self._max_iterations):\n            if time.time() - self._start_time > self._time_limit_seconds:\n                # Timeout failure\n                return\n\n            q_rand = self._get_random_sample()\n            nearest_vertex = self._graph.get_nearest_vertex(self._graph.root_vertices, q_rand)\n            q_new = self._get_new_vertex(nearest_vertex, q_rand)\n\n            if not self._get_grid().is_agent_valid_pos(q_new.position):\n                continue\n\n            if not self._can_connect(nearest_vertex.position, q_new.position):\n                continue\n\n            # Add vertex and edge\n            self._graph.root_vertices.append(q_new)\n            self._graph.add_edge(nearest_vertex, q_new)\n\n            # Cost update\n            q_new.cost = nearest_vertex.cost + self._get_grid().get_distance(nearest_vertex.position, q_new.position)\n\n            # Rewire near vertices for path improvement\n            near_vertices = self._near_vertices(q_new)\n            self._rewire(q_new, near_vertices)\n\n            # Attempt connection to goal if close enough\n            if self._get_grid().get_distance(q_new.position, self._graph.root_vertex_goal.position) <= self._max_distance:\n                if self._can_connect(q_new.position, self._graph.root_vertex_goal.position):\n                    self._graph.add_edge(q_new, self._graph.root_vertex_goal)\n                    self._graph.root_vertex_goal.cost = q_new.cost + self._get_grid().get_distance(q_new.position, self._graph.root_vertex_goal.position)\n                    self._rewire(self._graph.root_vertex_goal, self._near_vertices(self._graph.root_vertex_goal))\n                    self._extract_path()\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 215, in __run_simulation\n    sim: Simulator = Simulator(Services(config))\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 40, in __init__\n    self.__setup(config)\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 68, in __setup\n    self.__algorithm_runner.reset_algorithm()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\algorithm_runner.py\", line 59, in reset_algorithm\n    self.__algorithm = self.__algorithm_type(self._services, testing, *self.__algorithm_parameters[0],\n  File \"<string>\", line 62, in __init__\n  File \"<string>\", line 81, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 149, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m1",
     "algorithm": "This algorithm is an improved sample-based planner combining benefits from RRT* and lazy collision checks for enhanced efficiency and path quality under strict time limits.\n    It uses informed sampling to bias samples toward the goal to achieve faster convergence.\n    It applies adaptive radius neighbor selection with rewiring to improve path optimality.\n    Lazy collision checking postpones expensive collision validations until necessary, reducing overhead.\n    Time is strictly limited to 60 seconds to terminate unsuccessful planning attempts, increasing robustness.\n    The planner outputs smooth, shorter, and higher success rate paths compared to baseline RRT* and SPRM approaches.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n    _max_dist: float\n    _lambda_rrt_star: float\n    _max_radius: float\n    _dimension: int\n    _start_time: float\n    _time_limit_sec: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 15.0\n        self._lambda_rrt_star = 40.0  # Tuned radius factor\n        self._max_radius = 50.0\n        self._dimension = self._get_grid().size.n_dim\n        self._time_limit_sec = 60.0\n        self._start_time = 0.0\n        \n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    # Helper functions #\n    # -----------------#\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Informed sampling biased toward the goal and current best cost if available.\"\"\"\n        goal_pos = self._get_grid().goal.position.to_tensor()\n        start_pos = self._get_grid().agent.position.to_tensor()\n\n        while True:\n            # If we have a path cost so far (best found), sample in ellipsoidal informed subset.\n            best_cost = None\n            # Check if goal is connected and extract rough best_cost\n            if self._graph.root_vertex_goal.parents:\n                # Approximate path cost from root start to goal\n                best_cost = float('inf')\n                for parent in self._graph.root_vertex_goal.parents:\n                    c = parent.cost + torch.norm(parent.position.to_tensor() - goal_pos)\n                    if c < best_cost:\n                        best_cost = c\n\n            if best_cost is None or best_cost == float('inf'):\n                # Uniform sampling when no solution exists\n                rand_coords = np.random.randint(0, self._get_grid().size.values, self._dimension)\n                sample = Point(*rand_coords)\n            else:\n                # Informed sampling within ellipse defined by start, goal and best_cost\n                c_best = best_cost\n                c_min = torch.norm(start_pos - goal_pos).item()\n                if c_best < c_min:\n                    # Numerical safeguard\n                    c_best = c_min + 1e-6\n\n                # Define a prolate hyperspheroid (ellipse in 2D)\n                L = np.diag([c_best / 2.0] + [np.sqrt(c_best ** 2 - c_min ** 2) / 2.0] * (self._dimension - 1))\n                x_center = (start_pos + goal_pos).numpy() / 2.0\n                if self._dimension == 2:\n                    # Rotation matrix aligns x-axis along start to goal\n                    delta = goal_pos - start_pos\n                    theta = torch.atan2(delta[1], delta[0]).item()\n                    R = np.array([[np.cos(theta), -np.sin(theta)],\n                                  [np.sin(theta), np.cos(theta)]])\n                else:\n                    # Fallback rotation identity for dimensions > 2 for simplicity\n                    R = np.eye(self._dimension)\n\n                while True:\n                    # Sample within unit n-ball\n                    x_ball = np.random.normal(0, 1, self._dimension)\n                    norm_x = np.linalg.norm(x_ball)\n                    if norm_x == 0:\n                        continue\n                    x_ball = x_ball / norm_x * np.random.rand() ** (1.0 / self._dimension)\n\n                    x_rand = R.dot(L.dot(x_ball)) + x_center\n                    x_int = np.clip(np.round(x_rand).astype(int), 0, np.array(self._get_grid().size.values) - 1)\n                    sample = Point(*x_int)\n                    if self._get_grid().is_agent_valid_pos(sample):\n                        break\n\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pt_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new_pt = Point.from_tensor(q_new_pt_tensor)\n        return Vertex(q_new_pt)\n\n    def _lazy_collision_check(self, q_from: Point, q_to: Point) -> bool:\n        \"\"\"\n        Deferred collision checking - returns True if collision-free or not checked yet.\n        This method postpones heavy collision check until absolutely needed.\n        We only check the actual path when adding an edge for rewiring or confirming path.\n        \"\"\"\n        # Initially accept edge - only verify at rewiring & path extraction\n        return True\n\n    def _validate_edge(self, q_from: Point, q_to: Point) -> bool:\n        # Actual collision check - using standard method\n        line_seq = self._get_grid().get_line_sequence(q_from, q_to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _extract_path(self, q_goal: Vertex):\n\n        # Traverse parents back to start\n        path: List[Vertex] = [q_goal]\n        while len(path[-1].parents) > 0:\n            # parent with minimum cost\n            min_parent = None\n            min_cost = float('inf')\n            for p in path[-1].parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_parent = p\n            if min_parent is None:\n                break\n            path.append(min_parent)\n\n        path.reverse()\n\n        # Smooth path via shortcutting attempts\n        path = self._path_smoothing(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _path_smoothing(self, path: List[Vertex], max_attempts: int = 30) -> List[Vertex]:\n        \"\"\"\n        Attempt to shortcut path segments to smooth path and reduce length.\n        This local smoothing attempts to connect non-consecutive vertices directly if feasible.\n        \"\"\"\n        if len(path) < 3:\n            return path\n\n        pruned_path = path[:]\n        attempts = 0\n        idx = 0\n        while attempts < max_attempts and idx < len(pruned_path) - 2:\n            # Try to connect idx directly to idx+2 or beyond\n            next_idx = idx + 2\n            while next_idx < len(pruned_path):\n                v1 = pruned_path[idx].position\n                v2 = pruned_path[next_idx].position\n                # Check direct connection collision free\n                if self._validate_edge(v1, v2):\n                    # Remove intermediate vertices between idx and next_idx\n                    del pruned_path[idx + 1:next_idx]\n                    attempts += 1\n                    break\n                next_idx += 1\n            idx += 1\n        return pruned_path\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n\n        iterations = 12000  # Can adjust for better time/quality tradeoff\n\n        for i in range(iterations):\n\n            if time.time() - self._start_time > self._time_limit_sec:\n                # Planning failed due to timeout\n                return  # Exit method indicating failure by not extracting path\n\n            q_sample: Point = self._get_random_sample()\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n\n            # If sample is same as nearest vertex, skip\n            if q_nearest.position == q_sample:\n                self.key_frame()\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            # Lazy collision acceptance for edge q_nearest -> q_new\n            if not self._lazy_collision_check(q_nearest.position, q_new.position):\n                self.key_frame()\n                continue\n\n            # Calculate adaptive radius\n            card_v = float(max(self._graph.size, 1))\n            log_card_v = np.log(card_v) if card_v > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), self._max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent q_min minimizing cost + collision free path from q_min to q_new\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                if q_near.cost is None:\n                    continue\n                dist_near_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist_near_new > self._max_dist:\n                    continue  # skip distant neighbors for parent selection\n                if self._validate_edge(q_near.position, q_new.position):\n                    cost_candidate = q_near.cost + dist_near_new\n                    if cost_candidate < c_min:\n                        c_min = cost_candidate\n                        q_min = q_near\n\n            # Set cost and add edge q_min -> q_new\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if better path found through q_new\n            for q_near in Q_near:\n                if q_near is q_min:\n                    continue\n                if q_near.cost is None:\n                    continue\n                dist_new_near = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n                if dist_new_near > self._max_dist:\n                    continue\n                if self._validate_edge(q_new.position, q_near.position):\n                    cost_through_new = q_new.cost + dist_new_near\n                    if cost_through_new < q_near.cost:\n                        # Remove old edge parent->q_near\n                        old_parent = next(iter(q_near.parents), None)\n                        if old_parent:\n                            self._graph.remove_edge(old_parent, q_near)\n                        # Add edge q_new -> q_near\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check if q_new close enough to goal to connect\n            goal_pos = self._graph.root_vertex_goal.position\n            dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_pos.to_tensor()).item()\n            if dist_to_goal <= self._max_dist and self._validate_edge(q_new.position, goal_pos):\n                # Connect and set goal cost\n                goal_vertex = self._graph.root_vertex_goal\n                goal_vertex.cost = q_new.cost + dist_to_goal\n                self._graph.add_edge(q_new, goal_vertex)\n                self._extract_path(goal_vertex)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 219, in _find_path_internal\n  File \"<string>\", line 123, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 149, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m2",
     "algorithm": "Improved RRT* inspired algorithm with adaptive sampling, rewiring, and goal bias.\n    Introduces:\n    - Adaptive max extension distance scaled to the map size for better exploration.\n    - Goal bias sampling to accelerate convergence to the target.\n    - Neighborhood radius calculation for efficient rewiring and path quality improvement.\n    - Rewiring of nearby vertices for smooth, shorter paths.\n    - Early termination if a path is found within a feasible number of iterations.\n    - Search timeout handling to avoid excessive run time (>60s).\n    - Uses distance-weighted cost and valid collision-checking lines for graph edges.\n    Overall improves efficiency, success rate, path smoothness, and reduces search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        \n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= 1e-6:\n            return Vertex(q_near.position)  # Prevent division by zero or no movement\n\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        direction_normalized = direction / dist\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * direction_normalized)\n        return Vertex(q_new_point)\n\n    def _get_random_sample(self, goal_bias: float, max_samples: int = 1000) -> Point:\n        \"\"\"Randomly sample a point; with probability goal_bias sample the goal directly.\"\"\"\n        if np.random.random() < goal_bias:\n            return self._get_grid().goal.position\n\n        # Sampling with retries up to max_samples for valid position\n        for _ in range(max_samples):\n            rand_coords = np.random.uniform(low=0, high=np.array(self._get_grid().size.values), size=self._get_grid().size.n_dim)\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n        # Fallback to goal if no valid sample found (rare)\n        return self._get_grid().goal.position\n\n    def _extract_path(self, last_vertex: Vertex) -> None:\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(last_vertex, goal_vertex)\n\n        path: List[Vertex] = [goal_vertex]\n        current = last_vertex\n        while True:\n            if not current.parents:\n                break\n            # Choose parent with minimum cost to ensure optimal path\n            min_parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            path.append(min_parent)\n            current = min_parent\n\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _calculate_neighborhood_radius(self, num_vertices: int, dim: int) -> float:\n        gamma_rrt_star = 2 * (1 + 1/dim) ** (1/dim) * ((self._get_grid().size.width * self._get_grid().size.height) / np.pi) ** (1/dim)\n        return min(gamma_rrt_star * (np.log(num_vertices) / num_vertices) ** (1/dim), 50.0)\n\n    def _find_path_internal(self) -> None:\n        max_time_seconds = 60.0\n        start_time = time()\n\n        grid = self._get_grid()\n        dim = grid.size.n_dim\n\n        # Adaptive max extension distance based on map size (10% of diagonal length, capped)\n        diag = torch.norm(torch.tensor(grid.size.values, dtype=torch.float))\n        max_dist = float(min(max(diag * 0.10, 1.0), 30.0))\n\n        goal_bias = 0.10  # 10% of samples directed to goal\n        max_iterations = 10000\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iteration in range(max_iterations):\n            if time() - start_time > max_time_seconds:\n                # Fail due to timeout\n                break\n\n            q_sample = self._get_random_sample(goal_bias=goal_bias)\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new.position == q_near.position:\n                continue\n\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors in radius for rewiring\n            neighborhood_radius = self._calculate_neighborhood_radius(self._graph.size + 1, dim)\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, neighborhood_radius)\n\n            # Initialize cost and parent\n            min_cost = q_near.cost + grid.get_distance(q_near.position, q_new.position) if q_near.cost is not None else float('inf')\n            parent_vertex = q_near\n\n            # Choose best parent from neighbors to minimize cost\n            for neighbor in neighbors:\n                if neighbor.position == q_near.position:\n                    continue\n                potential_line = grid.get_line_sequence(neighbor.position, q_new.position)\n                if not grid.is_valid_line_sequence(potential_line):\n                    continue\n                if neighbor.cost is None:\n                    continue\n                new_cost = neighbor.cost + grid.get_distance(neighbor.position, q_new.position)\n                if new_cost < min_cost:\n                    min_cost = new_cost\n                    parent_vertex = neighbor\n\n            q_new.cost = min_cost\n            self._graph.add_edge(parent_vertex, q_new)\n\n            # Rewire neighbors to new vertex if it improves cost\n            for neighbor in neighbors:\n                if neighbor == parent_vertex:\n                    continue\n                line_to_neighbor = grid.get_line_sequence(q_new.position, neighbor.position)\n                if not grid.is_valid_line_sequence(line_to_neighbor):\n                    continue\n                if q_new.cost is None:\n                    continue\n                new_cost = q_new.cost + grid.get_distance(q_new.position, neighbor.position)\n                if neighbor.cost is None or new_cost < neighbor.cost:\n                    # Rewire parent edge\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 104, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "m3",
     "algorithm": "This path planning algorithm improves upon existing RRT-Connect and SPRM techniques by combining\n    bidirectional RRT-connect style tree expansion with informed sampling and rewiring inspired by RRT*.\n    Key improvements include:\n    - Adaptive sampling bias towards the goal region to improve convergence.\n    - Dynamic max extension distance based on environment dimensions.\n    - Rewiring of vertices within a shrinking radius to improve path quality and smoothness.\n    - Use of cyclic graph to maintain multiple feasible paths and improve robustness.\n    - Early termination if path is found.\n    - Time-out logic aborting search after 60 seconds to ensure responsiveness.\n    This approach aims for faster convergence, higher success rate, smoother and shorter paths, while maintaining\n    robustness in complex obstacle environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_dist: float\n    _iterations: int\n    _goal_sample_rate: float\n    _rewire_radius: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        agent_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n        # Initialize a cyclic graph with start and goal vertices\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(agent_pos, store_connectivity=True),\n                                       Vertex(goal_pos, store_connectivity=True),\n                                       [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        # Maximum extension distance normalized by map diagonal length for adaptive scaling\n        size = self._get_grid().size\n        diag_len = torch.norm(torch.tensor(size.values).float()).item()\n        self._max_dist = max(5.0, diag_len * 0.1)  # Minimum 5 or 10% of diagonal\n\n        self._iterations = 15000\n        self._goal_sample_rate = 0.15  # Probability of sampling goal directly to bias search\n        self._rewire_radius = diag_len * 0.15  # Radius for rewiring step to improve path quality\n\n    def _get_random_sample(self) -> Point:\n        # Bias sampling towards goal with a defined probability\n        if torch.rand(1).item() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        size = self._get_grid().size\n        while True:\n            sample_coords = [torch.randint(0, size[i], (1,)).item() for i in range(size.n_dim)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, q_near: Vertex, q_rand: Point) -> Vertex:\n        # Return vertex extended towards q_rand with max distance limit\n        dir_vec = q_rand.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= self._max_dist:\n            return Vertex(q_rand, store_connectivity=True)\n        dir_normalized = dir_vec / dist\n        new_pt_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n        new_point = Point.from_tensor(new_pt_tensor)\n        return Vertex(new_point, store_connectivity=True)\n\n    def _nearest(self, points: List[Vertex], target: Point) -> Vertex:\n        # Find closest vertex in points to target\n        return min(points, key=lambda v: torch.norm(v.position.to_tensor() - target.to_tensor()).item())\n\n    def _rewire(self, new_vertex: Vertex, neighborhood: List[Vertex]) -> None:\n        # Attempt to improve path quality by rewiring connections\n        grid = self._get_grid()\n        for neighbor in neighborhood:\n            if neighbor == new_vertex:\n                continue\n            line_seq = grid.get_line_sequence(new_vertex.position, neighbor.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_new_to_neighbor = grid.get_movement_cost(new_vertex.position, neighbor.position)\n            new_cost = new_vertex.cost + cost_new_to_neighbor\n            if neighbor.cost is None or new_cost < neighbor.cost:\n                # Rewire connection in cyclic graph\n                # Remove old parents edges (if any) pointing to neighbor, add new edge from new_vertex to neighbor\n                for p in list(neighbor.parents):\n                    self._graph.remove_edge(p, neighbor)\n                self._graph.add_edge(new_vertex, neighbor)\n                neighbor.cost = new_cost\n                # Update connectivity map for path extraction\n                new_vertex.connectivity[neighbor] = neighbor\n\n    def _extract_path(self) -> None:\n        # Extract best path by following connectivity from start vertex to goal vertex\n        start_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n        path = []\n        current = start_vertex\n\n        # Build path by following connectivity towards goal\n        visited = set()\n        while current != goal_vertex:\n            visited.add(current)\n            if goal_vertex in current.connectivity:\n                nxt = current.connectivity[goal_vertex]\n            else:\n                # Fallback: pick nearest connectivity vertex to goal\n                candidates = [v for v in current.connectivity if v not in visited]\n                if not candidates:\n                    break\n                nxt = min(candidates, key=lambda v: torch.norm(v.position.to_tensor() - goal_vertex.position.to_tensor()).item())\n            path.append(nxt)\n            current = nxt\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        # Initialize root vertices costs\n        start_vertex.cost = 0.0\n        goal_vertex.cost = None\n\n        # Add start and goal vertices to root_vertices list to keep track\n        self._graph.root_vertices = [start_vertex, goal_vertex]\n\n        for i in range(self._iterations):\n            if time.time() - start_time > 60.0:\n                # Timeout: treat as failure\n                return\n\n            # Sample random point with goal bias\n            q_rand = self._get_random_sample()\n\n            # Pick which tree to extend: alternate between start and goal roots\n            tree_a, tree_b = self._graph.root_vertices\n            if i % 2 == 0:\n                src_tree = tree_a\n                tgt_tree = tree_b\n            else:\n                src_tree = tree_b\n                tgt_tree = tree_a\n\n            # Extend src_tree towards q_rand\n            near_vertex = self._nearest([src_tree], q_rand)\n            new_vertex = self._steer(near_vertex, q_rand)\n\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(near_vertex.position, new_vertex.position)):\n                continue\n\n            # Set cost to new_vertex\n            new_vertex.cost = (near_vertex.cost if near_vertex.cost is not None else 0) + grid.get_movement_cost(near_vertex.position, new_vertex.position)\n\n            # Add new_vertex to the graph and link it\n            self._graph.root_vertices.append(new_vertex)\n            self._graph.add_edge(near_vertex, new_vertex)\n\n            # Rewire neighbors to improve path quality\n            neighborhood = self._graph.get_vertices_within_radius(self._graph.root_vertices, new_vertex.position, self._rewire_radius)\n            self._rewire(new_vertex, neighborhood)\n\n            # Try to connect new_vertex to opposite tree within max_dist\n            near_vertex_opposite = self._nearest([tgt_tree], new_vertex.position)\n            line_seq_connect = grid.get_line_sequence(new_vertex.position, near_vertex_opposite.position)\n\n            dist_connect = torch.norm(new_vertex.position.to_tensor() - near_vertex_opposite.position.to_tensor()).item()\n            if dist_connect <= self._max_dist and grid.is_valid_line_sequence(line_seq_connect):\n                # Connect both trees\n                new_vertex.cost += grid.get_movement_cost(new_vertex.position, near_vertex_opposite.position)\n                self._graph.add_edge(new_vertex, near_vertex_opposite)\n                self._graph.add_edge(near_vertex_opposite, new_vertex)\n                # Reconstruct path and exit\n                self._extract_path()\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 164, in _find_path_internal\nValueError: too many values to unpack (expected 2)\n"
     }
}
{
     "operator": "e1",
     "algorithm": "PathPlanning Algorithm: An improved sample-based path planning algorithm that combines the strengths of RRT* and informed sampling,\n    with a bidirectional search and path smoothing. It grows two trees, one from the start (agent) and one from the goal, expanding towards\n    random samples confined inside an ellipsoidal informed sampling region after an initial solution is found to accelerate convergence.\n    Rewiring within neighborhoods ensures path quality improvements. The bidirectional approach increases success rate and reduces search time.\n    Finally, a post-processing smoothing step improves path smoothness and reduces unnecessary detours.\n    The entire search is bounded by a 60-second timeout to guarantee robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _tree_start: Forest\n    _tree_goal: Forest\n    _max_extend_dist: float\n    _max_iterations: int\n    _search_timeout: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n\n        self._max_extend_dist = 12.0\n        self._max_iterations = 15000\n        self._search_timeout = 60.0  # 60 seconds timeout\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        # Use Forest graphs representing bidirectional trees\n        self._tree_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._tree_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n\n        self._init_displays()\n\n    # Helper for get random samples, optionally within ellipsoid informed region\n    def _get_random_sample(self, c_best: Optional[float], c_min: float,\n                           start: Point, goal: Point) -> Point:\n        # If no solution found yet, sample uniformly from full space\n        grid_size = self._get_grid().size.values\n        if c_best is None:\n            while True:\n                sample = Point(*[torch.randint(0, dim, (1,)).item() for dim in grid_size])\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling inside ellipsoid that bounds current best path length\n        c_best = max(c_best, c_min)\n        center = torch.tensor([(start.x + goal.x) * 0.5, (start.y + goal.y) * 0.5])\n        diff = torch.tensor([goal.x - start.x, goal.y - start.y])\n        e1 = diff / torch.norm(diff)\n        # Compute rotation matrix to align ellipsoid with the line start-goal\n        M = torch.tensor([[0.0, -1.0], [1.0, 0.0]])\n        e2 = M @ e1\n        # Radii of ellipsoid\n        a1 = c_best * 0.5\n        b1 = torch.sqrt(torch.tensor(c_best ** 2 - c_min ** 2)) * 0.5\n        tries = 0\n        max_tries = 1000\n        while tries < max_tries:\n            # Sample unit circle point\n            r = torch.sqrt(torch.rand(1))\n            theta = 2 * torch.pi * torch.rand(1)\n            x_ball = r * torch.cos(theta)\n            y_ball = r * torch.sin(theta)\n            # Scale point by ellipsoid radii\n            sample_point = center + a1 * e1 * x_ball + b1 * e2 * y_ball\n            pt_int = Point(int(sample_point[0].item()), int(sample_point[1].item()))\n            if self._get_grid().is_agent_valid_pos(pt_int):\n                return pt_int\n            tries += 1\n        # Fallback uniform sampling if ellipsoid sampling fails repeatedly\n        while True:\n            sample = Point(*[torch.randint(0, dim, (1,)).item() for dim in grid_size])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, tree: Forest, q_sample: Point) -> Vertex:\n        return tree.get_nearest_vertex(tree.root_vertices, q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pt = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pt)\n\n    def _is_collision_free(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _get_vertices_within_radius(self, tree: Forest, vertex: Vertex, radius: float) -> List[Vertex]:\n        return tree.get_vertices_within_radius(tree.root_vertices, vertex.position, radius)\n\n    def _rewire(self, tree: Forest, q_new: Vertex, neighbors: List[Vertex]):\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            if self._is_collision_free(q_new.position, q_near.position):\n                cost_through_new = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if q_near.cost is None or cost_through_new < q_near.cost:\n                    # Remove old parent edge\n                    old_parents = list(q_near.parents)\n                    for old_p in old_parents:\n                        tree.remove_edge(old_p, q_near)\n\n                    # Add new edge q_new -> q_near\n                    q_near.cost = cost_through_new\n                    tree.add_edge(q_new, q_near)\n\n    def _construct_path(self, vertex_start: Vertex, vertex_goal: Vertex) -> List[Point]:\n        # Trace back from start tree root vertex\n        path_start = []\n        v = vertex_start\n        while True:\n            path_start.append(v.position)\n            if len(v.parents) == 0:\n                break\n            v = next(iter(v.parents))\n        path_start.reverse()\n\n        # Trace back from goal tree root vertex\n        path_goal = []\n        v = vertex_goal\n        while True:\n            path_goal.append(v.position)\n            if len(v.parents) == 0:\n                break\n            v = next(iter(v.parents))\n\n        return path_start + path_goal\n\n    def _smooth_path(self, path: List[Point], max_iter=50) -> List[Point]:\n        if len(path) < 3:\n            return path\n\n        for _ in range(max_iter):\n            if len(path) <= 2:\n                break\n            i = torch.randint(0, len(path) - 2, (1,)).item()\n            j = torch.randint(i + 2, len(path), (1,)).item()\n\n            p_i = path[i]\n            p_j = path[j]\n\n            if self._is_collision_free(p_i, p_j):\n                # Remove intermediate points between i and j\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _find_path_internal(self) -> None:\n\n        start_time = time.time()\n        grid = self._get_grid()\n        start_pos = grid.agent.position\n        goal_pos = grid.goal.position\n        dimension = grid.size.n_dim\n        c_min = Map.get_distance(start_pos, goal_pos)  # minimum possible distance start-goal\n        c_best = None\n\n        radius_const = 50.0  # For neighbor circle in rewire, depends on dimension and graph size\n\n        # Initialize root vertices cost\n        self._tree_start.root_vertex_start.cost = 0.0\n        self._tree_goal.root_vertex_start.cost = 0.0\n\n        for i in range(self._max_iterations):\n\n            if time.time() - start_time > self._search_timeout:\n                # Fail if time exceeds 60 seconds\n                return\n\n            # Sample point, informed if solution found, else uniform\n            q_sample = self._get_random_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Extend tree from start\n            q_near_start = self._get_nearest_vertex(self._tree_start, q_sample)\n            q_new_start = self._get_new_vertex(q_near_start, q_sample, self._max_extend_dist)\n            if not self._is_collision_free(q_near_start.position, q_new_start.position):\n                self.key_frame()\n                continue\n\n            # Calculate cost to new node\n            cost_to_new_start = q_near_start.cost + torch.norm(q_near_start.position.to_tensor() - q_new_start.position.to_tensor())\n            q_new_start.cost = cost_to_new_start\n            self._tree_start.add_edge(q_near_start, q_new_start)\n            neighbors_start = self._get_vertices_within_radius(self._tree_start, q_new_start, radius_const)\n            self._rewire(self._tree_start, q_new_start, neighbors_start)\n\n            # Extend tree from goal towards new_start sample\n            q_near_goal = self._get_nearest_vertex(self._tree_goal, q_new_start.position)\n            q_new_goal = self._get_new_vertex(q_near_goal, q_new_start.position, self._max_extend_dist)\n            if not self._is_collision_free(q_near_goal.position, q_new_goal.position):\n                self.key_frame()\n                continue\n\n            cost_to_new_goal = q_near_goal.cost + torch.norm(q_near_goal.position.to_tensor() - q_new_goal.position.to_tensor())\n            q_new_goal.cost = cost_to_new_goal\n            self._tree_goal.add_edge(q_near_goal, q_new_goal)\n            neighbors_goal = self._get_vertices_within_radius(self._tree_goal, q_new_goal, radius_const)\n            self._rewire(self._tree_goal, q_new_goal, neighbors_goal)\n\n            # Check if connection between two trees is possible\n            dist_start_goal = torch.norm(q_new_start.position.to_tensor() - q_new_goal.position.to_tensor())\n            if dist_start_goal <= self._max_extend_dist:\n                # Check collision free connection\n                if self._is_collision_free(q_new_start.position, q_new_goal.position):\n                    # Connect trees\n                    self._tree_start.add_edge(q_new_start, q_new_goal)\n                    self._tree_goal.add_edge(q_new_goal, q_new_start)\n\n                    # Calculate total cost of this path\n                    total_cost = q_new_start.cost + dist_start_goal + q_new_goal.cost\n                    if c_best is None or total_cost < c_best:\n                        c_best = total_cost\n                        # Construct full path\n                        path = self._construct_path(q_new_start, q_new_goal)\n                        # Smooth path for better quality\n                        smooth_path = self._smooth_path(path)\n                        # Move agent through path\n                        for p in smooth_path:\n                            self.move_agent(p)\n                            self.key_frame(ignore_key_frame_skip=True)\n                        return\n\n            self.key_frame()\n\n        # If no path found in max iterations, no result\n        return",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 215, in __run_simulation\n    sim: Simulator = Simulator(Services(config))\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 40, in __init__\n    self.__setup(config)\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 68, in __setup\n    self.__algorithm_runner.reset_algorithm()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\algorithm_runner.py\", line 59, in reset_algorithm\n    self.__algorithm = self.__algorithm_type(self._services, testing, *self.__algorithm_parameters[0],\n  File \"<string>\", line 62, in __init__\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\sample_based_algorithm.py\", line 11, in _init_displays\n    self.__map_displays = [GraphMapDisplay(self._services, self._graph)]\nAttributeError: 'PathPlanning' object has no attribute '_graph'\n"
     }
}
{
     "operator": "m2",
     "algorithm": "Improved RRT* inspired algorithm with adaptive sampling, rewiring, and goal bias.\n    Introduces:\n    - Adaptive max extension distance scaled to the map size for better exploration.\n    - Goal bias sampling to accelerate convergence to the target.\n    - Neighborhood radius calculation for efficient rewiring and path quality improvement.\n    - Rewiring of nearby vertices for smooth, shorter paths.\n    - Early termination if a path is found within a feasible number of iterations.\n    - Search timeout handling to avoid excessive run time (>60s).\n    - Uses distance-weighted cost and valid collision-checking lines for graph edges.\n    Overall improves efficiency, success rate, path smoothness, and reduces search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: 'Point', max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= 1e-6:\n            return Vertex(q_near.position)  # Prevent division by zero or no movement\n\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        direction_normalized = direction / dist\n        q_new_point_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        # Construct Point from tensor manually because Point.from_tensor does not exist in reference\n        q_new_point = Point(*q_new_point_tensor.tolist())\n        return Vertex(q_new_point)\n\n    def _get_random_sample(self, goal_bias: float, max_samples: int = 1000) -> 'Point':\n        \"\"\"Randomly sample a point; with probability goal_bias sample the goal directly.\"\"\"\n        if np.random.random() < goal_bias:\n            return self._get_grid().goal.position\n\n        # Sampling with retries up to max_samples for valid position\n        for _ in range(max_samples):\n            rand_coords = np.random.uniform(low=0, high=np.array(self._get_grid().size.values), size=self._get_grid().size.n_dim)\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n        # Fallback to goal if no valid sample found (rare)\n        return self._get_grid().goal.position\n\n    def _extract_path(self, last_vertex: Vertex) -> None:\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(last_vertex, goal_vertex)\n\n        path: List[Vertex] = [goal_vertex]\n        current = last_vertex\n        while True:\n            if not current.parents:\n                break\n            # Choose parent with minimum cost to ensure optimal path\n            min_parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            path.append(min_parent)\n            current = min_parent\n\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _calculate_neighborhood_radius(self, num_vertices: int, dim: int) -> float:\n        gamma_rrt_star = 2 * (1 + 1/dim) ** (1/dim) * ((self._get_grid().size.width * self._get_grid().size.height) / np.pi) ** (1/dim)\n        return min(gamma_rrt_star * (np.log(num_vertices) / num_vertices) ** (1/dim), 50.0)\n\n    def _find_path_internal(self) -> None:\n        max_time_seconds = 60.0\n        start_time = time()\n\n        grid = self._get_grid()\n        dim = grid.size.n_dim\n\n        # Adaptive max extension distance based on map size (10% of diagonal length, capped)\n        diag = torch.norm(torch.tensor(grid.size.values, dtype=torch.float))\n        max_dist = float(min(max(diag.item() * 0.10, 1.0), 30.0))\n\n        goal_bias = 0.10  # 10% of samples directed to goal\n        max_iterations = 10000\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iteration in range(max_iterations):\n            if time() - start_time > max_time_seconds:\n                # Fail due to timeout\n                break\n\n            q_sample = self._get_random_sample(goal_bias=goal_bias)\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new.position == q_near.position:\n                continue\n\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors in radius for rewiring\n            neighborhood_radius = self._calculate_neighborhood_radius(self._graph.size + 1, dim)\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, neighborhood_radius)\n\n            # Initialize cost and parent\n            min_cost = q_near.cost + grid.get_distance(q_near.position, q_new.position) if q_near.cost is not None else float('inf')\n            parent_vertex = q_near\n\n            # Choose best parent from neighbors to minimize cost\n            for neighbor in neighbors:\n                if neighbor.position == q_near.position:\n                    continue\n                potential_line = grid.get_line_sequence(neighbor.position, q_new.position)\n                if not grid.is_valid_line_sequence(potential_line):\n                    continue\n                if neighbor.cost is None:\n                    continue\n                new_cost = neighbor.cost + grid.get_distance(neighbor.position, q_new.position)\n                if new_cost < min_cost:\n                    min_cost = new_cost\n                    parent_vertex = neighbor\n\n            q_new.cost = min_cost\n            self._graph.add_edge(parent_vertex, q_new)\n\n            # Rewire neighbors to new vertex if it improves cost\n            for neighbor in neighbors:\n                if neighbor == parent_vertex:\n                    continue\n                line_to_neighbor = grid.get_line_sequence(q_new.position, neighbor.position)\n                if not grid.is_valid_line_sequence(line_to_neighbor):\n                    continue\n                if q_new.cost is None:\n                    continue\n                new_cost = q_new.cost + grid.get_distance(q_new.position, neighbor.position)\n                if neighbor.cost is None or new_cost < neighbor.cost:\n                    # Rewire parent edge\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 105, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "e2",
     "algorithm": "Hybrid RRT* + RRT-Connect inspired path planning algorithm with adaptive rewiring and goal bias.\n    This algorithm grows two trees simultaneously: one from start and one from goal,\n    using a bidirectional sampling strategy with goal bias to boost convergence.\n    It improves path quality by rewiring vertices within a radius to reduce cost,\n    applies lazy collision checking to accelerate exploration,\n    and attempts direct connections between trees to quickly close the path.\n    Execution halts upon success or if runtime exceeds 60 seconds to guarantee bounded search time.\n    This design aims for better planning efficiency, improved success rate, smoother and \n    shorter paths, and overall path planning robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_dist: float\n    _iterations: int\n    _goal_sample_rate: float  # Probability of sampling the goal point\n    _rewire_radius_factor: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = CyclicGraph(start_vertex, goal_vertex, [start_vertex, goal_vertex])\n        self._max_dist = 15.0\n        self._iterations = 15000\n        self._goal_sample_rate = 0.1  # 10% chance to directly sample goal (goal bias)\n        self._rewire_radius_factor = 30.0  # radius to consider for rewiring, can be tuned\n        self._init_displays()\n\n    # Helper - Generate samples with goal bias\n    def _get_random_sample(self) -> Point:\n        import numpy as np\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        size = self._get_grid().size\n        while True:\n            rand_pos = np.random.randint(0, size.values, size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    # Helper - Steer towards sample, limited by max_dist\n    def _steer(self, from_vertex: Vertex, to_point: Point) -> Vertex:\n        from_pos_tensor = from_vertex.position.to_tensor()\n        to_pos_tensor = to_point.to_tensor()\n        direction = to_pos_tensor - from_pos_tensor\n        dist = torch.norm(direction)\n        if dist <= self._max_dist:\n            new_pos = to_point\n        else:\n            direction_normalized = direction / dist\n            new_pos_tensor = from_pos_tensor + direction_normalized * self._max_dist\n            new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos, store_connectivity=True)\n\n    # Helper - Find best parent for new vertex among vertices within radius, return best parent and cost\n    def _choose_parent(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> Tuple[Optional[Vertex], float]:\n        min_cost = float(\"inf\")\n        best_parent = None\n        for near_vertex in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(near_vertex.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = near_vertex.cost + self._get_grid().get_movement_cost(near_vertex.position, new_vertex.position) if near_vertex.cost is not None else self._get_grid().get_movement_cost(near_vertex.position, new_vertex.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = near_vertex\n        return best_parent, min_cost\n\n    # Helper - Rewire nearby vertices to the new vertex if cheaper\n    def _rewire(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> None:\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex:\n                continue\n            line_seq = self._get_grid().get_line_sequence(new_vertex.position, near_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, near_vertex.position)\n            if near_vertex.cost is None or new_cost < near_vertex.cost:\n                # Remove old parents' edges to near_vertex\n                for p in list(near_vertex.parents):\n                    self._graph.remove_edge(p, near_vertex)\n                # Add new edge from new_vertex\n                self._graph.add_edge(new_vertex, near_vertex)\n                near_vertex.cost = new_cost\n\n    # Helper - Compute Euclidean distance between two points\n    def _dist(self, p1: Point, p2: Point) -> float:\n        return float(torch.norm(p1.to_tensor() - p2.to_tensor()))\n\n    # Helper - Extract path from start to goal by tracing parents\n    def _extract_path(self, connecting_vertex_start: Vertex, connecting_vertex_goal: Vertex) -> None:\n        # From connecting point to start\n        path_from_start = [connecting_vertex_start]\n        while len(path_from_start[-1].parents) != 0:\n            # We assume single parent for simplicity\n            for parent in path_from_start[-1].parents:\n                path_from_start.append(parent)\n                break\n        path_from_start.reverse()\n\n        # From connecting point to goal\n        path_from_goal = [connecting_vertex_goal]\n        while len(path_from_goal[-1].parents) != 0:\n            for parent in path_from_goal[-1].parents:\n                path_from_goal.append(parent)\n                break\n\n        full_path = path_from_start + path_from_goal\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Attempts connection between two trees from new_vertex_start to tree_goal, returns connecting vertex if successful else None\n    def _try_connect_trees(self, new_vertex_start: Vertex, tree_goal_root: Vertex) -> Optional[Tuple[Vertex, Vertex]]:\n        # Get nearest vertex in goal tree to new_vertex_start\n        nearest_goal_vertex = self._graph.get_nearest_vertex([tree_goal_root], new_vertex_start.position)\n        direction = nearest_goal_vertex.position.to_tensor() - new_vertex_start.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist == 0:\n            return None\n        direction_normalized = direction / dist\n        extend_len = min(self._max_dist, dist)\n        new_pos_tensor = new_vertex_start.position.to_tensor() + direction_normalized * extend_len\n        new_vertex_goal = Vertex(Point.from_tensor(new_pos_tensor), store_connectivity=True)\n\n        # Check collision\n        line_seq = self._get_grid().get_line_sequence(new_vertex_start.position, new_vertex_goal.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        # Add edge to goal tree\n        self._graph.add_edge(nearest_goal_vertex, new_vertex_goal)\n        new_vertex_goal.cost = nearest_goal_vertex.cost + self._get_grid().get_movement_cost(nearest_goal_vertex.position, new_vertex_goal.position) if nearest_goal_vertex.cost is not None else self._get_grid().get_movement_cost(nearest_goal_vertex.position, new_vertex_goal.position)\n\n        # Try to connect further until new_vertex_goal reaches nearest_goal_vertex (reached goal tree)\n        current_vertex = new_vertex_goal\n        while True:\n            dist_to_nearest = self._dist(current_vertex.position, nearest_goal_vertex.position)\n            if dist_to_nearest < 1e-5:\n                # Connection complete; set parents accordingly\n                return new_vertex_start, current_vertex\n            extend_len = min(self._max_dist, dist_to_nearest)\n            dir_vec = nearest_goal_vertex.position.to_tensor() - current_vertex.position.to_tensor()\n            dir_norm = dir_vec / torch.norm(dir_vec)\n            next_pos_tensor = current_vertex.position.to_tensor() + dir_norm * extend_len\n            next_vertex = Vertex(Point.from_tensor(next_pos_tensor), store_connectivity=True)\n            line_seq = self._get_grid().get_line_sequence(current_vertex.position, next_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                return None\n            self._graph.add_edge(current_vertex, next_vertex)\n            next_vertex.cost = current_vertex.cost + self._get_grid().get_movement_cost(current_vertex.position, next_vertex.position) if current_vertex.cost is not None else self._get_grid().get_movement_cost(current_vertex.position, next_vertex.position)\n            current_vertex = next_vertex\n\n    # Main search implementation\n    def _find_path_internal(self) -> None:\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = 0.0\n\n        start_tree = self._graph.root_vertex_start\n        goal_tree = self._graph.root_vertex_goal\n\n        start_vertices = [start_tree]\n        goal_vertices = [goal_tree]\n\n        start_tree.cost = 0.0\n        goal_tree.cost = 0.0\n\n        start_root_vertices = [start_tree]\n        goal_root_vertices = [goal_tree]\n        from random import shuffle\n\n        start_time = time()\n        for iteration in range(self._iterations):\n\n            # Time cutoff check\n            if time() - start_time > 60:\n                # Fail gracefully\n                break\n\n            # Alternate expanding trees or swap roots for bidirectional growth\n            if iteration % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            # Sample a point from the space\n            q_rand = self._get_random_sample()\n\n            # Find nearest vertex in tree_a to q_rand\n            q_near = self._graph.get_nearest_vertex([tree_a], q_rand)\n\n            # Steer from q_near toward q_rand\n            q_new = self._steer(q_near, q_rand)\n            if q_new.position == q_near.position:\n                continue\n\n            # Check collision for edge (q_near -> q_new)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find vertices near q_new within radius for rewiring and choosing best parent\n            radius = self._rewire_radius_factor * ((torch.log(torch.tensor(self._graph.size + 1))) / (iteration+1))**(1/self._get_grid().size.n_dim) \\\n                     if iteration > 0 else self._max_dist\n            if radius < self._max_dist:\n                radius = self._max_dist\n            near_vertices = self._graph.get_vertices_within_radius([tree_a], q_new.position, radius)\n\n            # Choose parent with minimum cost\n            best_parent, best_cost = self._choose_parent(q_new, near_vertices)\n            if best_parent is None:\n                # fallback: connect from q_near directly\n                best_parent = q_near\n                best_cost = (q_near.cost if q_near.cost is not None else 0.0) + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n\n            # Assign cost and add edge\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire nearby vertices via q_new if cheaper\n            self._rewire(q_new, near_vertices)\n\n            # Check if q_new in goal radius (if expanding start_tree) or start radius (if expanding goal_tree)\n            if tree_a is start_tree and self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Attempt to connect q_new directly to goal tree\n                connecting = self._try_connect_trees(q_new, goal_tree)\n                if connecting is not None:\n                    start_connect, goal_connect = connecting\n                    self._extract_path(start_connect, goal_connect)\n                    break\n\n            if tree_a is goal_tree and self._dist(q_new.position, start_tree.position) <= self._max_dist:\n                # Try connect to start tree\n                nearest_start_vertex = self._graph.get_nearest_vertex([start_tree], q_new.position)\n                line_seq = self._get_grid().get_line_sequence(nearest_start_vertex.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Connect edges and extract path\n                    self._graph.add_edge(nearest_start_vertex, q_new)\n                    q_new.cost = (nearest_start_vertex.cost if nearest_start_vertex.cost is not None else 0.0) + self._get_grid().get_movement_cost(nearest_start_vertex.position,q_new.position)\n                    self._extract_path(nearest_start_vertex, q_new)\n                    break\n\n            # Swap roots for next iteration to promote balanced tree growth\n            if iteration % 2 == 0:\n                start_tree, goal_tree = goal_tree, start_tree\n\n            # Visualization\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 203, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "m2",
     "algorithm": "Improved RRT* inspired algorithm with adaptive sampling, rewiring, and goal bias.\n    Introduces:\n    - Adaptive max extension distance scaled to the map size for better exploration.\n    - Goal bias sampling to accelerate convergence to the target.\n    - Neighborhood radius calculation for efficient rewiring and path quality improvement.\n    - Rewiring of nearby vertices for smooth, shorter paths.\n    - Early termination if a path is found within a feasible number of iterations.\n    - Search timeout handling to avoid excessive run time (>60s).\n    - Uses distance-weighted cost and valid collision-checking lines for graph edges.\n    Overall improves efficiency, success rate, path smoothness, and reduces search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = gen_forest(services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: 'Point', max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= 1e-6:\n            return Vertex(q_near.position)  # Prevent division by zero or no movement\n\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        direction_normalized = direction / dist\n        q_new_point_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        q_new_point = Point(*q_new_point_tensor.tolist())\n        return Vertex(q_new_point)\n\n    def _get_random_sample(self, goal_bias: float, max_samples: int = 1000) -> 'Point':\n        if np.random.random() < goal_bias:\n            return self._get_grid().goal.position\n\n        for _ in range(max_samples):\n            rand_coords = np.random.uniform(low=0, high=np.array(self._get_grid().size.values), size=self._get_grid().size.n_dim)\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n        return self._get_grid().goal.position\n\n    def _extract_path(self, last_vertex: Vertex) -> None:\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(last_vertex, goal_vertex)\n\n        path: List[Vertex] = [goal_vertex]\n        current = last_vertex\n        while True:\n            if not current.parents:\n                break\n            min_parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            path.append(min_parent)\n            current = min_parent\n\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _calculate_neighborhood_radius(self, num_vertices: int, dim: int) -> float:\n        gamma_rrt_star = 2 * (1 + 1/dim) ** (1/dim) * ((self._get_grid().size.width * self._get_grid().size.height) / np.pi) ** (1/dim)\n        return min(gamma_rrt_star * (np.log(num_vertices) / num_vertices) ** (1/dim), 50.0)\n\n    def _find_path_internal(self) -> None:\n        max_time_seconds = 60.0\n        start_time = time()\n\n        grid = self._get_grid()\n        dim = grid.size.n_dim\n\n        diag = torch.norm(torch.tensor(grid.size.values, dtype=torch.float))\n        max_dist = float(min(max(diag.item() * 0.10, 1.0), 30.0))\n\n        goal_bias = 0.10\n        max_iterations = 10000\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iteration in range(max_iterations):\n            if time() - start_time > max_time_seconds:\n                break\n\n            q_sample = self._get_random_sample(goal_bias=goal_bias)\n\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new.position == q_near.position:\n                continue\n\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            neighborhood_radius = self._calculate_neighborhood_radius(self._graph.size + 1, dim)\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, neighborhood_radius)\n\n            min_cost = q_near.cost + grid.get_distance(q_near.position, q_new.position) if q_near.cost is not None else float('inf')\n            parent_vertex = q_near\n\n            for neighbor in neighbors:\n                if neighbor.position == q_near.position:\n                    continue\n                potential_line = grid.get_line_sequence(neighbor.position, q_new.position)\n                if not grid.is_valid_line_sequence(potential_line):\n                    continue\n                if neighbor.cost is None:\n                    continue\n                new_cost = neighbor.cost + grid.get_distance(neighbor.position, q_new.position)\n                if new_cost < min_cost:\n                    min_cost = new_cost\n                    parent_vertex = neighbor\n\n            q_new.cost = min_cost\n            self._graph.add_edge(parent_vertex, q_new)\n\n            for neighbor in neighbors:\n                if neighbor == parent_vertex:\n                    continue\n                line_to_neighbor = grid.get_line_sequence(q_new.position, neighbor.position)\n                if not grid.is_valid_line_sequence(line_to_neighbor):\n                    continue\n                if q_new.cost is None:\n                    continue\n                new_cost = q_new.cost + grid.get_distance(q_new.position, neighbor.position)\n                if neighbor.cost is None or new_cost < neighbor.cost:\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 101, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "m2",
     "algorithm": "Improved RRT* inspired algorithm with adaptive sampling, rewiring, and goal bias.\n    Introduces:\n    - Adaptive max extension distance scaled to the map size for better exploration.\n    - Goal bias sampling to accelerate convergence to the target.\n    - Neighborhood radius calculation for efficient rewiring and path quality improvement.\n    - Rewiring of nearby vertices for smooth, shorter paths.\n    - Early termination if a path is found within a feasible number of iterations.\n    - Search timeout handling to avoid excessive run time (>60s).\n    - Uses distance-weighted cost and valid collision-checking lines for graph edges.\n    Overall improves efficiency, success rate, path smoothness, and reduces search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: 'Point', max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= 1e-6:\n            return Vertex(q_near.position)  # Prevent division by zero or no movement\n\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        direction_normalized = direction / dist\n        q_new_point_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        q_new_point = Point(*q_new_point_tensor.tolist())\n        return Vertex(q_new_point)\n\n    def _get_random_sample(self, goal_bias: float, max_samples: int = 1000) -> 'Point':\n        if np.random.random() < goal_bias:\n            return self._get_grid().goal.position\n\n        for _ in range(max_samples):\n            rand_coords = np.random.uniform(low=0, high=np.array(self._get_grid().size.values), size=self._get_grid().size.n_dim)\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n        return self._get_grid().goal.position\n\n    def _extract_path(self, last_vertex: Vertex) -> None:\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(last_vertex, goal_vertex)\n\n        path: List[Vertex] = [goal_vertex]\n        current = last_vertex\n        while True:\n            if not current.parents:\n                break\n            min_parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            path.append(min_parent)\n            current = min_parent\n\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _calculate_neighborhood_radius(self, num_vertices: int, dim: int) -> float:\n        gamma_rrt_star = 2 * (1 + 1/dim) ** (1/dim) * ((self._get_grid().size.width * self._get_grid().size.height) / np.pi) ** (1/dim)\n        return min(gamma_rrt_star * (np.log(num_vertices) / num_vertices) ** (1/dim), 50.0)\n\n    def _find_path_internal(self) -> None:\n        max_time_seconds = 60.0\n        start_time = time()\n\n        grid = self._get_grid()\n        dim = grid.size.n_dim\n\n        diag = torch.norm(torch.tensor(grid.size.values, dtype=torch.float))\n        max_dist = float(min(max(diag.item() * 0.10, 1.0), 30.0))\n\n        goal_bias = 0.10\n        max_iterations = 10000\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iteration in range(max_iterations):\n            if time() - start_time > max_time_seconds:\n                break\n\n            q_sample = self._get_random_sample(goal_bias=goal_bias)\n\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new.position == q_near.position:\n                continue\n\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            neighborhood_radius = self._calculate_neighborhood_radius(self._graph.size + 1, dim)\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, neighborhood_radius)\n\n            min_cost = q_near.cost + grid.get_distance(q_near.position, q_new.position) if q_near.cost is not None else float('inf')\n            parent_vertex = q_near\n\n            for neighbor in neighbors:\n                if neighbor.position == q_near.position:\n                    continue\n                potential_line = grid.get_line_sequence(neighbor.position, q_new.position)\n                if not grid.is_valid_line_sequence(potential_line):\n                    continue\n                if neighbor.cost is None:\n                    continue\n                new_cost = neighbor.cost + grid.get_distance(neighbor.position, q_new.position)\n                if new_cost < min_cost:\n                    min_cost = new_cost\n                    parent_vertex = neighbor\n\n            q_new.cost = min_cost\n            self._graph.add_edge(parent_vertex, q_new)\n\n            for neighbor in neighbors:\n                if neighbor == parent_vertex:\n                    continue\n                line_to_neighbor = grid.get_line_sequence(q_new.position, neighbor.position)\n                if not grid.is_valid_line_sequence(line_to_neighbor):\n                    continue\n                if q_new.cost is None:\n                    continue\n                new_cost = q_new.cost + grid.get_distance(q_new.position, neighbor.position)\n                if neighbor.cost is None or new_cost < neighbor.cost:\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 101, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "m2",
     "algorithm": "Improved path planning algorithm based on a tuned and optimized RRT* variant with adaptive sampling bias,\n    radius-based rewiring for path smoothing, and time-limited search. It balances exploration and exploitation \n    by sampling near the goal with an increasing probability and rewiring the tree locally to improve path quality. \n    The algorithm terminates success if the agent reaches the goal region or fails if the planning exceeds 60 seconds.\n    Key improvements:\n    - Adaptive sampling with goal bias to increase convergence speed\n    - Radius-based rewiring of nearby vertices to reduce path length and smoothness\n    - Tuned maximum extension distance based on map size\n    - Early failure termination after 60 seconds to improve robustness\n    - Uses cost metric and rewiring to improve path quality",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True  # allow edge removals for rewiring\n        self._init_displays()\n\n    def _get_distance(self, p1: Point, p2: Point) -> float:\n        return float((p1.to_tensor() - p2.to_tensor()).norm().item())\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction).item()\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n\n        direction_normalized = direction / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _get_random_sample(self, goal_sample_rate: float) -> Point:\n        \"\"\"\n        With probability goal_sample_rate, return goal position,\n        otherwise return a valid random sample in the map.\n        \"\"\"\n        if np.random.rand() < goal_sample_rate:\n            return self._get_grid().goal.position\n\n        while True:\n            # Sample uniformly within grid size bounds\n            rand_coords = [\n                np.random.uniform(0, dim_size) for dim_size in self._get_grid().size.values\n            ]\n            rand_coords_int = [int(math.floor(c)) for c in rand_coords]\n            sample = Point(*rand_coords_int)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_vertices_within_radius(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        result = []\n        for v in vertices:\n            if self._get_distance(v.position, point) < radius:\n                result.append(v)\n        return result\n\n    def _choose_best_parent(self, near_vertices: List[Vertex], new_vertex: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        Select the best parent vertex to connect to the new_vertex by minimizing cost.\n        Returns None if no valid parent found.\n        \"\"\"\n        best_parent = None\n        best_cost = math.inf\n        line_cache = None\n\n        for vertex in near_vertices:\n            # Check if line from vertex to new_vertex is valid\n            line = self._get_grid().get_line_sequence(vertex.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n\n            cost = (vertex.cost if vertex.cost is not None else 0) + self._get_grid().get_movement_cost(vertex.position, new_vertex.position)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = vertex\n                line_cache = line\n\n        if best_parent is not None:\n            new_vertex.cost = best_cost\n            self._graph.add_edge(best_parent, new_vertex)\n        else:\n            # No valid parent - treat cost as infinity. We'll discard this vertex later.\n            new_vertex.cost = math.inf\n\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], new_vertex: Vertex) -> None:\n        \"\"\"\n        Rewire the vertices in near_vertices to connect optimally through new_vertex.\n        \"\"\"\n        for vertex in near_vertices:\n            if vertex == new_vertex:\n                continue\n\n            line = self._get_grid().get_line_sequence(new_vertex.position, vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n\n            new_cost = (new_vertex.cost if new_vertex.cost is not None else 0) + self._get_grid().get_movement_cost(new_vertex.position, vertex.position)\n            if vertex.cost is None or new_cost < vertex.cost:\n                # Remove old edge(s) to vertex\n                parents_to_remove = list(vertex.parents)\n                for p in parents_to_remove:\n                    self._graph.remove_edge(p, vertex)\n                # Add new edge from new_vertex\n                self._graph.add_edge(new_vertex, vertex)\n                vertex.cost = new_cost\n\n    def _extract_path(self, end_vertex: Vertex) -> None:\n        path: List[Vertex] = [end_vertex]\n\n        while len(path[-1].parents) != 0:\n            # Select parent with minimum cost\n            min_parent = None\n            min_cost = math.inf\n            for parent in path[-1].parents:\n                if parent.cost is not None and parent.cost < min_cost:\n                    min_cost = parent.cost\n                    min_parent = parent\n            if min_parent is None:\n                break\n            path.append(min_parent)\n\n        path.reverse()\n\n        # Animate path tracing from start to goal\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n\n    def _find_path_internal(self) -> None:\n        max_time_sec = 60.0\n        start_time = time.time()\n\n        grid = self._get_grid()\n        max_dist = max(5.0, min(grid.size.width, grid.size.height) * 0.1)  # 10% of smaller map dimension, minimum 5 units\n        iterations = 20000\n\n        # Initialize root start vertex cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for i in range(iterations):\n\n            elapsed = time.time() - start_time\n            if elapsed > max_time_sec:\n                # Fail gracefully if timeout exceeded\n                break\n\n            # Increase goal bias progressively after 30% iterations\n            goal_bias = 0.05 + 0.90 * min(i / (iterations * 0.7), 1.0)\n\n            q_sample = self._get_random_sample(goal_bias)\n\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Build line sequence between neighbor and new\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute cost and choose best parent from nearby vertices\n            all_vertices = self._graph.root_vertices + list(self._graph.root_vertex_start.children)  # broad list for rewire & parent selection\n            radius = max_dist * 2.5  # neighborhood radius for rewiring\n            near_vertices = self._get_vertices_within_radius(all_vertices, q_new.position, radius)\n\n            parent = self._choose_best_parent(near_vertices + [q_near], q_new)\n            if parent is None or q_new.cost == math.inf:\n                continue  # no valid parent, discard q_new\n\n            # Add new vertex to root vertices for search\n            self._graph.root_vertices.append(q_new)\n\n            # Rewire the tree for better paths\n            near_vertices_for_rewire = self._get_vertices_within_radius(all_vertices, q_new.position, radius)\n            self._rewire(near_vertices_for_rewire, q_new)\n\n            # Check if agent reached goal radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex for path extraction\n                goal_vertex = Vertex(grid.goal.position, store_connectivity=True)\n                goal_vertex.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_vertex.position)\n                self._graph.add_edge(q_new, goal_vertex)\n                self._extract_path(goal_vertex)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 187, in _find_path_internal\n  File \"<string>\", line 81, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m1",
     "algorithm": "This PathPlanning algorithm is an enhanced RRT*-inspired planner that adapts dynamically to the map size,\n    improves sampling quality and efficiency by biasing sampling towards the goal with some randomness,\n    incorporates informed rewiring with tightened radius computation for robust path smoothing,\n    and integrates early termination on success or after 60 seconds timeout.\n    It also applies limited shortcut smoothing post path extraction to improve final path smoothness and length.\n    The improvements focus on planning efficiency, path quality, robustness, and reduced search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(\n            self._services, start_vertex, goal_vertex, []\n        )\n\n        self._dimension = self._get_grid().size.n_dim\n        self._max_dist = max(self._get_grid().size.values) * 0.05 + 1  # scale max extension relative to map\n        self._lambda_rrt_star = 30.0  # tuning param for neighborhood radius\n        self._max_radius = max(self._get_grid().size.values) * 0.25 + 5  # cap for radius neighborhood\n        self._timeout_seconds = 60.0\n        self._goal_sample_rate = 0.2  # probability to sample goal directly\n        self._smooth_iterations = 20  # smoothing attempts post path extraction\n\n        self._init_displays()\n\n    # Helper functions #\n\n    def _get_random_sample(self) -> Point:\n        # Bias random sampling with goal_sample_rate towards the goal to improve goal reaching speed\n        import numpy as np\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_coords = [\n                    int(np.random.randint(0, self._get_grid().size[i])) for i in range(self._dimension)\n                ]\n                p = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(p):\n                    return p\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        from torch import norm\n\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_tensor = q_near.position.to_tensor() + dir_normalized * max_dist\n        return Vertex(Point.from_tensor(q_new_tensor))\n\n    def _collision_free(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Construct path from goal back to start\n        path: List[Vertex] = [Vertex(self._get_grid().goal.position)]\n        path[0].cost = q_new.cost + self._get_grid().get_distance(q_new.position, path[0].position)\n        self._graph.add_edge(q_new, path[0])\n\n        current = q_new\n        while current is not None and len(current.parents) > 0:\n            # pick one parent (ideally the one on shortest path)\n            for p in current.parents:\n                path.append(p)\n                current = p\n                break\n        if current is None or current.position != self._graph.root_vertex_start.position:\n            # no valid path found (should not occur if algorithm reached goal)\n            return\n\n        path.reverse()\n\n        # Apply shortcut smoothing to improve path length and smoothness\n        self._shortcut_smooth_path(path)\n\n        # Move agent along the path and keyframe\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_smooth_path(self, path: List[Vertex]) -> None:\n        # Attempt to shortcut edges in path by checking for direct collision-free segments\n        length = len(path)\n        import random\n        for _ in range(self._smooth_iterations):\n            if length < 3:\n                break\n            i = random.randint(0, length - 3)\n            j = random.randint(i + 2, length - 1)\n            p_i = path[i].position\n            p_j = path[j].position\n            if self._collision_free(p_i, p_j):\n                # Remove intermediate vertices between i and j\n                del path[i + 1 : j]\n\n                length = len(path)\n\n    # Main path planning loop #\n\n    def _find_path_internal(self) -> None:\n        import torch\n\n        start_time = time()\n        iter_limit = 15000  # cap on iterations - can be adjusted\n        iteration = 0\n\n        while iteration < iter_limit:\n            iteration += 1\n\n            if time() - start_time > self._timeout_seconds:\n                # Search failed due to timeout\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            if not self._collision_free(q_nearest.position, q_new.position):\n                continue\n\n            # Compute radius for neighbor search\n            card_v = torch.tensor(float(self._graph.size))\n            if card_v <= 1:\n                radius = self._max_radius\n            else:\n                log_card_v = torch.log(card_v)\n                radius = min(\n                    self._lambda_rrt_star\n                    * ((log_card_v / card_v) ** (1.0 / self._dimension)),\n                    self._max_radius,\n                )\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with minimum cost to new vertex\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._get_grid().get_distance(q_nearest.position, q_new.position)\n\n            for q_near in Q_near:\n                if self._collision_free(q_near.position, q_new.position):\n                    candidate_cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n                    if candidate_cost < c_min:\n                        q_min = q_near\n                        c_min = candidate_cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire nearby vertices to potentially improve their cost\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                if self._collision_free(q_new.position, q_near.position):\n                    candidate_cost = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n                    if candidate_cost < q_near.cost:\n                        # Remove old parent edge\n                        old_parents = list(q_near.parents)\n                        for old_parent in old_parents:\n                            self._graph.remove_edge(old_parent, q_near)\n\n                        q_near.cost = candidate_cost\n                        self._graph.add_edge(q_new, q_near)\n\n            # Early goal check: if new vertex is within goal radius, extract path\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 150, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is a hybrid informed RRT* variant with adaptive sampling and smoothing.\n    It improves planning efficiency and path quality by guiding the search within an \n    ellipsoidal informed subset of the space (informed sampling), dynamically adjusting \n    the search radius based on vertex density, and applying iterative smoothing when \n    the goal is reached. It uses a best-first priority queue expansion to favor low-cost \n    vertices, combined with rewiring for optimality. A timeout of 60 seconds is enforced \n    with failure notification. This balances robustness, success rate, path smoothness, \n    search time, and path length improvements.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _max_radius: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_time_sec: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 12.0\n        self._max_radius = 30.0\n        self._lambda_rrt_star = 50.0\n        self._dimension = self._get_grid().size.n_dim\n        self._max_time_sec = 60.0  # maximum allowed time in seconds\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    def _get_random_sample_informed(self, c_best: Optional[float]) -> Point:\n        \"\"\"\n        Informed sampling inside an ellipsoid defined by start, goal, and current best cost.\n        If no path found yet (c_best is None), sample uniformly.\n        \"\"\"\n        agent_pos = self._get_grid().agent.position.to_tensor()\n        goal_pos = self._get_grid().goal.position.to_tensor()\n\n        if c_best is None:\n            # Uniform sampling until a valid sample is found\n            while True:\n                coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n                sample = Point(*coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Informed sampling inside ellipsoid\n            c_min = torch.norm(goal_pos - agent_pos)\n            if c_best < c_min:\n                # rare case, fall back to uniform sampling\n                return self._get_random_sample_uniform()\n\n            # Center of ellipse\n            center = (agent_pos + goal_pos) / 2.0\n            a1 = (goal_pos - agent_pos) / c_min  # unit vector from start to goal\n\n            # Create orthonormal basis via SVD\n            U, _, _ = torch.svd(torch.eye(self._dimension) - a1.unsqueeze(1) @ a1.unsqueeze(0), some=True)\n            C = torch.cat([a1.unsqueeze(1), U[:, 1:].contiguous()], dim=1)\n\n            # Radius in each dimension\n            r1 = c_best / 2.0\n            r2 = torch.sqrt(c_best**2 - c_min**2) / 2.0\n\n            radii = torch.ones(self._dimension)\n            radii[0] = r1\n            radii[1:] = r2\n\n            for _ in range(1000):  # max attempts for valid sample\n                # Sample inside unit ball\n                direction = torch.randn(self._dimension)\n                direction /= torch.norm(direction)\n                radius = torch.rand(1).item() ** (1 / self._dimension)\n                rnd_ball = direction * radius\n\n                # Transform to ellipsoid space\n                sample_tensor = center + (C @ (radii * rnd_ball))\n\n                sample_point = Point(*[int(torch.clamp(x, 0, self._get_grid().size[i] - 1).item()) for i, x in enumerate(sample_tensor)])\n                if self._get_grid().is_agent_valid_pos(sample_point):\n                    return sample_point\n\n            # fallback uniform sample if fails\n            return self._get_random_sample_uniform()\n\n    def _get_random_sample_uniform(self) -> Point:\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        dir_vector = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vector)\n        if dist == 0:\n            return None  # Same position\n\n        if dist <= max_dist:\n            p = q_sample\n        else:\n            dir_norm = dir_vector / dist\n            new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_norm\n            coords = [int(torch.clamp(c, 0, self._get_grid().size[i] - 1).item()) for i, c in enumerate(new_pos_tensor)]\n            p = Point(*coords)\n\n        if not self._get_grid().is_agent_valid_pos(p):\n            return None\n\n        # Check path collision between q_near and p\n        line_seq = self._get_grid().get_line_sequence(q_near.position, p)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        return Vertex(p)\n\n    def _extract_path(self, last_vertex: Vertex):\n        # Reconstruct path from last_vertex to root\n        path = [last_vertex]\n        current = last_vertex\n        while current != self._graph.root_vertex_start and current.parents:\n            # Choose parent with lowest cost\n            current = min(current.parents, key=lambda v: v.cost if v.cost is not None else float('inf'))\n            path.append(current)\n        path.reverse()\n\n        # Smoothed path by shortcutting\n        smooth_path = self._short_cut_path(path)\n\n        for vertex in smooth_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _short_cut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Attempt to shortcut path segments to improve smoothness.\n        \"\"\"\n        if len(path) <= 2:\n            return path\n\n        new_path = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path\n\n    def _rewire(self, q_new: Vertex, Q_near: List[Vertex]) -> None:\n        for q_near in Q_near:\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cost_through_new = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            if q_near.cost is None or cost_through_new < q_near.cost:\n                # Remove old parent edge\n                for parent in q_near.parents:\n                    self._graph.remove_edge(parent, q_near)\n                # Add new parent edge\n                q_near.cost = cost_through_new\n                self._graph.add_edge(q_new, q_near)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        c_best = None  # best path cost found so far\n        best_last_vertex = None\n\n        priority_queue: List[Tuple[float, Vertex]] = []\n        heapq.heappush(priority_queue, (self._graph.root_vertex_start.cost, self._graph.root_vertex_start))\n\n        max_iterations = 15000\n        while time.time() - start_time < self._max_time_sec and max_iterations > 0:\n\n            max_iterations -= 1\n\n            # Sample informed or uniform depending on whether a path was found\n            q_sample = self._get_random_sample_informed(c_best)\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            if q_new is None:\n                continue\n\n            # Find neighbors within a radius adaptively\n            card_v = torch.tensor(float(self._graph.size + 1))\n            log_card = torch.log(card_v)\n            radius = min(self._lambda_rrt_star * torch.pow(log_card / card_v, 1 / self._dimension), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent that minimizes cost to q_new\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost_through_near = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if cost_through_near < c_min:\n                    q_min = q_near\n                    c_min = cost_through_near\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if it reduces cost\n            self._rewire(q_new, Q_near)\n\n            # Add q_new to priority queue for best-first expansion\n            heapq.heappush(priority_queue, (q_new.cost, q_new))\n\n            # Check goal proximity\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                if c_best is None or q_new.cost + torch.norm(q_new.position.to_tensor() - self._get_grid().goal.position.to_tensor()) < c_best:\n                    # Update best solution\n                    c_best = q_new.cost + torch.norm(q_new.position.to_tensor() - self._get_grid().goal.position.to_tensor())\n                    best_last_vertex = q_new\n\n            self.key_frame()\n\n        if best_last_vertex is not None:\n            self._extract_path(best_last_vertex)\n        else:\n            # No path found within time limit\n            # Optionally mark failure or halt gracefully here\n            # We do not move the agent\n            return",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 215, in _find_path_internal\nNameError: name 'heapq' is not defined\n"
     }
}
{
     "operator": "m2",
     "algorithm": "Improved path planning algorithm based on a tuned and optimized RRT* variant with adaptive sampling bias,\n    radius-based rewiring for path smoothing, and time-limited search. It balances exploration and exploitation \n    by sampling near the goal with an increasing probability and rewiring the tree locally to improve path quality. \n    The algorithm terminates success if the agent reaches the goal region or fails if the planning exceeds 60 seconds.\n    Key improvements:\n    - Adaptive sampling with goal bias to increase convergence speed\n    - Radius-based rewiring of nearby vertices to reduce path length and smoothness\n    - Tuned maximum extension distance based on map size\n    - Early failure termination after 60 seconds to improve robustness\n    - Uses cost metric and rewiring to improve path quality",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True  # allow edge removals for rewiring\n        self._init_displays()\n\n    def _get_distance(self, p1: Point, p2: Point) -> float:\n        return float((p1.to_tensor() - p2.to_tensor()).norm().item())\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction).item()\n        if dist <= max_dist:\n            # Round coordinates to int to avoid float point lookup issue\n            pos_values = tuple(int(round(c)) for c in q_sample.values)\n            return Vertex(Point(*pos_values), store_connectivity=True)\n\n        direction_normalized = direction / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        # Convert new_pos_tensor float coordinates to int to avoid float point lookup issue\n        pos_values = tuple(int(round(c)) for c in new_pos_tensor.tolist())\n        new_pos = Point(*pos_values)\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _get_random_sample(self, goal_sample_rate: float) -> Point:\n        \"\"\"\n        With probability goal_sample_rate, return goal position,\n        otherwise return a valid random sample in the map.\n        \"\"\"\n        if np.random.rand() < goal_sample_rate:\n            pos_values = tuple(int(round(c)) for c in self._get_grid().goal.position.values)\n            return Point(*pos_values)\n\n        while True:\n            # Sample uniformly within grid size bounds\n            rand_coords = [\n                np.random.uniform(0, dim_size) for dim_size in self._get_grid().size.values\n            ]\n            rand_coords_int = [int(math.floor(c)) for c in rand_coords]\n            sample = Point(*rand_coords_int)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_vertices_within_radius(self, vertices: list[Vertex], point: Point, radius: float) -> list[Vertex]:\n        result = []\n        for v in vertices:\n            if self._get_distance(v.position, point) < radius:\n                result.append(v)\n        return result\n\n    def _choose_best_parent(self, near_vertices: list[Vertex], new_vertex: Vertex) -> Point | None:\n        \"\"\"\n        Select the best parent vertex to connect to the new_vertex by minimizing cost.\n        Returns None if no valid parent found.\n        \"\"\"\n        best_parent = None\n        best_cost = math.inf\n        line_cache = None\n\n        for vertex in near_vertices:\n            # Check if line from vertex to new_vertex is valid\n            line = self._get_grid().get_line_sequence(vertex.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n\n            cost = (vertex.cost if vertex.cost is not None else 0) + self._get_grid().get_movement_cost(vertex.position, new_vertex.position)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = vertex\n                line_cache = line\n\n        if best_parent is not None:\n            new_vertex.cost = best_cost\n            self._graph.add_edge(best_parent, new_vertex)\n        else:\n            # No valid parent - treat cost as infinity. We'll discard this vertex later.\n            new_vertex.cost = math.inf\n\n        return best_parent\n\n    def _rewire(self, near_vertices: list[Vertex], new_vertex: Vertex) -> None:\n        \"\"\"\n        Rewire the vertices in near_vertices to connect optimally through new_vertex.\n        \"\"\"\n        for vertex in near_vertices:\n            if vertex == new_vertex:\n                continue\n\n            line = self._get_grid().get_line_sequence(new_vertex.position, vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n\n            new_cost = (new_vertex.cost if new_vertex.cost is not None else 0) + self._get_grid().get_movement_cost(new_vertex.position, vertex.position)\n            if vertex.cost is None or new_cost < vertex.cost:\n                # Remove old edge(s) to vertex\n                parents_to_remove = list(vertex.parents)\n                for p in parents_to_remove:\n                    self._graph.remove_edge(p, vertex)\n                # Add new edge from new_vertex\n                self._graph.add_edge(new_vertex, vertex)\n                vertex.cost = new_cost\n\n    def _extract_path(self, end_vertex: Vertex) -> None:\n        path: list[Vertex] = [end_vertex]\n\n        while len(path[-1].parents) != 0:\n            # Select parent with minimum cost\n            min_parent = None\n            min_cost = math.inf\n            for parent in path[-1].parents:\n                if parent.cost is not None and parent.cost < min_cost:\n                    min_cost = parent.cost\n                    min_parent = parent\n            if min_parent is None:\n                break\n            path.append(min_parent)\n\n        path.reverse()\n\n        # Animate path tracing from start to goal\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n\n    def _find_path_internal(self) -> None:\n        max_time_sec = 60.0\n        start_time = time.time()\n\n        grid = self._get_grid()\n        max_dist = max(5.0, min(grid.size.width, grid.size.height) * 0.1)  # 10% of smaller map dimension, minimum 5 units\n        iterations = 20000\n\n        # Initialize root start vertex cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for i in range(iterations):\n\n            elapsed = time.time() - start_time\n            if elapsed > max_time_sec:\n                # Fail gracefully if timeout exceeded\n                break\n\n            # Increase goal bias progressively after 30% iterations\n            goal_bias = 0.05 + 0.90 * min(i / (iterations * 0.7), 1.0)\n\n            q_sample = self._get_random_sample(goal_bias)\n\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Build line sequence between neighbor and new\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute cost and choose best parent from nearby vertices\n            all_vertices = self._graph.root_vertices + list(self._graph.root_vertex_start.children)  # broad list for rewire & parent selection\n            radius = max_dist * 2.5  # neighborhood radius for rewiring\n            near_vertices = self._get_vertices_within_radius(all_vertices, q_new.position, radius)\n\n            parent = self._choose_best_parent(near_vertices + [q_near], q_new)\n            if parent is None or q_new.cost == math.inf:\n                continue  # no valid parent, discard q_new\n\n            # Add new vertex to root vertices for search\n            self._graph.root_vertices.append(q_new)\n\n            # Rewire the tree for better paths\n            near_vertices_for_rewire = self._get_vertices_within_radius(all_vertices, q_new.position, radius)\n            self._rewire(near_vertices_for_rewire, q_new)\n\n            # Check if agent reached goal radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex for path extraction\n                goal_vertex = Vertex(grid.goal.position, store_connectivity=True)\n                goal_vertex.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_vertex.position)\n                self._graph.add_edge(q_new, goal_vertex)\n                self._extract_path(goal_vertex)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 89, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "e2",
     "algorithm": "Hybrid Path Planning Algorithm combining RRT-Connect with Informed RRT* optimization and adaptive rewiring for improved path quality,\n    efficiency, and smoothness. The algorithm grows two trees from start and goal sampling biased regions, attempts to connect them efficiently,\n    and rewires vertices within dynamic radius. It uses adaptive sampling within elliptical informed subsets to reduce search space once initial path found,\n    incorporates collision checking with Bresenham's line, and terminates if no solution is found within 60 seconds to enhance robustness and reduce search time.\n    The extracted path is smoothed further for path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_dist: float\n    _iterations: int\n    _rewire_radius_const: float\n\n    def __init__(self, services: \"Services\", testing: \"BasicTesting\" = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._max_dist = 15.0\n        self._iterations = 15000\n        # Rewiring radius factor (heuristic)\n        self._rewire_radius_const = 50.0\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_random_sample(self, informed_subset: Optional[Tuple[Point, float, float]] = None) -> Point:\n        \"\"\"\n        Returns a random sample Point in the environment.\n        When informed_subset is given (center, c_best, c_min), sample inside an ellipse for focused search.\n        Else uniform random sampling within map boundaries.\n        \"\"\"\n        size = self._get_grid().size\n\n        if informed_subset is None:\n            # Uniform random valid sample\n            for _ in range(100):\n                rand_pos = np.random.uniform(low=0, high=[size.width, size.height], size=(size.n_dim,))\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n            # fallback uniform discrete\n            while True:\n                rand_pos = np.random.randint(0, size.values, size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            center, c_best, c_min = informed_subset\n            # Sampling inside ellipse in 2D only - ellipse parameters and rotation matrix aligned along start-goal line\n            start = self._graph.root_vertex_start.position.to_tensor()\n            goal = self._graph.root_vertex_goal.position.to_tensor()\n            dim = size.n_dim\n            if dim < 2:\n                # fallback uniform\n                return self._get_random_sample(None)\n\n            # Create a coordinate system aligned with the vector from start to goal\n            diff = goal - start\n            dist = torch.norm(diff).item()\n            if dist == 0:\n                dist = 1e-6\n\n            a1 = diff / dist  # unit vector along major axis\n\n            # Generate random sample inside unit ball in 2D\n            while True:\n                # Sample uniformly in unit circle with rejection sampling\n                sample_in_unit_circle = np.random.uniform(-1, 1, 2)\n                if sample_in_unit_circle[0]**2 + sample_in_unit_circle[1]**2 <= 1:\n                    break\n            u1, u2 = sample_in_unit_circle\n\n            # Lengths of ellipse axes\n            r1 = c_best / 2.0  # Major axis radius\n            r2 = math.sqrt(c_best**2 - c_min**2) / 2.0  # Minor axis radius\n\n            # Rotate sample to global coordinates\n            # The ellipse is aligned such that major axis aligns with a1 (along start-goal)\n            # Build orthonormal basis [a1, a2]\n            a2 = torch.zeros(dim)\n            # Generate an arbitrary vector orthogonal to a1 in 2D\n            if dim == 2:\n                a2[0] = -a1[1]\n                a2[1] = a1[0]\n            else:  # For 3D+, approximation (not very accurate but better than nothing)\n                a2[0] = -a1[1]\n                a2[1] = a1[0]\n                if dim > 2:\n                    a2[2:] = 0\n\n            sample_vec = r1 * u1 * a1 + r2 * u2 * a2\n            sample_point_tensor = center.to_tensor() + sample_vec\n\n            sample_point = Point.from_tensor(sample_point_tensor)\n\n            # Clamp sample inside map bounds and check validity\n            clamped_coords = []\n            for idx, coord in enumerate(sample_point.values):\n                val = max(0, min(coord, size.values[idx] - 1))\n                clamped_coords.append(val)\n            sample_point = Point(*clamped_coords)\n\n            # Validate and fallback if invalid\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n            # If failed, fallback to uniform sample\n            return self._get_random_sample(None)\n\n    def _get_nearest_vertex(self, root_vertices: List[Vertex], point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(root_vertices, point)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n\n        dir_normalized = dir / norm_dir\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos, store_connectivity=True)\n\n    def _get_vertices_within_radius(self, root_vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(root_vertices, point, radius)\n\n    def _calculate_rewire_radius(self) -> float:\n        # Calculate rewiring radius as heuristic based on environment size and nodes count\n        size = self._get_grid().size\n        n = max(1, self._graph.size)\n        volume = size.width * size.height  # approx for 2D\n        r = min(self._max_dist, self._rewire_radius_const * math.sqrt((math.log(n) / n)))\n        r = max(r, 5.0)\n        return r\n\n    def _collision_free(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _cost(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        return self._get_grid().get_distance(from_vertex.position, to_vertex.position)\n\n    def _choose_parent(self, new_vertex: Vertex, neighbors: List[Vertex]) -> Optional[Vertex]:\n        # Choose best parent in terms of cost + cost-to-new_vertex\n        min_cost = math.inf\n        best_parent = None\n        for neighbor in neighbors:\n            if self._collision_free(neighbor.position, new_vertex.position):\n                tentative_cost = neighbor.cost if neighbor.cost is not None else 0\n                tentative_cost += self._cost(neighbor, new_vertex)\n                if tentative_cost < min_cost:\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n        if best_parent:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, neighbors: List[Vertex]) -> None:\n        new_cost = new_vertex.cost if new_vertex.cost is not None else 0\n        for neighbor in neighbors:\n            if neighbor is new_vertex:\n                continue\n            if self._collision_free(new_vertex.position, neighbor.position):\n                cost_through_new = new_cost + self._cost(new_vertex, neighbor)\n                if neighbor.cost is None or cost_through_new < neighbor.cost:\n                    # Rewire: remove old parent edges, add new edge\n                    # Remove previous parent edges\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(new_vertex, neighbor)\n                    neighbor.cost = cost_through_new\n\n    def _extract_path(self, connecting_vertex: Vertex) -> None:\n        # Trace back path from connecting_vertex to start and to goal\n        path_start = []\n        v = connecting_vertex\n        while v is not None:\n            path_start.append(v)\n            if len(v.parents) == 0:\n                break\n            v = next(iter(v.parents))  # one parent (tree structure)\n\n        path_goal = []\n        # goal root vertex\n        goal_vertex = self._graph.root_vertex_goal\n        # We find path from connecting_vertex to goal by DFS or backwards\n        # Walk from goal root downwards to connecting_vertex:\n        # As graph is cyclic, to find goal path we do upwards from goal root\n        # Instead traverse parents from goal root to connecting_vertex via children recursively\n\n        # We find the path from goal to connecting_vertex backwards (via DFS)\n        # Because in cyclic graph children and parents exist, but we enforce edges start->child as direction\n\n        def dfs_find_path(current: Vertex, target: Vertex, visited: Set[Vertex]) -> Optional[List[Vertex]]:\n            if current == target:\n                return [current]\n            visited.add(current)\n            for child in current.children:\n                if child in visited:\n                    continue\n                sub_path = dfs_find_path(child, target, visited)\n                if sub_path:\n                    return [current] + sub_path\n            return None\n\n        path_goal = dfs_find_path(goal_vertex, connecting_vertex, set()) or []\n\n        # Combine paths (path_start reversed is from start to connecting_vertex)\n        path_start.reverse()\n        if len(path_goal) > 0 and path_goal[0] == connecting_vertex:\n            path_goal = path_goal[1:]  # avoid duplicate vertex\n\n        full_path = path_start + path_goal\n\n        # Smooth the path to improve quality\n        smooth_path = self._smooth_path([v.position for v in full_path])\n\n        for pos in smooth_path:\n            self.move_agent(pos)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _smooth_path(self, path_points: List[Point]) -> List[Point]:\n        # Simple path smoothing by shortcutting over unnecessary vertices if collision free\n        if len(path_points) < 3:\n            return path_points\n\n        smooth_path = [path_points[0]]\n        i = 0\n        while i < len(path_points) - 1:\n            j = len(path_points) - 1\n            while j > i + 1:\n                if self._collision_free(path_points[i], path_points[j]):\n                    smooth_path.append(path_points[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # no shortcut found, advance by one\n                smooth_path.append(path_points[i + 1])\n                i += 1\n        return smooth_path\n\n    # Main Algorithm Loop #\n    # --------------------#\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        # Initialization\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        trees = [start_vertex, goal_vertex]  # root vertices for two trees\n        # Two vertex sets for easy access\n        start_tree_vertices = [start_vertex]\n        goal_tree_vertices = [goal_vertex]\n\n        path_found = False\n        best_path_cost = math.inf\n        best_connecting_vertex = None\n\n        # Constants\n        c_min = self._get_grid().get_distance(start_vertex.position, goal_vertex.position)\n        c_best = math.inf\n\n        for iter_idx in range(self._iterations):\n\n            if time.time() - start_time > 60:  # timeout 60 seconds\n                # Fail gracefully\n                break\n\n            # Determine if informed sampling is possible (after path found)\n            informed_subset = None\n            if path_found and best_connecting_vertex is not None and best_path_cost < math.inf:\n                center = Point(*np.array(start_vertex.position.values) + np.array(goal_vertex.position.values)) / 2\n                informed_subset = (center, best_path_cost, c_min)\n\n            # Sample randomly using informed sampling if available\n            q_rand = self._get_random_sample(informed_subset)\n\n            # Alternate tree to extend: 0 or 1\n            tree_idx = iter_idx % 2\n            curr_tree_root = trees[tree_idx]\n            other_tree_root = trees[1 - tree_idx]\n\n            # Extend current tree towards q_rand\n            q_near = self._get_nearest_vertex([curr_tree_root], q_rand)\n            q_new = self._get_new_vertex(q_near, q_rand, self._max_dist)\n\n            # Check collision along edge q_near->q_new\n            if not self._collision_free(q_near.position, q_new.position):\n                self.key_frame()\n                continue\n\n            # Get neighbors for rewiring (both trees)\n            neighbors_radius = self._calculate_rewire_radius()\n            neighbors = self._get_vertices_within_radius([curr_tree_root], q_new.position, neighbors_radius)\n\n            # Choose parent among neighbors\n            best_parent = self._choose_parent(q_new, neighbors)\n            if best_parent is None:\n                # No valid parent found, discard q_new\n                self.key_frame()\n                continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors for better path\n            self._rewire(q_new, neighbors)\n\n            # Add q_new to proper tree vertices list\n            if tree_idx == 0:\n                start_tree_vertices.append(q_new)\n            else:\n                goal_tree_vertices.append(q_new)\n\n            # Try to connect other_tree to q_new by extending towards it\n            q_near_other = self._get_nearest_vertex([other_tree_root], q_new.position)\n            q_new_other = self._get_new_vertex(q_near_other, q_new.position, self._max_dist)\n\n            if self._collision_free(q_near_other.position, q_new_other.position):\n                self._graph.add_edge(q_near_other, q_new_other)\n\n                # Check if connection possible between q_new and q_new_other\n                if self._collision_free(q_new.position, q_new_other.position):\n                    # Connect q_new with q_new_other and form path\n                    self._graph.add_edge(q_new, q_new_other)\n\n                    # Compute path cost for potential solution\n                    total_cost = (q_new.cost if q_new.cost else 0) + \\\n                                 self._get_grid().get_distance(q_new.position, q_new_other.position) + \\\n                                 (q_new_other.cost if q_new_other.cost else 0)\n\n                    if total_cost < best_path_cost:\n                        best_path_cost = total_cost\n                        best_connecting_vertex = q_new\n\n                    path_found = True\n                    # Once connected, break early: extract path\n                    self._extract_path(best_connecting_vertex)\n                    break\n\n            self.key_frame()\n\n        if not path_found:\n            # Mark failure as required (no path found)\n            # If desired, could raise an exception or signal failure here.\n            return",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 317, in _find_path_internal\n  File \"<string>\", line 76, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m1",
     "algorithm": "This PathPlanning algorithm is an enhanced RRT*-inspired planner that adapts dynamically to the map size,\n    improves sampling quality and efficiency by biasing sampling towards the goal with some randomness,\n    incorporates informed rewiring with tightened radius computation for robust path smoothing,\n    and integrates early termination on success or after 60 seconds timeout.\n    It also applies limited shortcut smoothing post path extraction to improve final path smoothness and length.\n    The improvements focus on planning efficiency, path quality, robustness, and reduced search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(\n            self._services, start_vertex, goal_vertex, []\n        )\n\n        self._dimension = self._get_grid().size.n_dim\n        self._max_dist = max(self._get_grid().size.values) * 0.05 + 1  # scale max extension relative to map\n        self._lambda_rrt_star = 30.0  # tuning param for neighborhood radius\n        self._max_radius = max(self._get_grid().size.values) * 0.25 + 5  # cap for radius neighborhood\n        self._timeout_seconds = 60.0\n        self._goal_sample_rate = 0.2  # probability to sample goal directly\n        self._smooth_iterations = 20  # smoothing attempts post path extraction\n\n        self._init_displays()\n\n    # Helper functions #\n\n    def _get_random_sample(self) -> Point:\n        # Bias random sampling with goal_sample_rate towards the goal to improve goal reaching speed\n        import numpy as np\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_coords = [\n                    int(np.random.randint(0, self._get_grid().size[i])) for i in range(self._dimension)\n                ]\n                p = Point(*rand_coords)\n                if self._get_grid().is_agent_valid_pos(p):\n                    return p\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> list[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        from torch import norm\n\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_tensor = q_near.position.to_tensor() + dir_normalized * max_dist\n        return Vertex(Point.from_tensor(q_new_tensor))\n\n    def _collision_free(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Construct path from goal back to start\n        path: list[Vertex] = [Vertex(self._get_grid().goal.position)]\n        path[0].cost = q_new.cost + self._get_grid().get_distance(q_new.position, path[0].position)\n        self._graph.add_edge(q_new, path[0])\n\n        current = q_new\n        while current is not None and len(current.parents) > 0:\n            # pick one parent (ideally the one on shortest path)\n            for p in current.parents:\n                path.append(p)\n                current = p\n                break\n        if current is None or current.position != self._graph.root_vertex_start.position:\n            # no valid path found (should not occur if algorithm reached goal)\n            return\n\n        path.reverse()\n\n        # Apply shortcut smoothing to improve path length and smoothness\n        self._shortcut_smooth_path(path)\n\n        # Move agent along the path and keyframe\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_smooth_path(self, path: list[Vertex]) -> None:\n        # Attempt to shortcut edges in path by checking for direct collision-free segments\n        length = len(path)\n        import random\n        for _ in range(self._smooth_iterations):\n            if length < 3:\n                break\n            i = random.randint(0, length - 3)\n            j = random.randint(i + 2, length - 1)\n            p_i = path[i].position\n            p_j = path[j].position\n            if self._collision_free(p_i, p_j):\n                # Remove intermediate vertices between i and j\n                del path[i + 1 : j]\n\n                length = len(path)\n\n    # Main path planning loop #\n\n    def _find_path_internal(self) -> None:\n        import torch\n        from time import time\n\n        start_time = time()\n        iter_limit = 15000  # cap on iterations - can be adjusted\n        iteration = 0\n\n        while iteration < iter_limit:\n            iteration += 1\n\n            if time() - start_time > self._timeout_seconds:\n                # Search failed due to timeout\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            if not self._collision_free(q_nearest.position, q_new.position):\n                continue\n\n            # Compute radius for neighbor search\n            card_v = float(self._graph.size)\n            if card_v <= 1:\n                radius = self._max_radius\n            else:\n                log_card_v = torch.log(torch.tensor(card_v))\n                radius = min(\n                    self._lambda_rrt_star\n                    * ((log_card_v / card_v) ** (1.0 / self._dimension)),\n                    self._max_radius,\n                )\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with minimum cost to new vertex\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._get_grid().get_distance(q_nearest.position, q_new.position)\n\n            for q_near in Q_near:\n                if self._collision_free(q_near.position, q_new.position):\n                    candidate_cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n                    if candidate_cost < c_min:\n                        q_min = q_near\n                        c_min = candidate_cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire nearby vertices to potentially improve their cost\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                if self._collision_free(q_new.position, q_near.position):\n                    candidate_cost = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n                    if candidate_cost < q_near.cost:\n                        # Remove old parent edge\n                        old_parents = list(q_near.parents)\n                        for old_parent in old_parents:\n                            self._graph.remove_edge(old_parent, q_near)\n\n                        q_near.cost = candidate_cost\n                        self._graph.add_edge(q_new, q_near)\n\n            # Early goal check: if new vertex is within goal radius, extract path\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 83, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "m2",
     "algorithm": "Improved path planning algorithm based on a tuned and optimized RRT* variant with adaptive sampling bias,\n    radius-based rewiring for path smoothing, and time-limited search. It balances exploration and exploitation \n    by sampling near the goal with an increasing probability and rewiring the tree locally to improve path quality. \n    The algorithm terminates success if the agent reaches the goal region or fails if the planning exceeds 60 seconds.\n    Key improvements:\n    - Adaptive sampling with goal bias to increase convergence speed\n    - Radius-based rewiring of nearby vertices to reduce path length and smoothness\n    - Tuned maximum extension distance based on map size\n    - Early failure termination after 60 seconds to improve robustness\n    - Uses cost metric and rewiring to improve path quality",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True  # allow edge removals for rewiring\n        self._init_displays()\n\n    def _get_distance(self, p1: Point, p2: Point) -> float:\n        return float((p1.to_tensor() - p2.to_tensor()).norm().item())\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction).item()\n        if dist <= max_dist:\n            # Round coordinates to int to avoid float point lookup issue\n            pos_values = tuple(int(round(c)) for c in q_sample.values)\n            return Vertex(Point(*pos_values), store_connectivity=True)\n\n        direction_normalized = direction / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        # Convert new_pos_tensor float coordinates to int to avoid float point lookup issue\n        pos_values = tuple(int(round(c)) for c in new_pos_tensor.tolist())\n        new_pos = Point(*pos_values)\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _get_random_sample(self, goal_sample_rate: float) -> Point:\n        \"\"\"\n        With probability goal_sample_rate, return goal position,\n        otherwise return a valid random sample in the map.\n        \"\"\"\n        if np.random.rand() < goal_sample_rate:\n            pos_values = tuple(int(round(c)) for c in self._get_grid().goal.position.values)\n            return Point(*pos_values)\n\n        while True:\n            # Sample uniformly within grid size bounds\n            rand_coords = [\n                np.random.uniform(0, dim_size) for dim_size in self._get_grid().size.values\n            ]\n            rand_coords_int = [int(math.floor(c)) for c in rand_coords]\n            sample = Point(*rand_coords_int)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_vertices_within_radius(self, vertices: list, point: Point, radius: float) -> list:\n        result = []\n        for v in vertices:\n            if self._get_distance(v.position, point) < radius:\n                result.append(v)\n        return result\n\n    def _choose_best_parent(self, near_vertices: list, new_vertex: Vertex) -> Point | None:\n        \"\"\"\n        Select the best parent vertex to connect to the new_vertex by minimizing cost.\n        Returns None if no valid parent found.\n        \"\"\"\n        best_parent = None\n        best_cost = math.inf\n        line_cache = None\n\n        for vertex in near_vertices:\n            # Check if line from vertex to new_vertex is valid\n            line = self._get_grid().get_line_sequence(vertex.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n\n            cost = (vertex.cost if vertex.cost is not None else 0) + self._get_grid().get_movement_cost(vertex.position, new_vertex.position)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = vertex\n                line_cache = line\n\n        if best_parent is not None:\n            new_vertex.cost = best_cost\n            self._graph.add_edge(best_parent, new_vertex)\n        else:\n            # No valid parent - treat cost as infinity. We'll discard this vertex later.\n            new_vertex.cost = math.inf\n\n        return best_parent\n\n    def _rewire(self, near_vertices: list, new_vertex: Vertex) -> None:\n        \"\"\"\n        Rewire the vertices in near_vertices to connect optimally through new_vertex.\n        \"\"\"\n        for vertex in near_vertices:\n            if vertex == new_vertex:\n                continue\n\n            line = self._get_grid().get_line_sequence(new_vertex.position, vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n\n            new_cost = (new_vertex.cost if new_vertex.cost is not None else 0) + self._get_grid().get_movement_cost(new_vertex.position, vertex.position)\n            if vertex.cost is None or new_cost < vertex.cost:\n                # Remove old edge(s) to vertex\n                parents_to_remove = list(vertex.parents)\n                for p in parents_to_remove:\n                    self._graph.remove_edge(p, vertex)\n                # Add new edge from new_vertex\n                self._graph.add_edge(new_vertex, vertex)\n                vertex.cost = new_cost\n\n    def _extract_path(self, end_vertex: Vertex) -> None:\n        path: list = [end_vertex]\n\n        while len(path[-1].parents) != 0:\n            # Select parent with minimum cost\n            min_parent = None\n            min_cost = math.inf\n            for parent in path[-1].parents:\n                if parent.cost is not None and parent.cost < min_cost:\n                    min_cost = parent.cost\n                    min_parent = parent\n            if min_parent is None:\n                break\n            path.append(min_parent)\n\n        path.reverse()\n\n        # Animate path tracing from start to goal\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n\n    def _find_path_internal(self) -> None:\n        max_time_sec = 60.0\n        start_time = time.time()\n\n        grid = self._get_grid()\n        max_dist = max(5.0, min(grid.size.width, grid.size.height) * 0.1)  # 10% of smaller map dimension, minimum 5 units\n        iterations = 20000\n\n        # Initialize root start vertex cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for i in range(iterations):\n\n            elapsed = time.time() - start_time\n            if elapsed > max_time_sec:\n                # Fail gracefully if timeout exceeded\n                break\n\n            # Increase goal bias progressively after 30% iterations\n            goal_bias = 0.05 + 0.90 * min(i / (iterations * 0.7), 1.0)\n\n            q_sample = self._get_random_sample(goal_bias)\n\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Build line sequence between neighbor and new\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute cost and choose best parent from nearby vertices\n            all_vertices = self._graph.root_vertices + list(self._graph.root_vertex_start.children)  # broad list for rewire & parent selection\n            radius = max_dist * 2.5  # neighborhood radius for rewiring\n            near_vertices = self._get_vertices_within_radius(all_vertices, q_new.position, radius)\n\n            parent = self._choose_best_parent(near_vertices + [q_near], q_new)\n            if parent is None or q_new.cost == math.inf:\n                continue  # no valid parent, discard q_new\n\n            # Add new vertex to root vertices for search\n            self._graph.root_vertices.append(q_new)\n\n            # Rewire the tree for better paths\n            near_vertices_for_rewire = self._get_vertices_within_radius(all_vertices, q_new.position, radius)\n            self._rewire(near_vertices_for_rewire, q_new)\n\n            # Check if agent reached goal radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex for path extraction\n                goal_vertex = Vertex(grid.goal.position, store_connectivity=True)\n                goal_vertex.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_vertex.position)\n                self._graph.add_edge(q_new, goal_vertex)\n                self._extract_path(goal_vertex)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 96, in PathPlanning\nTypeError: unsupported operand type(s) for |: 'type' and 'NoneType'\n"
     }
}
{
     "operator": "m3",
     "algorithm": "Improved sampling-based path planning algorithm that combines adaptive sampling \n    focusing near the goal with an anytime rewiring strategy inspired by RRT*.\n\n    Key features:\n    - Adaptive goal-bias sampling with dynamically adjusted radius to focus exploration efficiently.\n    - Anytime rewiring of the graph within a shrinking radius improving path quality progressively.\n    - Early pruning of costly connections based on incremental cost evaluation.\n    - Integration of time limit (60 sec) to abort search if no solution found.\n    - Uses cyclic graph structure enabling better edge manipulations and path smoothness.\n    - Balances exploration and exploitation dynamically based on iteration and search status.\n\n    The method aims for improved planning efficiency, path quality, robustness, and reduced search times.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: \"CyclicGraph\"\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n        start_v = Vertex(start_pos)\n        start_v.cost = 0\n        goal_v = Vertex(goal_pos)\n        self._graph = gen_cyclic_graph(self._services, start_v, goal_v, [])\n        self._init_displays()\n\n    def _get_random_sample(self, goal_bias=0.15, goal_sample_radius=15.0) -> Point:\n        \"\"\"Sample with bias: mostly uniform random, sometimes near goal within a radius.\"\"\"\n\n        grid = self._get_grid()\n        # Bias towards sampling near the goal position\n        if np.random.random() < goal_bias:\n            attempts = 0\n            while True:\n                # Sample in a circle around the goal (for 2D)\n                angle = np.random.uniform(0, 2 * np.pi)\n                radius = np.random.uniform(0, goal_sample_radius)\n                dx = radius * math.cos(angle)\n                dy = radius * math.sin(angle)\n                gp = grid.goal.position\n                candidate = Point(int(gp.x + dx), int(gp.y + dy))\n                attempts += 1\n                if grid.is_agent_valid_pos(candidate):\n                    return candidate\n                if attempts > 100:  # fallback to global random sampling\n                    break\n\n        # Uniform random sample in the entire map size\n        max_dims = grid.size.values\n        while True:\n            rand_pos = np.random.randint(0, max_dims, len(max_dims))\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_v: Vertex, to_p: Point, max_dist: float) -> Vertex:\n        \"\"\"Return a new vertex in the direction from from_v to to_p with max step length max_dist.\"\"\"\n        dir_vec = to_p.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(to_p)\n        dir_norm = dir_vec / dist\n        new_pos_tensor = from_v.position.to_tensor() + dir_norm * max_dist\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _get_nearest_vertex(self, point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, point)\n\n    def _get_nearby_vertices(self, vertex: Vertex, radius: float) -> list[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _cost(self, from_v: Vertex, to_v: Vertex) -> float:\n        return from_v.cost + self._get_grid().get_distance(from_v.position, to_v.position)\n\n    def _extract_path(self, last_vertex: Vertex) -> None:\n        # Goal vertex that references last vertex\n        goal_v = Vertex(self._get_grid().goal.position)\n        child_parent_dist = self._get_grid().get_distance(last_vertex.position, goal_v.position)\n        goal_v.cost = last_vertex.cost + child_parent_dist\n        self._graph.add_edge(last_vertex, goal_v)\n        path = [goal_v]\n\n        while path[-1].parents:\n            for p in path[-1].parents:\n                path.append(p)\n                break\n\n        path.pop()  # remove the root with no parents\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n\n        max_dist = 10.0\n        max_iter = 10000\n        dimension = grid.size.n_dim\n        max_time_sec = 60\n\n        start_time = time.time()\n\n        # Constants for radius calculation (RRT* inspired)\n        gamma_rrt_star = 50.0\n        goal_sample_radius = max(15.0, max_dist * 2)\n\n        # Initialize the start vertex cost (done in __init__)\n\n        for iter_count in range(max_iter):\n\n            if time.time() - start_time > max_time_sec:\n                # Treat search as failed after 60seconds\n                break\n\n            # Adaptive decreasing goal bias and radius for goal sampling\n            elapsed_ratio = iter_count / max_iter\n            goal_bias = max(0.1, 0.3 * (1.0 - elapsed_ratio))\n            adaptive_goal_radius = max(goal_sample_radius * (1.0 - elapsed_ratio), max_dist)\n\n            q_sample = self._get_random_sample(goal_bias=goal_bias, goal_sample_radius=adaptive_goal_radius)\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._steer(q_nearest, q_sample, max_dist)\n\n            # Check path between nearest and new is valid\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Radius for neighbors for rewiring, shrinking as tree grows\n            card_V = max(1, float(self._graph.size))\n            radius = min(\n                gamma_rrt_star * ((math.log(card_V) / card_V) ** (1 / dimension)),\n                max_dist * 3,\n            )\n\n            nearby_vertices = self._get_nearby_vertices(q_new, radius)\n\n            # Choose parent that minimizes cost and is collision free\n            q_min = q_nearest\n            c_min = self._cost(q_nearest, q_new)\n\n            for near_v in nearby_vertices:\n                # Edge collision check\n                if grid.is_valid_line_sequence(grid.get_line_sequence(near_v.position, q_new.position)):\n                    cost_through_near = self._cost(near_v, q_new)\n                    if cost_through_near < c_min:\n                        q_min = near_v\n                        c_min = cost_through_near\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if a cheaper path via q_new is found\n            for near_v in nearby_vertices:\n                if near_v == q_min:\n                    continue\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, near_v.position)):\n                    cost_via_new = q_new.cost + grid.get_distance(q_new.position, near_v.position)\n                    if cost_via_new < near_v.cost:\n                        # Remove old parent edge (assumption: one parent per vertex in this graph)\n                        old_parent = None\n                        for p in near_v.parents:\n                            old_parent = p\n                            break\n                        if old_parent:\n                            self._graph.remove_edge(old_parent, near_v)\n                        near_v.cost = None\n                        near_v.cost = cost_via_new\n                        self._graph.add_edge(q_new, near_v)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 97, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is a hybrid informed RRT* variant with adaptive sampling and smoothing.\n    It improves planning efficiency and path quality by guiding the search within an \n    ellipsoidal informed subset of the space (informed sampling), dynamically adjusting \n    the search radius based on vertex density, and applying iterative smoothing when \n    the goal is reached. It uses a best-first priority queue expansion to favor low-cost \n    vertices, combined with rewiring for optimality. A timeout of 60 seconds is enforced \n    with failure notification. This balances robustness, success rate, path smoothness, \n    search time, and path length improvements.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _max_radius: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_time_sec: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 12.0\n        self._max_radius = 30.0\n        self._lambda_rrt_star = 50.0\n        self._dimension = self._get_grid().size.n_dim\n        self._max_time_sec = 60.0  # maximum allowed time in seconds\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    def _get_random_sample_informed(self, c_best: Optional[float]) -> Point:\n        \"\"\"\n        Informed sampling inside an ellipsoid defined by start, goal, and current best cost.\n        If no path found yet (c_best is None), sample uniformly.\n        \"\"\"\n        agent_pos = self._get_grid().agent.position.to_tensor()\n        goal_pos = self._get_grid().goal.position.to_tensor()\n\n        if c_best is None:\n            # Uniform sampling until a valid sample is found\n            while True:\n                coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n                sample = Point(*coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Informed sampling inside ellipsoid\n            c_min = torch.norm(goal_pos - agent_pos)\n            if c_best < c_min:\n                # rare case, fall back to uniform sampling\n                return self._get_random_sample_uniform()\n\n            # Center of ellipse\n            center = (agent_pos + goal_pos) / 2.0\n            a1 = (goal_pos - agent_pos) / c_min  # unit vector from start to goal\n\n            # Create orthonormal basis via SVD\n            U, _, _ = torch.svd(torch.eye(self._dimension) - a1.unsqueeze(1) @ a1.unsqueeze(0), some=True)\n            C = torch.cat([a1.unsqueeze(1), U[:, 1:].contiguous()], dim=1)\n\n            # Radius in each dimension\n            r1 = c_best / 2.0\n            r2 = torch.sqrt(c_best**2 - c_min**2) / 2.0\n\n            radii = torch.ones(self._dimension)\n            radii[0] = r1\n            radii[1:] = r2\n\n            for _ in range(1000):  # max attempts for valid sample\n                # Sample inside unit ball\n                direction = torch.randn(self._dimension)\n                direction /= torch.norm(direction)\n                radius = torch.rand(1).item() ** (1 / self._dimension)\n                rnd_ball = direction * radius\n\n                # Transform to ellipsoid space\n                sample_tensor = center + (C @ (radii * rnd_ball))\n\n                sample_point = Point(*[int(torch.clamp(x, 0, self._get_grid().size[i] - 1).item()) for i, x in enumerate(sample_tensor)])\n                if self._get_grid().is_agent_valid_pos(sample_point):\n                    return sample_point\n\n            # fallback uniform sample if fails\n            return self._get_random_sample_uniform()\n\n    def _get_random_sample_uniform(self) -> Point:\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        dir_vector = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vector)\n        if dist == 0:\n            return None  # Same position\n\n        if dist <= max_dist:\n            p = q_sample\n        else:\n            dir_norm = dir_vector / dist\n            new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_norm\n            coords = [int(torch.clamp(c, 0, self._get_grid().size[i] - 1).item()) for i, c in enumerate(new_pos_tensor)]\n            p = Point(*coords)\n\n        if not self._get_grid().is_agent_valid_pos(p):\n            return None\n\n        # Check path collision between q_near and p\n        line_seq = self._get_grid().get_line_sequence(q_near.position, p)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        return Vertex(p)\n\n    def _extract_path(self, last_vertex: Vertex):\n        # Reconstruct path from last_vertex to root\n        path = [last_vertex]\n        current = last_vertex\n        while current != self._graph.root_vertex_start and current.parents:\n            # Choose parent with lowest cost\n            current = min(current.parents, key=lambda v: v.cost if v.cost is not None else float('inf'))\n            path.append(current)\n        path.reverse()\n\n        # Smoothed path by shortcutting\n        smooth_path = self._short_cut_path(path)\n\n        for vertex in smooth_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _short_cut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Attempt to shortcut path segments to improve smoothness.\n        \"\"\"\n        if len(path) <= 2:\n            return path\n\n        new_path = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path\n\n    def _rewire(self, q_new: Vertex, Q_near: List[Vertex]) -> None:\n        for q_near in Q_near:\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cost_through_new = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            if q_near.cost is None or cost_through_new < q_near.cost:\n                # Remove old parent edge\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                # Add new parent edge\n                q_near.cost = cost_through_new\n                self._graph.add_edge(q_new, q_near)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        c_best = None  # best path cost found so far\n        best_last_vertex = None\n\n        priority_queue: List[Tuple[float, Vertex]] = []\n        heapq.heappush(priority_queue, (self._graph.root_vertex_start.cost, self._graph.root_vertex_start))\n\n        max_iterations = 15000\n        while time.time() - start_time < self._max_time_sec and max_iterations > 0:\n\n            max_iterations -= 1\n\n            # Sample informed or uniform depending on whether a path was found\n            q_sample = self._get_random_sample_informed(c_best)\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            if q_new is None:\n                continue\n\n            # Find neighbors within a radius adaptively\n            card_v = torch.tensor(float(self._graph.size + 1))\n            log_card = torch.log(card_v)\n            radius = min(self._lambda_rrt_star * torch.pow(log_card / card_v, 1 / self._dimension), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent that minimizes cost to q_new\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost_through_near = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if cost_through_near < c_min:\n                    q_min = q_near\n                    c_min = cost_through_near\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if it reduces cost\n            self._rewire(q_new, Q_near)\n\n            # Add q_new to priority queue for best-first expansion\n            heapq.heappush(priority_queue, (q_new.cost, q_new))\n\n            # Check goal proximity\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = torch.norm(q_new.position.to_tensor() - self._get_grid().goal.position.to_tensor())\n                total_cost = q_new.cost + dist_to_goal\n                if c_best is None or total_cost < c_best:\n                    # Update best solution\n                    c_best = total_cost\n                    best_last_vertex = q_new\n\n            self.key_frame()\n\n        if best_last_vertex is not None:\n            self._extract_path(best_last_vertex)\n        else:\n            # No path found within time limit\n            # Optionally mark failure or halt gracefully here\n            # We do not move the agent\n            return",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 215, in _find_path_internal\nNameError: name 'heapq' is not defined\n"
     }
}
{
     "operator": "e2",
     "algorithm": "Hybrid Path Planning Algorithm combining RRT-Connect with Informed RRT* optimization and adaptive rewiring for improved path quality,\n    efficiency, and smoothness. The algorithm grows two trees from start and goal sampling biased regions, attempts to connect them efficiently,\n    and rewires vertices within dynamic radius. It uses adaptive sampling within elliptical informed subsets to reduce search space once initial path found,\n    incorporates collision checking with Bresenham's line, and terminates if no solution is found within 60 seconds to enhance robustness and reduce search time.\n    The extracted path is smoothed further for path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_dist: float\n    _iterations: int\n    _rewire_radius_const: float\n\n    def __init__(self, services: \"Services\", testing: \"BasicTesting\" = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._max_dist = 15.0\n        self._iterations = 15000\n        # Rewiring radius factor (heuristic)\n        self._rewire_radius_const = 50.0\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_random_sample(self, informed_subset: Optional[Tuple[Point, float, float]] = None) -> Point:\n        \"\"\"\n        Returns a random sample Point in the environment.\n        When informed_subset is given (center, c_best, c_min), sample inside an ellipse for focused search.\n        Else uniform random sampling within map boundaries.\n        \"\"\"\n        size = self._get_grid().size\n\n        def to_int_point(p: Point) -> Point:\n            # Convert Point with potential floats into Point with int coordinates\n            # This resolves the error with float positions in dense_map lookup\n            int_coords = tuple(int(round(coord)) for coord in p.values)\n            return Point(*int_coords)\n\n        if informed_subset is None:\n            # Uniform random valid sample\n            for _ in range(100):\n                rand_pos = np.random.uniform(low=0, high=[size.width, size.height], size=(size.n_dim,))\n                sample = Point(*rand_pos)\n                sample_int = to_int_point(sample)\n                if self._get_grid().is_agent_valid_pos(sample_int):\n                    return sample_int\n            # fallback uniform discrete\n            while True:\n                rand_pos = np.random.randint(0, size.values, size=size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            center, c_best, c_min = informed_subset\n            # Sampling inside ellipse in 2D only - ellipse parameters and rotation matrix aligned along start-goal line\n            start = self._graph.root_vertex_start.position.to_tensor()\n            goal = self._graph.root_vertex_goal.position.to_tensor()\n            dim = size.n_dim\n            if dim < 2:\n                # fallback uniform\n                return self._get_random_sample(None)\n\n            # Create a coordinate system aligned with the vector from start to goal\n            diff = goal - start\n            dist = torch.norm(diff).item()\n            if dist == 0:\n                dist = 1e-6\n\n            a1 = diff / dist  # unit vector along major axis\n\n            # Generate random sample inside unit ball in 2D\n            while True:\n                # Sample uniformly in unit circle with rejection sampling\n                sample_in_unit_circle = np.random.uniform(-1, 1, 2)\n                if sample_in_unit_circle[0]**2 + sample_in_unit_circle[1]**2 <= 1:\n                    break\n            u1, u2 = sample_in_unit_circle\n\n            # Lengths of ellipse axes\n            r1 = c_best / 2.0  # Major axis radius\n            r2 = math.sqrt(c_best**2 - c_min**2) / 2.0  # Minor axis radius\n\n            # Rotate sample to global coordinates\n            # The ellipse is aligned such that major axis aligns with a1 (along start-goal)\n            # Build orthonormal basis [a1, a2]\n            a2 = torch.zeros(dim)\n            # Generate an arbitrary vector orthogonal to a1 in 2D\n            if dim == 2:\n                a2[0] = -a1[1]\n                a2[1] = a1[0]\n            else:  # For 3D+, approximation (not very accurate but better than nothing)\n                a2[0] = -a1[1]\n                a2[1] = a1[0]\n                if dim > 2:\n                    a2[2:] = 0\n\n            sample_vec = r1 * u1 * a1 + r2 * u2 * a2\n            sample_point_tensor = center.to_tensor() + sample_vec\n\n            sample_point = Point(*sample_point_tensor.tolist())\n\n            # Clamp sample inside map bounds and check validity\n            clamped_coords = []\n            for idx, coord in enumerate(sample_point.values):\n                val = max(0, min(coord, size.values[idx] - 1))\n                clamped_coords.append(val)\n            sample_point = Point(*clamped_coords)\n\n            sample_int = to_int_point(sample_point)\n\n            # Validate and fallback if invalid\n            if self._get_grid().is_agent_valid_pos(sample_int):\n                return sample_int\n\n            # If failed, fallback to uniform sample\n            return self._get_random_sample(None)\n\n    def _get_nearest_vertex(self, root_vertices: List[Vertex], point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(root_vertices, point)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            # ensure position has integer coordinates for dense_map compatibility\n            p_int = Point(*[int(round(c)) for c in q_sample.values])\n            return Vertex(p_int, store_connectivity=True)\n\n        dir_normalized = dir / norm_dir\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        # Convert to integer Point\n        p_int = Point(*[int(round(c.item())) for c in new_pos_tensor])\n        return Vertex(p_int, store_connectivity=True)\n\n    def _get_vertices_within_radius(self, root_vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(root_vertices, point, radius)\n\n    def _calculate_rewire_radius(self) -> float:\n        # Calculate rewiring radius as heuristic based on environment size and nodes count\n        size = self._get_grid().size\n        n = max(1, self._graph.size)\n        volume = size.width * size.height  # approx for 2D\n        r = min(self._max_dist, self._rewire_radius_const * math.sqrt((math.log(n) / n)))\n        r = max(r, 5.0)\n        return r\n\n    def _collision_free(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _cost(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        return self._get_grid().get_distance(from_vertex.position, to_vertex.position)\n\n    def _choose_parent(self, new_vertex: Vertex, neighbors: List[Vertex]) -> Optional[Vertex]:\n        # Choose best parent in terms of cost + cost-to-new_vertex\n        min_cost = math.inf\n        best_parent = None\n        for neighbor in neighbors:\n            if self._collision_free(neighbor.position, new_vertex.position):\n                tentative_cost = neighbor.cost if neighbor.cost is not None else 0\n                tentative_cost += self._cost(neighbor, new_vertex)\n                if tentative_cost < min_cost:\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n        if best_parent:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, neighbors: List[Vertex]) -> None:\n        new_cost = new_vertex.cost if new_vertex.cost is not None else 0\n        for neighbor in neighbors:\n            if neighbor is new_vertex:\n                continue\n            if self._collision_free(new_vertex.position, neighbor.position):\n                cost_through_new = new_cost + self._cost(new_vertex, neighbor)\n                if neighbor.cost is None or cost_through_new < neighbor.cost:\n                    # Rewire: remove old parent edges, add new edge\n                    # Remove previous parent edges\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(new_vertex, neighbor)\n                    neighbor.cost = cost_through_new\n\n    def _extract_path(self, connecting_vertex: Vertex) -> None:\n        # Trace back path from connecting_vertex to start and to goal\n        path_start = []\n        v = connecting_vertex\n        while v is not None:\n            path_start.append(v)\n            if len(v.parents) == 0:\n                break\n            v = next(iter(v.parents))  # one parent (tree structure)\n\n        path_goal = []\n        # goal root vertex\n        goal_vertex = self._graph.root_vertex_goal\n        # We find path from connecting_vertex to goal by DFS or backwards\n        # Walk from goal root downwards to connecting_vertex:\n        # As graph is cyclic, to find goal path we do upwards from goal root\n        # Instead traverse parents from goal root to connecting_vertex via children recursively\n\n        # We find the path from goal to connecting_vertex backwards (via DFS)\n        # Because in cyclic graph children and parents exist, but we enforce edges start->child as direction\n\n        def dfs_find_path(current: Vertex, target: Vertex, visited: Set[Vertex]) -> Optional[List[Vertex]]:\n            if current == target:\n                return [current]\n            visited.add(current)\n            for child in current.children:\n                if child in visited:\n                    continue\n                sub_path = dfs_find_path(child, target, visited)\n                if sub_path:\n                    return [current] + sub_path\n            return None\n\n        path_goal = dfs_find_path(goal_vertex, connecting_vertex, set()) or []\n\n        # Combine paths (path_start reversed is from start to connecting_vertex)\n        path_start.reverse()\n        if len(path_goal) > 0 and path_goal[0] == connecting_vertex:\n            path_goal = path_goal[1:]  # avoid duplicate vertex\n\n        full_path = path_start + path_goal\n\n        # Smooth the path to improve quality\n        smooth_path = self._smooth_path([v.position for v in full_path])\n\n        for pos in smooth_path:\n            self.move_agent(pos)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _smooth_path(self, path_points: List[Point]) -> List[Point]:\n        # Simple path smoothing by shortcutting over unnecessary vertices if collision free\n        if len(path_points) < 3:\n            return path_points\n\n        smooth_path = [path_points[0]]\n        i = 0\n        while i < len(path_points) - 1:\n            j = len(path_points) - 1\n            while j > i + 1:\n                if self._collision_free(path_points[i], path_points[j]):\n                    smooth_path.append(path_points[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # no shortcut found, advance by one\n                smooth_path.append(path_points[i + 1])\n                i += 1\n        return smooth_path\n\n    # Main Algorithm Loop #\n    # --------------------#\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        # Initialization\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        trees = [start_vertex, goal_vertex]  # root vertices for two trees\n        # Two vertex sets for easy access\n        start_tree_vertices = [start_vertex]\n        goal_tree_vertices = [goal_vertex]\n\n        path_found = False\n        best_path_cost = math.inf\n        best_connecting_vertex = None\n\n        # Constants\n        c_min = self._get_grid().get_distance(start_vertex.position, goal_vertex.position)\n        c_best = math.inf\n\n        for iter_idx in range(self._iterations):\n\n            if time.time() - start_time > 60:  # timeout 60 seconds\n                # Fail gracefully\n                break\n\n            # Determine if informed sampling is possible (after path found)\n            informed_subset = None\n            if path_found and best_connecting_vertex is not None and best_path_cost < math.inf:\n                center_raw = np.array(start_vertex.position.values) + np.array(goal_vertex.position.values)\n                center = Point(*((center_raw / 2).tolist()))\n                informed_subset = (center, best_path_cost, c_min)\n\n            # Sample randomly using informed sampling if available\n            q_rand = self._get_random_sample(informed_subset)\n\n            # Alternate tree to extend: 0 or 1\n            tree_idx = iter_idx % 2\n            curr_tree_root = trees[tree_idx]\n            other_tree_root = trees[1 - tree_idx]\n\n            # Extend current tree towards q_rand\n            q_near = self._get_nearest_vertex([curr_tree_root], q_rand)\n            q_new = self._get_new_vertex(q_near, q_rand, self._max_dist)\n\n            # Check collision along edge q_near->q_new\n            if not self._collision_free(q_near.position, q_new.position):\n                self.key_frame()\n                continue\n\n            # Get neighbors for rewiring (both trees)\n            neighbors_radius = self._calculate_rewire_radius()\n            neighbors = self._get_vertices_within_radius([curr_tree_root], q_new.position, neighbors_radius)\n\n            # Choose parent among neighbors\n            best_parent = self._choose_parent(q_new, neighbors)\n            if best_parent is None:\n                # No valid parent found, discard q_new\n                self.key_frame()\n                continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors for better path\n            self._rewire(q_new, neighbors)\n\n            # Add q_new to proper tree vertices list\n            if tree_idx == 0:\n                start_tree_vertices.append(q_new)\n            else:\n                goal_tree_vertices.append(q_new)\n\n            # Try to connect other_tree to q_new by extending towards it\n            q_near_other = self._get_nearest_vertex([other_tree_root], q_new.position)\n            q_new_other = self._get_new_vertex(q_near_other, q_new.position, self._max_dist)\n\n            if self._collision_free(q_near_other.position, q_new_other.position):\n                self._graph.add_edge(q_near_other, q_new_other)\n\n                # Check if connection possible between q_new and q_new_other\n                if self._collision_free(q_new.position, q_new_other.position):\n                    # Connect q_new with q_new_other and form path\n                    self._graph.add_edge(q_new, q_new_other)\n\n                    # Compute path cost for potential solution\n                    total_cost = (q_new.cost if q_new.cost else 0) + \\\n                                 self._get_grid().get_distance(q_new.position, q_new_other.position) + \\\n                                 (q_new_other.cost if q_new_other.cost else 0)\n\n                    if total_cost < best_path_cost:\n                        best_path_cost = total_cost\n                        best_connecting_vertex = q_new\n\n                    path_found = True\n                    # Once connected, break early: extract path\n                    self._extract_path(best_connecting_vertex)\n                    break\n\n            self.key_frame()\n\n        if not path_found:\n            # Mark failure as required (no path found)\n            # If desired, could raise an exception or signal failure here.\n            return",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 331, in _find_path_internal\n  File \"<string>\", line 82, in _get_random_sample\n  File \"<string>\", line 74, in to_int_point\nAttributeError: 'Point' object has no attribute 'values'\n"
     }
}
{
     "operator": "m2",
     "algorithm": "Improved path planning algorithm based on a tuned and optimized RRT* variant with adaptive sampling bias,\n    radius-based rewiring for path smoothing, and time-limited search. It balances exploration and exploitation \n    by sampling near the goal with an increasing probability and rewiring the tree locally to improve path quality. \n    The algorithm terminates success if the agent reaches the goal region or fails if the planning exceeds 60 seconds.\n    Key improvements:\n    - Adaptive sampling with goal bias to increase convergence speed\n    - Radius-based rewiring of nearby vertices to reduce path length and smoothness\n    - Tuned maximum extension distance based on map size\n    - Early failure termination after 60 seconds to improve robustness\n    - Uses cost metric and rewiring to improve path quality",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True  # allow edge removals for rewiring\n        self._init_displays()\n\n    def _get_distance(self, p1: Point, p2: Point) -> float:\n        return float((p1.to_tensor() - p2.to_tensor()).norm().item())\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction).item()\n        if dist <= max_dist:\n            # Round coordinates to int to avoid float point lookup issue\n            pos_values = tuple(int(round(c)) for c in q_sample.values)\n            return Vertex(Point(*pos_values), store_connectivity=True)\n\n        direction_normalized = direction / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        # Convert new_pos_tensor float coordinates to int to avoid float point lookup issue\n        pos_values = tuple(int(round(c)) for c in new_pos_tensor.tolist())\n        new_pos = Point(*pos_values)\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _get_random_sample(self, goal_sample_rate: float) -> Point:\n        \"\"\"\n        With probability goal_sample_rate, return goal position,\n        otherwise return a valid random sample in the map.\n        \"\"\"\n        if np.random.rand() < goal_sample_rate:\n            pos_values = tuple(int(round(c)) for c in self._get_grid().goal.position.values)\n            return Point(*pos_values)\n\n        while True:\n            # Sample uniformly within grid size bounds\n            rand_coords = [\n                np.random.uniform(0, dim_size) for dim_size in self._get_grid().size.values\n            ]\n            rand_coords_int = [int(math.floor(c)) for c in rand_coords]\n            sample = Point(*rand_coords_int)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_vertices_within_radius(self, vertices: list, point: Point, radius: float) -> list:\n        result = []\n        for v in vertices:\n            if self._get_distance(v.position, point) < radius:\n                result.append(v)\n        return result\n\n    def _choose_best_parent(self, near_vertices: list, new_vertex: Vertex) -> Point or None:\n        \"\"\"\n        Select the best parent vertex to connect to the new_vertex by minimizing cost.\n        Returns None if no valid parent found.\n        \"\"\"\n        best_parent = None\n        best_cost = math.inf\n        line_cache = None\n\n        for vertex in near_vertices:\n            # Check if line from vertex to new_vertex is valid\n            line = self._get_grid().get_line_sequence(vertex.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n\n            cost = (vertex.cost if vertex.cost is not None else 0) + self._get_grid().get_movement_cost(vertex.position, new_vertex.position)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = vertex\n                line_cache = line\n\n        if best_parent is not None:\n            new_vertex.cost = best_cost\n            self._graph.add_edge(best_parent, new_vertex)\n        else:\n            # No valid parent - treat cost as infinity. We'll discard this vertex later.\n            new_vertex.cost = math.inf\n\n        return best_parent\n\n    def _rewire(self, near_vertices: list, new_vertex: Vertex) -> None:\n        \"\"\"\n        Rewire the vertices in near_vertices to connect optimally through new_vertex.\n        \"\"\"\n        for vertex in near_vertices:\n            if vertex == new_vertex:\n                continue\n\n            line = self._get_grid().get_line_sequence(new_vertex.position, vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line):\n                continue\n\n            new_cost = (new_vertex.cost if new_vertex.cost is not None else 0) + self._get_grid().get_movement_cost(new_vertex.position, vertex.position)\n            if vertex.cost is None or new_cost < vertex.cost:\n                # Remove old edge(s) to vertex\n                parents_to_remove = list(vertex.parents)\n                for p in parents_to_remove:\n                    self._graph.remove_edge(p, vertex)\n                # Add new edge from new_vertex\n                self._graph.add_edge(new_vertex, vertex)\n                vertex.cost = new_cost\n\n    def _extract_path(self, end_vertex: Vertex) -> None:\n        path: list = [end_vertex]\n\n        while len(path[-1].parents) != 0:\n            # Select parent with minimum cost\n            min_parent = None\n            min_cost = math.inf\n            for parent in path[-1].parents:\n                if parent.cost is not None and parent.cost < min_cost:\n                    min_cost = parent.cost\n                    min_parent = parent\n            if min_parent is None:\n                break\n            path.append(min_parent)\n\n        path.reverse()\n\n        # Animate path tracing from start to goal\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n\n    def _find_path_internal(self) -> None:\n        max_time_sec = 60.0\n        start_time = time.time()\n\n        grid = self._get_grid()\n        max_dist = max(5.0, min(grid.size.width, grid.size.height) * 0.1)  # 10% of smaller map dimension, minimum 5 units\n        iterations = 20000\n\n        # Initialize root start vertex cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for i in range(iterations):\n\n            elapsed = time.time() - start_time\n            if elapsed > max_time_sec:\n                # Fail gracefully if timeout exceeded\n                break\n\n            # Increase goal bias progressively after 30% iterations\n            goal_bias = 0.05 + 0.90 * min(i / (iterations * 0.7), 1.0)\n\n            q_sample = self._get_random_sample(goal_bias)\n\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Build line sequence between neighbor and new\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute cost and choose best parent from nearby vertices\n            all_vertices = self._graph.root_vertices + list(self._graph.root_vertex_start.children)  # broad list for rewire & parent selection\n            radius = max_dist * 2.5  # neighborhood radius for rewiring\n            near_vertices = self._get_vertices_within_radius(all_vertices, q_new.position, radius)\n\n            parent = self._choose_best_parent(near_vertices + [q_near], q_new)\n            if parent is None or q_new.cost == math.inf:\n                continue  # no valid parent, discard q_new\n\n            # Add new vertex to root vertices for search\n            self._graph.root_vertices.append(q_new)\n\n            # Rewire the tree for better paths\n            near_vertices_for_rewire = self._get_vertices_within_radius(all_vertices, q_new.position, radius)\n            self._rewire(near_vertices_for_rewire, q_new)\n\n            # Check if agent reached goal radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex for path extraction\n                goal_vertex = Vertex(grid.goal.position, store_connectivity=True)\n                goal_vertex.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_vertex.position)\n                self._graph.add_edge(q_new, goal_vertex)\n                self._extract_path(goal_vertex)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 192, in _find_path_internal\n  File \"<string>\", line 86, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m1",
     "algorithm": "An improved sample-based path planning algorithm combining advantages of RRT* and SPRM:\n    - Uses adaptive sampling biased towards unexplored and goal regions.\n    - Employs incremental connection radius adjustment for efficient graph construction.\n    - Uses a cyclic graph to allow multiple paths and rewiring for path smoothing.\n    - Utilizes a heuristic guided nearest neighbor selection to improve planning efficiency.\n    - Continuously checks for goal reachability and extracts path early.\n    - Limits search duration to 60 seconds for robustness against infinite loops.\n    - Post-processes the found path for smoothing using shortcutting heuristics.\n    - Aimed to improve path quality, reduce search time, increase success rate and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_vertices: int\n    _max_radius: float\n    _max_dist: float\n    _timeout_seconds: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_vertices = 500\n        self._max_radius = 20.0\n        self._max_dist = 10.0\n        self._timeout_seconds = 60.0\n        initial_agent_v = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        initial_agent_v.cost = 0.0\n        initial_goal_v = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        initial_goal_v.cost = float('inf')\n        vertices = [initial_agent_v]\n        # Start with initial vertex only; vertices will be added dynamically\n        self._graph = gen_cyclic_graph(self._services, initial_agent_v, initial_goal_v, vertices)\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\" Sample points mostly avoiding obstacles and biased toward goal region 10% \"\"\"\n        grid = self._get_grid()\n        size_vals = grid.size.values\n        goal_pos = grid.goal.position\n        # 10% samples directly on/near goal, 90% uniform random in map\n        if np.random.rand() < 0.1:\n            # Gaussian sampling near goal within radius 5, clipped inside map\n            goal_radius = 5\n            coords = []\n            for i, dim_len in enumerate(size_vals):\n                val = int(np.clip(\n                    np.random.normal(loc=goal_pos[i], scale=goal_radius), 0, dim_len - 1\n                ))\n                coords.append(val)\n            sample = Point(*coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n        # Uniform sampling in free space until valid\n        while True:\n            coords = [np.random.randint(0, dim_len) for dim_len in size_vals]\n            sample = Point(*coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _heuristic_nearest(self, candidates: List[Vertex], sample: Point) -> Optional[Vertex]:\n        \"\"\"Return nearest vertex to sample biased by cost + distance heuristic.\"\"\"\n        if not candidates:\n            return None\n        s_tensor = sample.to_tensor()\n        min_score = float('inf')\n        best_vertex = None\n        for v in candidates:\n            dist = torch.norm(v.position.to_tensor() - s_tensor).item()\n            score = v.cost + dist  # Combined cost-to-come + heuristic distance\n            if score < min_score:\n                min_score = score\n                best_vertex = v\n        return best_vertex\n\n    def _new_vertex_from_direction(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec).item()\n        if norm <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        dir_normalized = dir_vec / norm\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _vertices_within_radius(self, center: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, center, radius)\n\n    def _connect_vertices(self, v_from: Vertex, v_to: Vertex) -> bool:\n        \"\"\"Try connecting two vertices if path valid and update costs, return success.\"\"\"\n        grid = self._get_grid()\n        if v_from.position == v_to.position:\n            return False\n        line = grid.get_line_sequence(v_from.position, v_to.position)\n        if not grid.is_valid_line_sequence(line):\n            return False\n\n        dist = torch.norm(v_from.position.to_tensor() - v_to.position.to_tensor()).item()\n        new_cost = v_from.cost + dist\n\n        # Connect v_from -> v_to if better cost found or no parents (v_to.cost initialization might be inf)\n        if v_to.cost is None or new_cost < v_to.cost:\n            # Remove old edges to v_to\n            for parent in list(v_to.parents):\n                self._graph.remove_edge(parent, v_to)\n            # Add new edge\n            self._graph.add_edge(v_from, v_to)\n            # Update cost recursively downstream\n            self._update_descendants_cost(v_to)\n            return True\n        return False\n\n    def _update_descendants_cost(self, vertex: Vertex) -> None:\n        \"\"\"Recursively update costs of vertex descendants.\"\"\"\n        queue = [vertex]\n        while queue:\n            current = queue.pop()\n            for child in current.children:\n                dist = torch.norm(current.position.to_tensor() - child.position.to_tensor()).item()\n                updated_cost = current.cost + dist\n                if child.cost is None or updated_cost < child.cost:\n                    child.cost = updated_cost\n                    queue.append(child)\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        \"\"\"Extract best path from start to goal vertex and move agent along it.\"\"\"\n        # Backtrack parents to start\n        path_vertices = []\n        current = goal_vertex\n        while current.parents:\n            path_vertices.append(current)\n            # Choose parent with minimum cost\n            parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            current = parent\n            if current == self._graph.root_vertex_start:\n                path_vertices.append(current)\n                break\n        path_vertices.reverse()\n\n        # Post-process path smoothing by shortcutting\n        smoothed_path = self._shortcut_path(path_vertices)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path_vertices: List[Vertex]) -> List[Vertex]:\n        \"\"\"Shortcut path by checking direct connections between non-consecutive vertices.\"\"\"\n        if len(path_vertices) < 3:\n            return path_vertices\n        grid = self._get_grid()\n        smoothed_path = [path_vertices[0]]\n        idx = 0\n        while idx < len(path_vertices) - 1:\n            # Try to find farthest reachable vertex ahead (greedy shortcut)\n            far_idx = len(path_vertices) - 1\n            while far_idx > idx + 1:\n                line = grid.get_line_sequence(path_vertices[idx].position, path_vertices[far_idx].position)\n                if grid.is_valid_line_sequence(line):\n                    break\n                far_idx -= 1\n            smoothed_path.append(path_vertices[far_idx])\n            idx = far_idx\n        return smoothed_path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        goal_vertex = self._graph.root_vertex_goal\n        goal_reached = False\n\n        # Dynamic vertex list for graph growth\n        vertex_list = [start_vertex]\n        self._graph.root_vertices = vertex_list + [goal_vertex]\n\n        iteration = 0\n        while iteration < self._max_vertices:\n            iteration += 1\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout_seconds:\n                # FAIL path search due to timeout\n                return\n\n            q_sample = self._get_random_sample()\n            # Select nearest vertex biased by cost and heuristic\n            q_near = self._heuristic_nearest(vertex_list, q_sample)\n            if q_near is None or q_near.position == q_sample:\n                continue\n\n            q_new = self._new_vertex_from_direction(q_near, q_sample, self._max_dist)\n            # Check path from q_near to q_new\n            line = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line):\n                continue\n\n            # Prepare q_new cost estimate: tentative cost from q_near + dist\n            dist_near_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = q_near.cost + dist_near_new\n\n            # Find neighborhood radius adapting to n^(1/d) * some constant (RRT* inspired)\n            n = len(vertex_list) + 1\n            d = grid.size.n_dim\n            gamma = self._max_radius\n            radius = min(gamma * ((np.log(n) / n) ** (1/d)), self._max_radius)\n\n            neighbors = self._vertices_within_radius(q_new.position, radius)\n\n            # Choose best parent to minimize cost and ensure path validity\n            c_min = float('inf')\n            q_min = None\n            for neighbor in neighbors:\n                if neighbor.position == q_new.position:\n                    continue\n                line_n_new = grid.get_line_sequence(neighbor.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_n_new):\n                    continue\n                dist_n_new = torch.norm(neighbor.position.to_tensor() - q_new.position.to_tensor()).item()\n                cost = neighbor.cost + dist_n_new\n                if cost < c_min:\n                    c_min = cost\n                    q_min = neighbor\n\n            if q_min is None:\n                q_min = q_near\n                c_min = q_min.cost + dist_near_new\n\n            q_new.cost = c_min\n            # Add new vertex to graph and vertex list\n            vertex_list.append(q_new)\n            self._graph.root_vertices.insert(-1, q_new)  # Before goal vertex\n            self._graph.add_edge(q_min, q_new)\n\n            # Optimize connection of neighbors to q_new (rewiring)\n            for neighbor in neighbors:\n                if neighbor == q_min or neighbor == q_new:\n                    continue\n                dist_new_n = torch.norm(q_new.position.to_tensor() - neighbor.position.to_tensor()).item()\n                cost_through_new = q_new.cost + dist_new_n\n                if cost_through_new < neighbor.cost:\n                    line_new_n = grid.get_line_sequence(q_new.position, neighbor.position)\n                    if grid.is_valid_line_sequence(line_new_n):\n                        self._graph.remove_edge(next(iter(neighbor.parents)), neighbor)\n                        self._graph.add_edge(q_new, neighbor)\n                        neighbor.cost = cost_through_new\n                        self._update_descendants_cost(neighbor)\n\n            # Attempt connection to goal\n            line_to_goal = grid.get_line_sequence(q_new.position, goal_vertex.position)\n            dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_vertex.position.to_tensor()).item()\n            if grid.is_valid_line_sequence(line_to_goal):\n                cost_to_goal = q_new.cost + dist_to_goal\n                if cost_to_goal < goal_vertex.cost:\n                    # Connect q_new -> goal\n                    for p in list(goal_vertex.parents):\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_vertex.cost = cost_to_goal\n                    goal_reached = True\n\n            self.key_frame()\n\n            if goal_reached:\n                self._extract_path(goal_vertex)\n                return",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 213, in _find_path_internal\n  File \"<string>\", line 85, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an improved sample-based planner called \"Adaptive Informed RRT*\" \n    (A-Informed RRT*). It combines informed sampling within an ellipsoidal heuristic \n    sampling space to efficiently steer the search towards promising regions and uses \n    adaptive radius updates for rewiring, improving path quality and reducing search time. \n    The algorithm maintains a tree rooted at the start vertex and iteratively attempts to \n    connect towards random samples constrained inside an informed ellipse once an initial \n    feasible path is found. It performs rewiring in the neighborhood adaptively to improve \n    path cost and ensures robustness by validating edges along the proposed motion. \n    The search halts at success or after 60 seconds (treating any longer search as failure).",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_extend_dist = 12.0  # max edge length when extending tree\n        self._max_radius = 40.0  # max rewiring radius\n        self._min_radius = 5.0   # min rewiring radius\n        self._dimension = self._get_grid().size.n_dim\n        self._iteration_limit = 10000\n        self._goal_sample_rate = 0.1  # Probability to sample goal directly to bias search\n        self._init_displays()\n\n    def _get_distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _get_random_sample(self, c_best: Optional[float] = None) -> Point:\n        \"\"\"Informed sampling: if c_best is known, sample inside ellipsoidal region, else uniform.\"\"\"\n        if c_best is None or c_best == float(\"inf\"):\n            # Uniform sampling inside the map\n            grid_size = self._get_grid().size\n            while True:\n                sample_coords = [np.random.randint(0, grid_size[i]) for i in range(grid_size.n_dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Ellipsoidal informed sampling inside heuristic ellipse\n            start_pos = self._graph.root_vertex_start.position.to_tensor()\n            goal_pos = self._graph.root_vertex_goal.position.to_tensor()\n            c_min = self._get_distance(self._graph.root_vertex_start.position,\n                                       self._graph.root_vertex_goal.position)\n\n            # Define transformation to unit ball and back to ellipse in workspace\n            # Compute center and rotation\n            center = (start_pos + goal_pos) / 2\n            direction = (goal_pos - start_pos)\n            direction_norm = torch.norm(direction)\n            if direction_norm == 0:\n                # Start == goal, trivial\n                return self._graph.root_vertex_start.position\n\n            # Unit vector from start to goal\n            e1 = direction / direction_norm\n\n            # Build a rotation matrix to transform samples from unit ball to ellipse\n            def rotation_matrix_to_align_vector(vec: torch.Tensor):\n                # For 2D or 3D only\n                d = vec.shape[0]\n                if d == 2:\n                    theta = torch.atan2(vec[1], vec[0])\n                    c = torch.cos(theta)\n                    s = torch.sin(theta)\n                    R = torch.tensor([[c, -s], [s, c]], dtype=torch.float)\n                    return R\n                elif d == 3:\n                    # Use Rodrigues rotation formula to align x-axis to e1\n                    x_axis = torch.tensor([1.0, 0.0, 0.0])\n                    v = torch.cross(x_axis, vec)\n                    s = torch.norm(v)\n                    c = torch.dot(x_axis, vec)\n                    if s == 0:\n                        return torch.eye(3)\n                    vx = torch.tensor([[0, -v[2], v[1]],\n                                       [v[2], 0, -v[0]],\n                                       [-v[1], v[0], 0]])\n                    R = torch.eye(3) + vx + vx @ vx * ((1 - c) / (s ** 2))\n                    return R\n                else:\n                    # Higher dimensional not supported, fallback to uniform sampling\n                    return None\n\n            R = rotation_matrix_to_align_vector(e1)\n            if R is None:\n                return self._get_random_sample(None)\n\n            # Sampling inside unit n-ball\n            while True:\n                dir_sample = torch.randn(self._dimension)\n                r = torch.rand(1).pow(1 / self._dimension)\n                dir_sample = dir_sample / torch.norm(dir_sample) * r\n\n                # Scale samples according to ellipse radii using c_best and c_min\n                # Axis lengths of ellipse - major axis c_best/2, minor axes sqrt(c_best^2 - c_min^2)/2\n                a1 = c_best / 2\n                if c_best ** 2 - c_min ** 2 < 0:\n                    # numerical stability fallback\n                    r_minor = 0.0\n                else:\n                    r_minor = torch.sqrt(c_best ** 2 - c_min ** 2) / 2\n\n                r_minor = max(r_minor.item(), 0.001)\n                scale = torch.ones(self._dimension)\n                scale[0] = a1\n                if self._dimension > 1:\n                    scale[1:] = r_minor\n\n                local_sample = dir_sample * scale\n\n                # Rotate & translate back to world frame\n                world_sample = R @ local_sample + center\n                coords = [int(torch.clamp(world_sample[i], 0, self._get_grid().size[i] - 1).item())\n                          for i in range(self._dimension)]\n                sample = Point(*coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dir_norm\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n\n        return Vertex(q_new_pos)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Backtrack from q_new to root start\n        path = [q_new]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        c_best = float(\"inf\")\n        found_path = False\n\n        for i in range(self._iteration_limit):\n            if time.time() - start_time > 60:\n                # Time limit reached, fail search\n                return\n\n            # Bias sampling towards goal with probability goal_sample_rate\n            if np.random.rand() < self._goal_sample_rate:\n                q_sample = self._graph.root_vertex_goal.position\n            else:\n                q_sample = self._get_random_sample(c_best if found_path else None)\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_extend_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Cost to reach q_new via q_nearest\n            dist_near_to_new = self._get_distance(q_nearest.position, q_new.position)\n            q_new.cost = q_nearest.cost + dist_near_to_new\n\n            # Dynamic rewiring radius (shrinks as graph grows to approximate RRT* theoretical radius)\n            card_v = max(1, self._graph.size)\n            radius = min(self._max_radius,\n                         max(self._min_radius,\n                             50 * ((torch.log(torch.tensor(card_v, dtype=torch.float)) / card_v) ** (1 / self._dimension))))\n            \n            # Find neighbors for rewiring\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent from neighbors\n            q_min = q_nearest\n            c_min = q_new.cost\n            for q_near in neighbors:\n                if q_near == q_nearest:\n                    continue\n                line_seq_neighbor = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_neighbor):\n                    continue\n                cost_through_neighbor = q_near.cost + self._get_distance(q_near.position, q_new.position)\n                if cost_through_neighbor < c_min:\n                    q_min = q_near\n                    c_min = cost_through_neighbor\n            \n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if better\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n\n                line_seq_neighbor = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_neighbor):\n                    continue\n\n                new_cost = q_new.cost + self._get_distance(q_new.position, q_near.position)\n                if new_cost < q_near.cost:\n                    # Remove old edge and add new edge with q_new as parent\n                    old_parent = None\n                    for parent in q_near.parents:\n                        old_parent = parent\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if new vertex reached goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Attempt to connect q_new directly to goal vertex\n                goal_v = self._graph.root_vertex_goal\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    dist_to_goal = self._get_distance(q_new.position, goal_v.position)\n                    goal_v.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, goal_v)\n\n                    c_best = goal_v.cost\n                    found_path = True\n                    self._extract_path(goal_v)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 205, in _find_path_internal\n  File \"<string>\", line 166, in _get_new_vertex\nAttributeError: type object 'Point' has no attribute 'from_tensor'\n"
     }
}
{
     "operator": "m2",
     "algorithm": "Improved bidirectional RRT* inspired algorithm combining adaptive sampling,\n    informed radius rewiring, and goal biasing for faster convergence and better path quality.\n    Features:\n    - Bidirectional growth from start and goal for efficiency and robustness.\n    - Adaptive connection radius based on graph size and dimension for optimal rewiring.\n    - Goal biasing to guide sampling towards the goal region without sacrificing exploration.\n    - Max step size adaptively tuned to map size for smoother incremental expansion.\n    - Time limit (60s) to terminate early on failure.\n    - Post-path extraction smoothing by shortcutting feasible line segments to reduce path length.\n    This approach produces shorter, smoother paths, improves success rate in cluttered maps,\n    and balances exploration vs exploitation to reduce search time while maintaining robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: \"CyclicGraph\"\n    _max_dist: float\n    _iterations: int\n    _goal_sample_rate: float  # probability to sample goal to bias tree growth\n    _time_start: float\n    _time_limit: float = 60.0  # seconds\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        # Using a cyclic graph for flexible rewiring in both directions\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n\n        # Adaptive max step based on map diagonal length\n        diagonal = float(np.linalg.norm(np.array(self._get_grid().size.values)))\n        self._max_dist = max(5.0, diagonal * 0.05)  # 5 or 5% of diagonal\n\n        self._iterations = 12000\n        self._goal_sample_rate = 0.15  # 15% chance to sample goal directly\n\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # With goal biasing\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, roots: List[Vertex], q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(roots, q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_norm = dir_vec / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + dir_norm * max_dist)\n        return Vertex(new_pos)\n\n    def _get_vertices_within_radius(self, root_vertices: List[Vertex], q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(root_vertices, q_new.position, radius)\n\n    def _reconnect(self, q_new: Vertex, Q_near: List[Vertex], roots: List[Vertex]) -> None:\n        \"\"\"Rewire tree edges to improve path costs with collision check.\"\"\"\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n            cost_through_new = q_new.cost + dist\n            if cost_through_new >= q_near.cost:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Remove old edge\n            parent_to_remove = None\n            for p in q_near.parents:\n                parent_to_remove = p\n                break\n            if parent_to_remove is not None:\n                self._graph.remove_edge(parent_to_remove, q_near)\n\n            # Add new edge and update cost\n            q_near.cost = cost_through_new\n            self._graph.add_edge(q_new, q_near)\n\n            # Propagate cost changes downstream\n            self._propagate_cost(q_near, roots)\n\n    def _propagate_cost(self, vertex: Vertex, roots: List[Vertex]) -> None:\n        \"\"\"Update cost values recursively for descendants.\"\"\"\n        for child in vertex.children:\n            parent_cost = vertex.cost if vertex.cost is not None else float('inf')\n            dist = torch.norm(vertex.position.to_tensor() - child.position.to_tensor())\n            new_cost = parent_cost + dist\n            if child.cost is None or new_cost < child.cost:\n                child.cost = new_cost\n                self._propagate_cost(child, roots)\n\n    def _extract_path(self, q_meet: Vertex) -> None:\n        \"\"\"Extract path from start to goal through q_meet and then smooth it.\"\"\"\n        start_root = [self._graph.root_vertex_start]\n        goal_root = [self._graph.root_vertex_goal]\n\n        # Trace path start -> q_meet\n        path_start = []\n        v = q_meet\n        while True:\n            path_start.append(v)\n            if v in start_root:\n                break\n            if not v.parents:\n                break\n            # Pick parent with min cost (could be multiple parents)\n            v = min(v.parents, key=lambda x: x.cost if x.cost is not None else float('inf'))\n        path_start.reverse()\n\n        # Trace path q_meet -> goal\n        path_goal = []\n        v = q_meet\n        while True:\n            path_goal.append(v)\n            if v in goal_root:\n                break\n            if not v.children:\n                break\n            v = min(v.children, key=lambda x: x.cost if x.cost is not None else float('inf'))\n\n        full_path = path_start + path_goal[1:]\n\n        # Positions only\n        raw_points = [v.position for v in full_path]\n\n        # Smooth path by trying to shortcut segments directly if collision-free\n        smoothed_points = self._short_cut_path(raw_points)\n\n        for pos in smoothed_points:\n            self.move_agent(pos)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _short_cut_path(self, path_points: List[Point]) -> List[Point]:\n        \"\"\"Attempt to smooth path by shortcutting via valid direct lines.\"\"\"\n        if len(path_points) <= 2:\n            return path_points\n        smoothed = [path_points[0]]\n        i = 0\n        while i < len(path_points) - 1:\n            j = len(path_points) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path_points[i], path_points[j])\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed.append(path_points[j])\n            i = j\n        return smoothed\n\n    def _find_path_internal(self) -> None:\n        dimension = self._get_grid().size.n_dim\n        max_radius = max(self._get_grid().size.width, self._get_grid().size.height) * 0.2\n        lambda_rrt_star = 30.0\n\n        self._time_start = time.perf_counter()\n\n        # Roots for both trees\n        roots_start = [self._graph.root_vertex_start]\n        roots_goal = [self._graph.root_vertex_goal]\n\n        for i in range(self._iterations):\n\n            # Time limit check\n            if time.perf_counter() - self._time_start > self._time_limit:\n                # Failed due to timeout\n                break\n\n            # Alternate between growing start and goal trees\n            if i % 2 == 0:\n                tree_roots = roots_start\n                other_roots = roots_goal\n            else:\n                tree_roots = roots_goal\n                other_roots = roots_start\n\n            q_rand = self._get_random_sample()\n            q_near = self._get_nearest_vertex(tree_roots, q_rand)\n            if q_near.position == q_rand:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_rand, self._max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute adaptive radius\n            card_v = torch.tensor(float(self._graph.size))\n            if card_v <= 1:\n                radius = max_radius\n            else:\n                radius = min(lambda_rrt_star * ((torch.log(card_v) / card_v) ** (1 / dimension)), max_radius)\n\n            # Find neighbors within radius\n            Q_near = self._get_vertices_within_radius(tree_roots, q_new, radius)\n\n            # Choose parent with min cost + dist and valid path\n            q_min = q_near\n            c_min = (q_near.cost if q_near.cost is not None else float('inf')) + torch.norm(\n                q_near.position.to_tensor() - q_new.position.to_tensor())\n            for q_near_cand in Q_near:\n                dist_to_new = torch.norm(q_near_cand.position.to_tensor() - q_new.position.to_tensor())\n                cost_cand = (q_near_cand.cost if q_near_cand.cost is not None else float('inf')) + dist_to_new\n                if cost_cand < c_min:\n                    line_seq_cand = self._get_grid().get_line_sequence(q_near_cand.position, q_new.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq_cand):\n                        q_min = q_near_cand\n                        c_min = cost_cand\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors where cost can be improved via q_new\n            self._reconnect(q_new, Q_near, tree_roots)\n\n            # Try to connect the other tree to this new vertex\n            q_new_other_near = self._get_nearest_vertex(other_roots, q_new.position)\n            while True:\n                q_new_other = self._get_new_vertex(q_new_other_near, q_new.position, self._max_dist)\n                line_seq_other = self._get_grid().get_line_sequence(q_new_other_near.position, q_new_other.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_other):\n                    break\n                self._graph.add_edge(q_new_other_near, q_new_other)\n                q_new_other.cost = (q_new_other_near.cost if q_new_other_near.cost is not None else 0) + \\\n                                   torch.norm(q_new_other.position.to_tensor() - q_new_other_near.position.to_tensor())\n                if q_new_other.position == q_new.position:\n                    # Trees connected, path found\n                    self._extract_path(q_new)\n                    return\n                q_new_other_near = q_new_other\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 215, in _find_path_internal\n  File \"<string>\", line 75, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "e2",
     "algorithm": "Hybrid PathPlanning algorithm combining RRT-Connect bidirectional strategy with informed sampling and local rewiring \n    inspired by RRT* for improved path quality, robustness, and search efficiency.\n    Features:\n    - Bidirectional tree growth connecting start and goal for faster exploration.\n    - Informed sampling within an ellipse defined by start-goal distance and best cost to bias samples towards promising regions.\n    - Local rewiring (like RRT*) to improve path quality and smoothness dynamically.\n    - Early stopping if no improvement or goal reached.\n    - Timeout safeguard to fail if planning exceeds 60 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _best_goal_vertex: Optional[Vertex]\n    _start_vertex: Vertex\n    _goal_vertex: Vertex\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        # Start a forest with start and goal as roots\n        self._graph = Forest(self._start_vertex, self._goal_vertex, root_vertices=[])\n        self._graph.edges_removable = True\n        self._init_displays()\n        self._max_dist = 12.0\n        self._iterations = 12000\n        self._best_goal_vertex = None\n\n    def _get_random_sample(self, c_best: float = float(\"inf\")) -> Point:\n        \"\"\"\n        Perform informed sampling inside an ellipse between start and goal based on current best cost (c_best).\n        If no best cost known, sample uniformly.\n        \"\"\"\n        if np.isinf(c_best):\n            # No best path found yet. Uniform sampling.\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Informed Sampling ellipse parameters\n            start = self._start_vertex.position.to_tensor()\n            goal = self._goal_vertex.position.to_tensor()\n            c_min = torch.norm(goal - start).item()\n            if c_min == 0.0:\n                return Point(*start.tolist())\n\n            # ellipse parameters\n            center = (start + goal) / 2\n            a1 = (goal - start) / c_min  # unit vector from start to goal\n            dim = start.shape[0]\n\n            # Rotation matrix for ellipse aligned with a1 (only for 2D or 3D)\n            # We'll generate samples in unit ball, then transform to ellipse using rotation and scaling.\n            # Build orthogonal basis\n            def unit_vector(t):\n                return t / torch.norm(t)\n\n            basis = [a1]\n            if dim == 2:  # 2D case\n                b = torch.tensor([-a1[1], a1[0]])\n                basis.append(b)\n            elif dim >= 3:\n                # Gram-Schmidt to find orthonormal basis (dim-1 directions)\n                basis_vectors = [a1]\n                for i in range(1, dim):\n                    # Generate random vector and orthogonalize it w.r.t basis vectors\n                    v = torch.zeros(dim)\n                    v[i] = 1.0\n                    for bvec in basis_vectors:\n                        v -= torch.dot(v, bvec) * bvec\n                    v = unit_vector(v)\n                    basis_vectors.append(v)\n                basis = basis_vectors\n            else:\n                # fallback to uniform sampling if dim < 2 (unlikely)\n                while True:\n                    rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                    sample = Point(*rand_pos)\n                    if self._get_grid().is_agent_valid_pos(sample):\n                        return sample\n\n            C = torch.stack(basis, dim=1)  # rotation matrix\n\n            # sampling in unit n-ball\n            while True:\n                # sample from unit n-ball\n                direction = torch.randn(dim)\n                direction = direction / torch.norm(direction)\n                radius = np.random.rand() ** (1.0 / dim)  # uniform in volume\n                local_sample = radius * direction\n\n                # ellipse radius along main axis is c_best/2, perpendicular axes sqrt(c_best^2 - c_min^2)/2\n                if dim == 2:\n                    L = torch.diag(torch.tensor([c_best / 2.0, np.sqrt(c_best ** 2 - c_min ** 2) / 2.0]))\n                elif dim >= 3:\n                    perp_radius = np.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n                    diag_vals = [c_best / 2.0] + [perp_radius] * (dim - 1)\n                    L = torch.diag(torch.tensor(diag_vals))\n                else:\n                    L = torch.diag(torch.tensor([c_best / 2.0]))\n\n                sample_tensor = C @ (L @ local_sample) + center\n                # round sample to nearest int grid location\n                coords = torch.round(sample_tensor).int()\n                coords = coords.tolist()\n                if all(0 <= coords[i] < self._get_grid().size[i] for i in range(dim)):\n                    candidate = Point(*coords)\n                    if self._get_grid().is_agent_valid_pos(candidate):\n                        return candidate\n\n    def _steer(self, q_near: Vertex, q_target: Point) -> Vertex:\n        dir_vec = q_target.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= self._max_dist:\n            q_new_pt = q_target\n        else:\n            dir_unit = dir_vec / dist\n            new_pos_tensor = q_near.position.to_tensor() + dir_unit * self._max_dist\n            q_new_pt = Point.from_tensor(new_pos_tensor)\n        return Vertex(q_new_pt)\n\n    def _line_valid(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _get_nearest_vertex(self, vertices: List[Vertex], p: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(vertices, p)\n\n    def _get_near_vertices(self, vertices: List[Vertex], p: Point, radius: float) -> List[Vertex]:\n        # Return all vertices within radius of p from given vertices\n        return self._graph.get_vertices_within_radius(vertices, p, radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        # Choose best parent for q_new based on cost + movement cost and valid line\n        min_cost = float(\"inf\")\n        best_parent = None\n\n        for v in near_vertices:\n            cost_to_new = v.cost if v.cost is not None else 0\n            move_cost = self._get_grid().get_movement_cost(v.position, q_new.position)\n            c_total = cost_to_new + move_cost\n            if c_total < min_cost and self._line_valid(v.position, q_new.position):\n                min_cost = c_total\n                best_parent = v\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        # Attempt to improve costs of near vertices by connecting through q_new\n        c_new = q_new.cost if q_new.cost is not None else 0\n        for v in near_vertices:\n            if v == q_new:\n                continue\n            move_cost = self._get_grid().get_movement_cost(q_new.position, v.position)\n            new_cost = c_new + move_cost\n            if v.cost is None or new_cost < v.cost:\n                if self._line_valid(q_new.position, v.position):\n                    # Rewire edge: remove old parents, add q_new as parent\n                    # We assume one parent for simplification, else handle multi parents carefully\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = new_cost\n\n    def _build_path(self, goal_vertex: Vertex) -> List[Vertex]:\n        path = [goal_vertex]\n        current = goal_vertex\n        while current.parents:\n            # pick the parent with minimum cost if multiple\n            current = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            path.append(current)\n        path.reverse()\n        return path\n\n    def _extract_path_and_animate(self, goal_vertex: Vertex) -> None:\n        path = self._build_path(goal_vertex)\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _extend(self, root_vertex: Vertex, q_sample: Point) -> Tuple[str, Optional[Vertex]]:\n        q_near = self._get_nearest_vertex([root_vertex], q_sample)\n        q_new = self._steer(q_near, q_sample)\n        if not self._line_valid(q_near.position, q_new.position):\n            return 'trapped', None\n        # Find near vertices for rewiring radius (using radius from RRT* theory)\n        dimension = self._get_grid().size.n_dim\n        gamma_rrt_star = 30.0  # adjustable constant (usually set empirically)\n        radius = min(self._max_dist * 2.5, \n                     gamma_rrt_star * ((np.log(self._graph.size + 1) / (self._graph.size + 1)) ** (1/dimension)))\n        near_vertices = self._get_near_vertices([root_vertex] + self._graph.root_vertices, q_new.position, radius)\n\n        # Choose best parent among near vertices\n        best_parent = self._choose_parent(near_vertices, q_new)\n        if best_parent is None:\n            best_parent = q_near  # fallback\n        q_new.cost = (best_parent.cost if best_parent.cost is not None else 0) + \\\n            self._get_grid().get_movement_cost(best_parent.position, q_new.position)\n        self._graph.add_edge(best_parent, q_new)\n        self._rewire(near_vertices, q_new)\n\n        if q_new.position == q_sample:\n            return 'reached', q_new\n        else:\n            return 'advanced', q_new\n\n    def _connect(self, root_vertex: Vertex, q_target: Vertex) -> str:\n        status = 'advanced'\n        last_vertex = None\n        while status == 'advanced':\n            status, q_new = self._extend(root_vertex, q_target.position)\n            if q_new is not None:\n                last_vertex = q_new\n            else:\n                break\n            if status == 'reached':\n                break\n        return status\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        self._start_vertex.cost = 0\n        self._goal_vertex.cost = float(\"inf\")\n\n        # Keep root vertices list: start tree and goal tree\n        if self._graph.root_vertices == []:\n            self._graph.root_vertices = [self._start_vertex, self._goal_vertex]\n\n        # Bidirectional RRT* with informed sampling and rewiring\n        for _ in range(self._iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 60:\n                # Fail due to timeout\n                break\n\n            # Current best cost for informed sampling\n            c_best = self._best_goal_vertex.cost if self._best_goal_vertex is not None else float('inf')\n\n            # Sample point biased inside informed ellipse\n            q_rand = self._get_random_sample(c_best)\n\n            # Extend start tree towards q_rand\n            status_start, q_new_start = self._extend(self._graph.root_vertex_start, q_rand)\n            if status_start != 'trapped' and q_new_start is not None:\n                # Try connecting goal tree to q_new_start\n                status_goal = self._connect(self._graph.root_vertex_goal, q_new_start)\n                if status_goal == 'reached':\n                    # A connection made - update best path if shorter\n                    # Find connecting vertex between trees\n                    connecting_vertex_goal = self._graph.get_nearest_vertex([self._graph.root_vertex_goal], q_new_start.position)\n                    total_cost = q_new_start.cost if q_new_start.cost is not None else float('inf')\n                    if connecting_vertex_goal.cost is not None:\n                        total_cost += connecting_vertex_goal.cost + \\\n                                      self._get_grid().get_movement_cost(connecting_vertex_goal.position, q_new_start.position)\n                    if self._best_goal_vertex is None or total_cost < self._best_goal_vertex.cost:\n                        # Construct unified path: link q_new_start and connecting_vertex_goal\n                        self._graph.add_edge(q_new_start, connecting_vertex_goal)\n                        self._best_goal_vertex = connecting_vertex_goal\n                    # Extract and animate best path and finish\n                    if self._best_goal_vertex is not None:\n                        self._extract_path_and_animate(self._best_goal_vertex)\n                        break\n\n            # Swap roots for balanced growth\n            self._graph.reverse_root_vertices()\n\n            # Visual key frame/animation update\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 272, in _find_path_internal\n  File \"<string>\", line 69, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m1",
     "algorithm": "An improved sample-based path planning algorithm combining advantages of RRT* and SPRM:\n    - Uses adaptive sampling biased towards unexplored and goal regions.\n    - Employs incremental connection radius adjustment for efficient graph construction.\n    - Uses a cyclic graph to allow multiple paths and rewiring for path smoothing.\n    - Utilizes a heuristic guided nearest neighbor selection to improve planning efficiency.\n    - Continuously checks for goal reachability and extracts path early.\n    - Limits search duration to 60 seconds for robustness against infinite loops.\n    - Post-processes the found path for smoothing using shortcutting heuristics.\n    - Aimed to improve path quality, reduce search time, increase success rate and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_vertices: int\n    _max_radius: float\n    _max_dist: float\n    _timeout_seconds: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_vertices = 500\n        self._max_radius = 20.0\n        self._max_dist = 10.0\n        self._timeout_seconds = 60.0\n        initial_agent_v = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        initial_agent_v.cost = 0.0\n        initial_goal_v = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        initial_goal_v.cost = float('inf')\n        vertices = [initial_agent_v]\n        # Start with initial vertex only; vertices will be added dynamically\n        self._graph = gen_cyclic_graph(self._services, initial_agent_v, initial_goal_v, vertices)\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\" Sample points mostly avoiding obstacles and biased toward goal region 10% \"\"\"\n        grid = self._get_grid()\n        size_vals = grid.size.values\n        goal_pos = grid.goal.position\n        # 10% samples directly on/near goal, 90% uniform random in map\n        if np.random.rand() < 0.1:\n            # Gaussian sampling near goal within radius 5, clipped inside map\n            goal_radius = 5\n            coords = []\n            for i, dim_len in enumerate(size_vals):\n                val = int(np.clip(\n                    np.random.normal(loc=goal_pos[i], scale=goal_radius), 0, dim_len - 1\n                ))\n                coords.append(val)\n            sample = Point(*coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n        # Uniform sampling in free space until valid\n        while True:\n            coords = [np.random.randint(0, dim_len) for dim_len in size_vals]\n            sample = Point(*coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _heuristic_nearest(self, candidates: list[Vertex], sample: Point) -> Vertex | None:\n        \"\"\"Return nearest vertex to sample biased by cost + distance heuristic.\"\"\"\n        if not candidates:\n            return None\n        s_tensor = sample.to_tensor()\n        min_score = float('inf')\n        best_vertex = None\n        for v in candidates:\n            dist = torch.norm(v.position.to_tensor() - s_tensor).item()\n            score = v.cost + dist  # Combined cost-to-come + heuristic distance\n            if score < min_score:\n                min_score = score\n                best_vertex = v\n        return best_vertex\n\n    def _new_vertex_from_direction(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec).item()\n        if norm <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        dir_normalized = dir_vec / norm\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*[int(round(x)) for x in new_pos_tensor.tolist()])\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _vertices_within_radius(self, center: Point, radius: float) -> list[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, center, radius)\n\n    def _connect_vertices(self, v_from: Vertex, v_to: Vertex) -> bool:\n        \"\"\"Try connecting two vertices if path valid and update costs, return success.\"\"\"\n        grid = self._get_grid()\n        if v_from.position == v_to.position:\n            return False\n        line = grid.get_line_sequence(v_from.position, v_to.position)\n        if not grid.is_valid_line_sequence(line):\n            return False\n\n        dist = torch.norm(v_from.position.to_tensor() - v_to.position.to_tensor()).item()\n        new_cost = v_from.cost + dist\n\n        # Connect v_from -> v_to if better cost found or no parents (v_to.cost initialization might be inf)\n        if v_to.cost is None or new_cost < v_to.cost:\n            # Remove old edges to v_to\n            for parent in list(v_to.parents):\n                self._graph.remove_edge(parent, v_to)\n            # Add new edge\n            self._graph.add_edge(v_from, v_to)\n            # Update cost recursively downstream\n            self._update_descendants_cost(v_to)\n            return True\n        return False\n\n    def _update_descendants_cost(self, vertex: Vertex) -> None:\n        \"\"\"Recursively update costs of vertex descendants.\"\"\"\n        queue = [vertex]\n        while queue:\n            current = queue.pop()\n            for child in current.children:\n                dist = torch.norm(current.position.to_tensor() - child.position.to_tensor()).item()\n                updated_cost = current.cost + dist\n                if child.cost is None or updated_cost < child.cost:\n                    child.cost = updated_cost\n                    queue.append(child)\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        \"\"\"Extract best path from start to goal vertex and move agent along it.\"\"\"\n        # Backtrack parents to start\n        path_vertices = []\n        current = goal_vertex\n        while current.parents:\n            path_vertices.append(current)\n            # Choose parent with minimum cost\n            parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            current = parent\n            if current == self._graph.root_vertex_start:\n                path_vertices.append(current)\n                break\n        path_vertices.reverse()\n\n        # Post-process path smoothing by shortcutting\n        smoothed_path = self._shortcut_path(path_vertices)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path_vertices: list[Vertex]) -> list[Vertex]:\n        \"\"\"Shortcut path by checking direct connections between non-consecutive vertices.\"\"\"\n        if len(path_vertices) < 3:\n            return path_vertices\n        grid = self._get_grid()\n        smoothed_path = [path_vertices[0]]\n        idx = 0\n        while idx < len(path_vertices) - 1:\n            # Try to find farthest reachable vertex ahead (greedy shortcut)\n            far_idx = len(path_vertices) - 1\n            while far_idx > idx + 1:\n                line = grid.get_line_sequence(path_vertices[idx].position, path_vertices[far_idx].position)\n                if grid.is_valid_line_sequence(line):\n                    break\n                far_idx -= 1\n            smoothed_path.append(path_vertices[far_idx])\n            idx = far_idx\n        return smoothed_path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        goal_vertex = self._graph.root_vertex_goal\n        goal_reached = False\n\n        # Dynamic vertex list for graph growth\n        vertex_list = [start_vertex]\n        self._graph.root_vertices = vertex_list + [goal_vertex]\n\n        iteration = 0\n        while iteration < self._max_vertices:\n            iteration += 1\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout_seconds:\n                # FAIL path search due to timeout\n                return\n\n            q_sample = self._get_random_sample()\n            # Select nearest vertex biased by cost and heuristic\n            q_near = self._heuristic_nearest(vertex_list, q_sample)\n            if q_near is None or q_near.position == q_sample:\n                continue\n\n            q_new = self._new_vertex_from_direction(q_near, q_sample, self._max_dist)\n            # Check path from q_near to q_new\n            line = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line):\n                continue\n\n            # Prepare q_new cost estimate: tentative cost from q_near + dist\n            dist_near_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = q_near.cost + dist_near_new\n\n            # Find neighborhood radius adapting to n^(1/d) * some constant (RRT* inspired)\n            n = len(vertex_list) + 1\n            d = grid.size.n_dim\n            gamma = self._max_radius\n            radius = min(gamma * ((np.log(n) / n) ** (1/d)), self._max_radius)\n\n            neighbors = self._vertices_within_radius(q_new.position, radius)\n\n            # Choose best parent to minimize cost and ensure path validity\n            c_min = float('inf')\n            q_min = None\n            for neighbor in neighbors:\n                if neighbor.position == q_new.position:\n                    continue\n                line_n_new = grid.get_line_sequence(neighbor.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_n_new):\n                    continue\n                dist_n_new = torch.norm(neighbor.position.to_tensor() - q_new.position.to_tensor()).item()\n                cost = neighbor.cost + dist_n_new\n                if cost < c_min:\n                    c_min = cost\n                    q_min = neighbor\n\n            if q_min is None:\n                q_min = q_near\n                c_min = q_min.cost + dist_near_new\n\n            q_new.cost = c_min\n            # Add new vertex to graph and vertex list\n            vertex_list.append(q_new)\n            self._graph.root_vertices.insert(-1, q_new)  # Before goal vertex\n            self._graph.add_edge(q_min, q_new)\n\n            # Optimize connection of neighbors to q_new (rewiring)\n            for neighbor in neighbors:\n                if neighbor == q_min or neighbor == q_new:\n                    continue\n                dist_new_n = torch.norm(q_new.position.to_tensor() - neighbor.position.to_tensor()).item()\n                cost_through_new = q_new.cost + dist_new_n\n                if cost_through_new < neighbor.cost:\n                    line_new_n = grid.get_line_sequence(q_new.position, neighbor.position)\n                    if grid.is_valid_line_sequence(line_new_n):\n                        # Remove one parent edge to neighbor (assume only one parent)\n                        if neighbor.parents:\n                            self._graph.remove_edge(next(iter(neighbor.parents)), neighbor)\n                        self._graph.add_edge(q_new, neighbor)\n                        neighbor.cost = cost_through_new\n                        self._update_descendants_cost(neighbor)\n\n            # Attempt connection to goal\n            line_to_goal = grid.get_line_sequence(q_new.position, goal_vertex.position)\n            dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_vertex.position.to_tensor()).item()\n            if grid.is_valid_line_sequence(line_to_goal):\n                cost_to_goal = q_new.cost + dist_to_goal\n                if cost_to_goal < goal_vertex.cost:\n                    # Connect q_new -> goal\n                    for p in list(goal_vertex.parents):\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_vertex.cost = cost_to_goal\n                    goal_reached = True\n\n            self.key_frame()\n\n            if goal_reached:\n                self._extract_path(goal_vertex)\n                return",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 88, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "m3",
     "algorithm": "Improved sampling-based path planning algorithm that combines adaptive sampling \n    focusing near the goal with an anytime rewiring strategy inspired by RRT*.\n\n    Key features:\n    - Adaptive goal-bias sampling with dynamically adjusted radius to focus exploration efficiently.\n    - Anytime rewiring of the graph within a shrinking radius improving path quality progressively.\n    - Early pruning of costly connections based on incremental cost evaluation.\n    - Integration of time limit (60 sec) to abort search if no solution found.\n    - Uses cyclic graph structure enabling better edge manipulations and path smoothness.\n    - Balances exploration and exploitation dynamically based on iteration and search status.\n\n    The method aims for improved planning efficiency, path quality, robustness, and reduced search times.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: \"CyclicGraph\"\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n        start_v = Vertex(start_pos)\n        start_v.cost = 0\n        goal_v = Vertex(goal_pos)\n        self._graph = gen_cyclic_graph(self._services, start_v, goal_v, [])\n        self._init_displays()\n\n    def _get_random_sample(self, goal_bias=0.15, goal_sample_radius=15.0) -> Point:\n        \"\"\"Sample with bias: mostly uniform random, sometimes near goal within a radius.\"\"\"\n\n        grid = self._get_grid()\n        # Bias towards sampling near the goal position\n        if np.random.random() < goal_bias:\n            attempts = 0\n            while True:\n                # Sample in a circle around the goal (for 2D)\n                angle = np.random.uniform(0, 2 * np.pi)\n                radius = np.random.uniform(0, goal_sample_radius)\n                dx = radius * math.cos(angle)\n                dy = radius * math.sin(angle)\n                gp = grid.goal.position\n                candidate = Point(int(gp.x + dx), int(gp.y + dy))\n                attempts += 1\n                if grid.is_agent_valid_pos(candidate):\n                    return candidate\n                if attempts > 100:  # fallback to global random sampling\n                    break\n\n        # Uniform random sample in the entire map size\n        max_dims = grid.size.values\n        while True:\n            rand_pos = np.random.randint(0, max_dims, len(max_dims))\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_v: Vertex, to_p: Point, max_dist: float) -> Vertex:\n        \"\"\"Return a new vertex in the direction from from_v to to_p with max step length max_dist.\"\"\"\n        dir_vec = to_p.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(to_p)\n        dir_norm = dir_vec / dist\n        new_pos_tensor = from_v.position.to_tensor() + dir_norm * max_dist\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _get_nearest_vertex(self, point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, point)\n\n    def _get_nearby_vertices(self, vertex: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _cost(self, from_v: Vertex, to_v: Vertex) -> float:\n        return from_v.cost + self._get_grid().get_distance(from_v.position, to_v.position)\n\n    def _extract_path(self, last_vertex: Vertex) -> None:\n        # Goal vertex that references last vertex\n        goal_v = Vertex(self._get_grid().goal.position)\n        child_parent_dist = self._get_grid().get_distance(last_vertex.position, goal_v.position)\n        goal_v.cost = last_vertex.cost + child_parent_dist\n        self._graph.add_edge(last_vertex, goal_v)\n        path = [goal_v]\n\n        while path[-1].parents:\n            for p in path[-1].parents:\n                path.append(p)\n                break\n\n        path.pop()  # remove the root with no parents\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n\n        max_dist = 10.0\n        max_iter = 10000\n        dimension = grid.size.n_dim\n        max_time_sec = 60\n\n        start_time = time.time()\n\n        # Constants for radius calculation (RRT* inspired)\n        gamma_rrt_star = 50.0\n        goal_sample_radius = max(15.0, max_dist * 2)\n\n        # Initialize the start vertex cost (done in __init__)\n\n        for iter_count in range(max_iter):\n\n            if time.time() - start_time > max_time_sec:\n                # Treat search as failed after 60seconds\n                break\n\n            # Adaptive decreasing goal bias and radius for goal sampling\n            elapsed_ratio = iter_count / max_iter\n            goal_bias = max(0.1, 0.3 * (1.0 - elapsed_ratio))\n            adaptive_goal_radius = max(goal_sample_radius * (1.0 - elapsed_ratio), max_dist)\n\n            q_sample = self._get_random_sample(goal_bias=goal_bias, goal_sample_radius=adaptive_goal_radius)\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._steer(q_nearest, q_sample, max_dist)\n\n            # Check path between nearest and new is valid\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Radius for neighbors for rewiring, shrinking as tree grows\n            card_V = max(1, float(self._graph.size))\n            radius = min(\n                gamma_rrt_star * ((math.log(card_V) / card_V) ** (1 / dimension)),\n                max_dist * 3,\n            )\n\n            nearby_vertices = self._get_nearby_vertices(q_new, radius)\n\n            # Choose parent that minimizes cost and is collision free\n            q_min = q_nearest\n            c_min = self._cost(q_nearest, q_new)\n\n            for near_v in nearby_vertices:\n                # Edge collision check\n                if grid.is_valid_line_sequence(grid.get_line_sequence(near_v.position, q_new.position)):\n                    cost_through_near = self._cost(near_v, q_new)\n                    if cost_through_near < c_min:\n                        q_min = near_v\n                        c_min = cost_through_near\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if a cheaper path via q_new is found\n            for near_v in nearby_vertices:\n                if near_v == q_min:\n                    continue\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, near_v.position)):\n                    cost_via_new = q_new.cost + grid.get_distance(q_new.position, near_v.position)\n                    if near_v.cost is None or cost_via_new < near_v.cost:\n                        # Remove old parent edge (assumption: one parent per vertex in this graph)\n                        old_parent = None\n                        for p in near_v.parents:\n                            old_parent = p\n                            break\n                        if old_parent:\n                            self._graph.remove_edge(old_parent, near_v)\n                        near_v.cost = cost_via_new\n                        self._graph.add_edge(q_new, near_v)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 150, in _find_path_internal\n  File \"<string>\", line 70, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is a hybrid informed RRT* variant with adaptive sampling and smoothing.\n    It improves planning efficiency and path quality by guiding the search within an \n    ellipsoidal informed subset of the space (informed sampling), dynamically adjusting \n    the search radius based on vertex density, and applying iterative smoothing when \n    the goal is reached. It uses a best-first priority queue expansion to favor low-cost \n    vertices, combined with rewiring for optimality. A timeout of 60 seconds is enforced \n    with failure notification. This balances robustness, success rate, path smoothness, \n    search time, and path length improvements.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _max_radius: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_time_sec: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 12.0\n        self._max_radius = 30.0\n        self._lambda_rrt_star = 50.0\n        self._dimension = self._get_grid().size.n_dim\n        self._max_time_sec = 60.0  # maximum allowed time in seconds\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    def _get_random_sample_informed(self, c_best: Optional[float]) -> Point:\n        \"\"\"\n        Informed sampling inside an ellipsoid defined by start, goal, and current best cost.\n        If no path found yet (c_best is None), sample uniformly.\n        \"\"\"\n        agent_pos = self._get_grid().agent.position.to_tensor()\n        goal_pos = self._get_grid().goal.position.to_tensor()\n\n        if c_best is None:\n            # Uniform sampling until a valid sample is found\n            while True:\n                coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n                sample = Point(*coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Informed sampling inside ellipsoid\n            c_min = torch.norm(goal_pos - agent_pos)\n            if c_best < c_min:\n                # rare case, fall back to uniform sampling\n                return self._get_random_sample_uniform()\n\n            # Center of ellipse\n            center = (agent_pos + goal_pos) / 2.0\n            a1 = (goal_pos - agent_pos) / c_min  # unit vector from start to goal\n\n            # Create orthonormal basis via SVD\n            U, _, _ = torch.svd(torch.eye(self._dimension) - a1.unsqueeze(1) @ a1.unsqueeze(0), some=True)\n            C = torch.cat([a1.unsqueeze(1), U[:, 1:].contiguous()], dim=1)\n\n            # Radius in each dimension\n            r1 = c_best / 2.0\n            r2 = torch.sqrt(c_best**2 - c_min**2) / 2.0\n\n            radii = torch.ones(self._dimension)\n            radii[0] = r1\n            radii[1:] = r2\n\n            for _ in range(1000):  # max attempts for valid sample\n                # Sample inside unit ball\n                direction = torch.randn(self._dimension)\n                direction /= torch.norm(direction)\n                radius = torch.rand(1).item() ** (1 / self._dimension)\n                rnd_ball = direction * radius\n\n                # Transform to ellipsoid space\n                sample_tensor = center + (C @ (radii * rnd_ball))\n\n                sample_point = Point(*[int(torch.clamp(x, 0, self._get_grid().size[i] - 1).item()) for i, x in enumerate(sample_tensor)])\n                if self._get_grid().is_agent_valid_pos(sample_point):\n                    return sample_point\n\n            # fallback uniform sample if fails\n            return self._get_random_sample_uniform()\n\n    def _get_random_sample_uniform(self) -> Point:\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        dir_vector = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vector)\n        if dist == 0:\n            return None  # Same position\n\n        if dist <= max_dist:\n            p = q_sample\n        else:\n            dir_norm = dir_vector / dist\n            new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_norm\n            coords = [int(torch.clamp(c, 0, self._get_grid().size[i] - 1).item()) for i, c in enumerate(new_pos_tensor)]\n            p = Point(*coords)\n\n        if not self._get_grid().is_agent_valid_pos(p):\n            return None\n\n        # Check path collision between q_near and p\n        line_seq = self._get_grid().get_line_sequence(q_near.position, p)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        return Vertex(p)\n\n    def _extract_path(self, last_vertex: Vertex):\n        # Reconstruct path from last_vertex to root\n        path = [last_vertex]\n        current = last_vertex\n        while current != self._graph.root_vertex_start and current.parents:\n            # Choose parent with lowest cost\n            current = min(current.parents, key=lambda v: v.cost if v.cost is not None else float('inf'))\n            path.append(current)\n        path.reverse()\n\n        # Smoothed path by shortcutting\n        smooth_path = self._short_cut_path(path)\n\n        for vertex in smooth_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _short_cut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Attempt to shortcut path segments to improve smoothness.\n        \"\"\"\n        if len(path) <= 2:\n            return path\n\n        new_path = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path\n\n    def _rewire(self, q_new: Vertex, Q_near: List[Vertex]) -> None:\n        for q_near in Q_near:\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cost_through_new = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            if q_near.cost is None or cost_through_new < q_near.cost:\n                # Remove old parent edge\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                # Add new parent edge\n                q_near.cost = cost_through_new\n                self._graph.add_edge(q_new, q_near)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        c_best = None  # best path cost found so far\n        best_last_vertex = None\n\n        priority_queue: List[Tuple[float, Vertex]] = []\n        heapq.heappush(priority_queue, (self._graph.root_vertex_start.cost, self._graph.root_vertex_start))\n\n        max_iterations = 15000\n        while time.time() - start_time < self._max_time_sec and max_iterations > 0:\n\n            max_iterations -= 1\n\n            # Sample informed or uniform depending on whether a path was found\n            q_sample = self._get_random_sample_informed(c_best)\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            if q_new is None:\n                continue\n\n            # Find neighbors within a radius adaptively\n            card_v = torch.tensor(float(self._graph.size + 1))\n            log_card = torch.log(card_v)\n            radius = min(self._lambda_rrt_star * torch.pow(log_card / card_v, 1 / self._dimension), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent that minimizes cost to q_new\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost_through_near = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if cost_through_near < c_min:\n                    q_min = q_near\n                    c_min = cost_through_near\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if it reduces cost\n            self._rewire(q_new, Q_near)\n\n            # Add q_new to priority queue for best-first expansion\n            heapq.heappush(priority_queue, (q_new.cost, q_new))\n\n            # Check goal proximity\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = torch.norm(q_new.position.to_tensor() - self._get_grid().goal.position.to_tensor())\n                total_cost = q_new.cost + dist_to_goal\n                if c_best is None or total_cost < c_best:\n                    # Update best solution\n                    c_best = total_cost\n                    best_last_vertex = q_new\n\n            self.key_frame()\n\n        if best_last_vertex is not None:\n            self._extract_path(best_last_vertex)\n        else:\n            # No path found within time limit\n            # Optionally mark failure or halt gracefully here\n            # We do not move the agent\n            return",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 215, in _find_path_internal\nNameError: name 'heapq' is not defined\n"
     }
}
{
     "operator": "e2",
     "algorithm": "Hybrid Path Planning Algorithm combining RRT-Connect with Informed RRT* optimization and adaptive rewiring for improved path quality,\n    efficiency, and smoothness. The algorithm grows two trees from start and goal sampling biased regions, attempts to connect them efficiently,\n    and rewires vertices within dynamic radius. It uses adaptive sampling within elliptical informed subsets to reduce search space once initial path found,\n    incorporates collision checking with Bresenham's line, and terminates if no solution is found within 60 seconds to enhance robustness and reduce search time.\n    The extracted path is smoothed further for path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_dist: float\n    _iterations: int\n    _rewire_radius_const: float\n\n    def __init__(self, services: \"Services\", testing: \"BasicTesting\" = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._max_dist = 15.0\n        self._iterations = 15000\n        # Rewiring radius factor (heuristic)\n        self._rewire_radius_const = 50.0\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_random_sample(self, informed_subset: Optional[Tuple[Point, float, float]] = None) -> Point:\n        \"\"\"\n        Returns a random sample Point in the environment.\n        When informed_subset is given (center, c_best, c_min), sample inside an ellipse for focused search.\n        Else uniform random sampling within map boundaries.\n        \"\"\"\n        size = self._get_grid().size\n\n        def to_int_point(p: Point) -> Point:\n            # Convert Point with potential floats into Point with int coordinates\n            # This resolves the error with float positions in dense_map lookup\n            int_coords = tuple(int(round(coord)) for coord in p.values())\n            return Point(*int_coords)\n\n        if informed_subset is None:\n            # Uniform random valid sample\n            for _ in range(100):\n                rand_pos = np.random.uniform(low=0, high=[size.width, size.height], size=(size.n_dim,))\n                sample = Point(*rand_pos)\n                sample_int = to_int_point(sample)\n                if self._get_grid().is_agent_valid_pos(sample_int):\n                    return sample_int\n            # fallback uniform discrete\n            while True:\n                rand_pos = np.random.randint(0, size.values, size=size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            center, c_best, c_min = informed_subset\n            # Sampling inside ellipse in 2D only - ellipse parameters and rotation matrix aligned along start-goal line\n            start = self._graph.root_vertex_start.position.to_tensor()\n            goal = self._graph.root_vertex_goal.position.to_tensor()\n            dim = size.n_dim\n            if dim < 2:\n                # fallback uniform\n                return self._get_random_sample(None)\n\n            # Create a coordinate system aligned with the vector from start to goal\n            diff = goal - start\n            dist = torch.norm(diff).item()\n            if dist == 0:\n                dist = 1e-6\n\n            a1 = diff / dist  # unit vector along major axis\n\n            # Generate random sample inside unit ball in 2D\n            while True:\n                # Sample uniformly in unit circle with rejection sampling\n                sample_in_unit_circle = np.random.uniform(-1, 1, 2)\n                if sample_in_unit_circle[0]**2 + sample_in_unit_circle[1]**2 <= 1:\n                    break\n            u1, u2 = sample_in_unit_circle\n\n            # Lengths of ellipse axes\n            r1 = c_best / 2.0  # Major axis radius\n            r2 = math.sqrt(c_best**2 - c_min**2) / 2.0  # Minor axis radius\n\n            # Rotate sample to global coordinates\n            # The ellipse is aligned such that major axis aligns with a1 (along start-goal)\n            # Build orthonormal basis [a1, a2]\n            a2 = torch.zeros(dim)\n            # Generate an arbitrary vector orthogonal to a1 in 2D\n            if dim == 2:\n                a2[0] = -a1[1]\n                a2[1] = a1[0]\n            else:  # For 3D+, approximation (not very accurate but better than nothing)\n                a2[0] = -a1[1]\n                a2[1] = a1[0]\n                if dim > 2:\n                    a2[2:] = 0\n\n            sample_vec = r1 * u1 * a1 + r2 * u2 * a2\n            sample_point_tensor = center.to_tensor() + sample_vec\n\n            sample_point = Point(*sample_point_tensor.tolist())\n\n            # Clamp sample inside map bounds and check validity\n            clamped_coords = []\n            for idx, coord in enumerate(sample_point.values()):\n                val = max(0, min(coord, size.values[idx] - 1))\n                clamped_coords.append(val)\n            sample_point = Point(*clamped_coords)\n\n            sample_int = to_int_point(sample_point)\n\n            # Validate and fallback if invalid\n            if self._get_grid().is_agent_valid_pos(sample_int):\n                return sample_int\n\n            # If failed, fallback to uniform sample\n            return self._get_random_sample(None)\n\n    def _get_nearest_vertex(self, root_vertices: List[Vertex], point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(root_vertices, point)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            # ensure position has integer coordinates for dense_map compatibility\n            p_int = Point(*[int(round(c)) for c in q_sample.values()])\n            return Vertex(p_int, store_connectivity=True)\n\n        dir_normalized = dir / norm_dir\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        # Convert to integer Point\n        p_int = Point(*[int(round(c.item())) for c in new_pos_tensor])\n        return Vertex(p_int, store_connectivity=True)\n\n    def _get_vertices_within_radius(self, root_vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(root_vertices, point, radius)\n\n    def _calculate_rewire_radius(self) -> float:\n        # Calculate rewiring radius as heuristic based on environment size and nodes count\n        size = self._get_grid().size\n        n = max(1, self._graph.size)\n        volume = size.width * size.height  # approx for 2D\n        r = min(self._max_dist, self._rewire_radius_const * math.sqrt((math.log(n) / n)))\n        r = max(r, 5.0)\n        return r\n\n    def _collision_free(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _cost(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        return self._get_grid().get_distance(from_vertex.position, to_vertex.position)\n\n    def _choose_parent(self, new_vertex: Vertex, neighbors: List[Vertex]) -> Optional[Vertex]:\n        # Choose best parent in terms of cost + cost-to-new_vertex\n        min_cost = math.inf\n        best_parent = None\n        for neighbor in neighbors:\n            if self._collision_free(neighbor.position, new_vertex.position):\n                tentative_cost = neighbor.cost if neighbor.cost is not None else 0\n                tentative_cost += self._cost(neighbor, new_vertex)\n                if tentative_cost < min_cost:\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n        if best_parent:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, neighbors: List[Vertex]) -> None:\n        new_cost = new_vertex.cost if new_vertex.cost is not None else 0\n        for neighbor in neighbors:\n            if neighbor is new_vertex:\n                continue\n            if self._collision_free(new_vertex.position, neighbor.position):\n                cost_through_new = new_cost + self._cost(new_vertex, neighbor)\n                if neighbor.cost is None or cost_through_new < neighbor.cost:\n                    # Rewire: remove old parent edges, add new edge\n                    # Remove previous parent edges\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(new_vertex, neighbor)\n                    neighbor.cost = cost_through_new\n\n    def _extract_path(self, connecting_vertex: Vertex) -> None:\n        # Trace back path from connecting_vertex to start and to goal\n        path_start = []\n        v = connecting_vertex\n        while v is not None:\n            path_start.append(v)\n            if len(v.parents) == 0:\n                break\n            v = next(iter(v.parents))  # one parent (tree structure)\n\n        path_goal = []\n        # goal root vertex\n        goal_vertex = self._graph.root_vertex_goal\n        # We find path from connecting_vertex to goal by DFS or backwards\n        # Walk from goal root downwards to connecting_vertex:\n        # As graph is cyclic, to find goal path we do upwards from goal root\n        # Instead traverse parents from goal root to connecting_vertex via children recursively\n\n        # We find the path from goal to connecting_vertex backwards (via DFS)\n        # Because in cyclic graph children and parents exist, but we enforce edges start->child as direction\n\n        def dfs_find_path(current: Vertex, target: Vertex, visited: Set[Vertex]) -> Optional[List[Vertex]]:\n            if current == target:\n                return [current]\n            visited.add(current)\n            for child in current.children:\n                if child in visited:\n                    continue\n                sub_path = dfs_find_path(child, target, visited)\n                if sub_path:\n                    return [current] + sub_path\n            return None\n\n        path_goal = dfs_find_path(goal_vertex, connecting_vertex, set()) or []\n\n        # Combine paths (path_start reversed is from start to connecting_vertex)\n        path_start.reverse()\n        if len(path_goal) > 0 and path_goal[0] == connecting_vertex:\n            path_goal = path_goal[1:]  # avoid duplicate vertex\n\n        full_path = path_start + path_goal\n\n        # Smooth the path to improve quality\n        smooth_path = self._smooth_path([v.position for v in full_path])\n\n        for pos in smooth_path:\n            self.move_agent(pos)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _smooth_path(self, path_points: List[Point]) -> List[Point]:\n        # Simple path smoothing by shortcutting over unnecessary vertices if collision free\n        if len(path_points) < 3:\n            return path_points\n\n        smooth_path = [path_points[0]]\n        i = 0\n        while i < len(path_points) - 1:\n            j = len(path_points) - 1\n            while j > i + 1:\n                if self._collision_free(path_points[i], path_points[j]):\n                    smooth_path.append(path_points[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # no shortcut found, advance by one\n                smooth_path.append(path_points[i + 1])\n                i += 1\n        return smooth_path\n\n    # Main Algorithm Loop #\n    # --------------------#\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        # Initialization\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        trees = [start_vertex, goal_vertex]  # root vertices for two trees\n        # Two vertex sets for easy access\n        start_tree_vertices = [start_vertex]\n        goal_tree_vertices = [goal_vertex]\n\n        path_found = False\n        best_path_cost = math.inf\n        best_connecting_vertex = None\n\n        # Constants\n        c_min = self._get_grid().get_distance(start_vertex.position, goal_vertex.position)\n        c_best = math.inf\n\n        for iter_idx in range(self._iterations):\n\n            if time.time() - start_time > 60:  # timeout 60 seconds\n                # Fail gracefully\n                break\n\n            # Determine if informed sampling is possible (after path found)\n            informed_subset = None\n            if path_found and best_connecting_vertex is not None and best_path_cost < math.inf:\n                center_raw = np.array(start_vertex.position.values()) + np.array(goal_vertex.position.values())\n                center = Point(*((center_raw / 2).tolist()))\n                informed_subset = (center, best_path_cost, c_min)\n\n            # Sample randomly using informed sampling if available\n            q_rand = self._get_random_sample(informed_subset)\n\n            # Alternate tree to extend: 0 or 1\n            tree_idx = iter_idx % 2\n            curr_tree_root = trees[tree_idx]\n            other_tree_root = trees[1 - tree_idx]\n\n            # Extend current tree towards q_rand\n            q_near = self._get_nearest_vertex([curr_tree_root], q_rand)\n            q_new = self._get_new_vertex(q_near, q_rand, self._max_dist)\n\n            # Check collision along edge q_near->q_new\n            if not self._collision_free(q_near.position, q_new.position):\n                self.key_frame()\n                continue\n\n            # Get neighbors for rewiring (both trees)\n            neighbors_radius = self._calculate_rewire_radius()\n            neighbors = self._get_vertices_within_radius([curr_tree_root], q_new.position, neighbors_radius)\n\n            # Choose parent among neighbors\n            best_parent = self._choose_parent(q_new, neighbors)\n            if best_parent is None:\n                # No valid parent found, discard q_new\n                self.key_frame()\n                continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors for better path\n            self._rewire(q_new, neighbors)\n\n            # Add q_new to proper tree vertices list\n            if tree_idx == 0:\n                start_tree_vertices.append(q_new)\n            else:\n                goal_tree_vertices.append(q_new)\n\n            # Try to connect other_tree to q_new by extending towards it\n            q_near_other = self._get_nearest_vertex([other_tree_root], q_new.position)\n            q_new_other = self._get_new_vertex(q_near_other, q_new.position, self._max_dist)\n\n            if self._collision_free(q_near_other.position, q_new_other.position):\n                self._graph.add_edge(q_near_other, q_new_other)\n\n                # Check if connection possible between q_new and q_new_other\n                if self._collision_free(q_new.position, q_new_other.position):\n                    # Connect q_new with q_new_other and form path\n                    self._graph.add_edge(q_new, q_new_other)\n\n                    # Compute path cost for potential solution\n                    total_cost = (q_new.cost if q_new.cost else 0) + \\\n                                 self._get_grid().get_distance(q_new.position, q_new_other.position) + \\\n                                 (q_new_other.cost if q_new_other.cost else 0)\n\n                    if total_cost < best_path_cost:\n                        best_path_cost = total_cost\n                        best_connecting_vertex = q_new\n\n                    path_found = True\n                    # Once connected, break early: extract path\n                    self._extract_path(best_connecting_vertex)\n                    break\n\n            self.key_frame()\n\n        if not path_found:\n            # Mark failure as required (no path found)\n            # If desired, could raise an exception or signal failure here.\n            return",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 331, in _find_path_internal\n  File \"<string>\", line 82, in _get_random_sample\n  File \"<string>\", line 74, in to_int_point\nAttributeError: 'Point' object has no attribute 'values'\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an improved sample-based planner called \"Adaptive Informed RRT*\" \n    (A-Informed RRT*). It combines informed sampling within an ellipsoidal heuristic \n    sampling space to efficiently steer the search towards promising regions and uses \n    adaptive radius updates for rewiring, improving path quality and reducing search time. \n    The algorithm maintains a tree rooted at the start vertex and iteratively attempts to \n    connect towards random samples constrained inside an informed ellipse once an initial \n    feasible path is found. It performs rewiring in the neighborhood adaptively to improve \n    path cost and ensures robustness by validating edges along the proposed motion. \n    The search halts at success or after 60 seconds (treating any longer search as failure).",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_extend_dist = 12.0  # max edge length when extending tree\n        self._max_radius = 40.0  # max rewiring radius\n        self._min_radius = 5.0   # min rewiring radius\n        self._dimension = self._get_grid().size.n_dim\n        self._iteration_limit = 10000\n        self._goal_sample_rate = 0.1  # Probability to sample goal directly to bias search\n        self._init_displays()\n\n    def _get_distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _get_random_sample(self, c_best: Optional[float] = None) -> Point:\n        \"\"\"Informed sampling: if c_best is known, sample inside ellipsoidal region, else uniform.\"\"\"\n        if c_best is None or c_best == float(\"inf\"):\n            # Uniform sampling inside the map\n            grid_size = self._get_grid().size\n            while True:\n                sample_coords = [np.random.randint(0, grid_size[i]) for i in range(grid_size.n_dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Ellipsoidal informed sampling inside heuristic ellipse\n            start_pos = self._graph.root_vertex_start.position.to_tensor()\n            goal_pos = self._graph.root_vertex_goal.position.to_tensor()\n            c_min = self._get_distance(self._graph.root_vertex_start.position,\n                                       self._graph.root_vertex_goal.position)\n\n            # Define transformation to unit ball and back to ellipse in workspace\n            # Compute center and rotation\n            center = (start_pos + goal_pos) / 2\n            direction = (goal_pos - start_pos)\n            direction_norm = torch.norm(direction)\n            if direction_norm == 0:\n                # Start == goal, trivial\n                return self._graph.root_vertex_start.position\n\n            # Unit vector from start to goal\n            e1 = direction / direction_norm\n\n            # Build a rotation matrix to transform samples from unit ball to ellipse\n            def rotation_matrix_to_align_vector(vec: torch.Tensor):\n                # For 2D or 3D only\n                d = vec.shape[0]\n                if d == 2:\n                    theta = torch.atan2(vec[1], vec[0])\n                    c = torch.cos(theta)\n                    s = torch.sin(theta)\n                    R = torch.tensor([[c, -s], [s, c]], dtype=torch.float)\n                    return R\n                elif d == 3:\n                    # Use Rodrigues rotation formula to align x-axis to e1\n                    x_axis = torch.tensor([1.0, 0.0, 0.0])\n                    v = torch.cross(x_axis, vec)\n                    s = torch.norm(v)\n                    c = torch.dot(x_axis, vec)\n                    if s == 0:\n                        return torch.eye(3)\n                    vx = torch.tensor([[0, -v[2], v[1]],\n                                       [v[2], 0, -v[0]],\n                                       [-v[1], v[0], 0]])\n                    R = torch.eye(3) + vx + vx @ vx * ((1 - c) / (s ** 2))\n                    return R\n                else:\n                    # Higher dimensional not supported, fallback to uniform sampling\n                    return None\n\n            R = rotation_matrix_to_align_vector(e1)\n            if R is None:\n                return self._get_random_sample(None)\n\n            # Sampling inside unit n-ball\n            while True:\n                dir_sample = torch.randn(self._dimension)\n                r = torch.rand(1).pow(1 / self._dimension)\n                dir_sample = dir_sample / torch.norm(dir_sample) * r\n\n                # Scale samples according to ellipse radii using c_best and c_min\n                # Axis lengths of ellipse - major axis c_best/2, minor axes sqrt(c_best^2 - c_min^2)/2\n                a1 = c_best / 2\n                if c_best ** 2 - c_min ** 2 < 0:\n                    # numerical stability fallback\n                    r_minor = 0.0\n                else:\n                    r_minor = torch.sqrt(c_best ** 2 - c_min ** 2) / 2\n\n                r_minor = max(r_minor.item(), 0.001)\n                scale = torch.ones(self._dimension)\n                scale[0] = a1\n                if self._dimension > 1:\n                    scale[1:] = r_minor\n\n                local_sample = dir_sample * scale\n\n                # Rotate & translate back to world frame\n                world_sample = R @ local_sample + center\n                coords = [int(torch.clamp(world_sample[i], 0, self._get_grid().size[i] - 1).item())\n                          for i in range(self._dimension)]\n                sample = Point(*coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dir_norm\n        # Instead of Point.from_tensor (which doesn't exist), create using Point(...) with tuple\n        new_coords = (q_near.position.to_tensor() + max_dist * dir_normalized).tolist()\n        coords_int = [int(coord) for coord in new_coords]\n        q_new_pos = Point(*coords_int)\n\n        return Vertex(q_new_pos)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Backtrack from q_new to root start\n        path = [q_new]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        c_best = float(\"inf\")\n        found_path = False\n\n        for i in range(self._iteration_limit):\n            if time.time() - start_time > 60:\n                # Time limit reached, fail search\n                return\n\n            # Bias sampling towards goal with probability goal_sample_rate\n            if np.random.rand() < self._goal_sample_rate:\n                q_sample = self._graph.root_vertex_goal.position\n            else:\n                q_sample = self._get_random_sample(c_best if found_path else None)\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_extend_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Cost to reach q_new via q_nearest\n            dist_near_to_new = self._get_distance(q_nearest.position, q_new.position)\n            q_new.cost = q_nearest.cost + dist_near_to_new\n\n            # Dynamic rewiring radius (shrinks as graph grows to approximate RRT* theoretical radius)\n            card_v = max(1, self._graph.size)\n            radius = min(self._max_radius,\n                         max(self._min_radius,\n                             50 * ((torch.log(torch.tensor(card_v, dtype=torch.float)) / card_v) ** (1 / self._dimension))))\n            \n            # Find neighbors for rewiring\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent from neighbors\n            q_min = q_nearest\n            c_min = q_new.cost\n            for q_near in neighbors:\n                if q_near == q_nearest:\n                    continue\n                line_seq_neighbor = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_neighbor):\n                    continue\n                cost_through_neighbor = q_near.cost + self._get_distance(q_near.position, q_new.position)\n                if cost_through_neighbor < c_min:\n                    q_min = q_near\n                    c_min = cost_through_neighbor\n            \n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if better\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n\n                line_seq_neighbor = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_neighbor):\n                    continue\n\n                new_cost = q_new.cost + self._get_distance(q_new.position, q_near.position)\n                if new_cost < q_near.cost:\n                    # Remove old edge and add new edge with q_new as parent\n                    old_parent = None\n                    for parent in q_near.parents:\n                        old_parent = parent\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if new vertex reached goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Attempt to connect q_new directly to goal vertex\n                goal_v = self._graph.root_vertex_goal\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    dist_to_goal = self._get_distance(q_new.position, goal_v.position)\n                    goal_v.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, goal_v)\n\n                    c_best = goal_v.cost\n                    found_path = True\n                    self._extract_path(goal_v)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 201, in _find_path_internal\n  File \"<string>\", line 70, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m1",
     "algorithm": "An improved sample-based path planning algorithm combining advantages of RRT* and SPRM:\n    - Uses adaptive sampling biased towards unexplored and goal regions.\n    - Employs incremental connection radius adjustment for efficient graph construction.\n    - Uses a cyclic graph to allow multiple paths and rewiring for path smoothing.\n    - Utilizes a heuristic guided nearest neighbor selection to improve planning efficiency.\n    - Continuously checks for goal reachability and extracts path early.\n    - Limits search duration to 60 seconds for robustness against infinite loops.\n    - Post-processes the found path for smoothing using shortcutting heuristics.\n    - Aimed to improve path quality, reduce search time, increase success rate and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_vertices: int\n    _max_radius: float\n    _max_dist: float\n    _timeout_seconds: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_vertices = 500\n        self._max_radius = 20.0\n        self._max_dist = 10.0\n        self._timeout_seconds = 60.0\n        initial_agent_v = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        initial_agent_v.cost = 0.0\n        initial_goal_v = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        initial_goal_v.cost = float('inf')\n        vertices = [initial_agent_v]\n        # Start with initial vertex only; vertices will be added dynamically\n        self._graph = gen_cyclic_graph(self._services, initial_agent_v, initial_goal_v, vertices)\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\" Sample points mostly avoiding obstacles and biased toward goal region 10% \"\"\"\n        grid = self._get_grid()\n        size_vals = grid.size.values\n        goal_pos = grid.goal.position\n        # 10% samples directly on/near goal, 90% uniform random in map\n        if np.random.rand() < 0.1:\n            # Gaussian sampling near goal within radius 5, clipped inside map\n            goal_radius = 5\n            coords = []\n            for i, dim_len in enumerate(size_vals):\n                val = int(np.clip(\n                    np.random.normal(loc=goal_pos[i], scale=goal_radius), 0, dim_len - 1\n                ))\n                coords.append(val)\n            sample = Point(*coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n        # Uniform sampling in free space until valid\n        while True:\n            coords = [np.random.randint(0, dim_len) for dim_len in size_vals]\n            sample = Point(*coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _heuristic_nearest(self, candidates, sample: Point) -> Vertex or None:\n        \"\"\"Return nearest vertex to sample biased by cost + distance heuristic.\"\"\"\n        if not candidates:\n            return None\n        s_tensor = sample.to_tensor()\n        min_score = float('inf')\n        best_vertex = None\n        for v in candidates:\n            dist = torch.norm(v.position.to_tensor() - s_tensor).item()\n            score = v.cost + dist  # Combined cost-to-come + heuristic distance\n            if score < min_score:\n                min_score = score\n                best_vertex = v\n        return best_vertex\n\n    def _new_vertex_from_direction(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec).item()\n        if norm <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        dir_normalized = dir_vec / norm\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*[int(round(x)) for x in new_pos_tensor.tolist()])\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _vertices_within_radius(self, center: Point, radius: float) -> list:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, center, radius)\n\n    def _connect_vertices(self, v_from: Vertex, v_to: Vertex) -> bool:\n        \"\"\"Try connecting two vertices if path valid and update costs, return success.\"\"\"\n        grid = self._get_grid()\n        if v_from.position == v_to.position:\n            return False\n        line = grid.get_line_sequence(v_from.position, v_to.position)\n        if not grid.is_valid_line_sequence(line):\n            return False\n\n        dist = torch.norm(v_from.position.to_tensor() - v_to.position.to_tensor()).item()\n        new_cost = v_from.cost + dist\n\n        # Connect v_from -> v_to if better cost found or no parents (v_to.cost initialization might be inf)\n        if v_to.cost is None or new_cost < v_to.cost:\n            # Remove old edges to v_to\n            for parent in list(v_to.parents):\n                self._graph.remove_edge(parent, v_to)\n            # Add new edge\n            self._graph.add_edge(v_from, v_to)\n            # Update cost recursively downstream\n            self._update_descendants_cost(v_to)\n            return True\n        return False\n\n    def _update_descendants_cost(self, vertex: Vertex) -> None:\n        \"\"\"Recursively update costs of vertex descendants.\"\"\"\n        queue = [vertex]\n        while queue:\n            current = queue.pop()\n            for child in current.children:\n                dist = torch.norm(current.position.to_tensor() - child.position.to_tensor()).item()\n                updated_cost = current.cost + dist\n                if child.cost is None or updated_cost < child.cost:\n                    child.cost = updated_cost\n                    queue.append(child)\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        \"\"\"Extract best path from start to goal vertex and move agent along it.\"\"\"\n        # Backtrack parents to start\n        path_vertices = []\n        current = goal_vertex\n        while current.parents:\n            path_vertices.append(current)\n            # Choose parent with minimum cost\n            parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            current = parent\n            if current == self._graph.root_vertex_start:\n                path_vertices.append(current)\n                break\n        path_vertices.reverse()\n\n        # Post-process path smoothing by shortcutting\n        smoothed_path = self._shortcut_path(path_vertices)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path_vertices: list) -> list:\n        \"\"\"Shortcut path by checking direct connections between non-consecutive vertices.\"\"\"\n        if len(path_vertices) < 3:\n            return path_vertices\n        grid = self._get_grid()\n        smoothed_path = [path_vertices[0]]\n        idx = 0\n        while idx < len(path_vertices) - 1:\n            # Try to find farthest reachable vertex ahead (greedy shortcut)\n            far_idx = len(path_vertices) - 1\n            while far_idx > idx + 1:\n                line = grid.get_line_sequence(path_vertices[idx].position, path_vertices[far_idx].position)\n                if grid.is_valid_line_sequence(line):\n                    break\n                far_idx -= 1\n            smoothed_path.append(path_vertices[far_idx])\n            idx = far_idx\n        return smoothed_path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        goal_vertex = self._graph.root_vertex_goal\n        goal_reached = False\n\n        # Dynamic vertex list for graph growth\n        vertex_list = [start_vertex]\n        self._graph.root_vertices = vertex_list + [goal_vertex]\n\n        iteration = 0\n        while iteration < self._max_vertices:\n            iteration += 1\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout_seconds:\n                # FAIL path search due to timeout\n                return\n\n            q_sample = self._get_random_sample()\n            # Select nearest vertex biased by cost and heuristic\n            q_near = self._heuristic_nearest(vertex_list, q_sample)\n            if q_near is None or q_near.position == q_sample:\n                continue\n\n            q_new = self._new_vertex_from_direction(q_near, q_sample, self._max_dist)\n            # Check path from q_near to q_new\n            line = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line):\n                continue\n\n            # Prepare q_new cost estimate: tentative cost from q_near + dist\n            dist_near_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = q_near.cost + dist_near_new\n\n            # Find neighborhood radius adapting to n^(1/d) * some constant (RRT* inspired)\n            n = len(vertex_list) + 1\n            d = grid.size.n_dim\n            gamma = self._max_radius\n            radius = min(gamma * ((np.log(n) / n) ** (1/d)), self._max_radius)\n\n            neighbors = self._vertices_within_radius(q_new.position, radius)\n\n            # Choose best parent to minimize cost and ensure path validity\n            c_min = float('inf')\n            q_min = None\n            for neighbor in neighbors:\n                if neighbor.position == q_new.position:\n                    continue\n                line_n_new = grid.get_line_sequence(neighbor.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_n_new):\n                    continue\n                dist_n_new = torch.norm(neighbor.position.to_tensor() - q_new.position.to_tensor()).item()\n                cost = neighbor.cost + dist_n_new\n                if cost < c_min:\n                    c_min = cost\n                    q_min = neighbor\n\n            if q_min is None:\n                q_min = q_near\n                c_min = q_min.cost + dist_near_new\n\n            q_new.cost = c_min\n            # Add new vertex to graph and vertex list\n            vertex_list.append(q_new)\n            self._graph.root_vertices.insert(-1, q_new)  # Before goal vertex\n            self._graph.add_edge(q_min, q_new)\n\n            # Optimize connection of neighbors to q_new (rewiring)\n            for neighbor in neighbors:\n                if neighbor == q_min or neighbor == q_new:\n                    continue\n                dist_new_n = torch.norm(q_new.position.to_tensor() - neighbor.position.to_tensor()).item()\n                cost_through_new = q_new.cost + dist_new_n\n                if cost_through_new < neighbor.cost:\n                    line_new_n = grid.get_line_sequence(q_new.position, neighbor.position)\n                    if grid.is_valid_line_sequence(line_new_n):\n                        # Remove one parent edge to neighbor (assume only one parent)\n                        if neighbor.parents:\n                            self._graph.remove_edge(next(iter(neighbor.parents)), neighbor)\n                        self._graph.add_edge(q_new, neighbor)\n                        neighbor.cost = cost_through_new\n                        self._update_descendants_cost(neighbor)\n\n            # Attempt connection to goal\n            line_to_goal = grid.get_line_sequence(q_new.position, goal_vertex.position)\n            dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_vertex.position.to_tensor()).item()\n            if grid.is_valid_line_sequence(line_to_goal):\n                cost_to_goal = q_new.cost + dist_to_goal\n                if cost_to_goal < goal_vertex.cost:\n                    # Connect q_new -> goal\n                    for p in list(goal_vertex.parents):\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_vertex.cost = cost_to_goal\n                    goal_reached = True\n\n            self.key_frame()\n\n            if goal_reached:\n                self._extract_path(goal_vertex)\n                return",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 213, in _find_path_internal\n  File \"<string>\", line 85, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m2",
     "algorithm": "Improved bidirectional RRT* inspired algorithm combining adaptive sampling,\n    informed radius rewiring, and goal biasing for faster convergence and better path quality.\n    Features:\n    - Bidirectional growth from start and goal for efficiency and robustness.\n    - Adaptive connection radius based on graph size and dimension for optimal rewiring.\n    - Goal biasing to guide sampling towards the goal region without sacrificing exploration.\n    - Max step size adaptively tuned to map size for smoother incremental expansion.\n    - Time limit (60s) to terminate early on failure.\n    - Post-path extraction smoothing by shortcutting feasible line segments to reduce path length.\n    This approach produces shorter, smoother paths, improves success rate in cluttered maps,\n    and balances exploration vs exploitation to reduce search time while maintaining robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: \"CyclicGraph\"\n    _max_dist: float\n    _iterations: int\n    _goal_sample_rate: float  # probability to sample goal to bias tree growth\n    _time_start: float\n    _time_limit: float = 60.0  # seconds\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        # Using a cyclic graph for flexible rewiring in both directions\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n\n        # Adaptive max step based on map diagonal length\n        diagonal = float(np.linalg.norm(np.array(self._get_grid().size.values)))\n        self._max_dist = max(5.0, diagonal * 0.05)  # 5 or 5% of diagonal\n\n        self._iterations = 12000\n        self._goal_sample_rate = 0.15  # 15% chance to sample goal directly\n\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # With goal biasing\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = tuple(np.random.randint(0, self._get_grid().size[i]) for i in range(self._get_grid().size.n_dim))\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, roots: List[Vertex], q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(roots, q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_norm = dir_vec / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + dir_norm * max_dist)\n        return Vertex(new_pos)\n\n    def _get_vertices_within_radius(self, root_vertices: List[Vertex], q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(root_vertices, q_new.position, radius)\n\n    def _reconnect(self, q_new: Vertex, Q_near: List[Vertex], roots: List[Vertex]) -> None:\n        \"\"\"Rewire tree edges to improve path costs with collision check.\"\"\"\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n            cost_through_new = q_new.cost + dist\n            if cost_through_new >= q_near.cost:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Remove old edge\n            parent_to_remove = None\n            for p in q_near.parents:\n                parent_to_remove = p\n                break\n            if parent_to_remove is not None:\n                self._graph.remove_edge(parent_to_remove, q_near)\n\n            # Add new edge and update cost\n            q_near.cost = cost_through_new\n            self._graph.add_edge(q_new, q_near)\n\n            # Propagate cost changes downstream\n            self._propagate_cost(q_near, roots)\n\n    def _propagate_cost(self, vertex: Vertex, roots: List[Vertex]) -> None:\n        \"\"\"Update cost values recursively for descendants.\"\"\"\n        for child in vertex.children:\n            parent_cost = vertex.cost if vertex.cost is not None else float('inf')\n            dist = torch.norm(vertex.position.to_tensor() - child.position.to_tensor())\n            new_cost = parent_cost + dist\n            if child.cost is None or new_cost < child.cost:\n                child.cost = new_cost\n                self._propagate_cost(child, roots)\n\n    def _extract_path(self, q_meet: Vertex) -> None:\n        \"\"\"Extract path from start to goal through q_meet and then smooth it.\"\"\"\n        start_root = [self._graph.root_vertex_start]\n        goal_root = [self._graph.root_vertex_goal]\n\n        # Trace path start -> q_meet\n        path_start = []\n        v = q_meet\n        while True:\n            path_start.append(v)\n            if v in start_root:\n                break\n            if not v.parents:\n                break\n            # Pick parent with min cost (could be multiple parents)\n            v = min(v.parents, key=lambda x: x.cost if x.cost is not None else float('inf'))\n        path_start.reverse()\n\n        # Trace path q_meet -> goal\n        path_goal = []\n        v = q_meet\n        while True:\n            path_goal.append(v)\n            if v in goal_root:\n                break\n            if not v.children:\n                break\n            v = min(v.children, key=lambda x: x.cost if x.cost is not None else float('inf'))\n\n        full_path = path_start + path_goal[1:]\n\n        # Positions only\n        raw_points = [v.position for v in full_path]\n\n        # Smooth path by trying to shortcut segments directly if collision-free\n        smoothed_points = self._short_cut_path(raw_points)\n\n        for pos in smoothed_points:\n            self.move_agent(pos)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _short_cut_path(self, path_points: List[Point]) -> List[Point]:\n        \"\"\"Attempt to smooth path by shortcutting via valid direct lines.\"\"\"\n        if len(path_points) <= 2:\n            return path_points\n        smoothed = [path_points[0]]\n        i = 0\n        while i < len(path_points) - 1:\n            j = len(path_points) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path_points[i], path_points[j])\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed.append(path_points[j])\n            i = j\n        return smoothed\n\n    def _find_path_internal(self) -> None:\n        dimension = self._get_grid().size.n_dim\n        max_radius = max(self._get_grid().size.width, self._get_grid().size.height) * 0.2\n        lambda_rrt_star = 30.0\n\n        self._time_start = time.perf_counter()\n\n        # Roots for both trees\n        roots_start = [self._graph.root_vertex_start]\n        roots_goal = [self._graph.root_vertex_goal]\n\n        for i in range(self._iterations):\n\n            # Time limit check\n            if time.perf_counter() - self._time_start > self._time_limit:\n                # Failed due to timeout\n                break\n\n            # Alternate between growing start and goal trees\n            if i % 2 == 0:\n                tree_roots = roots_start\n                other_roots = roots_goal\n            else:\n                tree_roots = roots_goal\n                other_roots = roots_start\n\n            q_rand = self._get_random_sample()\n            q_near = self._get_nearest_vertex(tree_roots, q_rand)\n            if q_near.position == q_rand:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_rand, self._max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute adaptive radius\n            card_v = torch.tensor(float(self._graph.size))\n            if card_v <= 1:\n                radius = max_radius\n            else:\n                radius = min(lambda_rrt_star * ((torch.log(card_v) / card_v) ** (1 / dimension)), max_radius)\n\n            # Find neighbors within radius\n            Q_near = self._get_vertices_within_radius(tree_roots, q_new, radius)\n\n            # Choose parent with min cost + dist and valid path\n            q_min = q_near\n            c_min = (q_near.cost if q_near.cost is not None else float('inf')) + torch.norm(\n                q_near.position.to_tensor() - q_new.position.to_tensor())\n            for q_near_cand in Q_near:\n                dist_to_new = torch.norm(q_near_cand.position.to_tensor() - q_new.position.to_tensor())\n                cost_cand = (q_near_cand.cost if q_near_cand.cost is not None else float('inf')) + dist_to_new\n                if cost_cand < c_min:\n                    line_seq_cand = self._get_grid().get_line_sequence(q_near_cand.position, q_new.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq_cand):\n                        q_min = q_near_cand\n                        c_min = cost_cand\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors where cost can be improved via q_new\n            self._reconnect(q_new, Q_near, tree_roots)\n\n            # Try to connect the other tree to this new vertex\n            q_new_other_near = self._get_nearest_vertex(other_roots, q_new.position)\n            while True:\n                q_new_other = self._get_new_vertex(q_new_other_near, q_new.position, self._max_dist)\n                line_seq_other = self._get_grid().get_line_sequence(q_new_other_near.position, q_new_other.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_other):\n                    break\n                self._graph.add_edge(q_new_other_near, q_new_other)\n                q_new_other.cost = (q_new_other_near.cost if q_new_other_near.cost is not None else 0) + \\\n                                   torch.norm(q_new_other.position.to_tensor() - q_new_other_near.position.to_tensor())\n                if q_new_other.position == q_new.position:\n                    # Trees connected, path found\n                    self._extract_path(q_new)\n                    return\n                q_new_other_near = q_new_other\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 215, in _find_path_internal\n  File \"<string>\", line 75, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m3",
     "algorithm": "Improved sampling-based path planning algorithm that combines adaptive sampling \n    focusing near the goal with an anytime rewiring strategy inspired by RRT*.\n\n    Key features:\n    - Adaptive goal-bias sampling with dynamically adjusted radius to focus exploration efficiently.\n    - Anytime rewiring of the graph within a shrinking radius improving path quality progressively.\n    - Early pruning of costly connections based on incremental cost evaluation.\n    - Integration of time limit (60 sec) to abort search if no solution found.\n    - Uses cyclic graph structure enabling better edge manipulations and path smoothness.\n    - Balances exploration and exploitation dynamically based on iteration and search status.\n\n    The method aims for improved planning efficiency, path quality, robustness, and reduced search times.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: \"CyclicGraph\"\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n        start_v = Vertex(start_pos)\n        start_v.cost = 0\n        goal_v = Vertex(goal_pos)\n        self._graph = gen_cyclic_graph(self._services, start_v, goal_v, [])\n        self._init_displays()\n\n    def _get_random_sample(self, goal_bias=0.15, goal_sample_radius=15.0) -> Point:\n        \"\"\"Sample with bias: mostly uniform random, sometimes near goal within a radius.\"\"\"\n\n        grid = self._get_grid()\n        # Bias towards sampling near the goal position\n        if np.random.random() < goal_bias:\n            attempts = 0\n            while True:\n                # Sample in a circle around the goal (for 2D)\n                angle = np.random.uniform(0, 2 * np.pi)\n                radius = np.random.uniform(0, goal_sample_radius)\n                dx = radius * math.cos(angle)\n                dy = radius * math.sin(angle)\n                gp = grid.goal.position\n                candidate = Point(int(round(gp.x + dx)), int(round(gp.y + dy)))\n                attempts += 1\n                if grid.is_agent_valid_pos(candidate):\n                    return candidate\n                if attempts > 100:  # fallback to global random sampling\n                    break\n\n        # Uniform random sample in the entire map size\n        max_dims = grid.size.values\n        while True:\n            rand_pos = np.random.randint(0, max_dims, len(max_dims))\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_v: Vertex, to_p: Point, max_dist: float) -> Vertex:\n        \"\"\"Return a new vertex in the direction from from_v to to_p with max step length max_dist.\"\"\"\n        dir_vec = to_p.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(to_p)\n        dir_norm = dir_vec / dist\n        new_pos_tensor = from_v.position.to_tensor() + dir_norm * max_dist\n        new_pos_list = new_pos_tensor.tolist()\n        # Round to nearest int coordinates to avoid floating point positions\n        new_pos_int = tuple(int(round(coord)) for coord in new_pos_list)\n        new_pos = Point(*new_pos_int)\n        return Vertex(new_pos)\n\n    def _get_nearest_vertex(self, point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, point)\n\n    def _get_nearby_vertices(self, vertex: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _cost(self, from_v: Vertex, to_v: Vertex) -> float:\n        return from_v.cost + self._get_grid().get_distance(from_v.position, to_v.position)\n\n    def _extract_path(self, last_vertex: Vertex) -> None:\n        # Goal vertex that references last vertex\n        goal_v = Vertex(self._get_grid().goal.position)\n        child_parent_dist = self._get_grid().get_distance(last_vertex.position, goal_v.position)\n        goal_v.cost = last_vertex.cost + child_parent_dist\n        self._graph.add_edge(last_vertex, goal_v)\n        path = [goal_v]\n\n        while path[-1].parents:\n            for p in path[-1].parents:\n                path.append(p)\n                break\n\n        path.pop()  # remove the root with no parents\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n\n        max_dist = 10.0\n        max_iter = 10000\n        dimension = grid.size.n_dim\n        max_time_sec = 60\n\n        start_time = time.time()\n\n        # Constants for radius calculation (RRT* inspired)\n        gamma_rrt_star = 50.0\n        goal_sample_radius = max(15.0, max_dist * 2)\n\n        # Initialize the start vertex cost (done in __init__)\n\n        for iter_count in range(max_iter):\n\n            if time.time() - start_time > max_time_sec:\n                # Treat search as failed after 60seconds\n                break\n\n            # Adaptive decreasing goal bias and radius for goal sampling\n            elapsed_ratio = iter_count / max_iter\n            goal_bias = max(0.1, 0.3 * (1.0 - elapsed_ratio))\n            adaptive_goal_radius = max(goal_sample_radius * (1.0 - elapsed_ratio), max_dist)\n\n            q_sample = self._get_random_sample(goal_bias=goal_bias, goal_sample_radius=adaptive_goal_radius)\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._steer(q_nearest, q_sample, max_dist)\n\n            # Check path between nearest and new is valid\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Radius for neighbors for rewiring, shrinking as tree grows\n            card_V = max(1, float(self._graph.size))\n            radius = min(\n                gamma_rrt_star * ((math.log(card_V) / card_V) ** (1 / dimension)),\n                max_dist * 3,\n            )\n\n            nearby_vertices = self._get_nearby_vertices(q_new, radius)\n\n            # Choose parent that minimizes cost and is collision free\n            q_min = q_nearest\n            c_min = self._cost(q_nearest, q_new)\n\n            for near_v in nearby_vertices:\n                # Edge collision check\n                if grid.is_valid_line_sequence(grid.get_line_sequence(near_v.position, q_new.position)):\n                    cost_through_near = self._cost(near_v, q_new)\n                    if cost_through_near < c_min:\n                        q_min = near_v\n                        c_min = cost_through_near\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if a cheaper path via q_new is found\n            for near_v in nearby_vertices:\n                if near_v == q_min:\n                    continue\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, near_v.position)):\n                    cost_via_new = q_new.cost + grid.get_distance(q_new.position, near_v.position)\n                    if near_v.cost is None or cost_via_new < near_v.cost:\n                        # Remove old parent edge (assumption: one parent per vertex in this graph)\n                        old_parent = None\n                        for p in near_v.parents:\n                            old_parent = p\n                            break\n                        if old_parent:\n                            self._graph.remove_edge(old_parent, near_v)\n                        near_v.cost = cost_via_new\n                        self._graph.add_edge(q_new, near_v)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 153, in _find_path_internal\n  File \"<string>\", line 80, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m2",
     "algorithm": "Improved bidirectional RRT* inspired algorithm combining adaptive sampling,\n    informed radius rewiring, and goal biasing for faster convergence and better path quality.\n    Features:\n    - Bidirectional growth from start and goal for efficiency and robustness.\n    - Adaptive connection radius based on graph size and dimension for optimal rewiring.\n    - Goal biasing to guide sampling towards the goal region without sacrificing exploration.\n    - Max step size adaptively tuned to map size for smoother incremental expansion.\n    - Time limit (60s) to terminate early on failure.\n    - Post-path extraction smoothing by shortcutting feasible line segments to reduce path length.\n    This approach produces shorter, smoother paths, improves success rate in cluttered maps,\n    and balances exploration vs exploitation to reduce search time while maintaining robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: \"CyclicGraph\"\n    _max_dist: float\n    _iterations: int\n    _goal_sample_rate: float  # probability to sample goal to bias tree growth\n    _time_start: float\n    _time_limit: float = 60.0  # seconds\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        # Using a cyclic graph for flexible rewiring in both directions\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n\n        # Adaptive max step based on map diagonal length\n        diagonal = float(np.linalg.norm(np.array(self._get_grid().size.values)))\n        self._max_dist = max(5.0, diagonal * 0.05)  # 5 or 5% of diagonal\n\n        self._iterations = 12000\n        self._goal_sample_rate = 0.15  # 15% chance to sample goal directly\n\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # With goal biasing\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = tuple(\n                int(np.random.randint(0, self._get_grid().size[i])) for i in range(self._get_grid().size.n_dim)\n            )\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, roots: list[Vertex], q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(roots, q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_norm = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + dir_norm * max_dist\n        # Ensure new_pos is integer coordinates if original positions are int-based grid points\n        new_pos_vals = tuple(int(round(float(x))) for x in new_pos_tensor.tolist())\n        new_pos = Point(*new_pos_vals)\n        return Vertex(new_pos)\n\n    def _get_vertices_within_radius(self, root_vertices: list[Vertex], q_new: Vertex, radius: float) -> list[Vertex]:\n        return self._graph.get_vertices_within_radius(root_vertices, q_new.position, radius)\n\n    def _reconnect(self, q_new: Vertex, Q_near: list[Vertex], roots: list[Vertex]) -> None:\n        \"\"\"Rewire tree edges to improve path costs with collision check.\"\"\"\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n            cost_through_new = q_new.cost + dist\n            if cost_through_new >= q_near.cost:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Remove old edge\n            parent_to_remove = None\n            for p in q_near.parents:\n                parent_to_remove = p\n                break\n            if parent_to_remove is not None:\n                self._graph.remove_edge(parent_to_remove, q_near)\n\n            # Add new edge and update cost\n            q_near.cost = cost_through_new\n            self._graph.add_edge(q_new, q_near)\n\n            # Propagate cost changes downstream\n            self._propagate_cost(q_near, roots)\n\n    def _propagate_cost(self, vertex: Vertex, roots: list[Vertex]) -> None:\n        \"\"\"Update cost values recursively for descendants.\"\"\"\n        for child in vertex.children:\n            parent_cost = vertex.cost if vertex.cost is not None else float('inf')\n            dist = torch.norm(vertex.position.to_tensor() - child.position.to_tensor())\n            new_cost = parent_cost + dist\n            if child.cost is None or new_cost < child.cost:\n                child.cost = new_cost\n                self._propagate_cost(child, roots)\n\n    def _extract_path(self, q_meet: Vertex) -> None:\n        \"\"\"Extract path from start to goal through q_meet and then smooth it.\"\"\"\n        start_root = [self._graph.root_vertex_start]\n        goal_root = [self._graph.root_vertex_goal]\n\n        # Trace path start -> q_meet\n        path_start = []\n        v = q_meet\n        while True:\n            path_start.append(v)\n            if v in start_root:\n                break\n            if not v.parents:\n                break\n            # Pick parent with min cost (could be multiple parents)\n            v = min(v.parents, key=lambda x: x.cost if x.cost is not None else float('inf'))\n        path_start.reverse()\n\n        # Trace path q_meet -> goal\n        path_goal = []\n        v = q_meet\n        while True:\n            path_goal.append(v)\n            if v in goal_root:\n                break\n            if not v.children:\n                break\n            v = min(v.children, key=lambda x: x.cost if x.cost is not None else float('inf'))\n\n        full_path = path_start + path_goal[1:]\n\n        # Positions only\n        raw_points = [v.position for v in full_path]\n\n        # Smooth path by trying to shortcut segments directly if collision-free\n        smoothed_points = self._short_cut_path(raw_points)\n\n        for pos in smoothed_points:\n            self.move_agent(pos)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _short_cut_path(self, path_points: list[Point]) -> list[Point]:\n        \"\"\"Attempt to smooth path by shortcutting via valid direct lines.\"\"\"\n        if len(path_points) <= 2:\n            return path_points\n        smoothed = [path_points[0]]\n        i = 0\n        while i < len(path_points) - 1:\n            j = len(path_points) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path_points[i], path_points[j])\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed.append(path_points[j])\n            i = j\n        return smoothed\n\n    def _find_path_internal(self) -> None:\n        dimension = self._get_grid().size.n_dim\n        max_radius = max(self._get_grid().size.width, self._get_grid().size.height) * 0.2\n        lambda_rrt_star = 30.0\n\n        self._time_start = time.perf_counter()\n\n        # Roots for both trees\n        roots_start = [self._graph.root_vertex_start]\n        roots_goal = [self._graph.root_vertex_goal]\n\n        for i in range(self._iterations):\n\n            # Time limit check\n            if time.perf_counter() - self._time_start > self._time_limit:\n                # Failed due to timeout\n                break\n\n            # Alternate between growing start and goal trees\n            if i % 2 == 0:\n                tree_roots = roots_start\n                other_roots = roots_goal\n            else:\n                tree_roots = roots_goal\n                other_roots = roots_start\n\n            q_rand = self._get_random_sample()\n            q_near = self._get_nearest_vertex(tree_roots, q_rand)\n            if q_near.position == q_rand:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_rand, self._max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute adaptive radius\n            card_v = float(self._graph.size)\n            if card_v <= 1:\n                radius = max_radius\n            else:\n                radius = min(lambda_rrt_star * ((np.log(card_v) / card_v) ** (1 / dimension)), max_radius)\n\n            # Find neighbors within radius\n            Q_near = self._get_vertices_within_radius(tree_roots, q_new, radius)\n\n            # Choose parent with min cost + dist and valid path\n            q_min = q_near\n            c_min = (q_near.cost if q_near.cost is not None else float('inf')) + torch.norm(\n                q_near.position.to_tensor() - q_new.position.to_tensor())\n            for q_near_cand in Q_near:\n                dist_to_new = torch.norm(q_near_cand.position.to_tensor() - q_new.position.to_tensor())\n                cost_cand = (q_near_cand.cost if q_near_cand.cost is not None else float('inf')) + dist_to_new\n                if cost_cand < c_min:\n                    line_seq_cand = self._get_grid().get_line_sequence(q_near_cand.position, q_new.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq_cand):\n                        q_min = q_near_cand\n                        c_min = cost_cand\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors where cost can be improved via q_new\n            self._reconnect(q_new, Q_near, tree_roots)\n\n            # Try to connect the other tree to this new vertex\n            q_new_other_near = self._get_nearest_vertex(other_roots, q_new.position)\n            while True:\n                q_new_other = self._get_new_vertex(q_new_other_near, q_new.position, self._max_dist)\n                line_seq_other = self._get_grid().get_line_sequence(q_new_other_near.position, q_new_other.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_other):\n                    break\n                self._graph.add_edge(q_new_other_near, q_new_other)\n                q_new_other.cost = (q_new_other_near.cost if q_new_other_near.cost is not None else 0) + \\\n                                   torch.norm(q_new_other.position.to_tensor() - q_new_other_near.position.to_tensor())\n                if q_new_other.position == q_new.position:\n                    # Trees connected, path found\n                    self._extract_path(q_new)\n                    return\n                q_new_other_near = q_new_other\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 80, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "m2",
     "algorithm": "Improved bidirectional RRT* inspired algorithm combining adaptive sampling,\n    informed radius rewiring, and goal biasing for faster convergence and better path quality.\n    Features:\n    - Bidirectional growth from start and goal for efficiency and robustness.\n    - Adaptive connection radius based on graph size and dimension for optimal rewiring.\n    - Goal biasing to guide sampling towards the goal region without sacrificing exploration.\n    - Max step size adaptively tuned to map size for smoother incremental expansion.\n    - Time limit (60s) to terminate early on failure.\n    - Post-path extraction smoothing by shortcutting feasible line segments to reduce path length.\n    This approach produces shorter, smoother paths, improves success rate in cluttered maps,\n    and balances exploration vs exploitation to reduce search time while maintaining robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: \"CyclicGraph\"\n    _max_dist: float\n    _iterations: int\n    _goal_sample_rate: float  # probability to sample goal to bias tree growth\n    _time_start: float\n    _time_limit: float = 60.0  # seconds\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        # Using a cyclic graph for flexible rewiring in both directions\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n\n        # Adaptive max step based on map diagonal length\n        diagonal = float(np.linalg.norm(np.array(self._get_grid().size.values)))\n        self._max_dist = max(5.0, diagonal * 0.05)  # 5 or 5% of diagonal\n\n        self._iterations = 12000\n        self._goal_sample_rate = 0.15  # 15% chance to sample goal directly\n\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # With goal biasing\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = tuple(\n                int(np.random.randint(0, self._get_grid().size[i])) for i in range(self._get_grid().size.n_dim)\n            )\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, roots, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(roots, q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_norm = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + dir_norm * max_dist\n        # Ensure new_pos is integer coordinates if original positions are int-based grid points\n        new_pos_vals = tuple(int(round(float(x))) for x in new_pos_tensor.tolist())\n        new_pos = Point(*new_pos_vals)\n        return Vertex(new_pos)\n\n    def _get_vertices_within_radius(self, root_vertices, q_new: Vertex, radius: float):\n        return self._graph.get_vertices_within_radius(root_vertices, q_new.position, radius)\n\n    def _reconnect(self, q_new: Vertex, Q_near, roots) -> None:\n        \"\"\"Rewire tree edges to improve path costs with collision check.\"\"\"\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n            cost_through_new = q_new.cost + dist\n            if cost_through_new >= q_near.cost:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Remove old edge\n            parent_to_remove = None\n            for p in q_near.parents:\n                parent_to_remove = p\n                break\n            if parent_to_remove is not None:\n                self._graph.remove_edge(parent_to_remove, q_near)\n\n            # Add new edge and update cost\n            q_near.cost = cost_through_new\n            self._graph.add_edge(q_new, q_near)\n\n            # Propagate cost changes downstream\n            self._propagate_cost(q_near, roots)\n\n    def _propagate_cost(self, vertex: Vertex, roots) -> None:\n        \"\"\"Update cost values recursively for descendants.\"\"\"\n        for child in vertex.children:\n            parent_cost = vertex.cost if vertex.cost is not None else float('inf')\n            dist = torch.norm(vertex.position.to_tensor() - child.position.to_tensor())\n            new_cost = parent_cost + dist\n            if child.cost is None or new_cost < child.cost:\n                child.cost = new_cost\n                self._propagate_cost(child, roots)\n\n    def _extract_path(self, q_meet: Vertex) -> None:\n        \"\"\"Extract path from start to goal through q_meet and then smooth it.\"\"\"\n        start_root = [self._graph.root_vertex_start]\n        goal_root = [self._graph.root_vertex_goal]\n\n        # Trace path start -> q_meet\n        path_start = []\n        v = q_meet\n        while True:\n            path_start.append(v)\n            if v in start_root:\n                break\n            if not v.parents:\n                break\n            # Pick parent with min cost (could be multiple parents)\n            v = min(v.parents, key=lambda x: x.cost if x.cost is not None else float('inf'))\n        path_start.reverse()\n\n        # Trace path q_meet -> goal\n        path_goal = []\n        v = q_meet\n        while True:\n            path_goal.append(v)\n            if v in goal_root:\n                break\n            if not v.children:\n                break\n            v = min(v.children, key=lambda x: x.cost if x.cost is not None else float('inf'))\n\n        full_path = path_start + path_goal[1:]\n\n        # Positions only\n        raw_points = [v.position for v in full_path]\n\n        # Smooth path by trying to shortcut segments directly if collision-free\n        smoothed_points = self._short_cut_path(raw_points)\n\n        for pos in smoothed_points:\n            self.move_agent(pos)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _short_cut_path(self, path_points: list[Point]) -> list[Point]:\n        \"\"\"Attempt to smooth path by shortcutting via valid direct lines.\"\"\"\n        if len(path_points) <= 2:\n            return path_points\n        smoothed = [path_points[0]]\n        i = 0\n        while i < len(path_points) - 1:\n            j = len(path_points) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path_points[i], path_points[j])\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed.append(path_points[j])\n            i = j\n        return smoothed\n\n    def _find_path_internal(self) -> None:\n        dimension = self._get_grid().size.n_dim\n        max_radius = max(self._get_grid().size.width, self._get_grid().size.height) * 0.2\n        lambda_rrt_star = 30.0\n\n        self._time_start = time.perf_counter()\n\n        # Roots for both trees\n        roots_start = [self._graph.root_vertex_start]\n        roots_goal = [self._graph.root_vertex_goal]\n\n        for i in range(self._iterations):\n\n            # Time limit check\n            if time.perf_counter() - self._time_start > self._time_limit:\n                # Failed due to timeout\n                break\n\n            # Alternate between growing start and goal trees\n            if i % 2 == 0:\n                tree_roots = roots_start\n                other_roots = roots_goal\n            else:\n                tree_roots = roots_goal\n                other_roots = roots_start\n\n            q_rand = self._get_random_sample()\n            q_near = self._get_nearest_vertex(tree_roots, q_rand)\n            if q_near.position == q_rand:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_rand, self._max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute adaptive radius\n            card_v = float(self._graph.size)\n            if card_v <= 1:\n                radius = max_radius\n            else:\n                radius = min(lambda_rrt_star * ((np.log(card_v) / card_v) ** (1 / dimension)), max_radius)\n\n            # Find neighbors within radius\n            Q_near = self._get_vertices_within_radius(tree_roots, q_new, radius)\n\n            # Choose parent with min cost + dist and valid path\n            q_min = q_near\n            c_min = (q_near.cost if q_near.cost is not None else float('inf')) + torch.norm(\n                q_near.position.to_tensor() - q_new.position.to_tensor())\n            for q_near_cand in Q_near:\n                dist_to_new = torch.norm(q_near_cand.position.to_tensor() - q_new.position.to_tensor())\n                cost_cand = (q_near_cand.cost if q_near_cand.cost is not None else float('inf')) + dist_to_new\n                if cost_cand < c_min:\n                    line_seq_cand = self._get_grid().get_line_sequence(q_near_cand.position, q_new.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq_cand):\n                        q_min = q_near_cand\n                        c_min = cost_cand\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors where cost can be improved via q_new\n            self._reconnect(q_new, Q_near, tree_roots)\n\n            # Try to connect the other tree to this new vertex\n            q_new_other_near = self._get_nearest_vertex(other_roots, q_new.position)\n            while True:\n                q_new_other = self._get_new_vertex(q_new_other_near, q_new.position, self._max_dist)\n                line_seq_other = self._get_grid().get_line_sequence(q_new_other_near.position, q_new_other.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_other):\n                    break\n                self._graph.add_edge(q_new_other_near, q_new_other)\n                q_new_other.cost = (q_new_other_near.cost if q_new_other_near.cost is not None else 0) + \\\n                                   torch.norm(q_new_other.position.to_tensor() - q_new_other_near.position.to_tensor())\n                if q_new_other.position == q_new.position:\n                    # Trees connected, path found\n                    self._extract_path(q_new)\n                    return\n                q_new_other_near = q_new_other\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 177, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "m3",
     "algorithm": "Improved sample-based path planning algorithm combining benefits of RRT* and SPRM features:\n    - Uses an adaptive radius for neighborhood search based on vertex count and map size to enhance rewiring and path smoothness.\n    - Incorporates cost optimization while rewiring to ensure better path quality.\n    - Uses informed sampling centered around the current best path to improve planning efficiency.\n    - Limits search time to 60 seconds to ensure robustness by failing gracefully if no solution is found.\n    - Utilizes cyclic graph to avoid tree structure limitations and enable richer connectivity.\n    - Implements path smoothing by shortcutting edges when possible, improving path length and smoothness.\n    - Produces more optimal and robust paths with balanced exploration and exploitation.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n    _max_edge_len: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        self._V_size = 250\n        # Maximum edge length per extension step, scaled to map size\n        grid_size_sum = sum(self._get_grid().size.values)\n        self._max_edge_len = max(5, grid_size_sum / 20)\n        self._max_radius = max(10, grid_size_sum / 10)\n\n        V: List[Vertex] = []\n        for _ in range(self._V_size):\n            sample = self._get_random_sample()\n            V.append(Vertex(sample, store_connectivity=True))\n\n        self._graph = gen_cyclic_graph(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            V,\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Informed sampling within a heuristic ellipsoidal region to focus search near best path.\"\"\"\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n\n        c_best = float(\"inf\")\n        path_vertices = self._get_current_best_path_vertices()\n        if path_vertices:\n            c_best = sum(\n                self._get_grid().get_distance(path_vertices[i].position, path_vertices[i + 1].position)\n                for i in range(len(path_vertices) - 1)\n            )\n        else:\n            # If no path known, set to grid diagonal length * 2 to search broadly\n            c_best = (self._get_grid().size.to_tensor().float().norm()) * 2\n\n        while True:\n            # Uniform random sample in configuration space\n            random_sample = Point(\n                *[\n                    self._services.rng.uniform(0, self._get_grid().size[i])\n                    for i in range(self._get_grid().size.n_dim)\n                ]\n            )\n\n            # Reject samples outside informed ellipsoid (if path known) to focus search:\n            # Ellipsoid defined by foci start and goal and path cost c_best\n            dist_start_sample = (random_sample.to_tensor() - start).norm()\n            dist_sample_goal = (random_sample.to_tensor() - goal).norm()\n            if dist_start_sample + dist_sample_goal <= c_best + self._max_edge_len:\n                if self._get_grid().is_agent_valid_pos(random_sample):\n                    return random_sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = direction.norm()\n        if norm_dir <= max_dist:\n            q_new = q_sample\n        else:\n            q_new_tensor = q_near.position.to_tensor() + (direction / norm_dir) * max_dist\n            q_new = Point.from_tensor(q_new_tensor)\n        return Vertex(q_new, store_connectivity=True)\n\n    def _near(self, vertex: Vertex, radius: Optional[float] = None) -> List[Vertex]:\n        # Use adaptive radius if none specified\n        if radius is None:\n            n = max(1, len(self._graph.root_vertices))\n            # RRT* radius formula scaled to environment - robust and efficient\n            unit_ball_volume = 3.14  # Approximation for 2D; in higher dims could tune\n            gamma_rrt_star = 2 * (1 + 1 / self._get_grid().size.n_dim) ** (1 / self._get_grid().size.n_dim) * (\n                self._get_grid().size.width * self._get_grid().size.height\n            ) ** (1 / self._get_grid().size.n_dim)\n            radius = min(self._max_radius, gamma_rrt_star * (math.log(n) / n) ** (1 / self._get_grid().size.n_dim))\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _choose_parent_and_rewire(self, q_new: Vertex, q_near_list: List[Vertex]) -> None:\n        # Choose best parent based on total cost to q_new through neighbor and rewire neighbors if better path found\n        best_parent = None\n        best_cost = float(\"inf\")\n        for q_near in q_near_list:\n            if q_near.position == q_new.position:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            tentative_cost = (\n                getattr(q_near, \"cost\", 0) + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            )\n            if tentative_cost < best_cost:\n                best_parent = q_near\n                best_cost = tentative_cost\n        if best_parent:\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n            # Rewire neighbors if going through q_new offers a better cost\n            for q_near in q_near_list:\n                if q_near == best_parent or q_near == q_new:\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    continue\n                cost_through_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n                current_cost = getattr(q_near, \"cost\", float(\"inf\"))\n                if cost_through_new < current_cost:\n                    # Remove old edge(s) from parents\n                    for parent in list(q_near.parents):\n                        self._graph.remove_edge(parent, q_near)\n                    self._graph.add_edge(q_new, q_near)\n                    q_near.cost = cost_through_new\n\n    def _get_current_best_path_vertices(self) -> List[Vertex]:\n        # Try to recover current best path from start to goal if connected\n        start = self._graph.root_vertex_start\n        goal = self._graph.root_vertex_goal\n        if goal not in start.connectivity:\n            return []\n\n        path = []\n        current = start\n        while current != goal:\n            children = list(current.connectivity)\n            if not children:\n                break\n            # Choose child with lowest cost if available (heuristic)\n            if hasattr(current, \"cost\"):\n                children = sorted(children, key=lambda c: getattr(c, \"cost\", float(\"inf\")))\n            current = children[0]\n            path.append(current)\n            if current == goal:\n                break\n        return path\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Path shortcutting to improve smoothness: tries to connect non-adjacent points directly if possible\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[next_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                next_idx -= 1\n            shortcut_path.append(path[next_idx])\n            idx = next_idx\n        return shortcut_path\n\n    def _extract_path_and_animate(self, q_goal: Vertex) -> None:\n        # Extracts path from the goal vertex back to start and animates movement\n        path = [q_goal]\n        while path[-1].parents:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        path.reverse()\n\n        # Path shortcutting\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import math\n\n        start_time = time()\n        max_duration = 60  # seconds\n        max_iterations = 20000\n\n        # Initialize cost for root start and goal vertices\n        self._graph.root_vertex_start.cost = 0\n        self._graph.root_vertex_goal.cost = float(\"inf\")\n\n        for iteration in range(max_iterations):\n            if time() - start_time > max_duration:\n                # Fail gracefully if timeout reached\n                return\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_edge_len)\n\n            # Check feasibility of new edge\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Add the new vertex and find neighbors for rewiring\n            self._graph.root_vertices.append(q_new)\n            q_near_list = self._near(q_new, radius=self._max_radius)\n\n            # Choose parent and rewire neighbors to minimize cost\n            self._choose_parent_and_rewire(q_new, q_near_list)\n\n            # Check if new vertex reaches goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect goal vertex, update cost, extract path and exit\n                self._graph.add_edge(q_new, self._graph.root_vertex_goal)\n                self._graph.root_vertex_goal.cost = getattr(q_new, \"cost\", float(\"inf\")) + self._get_grid().get_movement_cost(q_new.position, self._graph.root_vertex_goal.position)\n                self._extract_path_and_animate(self._graph.root_vertex_goal)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 215, in __run_simulation\n    sim: Simulator = Simulator(Services(config))\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 40, in __init__\n    self.__setup(config)\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 68, in __setup\n    self.__algorithm_runner.reset_algorithm()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\algorithm_runner.py\", line 59, in reset_algorithm\n    self.__algorithm = self.__algorithm_type(self._services, testing, *self.__algorithm_parameters[0],\n  File \"<string>\", line 58, in __init__\n  File \"<string>\", line 72, in _get_random_sample\nAttributeError: 'PathPlanning' object has no attribute '_graph'\n"
     }
}
{
     "operator": "m2",
     "algorithm": "This improved path planning algorithm is a hybrid sample-based planner that blends RRT* style incremental tree construction\n    with informed sampling and rewiring heuristics for path quality improvement. It uses dynamic radius computation based on the \n    current graph size and environment scale to maintain efficient exploration and exploitation balance.\n    \n    Key Features:\n    - Adaptive sampling domain focused near start-goal elliptical region for efficiency.\n    - Use of cost-to-come and cost-to-go estimates for vertex rewiring (improves path quality).\n    - Dynamic neighborhood radius adjustment (to balance connectivity and complexity).\n    - Time-bounded search: stops planning if >60 seconds to prevent excessive computation.\n    - Edge validation using Bresenham line and environment collision checks.\n    - Path extraction includes backward traversal from goal to start.\n    - Smooth path by rewiring existing vertices when a better parent is found.\n    - Pruned search on goal proximity: when a vertex is close enough, attempts connection to goal.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_iterations: int\n    _max_radius: float\n    _max_extend_length: float\n    _start_time: float\n    _time_limit_sec: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_iterations = 20000\n        self._time_limit_sec = 60.0  # 1 minute limit\n        size = self._get_grid().size\n        # Max extend length relative to grid diagonal, capped limits\n        self._max_extend_length = max(5.0, min(20.0, (size.width ** 2 + size.height ** 2) ** 0.5 / 20))\n        self._max_radius = max(10.0, min(25.0, (size.width ** 2 + size.height ** 2) ** 0.5 / 4))\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Use informed sampling within an ellipse around start and goal to accelerate convergence.\n        If no solution found yet, sample uniformly.\n        \"\"\"\n        grid = self._get_grid()\n        start = grid.agent.position.to_tensor()\n        goal = grid.goal.position.to_tensor()\n\n        if not hasattr(self, '_best_cost') or self._best_cost is None:\n            # Uniform sampling\n            while True:\n                coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        dist_start_goal = torch.norm(goal - start).item()\n        c_best = self._best_cost\n        if c_best == float('inf') or c_best < dist_start_goal:\n            c_best = dist_start_goal * 1.5\n\n        # Sample within ellipse between start and goal defined by c_best\n        while True:\n            # Sample random point in unit circle (2D)\n            r1 = torch.rand(1).item()\n            r2 = torch.rand(1).item()\n            angle = 2 * 3.141592653589793 * r2\n            radius = r1 ** 0.5\n            x = radius * torch.cos(torch.tensor(angle)).item()\n            y = radius * torch.sin(torch.tensor(angle)).item()\n\n            # Scale factors of ellipse axis\n            a = c_best / 2.0\n            b = (c_best ** 2 - dist_start_goal ** 2) ** 0.5 / 2.0\n\n            # Rotate and translate ellipse point to map frame\n            direction = goal - start\n            unit_dir = direction / dist_start_goal\n            rot_matrix = torch.tensor([[unit_dir[0], -unit_dir[1]],\n                                       [unit_dir[1],  unit_dir[0]]])\n\n            sample_local = torch.tensor([a * x, b * y])\n            sample_global = start[:2] + torch.matmul(rot_matrix, sample_local)\n\n            # Clamp to map bounds and round to nearest int point for grid index\n            sx = int(max(0, min(self._get_grid().size.width - 1, round(sample_global[0].item()))))\n            sy = int(max(0, min(self._get_grid().size.height - 1, round(sample_global[1].item()))))\n            sample_pt = Point(sx, sy)\n\n            if self._get_grid().is_agent_valid_pos(sample_pt):\n                return sample_pt\n\n    def _steer(self, q_near: Vertex, q_rand: Point) -> Vertex:\n        \"\"\"\n        Produce a new vertex in the direction from q_near to q_rand but limited by max_extend_length.\n        \"\"\"\n        dir_vec = q_rand.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= self._max_extend_length:\n            return Vertex(q_rand)\n        dir_unit = dir_vec / dist\n        new_pos = q_near.position.to_tensor() + self._max_extend_length * dir_unit\n        new_pt = Point.from_tensor(new_pos)\n        return Vertex(new_pt)\n\n    def _get_nearby_vertices(self, v: Vertex) -> List[Vertex]:\n        \"\"\"\n        Return the vertices within the dynamic radius for possible rewiring.\n        Radius adapts to node density: r = min(max_radius, gamma * (log(n)/n)^{1/d}),\n        here approximated by a constant max_radius for complexity.\n        \"\"\"\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, v.position, self._max_radius)\n\n    def _cost(self, v_from: Vertex, v_to: Vertex) -> float:\n        return self._get_grid().get_movement_cost(v_from.position, v_to.position)\n\n    def _choose_parent(self, q_new: Vertex, nearby_vertices: List[Vertex]) -> Optional[Vertex]:\n        \"\"\"\n        Choose a parent for new vertex from nearby vertices minimizing cost-to-come + cost edge.\n        \"\"\"\n        min_cost = float('inf')\n        best_parent = None\n        for v in nearby_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            new_cost = v.cost + self._cost(v, q_new)\n            if new_cost < min_cost:\n                min_cost = new_cost\n                best_parent = v\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, nearby_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Attempt to update the cost and parent of nearby vertices through q_new if it improves the cost-to-come.\n        \"\"\"\n        for v in nearby_vertices:\n            if v is q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            potential_cost = q_new.cost + self._cost(q_new, v)\n            if potential_cost < v.cost:\n                # Rewire: update parent link\n                # Remove old edges from parents and add new edges for consistency\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = potential_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        \"\"\"\n        Extract the best path by tracing backwards parents from goal vertex.\n        \"\"\"\n        path: List[Vertex] = [q_goal]\n        current = q_goal\n        while current.position != self._graph.root_vertex_start.position:\n            parents = list(current.parents)\n            if not parents:\n                break\n            # Since it's a tree, expect one parent\n            current = parents[0]\n            path.append(current)\n        path.reverse()\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _update_best_cost(self, q_new: Vertex) -> None:\n        \"\"\"\n        Update the global best cost if q_new improves the current value.\n        \"\"\"\n        dist_to_goal = Map.get_distance(q_new.position, self._graph.root_vertex_goal.position)\n        cost_estimate = q_new.cost + dist_to_goal\n        if not hasattr(self, '_best_cost') or cost_estimate < self._best_cost:\n            self._best_cost = cost_estimate\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n        root_start = self._graph.root_vertex_start\n        root_goal = self._graph.root_vertex_goal\n\n        root_start.cost = 0.0\n        root_goal.cost = float('inf')\n        self._best_cost = float('inf')\n\n        for iteration in range(self._max_iterations):\n\n            if time.time() - self._start_time > self._time_limit_sec:\n                # Planning failed due to time constraint\n                return\n\n            q_rand = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_rand)\n            q_new = self._steer(q_near, q_rand)\n\n            if q_new.position == q_near.position:\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find nearby vertices for parent selection and rewiring\n            neighbor_vertices = self._get_nearby_vertices(q_new)\n\n            parent = self._choose_parent(q_new, [q_near] + neighbor_vertices)\n            if parent is None:\n                continue\n\n            q_new.cost = parent.cost + self._cost(parent, q_new)\n            self._graph.add_edge(parent, q_new)\n\n            # Rewire nearby nodes for better paths\n            self._rewire(q_new, neighbor_vertices)\n\n            # Add the new vertex to root vertices for expanded search\n            self._graph.root_vertices.append(q_new)\n\n            # Check if goal can be connected/improved from q_new\n            dist_to_goal = Map.get_distance(q_new.position, root_goal.position)\n            if dist_to_goal <= self._max_extend_length:\n                line_to_goal = self._get_grid().get_line_sequence(q_new.position, root_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_to_goal):\n                    # Connect goal to q_new with an edge if better\n                    new_goal_cost = q_new.cost + self._cost(q_new, root_goal)\n                    if new_goal_cost < root_goal.cost:\n                        # Remove old parents of goal to keep single best\n                        for p in list(root_goal.parents):\n                            self._graph.remove_edge(p, root_goal)\n                        root_goal.cost = new_goal_cost\n                        self._graph.add_edge(q_new, root_goal)\n                        self._update_best_cost(root_goal)\n\n                        # Extract path and return success\n                        self._extract_path(root_goal)\n                        return\n\n            self._update_best_cost(q_new)\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 216, in _find_path_internal\n  File \"<string>\", line 113, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This is an enhanced anytime, asymptotically optimal sample-based path planning algorithm named\n    \"ANYTIME RRT*-SMART\" designed to improve planning efficiency, path quality, robustness,\n    success rate, path smoothness, and path length while reducing overall search time.\n\n    It uses a forest structure (similar to RRT*) and incorporates the following innovations:\n    - Adaptive sampling biased toward the goal and lower-cost vertices to improve convergence speed.\n    - Sample pruning to remove vertices unlikely to improve the path (focused search).\n    - A path shortcutting post-process on found paths to smooth and shorten the trajectory.\n    - A time-bound search with a hard limit of 60 seconds to guarantee responsiveness.\n    - Dynamic radius selection using RRT* radius scaling for rewiring.\n    - Cost-aware rewiring of the graph for asymptotic optimality.\n    - Early termination when a feasible path is found and improved sufficiently.\n\n    The algorithm maintains a forest rooted at start and goal and grows the graph iteratively.\n    Sampling is biased towards the goal and sampled vertices close to the current best path.\n\n    On success, the path is extracted and shortened with shortcuts to produce a smooth and\n    quality trajectory.\n\n    Overall, this approach aims to balance exploration and exploitation, quickly find feasible\n    paths, and continue improving them within a time budget.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        # Empty initial vertices, will build as we sample\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        self._max_dist = 12.0  # max extension step length\n        self._dim = self._get_grid().size.n_dim\n        self._goal_sample_rate = 0.1  # Probability of sampling the goal directly\n        self._max_runtime = 60.0  # seconds: hard stop for planning\n        self._lambda_rrt_star = 50.0  # constant for radius calculation\n\n        self._best_goal_vertex: Optional[Vertex] = None  # best vertex reaching goal\n        self._init_displays()\n\n    def _get_random_sample(self, bias_to_goal=False) -> Point:\n        \"\"\"\n        Samples a random valid point inside the grid.\n        If bias_to_goal is True, samples exactly the goal position.\n        \"\"\"\n        if bias_to_goal:\n            return self._get_grid().goal.position\n        while True:\n            # Sample uniformly in n dimensions within grid bounds\n            vals = [int(torch.randint(0, self._get_grid().size[i], (1,)).item()) for i in range(self._dim)]\n            p = Point(*vals)\n            if self._get_grid().is_agent_valid_pos(p):\n                return p\n\n    def _steer(self, q_near: Vertex, q_rand: Point, max_dist: float) -> Optional[Vertex]:\n        \"\"\"\n        Returns a new vertex in the direction of q_rand from q_near at distance max_dist if\n        q_rand is farther than max_dist; else returns new vertex at q_rand (if valid).\n        \"\"\"\n        vec = q_rand.to_tensor() - q_near.position.to_tensor()\n        dist = float(torch.norm(vec))\n        if dist == 0:\n            return None\n        if dist <= max_dist:\n            new_pos = q_rand\n        else:\n            direction = vec / dist\n            new_pos_t = q_near.position.to_tensor() + max_dist * direction\n            new_pos = Point.from_tensor(new_pos_t)\n\n        if not self._get_grid().is_agent_valid_pos(new_pos):\n            return None\n        # Verify line between q_near and new_pos is free\n        line_seq = self._get_grid().get_line_sequence(q_near.position, new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        return Vertex(new_pos)\n\n    def _get_neighbors(self, v: Vertex, radius: float) -> List[Vertex]:\n        # Return vertices within radius from v to consider for rewiring\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], v.position, radius)\n\n    def _cost(self, frm: Point, to: Point) -> float:\n        # Cost function = Euclidean distance (can be adjusted if needed)\n        return float(torch.norm(frm.to_tensor() - to.to_tensor()))\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> (Optional[Vertex], float):\n        \"\"\"\n        Choose the best parent for q_new among neighbors minimizing cost + edge cost,\n        and valid collision-free path.\n        \"\"\"\n        c_min = math.inf\n        q_min = None\n        for q_near in neighbors:\n            # Check line collision between q_near and q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cost = q_near.cost + self._cost(q_near.position, q_new.position)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n        return q_min, c_min\n\n    def _rewire(self, neighbors: List[Vertex], q_new: Vertex) -> None:\n        \"\"\"\n        For each neighbor, check if path cost can be reduced by rewiring through q_new.\n        \"\"\"\n        for q_near in neighbors:\n            if q_near is q_new.parents:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_new = q_new.cost + self._cost(q_new.position, q_near.position)\n            if cost_new < q_near.cost:\n                # Remove old edges\n                old_parents = list(q_near.parents)\n                for old_parent in old_parents:\n                    self._graph.remove_edge(old_parent, q_near)\n                # Add new edge\n                q_near.cost = cost_new\n                self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Point]:\n        \"\"\"\n        Extracts the path from start to the given goal vertex by parents chain.\n        Returns list of Points from start to goal.\n        \"\"\"\n        path_vertices = []\n        current = goal_vertex\n        while current:\n            path_vertices.append(current)\n            if len(current.parents) == 0:\n                break\n            # We choose one parent (e.g. first) since this is a tree\n            current = next(iter(current.parents))\n        path_vertices.reverse()\n        return [v.position for v in path_vertices]\n\n    def _shortcut_path(self, path: List[Point], max_iterations=50) -> List[Point]:\n        \"\"\"\n        Applies simple shortcutting heuristic by attempting to replace intermediate points with\n        direct edges if they are collision free, repeated max_iterations times.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        for _ in range(max_iterations):\n            if len(path) < 3:\n                break\n            # Pick two indices i,j with j>i+1\n            i = int(torch.randint(0, len(path) - 2, (1,)).item())\n            j = int(torch.randint(i + 2, len(path), (1,)).item())\n\n            if j >= len(path) or i < 0 or i >= j:\n                continue\n            start = path[i]\n            end = path[j]\n            line_seq = self._get_grid().get_line_sequence(start, end)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                # Remove intermediate points between i and j\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        iterations = 0\n        max_iterations = 20000  # Cap to prevent infinite loops if time runs long\n        found_path = False\n        best_cost = math.inf\n\n        while True:\n            elapsed = time.time() - start_time\n            if elapsed > self._max_runtime:\n                # Fail and stop search if time exceeded\n                break\n            if iterations >= max_iterations:\n                break\n\n            iterations += 1\n\n            # Sampling: With probability goal_sample_rate sample goal, otherwise random\n            sample_goal_bias = torch.rand(1).item() < self._goal_sample_rate\n            q_sample = self._get_random_sample(bias_to_goal=sample_goal_bias)\n\n            # Nearest vertex in tree to sample\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n            # Steer towards q_sample from q_nearest with max extension limit\n            q_new = self._steer(q_nearest, q_sample, self._max_dist)\n            if q_new is None:\n                continue\n\n            # Determine radius for neighbor search (RRT* formula)\n            card_v = float(self._graph.size + 1)  # +1 to avoid log(0)\n            radius = min(self._lambda_rrt_star * ((math.log(card_v) / card_v) ** (1 / self._dim)), self._max_dist * 5)\n\n            # Find neighbors in radius\n            neighbors = self._get_neighbors(q_new, radius)\n\n            # Choose best parent among neighbors\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                # If no suitable parent found, abandon q_new\n                continue\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors through q_new if better\n            self._rewire(neighbors, q_new)\n\n            # Add new vertex to roots to keep track\n            self._graph.root_vertices.append(q_new)\n\n            # Check if q_new can connect to goal directly and improve path cost\n            dist_to_goal = float(torch.norm(q_new.position.to_tensor() - self._graph.root_vertex_goal.position.to_tensor()))\n            if dist_to_goal <= self._max_dist:\n                # Check collision to goal\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, self._graph.root_vertex_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    cost_to_goal = q_new.cost + dist_to_goal\n                    if cost_to_goal < best_cost:\n                        best_cost = cost_to_goal\n                        goal_vertex = Vertex(self._graph.root_vertex_goal.position)\n                        goal_vertex.cost = cost_to_goal\n                        self._graph.add_edge(q_new, goal_vertex)\n                        self._best_goal_vertex = goal_vertex\n                        self._graph.root_vertices.append(goal_vertex)\n                        found_path = True\n\n                        # If path is found, optionally run keyframe for visualization\n                        self.key_frame()\n\n            self.key_frame()\n\n            # Early stop if a good enough path is found (e.g. cost < threshold)\n            if found_path and best_cost < self._max_dist * 4:\n                break\n\n        # If a path was found, extract and shortcut path, then follow it\n        if found_path and self._best_goal_vertex is not None:\n            path = self._extract_path(self._best_goal_vertex)\n            path = self._shortcut_path(path, max_iterations=100)\n            for p in path:\n                self.move_agent(p)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 211, in _find_path_internal\n  File \"<string>\", line 73, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m1",
     "algorithm": "This algorithm integrates and improves upon sampling-based algorithms like RRT and SPRM,\n    combining efficient exploration with intelligent rewiring for optimal path quality.\n    It does the following:\n    - Uses informed sampling biased towards the goal to improve convergence speed.\n    - Uses a variable radius nearest neighbor search for rewiring to improve path quality.\n    - Employs a cost-to-come plus heuristic cost-to-go for vertex cost and prioritization.\n    - Uses early stopping when goal is reached.\n    - Uses a timestamp to terminate if planning exceeds 60 seconds.\n    - After finding the path, performs a path smoothing step to reduce sharp turns.\n    - Stores connectivity in a cyclic graph structure for rewiring edges.\n    - Supports 2D or higher dimensional maps.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius_init: float\n    _max_step: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._V_size = 300   # reasonable number of vertices\n        self._max_step = 12.0\n        self._max_radius_init = 20.0\n        V: List[Vertex] = list()\n\n        # start and goal vertices with connectivity info\n        start_v = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_v = Vertex(self._get_grid().goal.position, store_connectivity=True)\n\n        # Pre-fill samples biased toward goal region for informed exploration\n        for i in range(self._V_size):\n            V.append(self._sample_informed(goal_v.position))\n        self._graph = gen_cyclic_graph(self._services, start_v, goal_v, V)\n        self._graph.edges_removable = True  # allow rewiring for optimization\n\n        # Initialize cost of start vertex as 0, others as inf\n        start_v.cost = 0.0\n        for v in self._graph.root_vertices:\n            if v is not start_v:\n                v.cost = float('inf')\n\n        self._init_displays()\n\n    def _sample_informed(self, goal_pos: Point) -> Point:\n        \"\"\"Sample a point biased toward the goal, with fallback to uniform random if needed.\"\"\"\n        g = goal_pos\n        map_size = self._get_grid().size\n        for _ in range(10):\n            # Informed sampling: sample a point in an ellipse or near goal region\n            # For simplicity, here bias sampling toward goal +/- radius region\n            delta = 10\n            low = [max(0, g[i] - delta) for i in range(map_size.n_dim)]\n            high = [min(map_size[i] - 1, g[i] + delta) for i in range(map_size.n_dim)]\n\n            coords = []\n            for dim in range(map_size.n_dim):\n                val = int(torch.randint(low[dim], high[dim] + 1, (1,)).item())\n                coords.append(val)\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n        # fallback: uniform random valid sample\n        while True:\n            sample = Point(*[torch.randint(0, map_size[i], (1,)).item() for i in range(map_size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _get_nearest_vertex(self, vertices: List[Vertex], point: Point) -> Optional[Vertex]:\n        best_vertex = None\n        best_dist = float('inf')\n        for v in vertices:\n            dist = self._distance(v.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best_vertex = v\n        return best_vertex\n\n    def _get_near_vertices(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        near = []\n        for v in vertices:\n            if self._distance(v.position, point) <= radius:\n                near.append(v)\n        return near\n\n    def _steer(self, from_v: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        direction = to_point.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            return Vertex(to_point, store_connectivity=True)\n        direction_normalized = direction / dist\n        new_pos_tensor = from_v.position.to_tensor() + max_dist * direction_normalized\n        new_point = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_point, store_connectivity=True)\n\n    def _reconstruct_path(self, goal_vertex: Vertex) -> List[Vertex]:\n        path = []\n        current = goal_vertex\n        # Follow parents with minimal cost path backward to root start vertex\n        while True:\n            path.append(current)\n            if not current.parents or any(p.cost == 0 for p in current.parents):\n                break\n            # proceed to parent with lowest cost\n            min_parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            current = min_parent\n        path.reverse()\n        return path\n\n    def _line_collision_free(self, start: Point, end: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(start, end)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _path_smoothing(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"Attempt to smooth path by shortcutting between vertices skipping intermediates.\"\"\"\n        if len(path) <= 2:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_collision_free(path[i].position, path[j].position):\n                    smoothed.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # no shortcut found, just add next vertex\n                smoothed.append(path[i + 1])\n                i += 1\n        return smoothed\n\n    # Overridden implementation #\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        start_v = self._graph.root_vertex_start\n        goal_v = self._graph.root_vertex_goal\n\n        # Add start & goal to root_vertices if missing\n        if start_v not in self._graph.root_vertices:\n            self._graph.root_vertices.insert(0, start_v)\n        if goal_v not in self._graph.root_vertices:\n            self._graph.root_vertices.append(goal_v)\n\n        all_vertices = self._graph.root_vertices + self._graph.root_vertices[2:]  # start, goal + V\n\n        max_iter = 12000\n        radius_factor = 50.0  # controls rewiring radius scaling\n        dimension = self._get_grid().size.n_dim\n\n        for iter_idx in range(max_iter):\n\n            # Timeout fail check (60 seconds)\n            if time.time() - start_time > 60.0:\n                # Treat as fail: no path found in time\n                return\n\n            # Sample a point biased towards goal region\n            q_rand = self._sample_informed(goal_v.position)\n            # Find nearest vertex in graph\n            q_near = self._get_nearest_vertex(all_vertices, q_rand)\n            if q_near is None:\n                continue\n\n            # Steer toward sample with max step size\n            q_new = self._steer(q_near, q_rand, self._max_step)\n\n            # Check validity of path q_near to q_new\n            if not self._line_collision_free(q_near.position, q_new.position):\n                continue\n\n            # Calculate tentative cost to reach q_new through q_near\n            cost_to_q_new = (q_near.cost if q_near.cost is not None else float('inf')) + \\\n                            self._distance(q_near.position, q_new.position)\n            # If q_new already exists in graph (approximate), skip to avoid duplicates\n            overlap_vertices = [v for v in all_vertices if v.position == q_new.position]\n            if overlap_vertices:\n                # May try to rewire the vertex if this path better\n                existing_v = overlap_vertices[0]\n                if cost_to_q_new < (existing_v.cost if existing_v.cost is not None else float('inf')):\n                    existing_v.cost = cost_to_q_new\n                    # Change parents to q_near\n                    for p in list(existing_v.parents):\n                        existing_v.parents.remove(p)\n                        p.children.remove(existing_v)\n                    existing_v.add_parent(q_near)\n                    q_near.add_child(existing_v)\n                continue\n\n            # Assign cost & add q_new to graph connected from q_near\n            q_new.cost = cost_to_q_new\n            self._graph.root_vertices.append(q_new)\n            all_vertices.append(q_new)\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire neighbors within radius around q_new to possibly improve cost\n            radius = radius_factor * ( (np.log(len(all_vertices)) / len(all_vertices)) ** (1 / dimension) )\n            radius = max(radius, self._max_step)  # radius never below step size\n            near_vertices = self._get_near_vertices(all_vertices, q_new.position, radius)\n\n            for q_nearby in near_vertices:\n                if q_nearby is q_new or q_nearby is q_near:\n                    continue\n                # Check if edge q_new->q_nearby would improve cost and is feasible\n                if not self._line_collision_free(q_new.position, q_nearby.position):\n                    continue\n                cost_thru_q_new = q_new.cost + self._distance(q_new.position, q_nearby.position)\n                if cost_thru_q_new < (q_nearby.cost if q_nearby.cost is not None else float('inf')):\n                    # Rewire q_nearby parent from old parent to q_new\n                    # Remove old parent edges\n                    for p in list(q_nearby.parents):\n                        p.children.discard(q_nearby)\n                    q_nearby.parents.clear()\n                    q_nearby.cost = cost_thru_q_new\n                    q_nearby.add_parent(q_new)\n                    q_new.add_child(q_nearby)\n                    # If graph supports edges removal, remove old edges and add new edges\n                    try:\n                        self._graph.add_edge(q_new, q_nearby)\n                    except Exception:\n                        pass\n\n            # Try connecting q_new directly to goal if possible and update cost if better\n            if self._distance(q_new.position, goal_v.position) <= self._max_step:\n                if self._line_collision_free(q_new.position, goal_v.position):\n                    cost_to_goal_through_q_new = q_new.cost + self._distance(q_new.position, goal_v.position)\n                    if cost_to_goal_through_q_new < (goal_v.cost if goal_v.cost is not None else float('inf')):\n                        for p in list(goal_v.parents):\n                            p.children.discard(goal_v)\n                        goal_v.parents.clear()\n                        goal_v.cost = cost_to_goal_through_q_new\n                        goal_v.add_parent(q_new)\n                        q_new.add_child(goal_v)\n\n            # If goal reached and has a valid cost, extract and smooth path\n            if goal_v.cost is not None and goal_v.cost < float('inf') and len(goal_v.parents) > 0:\n                path = self._reconstruct_path(goal_v)\n                path = self._path_smoothing(path)\n\n                # Animate moving the agent along path\n                for v in path:\n                    self.move_agent(v.position)\n                    self.key_frame(ignore_key_frame_skip=True)\n                return\n\n            # key frame for display update per iteration\n            if iter_idx % 10 == 0:\n                self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 215, in __run_simulation\n    sim: Simulator = Simulator(Services(config))\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 40, in __init__\n    self.__setup(config)\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 68, in __setup\n    self.__algorithm_runner.reset_algorithm()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\algorithm_runner.py\", line 59, in reset_algorithm\n    self.__algorithm = self.__algorithm_type(self._services, testing, *self.__algorithm_parameters[0],\n  File \"<string>\", line 60, in __init__\n  File \"<string>\", line 88, in _sample_informed\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is a hybrid informed RRT* variant with adaptive sampling and smoothing.\n    It improves planning efficiency and path quality by guiding the search within an \n    ellipsoidal informed subset of the space (informed sampling), dynamically adjusting \n    the search radius based on vertex density, and applying iterative smoothing when \n    the goal is reached. It uses a best-first priority queue expansion to favor low-cost \n    vertices, combined with rewiring for optimality. A timeout of 60 seconds is enforced \n    with failure notification. This balances robustness, success rate, path smoothness, \n    search time, and path length improvements.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _max_radius: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _max_time_sec: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 12.0\n        self._max_radius = 30.0\n        self._lambda_rrt_star = 50.0\n        self._dimension = self._get_grid().size.n_dim\n        self._max_time_sec = 60.0  # maximum allowed time in seconds\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    def _get_random_sample_informed(self, c_best: Optional[float]) -> Point:\n        \"\"\"\n        Informed sampling inside an ellipsoid defined by start, goal, and current best cost.\n        If no path found yet (c_best is None), sample uniformly.\n        \"\"\"\n        agent_pos = self._get_grid().agent.position.to_tensor()\n        goal_pos = self._get_grid().goal.position.to_tensor()\n\n        if c_best is None:\n            # Uniform sampling until a valid sample is found\n            while True:\n                coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n                sample = Point(*coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Informed sampling inside ellipsoid\n            c_min = torch.norm(goal_pos - agent_pos)\n            if c_best < c_min:\n                # rare case, fall back to uniform sampling\n                return self._get_random_sample_uniform()\n\n            # Center of ellipse\n            center = (agent_pos + goal_pos) / 2.0\n            a1 = (goal_pos - agent_pos) / c_min  # unit vector from start to goal\n\n            # Create orthonormal basis via SVD\n            U, _, _ = torch.svd(torch.eye(self._dimension) - a1.unsqueeze(1) @ a1.unsqueeze(0), some=True)\n            C = torch.cat([a1.unsqueeze(1), U[:, 1:].contiguous()], dim=1)\n\n            # Radius in each dimension\n            r1 = c_best / 2.0\n            r2 = torch.sqrt(c_best**2 - c_min**2) / 2.0\n\n            radii = torch.ones(self._dimension)\n            radii[0] = r1\n            radii[1:] = r2\n\n            for _ in range(1000):  # max attempts for valid sample\n                # Sample inside unit ball\n                direction = torch.randn(self._dimension)\n                direction /= torch.norm(direction)\n                radius = torch.rand(1).item() ** (1 / self._dimension)\n                rnd_ball = direction * radius\n\n                # Transform to ellipsoid space\n                sample_tensor = center + (C @ (radii * rnd_ball))\n\n                sample_point = Point(*[int(torch.clamp(x, 0, self._get_grid().size[i] - 1).item()) for i, x in enumerate(sample_tensor)])\n                if self._get_grid().is_agent_valid_pos(sample_point):\n                    return sample_point\n\n            # fallback uniform sample if fails\n            return self._get_random_sample_uniform()\n\n    def _get_random_sample_uniform(self) -> Point:\n        while True:\n            coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        dir_vector = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vector)\n        if dist == 0:\n            return None  # Same position\n\n        if dist <= max_dist:\n            p = q_sample\n        else:\n            dir_norm = dir_vector / dist\n            new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_norm\n            coords = [int(torch.clamp(c, 0, self._get_grid().size[i] - 1).item()) for i, c in enumerate(new_pos_tensor)]\n            p = Point(*coords)\n\n        if not self._get_grid().is_agent_valid_pos(p):\n            return None\n\n        # Check path collision between q_near and p\n        line_seq = self._get_grid().get_line_sequence(q_near.position, p)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        return Vertex(p)\n\n    def _extract_path(self, last_vertex: Vertex):\n        # Reconstruct path from last_vertex to root\n        path = [last_vertex]\n        current = last_vertex\n        while current != self._graph.root_vertex_start and current.parents:\n            # Choose parent with lowest cost\n            current = min(current.parents, key=lambda v: v.cost if v.cost is not None else float('inf'))\n            path.append(current)\n        path.reverse()\n\n        # Smoothed path by shortcutting\n        smooth_path = self._short_cut_path(path)\n\n        for vertex in smooth_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _short_cut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Attempt to shortcut path segments to improve smoothness.\n        \"\"\"\n        if len(path) <= 2:\n            return path\n\n        new_path = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path\n\n    def _rewire(self, q_new: Vertex, Q_near: List[Vertex]) -> None:\n        for q_near in Q_near:\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cost_through_new = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            if q_near.cost is None or cost_through_new < q_near.cost:\n                # Remove old parent edge\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                # Add new parent edge\n                q_near.cost = cost_through_new\n                self._graph.add_edge(q_new, q_near)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        c_best = None  # best path cost found so far\n        best_last_vertex = None\n\n        priority_queue: List[Tuple[float, Vertex]] = []\n        heapq.heappush(priority_queue, (self._graph.root_vertex_start.cost, self._graph.root_vertex_start))\n\n        max_iterations = 15000\n        while time.time() - start_time < self._max_time_sec and max_iterations > 0:\n\n            max_iterations -= 1\n\n            # Sample informed or uniform depending on whether a path was found\n            q_sample = self._get_random_sample_informed(c_best)\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            if q_new is None:\n                continue\n\n            # Find neighbors within a radius adaptively\n            card_v = torch.tensor(float(self._graph.size + 1))\n            log_card = torch.log(card_v)\n            radius = min(self._lambda_rrt_star * torch.pow(log_card / card_v, 1 / self._dimension), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent that minimizes cost to q_new\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost_through_near = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if cost_through_near < c_min:\n                    q_min = q_near\n                    c_min = cost_through_near\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if it reduces cost\n            self._rewire(q_new, Q_near)\n\n            # Add q_new to priority queue for best-first expansion\n            heapq.heappush(priority_queue, (q_new.cost, q_new))\n\n            # Check goal proximity\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                dist_to_goal = torch.norm(q_new.position.to_tensor() - self._get_grid().goal.position.to_tensor())\n                total_cost = q_new.cost + dist_to_goal\n                if c_best is None or total_cost < c_best:\n                    # Update best solution\n                    c_best = total_cost\n                    best_last_vertex = q_new\n\n            self.key_frame()\n\n        if best_last_vertex is not None:\n            self._extract_path(best_last_vertex)\n        else:\n            # No path found within time limit\n            # Optionally mark failure or halt gracefully here\n            # We do not move the agent\n            return",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 215, in _find_path_internal\nNameError: name 'heapq' is not defined\n"
     }
}
{
     "operator": "e2",
     "algorithm": "This algorithm is a hybrid path planner combining strengths of RRT-Connect and informed sampling methods for\n    improved efficiency, path quality, robustness, and success rate. It uses bidirectional trees growing towards sampled\n    points with adaptive pruning and rewiring inspired by RRT* concepts, ensuring smoother, shorter paths.\n    It employs heuristic informed sampling biased towards the goal neighborhood for faster convergence.\n    The planner dynamically shortens and smooths the path during extraction.\n    A 60-second timeout guards against excessive computation time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _timeout_sec: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n        self._max_dist = max(self._get_grid().size.width, self._get_grid().size.height) / 20.0\n        self._iterations = 15000\n        self._timeout_sec = 60.0\n\n    def _get_random_sample_informed(self, c_best: Optional[float]) -> Point:\n        \"\"\"Informed sampling within an ellipse bounded by current best path length c_best.\"\"\"\n        grid = self._get_grid()\n        start = grid.agent.position.to_tensor()\n        goal = grid.goal.position.to_tensor()\n        n_dim = start.shape[0]\n\n        if c_best is None or c_best >= float('inf'):\n            # Uniform sample in space\n            while True:\n                rand_pos = torch.tensor([np.random.randint(0, s) for s in grid.size.values], dtype=torch.float32)\n                sample = Point(*rand_pos.int().tolist())\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Sample inside prolate hyperspheroid ellipse biasing toward goal\n            c_min = (goal - start).norm().item()\n            if c_min < 1e-6:\n                return Point(*goal.int().tolist())\n\n            # Transformation matrix for unit ball to ellipse\n            a1 = (goal - start) / c_min  # unit vector from start to goal\n            I = torch.eye(n_dim)\n            M = a1.unsqueeze(1) @ a1.unsqueeze(0)\n            U = I - M  # orthogonal complement projection\n\n            # Radii of ellipse along axes\n            r1 = c_best / 2.\n            r2 = (c_best ** 2 - c_min ** 2) ** 0.5 / 2.\n\n            while True:\n                # Sample unit ball\n                direction = torch.randn(n_dim)\n                direction /= direction.norm()\n                radius = torch.rand(1).item() ** (1.0 / n_dim)\n                unit_ball_sample = radius * direction\n\n                # Map unit ball sample to ellipse sample\n                ellipse_sample = r1 * a1 + r2 * (U @ unit_ball_sample)\n                sample_pt = (ellipse_sample + (start + goal) / 2.)\n                sample_int = Point(*sample_pt.round().int().tolist())\n\n                if all(0 <= sample_int[i] < s for i, s in enumerate(self._get_grid().size.values)) and grid.is_agent_valid_pos(sample_int):\n                    return sample_int\n\n    def _get_nearest_vertex(self, root_vertices: List[Vertex], point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(root_vertices, point)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Optional[Vertex]:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = dir_vec.norm().item()\n        if dist < 1e-6:\n            return None\n\n        if dist <= self._max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / dist\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_pos_int = Point(*new_pos_tensor.round().int().tolist())\n            q_new_pos = new_pos_int\n\n        if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new_pos)):\n            return None\n\n        return Vertex(q_new_pos)\n\n    def _add_vertex_with_rewiring(self, q_new: Vertex, root_vertices: List[Vertex]) -> None:\n        \"\"\"Add vertex and connect with minimal cost parent within radius; rewire neighbors for better paths.\"\"\"\n        grid = self._get_grid()\n        neighborhood_radius = self._max_dist * 2.5\n\n        # Find neighbors within radius\n        neighbors = self._graph.get_vertices_within_radius(root_vertices, q_new.position, neighborhood_radius)\n        if not neighbors:\n            # Connect to nearest vertex if no neighbors\n            q_near = self._get_nearest_vertex(root_vertices, q_new.position)\n            self._graph.add_edge(q_near, q_new)\n            q_new.cost = (q_near.cost if q_near.cost is not None else 0) + grid.get_movement_cost(q_near.position, q_new.position)\n            return\n\n        # Find best parent from neighbors minimizing cost+distance\n        best_parent = None\n        best_cost = float('inf')\n        cost_from_start = float('inf')\n        for neighbor in neighbors:\n            if neighbor.cost is None:\n                continue\n            tentative_cost = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new.position)\n            if tentative_cost < best_cost and self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position)):\n                best_cost = tentative_cost\n                best_parent = neighbor\n\n        if best_parent is None:\n            # fallback connect to nearest\n            q_near = self._get_nearest_vertex(root_vertices, q_new.position)\n            self._graph.add_edge(q_near, q_new)\n            q_new.cost = (q_near.cost if q_near.cost is not None else 0) + grid.get_movement_cost(q_near.position, q_new.position)\n            return\n\n        # Add edge from best parent\n        self._graph.add_edge(best_parent, q_new)\n        q_new.cost = best_cost\n\n        # Rewire neighbors if better through q_new\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            if neighbor.cost is None:\n                continue\n            cost_through_qnew = q_new.cost + grid.get_movement_cost(q_new.position, neighbor.position)\n            if cost_through_qnew < neighbor.cost and self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                # Remove old parent edges\n                for p in list(neighbor.parents):\n                    self._graph.remove_edge(p, neighbor)\n                # Add new better parent edge\n                self._graph.add_edge(q_new, neighbor)\n                neighbor.cost = cost_through_qnew\n\n    def _try_connect_trees(self) -> Optional[Tuple[Vertex, Vertex]]:\n        \"\"\"Try to connect root vertices of the two trees to form path, return connected vertices or None.\"\"\"\n        start_roots = [self._graph.root_vertex_start]\n        goal_roots = [self._graph.root_vertex_goal]\n\n        for sv in list(start_roots):\n            for gv in list(goal_roots):\n                if Map.get_distance(sv.position, gv.position) <= self._max_dist:\n                    # Check if can connect directly\n                    line_seq = self._get_grid().get_line_sequence(sv.position, gv.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        return sv, gv\n        return None\n\n    def _extract_path(self, connect_pair: Tuple[Vertex, Vertex]) -> None:\n        \"\"\"Extract and smooth path from start to goal through connected pair vertices, animate movement.\"\"\"\n        start_vertex, goal_vertex = connect_pair\n\n        # Trace backward from start vertex to root start\n        path_start = [start_vertex]\n        while len(path_start[-1].parents) != 0:\n            parent = next(iter(path_start[-1].parents))\n            path_start.append(parent)\n        path_start.reverse()\n\n        # Trace backward from goal vertex to root goal\n        path_goal = [goal_vertex]\n        while len(path_goal[-1].parents) != 0:\n            parent = next(iter(path_goal[-1].parents))\n            path_goal.append(parent)\n\n        # Combine paths\n        full_path = path_start + path_goal\n\n        # Attempt path smoothing by shortcutting intermediate points\n        smoothed_path = self._smooth_path(full_path)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"Attempt to shortcut path by checking if line between non-adjacent vertices is valid.\"\"\"\n        if len(path) < 3:\n            return path\n\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(path[i].position, path[j].position)):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _update_costs_on_root(self, root_vertex: Vertex) -> None:\n        \"\"\"Propagate costs from root vertex through children (BFS).\"\"\"\n        root_vertex.cost = 0\n        queue = [root_vertex]\n        while queue:\n            current = queue.pop(0)\n            for child in current.children:\n                cost = current.cost + self._get_grid().get_movement_cost(current.position, child.position)\n                if child.cost is None or cost < child.cost:\n                    child.cost = cost\n                    queue.append(child)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n\n        # Initialize costs for start and goal root vertices\n        self._graph.root_vertex_start.cost = 0\n        self._graph.root_vertex_goal.cost = 0\n\n        start_time = time.time()\n        best_path_cost = float('inf')\n        best_connect_pair = None\n\n        for i in range(self._iterations):\n            if time.time() - start_time > self._timeout_sec:\n                # Fail on timeout\n                break\n\n            c_best = best_path_cost if best_path_cost != float('inf') else None\n            # Sample point using informed sampling\n            q_rand = self._get_random_sample_informed(c_best)\n\n            # Select tree to extend (alternate or based on heuristic)\n            extend_tree_idx = i % 2\n            root_vertex = self._graph.root_vertices[extend_tree_idx]\n\n            q_near = self._get_nearest_vertex([root_vertex], q_rand)\n            q_new = self._get_new_vertex(q_near, q_rand)\n            if q_new is None:\n                self.key_frame()\n                continue\n\n            # Add vertex with rewiring to improve path quality in that tree\n            self._add_vertex_with_rewiring(q_new, [root_vertex])\n\n            # Update costs on this tree from root\n            self._update_costs_on_root(root_vertex)\n\n            # Try to connect the other tree to this newly added vertex\n            other_tree_root = self._graph.root_vertices[1 - extend_tree_idx]\n            q_near_other = self._get_nearest_vertex([other_tree_root], q_new.position)\n\n            dist = Map.get_distance(q_near_other.position, q_new.position)\n            if dist <= self._max_dist:\n                line_seq = grid.get_line_sequence(q_near_other.position, q_new.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Add connection edge\n                    self._graph.add_edge(q_near_other, q_new) if extend_tree_idx == 1 else self._graph.add_edge(q_new, q_near_other)\n\n                    # Update costs on other tree root after adding connection edge\n                    self._update_costs_on_root(other_tree_root)\n\n                    # Calculate combined path cost\n                    cost_start = self._graph.root_vertex_start.cost if self._graph.root_vertex_start.cost else 0\n                    cost_goal = self._graph.root_vertex_goal.cost if self._graph.root_vertex_goal.cost else 0\n                    total_cost = (q_new.cost if q_new.cost is not None else 0) + (q_near_other.cost if q_near_other.cost is not None else 0) + dist\n\n                    if total_cost < best_path_cost:\n                        best_path_cost = total_cost\n                        if extend_tree_idx == 0:\n                            best_connect_pair = (q_new, q_near_other)\n                        else:\n                            best_connect_pair = (q_near_other, q_new)\n\n                    # Extract and animate path\n                    if best_connect_pair:\n                        self._extract_path(best_connect_pair)\n                        break\n\n            # Alternate trees\n            self._graph.reverse_root_vertices()\n            self.key_frame()\n\n        # If no path found in time and best_connect_pair exists, extract it\n        if best_connect_pair:\n            self._extract_path(best_connect_pair)",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 265, in _find_path_internal\n  File \"<string>\", line 70, in _get_random_sample_informed\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "e2",
     "algorithm": "Hybrid Path Planning Algorithm combining RRT-Connect with Informed RRT* optimization and adaptive rewiring for improved path quality,\n    efficiency, and smoothness. The algorithm grows two trees from start and goal sampling biased regions, attempts to connect them efficiently,\n    and rewires vertices within dynamic radius. It uses adaptive sampling within elliptical informed subsets to reduce search space once initial path found,\n    incorporates collision checking with Bresenham's line, and terminates if no solution is found within 60 seconds to enhance robustness and reduce search time.\n    The extracted path is smoothed further for path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_dist: float\n    _iterations: int\n    _rewire_radius_const: float\n\n    def __init__(self, services: \"Services\", testing: \"BasicTesting\" = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._max_dist = 15.0\n        self._iterations = 15000\n        # Rewiring radius factor (heuristic)\n        self._rewire_radius_const = 50.0\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_random_sample(self, informed_subset: Optional[Tuple[Point, float, float]] = None) -> Point:\n        \"\"\"\n        Returns a random sample Point in the environment.\n        When informed_subset is given (center, c_best, c_min), sample inside an ellipse for focused search.\n        Else uniform random sampling within map boundaries.\n        \"\"\"\n        size = self._get_grid().size\n\n        def to_int_point(p: Point) -> Point:\n            # Convert Point with potential floats into Point with int coordinates\n            # This resolves the error with float positions in dense_map lookup\n            int_coords = tuple(int(round(coord)) for coord in p.values)\n            return Point(*int_coords)\n\n        if informed_subset is None:\n            # Uniform random valid sample\n            for _ in range(100):\n                rand_pos = np.random.uniform(low=0, high=[size.width, size.height], size=(size.n_dim,))\n                sample = Point(*rand_pos)\n                sample_int = to_int_point(sample)\n                if self._get_grid().is_agent_valid_pos(sample_int):\n                    return sample_int\n            # fallback uniform discrete\n            while True:\n                rand_pos = np.random.randint(0, size.values, size=size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            center, c_best, c_min = informed_subset\n            # Sampling inside ellipse in 2D only - ellipse parameters and rotation matrix aligned along start-goal line\n            start = self._graph.root_vertex_start.position.to_tensor()\n            goal = self._graph.root_vertex_goal.position.to_tensor()\n            dim = size.n_dim\n            if dim < 2:\n                # fallback uniform\n                return self._get_random_sample(None)\n\n            # Create a coordinate system aligned with the vector from start to goal\n            diff = goal - start\n            dist = torch.norm(diff).item()\n            if dist == 0:\n                dist = 1e-6\n\n            a1 = diff / dist  # unit vector along major axis\n\n            # Generate random sample inside unit ball in 2D\n            while True:\n                # Sample uniformly in unit circle with rejection sampling\n                sample_in_unit_circle = np.random.uniform(-1, 1, 2)\n                if sample_in_unit_circle[0]**2 + sample_in_unit_circle[1]**2 <= 1:\n                    break\n            u1, u2 = sample_in_unit_circle\n\n            # Lengths of ellipse axes\n            r1 = c_best / 2.0  # Major axis radius\n            r2 = math.sqrt(c_best**2 - c_min**2) / 2.0  # Minor axis radius\n\n            # Rotate sample to global coordinates\n            # The ellipse is aligned such that major axis aligns with a1 (along start-goal)\n            # Build orthonormal basis [a1, a2]\n            a2 = torch.zeros(dim)\n            # Generate an arbitrary vector orthogonal to a1 in 2D\n            if dim == 2:\n                a2[0] = -a1[1]\n                a2[1] = a1[0]\n            else:  # For 3D+, approximation (not very accurate but better than nothing)\n                a2[0] = -a1[1]\n                a2[1] = a1[0]\n                if dim > 2:\n                    a2[2:] = 0\n\n            sample_vec = r1 * u1 * a1 + r2 * u2 * a2\n            sample_point_tensor = center.to_tensor() + sample_vec\n\n            sample_point = Point(*sample_point_tensor.tolist())\n\n            # Clamp sample inside map bounds and check validity\n            clamped_coords = []\n            for idx, coord in enumerate(sample_point.values):\n                val = max(0, min(coord, size.values[idx] - 1))\n                clamped_coords.append(val)\n            sample_point = Point(*clamped_coords)\n\n            sample_int = to_int_point(sample_point)\n\n            # Validate and fallback if invalid\n            if self._get_grid().is_agent_valid_pos(sample_int):\n                return sample_int\n\n            # If failed, fallback to uniform sample\n            return self._get_random_sample(None)\n\n    def _get_nearest_vertex(self, root_vertices: List[Vertex], point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(root_vertices, point)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            # ensure position has integer coordinates for dense_map compatibility\n            p_int = Point(*[int(round(c)) for c in q_sample.values])\n            return Vertex(p_int, store_connectivity=True)\n\n        dir_normalized = dir / norm_dir\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        # Convert to integer Point\n        p_int = Point(*[int(round(c.item())) for c in new_pos_tensor])\n        return Vertex(p_int, store_connectivity=True)\n\n    def _get_vertices_within_radius(self, root_vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(root_vertices, point, radius)\n\n    def _calculate_rewire_radius(self) -> float:\n        # Calculate rewiring radius as heuristic based on environment size and nodes count\n        size = self._get_grid().size\n        n = max(1, self._graph.size)\n        volume = size.width * size.height  # approx for 2D\n        r = min(self._max_dist, self._rewire_radius_const * math.sqrt((math.log(n) / n)))\n        r = max(r, 5.0)\n        return r\n\n    def _collision_free(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _cost(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        return self._get_grid().get_distance(from_vertex.position, to_vertex.position)\n\n    def _choose_parent(self, new_vertex: Vertex, neighbors: List[Vertex]) -> Optional[Vertex]:\n        # Choose best parent in terms of cost + cost-to-new_vertex\n        min_cost = math.inf\n        best_parent = None\n        for neighbor in neighbors:\n            if self._collision_free(neighbor.position, new_vertex.position):\n                tentative_cost = neighbor.cost if neighbor.cost is not None else 0\n                tentative_cost += self._cost(neighbor, new_vertex)\n                if tentative_cost < min_cost:\n                    min_cost = tentative_cost\n                    best_parent = neighbor\n        if best_parent:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, neighbors: List[Vertex]) -> None:\n        new_cost = new_vertex.cost if new_vertex.cost is not None else 0\n        for neighbor in neighbors:\n            if neighbor is new_vertex:\n                continue\n            if self._collision_free(new_vertex.position, neighbor.position):\n                cost_through_new = new_cost + self._cost(new_vertex, neighbor)\n                if neighbor.cost is None or cost_through_new < neighbor.cost:\n                    # Rewire: remove old parent edges, add new edge\n                    # Remove previous parent edges\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(new_vertex, neighbor)\n                    neighbor.cost = cost_through_new\n\n    def _extract_path(self, connecting_vertex: Vertex) -> None:\n        # Trace back path from connecting_vertex to start and to goal\n        path_start = []\n        v = connecting_vertex\n        while v is not None:\n            path_start.append(v)\n            if len(v.parents) == 0:\n                break\n            v = next(iter(v.parents))  # one parent (tree structure)\n\n        path_goal = []\n        # goal root vertex\n        goal_vertex = self._graph.root_vertex_goal\n        # We find path from connecting_vertex to goal by DFS or backwards\n        # Walk from goal root downwards to connecting_vertex:\n        # As graph is cyclic, to find goal path we do upwards from goal root\n        # Instead traverse parents from goal root to connecting_vertex via children recursively\n\n        # We find the path from goal to connecting_vertex backwards (via DFS)\n        # Because in cyclic graph children and parents exist, but we enforce edges start->child as direction\n\n        def dfs_find_path(current: Vertex, target: Vertex, visited: Set[Vertex]) -> Optional[List[Vertex]]:\n            if current == target:\n                return [current]\n            visited.add(current)\n            for child in current.children:\n                if child in visited:\n                    continue\n                sub_path = dfs_find_path(child, target, visited)\n                if sub_path:\n                    return [current] + sub_path\n            return None\n\n        path_goal = dfs_find_path(goal_vertex, connecting_vertex, set()) or []\n\n        # Combine paths (path_start reversed is from start to connecting_vertex)\n        path_start.reverse()\n        if len(path_goal) > 0 and path_goal[0] == connecting_vertex:\n            path_goal = path_goal[1:]  # avoid duplicate vertex\n\n        full_path = path_start + path_goal\n\n        # Smooth the path to improve quality\n        smooth_path = self._smooth_path([v.position for v in full_path])\n\n        for pos in smooth_path:\n            self.move_agent(pos)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _smooth_path(self, path_points: List[Point]) -> List[Point]:\n        # Simple path smoothing by shortcutting over unnecessary vertices if collision free\n        if len(path_points) < 3:\n            return path_points\n\n        smooth_path = [path_points[0]]\n        i = 0\n        while i < len(path_points) - 1:\n            j = len(path_points) - 1\n            while j > i + 1:\n                if self._collision_free(path_points[i], path_points[j]):\n                    smooth_path.append(path_points[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # no shortcut found, advance by one\n                smooth_path.append(path_points[i + 1])\n                i += 1\n        return smooth_path\n\n    # Main Algorithm Loop #\n    # --------------------#\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        # Initialization\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        trees = [start_vertex, goal_vertex]  # root vertices for two trees\n        # Two vertex sets for easy access\n        start_tree_vertices = [start_vertex]\n        goal_tree_vertices = [goal_vertex]\n\n        path_found = False\n        best_path_cost = math.inf\n        best_connecting_vertex = None\n\n        # Constants\n        c_min = self._get_grid().get_distance(start_vertex.position, goal_vertex.position)\n        c_best = math.inf\n\n        for iter_idx in range(self._iterations):\n\n            if time.time() - start_time > 60:  # timeout 60 seconds\n                # Fail gracefully\n                break\n\n            # Determine if informed sampling is possible (after path found)\n            informed_subset = None\n            if path_found and best_connecting_vertex is not None and best_path_cost < math.inf:\n                center_raw = np.array(start_vertex.position.values) + np.array(goal_vertex.position.values)\n                center = Point(*((center_raw / 2).tolist()))\n                informed_subset = (center, best_path_cost, c_min)\n\n            # Sample randomly using informed sampling if available\n            q_rand = self._get_random_sample(informed_subset)\n\n            # Alternate tree to extend: 0 or 1\n            tree_idx = iter_idx % 2\n            curr_tree_root = trees[tree_idx]\n            other_tree_root = trees[1 - tree_idx]\n\n            # Extend current tree towards q_rand\n            q_near = self._get_nearest_vertex([curr_tree_root], q_rand)\n            q_new = self._get_new_vertex(q_near, q_rand, self._max_dist)\n\n            # Check collision along edge q_near->q_new\n            if not self._collision_free(q_near.position, q_new.position):\n                self.key_frame()\n                continue\n\n            # Get neighbors for rewiring (both trees)\n            neighbors_radius = self._calculate_rewire_radius()\n            neighbors = self._get_vertices_within_radius([curr_tree_root], q_new.position, neighbors_radius)\n\n            # Choose parent among neighbors\n            best_parent = self._choose_parent(q_new, neighbors)\n            if best_parent is None:\n                # No valid parent found, discard q_new\n                self.key_frame()\n                continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors for better path\n            self._rewire(q_new, neighbors)\n\n            # Add q_new to proper tree vertices list\n            if tree_idx == 0:\n                start_tree_vertices.append(q_new)\n            else:\n                goal_tree_vertices.append(q_new)\n\n            # Try to connect other_tree to q_new by extending towards it\n            q_near_other = self._get_nearest_vertex([other_tree_root], q_new.position)\n            q_new_other = self._get_new_vertex(q_near_other, q_new.position, self._max_dist)\n\n            if self._collision_free(q_near_other.position, q_new_other.position):\n                self._graph.add_edge(q_near_other, q_new_other)\n\n                # Check if connection possible between q_new and q_new_other\n                if self._collision_free(q_new.position, q_new_other.position):\n                    # Connect q_new with q_new_other and form path\n                    self._graph.add_edge(q_new, q_new_other)\n\n                    # Compute path cost for potential solution\n                    total_cost = (q_new.cost if q_new.cost else 0) + \\\n                                 self._get_grid().get_distance(q_new.position, q_new_other.position) + \\\n                                 (q_new_other.cost if q_new_other.cost else 0)\n\n                    if total_cost < best_path_cost:\n                        best_path_cost = total_cost\n                        best_connecting_vertex = q_new\n\n                    path_found = True\n                    # Once connected, break early: extract path\n                    self._extract_path(best_connecting_vertex)\n                    break\n\n            self.key_frame()\n\n        if not path_found:\n            # Mark failure as required (no path found)\n            # If desired, could raise an exception or signal failure here.\n            return",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 331, in _find_path_internal\n  File \"<string>\", line 82, in _get_random_sample\n  File \"<string>\", line 74, in to_int_point\nAttributeError: 'Point' object has no attribute 'values'\n"
     }
}
{
     "operator": "m3",
     "algorithm": "Improved sample-based path planning algorithm combining benefits of RRT* and SPRM features:\n    - Uses an adaptive radius for neighborhood search based on vertex count and map size to enhance rewiring and path smoothness.\n    - Incorporates cost optimization while rewiring to ensure better path quality.\n    - Uses informed sampling centered around the current best path to improve planning efficiency.\n    - Limits search time to 60 seconds to ensure robustness by failing gracefully if no solution is found.\n    - Utilizes cyclic graph to avoid tree structure limitations and enable richer connectivity.\n    - Implements path smoothing by shortcutting edges when possible, improving path length and smoothness.\n    - Produces more optimal and robust paths with balanced exploration and exploitation.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n    _max_edge_len: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        self._V_size = 250\n        # Maximum edge length per extension step, scaled to map size\n        grid_size_sum = sum(self._get_grid().size.values)\n        self._max_edge_len = max(5, grid_size_sum / 20)\n        self._max_radius = max(10, grid_size_sum / 10)\n\n        V: list[Vertex] = []\n        for _ in range(self._V_size):\n            sample = self._get_random_sample_init()\n            V.append(Vertex(sample, store_connectivity=True))\n\n        self._graph = gen_cyclic_graph(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            V,\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample_init(self) -> Point:\n        \"\"\"Random sample during initialization without relying on _graph attribute.\"\"\"\n        return Point(\n            *[\n                self._services.rng.uniform(0, self._get_grid().size[i])\n                for i in range(self._get_grid().size.n_dim)\n            ]\n        )\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Informed sampling within a heuristic ellipsoidal region to focus search near best path.\"\"\"\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n\n        c_best = float(\"inf\")\n        path_vertices = self._get_current_best_path_vertices()\n        if path_vertices:\n            c_best = sum(\n                self._get_grid().get_distance(path_vertices[i].position, path_vertices[i + 1].position)\n                for i in range(len(path_vertices) - 1)\n            )\n        else:\n            # If no path known, set to grid diagonal length * 2 to search broadly\n            c_best = (self._get_grid().size.to_tensor().float().norm()) * 2\n\n        while True:\n            # Uniform random sample in configuration space\n            random_sample = Point(\n                *[\n                    self._services.rng.uniform(0, self._get_grid().size[i])\n                    for i in range(self._get_grid().size.n_dim)\n                ]\n            )\n\n            # Reject samples outside informed ellipsoid (if path known) to focus search:\n            # Ellipsoid defined by foci start and goal and path cost c_best\n            dist_start_sample = (random_sample.to_tensor() - start).norm()\n            dist_sample_goal = (random_sample.to_tensor() - goal).norm()\n            if dist_start_sample + dist_sample_goal <= c_best + self._max_edge_len:\n                if self._get_grid().is_agent_valid_pos(random_sample):\n                    return random_sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = direction.norm()\n        if norm_dir <= max_dist:\n            q_new = q_sample\n        else:\n            q_new_tensor = q_near.position.to_tensor() + (direction / norm_dir) * max_dist\n            q_new = Point.from_tensor(q_new_tensor)\n        return Vertex(q_new, store_connectivity=True)\n\n    def _near(self, vertex: Vertex, radius: None | float = None) -> list[Vertex]:\n        # Use adaptive radius if none specified\n        if radius is None:\n            n = max(1, len(self._graph.root_vertices))\n            # RRT* radius formula scaled to environment - robust and efficient\n            unit_ball_volume = 3.14  # Approximation for 2D; in higher dims could tune\n            gamma_rrt_star = 2 * (1 + 1 / self._get_grid().size.n_dim) ** (1 / self._get_grid().size.n_dim) * (\n                self._get_grid().size.width * self._get_grid().size.height\n            ) ** (1 / self._get_grid().size.n_dim)\n            radius = min(self._max_radius, gamma_rrt_star * (math.log(n) / n) ** (1 / self._get_grid().size.n_dim))\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _choose_parent_and_rewire(self, q_new: Vertex, q_near_list: list[Vertex]) -> None:\n        # Choose best parent based on total cost to q_new through neighbor and rewire neighbors if better path found\n        best_parent = None\n        best_cost = float(\"inf\")\n        for q_near in q_near_list:\n            if q_near.position == q_new.position:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            tentative_cost = (\n                getattr(q_near, \"cost\", 0) + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            )\n            if tentative_cost < best_cost:\n                best_parent = q_near\n                best_cost = tentative_cost\n        if best_parent:\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n            # Rewire neighbors if going through q_new offers a better cost\n            for q_near in q_near_list:\n                if q_near == best_parent or q_near == q_new:\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    continue\n                cost_through_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n                current_cost = getattr(q_near, \"cost\", float(\"inf\"))\n                if cost_through_new < current_cost:\n                    # Remove old edge(s) from parents\n                    for parent in list(q_near.parents):\n                        self._graph.remove_edge(parent, q_near)\n                    self._graph.add_edge(q_new, q_near)\n                    q_near.cost = cost_through_new\n\n    def _get_current_best_path_vertices(self) -> list[Vertex]:\n        # Try to recover current best path from start to goal if connected\n        start = self._graph.root_vertex_start\n        goal = self._graph.root_vertex_goal\n        if goal not in start.connectivity:\n            return []\n\n        path = []\n        current = start\n        while current != goal:\n            children = list(current.connectivity)\n            if not children:\n                break\n            # Choose child with lowest cost if available (heuristic)\n            if hasattr(current, \"cost\"):\n                children = sorted(children, key=lambda c: getattr(c, \"cost\", float(\"inf\")))\n            current = children[0]\n            path.append(current)\n            if current == goal:\n                break\n        return path\n\n    def _shortcut_path(self, path: list[Vertex]) -> list[Vertex]:\n        # Path shortcutting to improve smoothness: tries to connect non-adjacent points directly if possible\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[next_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                next_idx -= 1\n            shortcut_path.append(path[next_idx])\n            idx = next_idx\n        return shortcut_path\n\n    def _extract_path_and_animate(self, q_goal: Vertex) -> None:\n        # Extracts path from the goal vertex back to start and animates movement\n        path = [q_goal]\n        while path[-1].parents:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        path.reverse()\n\n        # Path shortcutting\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import math\n        from time import time\n\n        start_time = time()\n        max_duration = 60  # seconds\n        max_iterations = 20000\n\n        # Initialize cost for root start and goal vertices\n        self._graph.root_vertex_start.cost = 0\n        self._graph.root_vertex_goal.cost = float(\"inf\")\n\n        for iteration in range(max_iterations):\n            if time() - start_time > max_duration:\n                # Fail gracefully if timeout reached\n                return\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_edge_len)\n\n            # Check feasibility of new edge\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Add the new vertex and find neighbors for rewiring\n            self._graph.root_vertices.append(q_new)\n            q_near_list = self._near(q_new, radius=self._max_radius)\n\n            # Choose parent and rewire neighbors to minimize cost\n            self._choose_parent_and_rewire(q_new, q_near_list)\n\n            # Check if new vertex reaches goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect goal vertex, update cost, extract path and exit\n                self._graph.add_edge(q_new, self._graph.root_vertex_goal)\n                self._graph.root_vertex_goal.cost = getattr(q_new, \"cost\", float(\"inf\")) + self._get_grid().get_movement_cost(q_new.position, self._graph.root_vertex_goal.position)\n                self._extract_path_and_animate(self._graph.root_vertex_goal)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 122, in PathPlanning\nTypeError: unsupported operand type(s) for |: 'NoneType' and 'type'\n"
     }
}
{
     "operator": "m1",
     "algorithm": "This algorithm integrates and improves upon sampling-based algorithms like RRT and SPRM,\n    combining efficient exploration with intelligent rewiring for optimal path quality.\n    It does the following:\n    - Uses informed sampling biased towards the goal to improve convergence speed.\n    - Uses a variable radius nearest neighbor search for rewiring to improve path quality.\n    - Employs a cost-to-come plus heuristic cost-to-go for vertex cost and prioritization.\n    - Uses early stopping when goal is reached.\n    - Uses a timestamp to terminate if planning exceeds 60 seconds.\n    - After finding the path, performs a path smoothing step to reduce sharp turns.\n    - Stores connectivity in a cyclic graph structure for rewiring edges.\n    - Supports 2D or higher dimensional maps.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius_init: float\n    _max_step: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._V_size = 300   # reasonable number of vertices\n        self._max_step = 12.0\n        self._max_radius_init = 20.0\n        V: list[Vertex] = list()\n\n        # start and goal vertices with connectivity info\n        start_v = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_v = Vertex(self._get_grid().goal.position, store_connectivity=True)\n\n        # Pre-fill samples biased toward goal region for informed exploration\n        for i in range(self._V_size):\n            V.append(self._sample_informed(goal_v.position))\n        self._graph = gen_cyclic_graph(self._services, start_v, goal_v, V)\n        self._graph.edges_removable = True  # allow rewiring for optimization\n\n        # Initialize cost of start vertex as 0, others as inf\n        start_v.cost = 0.0\n        for v in self._graph.root_vertices:\n            if v is not start_v:\n                v.cost = float('inf')\n\n        self._init_displays()\n\n    def _sample_informed(self, goal_pos: Point) -> Point:\n        \"\"\"Sample a point biased toward the goal, with fallback to uniform random if needed.\"\"\"\n        g = goal_pos\n        map_size = self._get_grid().size\n        for _ in range(10):\n            # Informed sampling: sample a point in an ellipse or near goal region\n            # For simplicity, here bias sampling toward goal +/- radius region\n            delta = 10\n            low = [max(0, g[i] - delta) for i in range(map_size.n_dim)]\n            high = [min(map_size[i] - 1, g[i] + delta) for i in range(map_size.n_dim)]\n\n            coords = []\n            for dim in range(map_size.n_dim):\n                val = int(torch.randint(low[dim], high[dim] + 1, (1,)).item())\n                coords.append(val)\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n        # fallback: uniform random valid sample\n        while True:\n            sample = Point(*[torch.randint(0, map_size[i], (1,)).item() for i in range(map_size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _get_nearest_vertex(self, vertices: list[Vertex], point: Point) -> Vertex | None:\n        best_vertex = None\n        best_dist = float('inf')\n        for v in vertices:\n            dist = self._distance(v.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best_vertex = v\n        return best_vertex\n\n    def _get_near_vertices(self, vertices: list[Vertex], point: Point, radius: float) -> list[Vertex]:\n        near = []\n        for v in vertices:\n            if self._distance(v.position, point) <= radius:\n                near.append(v)\n        return near\n\n    def _steer(self, from_v: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        direction = to_point.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            return Vertex(to_point, store_connectivity=True)\n        direction_normalized = direction / dist\n        new_pos_tensor = from_v.position.to_tensor() + max_dist * direction_normalized\n        # create new_point with integer coordinates to avoid floating positions\n        new_pos_ints = tuple(int(round(x.item())) for x in new_pos_tensor)\n        new_point = Point(*new_pos_ints)\n        return Vertex(new_point, store_connectivity=True)\n\n    def _reconstruct_path(self, goal_vertex: Vertex) -> list[Vertex]:\n        path = []\n        current = goal_vertex\n        # Follow parents with minimal cost path backward to root start vertex\n        while True:\n            path.append(current)\n            if not current.parents or any(p.cost == 0 for p in current.parents):\n                break\n            # proceed to parent with lowest cost\n            min_parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            current = min_parent\n        path.reverse()\n        return path\n\n    def _line_collision_free(self, start: Point, end: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(start, end)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _path_smoothing(self, path: list[Vertex]) -> list[Vertex]:\n        \"\"\"Attempt to smooth path by shortcutting between vertices skipping intermediates.\"\"\"\n        if len(path) <= 2:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_collision_free(path[i].position, path[j].position):\n                    smoothed.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # no shortcut found, just add next vertex\n                smoothed.append(path[i + 1])\n                i += 1\n        return smoothed\n\n    # Overridden implementation #\n    def _find_path_internal(self) -> None:\n        import time\n        import numpy as np\n\n        start_time = time.time()\n        start_v = self._graph.root_vertex_start\n        goal_v = self._graph.root_vertex_goal\n\n        # Add start & goal to root_vertices if missing\n        if start_v not in self._graph.root_vertices:\n            self._graph.root_vertices.insert(0, start_v)\n        if goal_v not in self._graph.root_vertices:\n            self._graph.root_vertices.append(goal_v)\n\n        all_vertices = self._graph.root_vertices + self._graph.root_vertices[2:]  # start, goal + V\n\n        max_iter = 12000\n        radius_factor = 50.0  # controls rewiring radius scaling\n        dimension = self._get_grid().size.n_dim\n\n        for iter_idx in range(max_iter):\n\n            # Timeout fail check (60 seconds)\n            if time.time() - start_time > 60.0:\n                # Treat as fail: no path found in time\n                return\n\n            # Sample a point biased towards goal region\n            q_rand = self._sample_informed(goal_v.position)\n            # Find nearest vertex in graph\n            q_near = self._get_nearest_vertex(all_vertices, q_rand)\n            if q_near is None:\n                continue\n\n            # Steer toward sample with max step size\n            q_new = self._steer(q_near, q_rand, self._max_step)\n\n            # Check validity of path q_near to q_new\n            if not self._line_collision_free(q_near.position, q_new.position):\n                continue\n\n            # Calculate tentative cost to reach q_new through q_near\n            cost_to_q_new = (q_near.cost if q_near.cost is not None else float('inf')) + \\\n                            self._distance(q_near.position, q_new.position)\n            # If q_new already exists in graph (approximate), skip to avoid duplicates\n            overlap_vertices = [v for v in all_vertices if v.position == q_new.position]\n            if overlap_vertices:\n                # May try to rewire the vertex if this path better\n                existing_v = overlap_vertices[0]\n                if cost_to_q_new < (existing_v.cost if existing_v.cost is not None else float('inf')):\n                    existing_v.cost = cost_to_q_new\n                    # Change parents to q_near\n                    for p in list(existing_v.parents):\n                        existing_v.parents.remove(p)\n                        p.children.remove(existing_v)\n                    existing_v.add_parent(q_near)\n                    q_near.add_child(existing_v)\n                continue\n\n            # Assign cost & add q_new to graph connected from q_near\n            q_new.cost = cost_to_q_new\n            self._graph.root_vertices.append(q_new)\n            all_vertices.append(q_new)\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire neighbors within radius around q_new to possibly improve cost\n            radius = radius_factor * ( (np.log(len(all_vertices)) / len(all_vertices)) ** (1 / dimension) )\n            radius = max(radius, self._max_step)  # radius never below step size\n            near_vertices = self._get_near_vertices(all_vertices, q_new.position, radius)\n\n            for q_nearby in near_vertices:\n                if q_nearby is q_new or q_nearby is q_near:\n                    continue\n                # Check if edge q_new->q_nearby would improve cost and is feasible\n                if not self._line_collision_free(q_new.position, q_nearby.position):\n                    continue\n                cost_thru_q_new = q_new.cost + self._distance(q_new.position, q_nearby.position)\n                if cost_thru_q_new < (q_nearby.cost if q_nearby.cost is not None else float('inf')):\n                    # Rewire q_nearby parent from old parent to q_new\n                    # Remove old parent edges\n                    for p in list(q_nearby.parents):\n                        p.children.discard(q_nearby)\n                    q_nearby.parents.clear()\n                    q_nearby.cost = cost_thru_q_new\n                    q_nearby.add_parent(q_new)\n                    q_new.add_child(q_nearby)\n                    # If graph supports edges removal, remove old edges and add new edges\n                    try:\n                        self._graph.add_edge(q_new, q_nearby)\n                    except Exception:\n                        pass\n\n            # Try connecting q_new directly to goal if possible and update cost if better\n            if self._distance(q_new.position, goal_v.position) <= self._max_step:\n                if self._line_collision_free(q_new.position, goal_v.position):\n                    cost_to_goal_through_q_new = q_new.cost + self._distance(q_new.position, goal_v.position)\n                    if cost_to_goal_through_q_new < (goal_v.cost if goal_v.cost is not None else float('inf')):\n                        for p in list(goal_v.parents):\n                            p.children.discard(goal_v)\n                        goal_v.parents.clear()\n                        goal_v.cost = cost_to_goal_through_q_new\n                        goal_v.add_parent(q_new)\n                        q_new.add_child(goal_v)\n\n            # If goal reached and has a valid cost, extract and smooth path\n            if goal_v.cost is not None and goal_v.cost < float('inf') and len(goal_v.parents) > 0:\n                path = self._reconstruct_path(goal_v)\n                path = self._path_smoothing(path)\n\n                # Animate moving the agent along path\n                for v in path:\n                    self.move_agent(v.position)\n                    self.key_frame(ignore_key_frame_skip=True)\n                return\n\n            # key frame for display update per iteration\n            if iter_idx % 10 == 0:\n                self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 99, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "m3",
     "algorithm": "Improved sample-based path planning algorithm combining benefits of RRT* and SPRM features:\n    - Uses an adaptive radius for neighborhood search based on vertex count and map size to enhance rewiring and path smoothness.\n    - Incorporates cost optimization while rewiring to ensure better path quality.\n    - Uses informed sampling centered around the current best path to improve planning efficiency.\n    - Limits search time to 60 seconds to ensure robustness by failing gracefully if no solution is found.\n    - Utilizes cyclic graph to avoid tree structure limitations and enable richer connectivity.\n    - Implements path smoothing by shortcutting edges when possible, improving path length and smoothness.\n    - Produces more optimal and robust paths with balanced exploration and exploitation.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n    _max_edge_len: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        self._V_size = 250\n        # Maximum edge length per extension step, scaled to map size\n        grid_size_sum = sum(self._get_grid().size.values)\n        self._max_edge_len = max(5, grid_size_sum / 20)\n        self._max_radius = max(10, grid_size_sum / 10)\n\n        V: list[Vertex] = []\n        for _ in range(self._V_size):\n            sample = self._get_random_sample_init()\n            V.append(Vertex(sample, store_connectivity=True))\n\n        self._graph = gen_cyclic_graph(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            V,\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample_init(self) -> Point:\n        \"\"\"Random sample during initialization without relying on _graph attribute.\"\"\"\n        return Point(\n            *[\n                self._services.rng.uniform(0, self._get_grid().size[i])\n                for i in range(self._get_grid().size.n_dim)\n            ]\n        )\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Informed sampling within a heuristic ellipsoidal region to focus search near best path.\"\"\"\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n\n        c_best = float(\"inf\")\n        path_vertices = self._get_current_best_path_vertices()\n        if path_vertices:\n            c_best = sum(\n                self._get_grid().get_distance(path_vertices[i].position, path_vertices[i + 1].position)\n                for i in range(len(path_vertices) - 1)\n            )\n        else:\n            # If no path known, set to grid diagonal length * 2 to search broadly\n            c_best = (self._get_grid().size.to_tensor().float().norm()) * 2\n\n        while True:\n            # Uniform random sample in configuration space\n            random_sample = Point(\n                *[\n                    self._services.rng.uniform(0, self._get_grid().size[i])\n                    for i in range(self._get_grid().size.n_dim)\n                ]\n            )\n\n            # Reject samples outside informed ellipsoid (if path known) to focus search:\n            # Ellipsoid defined by foci start and goal and path cost c_best\n            dist_start_sample = (random_sample.to_tensor() - start).norm()\n            dist_sample_goal = (random_sample.to_tensor() - goal).norm()\n            if dist_start_sample + dist_sample_goal <= c_best + self._max_edge_len:\n                if self._get_grid().is_agent_valid_pos(random_sample):\n                    return random_sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = direction.norm()\n        if norm_dir <= max_dist:\n            q_new = q_sample\n        else:\n            q_new_tensor = q_near.position.to_tensor() + (direction / norm_dir) * max_dist\n            q_new = Point(*tuple(q_new_tensor.tolist()))\n        return Vertex(q_new, store_connectivity=True)\n\n    def _near(self, vertex: Vertex, radius: Optional[float] = None) -> list[Vertex]:\n        # Use adaptive radius if none specified\n        if radius is None:\n            n = max(1, len(self._graph.root_vertices))\n            # RRT* radius formula scaled to environment - robust and efficient\n            unit_ball_volume = 3.14  # Approximation for 2D; in higher dims could tune\n            gamma_rrt_star = 2 * (1 + 1 / self._get_grid().size.n_dim) ** (1 / self._get_grid().size.n_dim) * (\n                self._get_grid().size.width * self._get_grid().size.height\n            ) ** (1 / self._get_grid().size.n_dim)\n            radius = min(self._max_radius, gamma_rrt_star * (math.log(n) / n) ** (1 / self._get_grid().size.n_dim))\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _choose_parent_and_rewire(self, q_new: Vertex, q_near_list: list[Vertex]) -> None:\n        # Choose best parent based on total cost to q_new through neighbor and rewire neighbors if better path found\n        best_parent = None\n        best_cost = float(\"inf\")\n        for q_near in q_near_list:\n            if q_near.position == q_new.position:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            tentative_cost = (\n                getattr(q_near, \"cost\", 0) + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            )\n            if tentative_cost < best_cost:\n                best_parent = q_near\n                best_cost = tentative_cost\n        if best_parent:\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n            # Rewire neighbors if going through q_new offers a better cost\n            for q_near in q_near_list:\n                if q_near == best_parent or q_near == q_new:\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    continue\n                cost_through_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n                current_cost = getattr(q_near, \"cost\", float(\"inf\"))\n                if cost_through_new < current_cost:\n                    # Remove old edge(s) from parents\n                    for parent in list(q_near.parents):\n                        self._graph.remove_edge(parent, q_near)\n                    self._graph.add_edge(q_new, q_near)\n                    q_near.cost = cost_through_new\n\n    def _get_current_best_path_vertices(self) -> list[Vertex]:\n        # Try to recover current best path from start to goal if connected\n        start = self._graph.root_vertex_start\n        goal = self._graph.root_vertex_goal\n        if goal not in start.connectivity:\n            return []\n\n        path = []\n        current = start\n        while current != goal:\n            children = list(current.connectivity)\n            if not children:\n                break\n            # Choose child with lowest cost if available (heuristic)\n            if hasattr(current, \"cost\"):\n                children = sorted(children, key=lambda c: getattr(c, \"cost\", float(\"inf\")))\n            current = children[0]\n            path.append(current)\n            if current == goal:\n                break\n        return path\n\n    def _shortcut_path(self, path: list[Vertex]) -> list[Vertex]:\n        # Path shortcutting to improve smoothness: tries to connect non-adjacent points directly if possible\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[next_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                next_idx -= 1\n            shortcut_path.append(path[next_idx])\n            idx = next_idx\n        return shortcut_path\n\n    def _extract_path_and_animate(self, q_goal: Vertex) -> None:\n        # Extracts path from the goal vertex back to start and animates movement\n        path = [q_goal]\n        while path[-1].parents:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        path.reverse()\n\n        # Path shortcutting\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        from time import time\n\n        start_time = time()\n        max_duration = 60  # seconds\n        max_iterations = 20000\n\n        # Initialize cost for root start and goal vertices\n        self._graph.root_vertex_start.cost = 0\n        self._graph.root_vertex_goal.cost = float(\"inf\")\n\n        for iteration in range(max_iterations):\n            if time() - start_time > max_duration:\n                # Fail gracefully if timeout reached\n                return\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_edge_len)\n\n            # Check feasibility of new edge\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Add the new vertex and find neighbors for rewiring\n            self._graph.root_vertices.append(q_new)\n            q_near_list = self._near(q_new, radius=self._max_radius)\n\n            # Choose parent and rewire neighbors to minimize cost\n            self._choose_parent_and_rewire(q_new, q_near_list)\n\n            # Check if new vertex reaches goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect goal vertex, update cost, extract path and exit\n                self._graph.add_edge(q_new, self._graph.root_vertex_goal)\n                self._graph.root_vertex_goal.cost = getattr(q_new, \"cost\", float(\"inf\")) + self._get_grid().get_movement_cost(q_new.position, self._graph.root_vertex_goal.position)\n                self._extract_path_and_animate(self._graph.root_vertex_goal)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 121, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an improved sample-based planner called \"Adaptive Informed RRT*\" \n    (A-Informed RRT*). It combines informed sampling within an ellipsoidal heuristic \n    sampling space to efficiently steer the search towards promising regions and uses \n    adaptive radius updates for rewiring, improving path quality and reducing search time. \n    The algorithm maintains a tree rooted at the start vertex and iteratively attempts to \n    connect towards random samples constrained inside an informed ellipse once an initial \n    feasible path is found. It performs rewiring in the neighborhood adaptively to improve \n    path cost and ensures robustness by validating edges along the proposed motion. \n    The search halts at success or after 60 seconds (treating any longer search as failure).",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_extend_dist = 12.0  # max edge length when extending tree\n        self._max_radius = 40.0  # max rewiring radius\n        self._min_radius = 5.0   # min rewiring radius\n        self._dimension = self._get_grid().size.n_dim\n        self._iteration_limit = 10000\n        self._goal_sample_rate = 0.1  # Probability to sample goal directly to bias search\n        self._init_displays()\n\n    def _get_distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _get_random_sample(self, c_best: Optional[float] = None) -> Point:\n        \"\"\"Informed sampling: if c_best is known, sample inside ellipsoidal region, else uniform.\"\"\"\n        if c_best is None or c_best == float(\"inf\"):\n            # Uniform sampling inside the map\n            grid_size = self._get_grid().size\n            while True:\n                sample_coords = [np.random.randint(0, grid_size[i]) for i in range(grid_size.n_dim)]\n                sample_coords = [int(c) for c in sample_coords]  # Ensure all integers\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Ellipsoidal informed sampling inside heuristic ellipse\n            start_pos = self._graph.root_vertex_start.position.to_tensor()\n            goal_pos = self._graph.root_vertex_goal.position.to_tensor()\n            c_min = self._get_distance(self._graph.root_vertex_start.position,\n                                       self._graph.root_vertex_goal.position)\n\n            # Define transformation to unit ball and back to ellipse in workspace\n            # Compute center and rotation\n            center = (start_pos + goal_pos) / 2\n            direction = (goal_pos - start_pos)\n            direction_norm = torch.norm(direction)\n            if direction_norm == 0:\n                # Start == goal, trivial\n                return self._graph.root_vertex_start.position\n\n            # Unit vector from start to goal\n            e1 = direction / direction_norm\n\n            # Build a rotation matrix to transform samples from unit ball to ellipse\n            def rotation_matrix_to_align_vector(vec: torch.Tensor):\n                # For 2D or 3D only\n                d = vec.shape[0]\n                if d == 2:\n                    theta = torch.atan2(vec[1], vec[0])\n                    c = torch.cos(theta)\n                    s = torch.sin(theta)\n                    R = torch.tensor([[c, -s], [s, c]], dtype=torch.float)\n                    return R\n                elif d == 3:\n                    # Use Rodrigues rotation formula to align x-axis to e1\n                    x_axis = torch.tensor([1.0, 0.0, 0.0])\n                    v = torch.cross(x_axis, vec)\n                    s = torch.norm(v)\n                    c = torch.dot(x_axis, vec)\n                    if s == 0:\n                        return torch.eye(3)\n                    vx = torch.tensor([[0, -v[2], v[1]],\n                                       [v[2], 0, -v[0]],\n                                       [-v[1], v[0], 0]])\n                    R = torch.eye(3) + vx + vx @ vx * ((1 - c) / (s ** 2))\n                    return R\n                else:\n                    # Higher dimensional not supported, fallback to uniform sampling\n                    return None\n\n            R = rotation_matrix_to_align_vector(e1)\n            if R is None:\n                return self._get_random_sample(None)\n\n            # Sampling inside unit n-ball\n            while True:\n                dir_sample = torch.randn(self._dimension)\n                r = torch.rand(1).pow(1 / self._dimension)\n                dir_sample = dir_sample / torch.norm(dir_sample) * r\n\n                # Scale samples according to ellipse radii using c_best and c_min\n                # Axis lengths of ellipse - major axis c_best/2, minor axes sqrt(c_best^2 - c_min^2)/2\n                a1 = c_best / 2\n                if c_best ** 2 - c_min ** 2 < 0:\n                    # numerical stability fallback\n                    r_minor = 0.0\n                else:\n                    r_minor = torch.sqrt(c_best ** 2 - c_min ** 2) / 2\n\n                r_minor = max(r_minor.item(), 0.001)\n                scale = torch.ones(self._dimension)\n                scale[0] = a1\n                if self._dimension > 1:\n                    scale[1:] = r_minor\n\n                local_sample = dir_sample * scale\n\n                # Rotate & translate back to world frame\n                world_sample = R @ local_sample + center\n                coords = [int(torch.clamp(world_sample[i], 0, self._get_grid().size[i] - 1).item())\n                          for i in range(self._dimension)]\n                coords = [int(c) for c in coords]  # Ensure integer coords\n                sample = Point(*coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dir_norm\n        # Instead of Point.from_tensor (which doesn't exist), create using Point(...) with tuple\n        new_coords = (q_near.position.to_tensor() + max_dist * dir_normalized).tolist()\n        coords_int = [int(coord) for coord in new_coords]\n        q_new_pos = Point(*coords_int)\n\n        return Vertex(q_new_pos)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Backtrack from q_new to root start\n        path = [q_new]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        c_best = float(\"inf\")\n        found_path = False\n\n        for i in range(self._iteration_limit):\n            if time.time() - start_time > 60:\n                # Time limit reached, fail search\n                return\n\n            # Bias sampling towards goal with probability goal_sample_rate\n            if np.random.rand() < self._goal_sample_rate:\n                q_sample = self._graph.root_vertex_goal.position\n            else:\n                q_sample = self._get_random_sample(c_best if found_path else None)\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_extend_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Cost to reach q_new via q_nearest\n            dist_near_to_new = self._get_distance(q_nearest.position, q_new.position)\n            q_new.cost = q_nearest.cost + dist_near_to_new\n\n            # Dynamic rewiring radius (shrinks as graph grows to approximate RRT* theoretical radius)\n            card_v = max(1, self._graph.size)\n            radius = min(self._max_radius,\n                         max(self._min_radius,\n                             50 * ((torch.log(torch.tensor(card_v, dtype=torch.float)) / card_v) ** (1 / self._dimension))))\n            \n            # Find neighbors for rewiring\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent from neighbors\n            q_min = q_nearest\n            c_min = q_new.cost\n            for q_near in neighbors:\n                if q_near == q_nearest:\n                    continue\n                line_seq_neighbor = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_neighbor):\n                    continue\n                cost_through_neighbor = q_near.cost + self._get_distance(q_near.position, q_new.position)\n                if cost_through_neighbor < c_min:\n                    q_min = q_near\n                    c_min = cost_through_neighbor\n            \n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if better\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n\n                line_seq_neighbor = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_neighbor):\n                    continue\n\n                new_cost = q_new.cost + self._get_distance(q_new.position, q_near.position)\n                if new_cost < q_near.cost:\n                    # Remove old edge and add new edge with q_new as parent\n                    old_parent = None\n                    for parent in q_near.parents:\n                        old_parent = parent\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if new vertex reached goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Attempt to connect q_new directly to goal vertex\n                goal_v = self._graph.root_vertex_goal\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    dist_to_goal = self._get_distance(q_new.position, goal_v.position)\n                    goal_v.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, goal_v)\n\n                    c_best = goal_v.cost\n                    found_path = True\n                    self._extract_path(goal_v)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 203, in _find_path_internal\n  File \"<string>\", line 71, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m1",
     "algorithm": "An improved sample-based path planning algorithm combining advantages of RRT* and SPRM:\n    - Uses adaptive sampling biased towards unexplored and goal regions.\n    - Employs incremental connection radius adjustment for efficient graph construction.\n    - Uses a cyclic graph to allow multiple paths and rewiring for path smoothing.\n    - Utilizes a heuristic guided nearest neighbor selection to improve planning efficiency.\n    - Continuously checks for goal reachability and extracts path early.\n    - Limits search duration to 60 seconds for robustness against infinite loops.\n    - Post-processes the found path for smoothing using shortcutting heuristics.\n    - Aimed to improve path quality, reduce search time, increase success rate and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_vertices: int\n    _max_radius: float\n    _max_dist: float\n    _timeout_seconds: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_vertices = 500\n        self._max_radius = 20.0\n        self._max_dist = 10.0\n        self._timeout_seconds = 60.0\n        initial_agent_v = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        initial_agent_v.cost = 0.0\n        initial_goal_v = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        initial_goal_v.cost = float('inf')\n        vertices = [initial_agent_v]\n        # Start with initial vertex only; vertices will be added dynamically\n        self._graph = gen_cyclic_graph(self._services, initial_agent_v, initial_goal_v, vertices)\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\" Sample points mostly avoiding obstacles and biased toward goal region 10% \"\"\"\n        grid = self._get_grid()\n        size_vals = grid.size.values\n        goal_pos = grid.goal.position\n        # 10% samples directly on/near goal, 90% uniform random in map\n        if np.random.rand() < 0.1:\n            # Gaussian sampling near goal within radius 5, clipped inside map\n            goal_radius = 5\n            coords = []\n            for i, dim_len in enumerate(size_vals):\n                val = int(np.clip(\n                    np.random.normal(loc=goal_pos[i], scale=goal_radius), 0, dim_len - 1\n                ))\n                coords.append(val)\n            sample = Point(*coords)\n            # Ensure sample is integer-coordinate Point (not floats) to avoid is_float error\n            if hasattr(sample, 'is_float'):\n                is_float = sample.is_float\n            else:\n                # fallback: check if any coordinate is float\n                is_float = any(isinstance(c, float) for c in sample.values)\n            if not is_float and grid.is_agent_valid_pos(sample):\n                return sample\n        # Uniform sampling in free space until valid\n        while True:\n            coords = [np.random.randint(0, dim_len) for dim_len in size_vals]\n            sample = Point(*coords)\n            # Likewise, ensure integer coordinates\n            if hasattr(sample, 'is_float'):\n                is_float = sample.is_float\n            else:\n                is_float = any(isinstance(c, float) for c in sample.values)\n            if not is_float and grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _heuristic_nearest(self, candidates, sample: Point) -> Vertex or None:\n        \"\"\"Return nearest vertex to sample biased by cost + distance heuristic.\"\"\"\n        if not candidates:\n            return None\n        s_tensor = sample.to_tensor()\n        min_score = float('inf')\n        best_vertex = None\n        for v in candidates:\n            dist = torch.norm(v.position.to_tensor() - s_tensor).item()\n            score = v.cost + dist  # Combined cost-to-come + heuristic distance\n            if score < min_score:\n                min_score = score\n                best_vertex = v\n        return best_vertex\n\n    def _new_vertex_from_direction(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec).item()\n        if norm <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        dir_normalized = dir_vec / norm\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point(*[int(round(x)) for x in new_pos_tensor.tolist()])\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _vertices_within_radius(self, center: Point, radius: float) -> list:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, center, radius)\n\n    def _connect_vertices(self, v_from: Vertex, v_to: Vertex) -> bool:\n        \"\"\"Try connecting two vertices if path valid and update costs, return success.\"\"\"\n        grid = self._get_grid()\n        if v_from.position == v_to.position:\n            return False\n        line = grid.get_line_sequence(v_from.position, v_to.position)\n        if not grid.is_valid_line_sequence(line):\n            return False\n\n        dist = torch.norm(v_from.position.to_tensor() - v_to.position.to_tensor()).item()\n        new_cost = v_from.cost + dist\n\n        # Connect v_from -> v_to if better cost found or no parents (v_to.cost initialization might be inf)\n        if v_to.cost is None or new_cost < v_to.cost:\n            # Remove old edges to v_to\n            for parent in list(v_to.parents):\n                self._graph.remove_edge(parent, v_to)\n            # Add new edge\n            self._graph.add_edge(v_from, v_to)\n            # Update cost recursively downstream\n            self._update_descendants_cost(v_to)\n            return True\n        return False\n\n    def _update_descendants_cost(self, vertex: Vertex) -> None:\n        \"\"\"Recursively update costs of vertex descendants.\"\"\"\n        queue = [vertex]\n        while queue:\n            current = queue.pop()\n            for child in current.children:\n                dist = torch.norm(current.position.to_tensor() - child.position.to_tensor()).item()\n                updated_cost = current.cost + dist\n                if child.cost is None or updated_cost < child.cost:\n                    child.cost = updated_cost\n                    queue.append(child)\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        \"\"\"Extract best path from start to goal vertex and move agent along it.\"\"\"\n        # Backtrack parents to start\n        path_vertices = []\n        current = goal_vertex\n        while current.parents:\n            path_vertices.append(current)\n            # Choose parent with minimum cost\n            parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            current = parent\n            if current == self._graph.root_vertex_start:\n                path_vertices.append(current)\n                break\n        path_vertices.reverse()\n\n        # Post-process path smoothing by shortcutting\n        smoothed_path = self._shortcut_path(path_vertices)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path_vertices: list) -> list:\n        \"\"\"Shortcut path by checking direct connections between non-consecutive vertices.\"\"\"\n        if len(path_vertices) < 3:\n            return path_vertices\n        grid = self._get_grid()\n        smoothed_path = [path_vertices[0]]\n        idx = 0\n        while idx < len(path_vertices) - 1:\n            # Try to find farthest reachable vertex ahead (greedy shortcut)\n            far_idx = len(path_vertices) - 1\n            while far_idx > idx + 1:\n                line = grid.get_line_sequence(path_vertices[idx].position, path_vertices[far_idx].position)\n                if grid.is_valid_line_sequence(line):\n                    break\n                far_idx -= 1\n            smoothed_path.append(path_vertices[far_idx])\n            idx = far_idx\n        return smoothed_path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        goal_vertex = self._graph.root_vertex_goal\n        goal_reached = False\n\n        # Dynamic vertex list for graph growth\n        vertex_list = [start_vertex]\n        self._graph.root_vertices = vertex_list + [goal_vertex]\n\n        iteration = 0\n        while iteration < self._max_vertices:\n            iteration += 1\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout_seconds:\n                # FAIL path search due to timeout\n                return\n\n            q_sample = self._get_random_sample()\n            # Select nearest vertex biased by cost and heuristic\n            q_near = self._heuristic_nearest(vertex_list, q_sample)\n            if q_near is None or q_near.position == q_sample:\n                continue\n\n            q_new = self._new_vertex_from_direction(q_near, q_sample, self._max_dist)\n            # Check path from q_near to q_new\n            line = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line):\n                continue\n\n            # Prepare q_new cost estimate: tentative cost from q_near + dist\n            dist_near_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = q_near.cost + dist_near_new\n\n            # Find neighborhood radius adapting to n^(1/d) * some constant (RRT* inspired)\n            n = len(vertex_list) + 1\n            d = grid.size.n_dim\n            gamma = self._max_radius\n            radius = min(gamma * ((np.log(n) / n) ** (1/d)), self._max_radius)\n\n            neighbors = self._vertices_within_radius(q_new.position, radius)\n\n            # Choose best parent to minimize cost and ensure path validity\n            c_min = float('inf')\n            q_min = None\n            for neighbor in neighbors:\n                if neighbor.position == q_new.position:\n                    continue\n                line_n_new = grid.get_line_sequence(neighbor.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_n_new):\n                    continue\n                dist_n_new = torch.norm(neighbor.position.to_tensor() - q_new.position.to_tensor()).item()\n                cost = neighbor.cost + dist_n_new\n                if cost < c_min:\n                    c_min = cost\n                    q_min = neighbor\n\n            if q_min is None:\n                q_min = q_near\n                c_min = q_min.cost + dist_near_new\n\n            q_new.cost = c_min\n            # Add new vertex to graph and vertex list\n            vertex_list.append(q_new)\n            self._graph.root_vertices.insert(-1, q_new)  # Before goal vertex\n            self._graph.add_edge(q_min, q_new)\n\n            # Optimize connection of neighbors to q_new (rewiring)\n            for neighbor in neighbors:\n                if neighbor == q_min or neighbor == q_new:\n                    continue\n                dist_new_n = torch.norm(q_new.position.to_tensor() - neighbor.position.to_tensor()).item()\n                cost_through_new = q_new.cost + dist_new_n\n                if cost_through_new < neighbor.cost:\n                    line_new_n = grid.get_line_sequence(q_new.position, neighbor.position)\n                    if grid.is_valid_line_sequence(line_new_n):\n                        # Remove one parent edge to neighbor (assume only one parent)\n                        if neighbor.parents:\n                            self._graph.remove_edge(next(iter(neighbor.parents)), neighbor)\n                        self._graph.add_edge(q_new, neighbor)\n                        neighbor.cost = cost_through_new\n                        self._update_descendants_cost(neighbor)\n\n            # Attempt connection to goal\n            line_to_goal = grid.get_line_sequence(q_new.position, goal_vertex.position)\n            dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_vertex.position.to_tensor()).item()\n            if grid.is_valid_line_sequence(line_to_goal):\n                cost_to_goal = q_new.cost + dist_to_goal\n                if cost_to_goal < goal_vertex.cost:\n                    # Connect q_new -> goal\n                    for p in list(goal_vertex.parents):\n                        self._graph.remove_edge(p, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_vertex.cost = cost_to_goal\n                    goal_reached = True\n\n            self.key_frame()\n\n            if goal_reached:\n                self._extract_path(goal_vertex)\n                return",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 224, in _find_path_internal\n  File \"<string>\", line 95, in _get_random_sample\nAttributeError: 'Point' object has no attribute 'values'\n"
     }
}
{
     "operator": "m3",
     "algorithm": "Improved sampling-based path planning algorithm that combines adaptive sampling \n    focusing near the goal with an anytime rewiring strategy inspired by RRT*.\n\n    Key features:\n    - Adaptive goal-bias sampling with dynamically adjusted radius to focus exploration efficiently.\n    - Anytime rewiring of the graph within a shrinking radius improving path quality progressively.\n    - Early pruning of costly connections based on incremental cost evaluation.\n    - Integration of time limit (60 sec) to abort search if no solution found.\n    - Uses cyclic graph structure enabling better edge manipulations and path smoothness.\n    - Balances exploration and exploitation dynamically based on iteration and search status.\n\n    The method aims for improved planning efficiency, path quality, robustness, and reduced search times.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: \"CyclicGraph\"\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n        start_v = Vertex(start_pos)\n        start_v.cost = 0\n        goal_v = Vertex(goal_pos)\n        self._graph = gen_cyclic_graph(self._services, start_v, goal_v, [])\n        self._init_displays()\n\n    def _get_random_sample(self, goal_bias=0.15, goal_sample_radius=15.0) -> Point:\n        \"\"\"Sample with bias: mostly uniform random, sometimes near goal within a radius.\"\"\"\n\n        grid = self._get_grid()\n        # Bias towards sampling near the goal position\n        if np.random.random() < goal_bias:\n            attempts = 0\n            while True:\n                # Sample in a circle around the goal (for 2D)\n                angle = np.random.uniform(0, 2 * np.pi)\n                radius = np.random.uniform(0, goal_sample_radius)\n                dx = radius * math.cos(angle)\n                dy = radius * math.sin(angle)\n                gp = grid.goal.position\n                candidate = Point(int(round(gp.x + dx)), int(round(gp.y + dy)))\n                attempts += 1\n                if grid.is_agent_valid_pos(candidate):\n                    return candidate\n                if attempts > 100:  # fallback to global random sampling\n                    break\n\n        # Uniform random sample in the entire map size\n        max_dims = grid.size.values\n        while True:\n            rand_pos = np.random.randint(0, max_dims, len(max_dims))\n            # Convert numpy ints to Python ints explicitly to avoid any float/index issues\n            rand_pos = tuple(int(pos) for pos in rand_pos)\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_v: Vertex, to_p: Point, max_dist: float) -> Vertex:\n        \"\"\"Return a new vertex in the direction from from_v to to_p with max step length max_dist.\"\"\"\n        dir_vec = to_p.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(to_p)\n        dir_norm = dir_vec / dist\n        new_pos_tensor = from_v.position.to_tensor() + dir_norm * max_dist\n        new_pos_list = new_pos_tensor.tolist()\n        # Round to nearest int coordinates to avoid floating point positions\n        new_pos_int = tuple(int(round(coord)) for coord in new_pos_list)\n        new_pos = Point(*new_pos_int)\n        return Vertex(new_pos)\n\n    def _get_nearest_vertex(self, point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, point)\n\n    def _get_nearby_vertices(self, vertex: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _cost(self, from_v: Vertex, to_v: Vertex) -> float:\n        return from_v.cost + self._get_grid().get_distance(from_v.position, to_v.position)\n\n    def _extract_path(self, last_vertex: Vertex) -> None:\n        # Goal vertex that references last vertex\n        goal_v = Vertex(self._get_grid().goal.position)\n        child_parent_dist = self._get_grid().get_distance(last_vertex.position, goal_v.position)\n        goal_v.cost = last_vertex.cost + child_parent_dist\n        self._graph.add_edge(last_vertex, goal_v)\n        path = [goal_v]\n\n        while path[-1].parents:\n            for p in path[-1].parents:\n                path.append(p)\n                break\n\n        path.pop()  # remove the root with no parents\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n\n        max_dist = 10.0\n        max_iter = 10000\n        dimension = grid.size.n_dim\n        max_time_sec = 60\n\n        start_time = time.time()\n\n        # Constants for radius calculation (RRT* inspired)\n        gamma_rrt_star = 50.0\n        goal_sample_radius = max(15.0, max_dist * 2)\n\n        # Initialize the start vertex cost (done in __init__)\n\n        for iter_count in range(max_iter):\n\n            if time.time() - start_time > max_time_sec:\n                # Treat search as failed after 60seconds\n                break\n\n            # Adaptive decreasing goal bias and radius for goal sampling\n            elapsed_ratio = iter_count / max_iter\n            goal_bias = max(0.1, 0.3 * (1.0 - elapsed_ratio))\n            adaptive_goal_radius = max(goal_sample_radius * (1.0 - elapsed_ratio), max_dist)\n\n            q_sample = self._get_random_sample(goal_bias=goal_bias, goal_sample_radius=adaptive_goal_radius)\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._steer(q_nearest, q_sample, max_dist)\n\n            # Check path between nearest and new is valid\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Radius for neighbors for rewiring, shrinking as tree grows\n            card_V = max(1, float(self._graph.size))\n            radius = min(\n                gamma_rrt_star * ((math.log(card_V) / card_V) ** (1 / dimension)),\n                max_dist * 3,\n            )\n\n            nearby_vertices = self._get_nearby_vertices(q_new, radius)\n\n            # Choose parent that minimizes cost and is collision free\n            q_min = q_nearest\n            c_min = self._cost(q_nearest, q_new)\n\n            for near_v in nearby_vertices:\n                # Edge collision check\n                if grid.is_valid_line_sequence(grid.get_line_sequence(near_v.position, q_new.position)):\n                    cost_through_near = self._cost(near_v, q_new)\n                    if cost_through_near < c_min:\n                        q_min = near_v\n                        c_min = cost_through_near\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if a cheaper path via q_new is found\n            for near_v in nearby_vertices:\n                if near_v == q_min:\n                    continue\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, near_v.position)):\n                    cost_via_new = q_new.cost + grid.get_distance(q_new.position, near_v.position)\n                    if near_v.cost is None or cost_via_new < near_v.cost:\n                        # Remove old parent edge (assumption: one parent per vertex in this graph)\n                        old_parent = None\n                        for p in near_v.parents:\n                            old_parent = p\n                            break\n                        if old_parent:\n                            self._graph.remove_edge(old_parent, near_v)\n                        near_v.cost = cost_via_new\n                        self._graph.add_edge(q_new, near_v)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 154, in _find_path_internal\n  File \"<string>\", line 81, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m2",
     "algorithm": "This improved path planning algorithm is a hybrid sample-based planner that blends RRT* style incremental tree construction\n    with informed sampling and rewiring heuristics for path quality improvement. It uses dynamic radius computation based on the \n    current graph size and environment scale to maintain efficient exploration and exploitation balance.\n    \n    Key Features:\n    - Adaptive sampling domain focused near start-goal elliptical region for efficiency.\n    - Use of cost-to-come and cost-to-go estimates for vertex rewiring (improves path quality).\n    - Dynamic neighborhood radius adjustment (to balance connectivity and complexity).\n    - Time-bounded search: stops planning if >60 seconds to prevent excessive computation.\n    - Edge validation using Bresenham line and environment collision checks.\n    - Path extraction includes backward traversal from goal to start.\n    - Smooth path by rewiring existing vertices when a better parent is found.\n    - Pruned search on goal proximity: when a vertex is close enough, attempts connection to goal.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_iterations: int\n    _max_radius: float\n    _max_extend_length: float\n    _start_time: float\n    _time_limit_sec: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_iterations = 20000\n        self._time_limit_sec = 60.0  # 1 minute limit\n        size = self._get_grid().size\n        # Max extend length relative to grid diagonal, capped limits\n        self._max_extend_length = max(5.0, min(20.0, (size.width ** 2 + size.height ** 2) ** 0.5 / 20))\n        self._max_radius = max(10.0, min(25.0, (size.width ** 2 + size.height ** 2) ** 0.5 / 4))\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Use informed sampling within an ellipse around start and goal to accelerate convergence.\n        If no solution found yet, sample uniformly.\n        \"\"\"\n        grid = self._get_grid()\n        start = grid.agent.position.to_tensor()\n        goal = grid.goal.position.to_tensor()\n\n        if not hasattr(self, '_best_cost') or self._best_cost is None:\n            # Uniform sampling\n            while True:\n                coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        dist_start_goal = torch.norm(goal - start).item()\n        c_best = self._best_cost\n        if c_best == float('inf') or c_best < dist_start_goal:\n            c_best = dist_start_goal * 1.5\n\n        # Sample within ellipse between start and goal defined by c_best\n        while True:\n            # Sample random point in unit circle (2D)\n            r1 = torch.rand(1).item()\n            r2 = torch.rand(1).item()\n            angle = 2 * 3.141592653589793 * r2\n            radius = r1 ** 0.5\n            x = radius * torch.cos(torch.tensor(angle)).item()\n            y = radius * torch.sin(torch.tensor(angle)).item()\n\n            # Scale factors of ellipse axis\n            a = c_best / 2.0\n            b = (c_best ** 2 - dist_start_goal ** 2) ** 0.5 / 2.0\n\n            # Rotate and translate ellipse point to map frame\n            direction = goal - start\n            unit_dir = direction / dist_start_goal\n            rot_matrix = torch.tensor([[unit_dir[0], -unit_dir[1]],\n                                       [unit_dir[1],  unit_dir[0]]])\n\n            sample_local = torch.tensor([a * x, b * y])\n            sample_global = start[:2] + torch.matmul(rot_matrix, sample_local)\n\n            # Clamp to map bounds and round to nearest int point for grid index\n            sx = int(max(0, min(self._get_grid().size.width - 1, round(sample_global[0].item()))))\n            sy = int(max(0, min(self._get_grid().size.height - 1, round(sample_global[1].item()))))\n            sample_pt = Point(sx, sy)\n\n            if self._get_grid().is_agent_valid_pos(sample_pt):\n                return sample_pt\n\n    def _steer(self, q_near: Vertex, q_rand: Point) -> Vertex:\n        \"\"\"\n        Produce a new vertex in the direction from q_near to q_rand but limited by max_extend_length.\n        \"\"\"\n        dir_vec = q_rand.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= self._max_extend_length:\n            return Vertex(q_rand)\n        dir_unit = dir_vec / dist\n        new_pos = q_near.position.to_tensor() + self._max_extend_length * dir_unit\n        new_pos = new_pos.round()  # round to nearest integer coordinate to avoid float Points in grid indexing\n        new_pos = new_pos.long()\n        new_pt = Point(*new_pos.tolist())\n        return Vertex(new_pt)\n\n    def _get_nearby_vertices(self, v: Vertex) -> List[Vertex]:\n        \"\"\"\n        Return the vertices within the dynamic radius for possible rewiring.\n        Radius adapts to node density: r = min(max_radius, gamma * (log(n)/n)^{1/d}),\n        here approximated by a constant max_radius for complexity.\n        \"\"\"\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, v.position, self._max_radius)\n\n    def _cost(self, v_from: Vertex, v_to: Vertex) -> float:\n        return self._get_grid().get_movement_cost(v_from.position, v_to.position)\n\n    def _choose_parent(self, q_new: Vertex, nearby_vertices: List[Vertex]) -> Optional[Vertex]:\n        \"\"\"\n        Choose a parent for new vertex from nearby vertices minimizing cost-to-come + cost edge.\n        \"\"\"\n        min_cost = float('inf')\n        best_parent = None\n        for v in nearby_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            new_cost = v.cost + self._cost(v, q_new)\n            if new_cost < min_cost:\n                min_cost = new_cost\n                best_parent = v\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, nearby_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Attempt to update the cost and parent of nearby vertices through q_new if it improves the cost-to-come.\n        \"\"\"\n        for v in nearby_vertices:\n            if v is q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            potential_cost = q_new.cost + self._cost(q_new, v)\n            if potential_cost < v.cost:\n                # Rewire: update parent link\n                # Remove old edges from parents and add new edges for consistency\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = potential_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        \"\"\"\n        Extract the best path by tracing backwards parents from goal vertex.\n        \"\"\"\n        path: List[Vertex] = [q_goal]\n        current = q_goal\n        while current.position != self._graph.root_vertex_start.position:\n            parents = list(current.parents)\n            if not parents:\n                break\n            # Since it's a tree, expect one parent\n            current = parents[0]\n            path.append(current)\n        path.reverse()\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _update_best_cost(self, q_new: Vertex) -> None:\n        \"\"\"\n        Update the global best cost if q_new improves the current value.\n        \"\"\"\n        dist_to_goal = Map.get_distance(q_new.position, self._graph.root_vertex_goal.position)\n        cost_estimate = q_new.cost + dist_to_goal\n        if not hasattr(self, '_best_cost') or cost_estimate < self._best_cost:\n            self._best_cost = cost_estimate\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n        root_start = self._graph.root_vertex_start\n        root_goal = self._graph.root_vertex_goal\n\n        root_start.cost = 0.0\n        root_goal.cost = float('inf')\n        self._best_cost = float('inf')\n\n        for iteration in range(self._max_iterations):\n\n            if time.time() - self._start_time > self._time_limit_sec:\n                # Planning failed due to time constraint\n                return\n\n            q_rand = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_rand)\n            q_new = self._steer(q_near, q_rand)\n\n            if q_new.position == q_near.position:\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find nearby vertices for parent selection and rewiring\n            neighbor_vertices = self._get_nearby_vertices(q_new)\n\n            parent = self._choose_parent(q_new, [q_near] + neighbor_vertices)\n            if parent is None:\n                continue\n\n            q_new.cost = parent.cost + self._cost(parent, q_new)\n            self._graph.add_edge(parent, q_new)\n\n            # Rewire nearby nodes for better paths\n            self._rewire(q_new, neighbor_vertices)\n\n            # Add the new vertex to root vertices for expanded search\n            self._graph.root_vertices.append(q_new)\n\n            # Check if goal can be connected/improved from q_new\n            dist_to_goal = Map.get_distance(q_new.position, root_goal.position)\n            if dist_to_goal <= self._max_extend_length:\n                line_to_goal = self._get_grid().get_line_sequence(q_new.position, root_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_to_goal):\n                    # Connect goal to q_new with an edge if better\n                    new_goal_cost = q_new.cost + self._cost(q_new, root_goal)\n                    if new_goal_cost < root_goal.cost:\n                        # Remove old parents of goal to keep single best\n                        for p in list(root_goal.parents):\n                            self._graph.remove_edge(p, root_goal)\n                        root_goal.cost = new_goal_cost\n                        self._graph.add_edge(q_new, root_goal)\n                        self._update_best_cost(root_goal)\n\n                        # Extract path and return success\n                        self._extract_path(root_goal)\n                        return\n\n            self._update_best_cost(q_new)\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 218, in _find_path_internal\n  File \"<string>\", line 113, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This is an enhanced anytime, asymptotically optimal sample-based path planning algorithm named\n    \"ANYTIME RRT*-SMART\" designed to improve planning efficiency, path quality, robustness,\n    success rate, path smoothness, and path length while reducing overall search time.\n\n    It uses a forest structure (similar to RRT*) and incorporates the following innovations:\n    - Adaptive sampling biased toward the goal and lower-cost vertices to improve convergence speed.\n    - Sample pruning to remove vertices unlikely to improve the path (focused search).\n    - A path shortcutting post-process on found paths to smooth and shorten the trajectory.\n    - A time-bound search with a hard limit of 60 seconds to guarantee responsiveness.\n    - Dynamic radius selection using RRT* radius scaling for rewiring.\n    - Cost-aware rewiring of the graph for asymptotic optimality.\n    - Early termination when a feasible path is found and improved sufficiently.\n\n    The algorithm maintains a forest rooted at start and goal and grows the graph iteratively.\n    Sampling is biased towards the goal and sampled vertices close to the current best path.\n\n    On success, the path is extracted and shortened with shortcuts to produce a smooth and\n    quality trajectory.\n\n    Overall, this approach aims to balance exploration and exploitation, quickly find feasible\n    paths, and continue improving them within a time budget.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        # Empty initial vertices, will build as we sample\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        self._max_dist = 12.0  # max extension step length\n        self._dim = self._get_grid().size.n_dim\n        self._goal_sample_rate = 0.1  # Probability of sampling the goal directly\n        self._max_runtime = 60.0  # seconds: hard stop for planning\n        self._lambda_rrt_star = 50.0  # constant for radius calculation\n\n        self._best_goal_vertex: Optional[Vertex] = None  # best vertex reaching goal\n        self._init_displays()\n\n    def _get_random_sample(self, bias_to_goal=False) -> Point:\n        \"\"\"\n        Samples a random valid point inside the grid.\n        If bias_to_goal is True, samples exactly the goal position.\n        \"\"\"\n        if bias_to_goal:\n            return self._get_grid().goal.position\n        while True:\n            # Sample uniformly in n dimensions within grid bounds\n            vals = [int(torch.randint(0, self._get_grid().size[i], (1,)).item()) for i in range(self._dim)]\n            # Explicitly create integer Point (avoid float) to pass is_agent_valid_pos check\n            p = Point(*vals)\n            # Defensive casting if Point constructor creates float based on inputs\n            # But test above shows Point stores int/floats from inputs correctly\n            # So no extra cast needed here\n            if self._get_grid().is_agent_valid_pos(p):\n                return p\n\n    def _steer(self, q_near: Vertex, q_rand: Point, max_dist: float) -> Optional[Vertex]:\n        \"\"\"\n        Returns a new vertex in the direction of q_rand from q_near at distance max_dist if\n        q_rand is farther than max_dist; else returns new vertex at q_rand (if valid).\n        \"\"\"\n        vec = q_rand.to_tensor() - q_near.position.to_tensor()\n        dist = float(torch.norm(vec))\n        if dist == 0:\n            return None\n        if dist <= max_dist:\n            new_pos = q_rand\n        else:\n            direction = vec / dist\n            new_pos_t = q_near.position.to_tensor() + max_dist * direction\n            # Round new_pos_t to nearest integers to ensure no float coords (Grid expects integer Points)\n            new_pos_ints = [int(round(v.item())) for v in new_pos_t]\n            new_pos = Point(*new_pos_ints)\n\n        if not self._get_grid().is_agent_valid_pos(new_pos):\n            return None\n        # Verify line between q_near and new_pos is free\n        line_seq = self._get_grid().get_line_sequence(q_near.position, new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        return Vertex(new_pos)\n\n    def _get_neighbors(self, v: Vertex, radius: float) -> List[Vertex]:\n        # Return vertices within radius from v to consider for rewiring\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], v.position, radius)\n\n    def _cost(self, frm: Point, to: Point) -> float:\n        # Cost function = Euclidean distance (can be adjusted if needed)\n        return float(torch.norm(frm.to_tensor() - to.to_tensor()))\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> (Optional[Vertex], float):\n        \"\"\"\n        Choose the best parent for q_new among neighbors minimizing cost + edge cost,\n        and valid collision-free path.\n        \"\"\"\n        c_min = math.inf\n        q_min = None\n        for q_near in neighbors:\n            # Check line collision between q_near and q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cost = q_near.cost + self._cost(q_near.position, q_new.position)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n        return q_min, c_min\n\n    def _rewire(self, neighbors: List[Vertex], q_new: Vertex) -> None:\n        \"\"\"\n        For each neighbor, check if path cost can be reduced by rewiring through q_new.\n        \"\"\"\n        for q_near in neighbors:\n            if q_new in q_near.parents:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_new = q_new.cost + self._cost(q_new.position, q_near.position)\n            if cost_new < q_near.cost:\n                # Remove old edges\n                old_parents = list(q_near.parents)\n                for old_parent in old_parents:\n                    self._graph.remove_edge(old_parent, q_near)\n                # Add new edge\n                q_near.cost = cost_new\n                self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Point]:\n        \"\"\"\n        Extracts the path from start to the given goal vertex by parents chain.\n        Returns list of Points from start to goal.\n        \"\"\"\n        path_vertices = []\n        current = goal_vertex\n        while current:\n            path_vertices.append(current)\n            if len(current.parents) == 0:\n                break\n            # We choose one parent (e.g. first) since this is a tree\n            current = next(iter(current.parents))\n        path_vertices.reverse()\n        return [v.position for v in path_vertices]\n\n    def _shortcut_path(self, path: List[Point], max_iterations=50) -> List[Point]:\n        \"\"\"\n        Applies simple shortcutting heuristic by attempting to replace intermediate points with\n        direct edges if they are collision free, repeated max_iterations times.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        for _ in range(max_iterations):\n            if len(path) < 3:\n                break\n            # Pick two indices i,j with j>i+1\n            i = int(torch.randint(0, len(path) - 2, (1,)).item())\n            j = int(torch.randint(i + 2, len(path), (1,)).item())\n\n            if j >= len(path) or i < 0 or i >= j:\n                continue\n            start = path[i]\n            end = path[j]\n            line_seq = self._get_grid().get_line_sequence(start, end)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                # Remove intermediate points between i and j\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        iterations = 0\n        max_iterations = 20000  # Cap to prevent infinite loops if time runs long\n        found_path = False\n        best_cost = math.inf\n\n        while True:\n            elapsed = time.time() - start_time\n            if elapsed > self._max_runtime:\n                # Fail and stop search if time exceeded\n                break\n            if iterations >= max_iterations:\n                break\n\n            iterations += 1\n\n            # Sampling: With probability goal_sample_rate sample goal, otherwise random\n            sample_goal_bias = torch.rand(1).item() < self._goal_sample_rate\n            q_sample = self._get_random_sample(bias_to_goal=sample_goal_bias)\n\n            # Nearest vertex in tree to sample\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n            # Steer towards q_sample from q_nearest with max extension limit\n            q_new = self._steer(q_nearest, q_sample, self._max_dist)\n            if q_new is None:\n                continue\n\n            # Determine radius for neighbor search (RRT* formula)\n            card_v = float(self._graph.size + 1)  # +1 to avoid log(0)\n            radius = min(self._lambda_rrt_star * ((math.log(card_v) / card_v) ** (1 / self._dim)), self._max_dist * 5)\n\n            # Find neighbors in radius\n            neighbors = self._get_neighbors(q_new, radius)\n\n            # Choose best parent among neighbors\n            q_min, c_min = self._choose_parent(neighbors, q_new)\n            if q_min is None:\n                # If no suitable parent found, abandon q_new\n                continue\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors through q_new if better\n            self._rewire(neighbors, q_new)\n\n            # Add new vertex to roots to keep track\n            self._graph.root_vertices.append(q_new)\n\n            # Check if q_new can connect to goal directly and improve path cost\n            dist_to_goal = float(torch.norm(q_new.position.to_tensor() - self._graph.root_vertex_goal.position.to_tensor()))\n            if dist_to_goal <= self._max_dist:\n                # Check collision to goal\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, self._graph.root_vertex_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    cost_to_goal = q_new.cost + dist_to_goal\n                    if cost_to_goal < best_cost:\n                        best_cost = cost_to_goal\n                        goal_vertex = Vertex(self._graph.root_vertex_goal.position)\n                        goal_vertex.cost = cost_to_goal\n                        self._graph.add_edge(q_new, goal_vertex)\n                        self._best_goal_vertex = goal_vertex\n                        self._graph.root_vertices.append(goal_vertex)\n                        found_path = True\n\n                        # If path is found, optionally run keyframe for visualization\n                        self.key_frame()\n\n            self.key_frame()\n\n            # Early stop if a good enough path is found (e.g. cost < threshold)\n            if found_path and best_cost < self._max_dist * 4:\n                break\n\n        # If a path was found, extract and shortcut path, then follow it\n        if found_path and self._best_goal_vertex is not None:\n            path = self._extract_path(self._best_goal_vertex)\n            path = self._shortcut_path(path, max_iterations=100)\n            for p in path:\n                self.move_agent(p)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 217, in _find_path_internal\n  File \"<string>\", line 77, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m1",
     "algorithm": "This algorithm implements an enhanced RRT*-inspired bidirectional sampling approach combined with local\n    rewiring and path smoothing to improve planning efficiency, path quality, and robustness. It samples new points\n    from both the start and goal trees to rapidly explore the space, connects vertices using a radius-based neighborhood,\n    performs rewiring to optimize path cost, and includes a post-processing step that smooths the extracted path.\n    Designed to handle varying map sizes, the search fails if planning exceeds 60 seconds. The approach balances \n    exploration, exploitation, and refinement to produce shorter, smoother paths with improved success rates.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _max_iter: int = 10000\n    _max_dist: float\n    _rewire_radius: float\n    _start_vertex: Vertex\n    _goal_vertex: Vertex\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        agent_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n\n        # Initialize start and goal vertices with connectivity stored\n        self._start_vertex = Vertex(agent_pos, store_connectivity=True)\n        self._goal_vertex = Vertex(goal_pos, store_connectivity=True)\n\n        # Empty initial set of vertices: add start & goal as roots plus no samples yet\n        self._graph = gen_cyclic_graph(\n            self._services,\n            self._start_vertex,\n            self._goal_vertex,\n            []\n        )\n        self._graph.edges_removable = True\n\n        # Set parameters adaptive to map size (heuristic)\n        map_diag = torch.norm(torch.tensor(self._get_grid().size.values, dtype=torch.float))\n        self._max_dist = max(5.0, float(map_diag.item()) * 0.1)  # max extension distance ~10% map diag\n        self._rewire_radius = max(8.0, float(map_diag.item()) * 0.15)  # radius for near vertices rewiring\n\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Uniformly sample a random valid point in the map.\"\"\"\n        size = self._get_grid().size\n        while True:\n            coords = [np.random.randint(0, size[i]) for i in range(size.n_dim)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_v: Vertex, to_p: Point, max_dist: float) -> Vertex:\n        \"\"\"Generate a new vertex in direction from 'from_v' toward 'to_p' limited by max_dist.\"\"\"\n        from_tensor = from_v.position.to_tensor()\n        to_tensor = to_p.to_tensor()\n        direction = to_tensor - from_tensor\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            new_pos = to_p\n        else:\n            direction_normalized = direction / dist\n            new_pos = Point.from_tensor(from_tensor + max_dist * direction_normalized)\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _near_vertices(self, point: Point) -> List[Vertex]:\n        \"\"\"Get list of vertices within rewire radius from point in graph's root vertices.\"\"\"\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, point, self._rewire_radius)\n\n    def _is_collision_free(self, from_p: Point, to_p: Point) -> bool:\n        \"\"\"Check if path between from_p and to_p is free of obstacles.\"\"\"\n        line_seq = self._get_grid().get_line_sequence(from_p, to_p)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _choose_parent(self, near_vertices: List[Vertex], new_vertex: Vertex) -> Optional[Vertex]:\n        \"\"\"Choose best parent minimizing cost + movement cost among neighbors that are collision free.\"\"\"\n        min_cost = None\n        best_parent = None\n        for vertex in near_vertices:\n            if vertex.position == new_vertex.position:\n                continue\n            if not self._is_collision_free(vertex.position, new_vertex.position):\n                continue\n            cost_to_new = vertex.cost if vertex.cost is not None else 0.0\n            move_cost = self._get_grid().get_movement_cost(vertex.position, new_vertex.position)\n            total_cost = cost_to_new + move_cost\n            if (min_cost is None) or (total_cost < min_cost):\n                min_cost = total_cost\n                best_parent = vertex\n        if best_parent is not None:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], new_vertex: Vertex) -> None:\n        \"\"\"Try to shortcut existing vertices via new_vertex if cost improves and path is collision free.\"\"\"\n        for vertex in near_vertices:\n            if vertex == new_vertex:\n                continue\n            if vertex.cost is None:\n                continue\n            if not self._is_collision_free(new_vertex.position, vertex.position):\n                continue\n            move_cost = self._get_grid().get_movement_cost(new_vertex.position, vertex.position)\n            new_cost = new_vertex.cost + move_cost\n            if vertex.cost > new_cost:\n                # Remove old parent edge and add new edge from new_vertex\n                for parent in list(vertex.parents):\n                    self._graph.remove_edge(parent, vertex)\n                self._graph.add_edge(new_vertex, vertex)\n                vertex.cost = new_cost\n\n    def _extract_path(self) -> List[Vertex]:\n        \"\"\"Extract the path by walking from goal to start via parents with min cost.\"\"\"\n        path = []\n        current = self._goal_vertex\n        # If the goal vertex cost is None, treat it as infinity - no path found\n        if current.cost is None:\n            return path\n\n        # We trace the lowest cost parents backward to the start.\n        while current != self._start_vertex:\n            path.append(current)\n            if not current.parents:\n                break\n            # Among parents choose one with min cost\n            current = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n        path.append(self._start_vertex)\n        path.reverse()\n        return path\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"Smooth the path by shortcutting between non-consecutive vertices when collision free.\"\"\"\n        if not path or len(path) < 3:\n            return path\n        smooth_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            # Try to find farthest vertex shortcut reachable\n            for j in range(len(path) - 1, idx, -1):\n                if self._is_collision_free(path[idx].position, path[j].position):\n                    next_idx = j\n                    break\n            smooth_path.append(path[next_idx])\n            idx = next_idx\n        return smooth_path\n\n    def _bidirectional_sample(self) -> Point:\n        \"\"\"Generate a random sample choosing goal bias with probability 0.1 to speed convergence.\"\"\"\n        if np.random.rand() < 0.1:\n            return self._goal_vertex.position\n        else:\n            return self._get_random_sample()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        # Initialize root vertices cost to zero\n        self._start_vertex.cost = 0.0\n        self._goal_vertex.cost = None  # Goal cost unknown initially\n\n        # Vertices storage: start tree and goal tree roots plus sampled vertices\n        sampled_vertices: List[Vertex] = []\n\n        # Alternate between extending start and goal trees\n        extend_start = True\n\n        for iter_count in range(self._max_iter):\n            # Time check\n            elapsed = time.time() - start_time\n            if elapsed > 60.0:\n                # Failed to find path within time limit\n                return  # Exit _find_path_internal without path extraction\n\n            # Sample point\n            q_sample = self._bidirectional_sample()\n\n            if extend_start:\n                tree_root_list = [self._start_vertex] + sampled_vertices\n            else:\n                tree_root_list = [self._goal_vertex] + sampled_vertices\n\n            # Find nearest vertex in the current tree\n            q_near = self._graph.get_nearest_vertex(tree_root_list, q_sample)\n            if q_near.position == q_sample:\n                # Sampled same point, try next iteration\n                extend_start = not extend_start\n                self.key_frame()\n                continue\n\n            # Steer towards sample within max_dist\n            q_new = self._steer(q_near, q_sample, self._max_dist)\n\n            if q_new.position == q_near.position:\n                extend_start = not extend_start\n                self.key_frame()\n                continue\n\n            if not self._is_collision_free(q_near.position, q_new.position):\n                extend_start = not extend_start\n                self.key_frame()\n                continue\n\n            # Find nearby vertices for potential better parent and rewiring\n            near_vertices = self._near_vertices(q_new.position)\n            if not near_vertices:\n                # No nearby vertices, connect to nearest vertex only\n                q_new.cost = (q_near.cost if q_near.cost is not None else 0.0) + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n                self._graph.add_edge(q_near, q_new)\n            else:\n                # Choose best parent among near vertices\n                best_parent = self._choose_parent(near_vertices, q_new)\n                if best_parent is None:\n                    # fallback: connect to q_near directly if no better parent found\n                    q_new.cost = (q_near.cost if q_near.cost is not None else 0.0) + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n                    best_parent = q_near\n                self._graph.add_edge(best_parent, q_new)\n                # Attempt to rewire neighbors using new vertex\n                self._rewire(near_vertices, q_new)\n\n            sampled_vertices.append(q_new)\n\n            # Attempt connection to the opposite tree for bidirectional path completion\n            other_tree_roots = [self._goal_vertex] if extend_start else [self._start_vertex]\n            # Also consider sampled vertices for opposite tree\n            other_tree_roots += sampled_vertices\n\n            q_connect_candidates = self._graph.get_vertices_within_radius(other_tree_roots, q_new.position, self._max_dist)\n            connected = False\n            for q_other in q_connect_candidates:\n                if q_other == q_new:\n                    continue\n                if self._is_collision_free(q_new.position, q_other.position):\n                    # Connect trees by adding bidirectional edges\n                    self._graph.add_edge(q_new, q_other)\n                    self._graph.add_edge(q_other, q_new)\n                    # Update costs if possible\n                    if q_other.cost is None and q_new.cost is not None:\n                        q_other.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_other.position)\n                    elif q_new.cost is None and q_other.cost is not None:\n                        q_new.cost = q_other.cost + self._get_grid().get_movement_cost(q_other.position, q_new.position)\n\n                    connected = True\n                    break\n\n            # Check if start and goal are connected\n            if self._goal_vertex in self._start_vertex.connectivity:\n                path = self._extract_path()\n                if not path:\n                    # If extraction failed, continue searching\n                    extend_start = not extend_start\n                    self.key_frame()\n                    continue\n                # Smooth the extracted path\n                smooth_path = self._smooth_path(path)\n\n                # Animate movement along smooth path\n                for vertex in smooth_path:\n                    self.move_agent(vertex.position)\n                    self.key_frame(ignore_key_frame_skip=True)\n                return\n\n            extend_start = not extend_start\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 206, in _find_path_internal\n  File \"<string>\", line 183, in _bidirectional_sample\n  File \"<string>\", line 80, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "e2",
     "algorithm": "This algorithm is a hybrid path planner combining strengths of RRT-Connect and informed sampling methods for\n    improved efficiency, path quality, robustness, and success rate. It uses bidirectional trees growing towards sampled\n    points with adaptive pruning and rewiring inspired by RRT* concepts, ensuring smoother, shorter paths.\n    It employs heuristic informed sampling biased towards the goal neighborhood for faster convergence.\n    The planner dynamically shortens and smooths the path during extraction.\n    A 60-second timeout guards against excessive computation time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _timeout_sec: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n        self._init_displays()\n        self._max_dist = max(self._get_grid().size.width, self._get_grid().size.height) / 20.0\n        self._iterations = 15000\n        self._timeout_sec = 60.0\n\n    def _get_random_sample_informed(self, c_best: Optional[float]) -> Point:\n        \"\"\"Informed sampling within an ellipse bounded by current best path length c_best.\"\"\"\n        grid = self._get_grid()\n        start = grid.agent.position.to_tensor()\n        goal = grid.goal.position.to_tensor()\n        n_dim = start.shape[0]\n\n        if c_best is None or c_best >= float('inf'):\n            # Uniform sample in space\n            while True:\n                rand_pos = torch.tensor([np.random.randint(0, s) for s in grid.size.values], dtype=torch.int64)  # ensure int64 tensor for Point\n                sample = Point(*rand_pos.tolist())\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Sample inside prolate hyperspheroid ellipse biasing toward goal\n            c_min = (goal - start).norm().item()\n            if c_min < 1e-6:\n                # Ensure to return int coordinates point\n                goal_int = Point(*goal.int().tolist())\n                return goal_int\n\n            # Transformation matrix for unit ball to ellipse\n            a1 = (goal - start) / c_min  # unit vector from start to goal\n            I = torch.eye(n_dim)\n            M = a1.unsqueeze(1) @ a1.unsqueeze(0)\n            U = I - M  # orthogonal complement projection\n\n            # Radii of ellipse along axes\n            r1 = c_best / 2.\n            r2 = (c_best ** 2 - c_min ** 2) ** 0.5 / 2.\n\n            while True:\n                # Sample unit ball\n                direction = torch.randn(n_dim)\n                direction /= direction.norm()\n                radius = torch.rand(1).item() ** (1.0 / n_dim)\n                unit_ball_sample = radius * direction\n\n                # Map unit ball sample to ellipse sample\n                ellipse_sample = r1 * a1 + r2 * (U @ unit_ball_sample)\n                sample_pt = (ellipse_sample + (start + goal) / 2.)\n                # Round and convert to int for Point (to avoid float Point which causes error)\n                sample_int = Point(*sample_pt.round().int().tolist())\n\n                if all(0 <= sample_int[i] < s for i, s in enumerate(self._get_grid().size.values)) and grid.is_agent_valid_pos(sample_int):\n                    return sample_int\n\n    def _get_nearest_vertex(self, root_vertices: List[Vertex], point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(root_vertices, point)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Optional[Vertex]:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = dir_vec.norm().item()\n        if dist < 1e-6:\n            return None\n\n        if dist <= self._max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / dist\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_pos_int = Point(*new_pos_tensor.round().int().tolist())\n            q_new_pos = new_pos_int\n\n        if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new_pos)):\n            return None\n\n        return Vertex(q_new_pos)\n\n    def _add_vertex_with_rewiring(self, q_new: Vertex, root_vertices: List[Vertex]) -> None:\n        \"\"\"Add vertex and connect with minimal cost parent within radius; rewire neighbors for better paths.\"\"\"\n        grid = self._get_grid()\n        neighborhood_radius = self._max_dist * 2.5\n\n        # Find neighbors within radius\n        neighbors = self._graph.get_vertices_within_radius(root_vertices, q_new.position, neighborhood_radius)\n        if not neighbors:\n            # Connect to nearest vertex if no neighbors\n            q_near = self._get_nearest_vertex(root_vertices, q_new.position)\n            self._graph.add_edge(q_near, q_new)\n            q_new.cost = (q_near.cost if q_near.cost is not None else 0) + grid.get_movement_cost(q_near.position, q_new.position)\n            return\n\n        # Find best parent from neighbors minimizing cost+distance\n        best_parent = None\n        best_cost = float('inf')\n        for neighbor in neighbors:\n            if neighbor.cost is None:\n                continue\n            tentative_cost = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new.position)\n            if tentative_cost < best_cost and self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position)):\n                best_cost = tentative_cost\n                best_parent = neighbor\n\n        if best_parent is None:\n            # fallback connect to nearest\n            q_near = self._get_nearest_vertex(root_vertices, q_new.position)\n            self._graph.add_edge(q_near, q_new)\n            q_new.cost = (q_near.cost if q_near.cost is not None else 0) + grid.get_movement_cost(q_near.position, q_new.position)\n            return\n\n        # Add edge from best parent\n        self._graph.add_edge(best_parent, q_new)\n        q_new.cost = best_cost\n\n        # Rewire neighbors if better through q_new\n        for neighbor in neighbors:\n            if neighbor is best_parent:\n                continue\n            if neighbor.cost is None:\n                continue\n            cost_through_qnew = q_new.cost + grid.get_movement_cost(q_new.position, neighbor.position)\n            if cost_through_qnew < neighbor.cost and self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                # Remove old parent edges\n                for p in list(neighbor.parents):\n                    self._graph.remove_edge(p, neighbor)\n                # Add new better parent edge\n                self._graph.add_edge(q_new, neighbor)\n                neighbor.cost = cost_through_qnew\n\n    def _try_connect_trees(self) -> Optional[Tuple[Vertex, Vertex]]:\n        \"\"\"Try to connect root vertices of the two trees to form path, return connected vertices or None.\"\"\"\n        start_roots = [self._graph.root_vertex_start]\n        goal_roots = [self._graph.root_vertex_goal]\n\n        for sv in list(start_roots):\n            for gv in list(goal_roots):\n                if Map.get_distance(sv.position, gv.position) <= self._max_dist:\n                    # Check if can connect directly\n                    line_seq = self._get_grid().get_line_sequence(sv.position, gv.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        return sv, gv\n        return None\n\n    def _extract_path(self, connect_pair: Tuple[Vertex, Vertex]) -> None:\n        \"\"\"Extract and smooth path from start to goal through connected pair vertices, animate movement.\"\"\"\n        start_vertex, goal_vertex = connect_pair\n\n        # Trace backward from start vertex to root start\n        path_start = [start_vertex]\n        while len(path_start[-1].parents) != 0:\n            parent = next(iter(path_start[-1].parents))\n            path_start.append(parent)\n        path_start.reverse()\n\n        # Trace backward from goal vertex to root goal\n        path_goal = [goal_vertex]\n        while len(path_goal[-1].parents) != 0:\n            parent = next(iter(path_goal[-1].parents))\n            path_goal.append(parent)\n\n        # Combine paths (exclude duplicate join vertex)\n        full_path = path_start + path_goal\n\n        # Attempt path smoothing by shortcutting intermediate points\n        smoothed_path = self._smooth_path(full_path)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"Attempt to shortcut path by checking if line between non-adjacent vertices is valid.\"\"\"\n        if len(path) < 3:\n            return path\n\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(path[i].position, path[j].position)):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _update_costs_on_root(self, root_vertex: Vertex) -> None:\n        \"\"\"Propagate costs from root vertex through children (BFS).\"\"\"\n        root_vertex.cost = 0\n        queue = [root_vertex]\n        while queue:\n            current = queue.pop(0)\n            for child in current.children:\n                cost = current.cost + self._get_grid().get_movement_cost(current.position, child.position)\n                if child.cost is None or cost < child.cost:\n                    child.cost = cost\n                    queue.append(child)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n\n        # Initialize costs for start and goal root vertices\n        self._graph.root_vertex_start.cost = 0\n        self._graph.root_vertex_goal.cost = 0\n\n        start_time = time.time()\n        best_path_cost = float('inf')\n        best_connect_pair = None\n\n        for i in range(self._iterations):\n            if time.time() - start_time > self._timeout_sec:\n                # Fail on timeout\n                break\n\n            c_best = best_path_cost if best_path_cost != float('inf') else None\n            # Sample point using informed sampling\n            q_rand = self._get_random_sample_informed(c_best)\n\n            # Select tree to extend (alternate or based on heuristic)\n            extend_tree_idx = i % 2\n            root_vertex = self._graph.root_vertices[extend_tree_idx]\n\n            q_near = self._get_nearest_vertex([root_vertex], q_rand)\n            q_new = self._get_new_vertex(q_near, q_rand)\n            if q_new is None:\n                self.key_frame()\n                continue\n\n            # Add vertex with rewiring to improve path quality in that tree\n            self._add_vertex_with_rewiring(q_new, [root_vertex])\n\n            # Update costs on this tree from root\n            self._update_costs_on_root(root_vertex)\n\n            # Try to connect the other tree to this newly added vertex\n            other_tree_root = self._graph.root_vertices[1 - extend_tree_idx]\n            q_near_other = self._get_nearest_vertex([other_tree_root], q_new.position)\n\n            dist = Map.get_distance(q_near_other.position, q_new.position)\n            if dist <= self._max_dist:\n                line_seq = grid.get_line_sequence(q_near_other.position, q_new.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Add connection edge\n                    if extend_tree_idx == 1:\n                        self._graph.add_edge(q_near_other, q_new)\n                    else:\n                        self._graph.add_edge(q_new, q_near_other)\n\n                    # Update costs on other tree root after adding connection edge\n                    self._update_costs_on_root(other_tree_root)\n\n                    # Calculate combined path cost\n                    cost_start = self._graph.root_vertex_start.cost if self._graph.root_vertex_start.cost else 0\n                    cost_goal = self._graph.root_vertex_goal.cost if self._graph.root_vertex_goal.cost else 0\n                    total_cost = (q_new.cost if q_new.cost is not None else 0) + (q_near_other.cost if q_near_other.cost is not None else 0) + dist\n\n                    if total_cost < best_path_cost:\n                        best_path_cost = total_cost\n                        if extend_tree_idx == 0:\n                            best_connect_pair = (q_new, q_near_other)\n                        else:\n                            best_connect_pair = (q_near_other, q_new)\n\n                    # Extract and animate path\n                    if best_connect_pair:\n                        self._extract_path(best_connect_pair)\n                        break\n\n            # Alternate trees\n            self._graph.reverse_root_vertices()\n            self.key_frame()\n\n        # If no path found in time and best_connect_pair exists, extract it\n        if best_connect_pair:\n            self._extract_path(best_connect_pair)",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 266, in _find_path_internal\n  File \"<string>\", line 69, in _get_random_sample_informed\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "e2",
     "algorithm": "This algorithm is a hybrid sample-based planner combining principles from SPRM and RRT*.\n    It enhances planning efficiency and path quality by:\n      - Using adaptive sampling biased towards the goal and unexplored regions\n      - Incrementally rewiring the graph for better paths (inspired by RRT*)\n      - Connecting vertices in a cyclic fashion and pruning longer edges to keep graph manageable\n      - Using radius-based near vertex search that adapts with vertex density to balance connectivity and performance\n      - Applying dynamic edge validation with bresenhamline to reduce invalid expansions\n      - Early termination after success or if path quality improvement stalls\n      - Active timeout management (stops if planning exceeds 60s)\n    This results in improved success rate, smoother and shorter paths, and reduced search time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n    _max_extend_dist: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 300\n        self._max_radius = 12.0   # radius for near neighbors, tuned for connectivity\n        self._max_extend_dist = 6.0  # max distance to extend toward sampled point\n\n        V: List[Vertex] = list()\n        for _ in range(self._V_size):\n            q_rand: Point = self._biased_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n\n        self._graph = gen_cyclic_graph(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            V,\n        )\n        self._graph.edges_removable = True  # allow dynamic rewiring/removal for path quality\n        self._init_displays()\n\n    def _biased_sample(self) -> Point:\n        \"\"\"\n        Sampling strategy biased toward the goal or unexplored space.\n        Probability 0.2 to sample exactly the goal position.\n        Probability 0.8 sample uniformly valid anywhere else.\n        \"\"\"\n        if torch.rand(1).item() < 0.2:\n            return self._get_grid().goal.position\n        while True:\n            sample = Point(\n                *[\n                    torch.randint(0, self._get_grid().size[i], (1,)).item()\n                    for i in range(self._get_grid().size.n_dim)\n                ]\n            )\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _near(self, vertex: Vertex, radius: Optional[float] = None) -> List[Vertex]:\n        r = radius if radius is not None else self._max_radius\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, r)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / norm\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _is_edge_valid(self, from_pos: Point, to_pos: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(from_pos, to_pos)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _rewire(self, vertex: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"\n        Attempts to improve the existing path tree by rewiring neighbors to vertex if it reduces cost.\n        \"\"\"\n        for neighbor in neighbors:\n            if neighbor is vertex:\n                continue\n            if self._is_edge_valid(vertex.position, neighbor.position):\n                cost_current = neighbor.cost if neighbor.cost is not None else float(\"inf\")\n                cost_new = vertex.cost + self._get_grid().get_movement_cost(vertex.position, neighbor.position)\n                if cost_new < cost_current:\n                    # Remove other parents that produce higher cost edges if removable\n                    for parent in list(neighbor.parents):\n                        if self._graph.edges_removable:\n                            self._graph.remove_edge(parent, neighbor)\n                    # Add new edge from vertex to neighbor\n                    self._graph.add_edge(vertex, neighbor)\n                    neighbor.cost = cost_new\n\n    def _extract_path(self) -> None:\n        goal_vertex = self._graph.root_vertex_goal\n        agent_vertex = self._graph.root_vertex_start\n\n        # Reconstruct path in forward direction using connectivity dict index\n        if goal_vertex not in agent_vertex.connectivity:\n            return\n\n        current_vertex = agent_vertex\n        path: List[Vertex] = []\n        while current_vertex is not goal_vertex:\n            current_vertex = current_vertex.connectivity[goal_vertex]\n            path.append(current_vertex)\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _initialize_costs(self) -> None:\n        \"\"\"\n        Initialize costs for all vertices starting from agent position.\n        Uses Dijkstra-like propagation with BFS.\n        \"\"\"\n        INF = float(\"inf\")\n        for v in self._graph.root_vertices:\n            v.cost = INF\n        start = self._graph.root_vertex_start\n        start.cost = 0.0\n\n        # BFS queue for cost relaxation\n        queue: List[Vertex] = [start]\n        visited: Set[Vertex] = {start}\n        while queue:\n            current = queue.pop(0)\n            cur_cost = current.cost\n            neighbors = list(current.connectivity)\n            for neighbor in neighbors:\n                step_cost = self._get_grid().get_movement_cost(current.position, neighbor.position)\n                new_cost = cur_cost + step_cost\n                if neighbor.cost is None or neighbor.cost > new_cost:\n                    neighbor.cost = new_cost\n                    if neighbor not in visited:\n                        queue.append(neighbor)\n                        visited.add(neighbor)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        max_time = 60.0  # max allowed time in seconds\n\n        # Set initial cost and graph connectivity for start vertex\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n\n        # Attempt to incrementally connect graph for max iterations or until timeout\n        for iteration in range(self._V_size * 8):\n            if (time.time() - start_time) > max_time:\n                # Planning failed due to timeout\n                return\n\n            # Sample random point biased towards goal/unexplored\n            q_sample = self._biased_sample()\n\n            # Find nearest vertex to sample in graph\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n            # Steer towards sample with max extend distance\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_extend_dist)\n\n            # Check if position already sampled approximately (avoid duplicates)\n            near_to_new = self._near(Vertex(q_new))\n            if any(torch.dist(torch.tensor(q_new.values), torch.tensor(v.position.values)) < 1e-2 for v in near_to_new):\n                # Skip too close samples for efficiency\n                continue\n\n            # Validate edge from q_near to q_new (collision free?)\n            if not self._is_edge_valid(q_near.position, q_new):\n                continue\n\n            # Create vertex and add it to graph\n            v_new = Vertex(q_new, store_connectivity=True)\n            v_new.cost = float(\"inf\")  # initialize cost as infinity\n\n            # Add vertex to graph's root vertex list for connectivity queries\n            self._graph.root_vertices.append(v_new)\n\n            # Add edge from nearest vertex to new vertex\n            self._graph.add_edge(q_near, v_new)\n\n            # Update cost to new vertex\n            v_new.cost = q_near.cost + self._get_grid().get_movement_cost(q_near.position, v_new.position)\n\n            # Find neighbors within radius (adaptive based on exploration density)\n            neighbors = self._near(v_new)\n\n            # Connect/rewire neighbors if new connections are better (improves path cost)\n            for neighbor in neighbors:\n                if neighbor is v_new:\n                    continue\n                if self._is_edge_valid(v_new.position, neighbor.position):\n                    cost_through_new = v_new.cost + self._get_grid().get_movement_cost(v_new.position, neighbor.position)\n                    if neighbor.cost is None or cost_through_new < neighbor.cost:\n                        self._graph.add_edge(v_new, neighbor)\n                        self._graph.add_edge(neighbor, v_new)\n                        neighbor.cost = cost_through_new\n\n            self._rewire(v_new, neighbors)\n\n            self.key_frame()\n\n            # Check connectivity: if goal connected in start's connectivity map, path found\n            if goal_vertex in start_vertex.connectivity:\n                # Initialize cost estimates across graph for smooth extraction\n                self._initialize_costs()\n                self._extract_path()\n                return",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 215, in __run_simulation\n    sim: Simulator = Simulator(Services(config))\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 40, in __init__\n    self.__setup(config)\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 68, in __setup\n    self.__algorithm_runner.reset_algorithm()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\algorithm_runner.py\", line 59, in reset_algorithm\n    self.__algorithm = self.__algorithm_type(self._services, testing, *self.__algorithm_parameters[0],\n  File \"<string>\", line 55, in __init__\n  File \"<string>\", line 82, in _biased_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m1",
     "algorithm": "This algorithm integrates and improves upon sampling-based algorithms like RRT and SPRM,\n    combining efficient exploration with intelligent rewiring for optimal path quality.\n    It does the following:\n    - Uses informed sampling biased towards the goal to improve convergence speed.\n    - Uses a variable radius nearest neighbor search for rewiring to improve path quality.\n    - Employs a cost-to-come plus heuristic cost-to-go for vertex cost and prioritization.\n    - Uses early stopping when goal is reached.\n    - Uses a timestamp to terminate if planning exceeds 60 seconds.\n    - After finding the path, performs a path smoothing step to reduce sharp turns.\n    - Stores connectivity in a cyclic graph structure for rewiring edges.\n    - Supports 2D or higher dimensional maps.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius_init: float\n    _max_step: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._V_size = 300   # reasonable number of vertices\n        self._max_step = 12.0\n        self._max_radius_init = 20.0\n        V = list()\n\n        # start and goal vertices with connectivity info\n        start_v = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_v = Vertex(self._get_grid().goal.position, store_connectivity=True)\n\n        # Pre-fill samples biased toward goal region for informed exploration\n        for i in range(self._V_size):\n            V.append(self._sample_informed(goal_v.position))\n        self._graph = gen_cyclic_graph(self._services, start_v, goal_v, V)\n        self._graph.edges_removable = True  # allow rewiring for optimization\n\n        # Initialize cost of start vertex as 0, others as inf\n        start_v.cost = 0.0\n        for v in self._graph.root_vertices:\n            if v is not start_v:\n                v.cost = float('inf')\n\n        self._init_displays()\n\n    def _sample_informed(self, goal_pos: Point) -> Point:\n        \"\"\"Sample a point biased toward the goal, with fallback to uniform random if needed.\"\"\"\n        g = goal_pos\n        map_size = self._get_grid().size\n        for _ in range(10):\n            # Informed sampling: sample a point in an ellipse or near goal region\n            # For simplicity, here bias sampling toward goal +/- radius region\n            delta = 10\n            low = [max(0, g[i] - delta) for i in range(map_size.n_dim)]\n            high = [min(map_size[i] - 1, g[i] + delta) for i in range(map_size.n_dim)]\n\n            coords = []\n            for dim in range(map_size.n_dim):\n                val = int(torch.randint(low[dim], high[dim] + 1, (1,)).item())\n                coords.append(val)\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n        # fallback: uniform random valid sample\n        while True:\n            sample = Point(*[torch.randint(0, map_size[i], (1,)).item() for i in range(map_size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _get_nearest_vertex(self, vertices, point: Point):\n        best_vertex = None\n        best_dist = float('inf')\n        for v in vertices:\n            dist = self._distance(v.position, point)\n            if dist < best_dist:\n                best_dist = dist\n                best_vertex = v\n        return best_vertex\n\n    def _get_near_vertices(self, vertices, point: Point, radius: float):\n        near = []\n        for v in vertices:\n            if self._distance(v.position, point) <= radius:\n                near.append(v)\n        return near\n\n    def _steer(self, from_v: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        direction = to_point.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            return Vertex(to_point, store_connectivity=True)\n        direction_normalized = direction / dist\n        new_pos_tensor = from_v.position.to_tensor() + max_dist * direction_normalized\n        # create new_point with integer coordinates to avoid floating positions\n        new_pos_ints = tuple(int(round(x.item())) for x in new_pos_tensor)\n        new_point = Point(*new_pos_ints)\n        return Vertex(new_point, store_connectivity=True)\n\n    def _reconstruct_path(self, goal_vertex: Vertex) -> list:\n        path = []\n        current = goal_vertex\n        # Follow parents with minimal cost path backward to root start vertex\n        while True:\n            path.append(current)\n            if not current.parents or any(p.cost == 0 for p in current.parents):\n                break\n            # proceed to parent with lowest cost\n            min_parent = min(current.parents, key=lambda p: p.cost if p.cost is not None else float('inf'))\n            current = min_parent\n        path.reverse()\n        return path\n\n    def _line_collision_free(self, start: Point, end: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(start, end)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _path_smoothing(self, path: list) -> list:\n        \"\"\"Attempt to smooth path by shortcutting between vertices skipping intermediates.\"\"\"\n        if len(path) <= 2:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_collision_free(path[i].position, path[j].position):\n                    smoothed.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # no shortcut found, just add next vertex\n                smoothed.append(path[i + 1])\n                i += 1\n        return smoothed\n\n    # Overridden implementation #\n    def _find_path_internal(self) -> None:\n        import time\n        import numpy as np\n\n        start_time = time.time()\n        start_v = self._graph.root_vertex_start\n        goal_v = self._graph.root_vertex_goal\n\n        # Add start & goal to root_vertices if missing\n        if start_v not in self._graph.root_vertices:\n            self._graph.root_vertices.insert(0, start_v)\n        if goal_v not in self._graph.root_vertices:\n            self._graph.root_vertices.append(goal_v)\n\n        all_vertices = self._graph.root_vertices + self._graph.root_vertices[2:]  # start, goal + V\n\n        max_iter = 12000\n        radius_factor = 50.0  # controls rewiring radius scaling\n        dimension = self._get_grid().size.n_dim\n\n        for iter_idx in range(max_iter):\n\n            # Timeout fail check (60 seconds)\n            if time.time() - start_time > 60.0:\n                # Treat as fail: no path found in time\n                return\n\n            # Sample a point biased towards goal region\n            q_rand = self._sample_informed(goal_v.position)\n            # Find nearest vertex in graph\n            q_near = self._get_nearest_vertex(all_vertices, q_rand)\n            if q_near is None:\n                continue\n\n            # Steer toward sample with max step size\n            q_new = self._steer(q_near, q_rand, self._max_step)\n\n            # Check validity of path q_near to q_new\n            if not self._line_collision_free(q_near.position, q_new.position):\n                continue\n\n            # Calculate tentative cost to reach q_new through q_near\n            cost_to_q_new = (q_near.cost if q_near.cost is not None else float('inf')) + \\\n                            self._distance(q_near.position, q_new.position)\n            # If q_new already exists in graph (approximate), skip to avoid duplicates\n            overlap_vertices = [v for v in all_vertices if v.position == q_new.position]\n            if overlap_vertices:\n                # May try to rewire the vertex if this path better\n                existing_v = overlap_vertices[0]\n                if cost_to_q_new < (existing_v.cost if existing_v.cost is not None else float('inf')):\n                    existing_v.cost = cost_to_q_new\n                    # Change parents to q_near\n                    for p in list(existing_v.parents):\n                        existing_v.parents.remove(p)\n                        p.children.remove(existing_v)\n                    existing_v.add_parent(q_near)\n                    q_near.add_child(existing_v)\n                continue\n\n            # Assign cost & add q_new to graph connected from q_near\n            q_new.cost = cost_to_q_new\n            self._graph.root_vertices.append(q_new)\n            all_vertices.append(q_new)\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire neighbors within radius around q_new to possibly improve cost\n            radius = radius_factor * ( (np.log(len(all_vertices)) / len(all_vertices)) ** (1 / dimension) )\n            radius = max(radius, self._max_step)  # radius never below step size\n            near_vertices = self._get_near_vertices(all_vertices, q_new.position, radius)\n\n            for q_nearby in near_vertices:\n                if q_nearby is q_new or q_nearby is q_near:\n                    continue\n                # Check if edge q_new->q_nearby would improve cost and is feasible\n                if not self._line_collision_free(q_new.position, q_nearby.position):\n                    continue\n                cost_thru_q_new = q_new.cost + self._distance(q_new.position, q_nearby.position)\n                if cost_thru_q_new < (q_nearby.cost if q_nearby.cost is not None else float('inf')):\n                    # Rewire q_nearby parent from old parent to q_new\n                    # Remove old parent edges\n                    for p in list(q_nearby.parents):\n                        p.children.discard(q_nearby)\n                    q_nearby.parents.clear()\n                    q_nearby.cost = cost_thru_q_new\n                    q_nearby.add_parent(q_new)\n                    q_new.add_child(q_nearby)\n                    # If graph supports edges removal, remove old edges and add new edges\n                    try:\n                        self._graph.add_edge(q_new, q_nearby)\n                    except Exception:\n                        pass\n\n            # Try connecting q_new directly to goal if possible and update cost if better\n            if self._distance(q_new.position, goal_v.position) <= self._max_step:\n                if self._line_collision_free(q_new.position, goal_v.position):\n                    cost_to_goal_through_q_new = q_new.cost + self._distance(q_new.position, goal_v.position)\n                    if cost_to_goal_through_q_new < (goal_v.cost if goal_v.cost is not None else float('inf')):\n                        for p in list(goal_v.parents):\n                            p.children.discard(goal_v)\n                        goal_v.parents.clear()\n                        goal_v.cost = cost_to_goal_through_q_new\n                        goal_v.add_parent(q_new)\n                        q_new.add_child(goal_v)\n\n            # If goal reached and has a valid cost, extract and smooth path\n            if goal_v.cost is not None and goal_v.cost < float('inf') and len(goal_v.parents) > 0:\n                path = self._reconstruct_path(goal_v)\n                path = self._path_smoothing(path)\n\n                # Animate moving the agent along path\n                for v in path:\n                    self.move_agent(v.position)\n                    self.key_frame(ignore_key_frame_skip=True)\n                return\n\n            # key frame for display update per iteration\n            if iter_idx % 10 == 0:\n                self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 215, in __run_simulation\n    sim: Simulator = Simulator(Services(config))\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 40, in __init__\n    self.__setup(config)\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 68, in __setup\n    self.__algorithm_runner.reset_algorithm()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\algorithm_runner.py\", line 59, in reset_algorithm\n    self.__algorithm = self.__algorithm_type(self._services, testing, *self.__algorithm_parameters[0],\n  File \"<string>\", line 60, in __init__\n  File \"<string>\", line 88, in _sample_informed\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is inspired by the advantages of RRT* and PRM but introduces a hybrid approach called\n    Adaptive Batch Informed RRT* with Smoothing (ABIRRT*-S).\n\n    Key improvements:\n    - Adaptive sampling: samples are biased progressively towards the heuristic ellipsoidal informed region to speed up convergence.\n    - Batch processing: samples are inserted and rewired in batches, improving path quality and reducing per-iteration overhead.\n    - Cyclic graph usage: allows multiple paths and rewiring to enhance robustness and path shortening.\n    - Early stopping by path quality improvements and time limit (60 seconds).\n    - Post-processing smoothing of the resulting path to reduce sharp turns.\n    - Dynamic radius update based on vertex count and dimension for efficient neighbor querying.\n    - Uses torch tensors for efficient distance calculations.\n    - Planning stops when a path is found and converges to a near-optimal solution or timeout is reached.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    def _get_random_sample(self, informed_center: Optional[Point] = None, informed_radii: Optional[List[float]] = None) -> Point:\n        grid_size = self._get_grid().size\n        dim = grid_size.n_dim\n\n        if informed_center is None or informed_radii is None:\n            # Uniform sample within map\n            while True:\n                rand_pos = np.random.randint(0, grid_size.values, dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling within an n-dimensional ellipsoid around current best path\n        for _ in range(100):  # limit tries to find a valid point in ellipsoid\n            # Sample uniform point in unit n-ball using normal distribution method\n            x = np.random.normal(size=dim)\n            norm = np.linalg.norm(x)\n            x_unit = x / norm if norm > 0 else x\n            r = np.random.random() ** (1.0 / dim)  # radius proportional sampling\n            sample_scaled = x_unit * r\n\n            # Scale by ellipsoid radii and translate by center\n            sample_coords = informed_center.values + np.multiply(sample_scaled, informed_radii)\n            sample_point = Point(*np.round(sample_coords).astype(int))\n\n            # Clamp sample to map boundaries\n            clamped = []\n            for i, val in enumerate(sample_point.values):\n                low = 0\n                high = grid_size[i] - 1\n                clamped.append(min(max(val, low), high))\n            sample_point = Point(*clamped)\n\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # Fallback uniform sampling\n        return self._get_random_sample()\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        direction = to_point.to_tensor() - from_vertex.position.to_tensor()\n        dist = torch.norm(direction).item()\n        if dist <= max_dist:\n            return Vertex(to_point)\n        direction_normalized = direction / dist\n        new_pos_tensor = from_vertex.position.to_tensor() + max_dist * direction_normalized\n        new_pos = Point(*torch.round(new_pos_tensor).int().tolist())\n        return Vertex(new_pos)\n\n    def _get_nearest_vertex(self, point: Point) -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, point)\n\n    def _get_near_vertices(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _collision_free(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Point]:\n        path = []\n        v = goal_vertex\n        while True:\n            path.append(v.position)\n            if len(v.parents) == 0:\n                break\n            # Pick min cost parent (support multiple parents)\n            min_parent = None\n            min_cost = float('inf')\n            for p in v.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_parent = p\n            v = min_parent\n        return path[::-1]\n\n    def _smooth_path(self, path: List[Point]) -> List[Point]:\n        # Simple path smoothing by shortcutting collidable-free segments\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._collision_free(path[i], path[j]):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _compute_informed_ellipse(self, start: Point, goal: Point, c_best: float) -> (Point, List[float]):\n        # Compute ellipsoid center & axes lengths for informed sampling\n        c_min = self._distance(start, goal)\n        if c_best < float('inf'):\n            center_t = (start.to_tensor() + goal.to_tensor()) / 2.0\n            center = Point(*center_t.tolist())\n            dim = start.n_dim\n            a1 = (goal.to_tensor() - start.to_tensor()) / self._distance(start, goal)\n            # Construct orthonormal basis via SVD or Gram-Schmidt (simplified here)\n            # Ellipsoid radii: [c_best/2, sqrt(c_best^2 - c_min^2)/2, ..., sqrt(c_best^2 - c_min^2)/2]\n            r1 = c_best / 2.0\n            rothers = np.sqrt(max(c_best ** 2 - c_min ** 2, 0)) / 2.0\n            radii = [r1] + [rothers] * (dim - 1)\n            return center, radii\n        else:\n            # No path found yet => sample entire space\n            return None, None\n\n    def _batch_rewire(self, new_vertex: Vertex, near_vertices: List[Vertex], max_dist: float) -> None:\n        # Find best parent from neighbors and rewire other neighbors if improves cost\n        best_parent = None\n        best_cost = float('inf')\n        for near in near_vertices:\n            if near.cost is None:\n                continue\n            dist_to_new = self._distance(near.position, new_vertex.position)\n            if dist_to_new > max_dist:\n                continue\n            if not self._collision_free(near.position, new_vertex.position):\n                continue\n            cost = near.cost + dist_to_new\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = near\n\n        if best_parent is None:\n            return\n\n        new_vertex.cost = best_cost\n        self._graph.add_edge(best_parent, new_vertex)\n\n        # Rewire neighbors\n        for near in near_vertices:\n            if near == best_parent or near.cost is None:\n                continue\n            dist_new_to_near = self._distance(new_vertex.position, near.position)\n            if dist_new_to_near > max_dist:\n                continue\n            if not self._collision_free(new_vertex.position, near.position):\n                continue\n\n            cost_through_new = new_vertex.cost + dist_new_to_near\n            if cost_through_new < near.cost:\n                # Remove old parent edge\n                old_parents = list(near.parents)\n                for old_p in old_parents:\n                    self._graph.remove_edge(old_p, near)\n                near.cost = cost_through_new\n                # Add new edge\n                self._graph.add_edge(new_vertex, near)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        max_iterations = 10000\n        max_dist = 15.0\n        dimension = self._get_grid().size.n_dim\n        max_radius = 50.0\n        lambda_rrt_star = 30.0\n\n        best_goal_cost = float('inf')\n        best_goal_vertex = None\n\n        batch_size = 15\n        samples: List[Point] = []\n\n        # Insert initial vertices\n        self.key_frame()\n\n        for iteration in range(max_iterations):\n\n            elapsed = time.time() - start_time\n            if elapsed > 60.0:  # timeout hard stop\n                break\n\n            # Compute informed sampling ellipsoid center and radii if path found\n            informed_center, informed_radii = self._compute_informed_ellipse(\n                self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position, best_goal_cost\n            )\n\n            # Sample multiple points (batch) using adaptive informed sampling\n            samples.clear()\n            for _ in range(batch_size):\n                sample = self._get_random_sample(informed_center, informed_radii)\n                samples.append(sample)\n\n            for sample in samples:\n                nearest = self._get_nearest_vertex(sample)\n                if nearest.position == sample:\n                    continue\n                new_vertex = self._steer(nearest, sample, max_dist)\n                if not self._collision_free(nearest.position, new_vertex.position):\n                    continue\n\n                # Compute radius for near vertices (adaptive)\n                card_v = float(self._graph.size) + 1e-6\n                radius = min(lambda_rrt_star * ((torch.log(torch.tensor(card_v)) / card_v) ** (1.0 / dimension)), max_radius)\n\n                near_vertices = self._get_near_vertices(new_vertex, radius)\n                self._batch_rewire(new_vertex, near_vertices, max_dist)\n\n                # Check goal reaching\n                if self._get_grid().is_agent_in_goal_radius(new_vertex.position):\n                    dist_to_goal = self._distance(new_vertex.position, self._graph.root_vertex_goal.position)\n                    path_cost = (new_vertex.cost if new_vertex.cost is not None else float('inf')) + dist_to_goal\n\n                    if path_cost < best_goal_cost:\n                        best_goal_cost = path_cost\n                        # Connect new_vertex to goal vertex for final path extraction\n                        goal_vertex = Vertex(self._graph.root_vertex_goal.position)\n                        goal_vertex.cost = path_cost\n                        self._graph.add_edge(new_vertex, goal_vertex)\n                        best_goal_vertex = goal_vertex\n\n            self.key_frame()\n\n            # Stop early if path cost converges sufficiently (small improvement threshold)\n            if best_goal_vertex is not None and iteration % 50 == 0:\n                # Extract, smooth, and re-set path for visualization\n                raw_path = self._extract_path(best_goal_vertex)\n                smooth_path = self._smooth_path(raw_path)\n                for p in smooth_path:\n                    self.move_agent(p)\n                    self.key_frame(ignore_key_frame_skip=True)\n                # Update best cost more conservatively\n                if best_goal_cost < float('inf'):\n                    break\n\n        # Final fallback: if path found, display smoothed path\n        if best_goal_vertex is not None:\n            final_raw_path = self._extract_path(best_goal_vertex)\n            final_path = self._smooth_path(final_raw_path)\n            for p in final_path:\n                self.move_agent(p)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 240, in _find_path_internal\n  File \"<string>\", line 61, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
{
     "operator": "m3",
     "algorithm": "Improved sample-based path planning algorithm combining benefits of RRT* and SPRM features:\n    - Uses an adaptive radius for neighborhood search based on vertex count and map size to enhance rewiring and path smoothness.\n    - Incorporates cost optimization while rewiring to ensure better path quality.\n    - Uses informed sampling centered around the current best path to improve planning efficiency.\n    - Limits search time to 60 seconds to ensure robustness by failing gracefully if no solution is found.\n    - Utilizes cyclic graph to avoid tree structure limitations and enable richer connectivity.\n    - Implements path smoothing by shortcutting edges when possible, improving path length and smoothness.\n    - Produces more optimal and robust paths with balanced exploration and exploitation.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n    _max_edge_len: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        self._V_size = 250\n        # Maximum edge length per extension step, scaled to map size\n        grid_size_sum = sum(self._get_grid().size.values)\n        self._max_edge_len = max(5, grid_size_sum / 20)\n        self._max_radius = max(10, grid_size_sum / 10)\n\n        V = []\n        for _ in range(self._V_size):\n            sample = self._get_random_sample_init()\n            V.append(Vertex(sample, store_connectivity=True))\n\n        self._graph = gen_cyclic_graph(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            V,\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample_init(self) -> Point:\n        \"\"\"Random sample during initialization without relying on _graph attribute.\"\"\"\n        return Point(\n            *[\n                self._services.rng.uniform(0, self._get_grid().size[i])\n                for i in range(self._get_grid().size.n_dim)\n            ]\n        )\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Informed sampling within a heuristic ellipsoidal region to focus search near best path.\"\"\"\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n\n        c_best = float(\"inf\")\n        path_vertices = self._get_current_best_path_vertices()\n        if path_vertices:\n            c_best = sum(\n                self._get_grid().get_distance(path_vertices[i].position, path_vertices[i + 1].position)\n                for i in range(len(path_vertices) - 1)\n            )\n        else:\n            # If no path known, set to grid diagonal length * 2 to search broadly\n            c_best = (self._get_grid().size.to_tensor().float().norm()) * 2\n\n        while True:\n            # Uniform random sample in configuration space\n            random_sample = Point(\n                *[\n                    self._services.rng.uniform(0, self._get_grid().size[i])\n                    for i in range(self._get_grid().size.n_dim)\n                ]\n            )\n\n            # Reject samples outside informed ellipsoid (if path known) to focus search:\n            # Ellipsoid defined by foci start and goal and path cost c_best\n            dist_start_sample = (random_sample.to_tensor() - start).norm()\n            dist_sample_goal = (random_sample.to_tensor() - goal).norm()\n            if dist_start_sample + dist_sample_goal <= c_best + self._max_edge_len:\n                if self._get_grid().is_agent_valid_pos(random_sample):\n                    return random_sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = direction.norm()\n        if norm_dir <= max_dist:\n            q_new = q_sample\n        else:\n            q_new_tensor = q_near.position.to_tensor() + (direction / norm_dir) * max_dist\n            q_new = Point(*tuple(q_new_tensor.tolist()))\n        return Vertex(q_new, store_connectivity=True)\n\n    def _near(self, vertex: Vertex, radius: float = None) -> list:\n        # Use adaptive radius if none specified\n        if radius is None:\n            n = max(1, len(self._graph.root_vertices))\n            # RRT* radius formula scaled to environment - robust and efficient\n            unit_ball_volume = 3.14  # Approximation for 2D; in higher dims could tune\n            gamma_rrt_star = 2 * (1 + 1 / self._get_grid().size.n_dim) ** (1 / self._get_grid().size.n_dim) * (\n                self._get_grid().size.width * self._get_grid().size.height\n            ) ** (1 / self._get_grid().size.n_dim)\n            radius = min(self._max_radius, gamma_rrt_star * (math.log(n) / n) ** (1 / self._get_grid().size.n_dim))\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _choose_parent_and_rewire(self, q_new: Vertex, q_near_list: list) -> None:\n        # Choose best parent based on total cost to q_new through neighbor and rewire neighbors if better path found\n        best_parent = None\n        best_cost = float(\"inf\")\n        for q_near in q_near_list:\n            if q_near.position == q_new.position:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            tentative_cost = (\n                getattr(q_near, \"cost\", 0) + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            )\n            if tentative_cost < best_cost:\n                best_parent = q_near\n                best_cost = tentative_cost\n        if best_parent:\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n            # Rewire neighbors if going through q_new offers a better cost\n            for q_near in q_near_list:\n                if q_near == best_parent or q_near == q_new:\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    continue\n                cost_through_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n                current_cost = getattr(q_near, \"cost\", float(\"inf\"))\n                if cost_through_new < current_cost:\n                    # Remove old edge(s) from parents\n                    for parent in list(q_near.parents):\n                        self._graph.remove_edge(parent, q_near)\n                    self._graph.add_edge(q_new, q_near)\n                    q_near.cost = cost_through_new\n\n    def _get_current_best_path_vertices(self) -> list:\n        # Try to recover current best path from start to goal if connected\n        start = self._graph.root_vertex_start\n        goal = self._graph.root_vertex_goal\n        if goal not in start.connectivity:\n            return []\n\n        path = []\n        current = start\n        while current != goal:\n            children = list(current.connectivity)\n            if not children:\n                break\n            # Choose child with lowest cost if available (heuristic)\n            if hasattr(current, \"cost\"):\n                children = sorted(children, key=lambda c: getattr(c, \"cost\", float(\"inf\")))\n            current = children[0]\n            path.append(current)\n            if current == goal:\n                break\n        return path\n\n    def _shortcut_path(self, path: list) -> list:\n        # Path shortcutting to improve smoothness: tries to connect non-adjacent points directly if possible\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[next_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                next_idx -= 1\n            shortcut_path.append(path[next_idx])\n            idx = next_idx\n        return shortcut_path\n\n    def _extract_path_and_animate(self, q_goal: Vertex) -> None:\n        # Extracts path from the goal vertex back to start and animates movement\n        path = [q_goal]\n        while path[-1].parents:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        path.reverse()\n\n        # Path shortcutting\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        from time import time\n\n        start_time = time()\n        max_duration = 60  # seconds\n        max_iterations = 20000\n\n        # Initialize cost for root start and goal vertices\n        self._graph.root_vertex_start.cost = 0\n        self._graph.root_vertex_goal.cost = float(\"inf\")\n\n        for iteration in range(max_iterations):\n            if time() - start_time > max_duration:\n                # Fail gracefully if timeout reached\n                return\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_edge_len)\n\n            # Check feasibility of new edge\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Add the new vertex and find neighbors for rewiring\n            self._graph.root_vertices.append(q_new)\n            q_near_list = self._near(q_new, radius=self._max_radius)\n\n            # Choose parent and rewire neighbors to minimize cost\n            self._choose_parent_and_rewire(q_new, q_near_list)\n\n            # Check if new vertex reaches goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect goal vertex, update cost, extract path and exit\n                self._graph.add_edge(q_new, self._graph.root_vertex_goal)\n                self._graph.root_vertex_goal.cost = getattr(q_new, \"cost\", float(\"inf\")) + self._get_grid().get_movement_cost(q_new.position, self._graph.root_vertex_goal.position)\n                self._extract_path_and_animate(self._graph.root_vertex_goal)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 215, in __run_simulation\n    sim: Simulator = Simulator(Services(config))\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 40, in __init__\n    self.__setup(config)\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 68, in __setup\n    self.__algorithm_runner.reset_algorithm()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\algorithm_runner.py\", line 59, in reset_algorithm\n    self.__algorithm = self.__algorithm_type(self._services, testing, *self.__algorithm_parameters[0],\n  File \"<string>\", line 57, in __init__\n  File \"<string>\", line 72, in _get_random_sample_init\n  File \"<string>\", line 73, in <listcomp>\nAttributeError: 'Services' object has no attribute 'rng'\n"
     }
}
{
     "operator": "m2",
     "algorithm": "This algorithm is an enhanced sample-based path planner inspired by SPRM and RRT techniques.\n    It uses adaptive sampling density based on distance to goal, dynamically adjusts the connection radius,\n    and employs pruning to reduce graph complexity. The planner uses a cyclic graph structure with\n    improved rewiring to enhance path quality and robustness, while performing early goal checking.\n    A timeout mechanism is implemented to terminate the search after 60 seconds to ensure timely failure.\n    This design balances planning efficiency, path smoothness and success rate across varying map sizes.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n    _max_dist_edge: float\n    _timeout_sec: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        grid = self._get_grid()\n        # Sample size scales with map area to better manage large maps\n        area = grid.size.width * grid.size.height\n        self._V_size = min(max(int(area * 0.5), 150), 600)\n        # max radius adaptive to map size (20% of max dimension, clipped)\n        max_dim = max(grid.size.width, grid.size.height)\n        self._max_radius = min(max_dim * 0.25, 25)\n        self._max_dist_edge = min(max_dim * 0.15, 15)\n        self._timeout_sec = 60.0\n\n        V: List[Vertex] = []\n        for _ in range(self._V_size):\n            q_rand = self._get_informed_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n\n        start_vertex = Vertex(grid.agent.position, store_connectivity=True)\n        goal_vertex = Vertex(grid.goal.position, store_connectivity=True)\n        self._graph = gen_cyclic_graph(self._services, start_vertex, goal_vertex, V)\n        self._graph.edges_removable = True  # allow pruning\n\n        self._init_displays()\n\n    def _get_informed_sample(self) -> Point:\n        \"\"\"\n        Informed sample biased towards goal region:\n        Sampling biased more closely near the line start-->goal to speed convergence.\n        \"\"\"\n        grid = self._get_grid()\n        start = grid.agent.position.to_tensor()\n        goal = grid.goal.position.to_tensor()\n        max_dim = max(grid.size.width, grid.size.height)\n        while True:\n            # Uniform random sample \n            sample_coords = torch.randint(0, grid.size.width, (grid.size.n_dim,), dtype=torch.float)\n            # Create a biased sample towards goal by linear interpolation with some noise\n            alpha = torch.rand(1).item()\n            informed = start + alpha * (goal - start)\n            noise = (torch.randn(grid.size.n_dim) * max_dim * 0.1).clamp(-max_dim * 0.15, max_dim * 0.15)\n            sample_pos = informed + noise\n            sample_pos = torch.clamp(sample_pos, min=0, max=torch.tensor(grid.size.values) - 1)\n            sample = Point.from_tensor(sample_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        delta = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(delta)\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        dir_normalized = delta / dist\n        new_pos = q_near.position.to_tensor() + dir_normalized * max_dist\n        q_new = Point.from_tensor(new_pos)\n        return Vertex(q_new, store_connectivity=True)\n\n    def _near(self, vertex: Vertex) -> List[Vertex]:\n        # Dynamically adjust radius based on graph size (smaller radius if graph bigger)\n        radius = self._max_radius * min(1.0, 300 / max(1, self._graph.size))\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # Try to improve graph paths by rewiring vertices to q_new if cost is lower and path is valid\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor is q_new:\n                continue\n            current_cost = neighbor.cost if neighbor.cost is not None else float('inf')\n            tentative_cost = (q_new.cost if q_new.cost is not None else 0) + grid.get_movement_cost(q_new.position, neighbor.position)\n            if tentative_cost < current_cost:\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, neighbor.position)):\n                    # Remove old parent's edge (choose one arbitrary parent)\n                    if neighbor.parents:\n                        for p in neighbor.parents:\n                            self._graph.remove_edge(p, neighbor)\n                    # Add new edge from q_new to neighbor\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = tentative_cost\n\n    def _extract_path(self, q_goal_conn: Vertex) -> None:\n        # Backtrack path from goal conn vertex to start using parents\n        path: List[Vertex] = []\n        current = q_goal_conn\n        while current.parents:\n            path.append(current)\n            parent = next(iter(current.parents))\n            current = parent\n        path.append(current)  # add root start\n        path.reverse()\n\n        # Smooth path by shortcutting\n        smooth_path = self._shortcut_path(path)\n\n        for vertex in smooth_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Simple shortcutting to reduce unnecessary waypoints in path by checking if \n        direct connections between non-adjacent vertices are valid.\n        \"\"\"\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path\n\n        shortened = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                # Check if direct connection valid: idx -> next_idx\n                line_seq = grid.get_line_sequence(path[idx].position, path[next_idx].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                next_idx -= 1\n            shortened.append(path[next_idx])\n            idx = next_idx\n        return shortened\n\n    # Overridden method #\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start_time = time.time()\n\n        # Initialize costs for root vertices\n        root_start, root_goal = self._graph.root_vertices\n        root_start.cost = 0.0\n        root_goal.cost = float('inf')\n\n        max_dist = self._max_dist_edge\n        iteration_limit = 15000\n\n        for iteration in range(iteration_limit):\n            if time.time() - start_time > self._timeout_sec:\n                # Planning failed due to timeout\n                return\n\n            q_sample = self._get_informed_sample()\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Assign cost to q_new if q_near has cost else default to inf\n            cost_to_q_new = (q_near.cost if q_near.cost is not None else 0) + grid.get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = cost_to_q_new\n\n            self._graph.add_edge(q_near, q_new)\n\n            neighbors = self._near(q_new)\n            self._rewire(q_new, neighbors)\n\n            # Early detection if q_new near goal and connects with valid edge for path extraction\n            dist_to_goal = torch.dist(torch.tensor(q_new.position.values), torch.tensor(root_goal.position.values))\n            if dist_to_goal <= self._max_dist_edge:\n                line_seq_to_goal = grid.get_line_sequence(q_new.position, root_goal.position)\n                if grid.is_valid_line_sequence(line_seq_to_goal):\n                    self._graph.add_edge(q_new, root_goal)\n                    root_goal.cost = q_new.cost + grid.get_movement_cost(q_new.position, root_goal.position)\n                    self._extract_path(q_new)\n                    return\n\n            # Periodically prune graph by removing vertices with no children (dead ends) and large cost\n            if iteration % 500 == 0 and self._graph.size > 200:\n                self._prune_graph()\n\n            self.key_frame()\n\n    def _prune_graph(self) -> None:\n        # Remove dead-end vertices with no children and high cost to reduce search complexity\n        to_remove = []\n        for v in self._graph.root_vertices:\n            if v is self._graph.root_vertex_start or v is self._graph.root_vertex_goal:\n                continue\n            if not v.children and (v.cost is None or v.cost > 1e5):\n                to_remove.append(v)\n        for v in to_remove:\n            for p in v.parents:\n                self._graph.remove_edge(p, v)\n            # Also remove from root vertices list if exists\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 215, in __run_simulation\n    sim: Simulator = Simulator(Services(config))\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 40, in __init__\n    self.__setup(config)\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 68, in __setup\n    self.__algorithm_runner.reset_algorithm()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\algorithm_runner.py\", line 59, in reset_algorithm\n    self.__algorithm = self.__algorithm_type(self._services, testing, *self.__algorithm_parameters[0],\n  File \"<string>\", line 62, in __init__\n  File \"<string>\", line 89, in _get_informed_sample\nTypeError: clamp() received an invalid combination of arguments - got (Tensor, min=int, max=Tensor), but expected one of:\n * (Tensor input, Tensor min = None, Tensor max = None, *, Tensor out = None)\n * (Tensor input, Number min = None, Number max = None, *, Tensor out = None)\n\n"
     }
}
{
     "operator": "m3",
     "algorithm": "This algorithm implements an improved variant of the RRT* approach with bi-directional tree \n    growth and rewiring to optimize path quality and convergence speed. It samples points \n    intelligently within the map's valid regions, incrementally builds two trees rooted at \n    start and goal, attempts to connect them, and rewires nearby vertices to reduce overall \n    cost. The algorithm enforces collision-free checks along edges and stops if a path \n    connecting start and goal is found or if the 60-second time limit is exceeded. \n    It balances exploration and exploitation for improved efficiency, robustness, \n    better path quality, and smoother, shorter paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _rewire_radius: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        # Initialize Forest with start and goal vertices\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True  # allow rewiring edges\n        self._max_dist = 15.0                  # max extension distance (tuneable)\n        self._rewire_radius = 20.0             # radius for rewiring neighbors (tuneable)\n        self._iterations = 10000               # max number of iterations\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Sample random valid point inside map bounds and valid for agent position.\n        \"\"\"\n        grid = self._get_grid()\n        size = grid.size\n        while True:\n            rand_coords = []\n            for d in range(size.n_dim):\n                rand_coords.append(np.random.uniform(0, size[d]))\n            sample = Point(*rand_coords)\n            # Round coordinates to grid integers if grid is integer-based\n            # but keep float for smoothness\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _steer(self, from_v: Vertex, to_p: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        Returns a new vertex in direction from from_v to to_p\n        at distance max_dist or less if closer.\n        \"\"\"\n        direction = to_p.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            new_pos = to_p\n        else:\n            direction_normalized = direction / dist\n            new_tensor = from_v.position.to_tensor() + max_dist * direction_normalized\n            new_pos = Point.from_tensor(new_tensor)\n        return Vertex(new_pos)\n\n    def _near_vertices(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        \"\"\"\n        Returns all vertices within radius of given point.\n        \"\"\"\n        return [v for v in vertices if self._distance(v.position, point) <= radius]\n\n    def _cost(self, vertex: Vertex) -> float:\n        \"\"\"\n        Returns cost to reach vertex from root.\n        \"\"\"\n        return vertex.cost if vertex.cost is not None else float('inf')\n\n    def _line_valid(self, start: Point, end: Point) -> bool:\n        \"\"\"\n        Check if line between two points is valid (collision-free).\n        \"\"\"\n        line_points = self._get_grid().get_line_sequence(start, end)\n        return self._get_grid().is_valid_line_sequence(line_points)\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Attempt to update edges to reduce cost from new_vertex to nearby vertices.\n        \"\"\"\n        grid = self._get_grid()\n        for near_v in near_vertices:\n            if near_v == new_vertex or near_v == self._graph.root_vertex_start:\n                continue\n            cost_through_new = self._cost(new_vertex) + grid.get_movement_cost(new_vertex.position, near_v.position)\n            if cost_through_new < self._cost(near_v) and self._line_valid(new_vertex.position, near_v.position):\n                # Remove old parent edge\n                for parent in near_v.parents:\n                    self._graph.remove_edge(parent, near_v)\n                # Add edge new_vertex->near_v\n                self._graph.add_edge(new_vertex, near_v)\n                near_v.cost = cost_through_new\n\n    def _find_min_cost_parent(self, near_vertices: List[Vertex], new_vertex: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        Among near vertices, find the parent that offers minimum cost path to new_vertex.\n        \"\"\"\n        grid = self._get_grid()\n        min_cost = float('inf')\n        min_parent = None\n        for near_v in near_vertices:\n            if self._line_valid(near_v.position, new_vertex.position):\n                cost_through_near = self._cost(near_v) + grid.get_movement_cost(near_v.position, new_vertex.position)\n                if cost_through_near < min_cost:\n                    min_cost = cost_through_near\n                    min_parent = near_v\n        return min_parent\n\n    def _extract_path(self, connecting_vertex_start: Vertex, connecting_vertex_goal: Vertex) -> None:\n        \"\"\"\n        Trace back path from start to goal by joining found connecting vertices.\n        \"\"\"\n        path_from_start = [connecting_vertex_start]\n        while len(path_from_start[-1].parents) != 0:\n            for p in path_from_start[-1].parents:\n                path_from_start.append(p)\n                break\n        path_from_start.reverse()\n\n        path_from_goal = [connecting_vertex_goal]\n        while len(path_from_goal[-1].parents) != 0:\n            for p in path_from_goal[-1].parents:\n                path_from_goal.append(p)\n                break\n\n        full_path = path_from_start + path_from_goal\n\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _can_connect(self, v1: Vertex, v2: Vertex) -> bool:\n        \"\"\"\n        Check if edge between v1 and v2 is valid.\n        \"\"\"\n        return self._line_valid(v1.position, v2.position)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start_root = self._graph.root_vertex_start\n        goal_root = self._graph.root_vertex_goal\n\n        start_root.cost = 0.0\n        goal_root.cost = 0.0\n\n        start_vertices = [start_root]\n        goal_vertices = [goal_root]\n\n        all_vertices = start_vertices + goal_vertices\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        start_tree = True  # flag to switch trees for bi-directional growth\n\n        start_time = time.time()\n\n        for _ in range(self._iterations):\n\n            if time.time() - start_time > 60:\n                # Fail due to timeout\n                break\n\n            q_rand = self._get_random_sample()\n\n            active_tree = tree_start if start_tree else tree_goal\n            other_tree = tree_goal if start_tree else tree_start\n\n            # Find nearest vertex from active tree\n            q_near = min(active_tree, key=lambda v: self._distance(v.position, q_rand))\n\n            # Generate new vertex in direction of q_rand\n            q_new = self._steer(q_near, q_rand, self._max_dist)\n            if not self._line_valid(q_near.position, q_new.position):\n                # Cannot reach q_new from q_near\n                self.key_frame()\n                continue\n\n            # Identify neighbors for rewiring and parent selection\n            radius = self._rewire_radius\n            near_vertices = self._near_vertices(active_tree, q_new.position, radius)\n\n            # Choose parent with minimal cost\n            min_parent = self._find_min_cost_parent(near_vertices, q_new)\n            if min_parent is None:\n                # No valid parent found, skip\n                self.key_frame()\n                continue\n\n            # Set cost and add edge from best parent to new vertex\n            q_new.cost = self._cost(min_parent) + grid.get_movement_cost(min_parent.position, q_new.position)\n            self._graph.add_edge(min_parent, q_new)\n\n            # Add new vertex to active tree and all vertices list\n            active_tree.append(q_new)\n            all_vertices.append(q_new)\n\n            # Rewire nearby vertices if cheaper via q_new\n            self._rewire(q_new, near_vertices)\n\n            # Try to connect the other tree to q_new\n            q_near_other = min(other_tree, key=lambda v: self._distance(v.position, q_new.position))\n            if self._distance(q_near_other.position, q_new.position) <= self._max_dist and self._can_connect(q_near_other, q_new):\n                # Connect trees: add edge\n                if start_tree:\n                    self._graph.add_edge(q_new, q_near_other)\n                else:\n                    self._graph.add_edge(q_near_other, q_new)\n\n                # Extract path using q_new and q_near_other as connecting vertices\n                self._extract_path(q_new if start_tree else q_near_other, \n                                   q_near_other if start_tree else q_new)\n                break\n\n            # Switch trees\n            start_tree = not start_tree\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 279, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 238, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 219, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 66, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 199, in _find_path_internal\n  File \"<string>\", line 72, in _get_random_sample\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 150, in is_agent_valid_pos\n    return self.at(pos) in (self.CLEAR_ID, self.AGENT_ID, self.GOAL_ID)\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\configuration\\maps\\dense_map.py\", line 91, in at\n    assert not p.is_float, f\"Can't look up a floating point Point in dense_map: {p}\"\nAttributeError: 'Point' object has no attribute 'is_float'\n"
     }
}
