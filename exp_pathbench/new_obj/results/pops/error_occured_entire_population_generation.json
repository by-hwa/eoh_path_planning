{
     "operator": "e1",
     "algorithm": "PathPlanning is an improved sample-based path planning algorithm combining informed sampling,\n    efficient rewiring like RRT*, and shortcut smoothing of the final path to improve path length,\n    smoothness, success rate, and planning speed. The planner generates random samples biased inside \n    an ellipsoidal informed region to focus search near the optimal path corridor between agent and \n    goal, reducing exploration overhead. A forest graph rooted at agent and goal is incrementally \n    extended during iterative sampling. Vertices are rewired within neighborhoods to minimize cost,\n    improving solution quality continuously. Upon finding a feasible path within a 10-second time limit,\n    the path is extracted, then post-processed with line-of-sight shortcut smoothing to enhance smoothness \n    and reduce unnecessary vertices. The algorithm balances exploration and exploitation, ensuring rapid \n    convergence to high-quality, collision-free paths even in cluttered environments with robustness against \n    failures by early timeout.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _informed_sampling_enabled: bool\n    _max_radius: float\n    _elapsed_time_limit: float\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(*args, **kwargs)\n        self._max_dist = 15.0\n        self._max_radius = 50.0\n        self._elapsed_time_limit = 10.0  # seconds\n        self._informed_sampling_enabled = True\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    def _get_distance(self, frm: Point, to: Point) -> float:\n        return self._get_grid().get_distance(frm, to)\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Perform informed sampling: samples inside an ellipsoid defined by current best solution cost,\n        between start and goal positions, if available. Otherwise uniform random sampling.\n        \"\"\"\n        grid = self._get_grid()\n        start = grid.agent.position\n        goal = grid.goal.position\n\n        if not self._informed_sampling_enabled or self._graph.root_vertex_goal.cost is None or self._graph.root_vertex_goal.cost == float('inf'):\n            # Uniform random sample in grid boundaries:\n            while True:\n                sample_coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling ellipse parameters:\n        c_best = self._graph.root_vertex_goal.cost\n        c_min = self._get_distance(start, goal)\n        if c_best is None or c_best == float('inf'):\n            c_best = float('inf')\n        if c_min == 0:\n            # Start and goal are same position (corner case)\n            return start\n\n        # Sample inside prolate hyperspheroid (in 2D ellipse) around start and goal\n        while True:\n            # Draw random sample inside unit n-ball:\n            dim = grid.size.n_dim\n            sample_in_ball = self._sample_unit_n_ball(dim)\n            # Scale according to ellipse radii:\n            r1 = c_best / 2.0\n            r2 = (c_best**2 - c_min**2)**0.5 / 2.0 if c_best > c_min else 0.0\n\n            if dim == 2:\n                L = torch.eye(2)\n                # Rotate to align with start-goal vector:\n                sg_dir = (goal.to_tensor() - start.to_tensor())\n                sg_dir = sg_dir / torch.norm(sg_dir)\n                rot = torch.tensor([[sg_dir[0], -sg_dir[1]], [sg_dir[1], sg_dir[0]]])\n                L = rot @ torch.diag(torch.tensor([r1, r2]))\n            else:\n                # For general n-dimensions, use alignment rotation with SVD:\n                # Construct rotation matrix from vector unit direction\n                sg_dir = (goal.to_tensor() - start.to_tensor())\n                sg_dir = sg_dir / torch.norm(sg_dir)\n                # Complete orthonormal basis using SVD:\n                U, _, _ = torch.svd(sg_dir.unsqueeze(1))\n                L = U @ torch.diag(torch.tensor([r1] + [r2]*(dim-1)))\n\n            transformed = L @ sample_in_ball\n            center = (start.to_tensor() + goal.to_tensor()) / 2.0\n            sample_coords = transformed + center\n            sample_point = Point.from_tensor(sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _sample_unit_n_ball(self, dim: int) -> torch.Tensor:\n        \"\"\"\n        Uniformly sample from unit n-ball in R^dim\n        \"\"\"\n        vec = torch.randn(dim)\n        vec /= torch.norm(vec)\n        r = torch.rand(1).pow(1.0 / dim)\n        return vec * r\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(direction)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / norm\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        new_point = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_point)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Reconstruct path from goal to start along parents:\n        path: List[Vertex] = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n        # Path shortcut smoothing by removing unnecessary vertices along line of sight\n        path = self._shortcut_smooth(path)\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_smooth(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Attempt to shortcut path by removing intermediate vertices where straight \n        line between two vertices is collision free.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        new_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(new_path[-1].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        iterations = 20000\n        dim = grid.size.n_dim\n        lambda_rrt_star = 50.0\n        start_time = time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        goal_vertex.cost = float('inf')\n\n        for i in range(iterations):\n            elapsed = time() - start_time\n            if elapsed > self._elapsed_time_limit:\n                # Mark failure by setting goal cost to inf and return\n                goal_vertex.cost = float('inf')\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                self.key_frame()\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            is_valid = grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest.position, q_new.position))\n            if not is_valid:\n                self.key_frame()\n                continue\n\n            card_v = float(self._graph.size)\n            log_card_v = torch.log(torch.tensor(card_v)) if card_v > 1 else torch.tensor(0.0)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dim)), self._max_radius)\n\n            near_vertices = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._get_distance(q_nearest.position, q_new.position)\n\n            # Choose best parent with minimum cost and collision-free edge\n            for q_near in near_vertices:\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position))\n                cost = q_near.cost + self._get_distance(q_near.position, q_new.position)\n                if line_free and cost < c_min:\n                    q_min = q_near\n                    c_min = cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if cost improves their cost\n            for q_near in near_vertices:\n                if q_near == q_min:\n                    continue\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position))\n                cost_through_qnew = q_new.cost + self._get_distance(q_new.position, q_near.position)\n                if line_free and cost_through_qnew < q_near.cost:\n                    # Remove old edge, add new edge, update cost\n                    old_parents = list(q_near.parents)\n                    for old_parent in old_parents:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = cost_through_qnew\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if can connect to goal and update best cost if improved\n            dist_to_goal = self._get_distance(q_new.position, goal_vertex.position)\n            if dist_to_goal <= self._max_dist:\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position))\n                if line_free:\n                    goal_cost_candidate = q_new.cost + dist_to_goal\n                    if goal_cost_candidate < goal_vertex.cost:\n                        # Connect q_new to goal and update goal cost\n                        goal_vertex.cost = goal_cost_candidate\n                        self._graph.add_edge(q_new, goal_vertex)\n                        # Extract and smooth path\n                        self._extract_path(goal_vertex)\n                        return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 266, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 225, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 206, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 190, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "e1",
     "algorithm": "PathPlanning is an improved sample-based path planning algorithm combining informed sampling,\n    efficient rewiring like RRT*, and shortcut smoothing of the final path to improve path length,\n    smoothness, success rate, and planning speed. The planner generates random samples biased inside \n    an ellipsoidal informed region to focus search near the optimal path corridor between agent and \n    goal, reducing exploration overhead. A forest graph rooted at agent and goal is incrementally \n    extended during iterative sampling. Vertices are rewired within neighborhoods to minimize cost,\n    improving solution quality continuously. Upon finding a feasible path within a 10-second time limit,\n    the path is extracted, then post-processed with line-of-sight shortcut smoothing to enhance smoothness \n    and reduce unnecessary vertices. The algorithm balances exploration and exploitation, ensuring rapid \n    convergence to high-quality, collision-free paths even in cluttered environments with robustness against \n    failures by early timeout.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _informed_sampling_enabled: bool\n    _max_radius: float\n    _elapsed_time_limit: float\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(*args, **kwargs)\n        self._max_dist = 15.0\n        self._max_radius = 50.0\n        self._elapsed_time_limit = 10.0  # seconds\n        self._informed_sampling_enabled = True\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    def _get_distance(self, frm: 'Point', to: 'Point') -> float:\n        return self._get_grid().get_distance(frm, to)\n\n    def _get_random_sample(self) -> 'Point':\n        \"\"\"\n        Perform informed sampling: samples inside an ellipsoid defined by current best solution cost,\n        between start and goal positions, if available. Otherwise uniform random sampling.\n        \"\"\"\n        grid = self._get_grid()\n        start = grid.agent.position\n        goal = grid.goal.position\n\n        if not self._informed_sampling_enabled or self._graph.root_vertex_goal.cost is None or self._graph.root_vertex_goal.cost == float('inf'):\n            # Uniform random sample in grid boundaries:\n            while True:\n                sample_coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling ellipse parameters:\n        c_best = self._graph.root_vertex_goal.cost\n        c_min = self._get_distance(start, goal)\n        if c_best is None or c_best == float('inf'):\n            c_best = float('inf')\n        if c_min == 0:\n            # Start and goal are same position (corner case)\n            return start\n\n        # Sample inside prolate hyperspheroid (in 2D ellipse) around start and goal\n        while True:\n            # Draw random sample inside unit n-ball:\n            dim = grid.size.n_dim\n            sample_in_ball = self._sample_unit_n_ball(dim)\n            # Scale according to ellipse radii:\n            r1 = c_best / 2.0\n            r2 = (c_best**2 - c_min**2)**0.5 / 2.0 if c_best > c_min else 0.0\n\n            if dim == 2:\n                # 2D case\n                sg_dir = (goal.to_tensor() - start.to_tensor())\n                sg_dir_norm = torch.norm(sg_dir)\n                if sg_dir_norm == 0:\n                    # Avoid division by zero\n                    return start\n                sg_dir = sg_dir / sg_dir_norm\n                rot = torch.tensor([[sg_dir[0], -sg_dir[1]], [sg_dir[1], sg_dir[0]]])\n                L = rot @ torch.diag(torch.tensor([r1, r2]))\n            else:\n                # For general n-dimensions, use alignment rotation with SVD:\n                sg_dir = (goal.to_tensor() - start.to_tensor())\n                sg_dir_norm = torch.norm(sg_dir)\n                if sg_dir_norm == 0:\n                    return start\n                sg_dir = sg_dir / sg_dir_norm\n                U, _, _ = torch.svd(sg_dir.unsqueeze(1))\n                L = U @ torch.diag(torch.tensor([r1] + [r2]*(dim-1)))\n\n            transformed = L @ sample_in_ball\n            center = (start.to_tensor() + goal.to_tensor()) / 2.0\n            sample_coords = transformed + center\n            sample_point = Point.from_tensor(sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _sample_unit_n_ball(self, dim: int) -> torch.Tensor:\n        \"\"\"\n        Uniformly sample from unit n-ball in R^dim\n        \"\"\"\n        vec = torch.randn(dim)\n        vec /= torch.norm(vec)\n        r = torch.rand(1).pow(1.0 / dim)\n        return vec * r\n\n    def _get_nearest_vertex(self, q_sample: 'Point') -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: 'Point', max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(direction)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / norm\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        new_point = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_point)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Reconstruct path from goal to start along parents:\n        path: List[Vertex] = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n        # Path shortcut smoothing by removing unnecessary vertices along line of sight\n        path = self._shortcut_smooth(path)\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_smooth(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Attempt to shortcut path by removing intermediate vertices where straight \n        line between two vertices is collision free.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        new_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(new_path[-1].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        iterations = 20000\n        dim = grid.size.n_dim\n        lambda_rrt_star = 50.0\n        start_time = time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        goal_vertex.cost = float('inf')\n\n        for i in range(iterations):\n            elapsed = time() - start_time\n            if elapsed > self._elapsed_time_limit:\n                # Mark failure by setting goal cost to inf and return\n                goal_vertex.cost = float('inf')\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                self.key_frame()\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            is_valid = grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest.position, q_new.position))\n            if not is_valid:\n                self.key_frame()\n                continue\n\n            card_v = float(self._graph.size)\n            log_card_v = torch.log(torch.tensor(card_v)) if card_v > 1 else torch.tensor(0.0)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dim)), self._max_radius)\n\n            near_vertices = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._get_distance(q_nearest.position, q_new.position)\n\n            # Choose best parent with minimum cost and collision-free edge\n            for q_near in near_vertices:\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position))\n                cost = q_near.cost + self._get_distance(q_near.position, q_new.position)\n                if line_free and cost < c_min:\n                    q_min = q_near\n                    c_min = cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if cost improves their cost\n            for q_near in near_vertices:\n                if q_near == q_min:\n                    continue\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position))\n                cost_through_qnew = q_new.cost + self._get_distance(q_new.position, q_near.position)\n                if line_free and cost_through_qnew < q_near.cost:\n                    # Remove old edge, add new edge, update cost\n                    old_parents = list(q_near.parents)\n                    for old_parent in old_parents:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = cost_through_qnew\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if can connect to goal and update best cost if improved\n            dist_to_goal = self._get_distance(q_new.position, goal_vertex.position)\n            if dist_to_goal <= self._max_dist:\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position))\n                if line_free:\n                    goal_cost_candidate = q_new.cost + dist_to_goal\n                    if goal_cost_candidate < goal_vertex.cost:\n                        # Connect q_new to goal and update goal cost\n                        goal_vertex.cost = goal_cost_candidate\n                        self._graph.add_edge(q_new, goal_vertex)\n                        # Extract and smooth path\n                        self._extract_path(goal_vertex)\n                        return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 266, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 225, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 206, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 194, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "e1",
     "algorithm": "PathPlanning is an improved sample-based path planning algorithm combining informed sampling,\n    efficient rewiring like RRT*, and shortcut smoothing of the final path to improve path length,\n    smoothness, success rate, and planning speed. The planner generates random samples biased inside \n    an ellipsoidal informed region to focus search near the optimal path corridor between agent and \n    goal, reducing exploration overhead. A forest graph rooted at agent and goal is incrementally \n    extended during iterative sampling. Vertices are rewired within neighborhoods to minimize cost,\n    improving solution quality continuously. Upon finding a feasible path within a 10-second time limit,\n    the path is extracted, then post-processed with line-of-sight shortcut smoothing to enhance smoothness \n    and reduce unnecessary vertices. The algorithm balances exploration and exploitation, ensuring rapid \n    convergence to high-quality, collision-free paths even in cluttered environments with robustness against \n    failures by early timeout.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n    _max_dist: float\n    _informed_sampling_enabled: bool\n    _max_radius: float\n    _elapsed_time_limit: float\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(*args, **kwargs)\n        self._max_dist = 15.0\n        self._max_radius = 50.0\n        self._elapsed_time_limit = 10.0  # seconds\n        self._informed_sampling_enabled = True\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    def _get_distance(self, frm: 'Point', to: 'Point') -> float:\n        return self._get_grid().get_distance(frm, to)\n\n    def _get_random_sample(self) -> 'Point':\n        \"\"\"\n        Perform informed sampling: samples inside an ellipsoid defined by current best solution cost,\n        between start and goal positions, if available. Otherwise uniform random sampling.\n        \"\"\"\n        grid = self._get_grid()\n        start = grid.agent.position\n        goal = grid.goal.position\n\n        if not self._informed_sampling_enabled or self._graph.root_vertex_goal.cost is None or self._graph.root_vertex_goal.cost == float('inf'):\n            # Uniform random sample in grid boundaries:\n            while True:\n                sample_coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling ellipse parameters:\n        c_best = self._graph.root_vertex_goal.cost\n        c_min = self._get_distance(start, goal)\n        if c_best is None or c_best == float('inf'):\n            c_best = float('inf')\n        if c_min == 0:\n            # Start and goal are same position (corner case)\n            return start\n\n        # Sample inside prolate hyperspheroid (in 2D ellipse) around start and goal\n        while True:\n            # Draw random sample inside unit n-ball:\n            dim = grid.size.n_dim\n            sample_in_ball = self._sample_unit_n_ball(dim)\n            # Scale according to ellipse radii:\n            r1 = c_best / 2.0\n            r2 = (c_best**2 - c_min**2)**0.5 / 2.0 if c_best > c_min else 0.0\n\n            if dim == 2:\n                # 2D case\n                sg_dir = (goal.to_tensor() - start.to_tensor())\n                sg_dir_norm = torch.norm(sg_dir)\n                if sg_dir_norm == 0:\n                    # Avoid division by zero\n                    return start\n                sg_dir = sg_dir / sg_dir_norm\n                rot = torch.tensor([[sg_dir[0], -sg_dir[1]], [sg_dir[1], sg_dir[0]]])\n                L = rot @ torch.diag(torch.tensor([r1, r2]))\n            else:\n                # For general n-dimensions, use alignment rotation with SVD:\n                sg_dir = (goal.to_tensor() - start.to_tensor())\n                sg_dir_norm = torch.norm(sg_dir)\n                if sg_dir_norm == 0:\n                    return start\n                sg_dir = sg_dir / sg_dir_norm\n                U, _, _ = torch.svd(sg_dir.unsqueeze(1))\n                L = U @ torch.diag(torch.tensor([r1] + [r2]*(dim-1)))\n\n            transformed = L @ sample_in_ball\n            center = (start.to_tensor() + goal.to_tensor()) / 2.0\n            sample_coords = transformed + center\n            sample_point = Point.from_tensor(sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _sample_unit_n_ball(self, dim: int) -> torch.Tensor:\n        \"\"\"\n        Uniformly sample from unit n-ball in R^dim\n        \"\"\"\n        vec = torch.randn(dim)\n        vec /= torch.norm(vec)\n        r = torch.rand(1).pow(1.0 / dim)\n        return vec * r\n\n    def _get_nearest_vertex(self, q_sample: 'Point') -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: 'Point', max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(direction)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / norm\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        new_point = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_point)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Reconstruct path from goal to start along parents:\n        path: List[Vertex] = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n        # Path shortcut smoothing by removing unnecessary vertices along line of sight\n        path = self._shortcut_smooth(path)\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_smooth(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Attempt to shortcut path by removing intermediate vertices where straight \n        line between two vertices is collision free.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        new_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(new_path[-1].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        iterations = 20000\n        dim = grid.size.n_dim\n        lambda_rrt_star = 50.0\n        start_time = time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        goal_vertex.cost = float('inf')\n\n        for i in range(iterations):\n            elapsed = time() - start_time\n            if elapsed > self._elapsed_time_limit:\n                # Mark failure by setting goal cost to inf and return\n                goal_vertex.cost = float('inf')\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                self.key_frame()\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            is_valid = grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest.position, q_new.position))\n            if not is_valid:\n                self.key_frame()\n                continue\n\n            card_v = float(self._graph.size)\n            log_card_v = torch.log(torch.tensor(card_v)) if card_v > 1 else torch.tensor(0.0)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dim)), self._max_radius)\n\n            near_vertices = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._get_distance(q_nearest.position, q_new.position)\n\n            # Choose best parent with minimum cost and collision-free edge\n            for q_near in near_vertices:\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position))\n                cost = q_near.cost + self._get_distance(q_near.position, q_new.position)\n                if line_free and cost < c_min:\n                    q_min = q_near\n                    c_min = cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if cost improves their cost\n            for q_near in near_vertices:\n                if q_near == q_min:\n                    continue\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position))\n                cost_through_qnew = q_new.cost + self._get_distance(q_new.position, q_near.position)\n                if line_free and cost_through_qnew < q_near.cost:\n                    # Remove old edge, add new edge, update cost\n                    old_parents = list(q_near.parents)\n                    for old_parent in old_parents:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = cost_through_qnew\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if can connect to goal and update best cost if improved\n            dist_to_goal = self._get_distance(q_new.position, goal_vertex.position)\n            if dist_to_goal <= self._max_dist:\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position))\n                if line_free:\n                    goal_cost_candidate = q_new.cost + dist_to_goal\n                    if goal_cost_candidate < goal_vertex.cost:\n                        # Connect q_new to goal and update goal cost\n                        goal_vertex.cost = goal_cost_candidate\n                        self._graph.add_edge(q_new, goal_vertex)\n                        # Extract and smooth path\n                        self._extract_path(goal_vertex)\n                        return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 266, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 225, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 206, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 193, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "e1",
     "algorithm": "PathPlanning is an improved sample-based path planning algorithm combining informed sampling,\n    efficient rewiring like RRT*, and shortcut smoothing of the final path to improve path length,\n    smoothness, success rate, and planning speed. The planner generates random samples biased inside \n    an ellipsoidal informed region to focus search near the optimal path corridor between agent and \n    goal, reducing exploration overhead. A forest graph rooted at agent and goal is incrementally \n    extended during iterative sampling. Vertices are rewired within neighborhoods to minimize cost,\n    improving solution quality continuously. Upon finding a feasible path within a 10-second time limit,\n    the path is extracted, then post-processed with line-of-sight shortcut smoothing to enhance smoothness \n    and reduce unnecessary vertices. The algorithm balances exploration and exploitation, ensuring rapid \n    convergence to high-quality, collision-free paths even in cluttered environments with robustness against \n    failures by early timeout.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n    _max_dist: float\n    _informed_sampling_enabled: bool\n    _max_radius: float\n    _elapsed_time_limit: float\n\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(*args, **kwargs)\n        self._max_dist = 15.0\n        self._max_radius = 50.0\n        self._elapsed_time_limit = 10.0  # seconds\n        self._informed_sampling_enabled = True\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    def _get_distance(self, frm: 'Point', to: 'Point') -> float:\n        return self._get_grid().get_distance(frm, to)\n\n    def _get_random_sample(self) -> 'Point':\n        \"\"\"\n        Perform informed sampling: samples inside an ellipsoid defined by current best solution cost,\n        between start and goal positions, if available. Otherwise uniform random sampling.\n        \"\"\"\n        grid = self._get_grid()\n        start = grid.agent.position\n        goal = grid.goal.position\n\n        if not self._informed_sampling_enabled or self._graph.root_vertex_goal.cost is None or self._graph.root_vertex_goal.cost == float('inf'):\n            # Uniform random sample in grid boundaries:\n            while True:\n                sample_coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling ellipse parameters:\n        c_best = self._graph.root_vertex_goal.cost\n        c_min = self._get_distance(start, goal)\n        if c_best is None or c_best == float('inf'):\n            c_best = float('inf')\n        if c_min == 0:\n            # Start and goal are same position (corner case)\n            return start\n\n        # Sample inside prolate hyperspheroid (in 2D ellipse) around start and goal\n        while True:\n            # Draw random sample inside unit n-ball:\n            dim = grid.size.n_dim\n            sample_in_ball = self._sample_unit_n_ball(dim)\n            # Scale according to ellipse radii:\n            r1 = c_best / 2.0\n            r2 = (c_best**2 - c_min**2)**0.5 / 2.0 if c_best > c_min else 0.0\n\n            if dim == 2:\n                # 2D case\n                sg_dir = (goal.to_tensor() - start.to_tensor())\n                sg_dir_norm = torch.norm(sg_dir)\n                if sg_dir_norm == 0:\n                    # Avoid division by zero\n                    return start\n                sg_dir = sg_dir / sg_dir_norm\n                rot = torch.tensor([[sg_dir[0], -sg_dir[1]], [sg_dir[1], sg_dir[0]]])\n                L = rot @ torch.diag(torch.tensor([r1, r2]))\n            else:\n                # For general n-dimensions, use alignment rotation with SVD:\n                sg_dir = (goal.to_tensor() - start.to_tensor())\n                sg_dir_norm = torch.norm(sg_dir)\n                if sg_dir_norm == 0:\n                    return start\n                sg_dir = sg_dir / sg_dir_norm\n                # Use torch.linalg.svd to get U, S, Vh instead of deprecated torch.svd\n                U, _, _ = torch.linalg.svd(sg_dir.unsqueeze(1))\n                L = U @ torch.diag(torch.tensor([r1] + [r2]*(dim-1)))\n\n            transformed = L @ sample_in_ball\n            center = (start.to_tensor() + goal.to_tensor()) / 2.0\n            sample_coords = transformed + center\n            sample_point = Point.from_tensor(sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _sample_unit_n_ball(self, dim: int) -> torch.Tensor:\n        \"\"\"\n        Uniformly sample from unit n-ball in R^dim\n        \"\"\"\n        vec = torch.randn(dim)\n        vec /= torch.norm(vec)\n        r = torch.rand(1).pow(1.0 / dim)\n        return vec * r\n\n    def _get_nearest_vertex(self, q_sample: 'Point') -> Vertex:\n        return self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: 'Point', max_dist: float) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(direction)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / norm\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * direction_normalized\n        new_point = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_point)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Reconstruct path from goal to start along parents:\n        path: List[Vertex] = [q_goal]\n        current = q_goal\n        while current.parents:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n        # Path shortcut smoothing by removing unnecessary vertices along line of sight\n        path = self._shortcut_smooth(path)\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_smooth(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Attempt to shortcut path by removing intermediate vertices where straight \n        line between two vertices is collision free.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        new_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(new_path[-1].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            new_path.append(path[j])\n            i = j\n        return new_path\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        iterations = 20000\n        dim = grid.size.n_dim\n        lambda_rrt_star = 50.0\n        start_time = time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        goal_vertex.cost = float('inf')\n\n        for i in range(iterations):\n            elapsed = time() - start_time\n            if elapsed > self._elapsed_time_limit:\n                # Mark failure by setting goal cost to inf and return\n                goal_vertex.cost = float('inf')\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                self.key_frame()\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n            is_valid = grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest.position, q_new.position))\n            if not is_valid:\n                self.key_frame()\n                continue\n\n            card_v = float(self._graph.size)\n            log_card_v = torch.log(torch.tensor(card_v)) if card_v > 1 else torch.tensor(0.0)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dim)), self._max_radius)\n\n            near_vertices = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._get_distance(q_nearest.position, q_new.position)\n\n            # Choose best parent with minimum cost and collision-free edge\n            for q_near in near_vertices:\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position))\n                cost = q_near.cost + self._get_distance(q_near.position, q_new.position)\n                if line_free and cost < c_min:\n                    q_min = q_near\n                    c_min = cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if cost improves their cost\n            for q_near in near_vertices:\n                if q_near == q_min:\n                    continue\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position))\n                cost_through_qnew = q_new.cost + self._get_distance(q_new.position, q_near.position)\n                if line_free and cost_through_qnew < q_near.cost:\n                    # Remove old edge, add new edge, update cost\n                    old_parents = list(q_near.parents)\n                    for old_parent in old_parents:\n                        self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = cost_through_qnew\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if can connect to goal and update best cost if improved\n            dist_to_goal = self._get_distance(q_new.position, goal_vertex.position)\n            if dist_to_goal <= self._max_dist:\n                line_free = grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position))\n                if line_free:\n                    goal_cost_candidate = q_new.cost + dist_to_goal\n                    if goal_cost_candidate < goal_vertex.cost:\n                        # Connect q_new to goal and update goal cost\n                        goal_vertex.cost = goal_cost_candidate\n                        self._graph.add_edge(q_new, goal_vertex)\n                        # Extract and smooth path\n                        self._extract_path(goal_vertex)\n                        return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 266, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 225, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 206, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 194, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This is an improved bidirectional informed RRT* inspired sample-based path planner\n      designed to enhance planning efficiency, path quality, robustness, path smoothness,\n      and success rate while reducing search time and path length.\n\n      Key features:\n      - Bidirectional trees (start and goal)\n      - Informed sampling focused around an ellipsoidal subset for path improvement\n      - Asymptotic optimality with rewiring to improve path quality dynamically\n      - Early termination when goal reachable\n      - Smoothness promotion by limiting step length and rewiring better parents\n      - Time-limited search (10 seconds max) to avoid long runtimes",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _start_time: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 12.0\n        self._iterations = 15000\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self, c_best: Optional[float], c_min: float, x_center: Point, C: List[List[float]]) -> Point:\n        \"\"\"Generate informed sample within an ellipsoid if c_best < inf, otherwise uniform random.\"\"\"\n        dim = self._get_grid().size.n_dim\n        if c_best == math.inf or c_best == 0 or c_best is None:\n            while True:\n                sample_coords = [self._services.get_random().randint(0, self._get_grid().size[i]-1) for i in range(dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling inside ellipsoid defined by c_best and transformation C\n        for _ in range(100):  # limited retries\n            # Sample unit n-ball\n            while True:\n                x_ball = [self._services.get_random().normalvariate(0, 1) for _ in range(dim)]\n                s = sum(v*v for v in x_ball)\n                if s > 0:\n                    x_ball = [v / math.sqrt(s) for v in x_ball]\n                    break\n            r = self._services.get_random().random() ** (1.0/dim)\n            x_ball = [r*v for v in x_ball]\n\n            # Scale by axis lengths\n            L = [c_best/2.0] + [math.sqrt(c_best*c_best - c_min*c_min)/2.0]*(dim-1)\n            x_scaled = [L[i] * x_ball[i] for i in range(dim)]\n\n            # Rotate and translate back to center\n            x_rotated = [sum(C[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim)]\n            sample_coords = [int(round(x_center[i] + x_rotated[i])) for i in range(dim)]\n            sample = Point(*sample_coords)\n\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n        # fallback uniform sample\n        while True:\n            sample_coords = [self._services.get_random().randint(0, self._get_grid().size[i]-1) for i in range(dim)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([root_vertex], q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        else:\n            dir_normalized = vec / dist\n            new_pos = q_near.position.to_tensor() + max_dist * dir_normalized\n            q_new = Point.from_tensor(new_pos)\n            return Vertex(q_new)\n\n    def _get_vertices_near(self, root_vertex: Vertex, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([root_vertex], q_new.position, radius)\n\n    def _rewire(self, root_vertex: Vertex, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # Try to improve cost to q_new by rewiring from neighbors\n        best_cost = q_new.cost if hasattr(q_new, 'cost') else math.inf\n        best_parent = None\n        for neighbor in neighbors:\n            if neighbor is q_new:\n                continue\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position)):\n                cost = neighbor.cost if hasattr(neighbor, 'cost') else 0.0\n                cost += self._get_grid().get_movement_cost(neighbor.position, q_new.position)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_parent = neighbor\n\n        if best_parent is not None:\n            # Reassign parent and cost\n            for p in list(q_new.parents):\n                self._graph.remove_edge(p, q_new)\n\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Try to rewire neighbors for which q_new offers better cost\n            for neighbor in neighbors:\n                if neighbor is q_new or neighbor is best_parent:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                    neighbor_cost = neighbor.cost if hasattr(neighbor, 'cost') else math.inf\n                    new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n                    if new_cost < neighbor_cost:\n                        for p in list(neighbor.parents):\n                            self._graph.remove_edge(p, neighbor)\n                        neighbor.cost = new_cost\n                        self._graph.add_edge(q_new, neighbor)\n\n    def _path_to_start(self, vertex: Vertex) -> List[Vertex]:\n        path = []\n        curr = vertex\n        while curr is not None:\n            path.append(curr)\n            if len(curr.parents) == 0:\n                break\n            # Pick the parent with minimal cost (or first if cost undefined)\n            costs_and_parents = [(p.cost if hasattr(p, 'cost') else 0, p) for p in curr.parents]\n            costs_and_parents.sort(key=lambda x: x[0])\n            curr = costs_and_parents[0][1]\n        path.reverse()\n        return path\n\n    def _extract_path(self, meet_vertex_start: Vertex, meet_vertex_goal: Vertex) -> None:\n        path_start = self._path_to_start(meet_vertex_start)\n        path_goal = self._path_to_start(meet_vertex_goal)\n        path_goal.reverse()  # from meeting vertex to goal\n        # Merge paths excluding duplicated meeting vertex\n        full_path = path_start + path_goal[1:]\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _build_rotation_matrix(self, x_center: List[float], goal_center: List[float]) -> List[List[float]]:\n        # Create orthonormal basis with first axis in direction (start->goal)\n        dim = len(x_center)\n        dir_vector = [goal_center[i] - x_center[i] for i in range(dim)]\n        dist = math.sqrt(sum(d * d for d in dir_vector))\n        if dist == 0:\n            return [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]  # Identity matrix\n\n        e1 = [d / dist for d in dir_vector]\n        U = [e1]  # Base first vector\n\n        # Use Gram-Schmidt to generate remaining orthonormal basis vectors\n        for i in range(1, dim):\n            base_vector = [0]*dim\n            base_vector[i] = 1\n            proj = sum(base_vector[j]*e1[j] for j in range(dim))\n            orthogonal_vec = [base_vector[j]-proj*e1[j] for j in range(dim)]\n            norm_orth = math.sqrt(sum(x*x for x in orthogonal_vec))\n            if norm_orth < 1e-10:\n                # fallback vector orthogonal to e1\n                orthogonal_vec = [0]*dim\n                orthogonal_vec[(i)%dim] = 1\n                norm_orth = 1\n            orthonormal_vec = [x / norm_orth for x in orthogonal_vec]\n            U.append(orthonormal_vec)\n        return [list(col) for col in zip(*U)]  # transpose for rotation matrix\n\n    # Main function to find path #\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        self._start_time = start_time\n\n        dim = self._get_grid().size.n_dim\n        start_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n\n        # Initialize costs\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = 0.0\n\n        c_min = self._get_grid().get_distance(start_pos, goal_pos)  # minimum possible distance\n        c_best = math.inf\n\n        # Ellipsoid center and rotation matrix for informed sampling\n        x_center = [(start_pos[i] + goal_pos[i]) / 2.0 for i in range(dim)]\n        C = self._build_rotation_matrix(list(start_pos), list(goal_pos))\n\n        # Add roots to vertex lists\n        vertices_start = [self._graph.root_vertex_start]\n        vertices_goal = [self._graph.root_vertex_goal]\n\n        # Internal helper to grow tree towards q_target\n        def extend(root_vertex: Vertex, q_target: Point) -> Tuple[str, Optional[Vertex]]:\n            q_near = self._get_nearest_vertex(root_vertex, q_target)\n            q_new = self._get_new_vertex(q_near, q_target, self._max_dist)\n\n            # Reject if invalid line crossing obstacles\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                return 'trapped', None\n\n            # Compute cost to new vertex\n            cost_near = q_near.cost if hasattr(q_near, 'cost') else 0.0\n            move_cost = self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = cost_near + move_cost\n\n            # Find neighbors for rewiring\n            radius = min(self._max_dist * 2.0, self._max_dist*((math.log(len(vertices_start)+len(vertices_goal)+1)/ (len(vertices_start)+len(vertices_goal)+1))**(1/dim)))\n            near_vertices = self._get_vertices_near(root_vertex, q_new, radius)\n\n            # Pick best parent for q_new among near vertices to reduce cost\n            best_cost = q_new.cost\n            best_parent = q_near\n            for near_v in near_vertices:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(near_v.position, q_new.position)):\n                    cost = near_v.cost + self._get_grid().get_movement_cost(near_v.position, q_new.position) if hasattr(near_v, 'cost') else math.inf\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_parent = near_v\n            q_new.cost = best_cost\n\n            # Add q_new and connect best parent\n            self._graph.add_edge(best_parent, q_new)\n            vertices = vertices_start if root_vertex is self._graph.root_vertex_start else vertices_goal\n            vertices.append(q_new)\n\n            # Rewire neighbors to q_new if better\n            self._rewire(root_vertex, q_new, near_vertices)\n\n            if q_new.position == q_target:\n                return 'reached', q_new\n            else:\n                return 'advanced', q_new\n\n        # Bidirectional tree extension alternates between start and goal trees\n        for iter_count in range(self._iterations):\n            if time.time() - start_time > 10.0:\n                # Fail early on timeout\n                return\n\n            # Determine informed sampling radius (c_best)\n            if c_best == math.inf:\n                sample_point = self._get_random_sample(None, c_min, x_center, C)\n            else:\n                sample_point = self._get_random_sample(c_best, c_min, x_center, C)\n\n            # Alternate trees: even iter - start, odd iter - goal\n            tree_selector = iter_count % 2\n            tree_root = self._graph.root_vertex_start if tree_selector == 0 else self._graph.root_vertex_goal\n            other_tree_root = self._graph.root_vertex_goal if tree_selector == 0 else self._graph.root_vertex_start\n            tree_vertices = vertices_start if tree_selector == 0 else vertices_goal\n            other_tree_vertices = vertices_goal if tree_selector == 0 else vertices_start\n\n            outcome, q_new = extend(tree_root, sample_point)\n            if outcome == 'trapped' or q_new is None:\n                self.key_frame()\n                continue\n\n            # Try to connect the opposite tree towards q_new\n            outcome_connect, q_new_connect = 'advanced', None\n            q_target = q_new.position\n            while outcome_connect == 'advanced':\n                outcome_connect, q_new_connect = extend(other_tree_root, q_target)\n                if outcome_connect == 'reached':\n                    # Path found: extract\n                    v_from_tree = q_new if tree_selector == 0 else q_new_connect\n                    v_from_other = q_new_connect if tree_selector == 0 else q_new\n                    c_best = min(c_best, v_from_tree.cost + v_from_other.cost)\n\n                    self._extract_path(v_from_tree, v_from_other)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 266, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 225, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 206, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 275, in _find_path_internal\n  File \"<string>\", line 62, in _get_random_sample\n  File \"<string>\", line 62, in <listcomp>\nAttributeError: 'Services' object has no attribute 'get_random'\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This is an improved bidirectional informed RRT* inspired sample-based path planner\n      designed to enhance planning efficiency, path quality, robustness, path smoothness,\n      and success rate while reducing search time and path length.\n\n      Key features:\n      - Bidirectional trees (start and goal)\n      - Informed sampling focused around an ellipsoidal subset for path improvement\n      - Asymptotic optimality with rewiring to improve path quality dynamically\n      - Early termination when goal reachable\n      - Smoothness promotion by limiting step length and rewiring better parents\n      - Time-limited search (10 seconds max) to avoid long runtimes",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _start_time: float\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 12.0\n        self._iterations = 15000\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_random_sample(self, c_best: Optional[float], c_min: float, x_center: Point, C: List[List[float]]) -> Point:\n        \"\"\"Generate informed sample within an ellipsoid if c_best < inf, otherwise uniform random.\"\"\"\n        dim = self._get_grid().size.n_dim\n        random_generator = self._services.random  # Correct access to random generator\n        if c_best == math.inf or c_best == 0 or c_best is None:\n            while True:\n                sample_coords = [random_generator.randint(0, self._get_grid().size[i]-1) for i in range(dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling inside ellipsoid defined by c_best and transformation C\n        for _ in range(100):  # limited retries\n            # Sample unit n-ball\n            while True:\n                x_ball = [random_generator.normalvariate(0, 1) for _ in range(dim)]\n                s = sum(v*v for v in x_ball)\n                if s > 0:\n                    x_ball = [v / math.sqrt(s) for v in x_ball]\n                    break\n            r = random_generator.random() ** (1.0/dim)\n            x_ball = [r*v for v in x_ball]\n\n            # Scale by axis lengths\n            L = [c_best/2.0] + [math.sqrt(c_best*c_best - c_min*c_min)/2.0]*(dim-1)\n            x_scaled = [L[i] * x_ball[i] for i in range(dim)]\n\n            # Rotate and translate back to center\n            x_rotated = [sum(C[i][j]*x_scaled[j] for j in range(dim)) for i in range(dim)]\n            sample_coords = [int(round(x_center[i] + x_rotated[i])) for i in range(dim)]\n            sample = Point(*sample_coords)\n\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n        # fallback uniform sample\n        while True:\n            sample_coords = [random_generator.randint(0, self._get_grid().size[i]-1) for i in range(dim)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([root_vertex], q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        else:\n            dir_normalized = vec / dist\n            new_pos = q_near.position.to_tensor() + max_dist * dir_normalized\n            q_new = Point.from_tensor(new_pos)\n            return Vertex(q_new)\n\n    def _get_vertices_near(self, root_vertex: Vertex, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([root_vertex], q_new.position, radius)\n\n    def _rewire(self, root_vertex: Vertex, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # Try to improve cost to q_new by rewiring from neighbors\n        best_cost = q_new.cost if hasattr(q_new, 'cost') else math.inf\n        best_parent = None\n        for neighbor in neighbors:\n            if neighbor is q_new:\n                continue\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position)):\n                cost = neighbor.cost if hasattr(neighbor, 'cost') else 0.0\n                cost += self._get_grid().get_movement_cost(neighbor.position, q_new.position)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_parent = neighbor\n\n        if best_parent is not None:\n            # Reassign parent and cost\n            for p in list(q_new.parents):\n                self._graph.remove_edge(p, q_new)\n\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Try to rewire neighbors for which q_new offers better cost\n            for neighbor in neighbors:\n                if neighbor is q_new or neighbor is best_parent:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                    neighbor_cost = neighbor.cost if hasattr(neighbor, 'cost') else math.inf\n                    new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n                    if new_cost < neighbor_cost:\n                        for p in list(neighbor.parents):\n                            self._graph.remove_edge(p, neighbor)\n                        neighbor.cost = new_cost\n                        self._graph.add_edge(q_new, neighbor)\n\n    def _path_to_start(self, vertex: Vertex) -> List[Vertex]:\n        path = []\n        curr = vertex\n        while curr is not None:\n            path.append(curr)\n            if len(curr.parents) == 0:\n                break\n            # Pick the parent with minimal cost (or first if cost undefined)\n            costs_and_parents = [(p.cost if hasattr(p, 'cost') else 0, p) for p in curr.parents]\n            costs_and_parents.sort(key=lambda x: x[0])\n            curr = costs_and_parents[0][1]\n        path.reverse()\n        return path\n\n    def _extract_path(self, meet_vertex_start: Vertex, meet_vertex_goal: Vertex) -> None:\n        path_start = self._path_to_start(meet_vertex_start)\n        path_goal = self._path_to_start(meet_vertex_goal)\n        path_goal.reverse()  # from meeting vertex to goal\n        # Merge paths excluding duplicated meeting vertex\n        full_path = path_start + path_goal[1:]\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _build_rotation_matrix(self, x_center: List[float], goal_center: List[float]) -> List[List[float]]:\n        # Create orthonormal basis with first axis in direction (start->goal)\n        dim = len(x_center)\n        dir_vector = [goal_center[i] - x_center[i] for i in range(dim)]\n        dist = math.sqrt(sum(d * d for d in dir_vector))\n        if dist == 0:\n            return [[1 if i==j else 0 for j in range(dim)] for i in range(dim)]  # Identity matrix\n\n        e1 = [d / dist for d in dir_vector]\n        U = [e1]  # Base first vector\n\n        # Use Gram-Schmidt to generate remaining orthonormal basis vectors\n        for i in range(1, dim):\n            base_vector = [0]*dim\n            base_vector[i] = 1\n            proj = sum(base_vector[j]*e1[j] for j in range(dim))\n            orthogonal_vec = [base_vector[j]-proj*e1[j] for j in range(dim)]\n            norm_orth = math.sqrt(sum(x*x for x in orthogonal_vec))\n            if norm_orth < 1e-10:\n                # fallback vector orthogonal to e1\n                orthogonal_vec = [0]*dim\n                orthogonal_vec[(i)%dim] = 1\n                norm_orth = 1\n            orthonormal_vec = [x / norm_orth for x in orthogonal_vec]\n            U.append(orthonormal_vec)\n        return [list(col) for col in zip(*U)]  # transpose for rotation matrix\n\n    # Main function to find path #\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        self._start_time = start_time\n\n        dim = self._get_grid().size.n_dim\n        start_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n\n        # Initialize costs\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = 0.0\n\n        c_min = self._get_grid().get_distance(start_pos, goal_pos)  # minimum possible distance\n        c_best = math.inf\n\n        # Ellipsoid center and rotation matrix for informed sampling\n        x_center = [(start_pos[i] + goal_pos[i]) / 2.0 for i in range(dim)]\n        C = self._build_rotation_matrix(list(start_pos), list(goal_pos))\n\n        # Add roots to vertex lists\n        vertices_start = [self._graph.root_vertex_start]\n        vertices_goal = [self._graph.root_vertex_goal]\n\n        # Internal helper to grow tree towards q_target\n        def extend(root_vertex: Vertex, q_target: Point) -> Tuple[str, Optional[Vertex]]:\n            q_near = self._get_nearest_vertex(root_vertex, q_target)\n            q_new = self._get_new_vertex(q_near, q_target, self._max_dist)\n\n            # Reject if invalid line crossing obstacles\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                return 'trapped', None\n\n            # Compute cost to new vertex\n            cost_near = q_near.cost if hasattr(q_near, 'cost') else 0.0\n            move_cost = self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = cost_near + move_cost\n\n            # Find neighbors for rewiring\n            radius = min(self._max_dist * 2.0, self._max_dist*((math.log(len(vertices_start)+len(vertices_goal)+1)/ (len(vertices_start)+len(vertices_goal)+1))**(1/dim)))\n            near_vertices = self._get_vertices_near(root_vertex, q_new, radius)\n\n            # Pick best parent for q_new among near vertices to reduce cost\n            best_cost = q_new.cost\n            best_parent = q_near\n            for near_v in near_vertices:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(near_v.position, q_new.position)):\n                    cost = near_v.cost + self._get_grid().get_movement_cost(near_v.position, q_new.position) if hasattr(near_v, 'cost') else math.inf\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_parent = near_v\n            q_new.cost = best_cost\n\n            # Add q_new and connect best parent\n            self._graph.add_edge(best_parent, q_new)\n            vertices = vertices_start if root_vertex is self._graph.root_vertex_start else vertices_goal\n            vertices.append(q_new)\n\n            # Rewire neighbors to q_new if better\n            self._rewire(root_vertex, q_new, near_vertices)\n\n            if q_new.position == q_target:\n                return 'reached', q_new\n            else:\n                return 'advanced', q_new\n\n        # Bidirectional tree extension alternates between start and goal trees\n        for iter_count in range(self._iterations):\n            if time.time() - start_time > 10.0:\n                # Fail early on timeout\n                return\n\n            # Determine informed sampling radius (c_best)\n            if c_best == math.inf:\n                sample_point = self._get_random_sample(None, c_min, x_center, C)\n            else:\n                sample_point = self._get_random_sample(c_best, c_min, x_center, C)\n\n            # Alternate trees: even iter - start, odd iter - goal\n            tree_selector = iter_count % 2\n            tree_root = self._graph.root_vertex_start if tree_selector == 0 else self._graph.root_vertex_goal\n            other_tree_root = self._graph.root_vertex_goal if tree_selector == 0 else self._graph.root_vertex_start\n            tree_vertices = vertices_start if tree_selector == 0 else vertices_goal\n            other_tree_vertices = vertices_goal if tree_selector == 0 else vertices_start\n\n            outcome, q_new = extend(tree_root, sample_point)\n            if outcome == 'trapped' or q_new is None:\n                self.key_frame()\n                continue\n\n            # Try to connect the opposite tree towards q_new\n            outcome_connect, q_new_connect = 'advanced', None\n            q_target = q_new.position\n            while outcome_connect == 'advanced':\n                outcome_connect, q_new_connect = extend(other_tree_root, q_target)\n                if outcome_connect == 'reached':\n                    # Path found: extract\n                    v_from_tree = q_new if tree_selector == 0 else q_new_connect\n                    v_from_other = q_new_connect if tree_selector == 0 else q_new\n                    c_best = min(c_best, v_from_tree.cost + v_from_other.cost)\n\n                    self._extract_path(v_from_tree, v_from_other)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 266, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 225, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 206, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 276, in _find_path_internal\n  File \"<string>\", line 60, in _get_random_sample\nAttributeError: 'Services' object has no attribute 'random'\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an advanced sample-based planner combining adaptive hybrid sampling,\n    dynamic radius graph construction, and anytime path optimization.\n    It integrates:\n    - Hybrid sampling: mixes uniform and obstacle-informed guided samples (using obstacle boundaries)\n      to improve exploration efficiency and obstacle avoidance.\n    - Dynamic neighbor radius based on sampling density and iteration count for adaptive rewiring.\n    - Anytime incremental search: progressively refines path quality by rewiring and smoothing during planning.\n    - Lazy collision checking combined with incremental path validation for speed.\n    - Early termination if no improvement after some iterations or 10 seconds limit.\n    This approach improves path quality, success rate, and reduces planning time, while maintaining robustness and smooth paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n\n        # Parameters (tunable)\n        self._max_dist = 10.0\n        self._max_radius = 35.0\n        self._lambda_rrt_star = 40.0\n        self._dimension = self._get_grid().size.n_dim\n\n        # For hybrid sampling\n        self._obstacle_boundaries = self._compute_obstacle_boundaries()\n\n        self._start_time = 0\n        self._max_time_sec = 10.0\n        self._samples_taken = 0\n\n        self._found_path = False\n        self._best_goal_vertex = None\n        self._best_cost = float('inf')\n\n        self._improvement_iter = 0  # Counts iterations without improvement for early stop\n        self._max_no_improve_iter = 300  # After these, terminate search early\n\n        self._init_displays()\n\n    def _compute_obstacle_boundaries(self) -> List[Point]:\n        \"\"\"\n        Compute boundary points of all obstacles to inform hybrid sampling.\n        Returns a combined list of obstacle boundary points.\n        \"\"\"\n        boundaries = []\n        visited = set()\n        for obs in self._get_grid().obstacles:\n            bound = self._get_grid().get_obstacle_bound(obs.position, visited)\n            boundaries.extend(bound)\n            visited.update(bound)\n        return boundaries\n\n    def _sample_from_obstacle_boundaries(self) -> Point:\n        \"\"\"\n        Sample near obstacle boundaries with Gaussian noise.\n        This encourages samples close but not inside obstacles.\n        \"\"\"\n        import random\n        import torch\n\n        if not self._obstacle_boundaries:\n            return self._get_random_sample_uniform()\n\n        # Choose random boundary point\n        base_pt = random.choice(self._obstacle_boundaries)\n\n        # Add small Gaussian offset to avoid exact obstacles and promote clearance\n        offset_scale = 3.0  # tunable\n        noise = []\n        for i in range(self._dimension):\n            noise.append(torch.normal(mean=0.0, std=offset_scale).item())\n        new_coords = []\n        grid_size = self._get_grid().size\n        for i in range(self._dimension):\n            c = base_pt[i] + noise[i]\n            c = max(0, min(c, grid_size[i] - 1))\n            new_coords.append(int(round(c)))\n\n        new_point = Point(*new_coords)\n        if self._get_grid().is_agent_valid_pos(new_point):\n            return new_point\n        else:\n            # Fallback uniform sample\n            return self._get_random_sample_uniform()\n\n    def _get_random_sample_uniform(self) -> Point:\n        \"\"\"Uniform random sample anywhere valid in workspace.\"\"\"\n        grid_size = self._get_grid().size\n        import torch\n        while True:\n            coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(self._dimension)]\n            p = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(p):\n                return p\n\n    def _get_hybrid_sample(self, p_obstacle_prob=0.3) -> Point:\n        \"\"\"\n        Hybrid sample: with probability p_obstacle_prob sample near obstacle boundaries,\n        else uniform random.\n        \"\"\"\n        import random\n        if random.random() < p_obstacle_prob:\n            return self._sample_from_obstacle_boundaries()\n        else:\n            return self._get_random_sample_uniform()\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        import torch\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec).item()\n        if length < 1e-6:\n            return None\n        if length <= self._max_dist:\n            new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / length\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_pos = Point.from_tensor(new_pos_tensor)\n\n        if not self._get_grid().is_agent_valid_pos(new_pos):\n            return None\n\n        return Vertex(new_pos)\n\n    def _line_collision_free_lazy(self, frm: Point, to: Point) -> bool:\n        \"\"\"\n        Lazy collision check: quickly reject invalid edges by stepping over line points.\n        Early exit on first invalid point.\n        \"\"\"\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        for p in line_seq:\n            if not self._get_grid().is_agent_valid_pos(p):\n                return False\n        return True\n\n    def _rewire(self, q_new: Vertex, Q_near: List[Vertex]) -> None:\n        import torch\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n            if dist > self._max_dist:\n                continue\n            new_cost = q_new.cost + dist\n            if q_near.cost is None or new_cost < q_near.cost:\n                if self._line_collision_free_lazy(q_new.position, q_near.position):\n                    # Remove old parent edge\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    # Add new edge\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Vertex]:\n        path = [goal_vertex]\n        while len(path[-1].parents) > 0:\n            min_parent = None\n            min_cost = float('inf')\n            for parent in path[-1].parents:\n                if parent.cost is not None and parent.cost < min_cost:\n                    min_cost = parent.cost\n                    min_parent = parent\n            if min_parent is None:\n                break\n            path.append(min_parent)\n        path.reverse()\n        return path\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_collision_free_lazy(path[i].position, path[j].position):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _dynamic_radius(self, n_vertices: int) -> float:\n        import torch\n        if n_vertices <= 1:\n            return self._max_radius\n        log_n = torch.log(torch.tensor(float(n_vertices) + 1e-8))\n        radius = min(self._lambda_rrt_star * ((log_n / n_vertices) ** (1.0 / self._dimension)), self._max_radius)\n        return radius.item()\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        self._start_time = time.perf_counter()\n\n        start = self._graph.root_vertex_start\n        goal = self._graph.root_vertex_goal\n\n        start.cost = 0.0\n        self._found_path = False\n        self._best_goal_vertex = None\n        self._best_cost = float('inf')\n        self._improvement_iter = 0\n\n        max_iterations = 15000\n\n        for iteration in range(max_iterations):\n            if time.perf_counter() - self._start_time > self._max_time_sec:\n                # Time limit exceeded, fail gracefully\n                break\n\n            # Hybrid sampling improves exploration and obstacle avoidance\n            q_sample = self._get_hybrid_sample()\n\n            q_near = self._get_nearest_vertex(q_sample)\n            if q_near is None:\n                continue\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            if q_new is None:\n                continue\n\n            # Lazy collision check before further processing\n            if not self._line_collision_free_lazy(q_near.position, q_new.position):\n                continue\n\n            cost_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = cost_to_new\n\n            # Dynamic radius based on current graph size\n            radius = self._dynamic_radius(self._graph.size)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent from Q_near minimizing cost and collision-free\n            q_min = q_near\n            c_min_vertex = cost_to_new\n            for q_near_cand in Q_near:\n                if q_near_cand == q_new:\n                    continue\n                dist = torch.norm(q_near_cand.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist > self._max_dist:\n                    continue\n                cand_cost = q_near_cand.cost + dist\n                if q_near_cand.cost is not None and cand_cost < c_min_vertex:\n                    if self._line_collision_free_lazy(q_near_cand.position, q_new.position):\n                        q_min = q_near_cand\n                        c_min_vertex = cand_cost\n\n            q_new.cost = c_min_vertex\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors for improved paths\n            self._rewire(q_new, Q_near)\n\n            # Insert new vertex into graph root vertices so it expands graph size\n            self._graph.root_vertices.append(q_new)\n\n            # Check goal proximity\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Evaluate path cost including cost to goal point\n                dist_goal = torch.norm(q_new.position.to_tensor() - goal.position.to_tensor()).item()\n                total_cost = q_new.cost + dist_goal\n                if total_cost + 1e-6 < self._best_cost:  # Allow tiny improvement tolerance\n                    self._best_cost = total_cost\n                    self._best_goal_vertex = q_new\n                    self._found_path = True\n                    self._improvement_iter = 0  # reset no improvement count\n                else:\n                    self._improvement_iter += 1\n            else:\n                self._improvement_iter += 1\n\n            self.key_frame()\n\n            # Early stop if no improvement for too long\n            if self._improvement_iter > self._max_no_improve_iter:\n                break\n\n        # After main loop finishes\n        if self._found_path and self._best_goal_vertex is not None:\n            raw_path = self._extract_path(self._best_goal_vertex)\n            smooth_path = self._smooth_path(raw_path)\n            for vertex in smooth_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # Failed to find path within constraints\n            pass",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 233, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 214, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 256, in _find_path_internal\n  File \"<string>\", line 134, in _get_hybrid_sample\n  File \"<string>\", line 102, in _sample_from_obstacle_boundaries\nTypeError: normal() received an invalid combination of arguments - got (mean=float, std=float, ), but expected one of:\n * (Tensor mean, Tensor std, *, torch.Generator generator = None, Tensor out = None)\n * (Tensor mean, float std = 1, *, torch.Generator generator = None, Tensor out = None)\n * (float mean, Tensor std, *, torch.Generator generator = None, Tensor out = None)\n * (float mean, float std, tuple of ints size, *, torch.Generator generator = None, Tensor out = None, torch.dtype dtype = None, torch.layout layout = None, torch.device device = None, bool pin_memory = False, bool requires_grad = False)\n\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an improved sampling-based planner inspired by RRT* with informed sampling and lazy collision checking. \n    It maintains a forest graph and incrementally builds paths by sampling points biased towards the goal using ellipsoidal \n    informed sampling, connecting vertices within a neighborhood radius. It uses a rewiring step to improve path quality \n    continuously and performs lazy collision checking only when connecting edges to reduce computation. Search terminates \n    successfully when a valid path to the goal is found or fails if exceeding a 10-second time limit. The approach balances \n    efficient sampling, path quality, smoothness, and computational efficiency to improve over plain SPRM methods.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        self._V_size = 300                  # Larger sample size for better coverage\n        self._max_radius = 20.0             # Neighborhood search radius for rewiring\n        self._goal_bias_prob = 0.2          # Probability to sample the goal point directly\n        self._graph = None\n\n        V = []\n        for _ in range(self._V_size):\n            q_rand = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = True\n\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Samples a point in the grid with goal bias and informed ellipsoidal sampling \n        around the current best path for efficiency.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        agent_pos = grid.agent.position\n\n        # Sampling box bounds\n        bounds = [grid.size[i] for i in range(grid.size.n_dim)]\n\n        # Goal biasing: with some probability sample goal directly\n        if torch.rand(1).item() < self._goal_bias_prob:\n            return Point(*goal_pos)\n\n        # If no path found yet, uniform random sampling\n        if not hasattr(self, \"_best_cost\"):\n            while True:\n                sample_coords = [torch.randint(0, bounds[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed Ellipsoidal Sampling (hypersphere around start-goal)\n        dist_start_goal = Map.get_distance(agent_pos, goal_pos)\n        c_best = getattr(self, \"_best_cost\", float(\"inf\"))\n\n        # If no feasible path cost known, just uniform sampling\n        if not (c_best < float(\"inf\")):\n            while True:\n                sample_coords = [torch.randint(0, bounds[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        c_min = dist_start_goal\n        center = Point(*[(agent_pos[i] + goal_pos[i]) / 2.0 for i in range(agent_pos.n_dim)])\n\n        # Define lengths of ellipse axes - major axis = c_best/2, others = sqrt(c_best\u00b2 - c_min\u00b2)/2\n        r1 = c_best / 2.0\n        if agent_pos.n_dim == 2:\n            r2 = ( (c_best**2 - c_min**2) ** 0.5 ) / 2.0 if c_best > c_min else 0.0\n            # Sample in unit circle then scale into ellipse\n            while True:\n                theta = 2 * 3.14159265359 * torch.rand(1).item()\n                rad = torch.rand(1).item() ** 0.5\n                x = rad * torch.cos(torch.tensor(theta))\n                y = rad * torch.sin(torch.tensor(theta))\n                sample_x = center.x + r1 * x.item()\n                sample_y = center.y + r2 * y.item()\n                sample_pt = Point(int(round(sample_x)), int(round(sample_y)))\n                if 0 <= sample_pt.x < bounds[0] and 0 <= sample_pt.y < bounds[1]:\n                    if grid.is_agent_valid_pos(sample_pt):\n                        return sample_pt\n        else:\n            # For n_dim > 2 uniform sampling inside hyperellipsoid (approximate)\n            while True:\n                rand_dir = torch.randn(agent_pos.n_dim)\n                rand_dir = rand_dir / torch.norm(rand_dir)\n                mag = torch.rand(1).item() ** (1.0 / agent_pos.n_dim)\n                scaled_dir = rand_dir * mag\n                # Scale major axis only along first dimension (approximation)\n                scaled_dir[0] = scaled_dir[0] * r1\n                # For other dims, scale to radius sqrt(c_best\u00b2 - c_min\u00b2)/2\n                scale_minor = ((c_best ** 2 - c_min ** 2) ** 0.5 / 2.0) if c_best > c_min else 0.0\n                for i in range(1, agent_pos.n_dim):\n                    scaled_dir[i] *= scale_minor\n                sample_coords = [center[i] + scaled_dir[i].item() for i in range(agent_pos.n_dim)]\n                sample_coords_int = [int(round(x)) for x in sample_coords]\n                sample_pt = Point(*sample_coords_int)\n                if all(0 <= sample_pt[i] < bounds[i] for i in range(agent_pos.n_dim)):\n                    if grid.is_agent_valid_pos(sample_pt):\n                        return sample_pt\n\n    def _get_near_vertices(self, position: Point) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, position, self._max_radius)\n\n    def _get_cost(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        return self._get_grid().get_movement_cost(from_vertex.position, to_vertex.position)\n\n    def _can_connect(self, p1: Point, p2: Point) -> bool:\n        \"\"\"Lazy collision check via Bresenham line with grid validation.\"\"\"\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Rewires the graph to improve path costs by connecting new_vertex to better parents,\n        and potentially reconnect children to new_vertex if beneficial.\n        \"\"\"\n        improved_parents = []\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex:\n                continue\n            if self._can_connect(near_vertex.position, new_vertex.position):\n                new_cost = near_vertex.cost + self._get_cost(near_vertex, new_vertex)\n                if new_cost < new_vertex.cost:\n                    new_vertex.parents.clear()\n                    new_vertex.cost = new_cost\n                    new_vertex.add_parent(near_vertex)\n                    near_vertex.add_child(new_vertex)\n                    improved_parents.append(near_vertex)\n\n        # Rewire children\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex:\n                continue\n            if self._can_connect(new_vertex.position, near_vertex.position):\n                new_cost = new_vertex.cost + self._get_cost(new_vertex, near_vertex)\n                if new_cost < near_vertex.cost:\n                    for p in list(near_vertex.parents):\n                        p.children.discard(near_vertex)\n                        near_vertex.parents.discard(p)\n                    near_vertex.cost = new_cost\n                    near_vertex.add_parent(new_vertex)\n                    new_vertex.add_child(near_vertex)\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Extracts the best path from the start vertex to the goal vertex using BFS \n        along parents with lowest cost, and moves the agent stepwise along it.\n        \"\"\"\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        # BFS from goal to start by walking parents to build path backward\n        path = deque()\n        current = goal_vertex\n        if current.cost == float(\"inf\"):\n            # No path exists\n            return\n        while current != start_vertex:\n            path.appendleft(current)\n            # Choose the lowest cost parent\n            parents_sorted = sorted(current.parents, key=lambda v: v.cost)\n            if not parents_sorted:\n                # Disconnected, no valid path\n                return\n            current = parents_sorted[0]\n        path.appendleft(start_vertex)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _initialize_costs(self) -> None:\n        \"\"\"Initialize vertex costs: zero for start, infinity else.\"\"\"\n        for v in self._graph.root_vertices:\n            v.cost = float(\"inf\")\n            v.parents.clear()\n            v.children.clear()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n    def _find_path_internal(self) -> None:\n        \"\"\"\n        Main function implementing RRT*-style informed path planning with time limit.\n        Samples, connects, rewires, and updates best path dynamically.\n        \"\"\"\n        grid = self._get_grid()\n        start_time = time()\n        max_duration = 10.0  # seconds timeout\n\n        self._initialize_costs()\n\n        # Insert edges from start and goal roots to their neighbors initially\n        for root in self._graph.root_vertices:\n            near_vertices = self._get_near_vertices(root.position)\n            for near_v in near_vertices:\n                if near_v == root:\n                    continue\n                if self._can_connect(root.position, near_v.position):\n                    cost_edge = self._get_cost(root, near_v)\n                    if root.cost + cost_edge < near_v.cost:\n                        near_v.cost = root.cost + cost_edge\n                        near_v.parents.clear()\n                        near_v.add_parent(root)\n                        root.add_child(near_v)\n\n        vertices = list(self._graph.root_vertices)\n\n        # Main iterative sampling, connecting, rewiring loop\n        while True:\n            if (time() - start_time) > max_duration:\n                return  # timeout/failure\n\n            # Sample new point\n            q_rand = self._get_random_sample()\n\n            # Find nearest vertex to the sampled point\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_rand)\n\n            # Steer towards q_rand with maximum step limited by max_radius (step size)\n            direction = q_rand.to_tensor() - q_near.position.to_tensor()\n            dist = torch.norm(direction).item()\n            if dist == 0:\n                continue\n            if dist > self._max_radius:\n                direction = direction / dist * self._max_radius\n                q_new_pt = Point.from_tensor(q_near.position.to_tensor() + direction)\n            else:\n                q_new_pt = q_rand\n\n            if not grid.is_agent_valid_pos(q_new_pt):\n                continue\n\n            if not self._can_connect(q_near.position, q_new_pt):\n                continue\n\n            q_new = Vertex(q_new_pt, store_connectivity=True)\n            # Cost from start to q_new through q_near\n            tentative_cost = q_near.cost + self._get_cost(q_near, q_new)\n\n            # Find near vertices for rewiring\n            near_vertices = self._get_near_vertices(q_new.position)\n\n            # Choose the best parent for q_new\n            min_cost = tentative_cost\n            best_parent = q_near\n            for near_v in near_vertices:\n                if near_v == q_near:\n                    continue\n                if self._can_connect(near_v.position, q_new.position):\n                    cost_through_near = near_v.cost + self._get_cost(near_v, q_new)\n                    if cost_through_near < min_cost:\n                        min_cost = cost_through_near\n                        best_parent = near_v\n\n            q_new.cost = min_cost\n            q_new.add_parent(best_parent)\n            best_parent.add_child(q_new)\n\n            # Add q_new to vertices and graph root vertices list to maintain structure\n            self._graph.root_vertices.append(q_new)\n            vertices.append(q_new)\n\n            # Rewire neighbors to improve paths\n            self._rewire(q_new, near_vertices)\n\n            # Check if can connect q_new to goal root vertex (possibly shortcut)\n            goal_vertex = self._graph.root_vertex_goal\n            if self._can_connect(q_new.position, goal_vertex.position):\n                cost_to_goal = q_new.cost + self._get_cost(q_new, goal_vertex)\n                if cost_to_goal < goal_vertex.cost:\n                    for p in list(goal_vertex.parents):\n                        p.children.discard(goal_vertex)\n                    goal_vertex.parents.clear()\n                    goal_vertex.cost = cost_to_goal\n                    goal_vertex.add_parent(q_new)\n                    q_new.add_child(goal_vertex)\n\n                    # Update best known cost for informed sampling\n                    self._best_cost = cost_to_goal\n\n                    # Extract and follow path\n                    self._extract_path()\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 233, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 214, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 224, in _find_path_internal\nTypeError: 'module' object is not callable\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an improved sampling-based planner inspired by RRT* with informed sampling and lazy collision checking. \n    It maintains a forest graph and incrementally builds paths by sampling points biased towards the goal using ellipsoidal \n    informed sampling, connecting vertices within a neighborhood radius. It uses a rewiring step to improve path quality \n    continuously and performs lazy collision checking only when connecting edges to reduce computation. Search terminates \n    successfully when a valid path to the goal is found or fails if exceeding a 10-second time limit. The approach balances \n    efficient sampling, path quality, smoothness, and computational efficiency to improve over plain SPRM methods.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n\n        self._V_size = 300                  # Larger sample size for better coverage\n        self._max_radius = 20.0             # Neighborhood search radius for rewiring\n        self._goal_bias_prob = 0.2          # Probability to sample the goal point directly\n        self._graph = None\n\n        V = []\n        for _ in range(self._V_size):\n            q_rand = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = True\n\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Samples a point in the grid with goal bias and informed ellipsoidal sampling \n        around the current best path for efficiency.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        agent_pos = grid.agent.position\n\n        # Sampling box bounds\n        bounds = [grid.size[i] for i in range(grid.size.n_dim)]\n\n        # Goal biasing: with some probability sample goal directly\n        if torch.rand(1).item() < self._goal_bias_prob:\n            return Point(*goal_pos)\n\n        # If no path found yet, uniform random sampling\n        if not hasattr(self, \"_best_cost\"):\n            while True:\n                sample_coords = [torch.randint(0, bounds[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed Ellipsoidal Sampling (hypersphere around start-goal)\n        dist_start_goal = Map.get_distance(agent_pos, goal_pos)\n        c_best = getattr(self, \"_best_cost\", float(\"inf\"))\n\n        # If no feasible path cost known, just uniform sampling\n        if not (c_best < float(\"inf\")):\n            while True:\n                sample_coords = [torch.randint(0, bounds[i], (1,)).item() for i in range(grid.size.n_dim)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        c_min = dist_start_goal\n        center = Point(*[(agent_pos[i] + goal_pos[i]) / 2.0 for i in range(agent_pos.n_dim)])\n\n        # Define lengths of ellipse axes - major axis = c_best/2, others = sqrt(c_best\u00b2 - c_min\u00b2)/2\n        r1 = c_best / 2.0\n        if agent_pos.n_dim == 2:\n            r2 = ((c_best**2 - c_min**2) ** 0.5) / 2.0 if c_best > c_min else 0.0\n            # Sample in unit circle then scale into ellipse\n            while True:\n                theta = 2 * 3.14159265359 * torch.rand(1).item()\n                rad = torch.rand(1).item() ** 0.5\n                x = rad * torch.cos(torch.tensor(theta))\n                y = rad * torch.sin(torch.tensor(theta))\n                sample_x = center.x + r1 * x.item()\n                sample_y = center.y + r2 * y.item()\n                sample_pt = Point(int(round(sample_x)), int(round(sample_y)))\n                if 0 <= sample_pt.x < bounds[0] and 0 <= sample_pt.y < bounds[1]:\n                    if grid.is_agent_valid_pos(sample_pt):\n                        return sample_pt\n        else:\n            # For n_dim > 2 uniform sampling inside hyperellipsoid (approximate)\n            while True:\n                rand_dir = torch.randn(agent_pos.n_dim)\n                rand_dir = rand_dir / torch.norm(rand_dir)\n                mag = torch.rand(1).item() ** (1.0 / agent_pos.n_dim)\n                scaled_dir = rand_dir * mag\n                # Scale major axis only along first dimension (approximation)\n                scaled_dir[0] = scaled_dir[0] * r1\n                # For other dims, scale to radius sqrt(c_best\u00b2 - c_min\u00b2)/2\n                scale_minor = ((c_best ** 2 - c_min ** 2) ** 0.5 / 2.0) if c_best > c_min else 0.0\n                for i in range(1, agent_pos.n_dim):\n                    scaled_dir[i] *= scale_minor\n                sample_coords = [center[i] + scaled_dir[i].item() for i in range(agent_pos.n_dim)]\n                sample_coords_int = [int(round(x)) for x in sample_coords]\n                sample_pt = Point(*sample_coords_int)\n                if all(0 <= sample_pt[i] < bounds[i] for i in range(agent_pos.n_dim)):\n                    if grid.is_agent_valid_pos(sample_pt):\n                        return sample_pt\n\n    def _get_near_vertices(self, position: Point) -> list[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, position, self._max_radius)\n\n    def _get_cost(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        return self._get_grid().get_movement_cost(from_vertex.position, to_vertex.position)\n\n    def _can_connect(self, p1: Point, p2: Point) -> bool:\n        \"\"\"Lazy collision check via Bresenham line with grid validation.\"\"\"\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: list[Vertex]) -> None:\n        \"\"\"\n        Rewires the graph to improve path costs by connecting new_vertex to better parents,\n        and potentially reconnect children to new_vertex if beneficial.\n        \"\"\"\n        improved_parents = []\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex:\n                continue\n            if self._can_connect(near_vertex.position, new_vertex.position):\n                new_cost = near_vertex.cost + self._get_cost(near_vertex, new_vertex)\n                if new_cost < new_vertex.cost:\n                    new_vertex.parents.clear()\n                    new_vertex.cost = new_cost\n                    new_vertex.add_parent(near_vertex)\n                    near_vertex.add_child(new_vertex)\n                    improved_parents.append(near_vertex)\n\n        # Rewire children\n        for near_vertex in near_vertices:\n            if near_vertex == new_vertex:\n                continue\n            if self._can_connect(new_vertex.position, near_vertex.position):\n                new_cost = new_vertex.cost + self._get_cost(new_vertex, near_vertex)\n                if new_cost < near_vertex.cost:\n                    for p in list(near_vertex.parents):\n                        p.children.discard(near_vertex)\n                        near_vertex.parents.discard(p)\n                    near_vertex.cost = new_cost\n                    near_vertex.add_parent(new_vertex)\n                    new_vertex.add_child(near_vertex)\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Extracts the best path from the start vertex to the goal vertex using BFS \n        along parents with lowest cost, and moves the agent stepwise along it.\n        \"\"\"\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        # BFS from goal to start by walking parents to build path backward\n        path = deque()\n        current = goal_vertex\n        if current.cost == float(\"inf\"):\n            # No path exists\n            return\n        while current != start_vertex:\n            path.appendleft(current)\n            # Choose the lowest cost parent\n            parents_sorted = sorted(current.parents, key=lambda v: v.cost)\n            if not parents_sorted:\n                # Disconnected, no valid path\n                return\n            current = parents_sorted[0]\n        path.appendleft(start_vertex)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _initialize_costs(self) -> None:\n        \"\"\"Initialize vertex costs: zero for start, infinity else.\"\"\"\n        for v in self._graph.root_vertices:\n            v.cost = float(\"inf\")\n            v.parents.clear()\n            v.children.clear()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n    def _find_path_internal(self) -> None:\n        \"\"\"\n        Main function implementing RRT*-style informed path planning with time limit.\n        Samples, connects, rewires, and updates best path dynamically.\n        \"\"\"\n        grid = self._get_grid()\n        start_time = time.time()\n        max_duration = 10.0  # seconds timeout\n\n        self._initialize_costs()\n\n        # Insert edges from start and goal roots to their neighbors initially\n        for root in self._graph.root_vertices:\n            near_vertices = self._get_near_vertices(root.position)\n            for near_v in near_vertices:\n                if near_v == root:\n                    continue\n                if self._can_connect(root.position, near_v.position):\n                    cost_edge = self._get_cost(root, near_v)\n                    if root.cost + cost_edge < near_v.cost:\n                        near_v.cost = root.cost + cost_edge\n                        near_v.parents.clear()\n                        near_v.add_parent(root)\n                        root.add_child(near_v)\n\n        vertices = list(self._graph.root_vertices)\n\n        # Main iterative sampling, connecting, rewiring loop\n        while True:\n            if (time.time() - start_time) > max_duration:\n                return  # timeout/failure\n\n            # Sample new point\n            q_rand = self._get_random_sample()\n\n            # Find nearest vertex to the sampled point\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_rand)\n\n            # Steer towards q_rand with maximum step limited by max_radius (step size)\n            direction = q_rand.to_tensor() - q_near.position.to_tensor()\n            dist = torch.norm(direction).item()\n            if dist == 0:\n                continue\n            if dist > self._max_radius:\n                direction = direction / dist * self._max_radius\n                q_new_pt = Point.from_tensor(q_near.position.to_tensor() + direction)\n            else:\n                q_new_pt = q_rand\n\n            if not grid.is_agent_valid_pos(q_new_pt):\n                continue\n\n            if not self._can_connect(q_near.position, q_new_pt):\n                continue\n\n            q_new = Vertex(q_new_pt, store_connectivity=True)\n            # Cost from start to q_new through q_near\n            tentative_cost = q_near.cost + self._get_cost(q_near, q_new)\n\n            # Find near vertices for rewiring\n            near_vertices = self._get_near_vertices(q_new.position)\n\n            # Choose the best parent for q_new\n            min_cost = tentative_cost\n            best_parent = q_near\n            for near_v in near_vertices:\n                if near_v == q_near:\n                    continue\n                if self._can_connect(near_v.position, q_new.position):\n                    cost_through_near = near_v.cost + self._get_cost(near_v, q_new)\n                    if cost_through_near < min_cost:\n                        min_cost = cost_through_near\n                        best_parent = near_v\n\n            q_new.cost = min_cost\n            q_new.add_parent(best_parent)\n            best_parent.add_child(q_new)\n\n            # Add q_new to vertices and graph root vertices list to maintain structure\n            self._graph.root_vertices.append(q_new)\n            vertices.append(q_new)\n\n            # Rewire neighbors to improve paths\n            self._rewire(q_new, near_vertices)\n\n            # Check if can connect q_new to goal root vertex (possibly shortcut)\n            goal_vertex = self._graph.root_vertex_goal\n            if self._can_connect(q_new.position, goal_vertex.position):\n                cost_to_goal = q_new.cost + self._get_cost(q_new, goal_vertex)\n                if cost_to_goal < goal_vertex.cost:\n                    for p in list(goal_vertex.parents):\n                        p.children.discard(goal_vertex)\n                    goal_vertex.parents.clear()\n                    goal_vertex.cost = cost_to_goal\n                    goal_vertex.add_parent(q_new)\n                    q_new.add_child(goal_vertex)\n\n                    # Update best known cost for informed sampling\n                    self._best_cost = cost_to_goal\n\n                    # Extract and follow path\n                    self._extract_path()\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 269, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 137, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an improved sampling-based planner integrating RRT*-style rewiring, \n    adaptive informed sampling, bidirectional search, and path smoothing. \n    \n    Key improvements:\n    1. Bidirectional tree growth from start and goal, reducing convergence time and improving success rate.\n    2. Adaptive informed sampling ellipsoids from both directions after initial connection, focusing search.\n    3. RRT* rewiring in both trees for path quality improvement.\n    4. Lazy collision checking with early abandon for efficiency.\n    5. Dynamic radius for rewiring based on vertex count and dimensionality.\n    6. After connection, smooth shortcutting path to improve path smoothness and length.\n    7. Strict 10 seconds timeout to fail gracefully.\n\n    The algorithm grows two forests (from start and goal), tries to connect them efficiently, extracts best path, smooths it,\n    and moves the agent along the final planned trajectory.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._max_dist = 12.0\n        self._max_radius = 40.0\n        self._lambda_rrt_star = 40.0\n        self._dimension = self._get_grid().size.n_dim\n        self._start_time = 0\n        self._samples_taken = 0\n        self._found_path = False\n        self._best_start_vertex: Vertex = None\n        self._best_goal_vertex: Vertex = None\n        self._best_cost = float('inf')\n        self._init_displays()\n\n    def _get_random_sample(self, informed_ball_start: tuple = None, informed_ball_goal: tuple = None) -> Point:\n        \"\"\"\n        Samples a point either uniformly or inside combined ellipsoids from start and goal informed sampling.\n        If informed balls for both trees are provided, probabilistically sample from one or uniform.\n        Otherwise uniform sampling.\n        \"\"\"\n        grid_size = self._get_grid().size\n        # Simple logic: 40% from start ellipsoid, 40% from goal ellipsoid, 20% uniform if informed balls exist\n        import random\n        prob = random.random()\n\n        def sample_ellipsoid(center: Point, c_best: float, c_min: float) -> Point:\n            if grid_size.n_dim != 2:\n                # fallback to uniform\n                return None\n            a1 = c_best / 2\n            try:\n                a2 = (c_best**2 - c_min**2)**0.5 / 2\n            except Exception:\n                return None\n            for _ in range(200):\n                rx = torch.FloatTensor(1).uniform_(-1,1).item()\n                ry = torch.FloatTensor(1).uniform_(-1,1).item()\n                norm = (rx**2 + ry**2)**0.5\n                if norm > 1e-5:\n                    break\n            else:\n                return None\n            rx /= norm\n            ry /= norm\n            r = torch.FloatTensor(1).uniform_(0,1).item() ** (1 / 2)\n            x = r * a1 * rx\n            y = r * a2 * ry\n            # Rotation: along vector start -> goal\n            start = self._graph_start.root_vertex_start.position\n            goal = self._graph_start.root_vertex_goal.position\n            delta = torch.tensor([goal.x - start.x, goal.y - start.y])\n            angle = torch.atan2(delta[1], delta[0]).item()\n            cos_ang = torch.cos(torch.tensor(angle))\n            sin_ang = torch.sin(torch.tensor(angle))\n            rot_x = cos_ang * x - sin_ang * y\n            rot_y = sin_ang * x + cos_ang * y\n            sample_x = int(round(center.x + rot_x))\n            sample_y = int(round(center.y + rot_y))\n            sample_x = max(0, min(sample_x, grid_size[0] - 1))\n            sample_y = max(0, min(sample_y, grid_size[1] - 1))\n            sample = Point(sample_x, sample_y)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            return None\n\n        if informed_ball_start and informed_ball_goal:\n            if prob < 0.4:\n                s = sample_ellipsoid(*informed_ball_start)\n                if s is not None:\n                    return s\n            elif prob < 0.8:\n                s = sample_ellipsoid(*informed_ball_goal)\n                if s is not None:\n                    return s\n            # fallback uniform\n        elif informed_ball_start:\n            s = sample_ellipsoid(*informed_ball_start)\n            if s is not None:\n                return s\n        elif informed_ball_goal:\n            s = sample_ellipsoid(*informed_ball_goal)\n            if s is not None:\n                return s\n\n        # uniform sampling fallback\n        attempts = 0\n        while attempts < 500:\n            rand_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(grid_size.n_dim)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n        # As a last resort fallback to agent's position to prevent error\n        return self._get_grid().agent.position\n\n    def _get_nearest_vertex(self, graph: Forest, q_sample: Point) -> Vertex:\n        return graph.get_nearest_vertex(graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, graph: Forest, position: Point, radius: float) -> list:\n        return graph.get_vertices_within_radius(graph.root_vertices, position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec)\n        if length < 1e-6:\n            return None\n        if length <= self._max_dist:\n            new_vertex_pos = q_sample\n        else:\n            dir_normalized = dir_vec / length\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_vertex_pos = Point.from_tensor(new_pos_tensor)\n        if not self._get_grid().is_agent_valid_pos(new_vertex_pos):\n            return None\n        return Vertex(new_vertex_pos)\n\n    def _line_collision_free_lazy(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        for pt in line_seq:\n            if not self._get_grid().is_agent_valid_pos(pt):\n                return False\n        return True\n\n    def _rewire(self, graph: Forest, q_new: Vertex, Q_near: list) -> None:\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n            if dist > self._max_dist:\n                continue\n            new_cost = q_new.cost + dist\n            if new_cost < q_near.cost:\n                if self._line_collision_free_lazy(q_new.position, q_near.position):\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    graph.add_edge(q_new, q_near)\n\n    def _connect_trees(self, v_start: Vertex, v_goal: Vertex) -> (Vertex, Vertex, float):\n        \"\"\"\n        Attempts to connect two vertices from start and goal trees directly if collision-free.\n        Returns tuple (start_vertex, goal_vertex, cost) if successful; else None.\n        \"\"\"\n        if not self._line_collision_free_lazy(v_start.position, v_goal.position):\n            return None\n        dist = torch.norm(v_start.position.to_tensor() - v_goal.position.to_tensor()).item()\n        total_cost = v_start.cost + dist + v_goal.cost\n        return (v_start, v_goal, total_cost)\n\n    def _extract_bidirectional_path(self, start_vertex: Vertex, goal_vertex: Vertex) -> list:\n        \"\"\"\n        Extract path from start vertex in start tree and from goal vertex in goal tree,\n        concatenating paths at meeting point.\n        \"\"\"\n        path_start = []\n        cur = start_vertex\n        while cur is not None:\n            path_start.append(cur)\n            if not cur.parents:\n                break\n            # Choose parent with minimal cost (should usually be one)\n            min_cost = float('inf')\n            min_p = None\n            for p in cur.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_p = p\n            cur = min_p\n        path_start.reverse()\n\n        path_goal = []\n        cur = goal_vertex\n        while cur is not None:\n            path_goal.append(cur)\n            if not cur.parents:\n                break\n            min_cost = float('inf')\n            min_p = None\n            for p in cur.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_p = p\n            cur = min_p\n\n        # Reverse path_goal for correct direction\n        path_goal.reverse()\n        # Remove duplicate meeting vertex at join\n        if len(path_goal) > 0 and len(path_start) > 0 and path_start[-1].position == path_goal[0].position:\n            path_goal = path_goal[1:]\n\n        return path_start + path_goal\n\n    def _smooth_path(self, path: list) -> list:\n        \"\"\"\n        Shortcut smoothing removing unnecessary vertices by connecting farther apart vertices directly.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_collision_free_lazy(path[i].position, path[j].position):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.perf_counter()\n        max_time_sec = 10.0\n        max_iterations = 15000\n\n        start_tree = self._graph_start\n        goal_tree = self._graph_goal\n\n        start_root = start_tree.root_vertex_start\n        goal_root = goal_tree.root_vertex_start\n\n        start_root.cost = 0.0\n        goal_root.cost = 0.0\n\n        self._found_path = False\n        self._best_cost = float('inf')\n        self._best_start_vertex = None\n        self._best_goal_vertex = None\n\n        for iteration in range(max_iterations):\n            if time.perf_counter() - self._start_time > max_time_sec:\n                # timeout -> fail gracefully\n                break\n\n            # Setup informed sampling ellipsoids if path found\n            informed_start = None\n            informed_goal = None\n            if self._found_path and self._best_cost < float('inf'):\n                c_min = torch.norm(start_root.position.to_tensor() - goal_root.position.to_tensor()).item()\n                c_best = self._best_cost\n                center_start = Point((start_root.position.x + goal_root.position.x) / 2,\n                                     (start_root.position.y + goal_root.position.y) / 2)\n                informed_start = (center_start, c_best, c_min)\n                informed_goal = (center_start, c_best, c_min)\n\n            # Alternate tree growth: odd iteration grow start tree, even grow goal tree\n            growing_start_tree = (iteration % 2 == 0)\n            graph = start_tree if growing_start_tree else goal_tree\n            other_graph = goal_tree if growing_start_tree else start_tree\n            root_vertex = graph.root_vertex_start\n\n            q_sample = self._get_random_sample(informed_ball_start=informed_start, informed_ball_goal=informed_goal)\n            q_near = self._get_nearest_vertex(graph, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            if not q_new:\n                continue\n\n            if not self._line_collision_free_lazy(q_near.position, q_new.position):\n                continue\n\n            dist = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = q_near.cost + dist\n\n            card_V = max(1, graph.size)\n            log_card_V = torch.log(torch.tensor(float(card_V) + 1e-8))\n            radius = min(self._lambda_rrt_star * ((log_card_V / card_V) ** (1.0 / self._dimension)), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(graph, q_new.position, radius)\n\n            # Choose parent with minimum cost + collision free\n            q_min = q_near\n            c_min_vertex = q_near.cost\n            for q_near_candidate in Q_near:\n                if q_near_candidate == q_new:\n                    continue\n                dist_candidate = torch.norm(q_near_candidate.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist_candidate > self._max_dist:\n                    continue\n                cost_candidate = q_near_candidate.cost + dist_candidate\n                if cost_candidate < c_min_vertex:\n                    if self._line_collision_free_lazy(q_near_candidate.position, q_new.position):\n                        q_min = q_near_candidate\n                        c_min_vertex = cost_candidate\n            q_new.cost = c_min_vertex\n            graph.add_edge(q_min, q_new)\n            self._rewire(graph, q_new, Q_near)\n\n            # Try to connect the other tree's nearest vertex to q_new\n            q_near_other = self._get_nearest_vertex(other_graph, q_new.position)\n\n            connection = self._connect_trees(q_new, q_near_other)\n            if connection is not None:\n                (start_v, goal_v, total_cost) = connection\n                if total_cost < self._best_cost:\n                    self._best_cost = total_cost\n                    if growing_start_tree:\n                        self._best_start_vertex = start_v\n                        self._best_goal_vertex = goal_v\n                    else:\n                        self._best_start_vertex = goal_v\n                        self._best_goal_vertex = start_v\n                    self._found_path = True\n\n            self.key_frame()\n\n        if self._found_path and self._best_start_vertex and self._best_goal_vertex:\n            path_vertices = self._extract_bidirectional_path(self._best_start_vertex, self._best_goal_vertex)\n            smoothed_path = self._smooth_path(path_vertices)\n            for vertex in smoothed_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # fail silently\n            pass",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 233, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 210, in __run_simulation\n    sim: Simulator = Simulator(Services(config))\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 40, in __init__\n    self.__setup(config)\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 68, in __setup\n    self.__algorithm_runner.reset_algorithm()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\algorithm_runner.py\", line 59, in reset_algorithm\n    self.__algorithm = self.__algorithm_type(self._services, testing, *self.__algorithm_parameters[0],\n  File \"<string>\", line 59, in __init__\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\classic\\sample_based\\core\\sample_based_algorithm.py\", line 11, in _init_displays\n    self.__map_displays = [GraphMapDisplay(self._services, self._graph)]\nAttributeError: 'PathPlanning' object has no attribute '_graph'\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an improved sampling-based planner integrating RRT*-style rewiring, \n    adaptive informed sampling, bidirectional search, and path smoothing. \n    \n    Key improvements:\n    1. Bidirectional tree growth from start and goal, reducing convergence time and improving success rate.\n    2. Adaptive informed sampling ellipsoids from both directions after initial connection, focusing search.\n    3. RRT* rewiring in both trees for path quality improvement.\n    4. Lazy collision checking with early abandon for efficiency.\n    5. Dynamic radius for rewiring based on vertex count and dimensionality.\n    6. After connection, smooth shortcutting path to improve path smoothness and length.\n    7. Strict 10 seconds timeout to fail gracefully.\n\n    The algorithm grows two forests (from start and goal), tries to connect them efficiently, extracts best path, smooths it,\n    and moves the agent along the final planned trajectory.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._graph = self._graph_start  # Fix: define _graph to avoid AttributeError in _init_displays\n        self._max_dist = 12.0\n        self._max_radius = 40.0\n        self._lambda_rrt_star = 40.0\n        self._dimension = self._get_grid().size.n_dim\n        self._start_time = 0\n        self._samples_taken = 0\n        self._found_path = False\n        self._best_start_vertex: Vertex = None\n        self._best_goal_vertex: Vertex = None\n        self._best_cost = float('inf')\n        self._init_displays()\n\n    def _get_random_sample(self, informed_ball_start: tuple = None, informed_ball_goal: tuple = None) -> Point:\n        \"\"\"\n        Samples a point either uniformly or inside combined ellipsoids from start and goal informed sampling.\n        If informed balls for both trees are provided, probabilistically sample from one or uniform.\n        Otherwise uniform sampling.\n        \"\"\"\n        grid_size = self._get_grid().size\n        # Simple logic: 40% from start ellipsoid, 40% from goal ellipsoid, 20% uniform if informed balls exist\n        import random\n        prob = random.random()\n\n        def sample_ellipsoid(center: Point, c_best: float, c_min: float) -> Point:\n            if grid_size.n_dim != 2:\n                # fallback to uniform\n                return None\n            a1 = c_best / 2\n            try:\n                a2 = (c_best**2 - c_min**2)**0.5 / 2\n            except Exception:\n                return None\n            for _ in range(200):\n                rx = torch.FloatTensor(1).uniform_(-1,1).item()\n                ry = torch.FloatTensor(1).uniform_(-1,1).item()\n                norm = (rx**2 + ry**2)**0.5\n                if norm > 1e-5:\n                    break\n            else:\n                return None\n            rx /= norm\n            ry /= norm\n            r = torch.FloatTensor(1).uniform_(0,1).item() ** (1 / 2)\n            x = r * a1 * rx\n            y = r * a2 * ry\n            # Rotation: along vector start -> goal\n            start = self._graph_start.root_vertex_start.position\n            goal = self._graph_start.root_vertex_goal.position\n            delta = torch.tensor([goal.x - start.x, goal.y - start.y])\n            angle = torch.atan2(delta[1], delta[0]).item()\n            cos_ang = torch.cos(torch.tensor(angle))\n            sin_ang = torch.sin(torch.tensor(angle))\n            rot_x = cos_ang * x - sin_ang * y\n            rot_y = sin_ang * x + cos_ang * y\n            sample_x = int(round(center.x + rot_x))\n            sample_y = int(round(center.y + rot_y))\n            sample_x = max(0, min(sample_x, grid_size[0] - 1))\n            sample_y = max(0, min(sample_y, grid_size[1] - 1))\n            sample = Point(sample_x, sample_y)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            return None\n\n        if informed_ball_start and informed_ball_goal:\n            if prob < 0.4:\n                s = sample_ellipsoid(*informed_ball_start)\n                if s is not None:\n                    return s\n            elif prob < 0.8:\n                s = sample_ellipsoid(*informed_ball_goal)\n                if s is not None:\n                    return s\n            # fallback uniform\n        elif informed_ball_start:\n            s = sample_ellipsoid(*informed_ball_start)\n            if s is not None:\n                return s\n        elif informed_ball_goal:\n            s = sample_ellipsoid(*informed_ball_goal)\n            if s is not None:\n                return s\n\n        # uniform sampling fallback\n        attempts = 0\n        while attempts < 500:\n            rand_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(grid_size.n_dim)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n        # As a last resort fallback to agent's position to prevent error\n        return self._get_grid().agent.position\n\n    def _get_nearest_vertex(self, graph: Forest, q_sample: Point) -> Vertex:\n        return graph.get_nearest_vertex(graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, graph: Forest, position: Point, radius: float) -> list:\n        return graph.get_vertices_within_radius(graph.root_vertices, position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec)\n        if length < 1e-6:\n            return None\n        if length <= self._max_dist:\n            new_vertex_pos = q_sample\n        else:\n            dir_normalized = dir_vec / length\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_vertex_pos = Point.from_tensor(new_pos_tensor)\n        if not self._get_grid().is_agent_valid_pos(new_vertex_pos):\n            return None\n        return Vertex(new_vertex_pos)\n\n    def _line_collision_free_lazy(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        for pt in line_seq:\n            if not self._get_grid().is_agent_valid_pos(pt):\n                return False\n        return True\n\n    def _rewire(self, graph: Forest, q_new: Vertex, Q_near: list) -> None:\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n            if dist > self._max_dist:\n                continue\n            new_cost = q_new.cost + dist\n            if new_cost < q_near.cost:\n                if self._line_collision_free_lazy(q_new.position, q_near.position):\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    graph.add_edge(q_new, q_near)\n\n    def _connect_trees(self, v_start: Vertex, v_goal: Vertex) -> (Vertex, Vertex, float):\n        \"\"\"\n        Attempts to connect two vertices from start and goal trees directly if collision-free.\n        Returns tuple (start_vertex, goal_vertex, cost) if successful; else None.\n        \"\"\"\n        if not self._line_collision_free_lazy(v_start.position, v_goal.position):\n            return None\n        dist = torch.norm(v_start.position.to_tensor() - v_goal.position.to_tensor()).item()\n        total_cost = v_start.cost + dist + v_goal.cost\n        return (v_start, v_goal, total_cost)\n\n    def _extract_bidirectional_path(self, start_vertex: Vertex, goal_vertex: Vertex) -> list:\n        \"\"\"\n        Extract path from start vertex in start tree and from goal vertex in goal tree,\n        concatenating paths at meeting point.\n        \"\"\"\n        path_start = []\n        cur = start_vertex\n        while cur is not None:\n            path_start.append(cur)\n            if not cur.parents:\n                break\n            # Choose parent with minimal cost (should usually be one)\n            min_cost = float('inf')\n            min_p = None\n            for p in cur.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_p = p\n            cur = min_p\n        path_start.reverse()\n\n        path_goal = []\n        cur = goal_vertex\n        while cur is not None:\n            path_goal.append(cur)\n            if not cur.parents:\n                break\n            min_cost = float('inf')\n            min_p = None\n            for p in cur.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_p = p\n            cur = min_p\n\n        # Reverse path_goal for correct direction\n        path_goal.reverse()\n        # Remove duplicate meeting vertex at join\n        if len(path_goal) > 0 and len(path_start) > 0 and path_start[-1].position == path_goal[0].position:\n            path_goal = path_goal[1:]\n\n        return path_start + path_goal\n\n    def _smooth_path(self, path: list) -> list:\n        \"\"\"\n        Shortcut smoothing removing unnecessary vertices by connecting farther apart vertices directly.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_collision_free_lazy(path[i].position, path[j].position):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.perf_counter()\n        max_time_sec = 10.0\n        max_iterations = 15000\n\n        start_tree = self._graph_start\n        goal_tree = self._graph_goal\n\n        start_root = start_tree.root_vertex_start\n        goal_root = goal_tree.root_vertex_start\n\n        start_root.cost = 0.0\n        goal_root.cost = 0.0\n\n        self._found_path = False\n        self._best_cost = float('inf')\n        self._best_start_vertex = None\n        self._best_goal_vertex = None\n\n        for iteration in range(max_iterations):\n            if time.perf_counter() - self._start_time > max_time_sec:\n                # timeout -> fail gracefully\n                break\n\n            # Setup informed sampling ellipsoids if path found\n            informed_start = None\n            informed_goal = None\n            if self._found_path and self._best_cost < float('inf'):\n                c_min = torch.norm(start_root.position.to_tensor() - goal_root.position.to_tensor()).item()\n                c_best = self._best_cost\n                center_start = Point((start_root.position.x + goal_root.position.x) / 2,\n                                     (start_root.position.y + goal_root.position.y) / 2)\n                informed_start = (center_start, c_best, c_min)\n                informed_goal = (center_start, c_best, c_min)\n\n            # Alternate tree growth: odd iteration grow start tree, even grow goal tree\n            growing_start_tree = (iteration % 2 == 0)\n            graph = start_tree if growing_start_tree else goal_tree\n            other_graph = goal_tree if growing_start_tree else start_tree\n            root_vertex = graph.root_vertex_start\n\n            q_sample = self._get_random_sample(informed_ball_start=informed_start, informed_ball_goal=informed_goal)\n            q_near = self._get_nearest_vertex(graph, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            if not q_new:\n                continue\n\n            if not self._line_collision_free_lazy(q_near.position, q_new.position):\n                continue\n\n            dist = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = q_near.cost + dist\n\n            card_V = max(1, graph.size)\n            log_card_V = torch.log(torch.tensor(float(card_V) + 1e-8))\n            radius = min(self._lambda_rrt_star * ((log_card_V / card_V) ** (1.0 / self._dimension)), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(graph, q_new.position, radius)\n\n            # Choose parent with minimum cost + collision free\n            q_min = q_near\n            c_min_vertex = q_near.cost\n            for q_near_candidate in Q_near:\n                if q_near_candidate == q_new:\n                    continue\n                dist_candidate = torch.norm(q_near_candidate.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist_candidate > self._max_dist:\n                    continue\n                cost_candidate = q_near_candidate.cost + dist_candidate\n                if cost_candidate < c_min_vertex:\n                    if self._line_collision_free_lazy(q_near_candidate.position, q_new.position):\n                        q_min = q_near_candidate\n                        c_min_vertex = cost_candidate\n            q_new.cost = c_min_vertex\n            graph.add_edge(q_min, q_new)\n            self._rewire(graph, q_new, Q_near)\n\n            # Try to connect the other tree's nearest vertex to q_new\n            q_near_other = self._get_nearest_vertex(other_graph, q_new.position)\n\n            connection = self._connect_trees(q_new, q_near_other)\n            if connection is not None:\n                (start_v, goal_v, total_cost) = connection\n                if total_cost < self._best_cost:\n                    self._best_cost = total_cost\n                    if growing_start_tree:\n                        self._best_start_vertex = start_v\n                        self._best_goal_vertex = goal_v\n                    else:\n                        self._best_start_vertex = goal_v\n                        self._best_goal_vertex = start_v\n                    self._found_path = True\n\n            self.key_frame()\n\n        if self._found_path and self._best_start_vertex and self._best_goal_vertex:\n            path_vertices = self._extract_bidirectional_path(self._best_start_vertex, self._best_goal_vertex)\n            smoothed_path = self._smooth_path(path_vertices)\n            for vertex in smoothed_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # fail silently\n            pass",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 233, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 214, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 303, in _find_path_internal\n  File \"<string>\", line 118, in _get_random_sample\n  File \"<string>\", line 103, in sample_ellipsoid\nTypeError: type Tensor doesn't define __round__ method\n"
     }
}
{
     "operator": "e1",
     "algorithm": "This algorithm is an improved sampling-based planner integrating RRT*-style rewiring, \n    adaptive informed sampling, bidirectional search, and path smoothing. \n    \n    Key improvements:\n    1. Bidirectional tree growth from start and goal, reducing convergence time and improving success rate.\n    2. Adaptive informed sampling ellipsoids from both directions after initial connection, focusing search.\n    3. RRT* rewiring in both trees for path quality improvement.\n    4. Lazy collision checking with early abandon for efficiency.\n    5. Dynamic radius for rewiring based on vertex count and dimensionality.\n    6. After connection, smooth shortcutting path to improve path smoothness and length.\n    7. Strict 10 seconds timeout to fail gracefully.\n\n    The algorithm grows two forests (from start and goal), tries to connect them efficiently, extracts best path, smooths it,\n    and moves the agent along the final planned trajectory.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._graph = self._graph_start  # Fix: define _graph to avoid AttributeError in _init_displays\n        self._max_dist = 12.0\n        self._max_radius = 40.0\n        self._lambda_rrt_star = 40.0\n        self._dimension = self._get_grid().size.n_dim\n        self._start_time = 0\n        self._samples_taken = 0\n        self._found_path = False\n        self._best_start_vertex: Vertex = None\n        self._best_goal_vertex: Vertex = None\n        self._best_cost = float('inf')\n        self._init_displays()\n\n    def _get_random_sample(self, informed_ball_start: tuple = None, informed_ball_goal: tuple = None) -> Point:\n        \"\"\"\n        Samples a point either uniformly or inside combined ellipsoids from start and goal informed sampling.\n        If informed balls for both trees are provided, probabilistically sample from one or uniform.\n        Otherwise uniform sampling.\n        \"\"\"\n        grid_size = self._get_grid().size\n        # Simple logic: 40% from start ellipsoid, 40% from goal ellipsoid, 20% uniform if informed balls exist\n        import random\n        prob = random.random()\n\n        def sample_ellipsoid(center: Point, c_best: float, c_min: float) -> Point:\n            if grid_size.n_dim != 2:\n                # fallback to uniform\n                return None\n            a1 = c_best / 2\n            try:\n                a2 = (c_best**2 - c_min**2)**0.5 / 2\n            except Exception:\n                return None\n            for _ in range(200):\n                rx = torch.FloatTensor(1).uniform_(-1,1).item()\n                ry = torch.FloatTensor(1).uniform_(-1,1).item()\n                norm = (rx**2 + ry**2)**0.5\n                if norm > 1e-5:\n                    break\n            else:\n                return None\n            rx /= norm\n            ry /= norm\n            r = torch.FloatTensor(1).uniform_(0,1).item() ** (1 / 2)\n            x = r * a1 * rx\n            y = r * a2 * ry\n            # Rotation: along vector start -> goal\n            start = self._graph_start.root_vertex_start.position\n            goal = self._graph_start.root_vertex_goal.position\n            delta = torch.tensor([goal.x - start.x, goal.y - start.y])\n            angle = torch.atan2(delta[1], delta[0]).item()\n            cos_ang = torch.cos(torch.tensor(angle))\n            sin_ang = torch.sin(torch.tensor(angle))\n            rot_x = cos_ang * x - sin_ang * y\n            rot_y = sin_ang * x + cos_ang * y\n            sample_x = int(round(float(center.x) + rot_x))\n            sample_y = int(round(float(center.y) + rot_y))\n            sample_x = max(0, min(sample_x, grid_size[0] - 1))\n            sample_y = max(0, min(sample_y, grid_size[1] - 1))\n            sample = Point(sample_x, sample_y)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            return None\n\n        if informed_ball_start and informed_ball_goal:\n            if prob < 0.4:\n                s = sample_ellipsoid(*informed_ball_start)\n                if s is not None:\n                    return s\n            elif prob < 0.8:\n                s = sample_ellipsoid(*informed_ball_goal)\n                if s is not None:\n                    return s\n            # fallback uniform\n        elif informed_ball_start:\n            s = sample_ellipsoid(*informed_ball_start)\n            if s is not None:\n                return s\n        elif informed_ball_goal:\n            s = sample_ellipsoid(*informed_ball_goal)\n            if s is not None:\n                return s\n\n        # uniform sampling fallback\n        attempts = 0\n        while attempts < 500:\n            rand_coords = [torch.randint(0, grid_size[i], (1,)).item() for i in range(grid_size.n_dim)]\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n        # As a last resort fallback to agent's position to prevent error\n        return self._get_grid().agent.position\n\n    def _get_nearest_vertex(self, graph: Forest, q_sample: Point) -> Vertex:\n        return graph.get_nearest_vertex(graph.root_vertices, q_sample)\n\n    def _get_vertices_within_radius(self, graph: Forest, position: Point, radius: float) -> list:\n        return graph.get_vertices_within_radius(graph.root_vertices, position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec)\n        if length < 1e-6:\n            return None\n        if length <= self._max_dist:\n            new_vertex_pos = q_sample\n        else:\n            dir_normalized = dir_vec / length\n            new_pos_tensor = q_near.position.to_tensor() + dir_normalized * self._max_dist\n            new_vertex_pos = Point.from_tensor(new_pos_tensor)\n        if not self._get_grid().is_agent_valid_pos(new_vertex_pos):\n            return None\n        return Vertex(new_vertex_pos)\n\n    def _line_collision_free_lazy(self, frm: Point, to: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        for pt in line_seq:\n            if not self._get_grid().is_agent_valid_pos(pt):\n                return False\n        return True\n\n    def _rewire(self, graph: Forest, q_new: Vertex, Q_near: list) -> None:\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n            if dist > self._max_dist:\n                continue\n            new_cost = q_new.cost + dist\n            if new_cost < q_near.cost:\n                if self._line_collision_free_lazy(q_new.position, q_near.position):\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    graph.add_edge(q_new, q_near)\n\n    def _connect_trees(self, v_start: Vertex, v_goal: Vertex) -> (Vertex, Vertex, float):\n        \"\"\"\n        Attempts to connect two vertices from start and goal trees directly if collision-free.\n        Returns tuple (start_vertex, goal_vertex, cost) if successful; else None.\n        \"\"\"\n        if not self._line_collision_free_lazy(v_start.position, v_goal.position):\n            return None\n        dist = torch.norm(v_start.position.to_tensor() - v_goal.position.to_tensor()).item()\n        total_cost = v_start.cost + dist + v_goal.cost\n        return (v_start, v_goal, total_cost)\n\n    def _extract_bidirectional_path(self, start_vertex: Vertex, goal_vertex: Vertex) -> list:\n        \"\"\"\n        Extract path from start vertex in start tree and from goal vertex in goal tree,\n        concatenating paths at meeting point.\n        \"\"\"\n        path_start = []\n        cur = start_vertex\n        while cur is not None:\n            path_start.append(cur)\n            if not cur.parents:\n                break\n            # Choose parent with minimal cost (should usually be one)\n            min_cost = float('inf')\n            min_p = None\n            for p in cur.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_p = p\n            cur = min_p\n        path_start.reverse()\n\n        path_goal = []\n        cur = goal_vertex\n        while cur is not None:\n            path_goal.append(cur)\n            if not cur.parents:\n                break\n            min_cost = float('inf')\n            min_p = None\n            for p in cur.parents:\n                if p.cost is not None and p.cost < min_cost:\n                    min_cost = p.cost\n                    min_p = p\n            cur = min_p\n\n        # Reverse path_goal for correct direction\n        path_goal.reverse()\n        # Remove duplicate meeting vertex at join\n        if len(path_goal) > 0 and len(path_start) > 0 and path_start[-1].position == path_goal[0].position:\n            path_goal = path_goal[1:]\n\n        return path_start + path_goal\n\n    def _smooth_path(self, path: list) -> list:\n        \"\"\"\n        Shortcut smoothing removing unnecessary vertices by connecting farther apart vertices directly.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_collision_free_lazy(path[i].position, path[j].position):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.perf_counter()\n        max_time_sec = 10.0\n        max_iterations = 15000\n\n        start_tree = self._graph_start\n        goal_tree = self._graph_goal\n\n        start_root = start_tree.root_vertex_start\n        goal_root = goal_tree.root_vertex_start\n\n        start_root.cost = 0.0\n        goal_root.cost = 0.0\n\n        self._found_path = False\n        self._best_cost = float('inf')\n        self._best_start_vertex = None\n        self._best_goal_vertex = None\n\n        for iteration in range(max_iterations):\n            if time.perf_counter() - self._start_time > max_time_sec:\n                # timeout -> fail gracefully\n                break\n\n            # Setup informed sampling ellipsoids if path found\n            informed_start = None\n            informed_goal = None\n            if self._found_path and self._best_cost < float('inf'):\n                c_min = torch.norm(start_root.position.to_tensor() - goal_root.position.to_tensor()).item()\n                c_best = self._best_cost\n                center_start = Point((start_root.position.x + goal_root.position.x) / 2,\n                                     (start_root.position.y + goal_root.position.y) / 2)\n                informed_start = (center_start, c_best, c_min)\n                informed_goal = (center_start, c_best, c_min)\n\n            # Alternate tree growth: odd iteration grow start tree, even grow goal tree\n            growing_start_tree = (iteration % 2 == 0)\n            graph = start_tree if growing_start_tree else goal_tree\n            other_graph = goal_tree if growing_start_tree else start_tree\n            root_vertex = graph.root_vertex_start\n\n            q_sample = self._get_random_sample(informed_ball_start=informed_start, informed_ball_goal=informed_goal)\n            q_near = self._get_nearest_vertex(graph, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample)\n            if not q_new:\n                continue\n\n            if not self._line_collision_free_lazy(q_near.position, q_new.position):\n                continue\n\n            dist = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = q_near.cost + dist\n\n            card_V = max(1, graph.size)\n            log_card_V = torch.log(torch.tensor(float(card_V) + 1e-8))\n            radius = min(self._lambda_rrt_star * ((log_card_V / card_V) ** (1.0 / self._dimension)), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(graph, q_new.position, radius)\n\n            # Choose parent with minimum cost + collision free\n            q_min = q_near\n            c_min_vertex = q_near.cost\n            for q_near_candidate in Q_near:\n                if q_near_candidate == q_new:\n                    continue\n                dist_candidate = torch.norm(q_near_candidate.position.to_tensor() - q_new.position.to_tensor()).item()\n                if dist_candidate > self._max_dist:\n                    continue\n                cost_candidate = q_near_candidate.cost + dist_candidate\n                if cost_candidate < c_min_vertex:\n                    if self._line_collision_free_lazy(q_near_candidate.position, q_new.position):\n                        q_min = q_near_candidate\n                        c_min_vertex = cost_candidate\n            q_new.cost = c_min_vertex\n            graph.add_edge(q_min, q_new)\n            self._rewire(graph, q_new, Q_near)\n\n            # Try to connect the other tree's nearest vertex to q_new\n            q_near_other = self._get_nearest_vertex(other_graph, q_new.position)\n\n            connection = self._connect_trees(q_new, q_near_other)\n            if connection is not None:\n                (start_v, goal_v, total_cost) = connection\n                if total_cost < self._best_cost:\n                    self._best_cost = total_cost\n                    if growing_start_tree:\n                        self._best_start_vertex = start_v\n                        self._best_goal_vertex = goal_v\n                    else:\n                        self._best_start_vertex = goal_v\n                        self._best_goal_vertex = start_v\n                    self._found_path = True\n\n            self.key_frame()\n\n        if self._found_path and self._best_start_vertex and self._best_goal_vertex:\n            path_vertices = self._extract_bidirectional_path(self._best_start_vertex, self._best_goal_vertex)\n            smoothed_path = self._smooth_path(path_vertices)\n            for vertex in smoothed_path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # fail silently\n            pass",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 233, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 214, in __run_simulation\n    resu = sim.start().get_results()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 59, in start\n    return self.__start_without_graphics()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\simulator.py\", line 95, in __start_without_graphics\n    self.__services.algorithm.instance.find_path()\n  File \"C:\\Workspace\\PathBench\\src\\algorithms\\algorithm.py\", line 65, in find_path\n    self._find_path_internal()\n  File \"<string>\", line 303, in _find_path_internal\n  File \"<string>\", line 114, in _get_random_sample\n  File \"<string>\", line 103, in sample_ellipsoid\nTypeError: type Tensor doesn't define __round__ method\n"
     }
}
{
     "operator": "e1",
     "algorithm": "Improved Path Planning Algorithm based on an enhanced RRT* concept with informed sampling and rewiring:\n    - Uses goal-biased sampling to focus exploration towards goal, improving planning efficiency.\n    - Applies rewiring to locally optimize path connections, improving path quality and smoothness.\n    - Uses adaptive neighborhood radius for rewiring to balance exploration vs. exploitation.\n    - Employs early termination if path to goal found, minimizing search time.\n    - Integrates timeout check ensuring search fails if exceeding 10 seconds for robustness.\n    - Uses precise collision checking via line validation for robustness.\n    - Maintains a forest graph structure for flexible path representations and fast nearest neighbor queries.\n    - Overall, this approach improves success rate, reduces path length, and smooths the resulting trajectory.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = Forest(\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n        )\n        self._graph.edges_removable = True\n        self._max_extend_dist = 12.0\n        self._rewire_radius_factor = 30.0  # factor to scale radius adaptively\n        self._goal_sample_rate = 0.2  # probability to sample goal directly\n        self._timeout_seconds = 10.0\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling with probability self._goal_sample_rate\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        dim = self._get_grid().size.n_dim\n        while True:\n            rand_coords = np.random.randint(0, self._get_grid().size, dim)\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_v: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        dir_vec = to_point.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            new_pos = to_point\n        else:\n            dir_norm = dir_vec / dist\n            new_pos_tensor = from_v.position.to_tensor() + max_dist * dir_norm\n            new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _collision_free(self, from_point: Point, to_point: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(from_point, to_point)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _near_vertices(self, new_vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], new_vertex.position, radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], new_vertex: Vertex) -> Optional[Vertex]:\n        min_cost = float('inf')\n        best_parent = None\n        for near_v in near_vertices:\n            if self._collision_free(near_v.position, new_vertex.position):\n                cost = near_v.cost + self._get_grid().get_movement_cost(near_v.position, new_vertex.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = near_v\n        if best_parent is not None:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> None:\n        for near_v in near_vertices:\n            if near_v == new_vertex:\n                continue\n            if self._collision_free(new_vertex.position, near_v.position):\n                new_cost = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, near_v.position)\n                if new_cost < near_v.cost:\n                    # Remove old edge(s) leading to near_v and add new edge from new_vertex\n                    for p in list(near_v.parents):\n                        self._graph.remove_edge(p, near_v)\n                    self._graph.add_edge(new_vertex, near_v)\n                    near_v.cost = new_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        # Extract path backward from goal to start via parents\n        path: List[Vertex] = [goal_vertex]\n        current = goal_vertex\n        while current.position != self._graph.root_vertex_start.position:\n            if not current.parents:\n                # No path to start\n                break\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Animate path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n\n        start_time = time()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        max_iter = 20000\n        found_goal = False\n\n        for iter_count in range(max_iter):\n            if time() - start_time > self._timeout_seconds:\n                # Treat as failed search due to timeout\n                break\n\n            q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._steer(q_near, q_sample, self._max_extend_dist)\n\n            if not self._collision_free(q_near.position, q_new.position):\n                continue\n\n            # Adaptive radius for rewiring (RRT* style): gamma * (log(n)/n)^(1/d)\n            n_vertices = self._graph.size + 1\n            dim = self._get_grid().size.n_dim\n            gamma = self._rewire_radius_factor\n            radius = gamma * (np.log(n_vertices) / n_vertices) ** (1.0 / dim)\n            radius = max(radius, self._max_extend_dist)\n\n            near_vertices = self._near_vertices(q_new, radius)\n            parent = self._choose_parent(near_vertices, q_new)\n            if parent is None:\n                parent = q_near\n                q_new.cost = parent.cost + self._get_grid().get_movement_cost(parent.position, q_new.position)\n\n            self._graph.add_edge(parent, q_new)\n\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex explicitly and extract path\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                goal_vertex.cost = float('inf')\n                if self._collision_free(q_new.position, goal_vertex.position):\n                    cost_to_goal = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    found_goal = True\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()\n\n        if not found_goal:\n            # No path found within constraints and timeout\n            pass  # Could raise or log failure if needed",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 233, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 210, in __run_simulation\n    sim: Simulator = Simulator(Services(config))\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 40, in __init__\n    self.__setup(config)\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 68, in __setup\n    self.__algorithm_runner.reset_algorithm()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\algorithm_runner.py\", line 59, in reset_algorithm\n    self.__algorithm = self.__algorithm_type(self._services, testing, *self.__algorithm_parameters[0],\n  File \"<string>\", line 46, in __init__\nTypeError: __init__() missing 1 required positional argument: 'root_vertices'\n"
     }
}
{
     "operator": "e1",
     "algorithm": "Improved Path Planning Algorithm based on an enhanced RRT* concept with informed sampling and rewiring:\n    - Uses goal-biased sampling to focus exploration towards goal, improving planning efficiency.\n    - Applies rewiring to locally optimize path connections, improving path quality and smoothness.\n    - Uses adaptive neighborhood radius for rewiring to balance exploration vs. exploitation.\n    - Employs early termination if path to goal found, minimizing search time.\n    - Integrates timeout check ensuring search fails if exceeding 10 seconds for robustness.\n    - Uses precise collision checking via line validation for robustness.\n    - Maintains a forest graph structure for flexible path representations and fast nearest neighbor queries.\n    - Overall, this approach improves success rate, reduces path length, and smooths the resulting trajectory.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = Forest(\n            root_vertices=[\n                Vertex(self._get_grid().agent.position),\n                Vertex(self._get_grid().goal.position),\n            ]\n        )\n        self._graph.edges_removable = True\n        self._max_extend_dist = 12.0\n        self._rewire_radius_factor = 30.0  # factor to scale radius adaptively\n        self._goal_sample_rate = 0.2  # probability to sample goal directly\n        self._timeout_seconds = 10.0\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling with probability self._goal_sample_rate\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        dim = self._get_grid().size.n_dim\n        while True:\n            rand_coords = np.random.randint(0, self._get_grid().size, dim)\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_v: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        dir_vec = to_point.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            new_pos = to_point\n        else:\n            dir_norm = dir_vec / dist\n            new_pos_tensor = from_v.position.to_tensor() + max_dist * dir_norm\n            new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _collision_free(self, from_point: Point, to_point: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(from_point, to_point)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _near_vertices(self, new_vertex: Vertex, radius: float) -> list[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertices[0]], new_vertex.position, radius)\n\n    def _choose_parent(self, near_vertices: list[Vertex], new_vertex: Vertex) -> Vertex | None:\n        min_cost = float(\"inf\")\n        best_parent = None\n        for near_v in near_vertices:\n            if self._collision_free(near_v.position, new_vertex.position):\n                cost = near_v.cost + self._get_grid().get_movement_cost(near_v.position, new_vertex.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = near_v\n        if best_parent is not None:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: list[Vertex]) -> None:\n        for near_v in near_vertices:\n            if near_v == new_vertex:\n                continue\n            if self._collision_free(new_vertex.position, near_v.position):\n                new_cost = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, near_v.position)\n                if new_cost < near_v.cost:\n                    # Remove old edge(s) leading to near_v and add new edge from new_vertex\n                    for p in list(near_v.parents):\n                        self._graph.remove_edge(p, near_v)\n                    self._graph.add_edge(new_vertex, near_v)\n                    near_v.cost = new_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        # Extract path backward from goal to start via parents\n        path: list[Vertex] = [goal_vertex]\n        current = goal_vertex\n        while current.position != self._graph.root_vertices[0].position:\n            if not current.parents:\n                # No path to start\n                break\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Animate path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n\n        start_time = time()\n        start_vertex = self._graph.root_vertices[0]\n        start_vertex.cost = 0.0\n\n        max_iter = 20000\n        found_goal = False\n\n        for iter_count in range(max_iter):\n            if time() - start_time > self._timeout_seconds:\n                # Treat as failed search due to timeout\n                break\n\n            q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._steer(q_near, q_sample, self._max_extend_dist)\n\n            if not self._collision_free(q_near.position, q_new.position):\n                continue\n\n            # Adaptive radius for rewiring (RRT* style): gamma * (log(n)/n)^(1/d)\n            n_vertices = self._graph.size + 1\n            dim = self._get_grid().size.n_dim\n            gamma = self._rewire_radius_factor\n            radius = gamma * (np.log(n_vertices) / n_vertices) ** (1.0 / dim)\n            radius = max(radius, self._max_extend_dist)\n\n            near_vertices = self._near_vertices(q_new, radius)\n            parent = self._choose_parent(near_vertices, q_new)\n            if parent is None:\n                parent = q_near\n                q_new.cost = parent.cost + self._get_grid().get_movement_cost(parent.position, q_new.position)\n\n            self._graph.add_edge(parent, q_new)\n\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex explicitly and extract path\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                goal_vertex.cost = float(\"inf\")\n                if self._collision_free(q_new.position, goal_vertex.position):\n                    cost_to_goal = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    found_goal = True\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()\n\n        if not found_goal:\n            # No path found within constraints and timeout\n            pass  # Could raise or log failure if needed",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 269, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 84, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
{
     "operator": "e1",
     "algorithm": "Improved Path Planning Algorithm based on an enhanced RRT* concept with informed sampling and rewiring:\n    - Uses goal-biased sampling to focus exploration towards goal, improving planning efficiency.\n    - Applies rewiring to locally optimize path connections, improving path quality and smoothness.\n    - Uses adaptive neighborhood radius for rewiring to balance exploration vs. exploitation.\n    - Employs early termination if path to goal found, minimizing search time.\n    - Integrates timeout check ensuring search fails if exceeding 10 seconds for robustness.\n    - Uses precise collision checking via line validation for robustness.\n    - Maintains a forest graph structure for flexible path representations and fast nearest neighbor queries.\n    - Overall, this approach improves success rate, reduces path length, and smooths the resulting trajectory.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    _graph: Forest\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = Forest(\n            root_vertices=[\n                Vertex(self._get_grid().agent.position),\n                Vertex(self._get_grid().goal.position),\n            ]\n        )\n        self._graph.edges_removable = True\n        self._max_extend_dist = 12.0\n        self._rewire_radius_factor = 30.0  # factor to scale radius adaptively\n        self._goal_sample_rate = 0.2  # probability to sample goal directly\n        self._timeout_seconds = 10.0\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling with probability self._goal_sample_rate\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        dim = self._get_grid().size.n_dim\n        while True:\n            rand_coords = np.random.randint(0, self._get_grid().size, dim)\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_v: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        dir_vec = to_point.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            new_pos = to_point\n        else:\n            dir_norm = dir_vec / dist\n            new_pos_tensor = from_v.position.to_tensor() + max_dist * dir_norm\n            new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _collision_free(self, from_point: Point, to_point: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(from_point, to_point)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _near_vertices(self, new_vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertices[0]], new_vertex.position, radius)\n\n    def _choose_parent(self, near_vertices: List[Vertex], new_vertex: Vertex) -> Optional[Vertex]:\n        min_cost = float(\"inf\")\n        best_parent = None\n        for near_v in near_vertices:\n            if self._collision_free(near_v.position, new_vertex.position):\n                cost = near_v.cost + self._get_grid().get_movement_cost(near_v.position, new_vertex.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = near_v\n        if best_parent is not None:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: List[Vertex]) -> None:\n        for near_v in near_vertices:\n            if near_v == new_vertex:\n                continue\n            if self._collision_free(new_vertex.position, near_v.position):\n                new_cost = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, near_v.position)\n                if new_cost < near_v.cost:\n                    # Remove old edge(s) leading to near_v and add new edge from new_vertex\n                    for p in list(near_v.parents):\n                        self._graph.remove_edge(p, near_v)\n                    self._graph.add_edge(new_vertex, near_v)\n                    near_v.cost = new_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        # Extract path backward from goal to start via parents\n        path: List[Vertex] = [goal_vertex]\n        current = goal_vertex\n        while current.position != self._graph.root_vertices[0].position:\n            if not current.parents:\n                # No path to start\n                break\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Animate path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n\n        start_time = time()\n        start_vertex = self._graph.root_vertices[0]\n        start_vertex.cost = 0.0\n\n        max_iter = 20000\n        found_goal = False\n\n        for iter_count in range(max_iter):\n            if time() - start_time > self._timeout_seconds:\n                # Treat as failed search due to timeout\n                break\n\n            q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._steer(q_near, q_sample, self._max_extend_dist)\n\n            if not self._collision_free(q_near.position, q_new.position):\n                continue\n\n            # Adaptive radius for rewiring (RRT* style): gamma * (log(n)/n)^(1/d)\n            n_vertices = self._graph.size + 1\n            dim = self._get_grid().size.n_dim\n            gamma = self._rewire_radius_factor\n            radius = gamma * (np.log(n_vertices) / n_vertices) ** (1.0 / dim)\n            radius = max(radius, self._max_extend_dist)\n\n            near_vertices = self._near_vertices(q_new, radius)\n            parent = self._choose_parent(near_vertices, q_new)\n            if parent is None:\n                parent = q_near\n                q_new.cost = parent.cost + self._get_grid().get_movement_cost(parent.position, q_new.position)\n\n            self._graph.add_edge(parent, q_new)\n\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex explicitly and extract path\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                goal_vertex.cost = float(\"inf\")\n                if self._collision_free(q_new.position, goal_vertex.position):\n                    cost_to_goal = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    found_goal = True\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()\n\n        if not found_goal:\n            # No path found within constraints and timeout\n            pass  # Could raise or log failure if needed",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 274, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 233, in __evaluate_path\n    results.append(self.__run_simulation(grid, planning_module, testing_type, algo_params))\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 210, in __run_simulation\n    sim: Simulator = Simulator(Services(config))\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 40, in __init__\n    self.__setup(config)\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\services.py\", line 68, in __setup\n    self.__algorithm_runner.reset_algorithm()\n  File \"C:\\Workspace\\PathBench\\src\\simulator\\services\\algorithm_runner.py\", line 59, in reset_algorithm\n    self.__algorithm = self.__algorithm_type(self._services, testing, *self.__algorithm_parameters[0],\n  File \"<string>\", line 45, in __init__\nTypeError: __init__() missing 2 required positional arguments: 'start_pos' and 'goal_pos'\n"
     }
}
{
     "operator": "e1",
     "algorithm": "Improved Path Planning Algorithm based on an enhanced RRT* concept with informed sampling and rewiring:\n    - Uses goal-biased sampling to focus exploration towards goal, improving planning efficiency.\n    - Applies rewiring to locally optimize path connections, improving path quality and smoothness.\n    - Uses adaptive neighborhood radius for rewiring to balance exploration vs. exploitation.\n    - Employs early termination if path to goal found, minimizing search time.\n    - Integrates timeout check ensuring search fails if exceeding 10 seconds for robustness.\n    - Uses precise collision checking via line validation for robustness.\n    - Maintains a forest graph structure for flexible path representations and fast nearest neighbor queries.\n    - Overall, this approach improves success rate, reduces path length, and smooths the resulting trajectory.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    _graph: Forest\n\n    def __init__(self, services, testing=None, start_pos=None, goal_pos=None):\n        super().__init__(services, testing)\n        # Use provided start_pos and goal_pos if given, else fallback to grid agent/goal positions\n        start_position = start_pos if start_pos is not None else self._get_grid().agent.position\n        goal_position = goal_pos if goal_pos is not None else self._get_grid().goal.position\n\n        self._graph = Forest(\n            root_vertices=[\n                Vertex(start_position),\n                Vertex(goal_position),\n            ]\n        )\n        self._graph.edges_removable = True\n        self._max_extend_dist = 12.0\n        self._rewire_radius_factor = 30.0  # factor to scale radius adaptively\n        self._goal_sample_rate = 0.2  # probability to sample goal directly\n        self._timeout_seconds = 10.0\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling with probability self._goal_sample_rate\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        dim = self._get_grid().size.n_dim\n        while True:\n            rand_coords = np.random.randint(0, self._get_grid().size, dim)\n            sample = Point(*rand_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _steer(self, from_v: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        dir_vec = to_point.to_tensor() - from_v.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            new_pos = to_point\n        else:\n            dir_norm = dir_vec / dist\n            new_pos_tensor = from_v.position.to_tensor() + max_dist * dir_norm\n            new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def _collision_free(self, from_point: Point, to_point: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(from_point, to_point)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _near_vertices(self, new_vertex: Vertex, radius: float) -> list[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertices[0]], new_vertex.position, radius)\n\n    def _choose_parent(self, near_vertices: list[Vertex], new_vertex: Vertex) -> Vertex | None:\n        min_cost = float(\"inf\")\n        best_parent = None\n        for near_v in near_vertices:\n            if self._collision_free(near_v.position, new_vertex.position):\n                cost = near_v.cost + self._get_grid().get_movement_cost(near_v.position, new_vertex.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = near_v\n        if best_parent is not None:\n            new_vertex.cost = min_cost\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, near_vertices: list[Vertex]) -> None:\n        for near_v in near_vertices:\n            if near_v == new_vertex:\n                continue\n            if self._collision_free(new_vertex.position, near_v.position):\n                new_cost = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, near_v.position)\n                if new_cost < near_v.cost:\n                    # Remove old edge(s) leading to near_v and add new edge from new_vertex\n                    for p in list(near_v.parents):\n                        self._graph.remove_edge(p, near_v)\n                    self._graph.add_edge(new_vertex, near_v)\n                    near_v.cost = new_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        # Extract path backward from goal to start via parents\n        path: list[Vertex] = [goal_vertex]\n        current = goal_vertex\n        while current.position != self._graph.root_vertices[0].position:\n            if not current.parents:\n                # No path to start\n                break\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Animate path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n\n        start_time = time()\n        start_vertex = self._graph.root_vertices[0]\n        start_vertex.cost = 0.0\n\n        max_iter = 20000\n        found_goal = False\n\n        for iter_count in range(max_iter):\n            if time() - start_time > self._timeout_seconds:\n                # Treat as failed search due to timeout\n                break\n\n            q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._steer(q_near, q_sample, self._max_extend_dist)\n\n            if not self._collision_free(q_near.position, q_new.position):\n                continue\n\n            # Adaptive radius for rewiring (RRT* style): gamma * (log(n)/n)^(1/d)\n            n_vertices = self._graph.size + 1\n            dim = self._get_grid().size.n_dim\n            gamma = self._rewire_radius_factor\n            radius = gamma * (np.log(n_vertices) / n_vertices) ** (1.0 / dim)\n            radius = max(radius, self._max_extend_dist)\n\n            near_vertices = self._near_vertices(q_new, radius)\n            parent = self._choose_parent(near_vertices, q_new)\n            if parent is None:\n                parent = q_near\n                q_new.cost = parent.cost + self._get_grid().get_movement_cost(parent.position, q_new.position)\n\n            self._graph.add_edge(parent, q_new)\n\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex explicitly and extract path\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                goal_vertex.cost = float(\"inf\")\n                if self._collision_free(q_new.position, goal_vertex.position):\n                    cost_to_goal = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    found_goal = True\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()\n\n        if not found_goal:\n            # No path found within constraints and timeout\n            pass  # Could raise or log failure if needed",
     "objective": null,
     "other_inf": null,
     "results": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\path_planning\\run.py\", line 269, in evaluate\n    exec(self.import_string+code_string, planning_module.__dict__)\n  File \"<string>\", line 39, in <module>\n  File \"<string>\", line 88, in PathPlanning\nTypeError: 'type' object is not subscriptable\n"
     }
}
