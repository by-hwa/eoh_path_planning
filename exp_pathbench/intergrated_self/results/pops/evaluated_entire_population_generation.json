Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0211,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.22
}
{
     "algorithm": "This algorithm, named PathPlanning, implements a heuristic-guided, goal-biased adaptive sampling RRT*\n    variant combined with path smoothing and adaptive max step distance.\n\n    Features:\n    - Goal bias sampling with configurable probability to accelerate reaching goal region.\n    - Use of A*-like cost heuristic (sum of exact cost so far + Euclidean distance to goal) for vertex expansion and rewiring.\n    - Adaptive max_dist that shrinks as the tree grows denser to improve path quality and smoother connections.\n    - Iteration early stopping if goal reached or if total time > 10 seconds.\n    - Post-processing path shortcutting/smoothing to improve path quality.\n    - Dynamic rewiring radius dependent on tree size to better exploit local connectivity.\n\n    This algorithm balances exploration and exploitation with adaptive parameters,\n    aims to minimize total cost while ensuring robustness and efficiency.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_initial_dist = 15.0  # Initial maximum extension distance\n        self._max_iterations = 5000\n        self._goal_sampling_rate = 0.2  # 20% samples biased toward goal\n        self._rewiring_lambda = 40.0    # Parameter for radius calculation in rewiring\n        self._dimension = len(self._get_grid().size)\n        self._init_displays()\n\n    # Helper: Goal biased random sample\n    def _get_biased_sample(self) -> Point:\n        if torch.rand(1).item() < self._goal_sampling_rate:\n            # Sample exactly at goal to bias growth toward goal\n            return self._get_grid().goal.position\n        else:\n            # Uniform random valid sample in map\n            while True:\n                sample_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item()\n                                 for i in range(self._get_grid().size.n_dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    # Heuristic cost: cost_so_far + Euclidean to goal\n    def _heuristic_cost(self, vertex: Vertex) -> float:\n        dist_to_goal = self._get_grid().get_distance(vertex.position, self._get_grid().goal.position)\n        return vertex.cost + dist_to_goal\n\n    # Adaptive max step depending on current graph size to improve precision as tree grows\n    def _adaptive_max_dist(self) -> float:\n        size = max(1, self._graph.size)\n        max_dist = max(3.0, min(self._max_initial_dist, 30.0 * (1.0 / (size ** 0.3))))\n        return max_dist\n\n    # Rewiring radius based on tree size\n    def _rewiring_radius(self) -> float:\n        size = max(1, self._graph.size)\n        radius = min(50.0, self._rewiring_lambda * ((torch.log(torch.tensor(size).float()) / torch.tensor(size).float()) ** (1.0 / self._dimension)))\n        return radius.item()\n\n    # Extract and smooth path using simple shortcutting approach\n    def _extract_and_smooth_path(self, goal_parent: Vertex) -> None:\n        path = [self._graph.root_vertex_goal]\n        v = goal_parent\n        # Walk back to start\n        while v is not None and v.parents:\n            path.append(v)\n            v = next(iter(v.parents))\n        path.append(self._graph.root_vertex_start)\n        path.reverse()\n\n        # Shortcut smoothing: try to jump and skip intermediate nodes if line is collision free\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed_path.append(path[j])\n            i = j\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            # Key frame forced to ensure animation frame updated\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        max_dist = self._max_initial_dist\n\n        for iteration in range(self._max_iterations):\n            # Timeout check - stop if over 10 seconds\n            if (time.time() - start_time) > 10.0:\n                # Consider path not found, return without moving agent\n                return\n\n            q_sample: Point = self._get_biased_sample()\n\n            q_nearest: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive max dist shrinks with tree growth\n            max_dist = self._adaptive_max_dist()\n            dir_vec = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dir_norm = torch.norm(dir_vec)\n\n            if dir_norm == 0:\n                continue\n\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vec / dir_norm\n                q_new_tensor = q_nearest.position.to_tensor() + max_dist * dir_normalized\n                q_new_pos = Point.from_tensor(q_new_tensor)\n\n            # Check collision along line from q_nearest to q_new_pos\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new_pos)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            # Initialize cost with infinity temporarily\n            q_new.cost = float('inf')\n\n            # Radius for rewiring\n            radius = self._rewiring_radius()\n\n            neighbors: List[Vertex] = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            # Choose parent minimizing cost + distance to q_new\n            q_min = q_nearest\n            cost_min = q_nearest.cost + self._get_grid().get_distance(q_nearest.position, q_new.position)\n            for neighbor in neighbors:\n                line_check = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position))\n                cost_candidate = neighbor.cost + self._get_grid().get_distance(neighbor.position, q_new.position)\n                if line_check and cost_candidate < cost_min:\n                    q_min = neighbor\n                    cost_min = cost_candidate\n\n            q_new.cost = cost_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors for better paths\n            for neighbor in neighbors:\n                if neighbor == q_min:\n                    continue\n                line_check = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position))\n                cost_through_new = q_new.cost + self._get_grid().get_distance(q_new.position, neighbor.position)\n                if line_check and cost_through_new < neighbor.cost:\n                    # Patch parent edge\n                    old_parents = list(neighbor.parents)\n                    for p in old_parents:\n                        self._graph.remove_edge(p, neighbor)\n                    neighbor.cost = None\n                    neighbor.cost = cost_through_new\n                    self._graph.add_edge(q_new, neighbor)\n\n            # Goal check with goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect goal with q_new\n                goal_vertex = self._graph.root_vertex_goal\n                dist_to_goal = self._get_grid().get_distance(q_new.position, goal_vertex.position)\n                goal_vertex.cost = q_new.cost + dist_to_goal\n                self._graph.add_edge(q_new, goal_vertex)\n\n                self._extract_and_smooth_path(q_new)\n                return\n\n            self.key_frame()",
     "objective": 2110.1,
     "other_inf": null,
     "results": {
          "goal_found_perc": 96.67,
          "average_steps": 10.23,
          "average_distance": 10.81,
          "average_smoothness": 0.32,
          "average_clearance": 2.09,
          "average_time": 0.3105,
          "average_distance_from_goal": 0.27,
          "average_original_distance_from_goal": 8.42,
          "average memory": 33.14,
          "goal_found_perc_improvement": -0.68,
          "average_steps_improvement": -11.93,
          "average_distance_improvement": -11.9,
          "average_smoothness_improvement": -23.08,
          "average_clearance_improvement": 3.98,
          "average_time_improvement": -1364.62,
          "average_distance_from_goal_improvement": -35.0,
          "average_path_deviation": 1.1500000000000004,
          "average_memory_improvement": 10.96
     }
}
{heur3
     "algorithm": "This algorithm is an Adaptive Heuristic-Informed RRT* with goal biasing and rewiring.\n    It improves over classic RRT and RRT-Connect by incorporating:\n    - Goal-biased sampling (with increasing probability towards the goal as iterations progress).\n    - Adaptive step size that shrinks near obstacles or when close to goal for finer exploration.\n    - Heuristic cost estimation using Euclidean distance to goal to guide vertex rewiring and new vertex choices.\n    - Rewiring steps to improve path cost and smoothness by considering neighbor vertices.\n    - A priority queue-based search embedded in vertex expansions for cost-effective growth.\n    - Early stopping if path found or after 10 seconds elapsed.\n    - Final path smoothing via shortcutting to improve path quality before output.\n    The algorithm operates within a Forest graph data structure and uses vertices with costs for optimal planning.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring edges\n        self._init_displays()\n\n        self._max_dist_max = 15.0\n        self._max_dist_min = 2.5\n        self._iterations_max = 8000\n        self._goal_sample_rate_start = 0.2  # Initial goal bias probability\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _get_adaptive_max_dist(self, pos: Point) -> float:\n        # If close to goal, shrink max dist for finer steps\n        dist_goal = self._distance(pos, self._get_grid().goal.position)\n        if dist_goal < 10:\n            return max(self._max_dist_min, self._max_dist_max * (dist_goal / 10))\n        return self._max_dist_max\n\n    def _get_random_sample(self, iteration: int) -> Point:\n        # Gradually increase goal bias probability during iterations\n        goal_bias_prob = min(0.8, self._goal_sample_rate_start + iteration * 0.0001)\n        if np.random.rand() < goal_bias_prob:\n            return self._get_grid().goal.position\n        else:\n            # Biased sampling: sample around the line start->goal plus random noise\n            start_pos = self._get_grid().agent.position\n            goal_pos = self._get_grid().goal.position\n            direction = (goal_pos.to_tensor() - start_pos.to_tensor()).numpy()\n            baseline = start_pos.to_tensor().numpy() + np.random.rand() * direction\n            \n            # Add Gaussian noise proportional to environment size\n            env_size = np.array(self._get_grid().size)\n            noise = np.random.normal(scale=env_size / 7.0)  # spread noise\n            sample_coords = baseline + noise\n            sample_coords = np.clip(sample_coords, 0, env_size - 1).astype(int)\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            else:\n                # fallback to uniform random sample\n                while True:\n                    rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                    sample = Point(*rand_pos)\n                    if self._get_grid().is_agent_valid_pos(sample):\n                        return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / norm_dir\n        q_new_coord = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new = Vertex(Point.from_tensor(q_new_coord))\n        return q_new\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> list:\n        # Return vertices within radius for rewiring\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _line_valid(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        # Edge cost plus heuristic cost (cost-to-come + estimated cost-to-goal)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return frm.cost + move_cost\n\n    def _heuristic(self, point: Point) -> float:\n        # Euclidean distance to goal used as heuristic estimate\n        return self._distance(point, self._get_grid().goal.position)\n\n    def _rewire(self, q_new: Vertex, near_vertices: list):\n        # Try to improve path cost by connecting q_new as parent for neighbors if better cost\n        for q_near in near_vertices:\n            if q_near == q_new:\n                continue\n            # Check if line valid and cost can improve\n            if self._line_valid(q_new.position, q_near.position):\n                new_cost = self._cost(q_new, q_near)\n                if new_cost < q_near.cost:\n                    # Rewire: remove old parent edge(s), add new edge\n                    for p in list(q_near.parents):\n                        self._graph.remove_edge(p, q_near)\n                    self._graph.add_edge(q_new, q_near)\n                    q_near.cost = new_cost\n\n    def _extract_path(self, last_vertex: Vertex) -> None:\n        # Extract path by traversing parents up to root start\n        path = []\n        current = last_vertex\n        while current:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            # Choose parent with lowest cost (should be only one in tree)\n            parent = min(current.parents, key=lambda v: v.cost)\n            current = parent\n        path.reverse()\n\n        # Shortcut path smoothing by trying to shortcut between non-adjacent points\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._line_valid(path[i].position, path[j].position):\n                    break\n                j -= 1\n            smoothed_path.append(path[j])\n            i = j\n\n        # Move agent along smoothed path with key frames\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        root_start = self._graph.root_vertex_start\n        root_start.cost = 0.0\n        # Initialize root goal with infinite cost\n        root_goal = self._graph.root_vertex_goal\n        root_goal.cost = float('inf')\n\n        # Add root start vertex initially\n        open_set = [root_start]\n\n        for iteration in range(self._iterations_max):\n\n            if time.time() - start_time > 10:\n                # Timeout - no path found\n                break\n\n            q_sample = self._get_random_sample(iteration)\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_near.position)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Avoid duplicates\n            if q_new.position == q_near.position:\n                continue\n\n            if not self._line_valid(q_near.position, q_new.position):\n                continue\n\n            new_cost = self._cost(q_near, q_new)\n            q_new.cost = new_cost\n\n            # Insert q_new into graph\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire nearby vertices if better cost can be achieved through q_new\n            neighbor_radius = min(max_dist * 2.5, 15.0)\n            near_vertices = self._get_near_vertices(q_new, neighbor_radius)\n            self._rewire(q_new, near_vertices)\n\n            # Early stop if goal is within radius and connect if possible\n            if self._distance(q_new.position, self._get_grid().goal.position) <= max_dist * 1.5:\n                # Try connecting directly to goal position vertex if valid\n                if self._line_valid(q_new.position, root_goal.position):\n                    # Update goal cost and parent edge\n                    if self._cost(q_new, root_goal) < root_goal.cost:\n                        for p in list(root_goal.parents):\n                            self._graph.remove_edge(p, root_goal)\n                        self._graph.add_edge(q_new, root_goal)\n                        root_goal.cost = self._cost(q_new, root_goal)\n\n                    # Check if goal reached with improved cost => extract path & done\n                    if root_goal.cost < float('inf'):\n                        self._extract_path(root_goal)\n                        break\n\n            # Visualization frame update\n            self.key_frame()",
     "objective": 1472.635,
     "other_inf": null,
     "results": {
          "goal_found_perc": 96.0,
          "average_steps": 10.81,
          "average_distance": 11.49,
          "average_smoothness": 0.34,
          "average_clearance": 2.09,
          "average_time": 0.2077,
          "average_distance_from_goal": 0.26,
          "average_original_distance_from_goal": 8.42,
          "average memory": 38.47,
          "goal_found_perc_improvement": -1.37,
          "average_steps_improvement": -17.37,
          "average_distance_improvement": -17.97,
          "average_smoothness_improvement": -30.77,
          "average_clearance_improvement": 5.56,
          "average_time_improvement": -870.56,
          "average_distance_from_goal_improvement": -30.0,
          "average_path_deviation": 1.75,
          "average_memory_improvement": -3.36
     }
}
{
     "algorithm": "This algorithm combines heuristic-guided sampling, goal biasing, and adaptive radius rewiring with\n    dynamic max step size to improve convergence, efficiency, and path quality on grid maps.\n    It builds a forest structure similar to RRT*, but applies A*-inspired cost + heuristic for vertex selection,\n    aggressively rewires neighbors to optimize costs, and performs path shortcutting after path extraction.\n    To improve efficiency, it uses a sampling bias towards goal and open space around current best path,\n    and it stops early if a feasible path is found or if it runs beyond 10 seconds.\n    This approach aims for balanced planning time, smoothness, connectivity, and success rate.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _max_radius: float\n    _lambda_rrt_star: float\n    _dimension: int\n    _goal_bias_prob: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        # Init Forest with start and goal vertices; costs initialized later\n        start_v = Vertex(self._get_grid().agent.position)\n        start_v.cost = 0.0\n        goal_v = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_v, goal_v, [])\n\n        # Parameters for planning\n        self._max_dist_base = 12.0         # Base maximum distance to extend tree steps\n        self._max_radius = 40.0            # Max radius for rewiring neighbors\n        self._lambda_rrt_star = 40.0       # Constant for rewiring radius calculation\n        self._dimension = len(self._get_grid().size)  # Dimensionality (usually 2)\n        self._goal_bias_prob = 0.15        # Probability to sample goal directly\n\n        self._init_displays()\n\n    def _heuristic_cost(self, p: Point) -> float:\n        # Euclidean distance heuristic from p to goal for guiding sampling and cost estimation\n        return self._get_grid().get_distance(p, self._get_grid().goal.position)\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased and heuristic-guided adaptive sampling:\n        # With some probability sample goal directly for goal bias.\n        # Else sample from a Gaussian around the vector from start to goal, to focus search.\n        if np.random.rand() < self._goal_bias_prob:\n            return self._get_grid().goal.position\n\n        start = self._get_grid().agent.position\n        goal = self._get_grid().goal.position\n        mean = (start.to_tensor() + goal.to_tensor()) / 2\n        cov_scale = self._max_dist_base * 4\n        cov = torch.eye(self._dimension) * cov_scale\n        sample_np = np.random.multivariate_normal(mean.numpy(), cov.numpy())\n\n        sample_point = Point(*np.round(sample_np).astype(int))\n        # If outside bounds or invalid, fall back to random uniform sample until valid\n        for _ in range(10):\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n            sample_np = np.random.randint(0, self._get_grid().size, size=self._dimension)\n            sample_point = Point(*sample_np)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # Last resort fallback: random uniform sample\n        while True:\n            sample_np = np.random.randint(0, self._get_grid().size, size=self._dimension)\n            sample_point = Point(*sample_np)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        # Find nearest vertex in start-tree by cost+heuristic metric\n        vertices = [self._graph.root_vertex_start] + list(self._graph.root_vertex_start.children)\n        min_score = float('inf')\n        nearest = self._graph.root_vertex_start\n        for v in self._graph.root_vertices:\n            # Search start-tree vertices only\n            pass\n        # Instead, use graph internal function to get nearest vertex by Euclidean distance\n        nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n        return nearest\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> list:\n        # Returns vertices within radius from vertex.position in start-tree vertices\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_adaptive_max_dist(self, q_near: Vertex) -> float:\n        # Adapt max_dist based on heuristic distance of q_near to goal\n        h = self._heuristic_cost(q_near.position)\n        max_dist = min(self._max_dist_base, max(4.0, h / 2))\n        return max_dist\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_norm = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_norm\n        q_new = Vertex(Point.from_tensor(new_pos_tensor))\n        return q_new\n\n    def _rewire(self, q_new: Vertex, neighbors: list):\n        # Try to rewire the neighbors to q_new if it offers lower cost paths\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n                if new_cost < q_near.cost:\n                    # Remove old edge\n                    old_parent = None\n                    for p in q_near.parents:\n                        old_parent = p\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    # Add new edge from q_new to q_near\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, leaf: Vertex) -> None:\n        # Extract path by walking up parents and then shortcut to smooth path\n        path = []\n        current = leaf\n        while current.parents:\n            path.append(current)\n            # Pick first parent\n            for p in current.parents:\n                current = p\n                break\n        path.append(current)  # Add root start vertex\n        path.reverse()\n\n        # Shortcut path smoothing\n        smoothed_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            for j in range(len(path) - 1, idx, -1):\n                line_seq = self._get_grid().get_line_sequence(smoothed_path[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    next_idx = j\n                    break\n            smoothed_path.append(path[next_idx])\n            idx = next_idx\n\n        # Follow smoothed path and move agent accordingly\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            # If ROS extension available, publish waypoint\n            grid = self._get_grid()\n            if hasattr(grid, 'publish_wp'):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self):\n        from time import time\n        max_iterations = 3000\n        start_time = time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        # Initialize costs for root vertices explicitly\n        start_vertex.cost = 0.0\n        goal_vertex.cost = float('inf')\n\n        dimension = self._dimension\n        lambda_rrt_star = self._lambda_rrt_star\n        max_radius = self._max_radius\n\n        for iteration in range(max_iterations):\n\n            # Check time limit - stop if exceeding 10 seconds\n            if time() - start_time > 10.0:\n                break\n\n            q_sample = self._get_random_sample()\n\n            # Nearest vertex in start-tree\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest)\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Validate path from q_nearest to q_new\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            dist_near_new = self._get_grid().get_distance(q_nearest.position, q_new.position)\n            q_new.cost = q_nearest.cost + dist_near_new\n\n            # Compute radius for neighborhood rewiring based on the graph size\n            card_v = max(1, self._graph.size)\n            log_card_v = np.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose the best parent for q_new from Q_near including q_nearest\n            q_min = q_nearest\n            c_min = q_new.cost\n\n            for q_near in Q_near:\n                line_seq_near_new = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_near_new):\n                    continue\n                cost_candidate = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n                if cost_candidate < c_min:\n                    q_min = q_near\n                    c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if better path found\n            self._rewire(q_new, Q_near)\n\n            # Add q_new to forest root vertices list for tracking\n            if q_new not in self._graph.root_vertices:\n                self._graph.root_vertices.append(q_new)\n\n            # Check if goal is reached or inside goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect to goal explicitly if possible\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    dist_to_goal = self._get_grid().get_distance(q_new.position, goal_vertex.position)\n                    goal_vertex.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    # Extract and smooth path\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": 2602.865,
     "other_inf": null,
     "results": {
          "goal_found_perc": 96.67,
          "average_steps": 9.77,
          "average_distance": 10.32,
          "average_smoothness": 0.34,
          "average_clearance": 2.06,
          "average_time": 0.3633,
          "average_distance_from_goal": 0.28,
          "average_original_distance_from_goal": 8.42,
          "average memory": 48.95,
          "goal_found_perc_improvement": -0.68,
          "average_steps_improvement": -7.13,
          "average_distance_improvement": -7.05,
          "average_smoothness_improvement": -30.77,
          "average_clearance_improvement": 2.49,
          "average_time_improvement": -1630.0,
          "average_distance_from_goal_improvement": -40.0,
          "average_path_deviation": 0.6799999999999997,
          "average_memory_improvement": -31.52
     }
}
{heur4
     "algorithm": "This algorithm implements an improved RRT* inspired planner combining goal-biased adaptive sampling, \n    dynamic step sizing, and rewiring for path quality optimization. It uses an adaptive max_dist based on \n    current graph density and environment scale. Sampling is biased toward the goal at configurable rates \n    to improve success speed and path smoothness. Each new vertex is connected to the best parent within \n    a neighborhood radius to minimize cost, then rewired to maintain optimality. The search halts when \n    the goal is reached or after 10 seconds to ensure timely response. The extracted path is shortcut-optimized \n    to improve smoothness. This approach enhances efficiency, robustness, and path quality versus plain RRT.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            [],\n        )\n        self._graph.edges_removable = True  # allow rewiring/removal for RRT*\n        self._init_displays()\n\n        # Parameters for adaptive sampling and planning\n        self._goal_bias: float = 0.15        # Probability to sample goal directly (goal bias)\n        self._max_iterations: int = 5000     # Max iterations for sample expansion\n        self._min_max_dist: float = 5.0       # Minimum max step size (for finer paths)\n        self._max_max_dist: float = 20.0      # Maximum max step size (for coarse environment)\n        self._rewire_radius_factor: float = 2.5  # Radius factor for neighbor search during rewiring\n\n    # Helper Functions #\n\n    def _get_max_dist(self) -> float:\n        \"\"\"\n        Adaptively computes max_dist step size based on graph size and grid size.\n        As graph grows, max_dist decreases to allow finer exploration and rewiring.\n        \"\"\"\n        graph_size: int = self._graph.size\n        grid_size_scalar: float = float(min(self._get_grid().size))  # assuming size tuple-like\n        decay_rate: float = 0.0005  # controls decay speed\n\n        step = self._max_max_dist * np.exp(-decay_rate * graph_size)\n        step_clamped = max(self._min_max_dist, min(step, self._max_max_dist))\n        return step_clamped\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Returns a random sample point with goal bias. With goal_bias probability,\n        the sampled point is the goal position to guide the tree.\n        \"\"\"\n        if np.random.rand() < self._goal_bias:\n            return self._get_grid().goal.position\n\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _choose_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        \"\"\"\n        Chooses the best parent vertex for q_new from nearby vertices minimizing:\n        cost(parent) + movement_cost(parent->q_new)\n        If none found, returns None.\n        \"\"\"\n        best_parent: Vertex = None\n        best_cost: float = float('inf')\n\n        for vertex in near_vertices:\n            movement_cost = self._get_grid().get_movement_cost(vertex.position, q_new.position)\n            total_cost = vertex.cost + movement_cost\n            if total_cost < best_cost:\n                line_seq = self._get_grid().get_line_sequence(vertex.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    best_cost = total_cost\n                    best_parent = vertex\n\n        return best_parent\n\n    def _rewire(self, near_vertices: list, q_new: Vertex) -> None:\n        \"\"\"\n        For each vertex near q_new, try to rewire the graph if going through q_new reduces cost.\n        Rewiring happens only if line connection is valid.\n        \"\"\"\n        for vertex in near_vertices:\n            if vertex == q_new.parents:\n                continue  # already parent or self\n\n            movement_cost = self._get_grid().get_movement_cost(q_new.position, vertex.position)\n            potential_cost = q_new.cost + movement_cost\n            if potential_cost < vertex.cost:\n                # check valid path\n                line_seq = self._get_grid().get_line_sequence(q_new.position, vertex.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n\n                # remove old parent edge(s)\n                for p in list(vertex.parents):\n                    self._graph.remove_edge(p, vertex)\n\n                self._graph.add_edge(q_new, vertex)\n                vertex.cost = potential_cost\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"\n        Extracts and smoothes the final path from goal to start by following parents.\n        Then shortcut improves path by skipping unnecessary intermediate vertices.\n        Finally animates agent movement along path.\n        \"\"\"\n        # Connect last q_new to goal vertex explicitly (if disconnected)\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        line_seq_connect_goal = self._get_grid().get_line_sequence(q_new.position, goal_v.position)\n        if self._get_grid().is_valid_line_sequence(line_seq_connect_goal):\n            self._graph.add_edge(q_new, goal_v)\n            goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n        else:\n            goal_v.cost = float('inf')\n\n        path_vertices: list[Vertex] = [goal_v]\n        current_vertex = goal_v\n\n        while current_vertex.position != self._graph.root_vertex_start.position:\n            if not current_vertex.parents:\n                break  # no path found fully, exit early\n            parent = min(current_vertex.parents, key=lambda p: p.cost)\n            path_vertices.append(parent)\n            current_vertex = parent\n\n        path_vertices.reverse()\n\n        # Shortcut smoothing: attempt to directly connect non-adjacent vertices if path valid\n        def shortcut_path(path: list) -> list:\n            if len(path) <= 2:\n                return path\n            smoothed_path = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                while next_idx > idx + 1:\n                    line_seq = self._get_grid().get_line_sequence(path[idx].position, path[next_idx].position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        break\n                    next_idx -= 1\n                smoothed_path.append(path[next_idx])\n                idx = next_idx\n            return smoothed_path\n\n        path_vertices = shortcut_path(path_vertices)\n\n        for vertex in path_vertices:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        iteration = 0\n\n        start_vertex: Vertex = self._graph.root_vertex_start\n        goal_pos: Point = self._get_grid().goal.position\n\n        # Initialize cost for start vertex\n        start_vertex.cost = 0.0\n\n        while iteration < self._max_iterations:\n            iteration += 1\n\n            if (time.time() - start_time) > 10.0:  # early exit if over 10 seconds\n                break\n\n            max_dist: float = self._get_max_dist()\n\n            q_sample: Point = self._get_random_sample()\n\n            q_near: Vertex = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Generate new vertex in direction q_sample from q_near with max_dist limit\n            dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n            dist = torch.norm(dir_vec)\n            if dist <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vec / dist\n                new_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n                q_new_pos = Point.from_tensor(new_tensor)\n\n            # Check if new position is valid\n            if not self._get_grid().is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos, store_connectivity=True)\n\n            # Find all nearby vertices within rewiring radius\n            neighbor_radius = self._rewire_radius_factor * max_dist\n            near_vertices: list[Vertex] = self._graph.get_vertices_within_radius([start_vertex], q_new_pos, neighbor_radius)\n\n            # Choose best parent minimizing cost\n            best_parent = self._choose_parent(near_vertices, q_new)\n\n            if best_parent is None:\n                # Fall back to q_near if no better parent\n                best_parent = q_near\n                # Sanity check connectivity (line was already checked above)\n            q_new.cost = best_parent.cost + self._get_grid().get_movement_cost(best_parent.position, q_new_pos)\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors through q_new for potential cost improvement\n            self._rewire(near_vertices, q_new)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": 1523.43,
     "other_inf": null,
     "results": {
          "goal_found_perc": 97.33,
          "average_steps": 10.32,
          "average_distance": 11.01,
          "average_smoothness": 0.35,
          "average_clearance": 2.08,
          "average_time": 0.2017,
          "average_distance_from_goal": 0.2,
          "average_original_distance_from_goal": 8.42,
          "average memory": 76.29,
          "goal_found_perc_improvement": 0.0,
          "average_steps_improvement": -12.91,
          "average_distance_improvement": -13.98,
          "average_smoothness_improvement": -34.62,
          "average_clearance_improvement": 4.0,
          "average_time_improvement": -855.92,
          "average_distance_from_goal_improvement": -0.0,
          "average_path_deviation": 1.3499999999999996,
          "average_memory_improvement": -104.97
     }
}
Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0221,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.22
}
{
     "algorithm": "This algorithm implements an Adaptive Heuristic Guided RRT with Goal Biasing and Post-Processing Smoothing.\n    It dynamically adjusts step size based on local obstacle density, biases sampling towards the goal with progressive increase,\n    and incorporates heuristic cost (A*-inspired) to guide vertex connection and rewiring for optimal path quality.\n    It also performs a shortcut smoothing pass on the final path.\n    A time limit of 10 seconds is enforced to stop planning early if no solution is found.\n    This approach improves efficiency by focusing growth near promising areas, maintains robustness via adaptive sampling,\n    and yields smoother, shorter paths due to heuristic-guided rewiring and post-processing smoothing.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: \"Services\", testing: \"BasicTesting\" = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n        # Additional members\n        self._max_step_base = 8.0\n        self._max_step_min = 3.0\n        self._max_step_max = 15.0\n        self._goal_bias_start = 0.1\n        self._goal_bias_end = 0.5\n        self._goal_bias_current = self._goal_bias_start\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_random_sample_goal_biased(self) -> Point:\n        import random\n        if random.random() < self._goal_bias_current:\n            return self._get_grid().goal.position\n        else:\n            # Uniform random sample valid for the agent\n            while True:\n                sample = self._get_random_sample()\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_random_sample(self) -> Point:\n        size = self._get_grid().size\n        while True:\n            import numpy as np\n            rand_pos = np.random.randint(0, size, size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_max_step_dynamic(self, position: Point) -> float:\n        \"\"\"\n        Adaptive step size based on local obstacle density.\n        Sample points in the vicinity and reduce step if close to obstacles.\n        \"\"\"\n        check_radius = 5.0\n        nearby_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, position, check_radius)\n        if len(nearby_vertices) > 15:\n            return self._max_step_min\n        elif len(nearby_vertices) > 5:\n            return (self._max_step_min + self._max_step_base) / 2\n        else:\n            return min(self._max_step_max, self._max_step_base + len(nearby_vertices))\n\n    def _heuristic_cost(self, from_pos: Point) -> float:\n        \"\"\"\n        Heuristic cost: Euclidean from current position to goal.\n        \"\"\"\n        return self._get_grid().get_distance(from_pos, self._get_grid().goal.position)\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> \"List[Vertex]\":\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        Modified to use adaptive max_dist\n        \"\"\"\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_norm = dir_vec / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_norm)\n        return Vertex(q_new_pos)\n\n    def _cost_between(self, frm: Vertex, to: Vertex) -> float:\n        return self._get_grid().get_distance(frm.position, to.position)\n\n    def _add_and_rewire(self, q_new: Vertex, Q_near: \"List[Vertex]\") -> None:\n        \"\"\"\n        Connect q_new to best parent in Q_near minimizing cost + heuristic and rewire neighbors optimizing path cost.\n        \"\"\"\n        # Choose best parent\n        c_min = float('inf')\n        q_min = None\n        for q_near in Q_near:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost = q_near.cost + self._cost_between(q_near, q_new)\n            # Heuristic-guided: include heuristic in cost for rewiring (although primarily on path extraction)\n            if cost < c_min:\n                c_min = cost\n                q_min = q_near\n\n        if q_min is None:\n            return  # Cannot connect, skip\n\n        q_new.cost = c_min\n        self._graph.add_edge(q_min, q_new)\n\n        # Rewire nearby vertices if beneficial\n        for q_near in Q_near:\n            if q_near is q_min:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                continue\n            new_cost = q_new.cost + self._cost_between(q_new, q_near)\n            if new_cost < q_near.cost:\n                # Remove old parent edge\n                old_parent = None\n                for parent in q_near.parents:\n                    old_parent = parent\n                    break\n                if old_parent:\n                    self._graph.remove_edge(old_parent, q_near)\n                    q_near.cost = new_cost\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path_with_smoothing(self, q_goal: Vertex) -> None:\n        \"\"\"\n        Extract path from start to goal and perform shortcut smoothing between path points.\n        \"\"\"\n\n        path = [q_goal]\n        current = q_goal\n        while len(current.parents) != 0:\n            for parent in current.parents:\n                path.append(parent)\n                current = parent\n                break\n        path.reverse()\n        positions = [v.position for v in path]\n\n        # Shortcut smoothing post-processing\n        smoothed_positions = self._shortcut_smooth_path(positions)\n\n        for pos in smoothed_positions:\n            self.move_agent(pos)\n            # Send waypoint if ROS map\n            grid = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_smooth_path(self, positions: \"List[Point]\") -> \"List[Point]\":\n        \"\"\"\n        Performs shortcut smoothing by attempting to connect non-adjacent path points directly.\n        \"\"\"\n        if len(positions) <= 2:\n            return positions\n\n        smoothed = [positions[0]]\n        i = 0\n        while i < len(positions) - 1:\n            j = len(positions) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(positions[i], positions[j])\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    smoothed.append(positions[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # no shortcut found\n                smoothed.append(positions[i + 1])\n                i += 1\n\n        return smoothed\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_iterations = 8000\n        dimension = 2\n        lambda_rrt_star = 30\n        max_radius_cap = 35\n\n        start_time = time.time()\n\n        for i in range(max_iterations):\n            # Enforce 10 seconds max time limit\n            if time.time() - start_time > 10:\n                return  # Fail gracefully after 10 seconds without path\n\n            # Gradually increase goal bias to focus more on goal in later steps\n            self._goal_bias_current = min(self._goal_bias_end, self._goal_bias_start + (i / max_iterations)*(self._goal_bias_end - self._goal_bias_start))\n\n            q_sample = self._get_random_sample_goal_biased()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive step size based on local environment from nearest vertex\n            max_step = self._get_max_step_dynamic(q_nearest.position)\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_step)\n\n            # Check line validity\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Nearby vertices for rewiring and parent selection\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v) if card_v > 1 else torch.tensor(0.)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v)**(1/dimension)).item() if card_v > 1 else max_radius_cap, max_radius_cap)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n            self._add_and_rewire(q_new, Q_near)\n\n            # Add q_new to graph root vertices collection\n            self._graph.root_vertices.append(q_new)\n\n            # Check if goal can be connected with near q_new\n            goal_pos = self._get_grid().goal.position\n            if self._get_grid().get_distance(q_new.position, goal_pos) <= max_step:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_pos)):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_pos)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path_with_smoothing(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": 1602.73,
     "other_inf": null,
     "results": {
          "goal_found_perc": 96.0,
          "average_steps": 10.9,
          "average_distance": 11.52,
          "average_smoothness": 0.34,
          "average_clearance": 2.14,
          "average_time": 0.2318,
          "average_distance_from_goal": 0.3,
          "average_original_distance_from_goal": 8.42,
          "average memory": 36.77,
          "goal_found_perc_improvement": -1.37,
          "average_steps_improvement": -20.31,
          "average_distance_improvement": -20.5,
          "average_smoothness_improvement": -30.77,
          "average_clearance_improvement": 5.94,
          "average_time_improvement": -963.3,
          "average_distance_from_goal_improvement": -50.0,
          "average_path_deviation": 1.959999999999999,
          "average_memory_improvement": 1.21
     }
}
{heur 2
     "algorithm": "PathPlanning is a hybrid informed-sample-based algorithm that uses goal-biased sampling, \n    heuristic-guided expansion, and adaptive step size to efficiently construct a tree \n    from start toward goal while simultaneously attempting shortcut connections to improve path quality. \n    It maintains a Forest data structure like RRT*, but differs by:\n    - Using adaptive max_dist step size based on proximity to the goal.\n    - Incorporating a heuristic (Euclidean + cost) for choosing parents.\n    - Aggressively rewiring nearby nodes for cost improvements.\n    - Prioritizing goal connection attempts regularly.\n    - Applying a shortcut smoothing step after path extraction.\n    It includes a strict 10-second timeout to abort in case of long or failed searches.\n    This aims to improve success rate, reduce iterations, and produce shorter/smoother paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _max_radius: float\n    _goal_bias_prob: float\n    _dimension: int\n    _lambda_rrt_star: float\n    _timeout_sec: float\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        # Base max step length\n        self._max_dist_base = 12.0\n        # Radius for neighbor search (rewiring)\n        self._max_radius = 30.0\n        # Probability of sampling the goal for goal bias\n        self._goal_bias_prob = 0.15\n        self._dimension = 2\n        self._lambda_rrt_star = 35.0\n        self._timeout_sec = 10.0\n        self._init_displays()\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_random_sample(self) -> Point:\n        import random\n        if random.random() < self._goal_bias_prob:\n            # Goal-biased sampling\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)])\n            if self._get_grid().is_agent_valid_pos(rand_pos):\n                return rand_pos\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir_vec)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dir_norm\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _heuristic_cost(self, point: Point) -> float:\n        goal_pos = self._get_grid().goal.position\n        return Map.get_distance(point, goal_pos)\n\n    def _extract_path(self, q_goal_reached: Vertex) -> None:\n        path: List[Vertex] = [q_goal_reached]\n        # Backtrack using parents\n        while path[-1].parents:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        path.reverse()\n\n        # Smooth path shortcutting\n        smoothed_path = self._shortcut_path(path)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            # ROS waypoint publishing support, if applicable\n            grid = self._get_grid()\n            if hasattr(grid, 'publish_wp'):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        new_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            # Search for furthest reachable vertex with collision-free line\n            for check_idx in range(len(path) - 1, idx, -1):\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[check_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    next_idx = check_idx\n                    break\n            new_path.append(path[next_idx])\n            idx = next_idx\n        return new_path\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_iterations = 5000\n        start_time = time.time()\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n\n        for iteration in range(max_iterations):\n            curr_time = time.time()\n            if curr_time - start_time > self._timeout_sec:\n                # Timeout: path not found within 10 seconds\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n\n            if q_nearest.position == q_sample:\n                # Sampled exactly at existing vertex, no extension needed\n                self.key_frame()\n                continue\n\n            # Adaptive max_dist based on distance to goal, smaller as closer to reduce overshoot and improve smoothing\n            dist_to_goal = Map.get_distance(q_nearest.position, goal_pos)\n            max_dist = self._max_dist_base * (dist_to_goal / max(self._get_grid().size[0], 1))\n            max_dist = max(3.0, min(max_dist, self._max_dist_base))\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Validate line from nearest to new\n            line_seq_near_new = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq_near_new):\n                self.key_frame()\n                continue\n\n            # Radius for near neighbors for rewiring using RRT* heuristic formula\n            card_v = max(float(self._graph.size), 1.0)\n            radius = min(self._lambda_rrt_star * ((torch.log(torch.tensor(card_v)) / card_v) ** (1.0 / self._dimension)), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with min cost + heuristic (like A*) among neighbors + q_nearest\n            c_min = q_nearest.cost + Map.get_distance(q_nearest.position, q_new.position)\n            q_min = q_nearest\n\n            for q_near_cand in Q_near:\n                line_seq_cand = self._get_grid().get_line_sequence(q_near_cand.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_cand):\n                    continue\n                cost_cand = q_near_cand.cost + Map.get_distance(q_near_cand.position, q_new.position)\n                # Add heuristic to prioritize vertices closer to goal (aiming smoother optimization)\n                cost_cand += self._heuristic_cost(q_new.position) * 0.2\n                if cost_cand < c_min:\n                    c_min = cost_cand\n                    q_min = q_near_cand\n\n            # Set cost and add edge\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if shorter path via q_new exists\n            for q_near_cand in Q_near:\n                if q_near_cand == q_min:\n                    continue\n                line_seq_rewire = self._get_grid().get_line_sequence(q_new.position, q_near_cand.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_rewire):\n                    continue\n                cost_through_new = q_new.cost + Map.get_distance(q_new.position, q_near_cand.position)\n                if cost_through_new < q_near_cand.cost:\n                    # Remove old parent edge\n                    parent_old = next(iter(q_near_cand.parents), None)\n                    if parent_old is not None:\n                        self._graph.remove_edge(parent_old, q_near_cand)\n                    # Add new edge with q_new as parent\n                    q_near_cand.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near_cand)\n\n            # Attempt to directly connect newly added vertex to the goal if close enough and path is free\n            dist_to_goal_new = Map.get_distance(q_new.position, goal_pos)\n            connection_threshold = 10.0\n            if dist_to_goal_new <= connection_threshold:\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_pos)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    goal_vertex = self._graph.root_vertex_goal\n                    cost_goal = q_new.cost + dist_to_goal_new\n                    # If no parents yet (not connected) or better cost, connect goal to q_new\n                    if not goal_vertex.parents or cost_goal < goal_vertex.cost:\n                        goal_vertex.parents.clear()\n                        goal_vertex.cost = cost_goal\n                        self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": 892.995,
     "other_inf": null,
     "results": {
          "goal_found_perc": 97.33,
          "average_steps": 10.46,
          "average_distance": 11.25,
          "average_smoothness": 0.34,
          "average_clearance": 2.1,
          "average_time": 0.1516,
          "average_distance_from_goal": 0.2,
          "average_original_distance_from_goal": 8.42,
          "average memory": 32.67,
          "goal_found_perc_improvement": 0.0,
          "average_steps_improvement": -14.44,
          "average_distance_improvement": -16.46,
          "average_smoothness_improvement": -30.77,
          "average_clearance_improvement": 5.0,
          "average_time_improvement": -595.41,
          "average_distance_from_goal_improvement": -0.0,
          "average_path_deviation": 1.5899999999999999,
          "average_memory_improvement": 12.06
     }
}
{ heur1
     "algorithm": "This algorithm implements an improved RRT* inspired planner that combines:\n     - Adaptive goal-biased sampling with dynamic probability adjustment to focus\n       exploration progressively towards the goal while still sampling widely.\n     - Heuristic-guided nearest neighbor search that uses both Euclidean distance and \n       path cost to select the best parent candidate, improving tree quality.\n     - Rewiring of nearby vertices with a radius that scales adaptively with the graph size\n       to reduce path cost dynamically (RRT* style).\n     - Adaptive max_dist step size that reduces when near obstacles or goal area for fine \n       path refinement and increases in free space for faster exploration.\n     - Early stopping if a path is found within a target cost threshold.\n     - Path shortcutting smoothing to improve path quality after extraction.\n     - Maximum 10 seconds total allowed runtime to avoid long planning delays.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n\n        self._goal_bias = 0.2  # starting probability to sample goal directly\n        self._max_dist = 15.0  # initial max extension distance\n        self._rewire_radius_constant = 30.0  # constant to scale rewiring radius\n        self._iterations = 8000  # max iterations\n        self._timeout = 10.0  # max allowed seconds to find path\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # With probability self._goal_bias sample the goal point directly, else uniform random\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        # Uniform random sampling over valid positions\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n    \n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        # Direction and distance vector\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir_vec / dist\n        # Adaptive max_dist: smaller steps near obstacles or goal\n        # Check if q_near close to goal or obstacles, reduce max_dist in those cases\n        reduce_factor = 1.0\n        if self._get_grid().is_agent_in_goal_radius(agent_pos=q_near.position):\n            reduce_factor = 0.3\n        else:\n            # Check distance to nearest obstacle (estimate by grid sampling radius)\n            # To avoid expensive computing, just check neighbours near q_near\n            neighbors = self._get_grid().get_next_positions(q_near.position)\n            obstacle_near = any(not self._get_grid().is_agent_valid_pos(p) for p in neighbors)\n            if obstacle_near:\n                reduce_factor = 0.5\n        \n        adaptive_dist = max_dist * reduce_factor\n        q_new_pos_tensor = q_near.position.to_tensor() + adaptive_dist * dir_normalized\n        q_new_pos = Point.from_tensor(q_new_pos_tensor)\n        return Vertex(q_new_pos)\n\n    def _cost(self, from_v: Vertex, to_v: Vertex) -> float:\n        # Cost function: path cost + movement cost\n        # Includes from_v.cost + cost from from_v to to_v\n        c = from_v.cost + self._get_grid().get_movement_cost(from_v.position, to_v.position)\n        return c\n\n    def _choose_parent(self, q_near_list: List[Vertex], q_new: Vertex) -> Vertex:\n        # Among q_near_list, choose parent minimizing total cost to reach q_new\n        best_parent = None\n        best_cost = float('inf')\n\n        for q_near in q_near_list:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            c = self._cost(q_near, q_new)\n            if c < best_cost:\n                best_cost = c\n                best_parent = q_near\n        \n        if best_parent is None:\n            # fallback: nearest by Euclidean distance\n            best_parent = q_near_list[0]\n            best_cost = self._cost(best_parent, q_new)\n\n        q_new.cost = best_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, q_near_list: List[Vertex]):\n        # Attempt to rewire neighbors to q_new if it improves their cost via q_new\n        for q_near in q_near_list:\n            if q_near is q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                continue\n            potential_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n            if potential_cost < q_near.cost:\n                # Remove old parent edge(s) and add new edge q_new->q_near\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = potential_cost\n\n    def _extract_path(self, q_last: Vertex) -> None:\n        # Trace back from q_last to root_vertex_start\n        path: List[Vertex] = [q_last]\n        current = q_last\n        while len(current.parents) > 0:\n            # pick parent with lowest cost for robustness\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Path shortcutting / smoothing\n        path = self._shortcut_path(path)\n\n        # Animate path movement & key frames\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Try to shortcut between non-consecutive vertices if line is valid\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            for test_idx in range(len(path) - 1, idx, -1):\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[test_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    next_idx = test_idx\n                    break\n            shortcut_path.append(path[next_idx])\n            idx = next_idx\n        return shortcut_path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        self._graph.root_vertex_start.cost = 0.0\n        last_best_cost = float('inf')\n        best_goal_vertex = None\n\n        for i in range(self._iterations):\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout:\n                # Timeout reached, stop planning\n                break\n\n            # Adaptive goal bias - ramps up as iterations progress\n            self._goal_bias = min(0.7, 0.2 + 0.5 * (i / self._iterations))\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            # Validate line from q_nearest to q_new\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors within adaptive radius for choosing parent & rewiring\n            radius = min(self._rewire_radius_constant * math.sqrt(math.log(max(1, self._graph.size)) / max(1, self._graph.size)), self._max_dist * 5)\n            neighbor_vertices = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            if len(neighbor_vertices) == 0:\n                neighbor_vertices = [q_nearest]\n\n            # Choose best parent using cost heuristic\n            best_parent = self._choose_parent(neighbor_vertices, q_new)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors if improvement possible\n            self._rewire(q_new, neighbor_vertices)\n\n            # If close enough to goal, try direct connection\n            goal_pos = self._get_grid().goal.position\n            if Map.get_distance(q_new.position, goal_pos) <= self._max_dist * 1.5:\n                line_to_goal = self._get_grid().get_line_sequence(q_new.position, goal_pos)\n                if self._get_grid().is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_pos)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    # Check if this new path is best so far\n                    if goal_vertex.cost < last_best_cost:\n                        last_best_cost = goal_vertex.cost\n                        best_goal_vertex = goal_vertex\n\n            # Early stop if very good path found\n            if best_goal_vertex is not None and last_best_cost < self._max_dist * 20:\n                break\n\n            # Periodically add key_frame for visualization\n            if i % 100 == 0:\n                self.key_frame()\n\n        # Extract and animate path if found\n        if best_goal_vertex is not None:\n            self._extract_path(best_goal_vertex)",
     "objective": 559.375,
     "other_inf": null,
     "results": {
          "goal_found_perc": 97.33,
          "average_steps": 11.43,
          "average_distance": 12.41,
          "average_smoothness": 0.34,
          "average_clearance": 2.17,
          "average_time": 0.0361,
          "average_distance_from_goal": 0.2,
          "average_original_distance_from_goal": 8.42,
          "average memory": 36.41,
          "goal_found_perc_improvement": 0.0,
          "average_steps_improvement": -25.05,
          "average_distance_improvement": -28.47,
          "average_smoothness_improvement": -30.77,
          "average_clearance_improvement": 8.5,
          "average_time_improvement": -362.82,
          "average_distance_from_goal_improvement": -0.0,
          "average_path_deviation": 2.75,
          "average_memory_improvement": 2.18
     }
}Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0073,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.22
}
{
     "algorithm": "This algorithm implements an Adaptive Heuristic Biasing RRT (AHB-RRT) for improved path planning.\n    The key ideas are:\n    - Adaptive step size based on distance to the goal, enabling coarse exploration far away,\n      and fine exploration near the goal.\n    - Goal-biased sampling with increasing probability as iterations progress to speed up convergence.\n    - Heuristic cost used during vertex selection: combines distance from start and to goal (A*-style).\n    - Rewiring within a dynamic radius to optimize path quality.\n    - Early stopping criteria when a path is found and no better improvements in recent iterations.\n    - Path smoothing via shortcutting on extracted path before moving agent.\n    - Timeout limit of 10 seconds to ensure timely termination.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph: Forest = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_iterations: int = 5000\n        self._max_step_size: float = 20.0\n        self._min_step_size: float = 5.0\n        self._rewire_constant: float = 30.0\n        self._goal_sample_bias_max: float = 0.4  # max goal bias probability\n        self._goal_sample_bias_start: float = 0.05\n        self._goal_sample_bias_increment: float =  (self._goal_sample_bias_max - self._goal_sample_bias_start) / (self._max_iterations // 2)\n        self._last_improvement_iter: int = 0\n        self._improvement_threshold: int = 200  # iterations without improvement to stop\n        self._best_goal_cost: float = float('inf')\n        self._init_displays()\n\n    def _get_random_sample(self, goal_bias_prob: float) -> Point:\n        # Goal-biased sampling: with prob goal_bias_prob sample goal else random\n        import random as pyrandom\n        if pyrandom.random() < goal_bias_prob:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                sample_coords = [pyrandom.randint(0, self._get_grid().size[i]-1) for i in range(self._get_grid().size.n_dim)]\n                sample = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _heuristic_cost(self, q_from: Vertex, q_to: Point) -> float:\n        # Cost from start to q_from + heuristic distance q_from to q_to (A* style)\n        dist_to_goal = Map.get_distance(q_from.position, q_to)\n        return q_from.cost + dist_to_goal\n\n    def _get_nearest_vertex_heuristic(self, q_sample: Point) -> Vertex:\n        # Returns vertex with minimal heuristic cost of reaching goal via that vertex\n        candidate_vertices = [v for v in self._graph.root_vertices[0].children] + [self._graph.root_vertex_start]\n        best_vertex = self._graph.root_vertex_start\n        best_cost = self._heuristic_cost(best_vertex, q_sample)\n        for v in candidate_vertices:\n            cost_est = self._heuristic_cost(v, q_sample)\n            if cost_est < best_cost:\n                best_vertex = v\n                best_cost = cost_est\n        return best_vertex\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        direction = vec / dist\n        new_point_tensor = q_near.position.to_tensor() + direction * max_dist\n        new_point = Point.from_tensor(new_point_tensor)\n        return Vertex(new_point)\n\n    def _get_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Vertex]:\n        # Extract path by backtracking parents until start\n        path = [goal_vertex]\n        current = goal_vertex\n        while current is not self._graph.root_vertex_start:\n            # Prefer parent with lowest cost\n            if len(current.parents) == 0:\n                break\n            min_cost_parent = None\n            min_cost = float('inf')\n            for p in current.parents:\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_cost_parent = p\n            current = min_cost_parent\n            path.append(current)\n        path.reverse()\n        return path\n\n    def _path_shortcut(self, path: List[Vertex], max_attempts: int = 30) -> List[Vertex]:\n        # Attempt to shortcut path by checking line connections between non-adjacent vertices\n        if len(path) < 3:\n            return path\n        import random as pyrandom\n        new_path = path[:]\n        attempts = 0\n        while attempts < max_attempts:\n            attempts += 1\n            if len(new_path) < 3:\n                break\n            i = pyrandom.randint(0, len(new_path) - 3)\n            j = pyrandom.randint(i + 2, len(new_path)-1)\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(new_path[i].position, new_path[j].position)):\n                # shortcut possible, remove intermediate vertices\n                new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _find_path_internal(self) -> None:\n\n        import time\n        start_time = time.time()\n\n        iteration: int = 0\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        max_iterations = self._max_iterations\n        max_step_size = self._max_step_size\n        min_step_size = self._min_step_size\n        rewire_constant = self._rewire_constant\n        improvement_threshold = self._improvement_threshold\n        best_goal_cost = self._best_goal_cost\n        last_improvement_iter = self._last_improvement_iter\n\n        while iteration < max_iterations:\n            iter_elapsed = iteration\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 10.0:\n                # Time limit exceeded\n                break\n\n            # Adaptive goal bias increasing until max_goal_sample_bias at half iterations\n            if iteration <= max_iterations // 2:\n                goal_bias = self._goal_sample_bias_start + iteration * self._goal_sample_bias_increment\n            else:\n                goal_bias = self._goal_sample_bias_max\n\n            q_sample = self._get_random_sample(goal_bias)\n\n            # Adaptive step size based on dist to goal (smaller as near goal)\n            dist_to_goal = Map.get_distance(q_sample, goal_vertex.position)\n            adaptive_step = min_step_size + (max_step_size - min_step_size) * (dist_to_goal / max(self._get_grid().size[0], self._get_grid().size[1]))\n            adaptive_step = max(min_step_size, min(adaptive_step, max_step_size))\n\n            q_nearest: Vertex = self._graph.get_nearest_vertex([start_vertex], q_sample)\n\n            if q_nearest.position == q_sample:\n                iteration += 1\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, adaptive_step)\n\n            # Check if new vertex is collision free from nearest vertex\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                iteration += 1\n                continue\n\n            # Determine neighbors within rewiring radius\n            card_v = float(self._graph.size + 1)\n            dimension = self._get_grid().size.n_dim\n            radius = min(rewire_constant * (math.log(card_v) / card_v)**(1/dimension), rewire_constant)\n\n            nearby_vertices = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose best parent from nearby with lowest cost + reachable free path\n            q_min = q_nearest\n            c_min = q_nearest.cost + Map.get_distance(q_nearest.position, q_new.position)\n            for q_near in nearby_vertices:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    temp_cost = q_near.cost + Map.get_distance(q_near.position, q_new.position)\n                    if temp_cost < c_min:\n                        q_min = q_near\n                        c_min = temp_cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if connecting via new lowers cost and is collision free\n            for q_near in nearby_vertices:\n                if q_near == q_min:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    cost_through_new = q_new.cost + Map.get_distance(q_new.position, q_near.position)\n                    if cost_through_new < q_near.cost:\n                        # Remove old edges\n                        old_parents = list(q_near.parents)\n                        for p in old_parents:\n                            self._graph.remove_edge(p, q_near)\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check if new vertex can connect to goal (if close enough and path free)\n            dist_to_goal_vertex = Map.get_distance(q_new.position, goal_vertex.position)\n            if dist_to_goal_vertex <= adaptive_step:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)):\n                    goal_vertex.cost = q_new.cost + dist_to_goal_vertex\n                    self._graph.add_edge(q_new, goal_vertex)\n                    if goal_vertex.cost < best_goal_cost:\n                        best_goal_cost = goal_vertex.cost\n                        last_improvement_iter = iteration\n                    path = self._extract_path(goal_vertex)\n                    # Smooth path with shortcuts\n                    path = self._path_shortcut(path)\n                    for vertex in path:\n                        self.move_agent(vertex.position)\n                        self.key_frame(ignore_key_frame_skip=True)\n                    break\n\n            # Check if goal vertex already connected, update best cost and maybe stop if no improvement\n            if len(goal_vertex.parents) > 0:\n                if goal_vertex.cost < best_goal_cost:\n                    best_goal_cost = goal_vertex.cost\n                    last_improvement_iter = iteration\n\n                # Stop if no improvement beyond threshold\n                if iteration - last_improvement_iter > improvement_threshold:\n                    path = self._extract_path(goal_vertex)\n                    path = self._path_shortcut(path)\n                    for vertex in path:\n                        self.move_agent(vertex.position)\n                        self.key_frame(ignore_key_frame_skip=True)\n                    break\n\n            iteration += 1\n            self.key_frame()",
     "objective": 4588.25,
     "other_inf": null,
     "results": {
          "goal_found_perc": 97.33,
          "average_steps": 11.84,
          "average_distance": 12.71,
          "average_smoothness": 0.34,
          "average_clearance": 2.19,
          "average_time": 0.2264,
          "average_distance_from_goal": 0.2,
          "average_original_distance_from_goal": 8.42,
          "average memory": 49.9,
          "goal_found_perc_improvement": 0.0,
          "average_steps_improvement": -29.54,
          "average_distance_improvement": -31.57,
          "average_smoothness_improvement": -30.77,
          "average_clearance_improvement": 9.5,
          "average_time_improvement": -3001.37,
          "average_distance_from_goal_improvement": -0.0,
          "average_path_deviation": 3.0500000000000007,
          "average_memory_improvement": -34.07
     }
}
{
     "algorithm": "This algorithm is an improved RRT* inspired path planner with adaptive, goal-biased sampling and dynamic step sizing.\n    It incrementally builds a tree rooted at the start vertex, but unlike classical RRT, it applies rewiring and parent updates\n    to optimize path cost (like RRT*). The algorithm biases samples towards the goal with increasing probability over time,\n    improving convergence speed. Step size dynamically adjusts based on distance to samples and goal for efficient exploration.\n    Early stopping is implemented if the goal is connected or time exceeds 10 seconds. After path extraction, a path smoothing\n    procedure attempts shortcuts by checking direct valid lines between non-adjacent vertices to improve path quality.\n    This leads to higher success rate, smoother and shorter paths, and robustness in complex discrete grid environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # enable removable edges to allow rewiring\n        self._init_displays()\n\n        self._max_dist_min = 5.0\n        self._max_dist_max = 20.0\n        self._iterations = 10000\n        self._goal_sample_bias_init = 0.05  # initial goal bias probability\n        self._goal_sample_bias_max = 0.25   # max goal bias probability\n\n    def _get_random_sample(self, iteration:int) -> Point:\n        \"\"\"Goal-biased random sampling with increasing bias over iterations.\"\"\"\n        bias = self._goal_sample_bias_init + (self._goal_sample_bias_max - self._goal_sample_bias_init) * (iteration / self._iterations)\n        bias = min(bias, self._goal_sample_bias_max)\n        if np.random.rand() < bias:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * direction_normalized)\n        return Vertex(new_pos)\n\n    def _choose_parent(self, nearby_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        \"\"\"Chooses a parent among nearby vertices with minimal cost + movement cost.\"\"\"\n        min_cost = float('inf')\n        best_parent = None\n        for vertex in nearby_vertices:\n            line_seq = self._get_grid().get_line_sequence(vertex.position, q_new.position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                cost = vertex.cost + self._get_grid().get_movement_cost(vertex.position, q_new.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = vertex\n        if best_parent is not None:\n            q_new.cost = min_cost\n            return best_parent\n        else:\n            return None\n\n    def _rewire(self, nearby_vertices: List[Vertex], q_new: Vertex) -> None:\n        \"\"\"Attempt to rewire nearby vertices if going through q_new reduces cost.\"\"\"\n        for vertex in nearby_vertices:\n            line_seq = self._get_grid().get_line_sequence(q_new.position, vertex.position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                cost_through_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, vertex.position)\n                if cost_through_new < vertex.cost:\n                    # Remove old parent edges\n                    for parent in list(vertex.parents):\n                        self._graph.remove_edge(parent, vertex)\n                    # Add new edge\n                    self._graph.add_edge(q_new, vertex)\n                    vertex.cost = cost_through_new\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Vertex]:\n        \"\"\"Extract path from goal to start by traversing parent links.\"\"\"\n        path = [goal_vertex]\n        while len(path[-1].parents) != 0:\n            # Safe to pick the first parent because this is a tree structure\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        path.reverse()\n        return path\n\n    def _smooth_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"Try shortcutting via direct lines between non-adjacent vertices if valid.\"\"\"\n        if len(path) < 3:\n            return path\n\n        smoothed = [path[0]]\n        idx = 0\n        while idx < len(path) -1:\n            # try farthest possible next vertex with direct valid connection\n            next_idx = len(path) -1\n            while next_idx > idx+1:\n                line_seq = self._get_grid().get_line_sequence(smoothed[-1].position, path[next_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                next_idx -= 1\n            smoothed.append(path[next_idx])\n            idx = next_idx\n        return smoothed\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        # Root start vertex cost 0\n        self._graph.root_vertex_start.cost = 0.0\n        \n        for iteration in range(self._iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout - fail to find path in time\n                break\n\n            # Adaptive max_dist based on progress: decrease as iterations increase (exploration to refinement)\n            max_dist = self._max_dist_max - (self._max_dist_max - self._max_dist_min) * (iteration / self._iterations)\n            max_dist = max(self._max_dist_min, max_dist)\n\n            q_sample = self._get_random_sample(iteration)\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find nearby vertices for rewiring (radius based on max_dist)\n            nearby_vertices = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius=max_dist*1.5)\n\n            # Choose the best parent from nearby vertices\n            best_parent = self._choose_parent(nearby_vertices + [q_near], q_new)\n            if best_parent is None:\n                continue\n\n            # Add q_new and connect to best parent\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire the tree to maintain cost optimality\n            self._rewire(nearby_vertices, q_new)\n\n            # Early stopping if goal is reached or sufficiently close\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect the goal vertex to q_new if possible\n                goal_pos = self._get_grid().goal.position\n                goal_vertex = self._graph.root_vertex_goal\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_pos)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    cost_goal = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_pos)\n                    # Connect goal vertex to q_new with updated cost\n                    for parent in list(goal_vertex.parents):\n                        self._graph.remove_edge(parent, goal_vertex)\n                    goal_vertex.cost = cost_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    path = self._extract_path(goal_vertex)\n                    path = self._smooth_path(path)\n\n                    # Move agent along path for animation\n                    for vertex in path:\n                        self.move_agent(vertex.position)\n                        self.key_frame(ignore_key_frame_skip=True)\n\n                    break\n\n            self.key_frame()",
     "objective": 16115.005,
     "other_inf": null,
     "results": {
          "goal_found_perc": 96.0,
          "average_steps": 9.96,
          "average_distance": 10.51,
          "average_smoothness": 0.33,
          "average_clearance": 2.06,
          "average_time": 0.7762,
          "average_distance_from_goal": 0.35,
          "average_original_distance_from_goal": 8.42,
          "average memory": 65.96,
          "goal_found_perc_improvement": -1.37,
          "average_steps_improvement": -9.57,
          "average_distance_improvement": -9.59,
          "average_smoothness_improvement": -26.92,
          "average_clearance_improvement": 2.49,
          "average_time_improvement": -10532.88,
          "average_distance_from_goal_improvement": -75.0,
          "average_path_deviation": 0.9199999999999999,
          "average_memory_improvement": -77.22
     }
}
Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0075,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.22
}
{heur 5
     "algorithm": "This is an improved path planning algorithm inspired by RRT* with goal biasing and rewiring for path optimization.\n    Key features include:\n    - Goal-biased sampling to guide exploration towards the goal with a probability to speed convergence.\n    - Adaptive max_dist step size scaled by the distance from the current nearest vertex to the goal for finer movements near goal.\n    - Rewiring step to reduce path cost by connecting new vertices to nearby vertices if it improves cost.\n    - Early stopping if the path is found and improvements are negligible or after a max 10 seconds timeout.\n    - Shortcut smoothing of the final path by attempting to skip intermediate vertices if direct connection is valid.\n    \n    This achieves improved planning efficiency, shorter and smoother paths, and higher success rate in complex discrete grid environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    \n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring/removal in improved algorithm\n        self._max_time = 10.0  # seconds\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self, goal_sample_rate=0.2) -> Point:\n        \"\"\"Goal-biased sampling: with probability goal_sample_rate, sample the goal directly.\"\"\"\n        if random.random() < goal_sample_rate:\n            return self._get_grid().goal.position  # bias sampling to goal\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"Try rewiring neighboring vertices to q_new if this improves path cost and connection is valid.\"\"\"\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            # Cost to reach q_near through q_new\n            new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n            if new_cost + 1e-6 < q_near.cost:\n                # Check line validity from q_new to q_near\n                line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Rewire edges: remove old parent edges and add new edge\n                    for parent in list(q_near.parents):\n                        self._graph.remove_edge(parent, q_near)\n                    self._graph.add_edge(q_new, q_near)\n                    q_near.cost = new_cost\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"Attempt to shortcut the path by skipping intermediate nodes with direct valid connections.\"\"\"\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            # Try to find farthest vertex reachable directly from current idx\n            for test_idx in range(len(path) - 1, idx, -1):\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[test_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    next_idx = test_idx\n                    break\n            shortcut_path.append(path[next_idx])\n            idx = next_idx\n        return shortcut_path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"Extract path from start to goal, smooth it and animate.\"\"\"\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n        path: List[Vertex] = [goal_v]\n        current = goal_v\n\n        while len(current.parents) != 0:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n\n        path.reverse()\n\n        # Smooth path with shortcutting\n        smooth_path = self._shortcut_path(path)\n\n        for p in smooth_path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iter = 10000\n        base_max_dist = 15\n        goal_sample_rate = 0.2\n        radius = 20  # Rewiring neighborhood radius\n        start_time = time.time()\n\n        # Initialize start vertex cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for iteration in range(max_iter):\n\n            # Timeout check \n            if time.time() - start_time > self._max_time:\n                # Timeout, fail gracefully\n                break\n\n            q_sample: Point = self._get_random_sample(goal_sample_rate=goal_sample_rate)\n\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive max_dist based on proximity to goal to allow fine increments near goal\n            dist_to_goal = Map.get_distance(q_near.position, self._get_grid().goal.position)\n            adaptive_max_dist = min(base_max_dist, max(2.0, dist_to_goal / 3))\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, adaptive_max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Compute cost and set vertex cost\n            new_cost = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = new_cost\n\n            # Find neighbors for rewiring\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            # Choose parent with minimal cost among neighbors plus cost to reach q_new\n            min_cost = q_new.cost\n            min_parent = q_near\n            for q_neighbor in neighbors:\n                if q_neighbor == q_new:\n                    continue\n                line_seq = self._get_grid().get_line_sequence(q_neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost_through_neighbor = q_neighbor.cost + self._get_grid().get_movement_cost(q_neighbor.position, q_new.position)\n                if cost_through_neighbor < min_cost:\n                    min_cost = cost_through_neighbor\n                    min_parent = q_neighbor\n\n            # Update parent and cost with minimal cost parent\n            q_new.cost = min_cost\n            self._graph.add_edge(min_parent, q_new)\n\n            # Rewire neighbors\n            self._rewire(q_new, neighbors)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": 3332.105,
     "other_inf": null,
     "results": {
          "goal_found_perc": 97.33,
          "average_steps": 9.57,
          "average_distance": 10.09,
          "average_smoothness": 0.35,
          "average_clearance": 2.04,
          "average_time": 0.1659,
          "average_distance_from_goal": 0.2,
          "average_original_distance_from_goal": 8.42,
          "average memory": 62.02,
          "goal_found_perc_improvement": 0.0,
          "average_steps_improvement": -4.7,
          "average_distance_improvement": -4.45,
          "average_smoothness_improvement": -34.62,
          "average_clearance_improvement": 2.0,
          "average_time_improvement": -2112.0,
          "average_distance_from_goal_improvement": -0.0,
          "average_path_deviation": 0.4299999999999997,
          "average_memory_improvement": -66.63
     }
}
{heur 6
     "algorithm": "Improved sample-based path planning algorithm inspired by RRT* \n    with the following enhancements:\n     - Goal-biased sampling to guide expansion towards the goal with probability.\n     - Adaptive max step size, shrinking the step size near goal for finer resolution.\n     - Rewiring neighbors to shorten path costs (RRT* style).\n     - Early stopping after connecting to goal.\n     - Time budget limit: halts search if exceeds 10 seconds.\n     - Path shortcutting when extracting path to smooth and reduce length.\n    This ensures better path quality, smoother and shorter paths, higher success rate,\n    and improved efficiency by focusing samples intelligently.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # Allow rewiring/removal for RRT*\n        self._goal_bias = 0.15  # Probability of sampling the goal directly for bias\n        self._initial_max_dist = 15.0\n        self._min_max_dist = 3.0   # Minimal adaptive step size near goal\n        self._rewire_radius = 20.0  # Radius within which to attempt rewiring\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / norm\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling: sample goal directly with probability _goal_bias\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n\n        # Otherwise sample uniformly random valid point\n        grid_size = self._get_grid().size\n        while True:\n            rand_pos_np = np.random.randint(0, grid_size, grid_size.n_dim)\n            sample_point = Point(*rand_pos_np)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _choose_parent(self, q_new_pos: Point, near_vertices: List[Vertex]) -> Optional[Vertex]:\n        # Choose the best parent among near vertices based on minimal cost + movement cost\n        best_parent = None\n        best_cost = float('inf')\n        for q_near in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new_pos)):\n                continue\n            move_cost = self._get_grid().get_movement_cost(q_near.position, q_new_pos)\n            total_cost = q_near.cost + move_cost\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_parent = q_near\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]):\n        # Try to rewire near vertices if it shortens their path cost through q_new\n        for q_near in near_vertices:\n            if q_near == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                continue\n            move_cost = self._get_grid().get_movement_cost(q_new.position, q_near.position)\n            new_cost = q_new.cost + move_cost\n            if new_cost < q_near.cost:\n                # Remove old parent edge(s)\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                # Add new edge from q_new (rewiring)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _extract_and_smooth_path(self, q_new: Vertex):\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n\n        path: List[Vertex] = [goal_v]\n        current = goal_v\n        # Trace back to start\n        while current.parents:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n\n        path.reverse()\n\n        # Path shortcutting for smoothing\n        def shortcut_path(path: List[Vertex]) -> List[Vertex]:\n            if len(path) <= 2:\n                return path\n            smooth_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if self._get_grid().is_valid_line_sequence(\n                        self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                    ):\n                        break\n                    j -= 1\n                smooth_path.append(path[j])\n                i = j\n            return smooth_path\n\n        smooth_vertices = shortcut_path(path)\n\n        # Animate the agent moving along the smoothed path\n        for v in smooth_vertices:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _adaptive_max_dist(self, pos: Point) -> float:\n        # Adaptive max step size: smaller when nearer to goal to increase precision\n        dist_to_goal = self._get_grid().get_distance(pos, self._get_grid().goal.position)\n        max_dist = max(self._min_max_dist, min(self._initial_max_dist, dist_to_goal / 2.0))\n        return max_dist\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        max_time_sec = 10.0\n        iterations = 10000\n\n        start_vertex: Vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0  # Initialize cost to zero for start\n\n        for i in range(iterations):\n            if time.time() - start_time > max_time_sec:\n                # Timeout: no path found within time budget\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near.position)\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Find near vertices within rewire radius around q_new.position\n            near_vertices: List[Vertex] = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, self._rewire_radius)\n            if not near_vertices:\n                near_vertices = [q_near]\n\n            # Choose best parent among near vertices\n            best_parent = self._choose_parent(q_new.position, near_vertices)\n            if best_parent is None:\n                continue\n\n            # Add q_new to graph with best parent edge and cost\n            self._graph.add_edge(best_parent, q_new)\n            move_cost = self._get_grid().get_movement_cost(best_parent.position, q_new.position)\n            q_new.cost = best_parent.cost + move_cost\n\n            # Rewire nearby vertices if going through q_new shortens their cost\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_and_smooth_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": 4699.575,
     "other_inf": null,
     "results": {
          "goal_found_perc": 97.33,
          "average_steps": 9.8,
          "average_distance": 10.45,
          "average_smoothness": 0.34,
          "average_clearance": 2.04,
          "average_time": 0.2266,
          "average_distance_from_goal": 0.2,
          "average_original_distance_from_goal": 8.42,
          "average memory": 90.95,
          "goal_found_perc_improvement": 0.0,
          "average_steps_improvement": -7.22,
          "average_distance_improvement": -8.18,
          "average_smoothness_improvement": -30.77,
          "average_clearance_improvement": 2.0,
          "average_time_improvement": -2921.33,
          "average_distance_from_goal_improvement": -0.0,
          "average_path_deviation": 0.7899999999999991,
          "average_memory_improvement": -144.36
     }
}
Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0081,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.22
}
{
     "algorithm": "Improved Path Planning Algorithm inspired by RRT* with Goal Biasing and Adaptive Step Size.\n\n    This algorithm creates a single tree rooted at the start vertex but uses goal biasing with an increasing \n    probability to sample the goal directly as iterations progress, promoting faster progress towards the goal.\n\n    It implements rewiring similar to RRT* to improve path quality by locally optimizing connections around\n    the new vertex and attempting to reduce overall path cost.\n\n    The max expansion distance (max_dist) adapts dynamically based on proximity to obstacles: smaller steps near\n    obstacles for safer exploration, larger steps in free space for faster expansion.\n\n    It uses heuristic guidance (distance to goal) in the rewiring step to prefer connections that decrease the\n    cost-to-go estimate, enhancing path optimality.\n\n    Early stopping is implemented if the path is found or if runtime exceeds 10 seconds, preventing excessive computation.\n\n    After a solution is found, a shortcut smoothing procedure is run on the final path to reduce unnecessary waypoints,\n    making the path smoother and shorter.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                 Vertex(self._get_grid().goal.position, store_connectivity=True), [])\n        self._graph.edges_removable = True  # we will do rewiring and edge removal\n        self._init_displays()\n\n        self._base_max_dist = 15.0\n        self._min_max_dist = 3.0\n        self._max_iterations = 8000\n        self._goal_bias_start = 0.05  # initial goal bias probability\n        self._goal_bias_end = 0.3     # max goal bias probability at max iterations\n\n    def _adaptive_max_dist(self, pos: Point) -> float:\n        \"\"\"\n        Adaptively reduce max_dist when close to obstacles.\n        If close to any obstacle boundary (within radius 5), reduce step size.\n        \"\"\"\n        search_radius = 5\n        grid = self._get_grid()\n\n        # Check points around pos with small radius to detect obstacles nearby\n        nearby_obstacles = False\n        for dx in range(-search_radius, search_radius+1):\n            for dy in range(-search_radius, search_radius+1):\n                test_p = Point(pos.x + dx, pos.y + dy)\n                if not grid.is_agent_valid_pos(test_p):\n                    nearby_obstacles = True\n                    break\n            if nearby_obstacles:\n                break\n\n        if nearby_obstacles:\n            return max(self._min_max_dist, self._base_max_dist / 3)\n        else:\n            return self._base_max_dist\n\n    def _heuristic_cost(self, frm: Point, to: Point) -> float:\n        # Euclidean distance heuristic\n        return self._get_grid().get_distance(frm, to)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir_tensor)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n\n        dir_normalized = dir_tensor / norm_dir\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point, store_connectivity=True)\n\n    def _get_random_sample(self, iter_idx: int) -> Point:\n        \"\"\"\n        Goal-biased random sampling with linearly increasing bias.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        bias = self._goal_bias_start + (self._goal_bias_end - self._goal_bias_start) * (iter_idx / self._max_iterations)\n        bias = min(bias, self._goal_bias_end)\n\n        if np.random.rand() < bias:\n            return goal_pos\n\n        while True:\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _find_near_vertices(self, vertices: List[Vertex], q_new: Vertex, radius: float) -> List[Vertex]:\n        # Finds nearby vertices within radius to attempt rewiring\n        return self._graph.get_vertices_within_radius(vertices, q_new.position, radius)\n\n    def _choose_parent(self, q_near: Vertex, near_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        \"\"\"\n        Choose the best parent for q_new among near_vertices minimizing cost + movement cost,\n        provided line of path is valid.\n        \"\"\"\n        grid = self._get_grid()\n        best_parent = q_near\n        min_cost = q_near.cost + grid.get_movement_cost(q_near.position, q_new.position)\n\n        for near_v in near_vertices:\n            if near_v == q_near:\n                continue\n            candidate_cost = near_v.cost + grid.get_movement_cost(near_v.position, q_new.position)\n            # Validate path feasibility\n            line_seq = grid.get_line_sequence(near_v.position, q_new.position)\n            if candidate_cost < min_cost and grid.is_valid_line_sequence(line_seq):\n                best_parent = near_v\n                min_cost = candidate_cost\n\n        q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex):\n        \"\"\"\n        Rewire near vertices with a potential better cost through q_new.\n        \"\"\"\n        grid = self._get_grid()\n        for near_v in near_vertices:\n            if near_v == q_new.parents or near_v == q_new:\n                continue\n            cost_through_new = q_new.cost + grid.get_movement_cost(q_new.position, near_v.position)\n            if cost_through_new < near_v.cost:\n                line_seq = grid.get_line_sequence(q_new.position, near_v.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Remove old parents edges (only those with worse cost)\n                    for p in list(near_v.parents):\n                        self._graph.remove_edge(p, near_v)\n                    # Add new edge with better cost path\n                    self._graph.add_edge(q_new, near_v)\n                    near_v.cost = cost_through_new\n\n    def _extract_path(self, last_vertex: Vertex):\n        \"\"\"\n        Extract the path from goal to start by traversing parents,\n        then simplify via shortcut smoothing.\n        \"\"\"\n        grid = self._get_grid()\n\n        path: List[Vertex] = [last_vertex]\n        while len(path[-1].parents) != 0:\n            # choose parent with minimum cost\n            parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(parent)\n\n        path.reverse()\n\n        # Shortcut smoothing\n        path = self._shortcut_path(path)\n\n        # Animate the path\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"\n        Shortcut path by checking if line between non-adjacent vertices is valid,\n        remove intermediate vertices if possible.\n        \"\"\"\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path\n\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                # Check if direct line is valid\n                if grid.is_valid_line_sequence(grid.get_line_sequence(path[i].position, path[j].position)):\n                    shortcut_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                i += 1\n                if i < len(path):\n                    shortcut_path.append(path[i])\n                else:\n                    break\n\n        return shortcut_path\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        grid = self._get_grid()\n        root_vertex_start = self._graph.root_vertex_start\n        root_vertex_start.cost = 0.0\n\n        for i in range(self._max_iterations):\n            # Stop if taking too long (>10 seconds)\n            if time.time() - start_time > 10:\n                break\n\n            q_sample = self._get_random_sample(i)\n            q_near = self._graph.get_nearest_vertex([root_vertex_start], q_sample)\n\n            max_dist_adaptive = self._adaptive_max_dist(q_near.position)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist_adaptive)\n\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                self.key_frame()\n                continue\n\n            near_radius = min(30.0, max_dist_adaptive * 10)  # radius for neighbors to consider\n            near_vertices = self._find_near_vertices([root_vertex_start], q_new, near_radius)\n\n            best_parent = self._choose_parent(q_near, near_vertices, q_new)\n            self._graph.add_edge(best_parent, q_new)\n\n            self._rewire(near_vertices, q_new)\n\n            # If new vertex close enough to goal radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._graph.add_edge(q_new, self._graph.root_vertex_goal)\n                self._graph.root_vertex_goal.cost = q_new.cost + grid.get_movement_cost(q_new.position, self._graph.root_vertex_goal.position)\n                self._extract_path(self._graph.root_vertex_goal)\n                return\n\n            self.key_frame()",
     "objective": 10015.135,
     "other_inf": null,
     "results": {
          "goal_found_perc": 95.33,
          "average_steps": 9.66,
          "average_distance": 10.27,
          "average_smoothness": 0.33,
          "average_clearance": 2.07,
          "average_time": 0.5085,
          "average_distance_from_goal": 0.42,
          "average_original_distance_from_goal": 8.42,
          "average memory": 134.02,
          "goal_found_perc_improvement": -2.05,
          "average_steps_improvement": -6.98,
          "average_distance_improvement": -7.65,
          "average_smoothness_improvement": -26.92,
          "average_clearance_improvement": 2.48,
          "average_time_improvement": -6177.78,
          "average_distance_from_goal_improvement": -110.0,
          "average_path_deviation": 0.7300000000000004,
          "average_memory_improvement": -260.08
     }
}
Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0077,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.22
}
{
     "algorithm": "Description:\n    This algorithm implements a goal-biased, heuristic-informed adaptive RRT-inspired planner named \"Heuristic Adaptive RRT (HA-RRT)\".\n\n    Key features:\n    - Goal-biased sampling: biased sampling towards the goal with a predefined probability to improve convergence.\n    - Adaptive step size: dynamically adjusts max extension distance based on proximity to obstacles and iteration progress.\n    - Heuristic cost (A*-style): expands vertices considering the sum of cost-to-come and heuristic estimate-to-goal.\n    - Rewiring of the tree for path quality improvement like in RRT*.\n    - Shortcut smoothing on the found path for better smoothness.\n    - Time-based early stopping: aborts planning if exceeding 10 seconds.\n    - Uses a Forest graph structure, allowing efficient rewiring and cost updates.\n    \n    This method balances exploration and exploitation, efficiently finding high-quality paths with robustness and speed.",
     "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\nimport random\nimport time\nimport math\n\nfrom memory_profiler import profile\nfrom typing import TYPE_CHECKING, List, Tuple, Type, Any, Dict, Union, Optional\n\nfrom algorithms.basic_testing import BasicTesting\n\nfrom algorithms.algorithm import Algorithm\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\nfrom algorithms.classic.sample_based.core.graph import gen_cyclic_graph, CyclicGraph\n\nfrom algorithms.configuration.entities.agent import Agent\nfrom algorithms.configuration.entities.entity import Entity\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.entities.obstacle import Obstacle\nfrom algorithms.configuration.entities.trace import Trace\nfrom algorithms.configuration.maps.map import Map\nfrom algorithms.configuration.maps.ros_map import RosMap\nfrom algorithms.configuration.maps.bresenhams_algo import bresenhamline\n\nfrom simulator.services.services import Services\n\nfrom simulator.views.map.display.gradient_list_map_display import GradientListMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\n\nfrom structures import Point, Size, Colour, BLUE, DynamicColour\nfrom structures.factory import gen_set, gen_heap\nfrom structures.heap import Heap\n\n\n\nclass PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_iterations: int\n    _max_time: float\n    _goal_sample_rate: float  # Probability [0,1] of sampling the goal directly\n    _max_extension_default: float\n    _lambda_rrt_star: float\n    _dimension: int\n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_iterations = 5000\n        self._max_time = 10.0\n        self._goal_sample_rate = 0.15\n        self._max_extension_default = 12.0\n        self._lambda_rrt_star = 50.0\n        self._dimension = 2  # For 2D grid planning\n        self._init_displays()\n\n    def _heuristic_cost(self, pos: Point) -> float:\n        goal_pos = self._get_grid().goal.position\n        return self._get_grid().get_distance(pos, goal_pos)\n\n    def _get_random_sample(self) -> Point:\n        # With goal_sample_rate probability, sample exactly the goal for bias\n        import random\n        if random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = [int(torch.randint(0, self._get_grid().size[i], (1,)).item()) for i in range(self._dimension)]\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        # Using cost + heuristic for \"nearest\" is costly;\n        # here we get nearest by Euclidean, then evaluate cost heuristic in rewiring.\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        dir_vector = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir_vector)\n        if dir_norm == 0:\n            return None\n        if dir_norm <= max_dist:\n            new_pos = q_sample\n        else:\n            dir_normalized = dir_vector / dir_norm\n            new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n            new_pos = Point.from_tensor(new_pos_tensor)\n        if not self._get_grid().is_agent_valid_pos(new_pos):\n            return None\n        return Vertex(new_pos)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"Attempt to shortcut the path by skipping intermediate nodes if direct line valid.\"\"\"\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            furthest = i + 1\n            for j in range(len(path) - 1, i, -1):\n                line = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    furthest = j\n                    break\n            shortcut_path.append(path[furthest])\n            i = furthest\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n        current = q_goal\n        # Walk parents back to start\n        while len(current.parents) > 0:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Apply shortcut smoothing\n        path = self._shortcut_path(path)\n\n        for vert in path:\n            self.move_agent(vert.position)\n            grid = self._get_grid()\n            # Publish waypoint if ROS extension available\n            if hasattr(grid, 'publish_wp'):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _adaptive_max_extension(self, iteration: int) -> float:\n        # Decrease max_dist as iterations increase to favor finer expansions later\n        factor = max(0.3, 1.0 - iteration / self._max_iterations)\n        adaptive_dist = self._max_extension_default * factor\n        return max(5.0, adaptive_dist)  # never less than 5.0 to maintain progress\n\n    def _is_collision_free(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        goal_pos = self._get_grid().goal.position\n\n        for iteration in range(self._max_iterations):\n            current_time = time.time()\n            if current_time - start_time > self._max_time:\n                # Abort on time limit exceeded\n                break\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_extension(iteration)\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            if not self._is_collision_free(q_nearest.position, q_new.position):\n                continue\n\n            # Calculate radius per RRT* formula\n            n_vertices = max(1, self._graph.size)\n            radius = min(self._lambda_rrt_star * ((torch.log(torch.tensor(n_vertices)) / n_vertices) ** (1 / self._dimension)), 40.0)\n\n            # Find nearby vertices to consider for rewiring\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent that minimizes cost to reach q_new + heuristic\n            c_min = q_nearest.cost + self._get_grid().get_distance(q_nearest.position, q_new.position)\n            q_min = q_nearest\n            for q_near in Q_near:\n                if q_near == q_nearest:\n                    continue\n                if not self._is_collision_free(q_near.position, q_new.position):\n                    continue\n                cost_candidate = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n                if cost_candidate < c_min:\n                    c_min = cost_candidate\n                    q_min = q_near\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire tree: try to use q_new as parent for neighbors if it improves cost\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                if not self._is_collision_free(q_new.position, q_near.position):\n                    continue\n                cost_through_new = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n                if cost_through_new < q_near.cost:\n                    # Remove old parent edge(s)\n                    for parent in list(q_near.parents):\n                        self._graph.remove_edge(parent, q_near)\n                    # Add new edge from q_new to q_near\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if goal is reachable from q_new directly\n            dist_to_goal = self._get_grid().get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist and self._is_collision_free(q_new.position, goal_pos):\n                goal_vertex = self._graph.root_vertex_goal\n                # If goal vertex has parents already, remove to prevent cycles\n                for parent in list(goal_vertex.parents):\n                    self._graph.remove_edge(parent, goal_vertex)\n                goal_vertex.cost = q_new.cost + dist_to_goal\n                self._graph.add_edge(q_new, goal_vertex)\n                self._extract_path(goal_vertex)\n                return\n\n            if iteration % 20 == 0:\n                self.key_frame()",
     "objective": 4569.235,
     "other_inf": null,
     "results": {
          "goal_found_perc": 94.67,
          "average_steps": 11.35,
          "average_distance": 12.19,
          "average_smoothness": 0.35,
          "average_clearance": 2.16,
          "average_time": 0.1984,
          "average_distance_from_goal": 0.5,
          "average_original_distance_from_goal": 8.42,
          "average memory": 110.71,
          "goal_found_perc_improvement": -2.73,
          "average_steps_improvement": -26.25,
          "average_distance_improvement": -28.59,
          "average_smoothness_improvement": -34.62,
          "average_clearance_improvement": 6.4,
          "average_time_improvement": -2581.08,
          "average_distance_from_goal_improvement": -150.0,
          "average_path_deviation": 2.709999999999999,
          "average_memory_improvement": -197.45
     }
}
{
     "algorithm": "This algorithm is an improved and hybrid variant inspired by RRT* and goal-biased adaptive sampling with \n    heuristic guidance and rewiring for path optimization.\n\n    Main features:\n    - Adaptive max step size that decreases as vertices approach the goal for finer resolution.\n    - Goal-biased sampling with probability to sample goal directly to improve success rate.\n    - Rewiring nearby vertices to optimize cost and produce smoother, shorter paths.\n    - Early stopping criteria if path found or 10 seconds timeout exceeded.\n    - Final path smoothing by shortcutting invalid intermediate points.\n    - Uses Forest graph structure with vertices and edges, and pruning of suboptimal connections.\n    - Heuristic uses Euclidean distance for cost-to-go estimation.\n\n    This algorithm aims for balance between efficiency, path quality, robustness, and success rate,\n    by combining informed sampling, rewiring optimization, and dynamic step sizing.",
     "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\nimport random\nimport time\nimport math\n\nfrom memory_profiler import profile\nfrom typing import TYPE_CHECKING, List, Tuple, Type, Any, Dict, Union, Optional\n\nfrom algorithms.basic_testing import BasicTesting\n\nfrom algorithms.algorithm import Algorithm\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\nfrom algorithms.classic.sample_based.core.graph import gen_cyclic_graph, CyclicGraph\n\nfrom algorithms.configuration.entities.agent import Agent\nfrom algorithms.configuration.entities.entity import Entity\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.entities.obstacle import Obstacle\nfrom algorithms.configuration.entities.trace import Trace\nfrom algorithms.configuration.maps.map import Map\nfrom algorithms.configuration.maps.ros_map import RosMap\nfrom algorithms.configuration.maps.bresenhams_algo import bresenhamline\n\nfrom simulator.services.services import Services\n\nfrom simulator.views.map.display.gradient_list_map_display import GradientListMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\n\nfrom structures import Point, Size, Colour, BLUE, DynamicColour\nfrom structures.factory import gen_set, gen_heap\nfrom structures.heap import Heap\n\n\n\nclass PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True  # Allow rewiring/removing edges\n        self._max_initial_dist = 15.0\n        self._goal_sample_rate = 0.2  # 20% samples from goal\n        self._rewire_radius = 20.0\n        self._max_iterations = 5000\n        self._init_displays()\n        \n\n    def _get_random_sample(self) -> Point:\n        import random\n\n        if random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Optional[Vertex]:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist == 0:\n            return None\n        if dist <= max_dist:\n            new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / dist\n            new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n\n        if not self._get_grid().is_agent_valid_pos(new_pos):\n            return None\n\n        return Vertex(new_pos)\n\n    def _cost(self, vertex_from: Vertex, vertex_to: Vertex) -> float:\n        return self._get_grid().get_movement_cost(vertex_from.position, vertex_to.position)\n\n    def _heuristic(self, v: Vertex) -> float:\n        return Map.get_distance(v.position, self._get_grid().goal.position)\n\n    def _choose_parent(self, q_new: Vertex, near_vertices: List[Vertex]) -> Optional[Vertex]:\n        min_cost = float('inf')\n        best_parent = None\n\n        for q_near in near_vertices:\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                new_cost = q_near.cost + self._cost(q_near, q_new)\n                if new_cost < min_cost:\n                    min_cost = new_cost\n                    best_parent = q_near\n\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]):\n        for q_near in near_vertices:\n            if q_near == q_new.parents:\n                continue\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                existing_cost = q_near.cost\n                new_cost = q_new.cost + self._cost(q_new, q_near)\n                if new_cost < existing_cost:\n                    # Remove old parent edge(s)\n                    for p in list(q_near.parents):\n                        self._graph.remove_edge(p, q_near)\n                    # Add new edge\n                    self._graph.add_edge(q_new, q_near)\n                    q_near.cost = new_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Vertex]:\n        path = []\n        current = goal_vertex\n        while current.parents:\n            path.append(current)\n            current = next(iter(current.parents))\n        path.append(current)  # add root/start vertex\n        path.reverse()\n        return path\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        if not path or len(path) <= 2:\n            return path\n\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(path[i].position, path[j].position)):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        max_dist = self._max_initial_dist\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n\n        found_goal = False\n\n        for _ in range(self._max_iterations):\n\n            # Timeout check\n            if time.time() - start_time > 10.0:\n                # Fail: No path found within 10 seconds\n                break\n\n            q_sample: Point = self._get_random_sample()\n\n            # Adaptive max_dist, reduce near goal for finer resolution\n            dist_to_goal = Map.get_distance(q_sample, goal_vertex.position)\n            adaptive_max_dist = max(3.0, max_dist * (dist_to_goal / max_dist))  # between 3 and max_dist\n\n            q_near: Vertex = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Optional[Vertex] = self._get_new_vertex(q_near, q_sample, adaptive_max_dist)\n            if q_new is None:\n                continue\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Get vertices near q_new within rewire radius\n            near_vertices: List[Vertex] = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n\n            # Choose best parent minimizing cost to q_new\n            best_parent: Optional[Vertex] = self._choose_parent(q_new, near_vertices)\n            if best_parent is None:\n                # Fallback to q_near if no better parent\n                best_parent = q_near\n                q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire near vertices to optimize their cost (if improved by connecting through q_new)\n            self._rewire(q_new, near_vertices)\n\n            # Add q_new to graph root_vertices list for next iterations\n            self._graph.root_vertices.append(q_new)\n\n            self.key_frame()\n\n            # Check if q_new reached goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new directly to goal vertex if valid\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)):\n                    goal_vertex.cost = q_new.cost + self._cost(q_new, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    # Extract and shortcut path\n                    path_vertices: List[Vertex] = self._extract_path(goal_vertex)\n                    path_vertices = self._shortcut_path(path_vertices)\n\n                    # Animate path\n                    for vertex in path_vertices:\n                        self.move_agent(vertex.position)\n                        self.key_frame(ignore_key_frame_skip=True)\n\n                    found_goal = True\n                    break\n\n        if not found_goal:\n            # If no path found, consider fallback or do nothing\n            pass",
     "objective": 17603.095,
     "other_inf": null,
     "results": {
          "goal_found_perc": 93.33,
          "average_steps": 9.68,
          "average_distance": 10.24,
          "average_smoothness": 0.34,
          "average_clearance": 2.09,
          "average_time": 0.8356,
          "average_distance_from_goal": 0.63,
          "average_original_distance_from_goal": 8.42,
          "average memory": 107.56,
          "goal_found_perc_improvement": -4.11,
          "average_steps_improvement": -8.4,
          "average_distance_improvement": -8.82,
          "average_smoothness_improvement": -30.77,
          "average_clearance_improvement": 2.96,
          "average_time_improvement": -11191.89,
          "average_distance_from_goal_improvement": -215.0,
          "average_path_deviation": 0.8300000000000001,
          "average_memory_improvement": -188.98
     }
}
{
     "algorithm": "This algorithm is an improved sample-based planner combining goal-biased Adaptive RRT* with heuristic-guided rewiring and adaptive step sizing.\n    It uses a dynamic goal-biased sampling strategy to focus samples towards the goal (with increasing probability),\n    employs an adaptive step size based on current vertex density,\n    and a heuristic cost-to-go to improve tree extension decisions.\n    The rewiring step optimizes path quality during growth similarly to RRT*.\n    Additionally, it includes a shortcut smoothing procedure after path discovery.\n    An early stopping criterion is enforced with a 10 seconds max runtime to increase efficiency and success rate.\n    The algorithm utilizes Forest for tree structure, reuses helper functions, and integrates the Map environment effectively.",
     "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\nimport random\nimport time\nimport math\n\nfrom memory_profiler import profile\nfrom typing import TYPE_CHECKING, List, Tuple, Type, Any, Dict, Union, Optional\n\nfrom algorithms.basic_testing import BasicTesting\n\nfrom algorithms.algorithm import Algorithm\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\nfrom algorithms.classic.sample_based.core.graph import gen_cyclic_graph, CyclicGraph\n\nfrom algorithms.configuration.entities.agent import Agent\nfrom algorithms.configuration.entities.entity import Entity\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.entities.obstacle import Obstacle\nfrom algorithms.configuration.entities.trace import Trace\nfrom algorithms.configuration.maps.map import Map\nfrom algorithms.configuration.maps.ros_map import RosMap\nfrom algorithms.configuration.maps.bresenhams_algo import bresenhamline\n\nfrom simulator.services.services import Services\n\nfrom simulator.views.map.display.gradient_list_map_display import GradientListMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\n\nfrom structures import Point, Size, Colour, BLUE, DynamicColour\nfrom structures.factory import gen_set, gen_heap\nfrom structures.heap import Heap\n\n\n\nclass PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_radius = 50\n        self._dimension = self._get_grid().size.n_dim\n        self._lambda_rrt_star = 50\n        self._initial_max_dist = 15\n        self._goal_sample_rate = 0.2  # initial goal bias rate\n        self._timeout_sec = 10\n\n        self._init_displays()\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_random_sample(self, goal_bias_prob: float = 0.0) -> Point:\n        # Goal biased sampling: with goal_bias_prob probability sample the goal position, else uniform random\n        if torch.rand(1).item() < goal_bias_prob:\n            return self._get_grid().goal.position\n        while True:\n            sample_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        diff = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(diff)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        direction = diff / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * direction)\n        return Vertex(new_pos)\n\n    def _heuristic_cost(self, vertex_pos: Point) -> float:\n        # Euclidean distance heuristic cost to goal:\n        return Map.get_distance(vertex_pos, self._get_grid().goal.position)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = []\n        curr = q_goal\n        while len(curr.parents) != 0:\n            path.append(curr)\n            # Single parent assumed or pick any parent (first)\n            curr = next(iter(curr.parents))\n        path.append(curr)  # Append start vertex\n        path.reverse()\n\n        # Shortcut smoothing after extraction\n        smoothed_path = self._smooth_path(path)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            # Support ROS waypoint publishing if applicable\n            grid = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _smooth_path(self, path: list) -> list:\n        # Attempt shortcuts between non-consecutive vertices if collision-free\n        if len(path) <= 2:\n            return path\n\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(smoothed[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    smoothed.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # no shortcut found, advance by one\n                smoothed.append(path[i + 1])\n                i += 1\n        return smoothed\n\n    def _adaptive_max_dist(self) -> float:\n        # Adaptive max_dist based on number of vertices (more vertices => smaller max_dist)\n        count = max(1, self._graph.size)\n        max_dist = self._initial_max_dist * (1.0 / (count ** 0.3))\n        return max(3.0, min(max_dist, self._initial_max_dist))\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        max_iterations = 5000\n        iteration = 0\n        goal_found = False\n\n        while iteration < max_iterations:\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout_sec:\n                # Timeout reached\n                break\n\n            # Adaptive goal bias: increase towards max 0.5 with iterations\n            goal_bias = min(0.5, self._goal_sample_rate + iteration / max_iterations * 0.3)\n            q_sample = self._get_random_sample(goal_bias)\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                iteration += 1\n                continue\n\n            max_dist = self._adaptive_max_dist()\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check if path from q_nearest -> q_new is valid\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                iteration += 1\n                continue\n\n            # Cost calculations\n            c_nearest = q_nearest.cost\n            if c_nearest is None:\n                c_nearest = float(\"inf\")\n            dist_nearest_new = torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = c_nearest + dist_nearest_new\n\n            # Compute rewiring radius dynamically\n            card_V = max(float(self._graph.size), 1.0)\n            log_V = torch.log(torch.tensor(card_V))\n            radius = min(self._lambda_rrt_star * ((log_V / card_V) ** (1 / self._dimension)), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_new.cost\n\n            # Choose parent minimizing cost + heuristic (A* style)\n            for q_near in Q_near:\n                line_seq_candidate = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_candidate):\n                    continue\n                cost_candidate = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                heuristic = self._heuristic_cost(q_new.position)\n                if cost_candidate + heuristic < c_min + self._heuristic_cost(q_min.position):\n                    q_min = q_near\n                    c_min = cost_candidate\n\n            # Add edge from best parent found (q_min) to q_new\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire nearby vertices if better cost found through q_new\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                line_seq_near_qnew = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_near_qnew):\n                    continue\n                cost_through_new = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if cost_through_new < q_near.cost:\n                    # Remove old edge\n                    parent_to_remove = next(iter(q_near.parents), None)\n                    if parent_to_remove is not None:\n                        self._graph.remove_edge(parent_to_remove, q_near)\n                    q_near.cost = None\n                    # Add new edge\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check goal reached within goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                goal_found = True\n                break\n\n            iteration += 1\n            self.key_frame()\n\n        if not goal_found:\n            # Path not found - can optionally mark or handle here\n            pass",
     "objective": 18186.185,
     "other_inf": null,
     "results": {
          "goal_found_perc": 92.0,
          "average_steps": 10.56,
          "average_distance": 11.18,
          "average_smoothness": 0.33,
          "average_clearance": 2.17,
          "average_time": 0.8738,
          "average_distance_from_goal": 0.73,
          "average_original_distance_from_goal": 8.42,
          "average memory": 92.09,
          "goal_found_perc_improvement": -5.48,
          "average_steps_improvement": -18.25,
          "average_distance_improvement": -19.06,
          "average_smoothness_improvement": -26.92,
          "average_clearance_improvement": 6.37,
          "average_time_improvement": -11550.67,
          "average_distance_from_goal_improvement": -265.0,
          "average_path_deviation": 1.7899999999999991,
          "average_memory_improvement": -147.42
     }
}
{
     "algorithm": "This algorithm implements an improved RRT* inspired path planner with the following enhancements:\n    - Goal-biased sampling: samples the goal with a fixed probability to bias growth towards the goal.\n    - Adaptive step size: adjusts max extension distance based on distance from nearest vertex to sample, improving efficiency.\n    - Rewiring: after adding a new vertex, rewires nearby vertices if connecting through the new vertex reduces cost, optimizing path quality.\n    - Early stopping: stops as soon as the goal is reachable within a threshold.\n    - Shortcut smoothing: after path extraction, tries to shortcut the path by attempting direct connections between non-adjacent vertices to smooth the final path.\n    - Time bound: total planning time capped to 10 seconds for robustness.\n    \n    The algorithm builds a tree from start, incrementally growing toward samples while maintaining a low-cost tree structure.",
     "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\nimport random\nimport time\nimport math\n\nfrom memory_profiler import profile\nfrom typing import TYPE_CHECKING, List, Tuple, Type, Any, Dict, Union, Optional\n\nfrom algorithms.basic_testing import BasicTesting\n\nfrom algorithms.algorithm import Algorithm\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\nfrom algorithms.classic.sample_based.core.graph import gen_cyclic_graph, CyclicGraph\n\nfrom algorithms.configuration.entities.agent import Agent\nfrom algorithms.configuration.entities.entity import Entity\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.entities.obstacle import Obstacle\nfrom algorithms.configuration.entities.trace import Trace\nfrom algorithms.configuration.maps.map import Map\nfrom algorithms.configuration.maps.ros_map import RosMap\nfrom algorithms.configuration.maps.bresenhams_algo import bresenhamline\n\nfrom simulator.services.services import Services\n\nfrom simulator.views.map.display.gradient_list_map_display import GradientListMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\n\nfrom structures import Point, Size, Colour, BLUE, DynamicColour\nfrom structures.factory import gen_set, gen_heap\nfrom structures.heap import Heap\n\n\n\nclass PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 15.0\n        self._goal_sample_rate = 0.1\n        self._rewire_radius = 20.0\n        self._iterations = 15000\n        self._time_limit = 10.0  # seconds\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling: with probability goal_sample_rate, sample goal directly\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _calculate_cost(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        return from_vertex.cost + self._get_grid().get_movement_cost(from_vertex.position, to_vertex.position)\n\n    def _choose_parent(self, q_new: Vertex, near_vertices: list) -> Vertex:\n        # Choose the vertex in near_vertices that yields the lowest cost path to q_new\n        min_cost = float('inf')\n        best_parent = None\n        for vertex in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(vertex.position, q_new.position)):\n                continue\n            cost = self._calculate_cost(vertex, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = vertex\n        if best_parent is None:\n            # No suitable parent found; fallback to nearest vertex (should rarely happen)\n            return None\n        q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: list) -> None:\n        for vertex in near_vertices:\n            if vertex == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, vertex.position)):\n                continue\n            new_cost = self._calculate_cost(q_new, vertex)\n            if new_cost < vertex.cost:\n                # Remove old parent edges to this vertex\n                for parent in list(vertex.parents):\n                    self._graph.remove_edge(parent, vertex)\n                self._graph.add_edge(q_new, vertex)\n                vertex.cost = new_cost\n\n    def _extract_path(self, q_end: Vertex) -> list:\n        # Trace path from q_end to start\n        path = [q_end]\n        current = q_end\n        while current.parents:\n            # choose the parent with lowest cost\n            next_vertex = min(current.parents, key=lambda v: v.cost)\n            path.append(next_vertex)\n            current = next_vertex\n        path.reverse()\n        return path\n\n    def _shortcut_path(self, path: list) -> list:\n        # Try to connect non-adjacent waypoints directly if valid to smooth the path\n        if len(path) <= 2:\n            return path  # No smoothing needed\n\n        shortened_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            # Find furthest reachable vertex from current vertex without invalid obstacles on line\n            next_idx = len(path) - 1\n            for check_idx in range(len(path) - 1, idx, -1):\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[check_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    next_idx = check_idx\n                    break\n            shortened_path.append(path[next_idx])\n            idx = next_idx\n        return shortened_path\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.perf_counter()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for i in range(self._iterations):\n            current_time = time.perf_counter()\n            if current_time - start_time > self._time_limit:\n                # Timeout, no path found\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n\n            dist_near_sample = Map.get_distance(q_near.position, q_sample)\n            max_dist = min(self._max_dist_base, dist_near_sample)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find vertices near q_new within a radius for choosing the best parent and rewiring\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n            # Include q_near if not in near_vertices (rare but possible)\n            if q_near not in near_vertices:\n                near_vertices.append(q_near)\n\n            parent_vertex = self._choose_parent(q_new, near_vertices)\n            if parent_vertex is None:\n                continue  # no valid parent found\n\n            self._graph.add_edge(parent_vertex, q_new)\n\n            # Rewire nearby vertices through q_new if it improves cost\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Extract and smooth path then move agent along path\n                path_vertices = self._extract_path(q_new)\n                path_vertices = self._shortcut_path(path_vertices)\n\n                for vertex in path_vertices:\n                    self.move_agent(vertex.position)\n                    self.key_frame(ignore_key_frame_skip=True)\n                break\n\n            self.key_frame()",
     "objective": 16648.025,
     "other_inf": null,
     "results": {
          "goal_found_perc": 90.0,
          "average_steps": 9.95,
          "average_distance": 10.46,
          "average_smoothness": 0.35,
          "average_clearance": 2.14,
          "average_time": 0.7738,
          "average_distance_from_goal": 0.97,
          "average_original_distance_from_goal": 8.42,
          "average memory": 59.09,
          "goal_found_perc_improvement": -7.53,
          "average_steps_improvement": -12.18,
          "average_distance_improvement": -12.11,
          "average_smoothness_improvement": -34.62,
          "average_clearance_improvement": 4.39,
          "average_time_improvement": -10500.0,
          "average_distance_from_goal_improvement": -385.0,
          "average_path_deviation": 1.1300000000000008,
          "average_memory_improvement": -58.76
     }
}
