[
     {
          "algorithm": "This is the RRT algorithm, a sample-based pathfinding algorithm that explores the space by randomly sampling points and connecting them to the nearest vertex.",
          "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\n\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.basic_testing import BasicTesting\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\n\nfrom simulator.services.services import Services\n\nfrom structures import Point\n\n\nclass RRT(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        if torch.norm(dir) <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / torch.norm(dir)\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_new):\n\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)    #connect the last sampled point that's close to goal vertex and connet point to goal vertex with edge\n        path: List[Vertex] = [goal_v]    \n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        #get animation of path tracing from start to goal\n        for p in path:\n            self.move_agent(p.position)   \n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n\n        max_dist: float = 10\n        iterations: int = 10000\n\n        for i in range(iterations):\n\n            q_sample: Point = self._get_random_sample()     #sample a random point and return it if it's in valid position\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample) \n            if q_near.position == q_sample:\n                continue    #restart the while loop right away if sample point same as nearest vertex point\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)    #get new vertex\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):    \n                continue    #restart the while loop right away if the straight line path from nearest vertex to new sample point is invalid \n            self._graph.add_edge(q_near, q_new)    #add edge between 2 points\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):    #if agent is in goal radius, then run _extract_path method \n                self._extract_path(q_new)\n                break\n\n            self.key_frame()    #add the new vertex and edge if the new sample point is not at goal yet\n",
          "objective": 0,
          "other_inf": null
     },
     {
          "algorithm": "Description:\n    This algorithm implements a goal-biased, heuristic-informed adaptive RRT-inspired planner named \"Heuristic Adaptive RRT (HA-RRT)\".\n\n    Key features:\n    - Goal-biased sampling: biased sampling towards the goal with a predefined probability to improve convergence.\n    - Adaptive step size: dynamically adjusts max extension distance based on proximity to obstacles and iteration progress.\n    - Heuristic cost (A*-style): expands vertices considering the sum of cost-to-come and heuristic estimate-to-goal.\n    - Rewiring of the tree for path quality improvement like in RRT*.\n    - Shortcut smoothing on the found path for better smoothness.\n    - Time-based early stopping: aborts planning if exceeding 10 seconds.\n    - Uses a Forest graph structure, allowing efficient rewiring and cost updates.\n    \n    This method balances exploration and exploitation, efficiently finding high-quality paths with robustness and speed.",
          "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\nimport random\nimport time\nimport math\n\nfrom memory_profiler import profile\nfrom typing import TYPE_CHECKING, List, Tuple, Type, Any, Dict, Union, Optional\n\nfrom algorithms.basic_testing import BasicTesting\n\nfrom algorithms.algorithm import Algorithm\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\nfrom algorithms.classic.sample_based.core.graph import gen_cyclic_graph, CyclicGraph\n\nfrom algorithms.configuration.entities.agent import Agent\nfrom algorithms.configuration.entities.entity import Entity\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.entities.obstacle import Obstacle\nfrom algorithms.configuration.entities.trace import Trace\nfrom algorithms.configuration.maps.map import Map\nfrom algorithms.configuration.maps.ros_map import RosMap\nfrom algorithms.configuration.maps.bresenhams_algo import bresenhamline\n\nfrom simulator.services.services import Services\n\nfrom simulator.views.map.display.gradient_list_map_display import GradientListMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\n\nfrom structures import Point, Size, Colour, BLUE, DynamicColour\nfrom structures.factory import gen_set, gen_heap\nfrom structures.heap import Heap\n\n\n\nclass PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_iterations: int\n    _max_time: float\n    _goal_sample_rate: float  # Probability [0,1] of sampling the goal directly\n    _max_extension_default: float\n    _lambda_rrt_star: float\n    _dimension: int\n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_iterations = 5000\n        self._max_time = 10.0\n        self._goal_sample_rate = 0.15\n        self._max_extension_default = 12.0\n        self._lambda_rrt_star = 50.0\n        self._dimension = 2  # For 2D grid planning\n        self._init_displays()\n\n    def _heuristic_cost(self, pos: Point) -> float:\n        goal_pos = self._get_grid().goal.position\n        return self._get_grid().get_distance(pos, goal_pos)\n\n    def _get_random_sample(self) -> Point:\n        # With goal_sample_rate probability, sample exactly the goal for bias\n        import random\n        if random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = [int(torch.randint(0, self._get_grid().size[i], (1,)).item()) for i in range(self._dimension)]\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        # Using cost + heuristic for \"nearest\" is costly;\n        # here we get nearest by Euclidean, then evaluate cost heuristic in rewiring.\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        dir_vector = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir_vector)\n        if dir_norm == 0:\n            return None\n        if dir_norm <= max_dist:\n            new_pos = q_sample\n        else:\n            dir_normalized = dir_vector / dir_norm\n            new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n            new_pos = Point.from_tensor(new_pos_tensor)\n        if not self._get_grid().is_agent_valid_pos(new_pos):\n            return None\n        return Vertex(new_pos)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"Attempt to shortcut the path by skipping intermediate nodes if direct line valid.\"\"\"\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            furthest = i + 1\n            for j in range(len(path) - 1, i, -1):\n                line = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    furthest = j\n                    break\n            shortcut_path.append(path[furthest])\n            i = furthest\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n        current = q_goal\n        # Walk parents back to start\n        while len(current.parents) > 0:\n            parent = next(iter(current.parents))\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Apply shortcut smoothing\n        path = self._shortcut_path(path)\n\n        for vert in path:\n            self.move_agent(vert.position)\n            grid = self._get_grid()\n            # Publish waypoint if ROS extension available\n            if hasattr(grid, 'publish_wp'):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _adaptive_max_extension(self, iteration: int) -> float:\n        # Decrease max_dist as iterations increase to favor finer expansions later\n        factor = max(0.3, 1.0 - iteration / self._max_iterations)\n        adaptive_dist = self._max_extension_default * factor\n        return max(5.0, adaptive_dist)  # never less than 5.0 to maintain progress\n\n    def _is_collision_free(self, p1: Point, p2: Point) -> bool:\n        line_seq = self._get_grid().get_line_sequence(p1, p2)\n        return self._get_grid().is_valid_line_sequence(line_seq)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        goal_pos = self._get_grid().goal.position\n\n        for iteration in range(self._max_iterations):\n            current_time = time.time()\n            if current_time - start_time > self._max_time:\n                # Abort on time limit exceeded\n                break\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_extension(iteration)\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            if not self._is_collision_free(q_nearest.position, q_new.position):\n                continue\n\n            # Calculate radius per RRT* formula\n            n_vertices = max(1, self._graph.size)\n            radius = min(self._lambda_rrt_star * ((torch.log(torch.tensor(n_vertices)) / n_vertices) ** (1 / self._dimension)), 40.0)\n\n            # Find nearby vertices to consider for rewiring\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent that minimizes cost to reach q_new + heuristic\n            c_min = q_nearest.cost + self._get_grid().get_distance(q_nearest.position, q_new.position)\n            q_min = q_nearest\n            for q_near in Q_near:\n                if q_near == q_nearest:\n                    continue\n                if not self._is_collision_free(q_near.position, q_new.position):\n                    continue\n                cost_candidate = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n                if cost_candidate < c_min:\n                    c_min = cost_candidate\n                    q_min = q_near\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire tree: try to use q_new as parent for neighbors if it improves cost\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                if not self._is_collision_free(q_new.position, q_near.position):\n                    continue\n                cost_through_new = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n                if cost_through_new < q_near.cost:\n                    # Remove old parent edge(s)\n                    for parent in list(q_near.parents):\n                        self._graph.remove_edge(parent, q_near)\n                    # Add new edge from q_new to q_near\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if goal is reachable from q_new directly\n            dist_to_goal = self._get_grid().get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist and self._is_collision_free(q_new.position, goal_pos):\n                goal_vertex = self._graph.root_vertex_goal\n                # If goal vertex has parents already, remove to prevent cycles\n                for parent in list(goal_vertex.parents):\n                    self._graph.remove_edge(parent, goal_vertex)\n                goal_vertex.cost = q_new.cost + dist_to_goal\n                self._graph.add_edge(q_new, goal_vertex)\n                self._extract_path(goal_vertex)\n                return\n\n            if iteration % 20 == 0:\n                self.key_frame()",
          "objective": 4569.235,
          "other_inf": null,
          "results": {
               "goal_found_perc": 94.67,
               "average_steps": 11.35,
               "average_distance": 12.19,
               "average_smoothness": 0.35,
               "average_clearance": 2.16,
               "average_time": 0.1984,
               "average_distance_from_goal": 0.5,
               "average_original_distance_from_goal": 8.42,
               "average memory": 110.71,
               "goal_found_perc_improvement": -2.73,
               "average_steps_improvement": -26.25,
               "average_distance_improvement": -28.59,
               "average_smoothness_improvement": -34.62,
               "average_clearance_improvement": 6.4,
               "average_time_improvement": -2581.08,
               "average_distance_from_goal_improvement": -150.0,
               "average_path_deviation": 2.709999999999999,
               "average_memory_improvement": -197.45
          }
     },
     {
          "algorithm": "This algorithm implements an improved RRT* inspired path planner with the following enhancements:\n    - Goal-biased sampling: samples the goal with a fixed probability to bias growth towards the goal.\n    - Adaptive step size: adjusts max extension distance based on distance from nearest vertex to sample, improving efficiency.\n    - Rewiring: after adding a new vertex, rewires nearby vertices if connecting through the new vertex reduces cost, optimizing path quality.\n    - Early stopping: stops as soon as the goal is reachable within a threshold.\n    - Shortcut smoothing: after path extraction, tries to shortcut the path by attempting direct connections between non-adjacent vertices to smooth the final path.\n    - Time bound: total planning time capped to 10 seconds for robustness.\n    \n    The algorithm builds a tree from start, incrementally growing toward samples while maintaining a low-cost tree structure.",
          "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\nimport random\nimport time\nimport math\n\nfrom memory_profiler import profile\nfrom typing import TYPE_CHECKING, List, Tuple, Type, Any, Dict, Union, Optional\n\nfrom algorithms.basic_testing import BasicTesting\n\nfrom algorithms.algorithm import Algorithm\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\nfrom algorithms.classic.sample_based.core.graph import gen_cyclic_graph, CyclicGraph\n\nfrom algorithms.configuration.entities.agent import Agent\nfrom algorithms.configuration.entities.entity import Entity\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.entities.obstacle import Obstacle\nfrom algorithms.configuration.entities.trace import Trace\nfrom algorithms.configuration.maps.map import Map\nfrom algorithms.configuration.maps.ros_map import RosMap\nfrom algorithms.configuration.maps.bresenhams_algo import bresenhamline\n\nfrom simulator.services.services import Services\n\nfrom simulator.views.map.display.gradient_list_map_display import GradientListMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\n\nfrom structures import Point, Size, Colour, BLUE, DynamicColour\nfrom structures.factory import gen_set, gen_heap\nfrom structures.heap import Heap\n\n\n\nclass PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 15.0\n        self._goal_sample_rate = 0.1\n        self._rewire_radius = 20.0\n        self._iterations = 15000\n        self._time_limit = 10.0  # seconds\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling: with probability goal_sample_rate, sample goal directly\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _calculate_cost(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        return from_vertex.cost + self._get_grid().get_movement_cost(from_vertex.position, to_vertex.position)\n\n    def _choose_parent(self, q_new: Vertex, near_vertices: list) -> Vertex:\n        # Choose the vertex in near_vertices that yields the lowest cost path to q_new\n        min_cost = float('inf')\n        best_parent = None\n        for vertex in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(vertex.position, q_new.position)):\n                continue\n            cost = self._calculate_cost(vertex, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = vertex\n        if best_parent is None:\n            # No suitable parent found; fallback to nearest vertex (should rarely happen)\n            return None\n        q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: list) -> None:\n        for vertex in near_vertices:\n            if vertex == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, vertex.position)):\n                continue\n            new_cost = self._calculate_cost(q_new, vertex)\n            if new_cost < vertex.cost:\n                # Remove old parent edges to this vertex\n                for parent in list(vertex.parents):\n                    self._graph.remove_edge(parent, vertex)\n                self._graph.add_edge(q_new, vertex)\n                vertex.cost = new_cost\n\n    def _extract_path(self, q_end: Vertex) -> list:\n        # Trace path from q_end to start\n        path = [q_end]\n        current = q_end\n        while current.parents:\n            # choose the parent with lowest cost\n            next_vertex = min(current.parents, key=lambda v: v.cost)\n            path.append(next_vertex)\n            current = next_vertex\n        path.reverse()\n        return path\n\n    def _shortcut_path(self, path: list) -> list:\n        # Try to connect non-adjacent waypoints directly if valid to smooth the path\n        if len(path) <= 2:\n            return path  # No smoothing needed\n\n        shortened_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            # Find furthest reachable vertex from current vertex without invalid obstacles on line\n            next_idx = len(path) - 1\n            for check_idx in range(len(path) - 1, idx, -1):\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[check_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    next_idx = check_idx\n                    break\n            shortened_path.append(path[next_idx])\n            idx = next_idx\n        return shortened_path\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.perf_counter()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for i in range(self._iterations):\n            current_time = time.perf_counter()\n            if current_time - start_time > self._time_limit:\n                # Timeout, no path found\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n\n            dist_near_sample = Map.get_distance(q_near.position, q_sample)\n            max_dist = min(self._max_dist_base, dist_near_sample)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find vertices near q_new within a radius for choosing the best parent and rewiring\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n            # Include q_near if not in near_vertices (rare but possible)\n            if q_near not in near_vertices:\n                near_vertices.append(q_near)\n\n            parent_vertex = self._choose_parent(q_new, near_vertices)\n            if parent_vertex is None:\n                continue  # no valid parent found\n\n            self._graph.add_edge(parent_vertex, q_new)\n\n            # Rewire nearby vertices through q_new if it improves cost\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Extract and smooth path then move agent along path\n                path_vertices = self._extract_path(q_new)\n                path_vertices = self._shortcut_path(path_vertices)\n\n                for vertex in path_vertices:\n                    self.move_agent(vertex.position)\n                    self.key_frame(ignore_key_frame_skip=True)\n                break\n\n            self.key_frame()",
          "objective": 16648.025,
          "other_inf": null,
          "results": {
               "goal_found_perc": 90.0,
               "average_steps": 9.95,
               "average_distance": 10.46,
               "average_smoothness": 0.35,
               "average_clearance": 2.14,
               "average_time": 0.7738,
               "average_distance_from_goal": 0.97,
               "average_original_distance_from_goal": 8.42,
               "average memory": 59.09,
               "goal_found_perc_improvement": -7.53,
               "average_steps_improvement": -12.18,
               "average_distance_improvement": -12.11,
               "average_smoothness_improvement": -34.62,
               "average_clearance_improvement": 4.39,
               "average_time_improvement": -10500.0,
               "average_distance_from_goal_improvement": -385.0,
               "average_path_deviation": 1.1300000000000008,
               "average_memory_improvement": -58.76
          }
     },
     {
          "algorithm": "This algorithm is an improved and hybrid variant inspired by RRT* and goal-biased adaptive sampling with \n    heuristic guidance and rewiring for path optimization.\n\n    Main features:\n    - Adaptive max step size that decreases as vertices approach the goal for finer resolution.\n    - Goal-biased sampling with probability to sample goal directly to improve success rate.\n    - Rewiring nearby vertices to optimize cost and produce smoother, shorter paths.\n    - Early stopping criteria if path found or 10 seconds timeout exceeded.\n    - Final path smoothing by shortcutting invalid intermediate points.\n    - Uses Forest graph structure with vertices and edges, and pruning of suboptimal connections.\n    - Heuristic uses Euclidean distance for cost-to-go estimation.\n\n    This algorithm aims for balance between efficiency, path quality, robustness, and success rate,\n    by combining informed sampling, rewiring optimization, and dynamic step sizing.",
          "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\nimport random\nimport time\nimport math\n\nfrom memory_profiler import profile\nfrom typing import TYPE_CHECKING, List, Tuple, Type, Any, Dict, Union, Optional\n\nfrom algorithms.basic_testing import BasicTesting\n\nfrom algorithms.algorithm import Algorithm\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\nfrom algorithms.classic.sample_based.core.graph import gen_cyclic_graph, CyclicGraph\n\nfrom algorithms.configuration.entities.agent import Agent\nfrom algorithms.configuration.entities.entity import Entity\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.entities.obstacle import Obstacle\nfrom algorithms.configuration.entities.trace import Trace\nfrom algorithms.configuration.maps.map import Map\nfrom algorithms.configuration.maps.ros_map import RosMap\nfrom algorithms.configuration.maps.bresenhams_algo import bresenhamline\n\nfrom simulator.services.services import Services\n\nfrom simulator.views.map.display.gradient_list_map_display import GradientListMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\n\nfrom structures import Point, Size, Colour, BLUE, DynamicColour\nfrom structures.factory import gen_set, gen_heap\nfrom structures.heap import Heap\n\n\n\nclass PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True  # Allow rewiring/removing edges\n        self._max_initial_dist = 15.0\n        self._goal_sample_rate = 0.2  # 20% samples from goal\n        self._rewire_radius = 20.0\n        self._max_iterations = 5000\n        self._init_displays()\n        \n\n    def _get_random_sample(self) -> Point:\n        import random\n\n        if random.random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Optional[Vertex]:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist == 0:\n            return None\n        if dist <= max_dist:\n            new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / dist\n            new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n\n        if not self._get_grid().is_agent_valid_pos(new_pos):\n            return None\n\n        return Vertex(new_pos)\n\n    def _cost(self, vertex_from: Vertex, vertex_to: Vertex) -> float:\n        return self._get_grid().get_movement_cost(vertex_from.position, vertex_to.position)\n\n    def _heuristic(self, v: Vertex) -> float:\n        return Map.get_distance(v.position, self._get_grid().goal.position)\n\n    def _choose_parent(self, q_new: Vertex, near_vertices: List[Vertex]) -> Optional[Vertex]:\n        min_cost = float('inf')\n        best_parent = None\n\n        for q_near in near_vertices:\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                new_cost = q_near.cost + self._cost(q_near, q_new)\n                if new_cost < min_cost:\n                    min_cost = new_cost\n                    best_parent = q_near\n\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]):\n        for q_near in near_vertices:\n            if q_near == q_new.parents:\n                continue\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                existing_cost = q_near.cost\n                new_cost = q_new.cost + self._cost(q_new, q_near)\n                if new_cost < existing_cost:\n                    # Remove old parent edge(s)\n                    for p in list(q_near.parents):\n                        self._graph.remove_edge(p, q_near)\n                    # Add new edge\n                    self._graph.add_edge(q_new, q_near)\n                    q_near.cost = new_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Vertex]:\n        path = []\n        current = goal_vertex\n        while current.parents:\n            path.append(current)\n            current = next(iter(current.parents))\n        path.append(current)  # add root/start vertex\n        path.reverse()\n        return path\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        if not path or len(path) <= 2:\n            return path\n\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(path[i].position, path[j].position)):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        max_dist = self._max_initial_dist\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n\n        found_goal = False\n\n        for _ in range(self._max_iterations):\n\n            # Timeout check\n            if time.time() - start_time > 10.0:\n                # Fail: No path found within 10 seconds\n                break\n\n            q_sample: Point = self._get_random_sample()\n\n            # Adaptive max_dist, reduce near goal for finer resolution\n            dist_to_goal = Map.get_distance(q_sample, goal_vertex.position)\n            adaptive_max_dist = max(3.0, max_dist * (dist_to_goal / max_dist))  # between 3 and max_dist\n\n            q_near: Vertex = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Optional[Vertex] = self._get_new_vertex(q_near, q_sample, adaptive_max_dist)\n            if q_new is None:\n                continue\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Get vertices near q_new within rewire radius\n            near_vertices: List[Vertex] = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n\n            # Choose best parent minimizing cost to q_new\n            best_parent: Optional[Vertex] = self._choose_parent(q_new, near_vertices)\n            if best_parent is None:\n                # Fallback to q_near if no better parent\n                best_parent = q_near\n                q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire near vertices to optimize their cost (if improved by connecting through q_new)\n            self._rewire(q_new, near_vertices)\n\n            # Add q_new to graph root_vertices list for next iterations\n            self._graph.root_vertices.append(q_new)\n\n            self.key_frame()\n\n            # Check if q_new reached goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new directly to goal vertex if valid\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)):\n                    goal_vertex.cost = q_new.cost + self._cost(q_new, goal_vertex)\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    # Extract and shortcut path\n                    path_vertices: List[Vertex] = self._extract_path(goal_vertex)\n                    path_vertices = self._shortcut_path(path_vertices)\n\n                    # Animate path\n                    for vertex in path_vertices:\n                        self.move_agent(vertex.position)\n                        self.key_frame(ignore_key_frame_skip=True)\n\n                    found_goal = True\n                    break\n\n        if not found_goal:\n            # If no path found, consider fallback or do nothing\n            pass",
          "objective": 17603.095,
          "other_inf": null,
          "results": {
               "goal_found_perc": 93.33,
               "average_steps": 9.68,
               "average_distance": 10.24,
               "average_smoothness": 0.34,
               "average_clearance": 2.09,
               "average_time": 0.8356,
               "average_distance_from_goal": 0.63,
               "average_original_distance_from_goal": 8.42,
               "average memory": 107.56,
               "goal_found_perc_improvement": -4.11,
               "average_steps_improvement": -8.4,
               "average_distance_improvement": -8.82,
               "average_smoothness_improvement": -30.77,
               "average_clearance_improvement": 2.96,
               "average_time_improvement": -11191.89,
               "average_distance_from_goal_improvement": -215.0,
               "average_path_deviation": 0.8300000000000001,
               "average_memory_improvement": -188.98
          }
     },
     {
          "algorithm": "This algorithm is an improved sample-based planner combining goal-biased Adaptive RRT* with heuristic-guided rewiring and adaptive step sizing.\n    It uses a dynamic goal-biased sampling strategy to focus samples towards the goal (with increasing probability),\n    employs an adaptive step size based on current vertex density,\n    and a heuristic cost-to-go to improve tree extension decisions.\n    The rewiring step optimizes path quality during growth similarly to RRT*.\n    Additionally, it includes a shortcut smoothing procedure after path discovery.\n    An early stopping criterion is enforced with a 10 seconds max runtime to increase efficiency and success rate.\n    The algorithm utilizes Forest for tree structure, reuses helper functions, and integrates the Map environment effectively.",
          "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\nimport random\nimport time\nimport math\n\nfrom memory_profiler import profile\nfrom typing import TYPE_CHECKING, List, Tuple, Type, Any, Dict, Union, Optional\n\nfrom algorithms.basic_testing import BasicTesting\n\nfrom algorithms.algorithm import Algorithm\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\nfrom algorithms.classic.sample_based.core.graph import gen_cyclic_graph, CyclicGraph\n\nfrom algorithms.configuration.entities.agent import Agent\nfrom algorithms.configuration.entities.entity import Entity\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.entities.obstacle import Obstacle\nfrom algorithms.configuration.entities.trace import Trace\nfrom algorithms.configuration.maps.map import Map\nfrom algorithms.configuration.maps.ros_map import RosMap\nfrom algorithms.configuration.maps.bresenhams_algo import bresenhamline\n\nfrom simulator.services.services import Services\n\nfrom simulator.views.map.display.gradient_list_map_display import GradientListMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\n\nfrom structures import Point, Size, Colour, BLUE, DynamicColour\nfrom structures.factory import gen_set, gen_heap\nfrom structures.heap import Heap\n\n\n\nclass PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_radius = 50\n        self._dimension = self._get_grid().size.n_dim\n        self._lambda_rrt_star = 50\n        self._initial_max_dist = 15\n        self._goal_sample_rate = 0.2  # initial goal bias rate\n        self._timeout_sec = 10\n\n        self._init_displays()\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_random_sample(self, goal_bias_prob: float = 0.0) -> Point:\n        # Goal biased sampling: with goal_bias_prob probability sample the goal position, else uniform random\n        if torch.rand(1).item() < goal_bias_prob:\n            return self._get_grid().goal.position\n        while True:\n            sample_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._dimension)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        diff = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(diff)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        direction = diff / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * direction)\n        return Vertex(new_pos)\n\n    def _heuristic_cost(self, vertex_pos: Point) -> float:\n        # Euclidean distance heuristic cost to goal:\n        return Map.get_distance(vertex_pos, self._get_grid().goal.position)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = []\n        curr = q_goal\n        while len(curr.parents) != 0:\n            path.append(curr)\n            # Single parent assumed or pick any parent (first)\n            curr = next(iter(curr.parents))\n        path.append(curr)  # Append start vertex\n        path.reverse()\n\n        # Shortcut smoothing after extraction\n        smoothed_path = self._smooth_path(path)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            # Support ROS waypoint publishing if applicable\n            grid = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _smooth_path(self, path: list) -> list:\n        # Attempt shortcuts between non-consecutive vertices if collision-free\n        if len(path) <= 2:\n            return path\n\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(smoothed[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    smoothed.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # no shortcut found, advance by one\n                smoothed.append(path[i + 1])\n                i += 1\n        return smoothed\n\n    def _adaptive_max_dist(self) -> float:\n        # Adaptive max_dist based on number of vertices (more vertices => smaller max_dist)\n        count = max(1, self._graph.size)\n        max_dist = self._initial_max_dist * (1.0 / (count ** 0.3))\n        return max(3.0, min(max_dist, self._initial_max_dist))\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        max_iterations = 5000\n        iteration = 0\n        goal_found = False\n\n        while iteration < max_iterations:\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout_sec:\n                # Timeout reached\n                break\n\n            # Adaptive goal bias: increase towards max 0.5 with iterations\n            goal_bias = min(0.5, self._goal_sample_rate + iteration / max_iterations * 0.3)\n            q_sample = self._get_random_sample(goal_bias)\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                iteration += 1\n                continue\n\n            max_dist = self._adaptive_max_dist()\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check if path from q_nearest -> q_new is valid\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                iteration += 1\n                continue\n\n            # Cost calculations\n            c_nearest = q_nearest.cost\n            if c_nearest is None:\n                c_nearest = float(\"inf\")\n            dist_nearest_new = torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = c_nearest + dist_nearest_new\n\n            # Compute rewiring radius dynamically\n            card_V = max(float(self._graph.size), 1.0)\n            log_V = torch.log(torch.tensor(card_V))\n            radius = min(self._lambda_rrt_star * ((log_V / card_V) ** (1 / self._dimension)), self._max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_new.cost\n\n            # Choose parent minimizing cost + heuristic (A* style)\n            for q_near in Q_near:\n                line_seq_candidate = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_candidate):\n                    continue\n                cost_candidate = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                heuristic = self._heuristic_cost(q_new.position)\n                if cost_candidate + heuristic < c_min + self._heuristic_cost(q_min.position):\n                    q_min = q_near\n                    c_min = cost_candidate\n\n            # Add edge from best parent found (q_min) to q_new\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire nearby vertices if better cost found through q_new\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                line_seq_near_qnew = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_near_qnew):\n                    continue\n                cost_through_new = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if cost_through_new < q_near.cost:\n                    # Remove old edge\n                    parent_to_remove = next(iter(q_near.parents), None)\n                    if parent_to_remove is not None:\n                        self._graph.remove_edge(parent_to_remove, q_near)\n                    q_near.cost = None\n                    # Add new edge\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check goal reached within goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                goal_found = True\n                break\n\n            iteration += 1\n            self.key_frame()\n\n        if not goal_found:\n            # Path not found - can optionally mark or handle here\n            pass",
          "objective": 18186.185,
          "other_inf": null,
          "results": {
               "goal_found_perc": 92.0,
               "average_steps": 10.56,
               "average_distance": 11.18,
               "average_smoothness": 0.33,
               "average_clearance": 2.17,
               "average_time": 0.8738,
               "average_distance_from_goal": 0.73,
               "average_original_distance_from_goal": 8.42,
               "average memory": 92.09,
               "goal_found_perc_improvement": -5.48,
               "average_steps_improvement": -18.25,
               "average_distance_improvement": -19.06,
               "average_smoothness_improvement": -26.92,
               "average_clearance_improvement": 6.37,
               "average_time_improvement": -11550.67,
               "average_distance_from_goal_improvement": -265.0,
               "average_path_deviation": 1.7899999999999991,
               "average_memory_improvement": -147.42
          }
     },
     {
          "algorithm": "This algorithm is an improved sample-based planner combining goal-biased sampling,\n    adaptive step size control, heuristic-guided expansion, and path shortcutting. \n    Unlike classic RRT* or SPRM, it uses dynamic max step sizes adjusted by proximity to obstacles,\n    and adaptive sampling probability to bias samples increasingly toward the goal over time.\n    It maintains a Forest graph for connectivity and rewiring to optimize path costs.\n    A post-processing shortcutting step attempts to smooth the final path by shortcutting across\n    obstacle-free line sequences. Additionally, early stopping occurs at successful low-cost paths\n    or if path search exceeds 10 seconds to improve efficiency and robustness.",
          "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\nimport random\nimport time\nimport math\n\nfrom memory_profiler import profile\nfrom typing import TYPE_CHECKING, List, Tuple, Type, Any, Dict, Union, Optional\n\nfrom algorithms.basic_testing import BasicTesting\n\nfrom algorithms.algorithm import Algorithm\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\nfrom algorithms.classic.sample_based.core.graph import gen_cyclic_graph, CyclicGraph\n\nfrom algorithms.configuration.entities.agent import Agent\nfrom algorithms.configuration.entities.entity import Entity\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.entities.obstacle import Obstacle\nfrom algorithms.configuration.entities.trace import Trace\nfrom algorithms.configuration.maps.map import Map\nfrom algorithms.configuration.maps.ros_map import RosMap\nfrom algorithms.configuration.maps.bresenhams_algo import bresenhamline\n\nfrom simulator.services.services import Services\n\nfrom simulator.views.map.display.gradient_list_map_display import GradientListMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\n\nfrom structures import Point, Size, Colour, BLUE, DynamicColour\nfrom structures.factory import gen_set, gen_heap\nfrom structures.heap import Heap\n\n\n\nclass PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n        # Added members for adaptive sampling and timing\n        import time\n        self._start_time = None\n        self._max_iterations = 8000\n        self._base_max_step = 15\n        self._goal_sample_bias_start = 0.1\n        self._goal_sample_bias_end = 0.6\n        self._goal_sample_bias_increase_rate = (self._goal_sample_bias_end - self._goal_sample_bias_start) / self._max_iterations\n\n    def _get_adaptive_goal_sample_prob(self, iter_num: int) -> float:\n        # Linearly increase goal bias sampling probability during iterations\n        prob = self._goal_sample_bias_start + self._goal_sample_bias_increase_rate * iter_num\n        return min(prob, self._goal_sample_bias_end)\n\n    def _get_dynamic_max_step(self, current_pos: Point) -> float:\n        # Estimate distance to nearest obstacle boundary for adaptive step size\n        # Inflate by factor to ensure robust step size (minimum 5)\n        min_dist = 20.0\n        for obs in self._get_grid().obstacles:\n            obs_bound = self._get_grid().get_obstacle_bound(obs.position)\n            for p in obs_bound:\n                dist = Map.get_distance(current_pos, p)\n                if dist < min_dist:\n                    min_dist = dist\n        return max(5.0, min(self._base_max_step, min_dist * 0.6))\n\n    def _heuristic_cost(self, from_pos: Point, to_pos: Point) -> float:\n        # Euclidean distance heuristic used as cost estimate\n        return Map.get_distance(from_pos, to_pos)\n\n    def _get_random_sample(self, iteration: int) -> Point:\n        import random\n        prob_goal = self._get_adaptive_goal_sample_prob(iteration)\n        if random.random() < prob_goal:\n            return self._get_grid().goal.position  # goal biasing\n        else:\n            while True:\n                sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dir_norm\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut path by connecting non-consecutive points directly if feasible\n        if len(path) < 3:\n            return path\n        i = 0\n        while i < len(path) - 2:\n            j = len(path) - 1\n            shortcut_found = False\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove intermediate vertices between i and j\n                    del path[i + 1:j]\n                    shortcut_found = True\n                    break\n                j -= 1\n            if not shortcut_found:\n                i += 1\n        return path\n\n    def _extract_path(self, goal_vertex: Vertex):\n        path: List[Vertex] = [goal_vertex]\n        while len(path[-1].parents) != 0:\n            # Just pick the first parent (minimal cost tree)\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n        path.reverse()\n\n        # Path shortcutting for smoother path\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid: Map = self._get_grid()\n            # Publish waypoint for ROS extension if applicable\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        self._start_time = time.time()\n\n        max_dist_Default = self._base_max_step\n        iterations = self._max_iterations\n        dimension = self._get_grid().size.n_dim\n        lambda_rrt_star = 50\n        max_radius = 40.0\n\n        start_vertex = self._graph.root_vertex_start\n        goal_point = self._get_grid().goal.position\n\n        for i in range(iterations):\n            # Early stop if >10 seconds elapsed\n            current_time = time.time()\n            if current_time - self._start_time > 10.0:\n                # Timeout no path found within time budget\n                break\n\n            q_sample = self._get_random_sample(i)\n            q_nearest = self._get_nearest_vertex(q_sample)\n\n            # If sample equals nearest vertex, skip\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive step size depends on proximity to obstacles\n            max_dist = self._get_dynamic_max_step(q_nearest.position)\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check path collision-free\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Calculate rewiring radius based on number of vertices\n            card_v = torch.tensor(float(self._graph.size if self._graph.size > 0 else 1))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with minimum cost + edge cost\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._heuristic_cost(q_nearest.position, q_new.position)\n            for q_near in neighbors:\n                near_to_new_line = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(near_to_new_line):\n                    c_near_to_new = q_near.cost + self._heuristic_cost(q_near.position, q_new.position)\n                    if c_near_to_new < c_min:\n                        q_min = q_near\n                        c_min = c_near_to_new\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors through q_new if cost improves\n            for q_near in neighbors:\n                new_to_near_line = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if self._get_grid().is_valid_line_sequence(new_to_near_line):\n                    cost_via_new = q_new.cost + self._heuristic_cost(q_new.position, q_near.position)\n                    if cost_via_new < q_near.cost:\n                        # Remove old parent edge\n                        old_parent = None\n                        for parent in q_near.parents:\n                            old_parent = parent\n                            break\n                        if old_parent is not None:\n                            self._graph.remove_edge(old_parent, q_near)\n                        # Add new parent edge\n                        q_near.cost = cost_via_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check if goal is reached within goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Add goal edge, cost and extract path\n                goal_vertex = Vertex(goal_point)\n                dist_to_goal = self._heuristic_cost(q_new.position, goal_point)\n                goal_vertex.cost = q_new.cost + dist_to_goal\n                self._graph.add_edge(q_new, goal_vertex)\n\n                self._extract_path(goal_vertex)\n                return\n\n            self.key_frame()\n\n        # If here, no path found in time and iteration limits\n        return",
          "objective": Infinity,
          "other_inf": null,
          "results": {}
     }
]