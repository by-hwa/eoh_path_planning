[
     {
          "algorithm": "This is the RRT algorithm, a sample-based pathfinding algorithm that explores the space by randomly sampling points and connecting them to the nearest vertex.",
          "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\n\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.basic_testing import BasicTesting\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\n\nfrom simulator.services.services import Services\n\nfrom structures import Point\n\n\nclass RRT(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        if torch.norm(dir) <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / torch.norm(dir)\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_new):\n\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)    #connect the last sampled point that's close to goal vertex and connet point to goal vertex with edge\n        path: List[Vertex] = [goal_v]    \n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        #get animation of path tracing from start to goal\n        for p in path:\n            self.move_agent(p.position)   \n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n\n        max_dist: float = 10\n        iterations: int = 10000\n\n        for i in range(iterations):\n\n            q_sample: Point = self._get_random_sample()     #sample a random point and return it if it's in valid position\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample) \n            if q_near.position == q_sample:\n                continue    #restart the while loop right away if sample point same as nearest vertex point\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)    #get new vertex\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):    \n                continue    #restart the while loop right away if the straight line path from nearest vertex to new sample point is invalid \n            self._graph.add_edge(q_near, q_new)    #add edge between 2 points\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):    #if agent is in goal radius, then run _extract_path method \n                self._extract_path(q_new)\n                break\n\n            self.key_frame()    #add the new vertex and edge if the new sample point is not at goal yet\n",
          "objective": 0,
          "other_inf": null
     },
     {
          "algorithm": "\"\"\"\n    An improved path planning algorithm inspired by RRT*-like incremental tree expansion with\n    heuristic guidance and memory-efficient data management. To reduce memory usage, this \n    variant maintains a flat list of vertices instead of extensive graph connectivity sets \n    and limits the number of stored vertices dynamically. Vertex rewiring is restricted to \n    a dynamically shrinking radius adapted to current environment resolution and vertex density,\n    improving planning efficiency and path quality. It uses goal-biased and heuristic sampling \n    combined with adaptive step sizing, and terminates on success or timeout (~10s). Path \n    extraction includes shortcut smoothing for better final path quality.\n    \"\"\"",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\"\n    An improved path planning algorithm inspired by RRT*-like incremental tree expansion with\n    heuristic guidance and memory-efficient data management. To reduce memory usage, this \n    variant maintains a flat list of vertices instead of extensive graph connectivity sets \n    and limits the number of stored vertices dynamically. Vertex rewiring is restricted to \n    a dynamically shrinking radius adapted to current environment resolution and vertex density,\n    improving planning efficiency and path quality. It uses goal-biased and heuristic sampling \n    combined with adaptive step sizing, and terminates on success or timeout (~10s). Path \n    extraction includes shortcut smoothing for better final path quality.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._max_dist_base = 15.0\n        self._goal_bias = 0.15        # Slightly higher goal bias for focused sampling\n        self._rewire_radius = 15.0    # Shrinking rewire radius for better memory\n        self._vertex_limit = 1500     # Limit max vertices for memory efficiency\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_goal_biased_sample(self) -> Point:\n        import random\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            attempts = 0\n            while attempts < 50:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n                attempts += 1\n            # fallback to goal if sampling fails repeatedly\n            return self._get_grid().goal.position\n\n    def _choose_parent(self, near_vertices: list, q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: list, q_new: Vertex) -> None:\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                # Remove all existing parents to reduce memory usage\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path = [q_goal]\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n        smoothed = self._shortcut_path(path)\n        for v in smoothed:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _decrease_rewire_radius(self, iteration: int, max_iterations: int) -> float:\n        \"\"\"Shrink rewire radius over time for efficiency and memory.\"\"\"\n        min_radius = 5.0\n        radius = self._rewire_radius * (1.0 - iteration / max_iterations)\n        return max(radius, min_radius)\n\n    def _limit_graph_size(self) -> None:\n        \"\"\"Limit max vertex count in graph for memory efficiency by pruning farthest or high cost vertices.\"\"\"\n        max_verts = self._vertex_limit\n        if self._graph.size <= max_verts:\n            return\n        # Sort vertices by cost descending, skip root start and goal\n        vertices = [v for v in self._graph.root_vertices if v != self._graph.root_vertex_start and v != self._graph.root_vertex_goal]\n        vertices = sorted(vertices, key=lambda v: v.cost, reverse=True)\n        remove_count = self._graph.size - max_verts\n        to_remove = vertices[:remove_count]\n        for v in to_remove:\n            # Remove all edges to/from vertex to prune it\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            # Remove vertex from roots if present\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n        # Rebuild size count\n        self._graph.size = len(self._graph.root_vertices)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        start_time = time.time()\n        max_iterations = 8000\n        max_dist_base = self._max_dist_base\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout exit\n                break\n\n            q_sample = self._get_goal_biased_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            adaptive_step = min(max_dist_base, dist_to_sample)\n\n            # Further adapt step based on costs to encourage finer exploration near obstacles or goal\n            adaptive_step *= 0.7 + 0.3 * (1 - min(q_near.cost / 100.0, 1.0))\n\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_step)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Shrinking rewire radius to save memory and speed later on\n            cur_rewire_radius = self._decrease_rewire_radius(iteration, max_iterations)\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, cur_rewire_radius)\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                # Fallback to nearest vertex if viable\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            self._rewire(near_vertices, q_new)\n\n            # Prune to keep memory low if vertices grow large\n            self._limit_graph_size()\n\n            # Check goal proximity with radius for early success\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                q_goal = Vertex(goal_pos)\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, q_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            self.key_frame()",
          "objective": 3730.24,
          "other_inf": null,
          "results": {
               "goal_found_perc": 97.33,
               "average_steps": 10.32,
               "average_distance": 10.94,
               "average_smoothness": 0.35,
               "average_clearance": 2.1,
               "average_time": 0.1889,
               "average_distance_from_goal": 0.2,
               "average_original_distance_from_goal": 8.42,
               "average memory": 60.63,
               "goal_found_perc_improvement": 0.0,
               "average_steps_improvement": -12.91,
               "average_distance_improvement": -13.25,
               "average_smoothness_improvement": -34.62,
               "average_clearance_improvement": 5.0,
               "average_time_improvement": -2385.53,
               "average_distance_from_goal_improvement": -0.0,
               "average_path_deviation": 1.2799999999999994,
               "average_memory_improvement": -62.85
          }
     },
     {
          "algorithm": "This algorithm is an improved path planner inspired by RRT* and heuristic-guided sampling.\n    It uses adaptive step size and goal-biased sampling to speed up exploration.\n    The algorithm incrementally builds a tree with rewiring to optimize path cost (like RRT*),\n    reuses a radius-based neighborhood search to improve connectivity and smoothness,\n    and employs a heuristic based on Euclidean distance to goal to guide sampling.\n    During path extraction, it attempts path shortcutting to smoothen it.\n    To ensure responsiveness, search is limited to 10 seconds.",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_dist_base: float\n    _goal_bias: float\n    _rewire_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edge rewiring (optimization)\n        self._init_displays()\n\n        self._max_dist_base = 15.0  # Base max extending distance (can adapt)\n        self._goal_bias = 0.1       # Probability to sample goal directly\n        self._rewire_radius = 20.0  # Neighborhood radius for rewiring\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_goal_biased_sample(self) -> Point:\n        # With probability goal_bias, sample the goal; otherwise random valid sample\n        import random\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _near_vertices(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        # Return all vertices within radius of point in given list\n        near_vert = []\n        radius_sq = radius * radius\n        for v in vertices:\n            if Map.get_distance(v.position, point) <= radius:\n                near_vert.append(v)\n        return near_vert\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        # Cost equivalently distance plus movement cost from grid (might consider obstacles implicitly)\n        dist = Map.get_distance(frm.position, to.position)\n        # Movement cost from grid between positions (may differ if terrain)\n        move_cost = self._get_grid().get_movement_cost(frm.position, to.position)\n        return dist + move_cost\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose best parent vertex minimizing cost to q_new + movement cost, only if line valid\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            cost = v.cost + self._cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        # Try to rewire the tree to use q_new as intermediate for near vertices if it reduces cost\n        for v in near_vertices:\n            if v == q_new or v == self._graph.root_vertex_start:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, v)\n            if cost_through_qnew < v.cost:\n                # Remove old parent edges, add new edge from q_new\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut path by skipping intermediate vertices if direct line is valid\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            # Decrease j until direct connection is valid\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n        # Backtrack to root start by best parent chain (assume single parent tree)\n        current = q_goal\n        while current != self._graph.root_vertex_start:\n            if not current.parents:\n                break  # no path\n            # Choose the parent with minimal cost (should be single due to rewiring but safe check)\n            parent = min(current.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current = parent\n        path.reverse()\n\n        # Shortcut smoothing\n        smoothed_path = self._shortcut_path(path)\n\n        for p in smoothed_path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n\n        max_iterations = 10000\n        max_dist = self._max_dist_base\n        goal_pos = self._get_grid().goal.position\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for i in range(max_iterations):\n            # Timeout check\n            if time.time() - start_time > 10.0:\n                # Give up on path finding (not found in time)\n                break\n\n            q_sample = self._get_goal_biased_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive max_dist based on distance to sample\n            dist_to_sample = Map.get_distance(q_near.position, q_sample)\n            step = min(max_dist, dist_to_sample)\n\n            q_new = self._get_new_vertex(q_near, q_sample, step)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Find near vertices for rewiring (within radius)\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n\n            # Choose best parent to connect q_new with\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                # No suitable parent found, try q_near as fallback\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    q_new.cost = q_near.cost + self._cost(q_near, q_new)\n                    best_parent = q_near\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors to q_new if it improves cost\n            self._rewire(near_vertices, q_new)\n\n            # Check goal reached\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position, goal=self._get_grid().goal):\n                # Connect final goal vertex\n                q_goal = Vertex(goal_pos)\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_goal.position)):\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            self.key_frame()",
          "objective": 4120.16,
          "other_inf": null,
          "results": {
               "goal_found_perc": 97.33,
               "average_steps": 10.27,
               "average_distance": 10.93,
               "average_smoothness": 0.33,
               "average_clearance": 2.09,
               "average_time": 0.2083,
               "average_distance_from_goal": 0.2,
               "average_original_distance_from_goal": 8.42,
               "average memory": 63.1,
               "goal_found_perc_improvement": 0.0,
               "average_steps_improvement": -12.36,
               "average_distance_improvement": -13.15,
               "average_smoothness_improvement": -26.92,
               "average_clearance_improvement": 4.5,
               "average_time_improvement": -2640.79,
               "average_distance_from_goal_improvement": -0.0,
               "average_path_deviation": 1.2699999999999996,
               "average_memory_improvement": -69.49
          }
     }
]