[
     {
          "algorithm": "This is the RRT algorithm, a sample-based pathfinding algorithm that explores the space by randomly sampling points and connecting them to the nearest vertex.",
          "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\n\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.basic_testing import BasicTesting\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\n\nfrom simulator.services.services import Services\n\nfrom structures import Point\n\n\nclass RRT(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        if torch.norm(dir) <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / torch.norm(dir)\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_new):\n\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)    #connect the last sampled point that's close to goal vertex and connet point to goal vertex with edge\n        path: List[Vertex] = [goal_v]    \n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        #get animation of path tracing from start to goal\n        for p in path:\n            self.move_agent(p.position)   \n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n\n        max_dist: float = 10\n        iterations: int = 10000\n\n        for i in range(iterations):\n\n            q_sample: Point = self._get_random_sample()     #sample a random point and return it if it's in valid position\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample) \n            if q_near.position == q_sample:\n                continue    #restart the while loop right away if sample point same as nearest vertex point\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)    #get new vertex\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):    \n                continue    #restart the while loop right away if the straight line path from nearest vertex to new sample point is invalid \n            self._graph.add_edge(q_near, q_new)    #add edge between 2 points\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):    #if agent is in goal radius, then run _extract_path method \n                self._extract_path(q_new)\n                break\n\n            self.key_frame()    #add the new vertex and edge if the new sample point is not at goal yet\n",
          "objective": 0,
          "other_inf": null
     },
     {
          "algorithm": "This is the SPRM algorithm, a sample-based pathfinding algorithm that uses a cyclic graph to find a path from the agent to the goal.",
          "code": "\nfrom typing import List\n\nimport torch\n\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.basic_testing import BasicTesting\nfrom simulator.services.services import Services\nfrom structures import Point\n\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_cyclic_graph, CyclicGraph\n\n\nclass SPRM(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 15\n        V: List[Vertex] = list()\n        for i in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _near(self, vertex: Vertex) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, self._max_radius)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        if torch.norm(dir) <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / torch.norm(dir)\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _extract_path(self):\n\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        current_vertex = agent\n        path = list()\n        while current_vertex is not goal:\n            current_vertex = current_vertex.connectivity[goal]\n            path.append(current_vertex)\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n\n        for i, v in enumerate(self._graph.root_vertices):\n            U = self._near(v)\n            for u in U:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(u.position, v.position)):\n                    if v is not u:\n                        self._graph.add_edge(v, u)\n                        self._graph.add_edge(u, v)\n                    self.key_frame()\n                    if self._graph.root_vertices[1] in self._graph.root_vertices[0].connectivity:\n                        self._extract_path()\n                        return\n",
          "objective": 0,
          "other_inf": null
     },
     {
          "algorithm": "This is the RRT* algorithm, an optimized version of RRT that finds the shortest path by rewiring the tree as it grows.",
          "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\n\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.basic_testing import BasicTesting\nfrom simulator.services.services import Services\nfrom structures import Point\nfrom algorithms.configuration.maps.ros_map import RosMap\nfrom algorithms.configuration.maps.map import Map\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\n\n\nclass RRT_Star(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / torch.norm(dir)\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _extract_path(self, q_new):\n\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            #sends waypoint for ros extension\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        for i in range(iterations):\n\n            q_sample: Point = self._get_random_sample()\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star*((log_card_v/card_v)**(1/dimension)),max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    q_near.cost = None\n                    self._graph.remove_edge(q_parent, q_near)\n                    child_parent_dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                    q_near.cost = q_new.cost + child_parent_dist\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()\n\n",
          "objective": 0,
          "other_inf": null
     },
     {
          "algorithm": "This is the RRT-Connect algorithm, a sample-based pathfinding algorithm that connects two trees to find a path.",
          "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\n\nfrom memory_profiler import profile\n\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.basic_testing import BasicTesting\nfrom simulator.services.services import Services\nfrom structures import Point\n\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\n\nn=0\n\nclass RRT_Connect(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n        \n        self._max_dist = 10\n        self._iterations = 10000\n\n    # Helper Functions #\n    # -----------------#\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        self._q_near: Vertex = self._get_nearest_vertex(root_vertex, q)\n        self._q_new: Vertex = self._get_new_vertex(self._q_near, q, self._max_dist)\n        if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)):\n            self._graph.add_edge(self._q_near, self._q_new)\n            if self._q_new.position == q:\n                return 'reached'\n            else:\n                return 'advanced'\n        return 'trapped'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        S = 'advanced'\n        while S == 'advanced':\n            S = self._extend(root_vertex, q.position)\n        self._mid_vertex = q\n        return S\n\n    def _extract_path(self):\n\n        # trace back\n        path_mid_to_b: List[Vertex] = [self._q_new]\n\n        while len(path_mid_to_b[-1].parents) != 0:\n            for parent in path_mid_to_b[-1].parents:\n                path_mid_to_b.append(parent)\n                break\n\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n\n        while len(path_a_to_mid[-1].parents) != 0:\n            for parent in path_a_to_mid[-1].parents:\n                path_a_to_mid.append(parent)\n                break\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, graph_root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([graph_root_vertex], q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        if torch.norm(dir) <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / torch.norm(dir)\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    #@profile\n    def _find_path_internal(self) -> None:\n\n        for i in range(self._iterations):\n            global n \n            n+=1\n\n            if n == 100:\n                break\n\n            q_rand: Point = self._get_random_sample()\n\n            if not self._extend(self._graph.root_vertices[0], q_rand) == 'trapped':\n                self._extension_target = self._q_new\n                if self._connect(self._graph.root_vertices[-1], self._q_new) == 'reached':\n                    self._extract_path()\n                    break\n            self._graph.reverse_root_vertices()\n\n            # visualization code\n            self.key_frame()\n",
          "objective": 0,
          "other_inf": null
     }
]