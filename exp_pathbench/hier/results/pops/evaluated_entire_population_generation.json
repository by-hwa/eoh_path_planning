Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0071,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.22
}
{heur3
     "algorithm": "Improved path planning algorithm combining RRT* with goal biasing, adaptive step size,\n    and rewiring to improve path quality and success rate.\n\n    Key features:\n    - Goal-biased sampling to guide exploration towards the goal efficiently.\n    - Adaptive max_dist step size based on distance to goal and local obstacles.\n    - Rewiring of the graph to optimize path cost and produce shorter, smoother paths.\n    - Early stopping if solution found or after 10 seconds to limit planning time.\n    - Uses helper functions for modular design: sampling, extending, rewiring, and path extraction.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring/removal of edges\n        self._max_dist_base = 10  # Base max extension distance\n        self._goal_bias_prob = 0.2  # Probability of sampling goal directly\n        self._rewire_radius = 20.0  # Radius for rewiring neighbors\n        self._max_time = 10.0  # Maximum allowed planning time in seconds\n        self._init_displays()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        iterations = 10000\n\n        for i in range(iterations):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > self._max_time:\n                # Timeout: fail gracefully\n                break\n\n            # Sampling with goal bias\n            q_sample: Point = self._biased_random_sample()\n\n            # Nearest existing vertex in the tree\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive max_dist based on distance and environment\n            max_dist: float = self._adaptive_max_dist(q_near.position, q_sample)\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Insert q_new into the graph with cost update\n            self._graph.add_edge(q_near, q_new)\n\n            mov_cost = self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            if mov_cost is None:\n                mov_cost = float('inf')\n            q_new.cost = (q_near.cost if q_near.cost is not None else float('inf')) + mov_cost\n\n            # Rewiring step to optimize path locally (RRT*)\n            neighbors: list[Vertex] = self._graph.get_vertices_within_radius([self._graph.root_vertex_start],\n                                                                            q_new.position,\n                                                                            self._rewire_radius)\n            for q_near_candidate in neighbors:\n                if q_near_candidate == q_near:\n                    continue\n                candidate_line = self._get_grid().get_line_sequence(q_near_candidate.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(candidate_line):\n                    continue\n                mov_cost = self._get_grid().get_movement_cost(q_near_candidate.position, q_new.position)\n                if mov_cost is None:\n                    continue\n                q_near_cost = q_near_candidate.cost if q_near_candidate.cost is not None else float('inf')\n                cost_through_candidate = q_near_cost + mov_cost\n                if cost_through_candidate < q_new.cost:\n                    # Rewire q_new to q_near_candidate\n                    self._graph.remove_edge(q_near, q_new)\n                    self._graph.add_edge(q_near_candidate, q_new)\n                    q_new.cost = cost_through_candidate\n                    q_near = q_near_candidate\n\n            # Also try rewiring neighbors through q_new for better paths\n            for neighbor in neighbors:\n                if neighbor == q_new:\n                    continue\n                rewiring_line = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if not self._get_grid().is_valid_line_sequence(rewiring_line):\n                    continue\n                mov_cost = self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n                if mov_cost is None:\n                    continue\n                q_new_cost = q_new.cost if q_new.cost is not None else float('inf')\n                cost_through_q_new = q_new_cost + mov_cost\n                neighbor_cost = neighbor.cost if neighbor.cost is not None else float('inf')\n                if cost_through_q_new < neighbor_cost:\n                    # Rewire neighbor parent edges\n                    # Find current parents and remove edges\n                    for parent in list(neighbor.parents):\n                        self._graph.remove_edge(parent, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = cost_through_q_new\n\n            # If this new vertex is close enough to goal, attempt connection\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path_with_smoothing(q_new)\n                break\n\n            self.key_frame()\n\n    def _biased_random_sample(self) -> Point:\n        if (random.random() < self._goal_bias_prob):\n            return self._graph.root_vertex_goal.position\n        else:\n            grid_size = self._get_grid().size\n            while True:\n                sample_x = int(round(random.uniform(0, grid_size.width)))\n                sample_y = int(round(random.uniform(0, grid_size.height)))\n                sample = Point(sample_x, sample_y)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _adaptive_max_dist(self, q_near_pos: Point, q_sample_pos: Point) -> float:\n        base_dist = self._max_dist_base\n        dist = Map.get_distance(q_near_pos, q_sample_pos)\n        goal_pos = self._graph.root_vertex_goal.position\n        dist_to_goal = Map.get_distance(q_near_pos, goal_pos)\n        if (dist_to_goal < (base_dist * 2)):\n            base_dist *= 0.5\n        obstacle_nearby = False\n        obstacle_safe_dist = base_dist\n        for obs in self._get_grid().obstacles:\n            obs_dist = Map.get_distance(q_near_pos, obs.position)\n            if (obs_dist <= (obstacle_safe_dist + obs.radius)):\n                obstacle_nearby = True\n                break\n        if obstacle_nearby:\n            base_dist *= 0.3\n        max_dist = min(base_dist, dist)\n        if (max_dist < 1e-05):\n            max_dist = 1.0\n        return max_dist\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = Point((q_sample.x - q_near.position.x), (q_sample.y - q_near.position.y))\n        length = math.hypot(direction.x, direction.y)\n        if (length <= max_dist):\n            new_pos = q_sample\n        else:\n            scale = (max_dist / length)\n            new_x = q_near.position.x + (direction.x * scale)\n            new_y = q_near.position.y + (direction.y * scale)\n            new_pos = Point(new_x, new_y)\n\n        # Ensure position is integer coordinates before querying the grid\n        int_pos = Point(int(round(new_pos.x)), int(round(new_pos.y)))\n        new_vertex = Vertex(int_pos)\n        new_vertex.cost = float('inf')\n        return new_vertex\n\n    def _extract_path_with_smoothing(self, q_new: Vertex) -> None:\n        path = []\n        current_vertex = q_new\n        while (current_vertex is not None):\n            path.append(current_vertex.position)\n            if (len(current_vertex.parents) == 0):\n                break\n            current_vertex = min(current_vertex.parents, key=(lambda v: v.cost))\n        path.reverse()\n        smoothed_path = [path[0]]\n        i = 0\n        while (i < (len(path) - 1)):\n            j = (len(path) - 1)\n            while (j > (i + 1)):\n                line_seq = self._get_grid().get_line_sequence(path[i], path[j])\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed_path.append(path[j])\n            i = j\n        for point in smoothed_path:\n            self.move_agent(point)\n            self.key_frame()",
     "objective": 7941.59,
     "other_inf": null,
     "results": {
          "goal_found_perc": 96.67,
          "average_steps": 9.5,
          "average_distance": 10.11,
          "average_smoothness": 0.32,
          "average_clearance": 2.02,
          "average_time": 0.3711,
          "average_distance_from_goal": 0.25,
          "average_original_distance_from_goal": 8.42,
          "average memory": 66.88,
          "goal_found_perc_improvement": -0.68,
          "average_steps_improvement": -4.17,
          "average_distance_improvement": -4.98,
          "average_smoothness_improvement": -23.08,
          "average_clearance_improvement": 0.5,
          "average_time_improvement": -5126.76,
          "average_distance_from_goal_improvement": -25.0,
          "average_path_deviation": 0.47999999999999865,
          "average_memory_improvement": -79.69
     }
}
{heur4
     "algorithm": "PathPlanning: An improved sample-based path planning algorithm inspired by RRT* with goal biasing, adaptive step size,\n    and rewiring for path optimization. The algorithm biases samples towards the goal to increase efficiency, adapts\n    the maximum extension distance to environment scale, and performs local rewiring to reduce path cost and improve \n    path smoothness. It includes shortcut path smoothing after a path is found and enforces a maximum runtime of 10 seconds \n    for robustness. This approach balances exploration and exploitation to achieve better success rates, faster planning, \n    and higher quality paths with fewer failures in cluttered environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize the sample-based graph with start and goal vertices\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0  # Initialize start vertex cost\n        self._graph = gen_forest(self._services, start_vertex, Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable removability for rewiring\n        # Adaptive max extension distance based on environment diagonal\n        self._max_dist = max(5, int(math.sqrt(self._get_grid().size.width ** 2 + self._get_grid().size.height ** 2) / 20))\n        self._goal_bias = 0.15  # Bias towards goal sampling probability\n        self._init_displays()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        max_iterations = 8000\n\n        goal_position: Point = self._get_grid().goal.position\n\n        for iteration in range(max_iterations):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 10:  # Fail if planning takes too long\n                break\n\n            # Goal-biased random sampling\n            if random.random() < self._goal_bias:\n                q_sample = goal_position\n            else:\n                q_sample = self._get_random_sample()\n\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                self.key_frame()\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            # Add q_new as vertex in graph\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire: find nearby vertices and try to update parent if better path found\n            radius = self._max_dist * 2\n            near_vertices = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            for q_nearby in near_vertices:\n                if q_nearby == q_near:\n                    continue\n                new_line_seq = self._get_grid().get_line_sequence(q_new.position, q_nearby.position)\n                if self._get_grid().is_valid_line_sequence(new_line_seq):\n                    cost_through_new = q_new.cost + self._get_grid().get_distance(q_new.position, q_nearby.position)\n                    if cost_through_new < q_nearby.cost:\n                        # Remove old edge and add new edge for rewiring\n                        for parent_vertex in list(q_nearby.parents):\n                            self._graph.remove_edge(parent_vertex, q_nearby)\n                        self._graph.add_edge(q_new, q_nearby)\n                        q_nearby.cost = cost_through_new\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect directly to goal vertex and update cost\n                goal_vertex = Vertex(goal_position)\n                goal_vertex.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_position)\n                self._graph.add_edge(q_new, goal_vertex)\n\n                # Extract and shortcut path\n                self._extract_path(q_new)\n\n                # Optional post-processing for smoothing path (call helper)\n                self._shortcut_path()\n\n                break\n\n            self.key_frame()\n\n    def _get_random_sample(self) -> Point:\n        width = self._get_grid().size.width\n        height = self._get_grid().size.height\n        while True:\n            x = random.randint(0, (width - 1))\n            y = random.randint(0, (height - 1))\n            sample_point = Point(x, y)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = Point((q_sample.x - q_near.position.x), (q_sample.y - q_near.position.y))\n        dist = math.sqrt(((direction.x ** 2) + (direction.y ** 2)))\n        if (dist <= max_dist):\n            new_position = q_sample\n        else:\n            scale = (max_dist / dist)\n            new_x = int(round((q_near.position.x + (direction.x * scale))))\n            new_y = int(round((q_near.position.y + (direction.y * scale))))\n            new_position = Point(new_x, new_y)\n        new_vertex = Vertex(new_position)\n        # Initialize cost for q_near if None\n        if q_near.cost is None:\n            q_near.cost = 0.0\n        new_vertex.cost = (q_near.cost + self._get_grid().get_distance(q_near.position, new_position))\n        return new_vertex\n\n    def _extract_path(self, last_vertex: Vertex) -> None:\n        path = []\n        current = last_vertex\n        while (current is not None):\n            path.append(current.position)\n            if current.parents:\n                current = min(current.parents, key=(lambda p: p.cost))\n            else:\n                current = None\n        path.reverse()\n        self._path = path\n        for point in path:\n            self.move_agent(point)\n            self.key_frame()\n\n    def _shortcut_path(self) -> None:\n        if ((not hasattr(self, '_path')) or (not self._path) or (len(self._path) < 3)):\n            return\n        shortened_path = [self._path[0]]\n        current_index = 0\n        while (current_index < (len(self._path) - 1)):\n            next_index = (len(self._path) - 1)\n            for j in range((len(self._path) - 1), current_index, (- 1)):\n                line_seq = self._get_grid().get_line_sequence(self._path[current_index], self._path[j])\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    next_index = j\n                    break\n            shortened_path.append(self._path[next_index])\n            current_index = next_index\n        self._path = shortened_path\n        for point in self._path:\n            self.move_agent(point)\n            self.key_frame()",
     "objective": 3067.32,
     "other_inf": null,
     "results": {
          "goal_found_perc": 95.33,
          "average_steps": 21.66,
          "average_distance": 22.99,
          "average_smoothness": 0.47,
          "average_clearance": 2.13,
          "average_time": 0.1316,
          "average_distance_from_goal": 0.31,
          "average_original_distance_from_goal": 8.42,
          "average memory": 55.27,
          "goal_found_perc_improvement": -2.05,
          "average_steps_improvement": -139.87,
          "average_distance_improvement": -141.24,
          "average_smoothness_improvement": -80.77,
          "average_clearance_improvement": 5.45,
          "average_time_improvement": -1753.52,
          "average_distance_from_goal_improvement": -55.0,
          "average_path_deviation": 13.459999999999999,
          "average_memory_improvement": -48.5
     }
}
Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0074,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.22
}
Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0072,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.22
}
{heur1
     "algorithm": "This improved PathPlanning algorithm enhances traditional sampling-based planners\n    by integrating an adaptive goal-biased sampling mechanism combined with heuristic-guided extension steps.\n    It uses A*-inspired cost estimates to select promising extension directions and adaptively modulates step sizes\n    based on local environment density and distance to goal to accelerate convergence.\n    The rewiring approach leverages a dynamically shrinking radius to maintain balance between exploration and exploitation.\n    Additionally, it incorporates offline path smoothing by progressively shortcutting and refining paths during planning,\n    enabling higher-quality (shorter and smoother) paths to be found faster.\n    Early stopping enforces a 10-second time budget to ensure timely results.\n    These improvements raise planning efficiency, robustness, path smoothness, and success rate compared to baseline methods.",
     "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\nimport random\nimport time\nimport math\n\nfrom memory_profiler import profile\nfrom typing import TYPE_CHECKING, List, Tuple, Type, Any, Dict, Union, Optional\n\nfrom algorithms.basic_testing import BasicTesting\n\nfrom algorithms.algorithm import Algorithm\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\nfrom algorithms.classic.sample_based.core.graph import gen_cyclic_graph, CyclicGraph\n\nfrom algorithms.configuration.entities.agent import Agent\nfrom algorithms.configuration.entities.entity import Entity\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.entities.obstacle import Obstacle\nfrom algorithms.configuration.entities.trace import Trace\nfrom algorithms.configuration.maps.map import Map\nfrom algorithms.configuration.maps.ros_map import RosMap\nfrom algorithms.configuration.maps.bresenhams_algo import bresenhamline\n\nfrom simulator.services.services import Services\n\nfrom simulator.views.map.display.gradient_list_map_display import GradientListMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\n\nfrom structures import Point, Size, Colour, BLUE, DynamicColour\nfrom structures.factory import gen_set, gen_heap\nfrom structures.heap import Heap\n\n\n\nclass PathPlanning(SampleBasedAlgorithm):\n    \n    \n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_iter = 4000  # Slightly fewer max iterations for efficiency\n        self._time_limit = 10.0  # seconds\n        self._goal_sample_rate = 0.20  # increased goal bias for faster convergence\n        self._max_dist_base = 20.0  # increased base extension distance\n        self._rewire_radius_initial = 25.0  # initial rewire radius\n        self._rewire_radius_min = 10.0  # minimum rewire radius to maintain connectivity\n        self._rewire_decay_rate = 0.995  # radius decay per iteration for adaptive rewiring\n        self._iteration = 0\n        \n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            []\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n        \n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.aux['cost'] = 0.0\n        goal_vertex.aux['cost'] = float('inf')\n        \n        self._graph.root_vertices.append(start_vertex)\n        self._graph.root_vertices.append(goal_vertex)\n        \n        rewire_radius = self._rewire_radius_initial\n        \n        for iteration in range(self._max_iter):\n            self._iteration = iteration\n            \n            # Early stopping if time exceeded\n            if (time.time() - start_time) > self._time_limit:\n                return\n            \n            # Sample point with dynamic goal bias and heuristic guidance\n            sample_point = self._get_heuristic_goal_biased_sample(self._goal_sample_rate, goal_vertex.position)\n            \n            # Find nearest vertex for extension\n            nearest_vertex = self._graph.get_nearest_vertex([start_vertex], sample_point)\n            \n            if nearest_vertex is None:\n                continue\n            \n            # Adaptive step size: influenced by distance to goal and local density heuristic\n            dist_to_sample = self._get_grid().get_distance(nearest_vertex.position, sample_point)\n            dist_to_goal = self._get_grid().get_distance(nearest_vertex.position, goal_vertex.position)\n            \n            # Use a decreasing step size as we approach goal\n            max_dist_dynamic = max(5.0, min(self._max_dist_base, dist_to_goal * 0.7))\n            max_dist = min(max_dist_dynamic, dist_to_sample)\n            \n            # Generate new vertex toward sample point\n            new_vertex = self._get_new_vertex_heuristic(nearest_vertex, sample_point, max_dist, goal_vertex.position)\n            if new_vertex.position == nearest_vertex.position:\n                continue\n            \n            line_seq = self._get_grid().get_line_sequence(nearest_vertex.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            \n            cost_to_nearest = nearest_vertex.aux.get('cost', float('inf'))\n            step_cost = self._get_grid().get_movement_cost(nearest_vertex.position, new_vertex.position)\n            new_vertex_cost = cost_to_nearest + step_cost\n            \n            # Find neighbors within rewiring radius (shrinking radius)\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], new_vertex.position, rewire_radius)\n            \n            best_parent = nearest_vertex\n            best_cost = new_vertex_cost\n            \n            # Choose best parent among near vertices by cost + collision check\n            for neighbor in neighbors:\n                if neighbor == nearest_vertex:\n                    continue\n                line_seq_to_new = self._get_grid().get_line_sequence(neighbor.position, new_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_to_new):\n                    cost_through_neighbor = neighbor.aux.get('cost', float('inf')) + self._get_grid().get_movement_cost(neighbor.position, new_vertex.position)\n                    if cost_through_neighbor < best_cost:\n                        best_parent = neighbor\n                        best_cost = cost_through_neighbor\n            \n            new_vertex.aux['cost'] = best_cost\n            self._graph.add_edge(best_parent, new_vertex)\n            \n            # Rewiring attempt: connect neighbors through new_vertex for better cost\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                line_seq_rewire = self._get_grid().get_line_sequence(new_vertex.position, neighbor.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_rewire):\n                    cost_through_new = new_vertex.aux.get('cost', float('inf')) + self._get_grid().get_movement_cost(new_vertex.position, neighbor.position)\n                    if cost_through_new < neighbor.aux.get('cost', float('inf')):\n                        for p in list(neighbor.parents):\n                            self._graph.remove_edge(p, neighbor)\n                        self._graph.add_edge(new_vertex, neighbor)\n                        neighbor.aux['cost'] = cost_through_new\n            \n            self._graph.root_vertices.append(new_vertex)\n            \n            # Attempt direct connection to goal vertex if close enough\n            if self._get_grid().get_distance(new_vertex.position, goal_vertex.position) <= self._max_dist_base:\n                goal_line_seq = self._get_grid().get_line_sequence(new_vertex.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(goal_line_seq):\n                    cost_to_goal_candidate = new_vertex.aux.get('cost', float('inf')) + self._get_grid().get_movement_cost(new_vertex.position, goal_vertex.position)\n                    if cost_to_goal_candidate < goal_vertex.aux.get('cost', float('inf')):\n                        for p in list(goal_vertex.parents):\n                            self._graph.remove_edge(p, goal_vertex)\n                        self._graph.add_edge(new_vertex, goal_vertex)\n                        goal_vertex.aux['cost'] = cost_to_goal_candidate\n                        \n                        # Extract and smooth path progressively further\n                        self._extract_and_smooth_path_improved(goal_vertex)\n                        return\n            \n            # Decay rewiring radius to focus rewiring as tree grows\n            rewire_radius = max(self._rewire_radius_min, rewire_radius * self._rewire_decay_rate)\n            \n            self.key_frame()\n\n\n\n    def _get_heuristic_goal_biased_sample(self, goal_sample_rate: float, goal_position: Point) -> Point:\n        if (random.random() < goal_sample_rate):\n            return goal_position\n        grid = self._get_grid()\n        size = grid.size\n        while True:\n            sample_x = random.uniform(0, (size.width - 1))\n            sample_y = random.uniform(0, (size.height - 1))\n            sample_point = Point(int(sample_x), int(sample_y))\n            direction_to_goal = Point((goal_position.x - sample_point.x), (goal_position.y - sample_point.y))\n            length = math.sqrt(((direction_to_goal.x ** 2) + (direction_to_goal.y ** 2)))\n            if (length > 1e-05):\n                direction_to_goal = Point((direction_to_goal.x / length), (direction_to_goal.y / length))\n                bias_factor = 0.3\n                biased_x = (sample_point.x + (((direction_to_goal.x * bias_factor) * size.width) * random.random()))\n                biased_y = (sample_point.y + (((direction_to_goal.y * bias_factor) * size.height) * random.random()))\n                biased_point = Point(int(max(0, min((size.width - 1), biased_x))), int(max(0, min((size.height - 1), biased_y))))\n            else:\n                biased_point = sample_point\n            if grid.is_agent_valid_pos(biased_point):\n                return biased_point\n\n\n\n\n    def _get_new_vertex_heuristic(self, nearest_vertex: Vertex, sample_point: Point, max_dist: float, goal_position: Point) -> Vertex:\n        direction = Point((sample_point.x - nearest_vertex.position.x), (sample_point.y - nearest_vertex.position.y))\n        length = math.sqrt(((direction.x ** 2) + (direction.y ** 2)))\n        if (length > max_dist):\n            scale = (max_dist / length)\n            new_x = (nearest_vertex.position.x + int((direction.x * scale)))\n            new_y = (nearest_vertex.position.y + int((direction.y * scale)))\n        else:\n            (new_x, new_y) = (sample_point.x, sample_point.y)\n        new_position = Point(new_x, new_y)\n        dist_to_goal_from_new = self._get_grid().get_distance(new_position, goal_position)\n        dist_to_goal_from_nearest = self._get_grid().get_distance(nearest_vertex.position, goal_position)\n        if (dist_to_goal_from_new > dist_to_goal_from_nearest):\n            direction_to_goal = Point((goal_position.x - new_position.x), (goal_position.y - new_position.y))\n            dist_to_goal = math.sqrt(((direction_to_goal.x ** 2) + (direction_to_goal.y ** 2)))\n            if (dist_to_goal > 1e-05):\n                move_scale = min((max_dist * 0.3), dist_to_goal)\n                direction_to_goal = Point((direction_to_goal.x / dist_to_goal), (direction_to_goal.y / dist_to_goal))\n                new_x = (new_position.x + int((direction_to_goal.x * move_scale)))\n                new_y = (new_position.y + int((direction_to_goal.y * move_scale)))\n                new_position = Point(max(0, min(new_x, (self._get_grid().size.width - 1))), max(0, min(new_y, (self._get_grid().size.height - 1))))\n        return Vertex(new_position, store_connectivity=True)\n\n\n\n\n    def _extract_and_smooth_path_improved(self, goal_vertex: Vertex) -> None:\n        path: List[Point] = []\n        vertex = goal_vertex\n        while (vertex is not None):\n            path.append(vertex.position)\n            if (not vertex.parents):\n                break\n            vertex = min(vertex.parents, key=(lambda v: v.aux.get('cost', float('inf'))))\n        path.reverse()\n        smoothed_path: List[Point] = [path[0]]\n        last_added = path[0]\n        for i in range(1, len(path)):\n            candidate = path[i]\n            line_seq = self._get_grid().get_line_sequence(last_added, candidate)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            else:\n                smoothed_path.append(path[(i - 1)])\n                last_added = path[(i - 1)]\n        if (smoothed_path[(- 1)] != path[(- 1)]):\n            smoothed_path.append(path[(- 1)])\n        self._trace = [Trace(pos) for pos in smoothed_path]\n        for pos in smoothed_path:\n            self.move_agent(pos)\n            self.key_frame()\n\n\n",
     "objective": 3519.61,
     "other_inf": null,
     "results": {
          "goal_found_perc": 95.33,
          "average_steps": 10.14,
          "average_distance": 10.89,
          "average_smoothness": 0.33,
          "average_clearance": 2.05,
          "average_time": 0.1516,
          "average_distance_from_goal": 0.46,
          "average_original_distance_from_goal": 8.42,
          "average memory": 63.63,
          "goal_found_perc_improvement": -2.05,
          "average_steps_improvement": -13.42,
          "average_distance_improvement": -15.24,
          "average_smoothness_improvement": -26.92,
          "average_clearance_improvement": 2.5,
          "average_time_improvement": -2097.1,
          "average_distance_from_goal_improvement": -130.0,
          "average_path_deviation": 1.4400000000000013,
          "average_memory_improvement": -70.96
     }
}
{heur2
     "algorithm": "This algorithm enhances the basic goal-biased RRT* by integrating a clearance-aware sampling strategy \n    that prefers sampling points away from obstacles to improve path safety and robustness.\n    It uses heuristic-guided extension biased by cost-to-go estimates to better guide tree growth towards the goal.\n    Adaptive step sizing is employed based on clearance and distance to goal to balance exploration and exploitation.\n    Rewiring is performed for local optimality improvements in path cost.\n    After a path is found, the algorithm applies shortcut smoothing for improved path quality.\n    The planner respects a strict 10-second time limit for early stopping and dynamically adjusts iteration control for efficiency.\n    The improved clearance awareness aims to reduce collisions and increase success rate and path smoothness.",
     "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\nimport random\nimport time\nimport math\n\nfrom memory_profiler import profile\nfrom typing import TYPE_CHECKING, List, Tuple, Type, Any, Dict, Union, Optional\n\nfrom algorithms.basic_testing import BasicTesting\n\nfrom algorithms.algorithm import Algorithm\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\nfrom algorithms.classic.sample_based.core.graph import gen_cyclic_graph, CyclicGraph\n\nfrom algorithms.configuration.entities.agent import Agent\nfrom algorithms.configuration.entities.entity import Entity\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.entities.obstacle import Obstacle\nfrom algorithms.configuration.entities.trace import Trace\nfrom algorithms.configuration.maps.map import Map\nfrom algorithms.configuration.maps.ros_map import RosMap\nfrom algorithms.configuration.maps.bresenhams_algo import bresenhamline\n\nfrom simulator.services.services import Services\n\nfrom simulator.views.map.display.gradient_list_map_display import GradientListMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\n\nfrom structures import Point, Size, Colour, BLUE, DynamicColour\nfrom structures.factory import gen_set, gen_heap\nfrom structures.heap import Heap\n\n\n\nclass PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_iter = 5000\n        self._time_limit = 10.0  # seconds allowed for planning\n        self._goal_sample_rate = 0.2  # Increased goal bias for quicker goal convergence\n        self._max_dist_base = 20.0    # Slightly larger base max step size for faster exploration\n        self._rewire_radius = 25.0    # Larger rewire radius for better optimization\n        self._clearance_weight = 5.0  # Weight factor to encourage clearance during sampling\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            []\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.aux['cost'] = 0.0\n        self._graph.root_vertices.append(start_vertex)\n        self._graph.root_vertices.append(goal_vertex)\n\n        for iteration in range(self._max_iter):\n\n            # Early stop on time limit\n            if (time.time() - start_time) > self._time_limit:\n                return  # fail if no path found in time\n\n            # Sample point with clearance-awareness and goal bias\n            sample_point = self._get_clearance_aware_sample(self._goal_sample_rate, goal_vertex.position, self._clearance_weight)\n\n            # Find nearest vertex from tree toward sample point\n            nearest_vertex = self._graph.get_nearest_vertex([start_vertex], sample_point)\n\n            # Calculate adaptive max_dist based on clearance heuristic and proximity to goal\n            dist_to_goal = self._get_grid().get_distance(nearest_vertex.position, goal_vertex.position)\n            clearance_at_nearest = self._estimate_clearance(nearest_vertex.position)\n            clearance_factor = max(1.0, clearance_at_nearest / self._clearance_weight)\n            max_dist = min(self._max_dist_base * clearance_factor, dist_to_goal * 0.8)\n\n            # Create a new vertex extended towards the sample point with max_dist constraint\n            new_vertex = self._get_new_vertex(nearest_vertex, sample_point, max_dist)\n            if new_vertex.position == nearest_vertex.position:\n                continue  # no meaningful extension\n\n            # Check collision for path from nearest to new vertex\n            line_seq = self._get_grid().get_line_sequence(nearest_vertex.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Calculate cost to new vertex using current cost + movement cost\n            cost_to_nearest = nearest_vertex.aux.get('cost', float('inf'))\n            step_cost = self._get_grid().get_movement_cost(nearest_vertex.position, new_vertex.position)\n            new_cost = cost_to_nearest + step_cost\n\n            # Find neighbors in rewire radius for better connection and rewiring\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], new_vertex.position, self._rewire_radius)\n\n            # Select best parent based on minimal cost and valid path\n            best_parent = nearest_vertex\n            best_cost = new_cost\n            for near_vertex in near_vertices:\n                if near_vertex == nearest_vertex:\n                    continue\n                line_seq_near = self._get_grid().get_line_sequence(near_vertex.position, new_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_near):\n                    cost_to_near = near_vertex.aux.get('cost', float('inf'))\n                    candidate_cost = cost_to_near + self._get_grid().get_movement_cost(near_vertex.position, new_vertex.position)\n                    # Heuristic: prioritize vertices with higher clearance by discounting cost slightly\n                    clearance_near = self._estimate_clearance(near_vertex.position)\n                    candidate_cost -= self._clearance_weight * (clearance_near / 100.0)\n                    if candidate_cost < best_cost:\n                        best_parent = near_vertex\n                        best_cost = candidate_cost\n\n            # Set auxiliary cost and add edge from best parent to new vertex\n            new_vertex.aux['cost'] = best_cost\n            self._graph.add_edge(best_parent, new_vertex)\n\n            # Rewiring for neighbors considering new vertex as better path provider\n            for near_vertex in near_vertices:\n                if near_vertex == best_parent:\n                    continue\n                line_seq_rewire = self._get_grid().get_line_sequence(new_vertex.position, near_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_rewire):\n                    cost_through_new = new_vertex.aux.get('cost', float('inf')) + \\\n                                       self._get_grid().get_movement_cost(new_vertex.position, near_vertex.position)\n                    current_cost = near_vertex.aux.get('cost', float('inf'))\n                    if cost_through_new < current_cost:\n                        # Remove old parents and add new edge from new_vertex\n                        for p in list(near_vertex.parents):\n                            self._graph.remove_edge(p, near_vertex)\n                        self._graph.add_edge(new_vertex, near_vertex)\n                        near_vertex.aux['cost'] = cost_through_new\n\n            # Add new vertex to forest root vertices for exploration\n            self._graph.root_vertices.append(new_vertex)\n\n            # Try connecting new vertex directly to goal if close enough\n            dist_to_goal_from_new = self._get_grid().get_distance(new_vertex.position, goal_vertex.position)\n            if dist_to_goal_from_new <= self._max_dist_base * 1.2:\n                goal_line_seq = self._get_grid().get_line_sequence(new_vertex.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(goal_line_seq):\n                    cost_to_goal_new = new_vertex.aux.get('cost', float('inf')) + \\\n                                       self._get_grid().get_movement_cost(new_vertex.position, goal_vertex.position)\n                    if cost_to_goal_new < goal_vertex.aux.get('cost', float('inf')):\n                        # Remove all previous parents from goal and add edge from new_vertex\n                        for p in list(goal_vertex.parents):\n                            self._graph.remove_edge(p, goal_vertex)\n                        self._graph.add_edge(new_vertex, goal_vertex)\n                        goal_vertex.aux['cost'] = cost_to_goal_new\n\n                        # Extract and smooth the found path\n                        self._extract_and_smooth_path(goal_vertex)\n                        return\n\n            self.key_frame()\n\n\n\n    def _get_clearance_aware_sample(self, goal_sample_rate: float, goal_pos: Point, clearance_weight: float) -> Point:\n        'Generate a clearance-aware sample point for RRT planning with goal bias.\\n\\n    Args:\\n        goal_sample_rate (float): Probability of sampling the goal directly.\\n        goal_pos (Point): Position of the goal to bias sampling.\\n        clearance_weight (float): Weight factor to prefer samples with higher clearance.\\n\\n    Returns:\\n        Point: A sampled point in the map.\\n    '\n        if (random.random() < goal_sample_rate):\n            return goal_pos\n        grid = self._get_grid()\n        size = grid.size\n        num_samples = 10\n        best_sample = None\n        best_score = (- float('inf'))\n        for _ in range(num_samples):\n            x = random.uniform(0, (size.width - 1))\n            y = random.uniform(0, (size.height - 1))\n            sample = Point(int(round(x)), int(round(y)))\n            if (not grid.is_agent_valid_pos(sample)):\n                continue\n            clearance = self._estimate_clearance(sample)\n            score = (clearance * clearance_weight)\n            if (score > best_score):\n                best_score = score\n                best_sample = sample\n        if (best_sample is None):\n            while True:\n                x = random.randint(0, (size.width - 1))\n                y = random.randint(0, (size.height - 1))\n                sample = Point(x, y)\n                if grid.is_agent_valid_pos(sample):\n                    best_sample = sample\n                    break\n        return best_sample\n\n\n\n\n    def _estimate_clearance(self, pos: Point) -> float:\n        grid = self._get_grid()\n        max_clearance_distance = 50\n        clearance = 0.0\n        for d in range(1, (max_clearance_distance + 1)):\n            points_to_check = []\n            (x0, y0) = (pos.x, pos.y)\n            for x in range((x0 - d), ((x0 + d) + 1)):\n                points_to_check.append(Point(x, (y0 - d)))\n                points_to_check.append(Point(x, (y0 + d)))\n            for y in range(((y0 - d) + 1), (y0 + d)):\n                points_to_check.append(Point((x0 - d), y))\n                points_to_check.append(Point((x0 + d), y))\n            all_clear = True\n            for pt in points_to_check:\n                if (not grid.is_agent_valid_pos(pt)):\n                    all_clear = False\n                    break\n            if all_clear:\n                clearance = float(d)\n            else:\n                break\n        return clearance\n\n\n\n\n    def _get_new_vertex(self, nearest_vertex: Vertex, sample_point: Point, max_dist: float) -> Vertex:\n        from math import sqrt\n        direction_x = (sample_point.x - nearest_vertex.position.x)\n        direction_y = (sample_point.y - nearest_vertex.position.y)\n        dist = sqrt(((direction_x ** 2) + (direction_y ** 2)))\n        if (dist == 0):\n            return Vertex(nearest_vertex.position, store_connectivity=True)\n        scale = min((max_dist / dist), 1.0)\n        new_x = (nearest_vertex.position.x + (direction_x * scale))\n        new_y = (nearest_vertex.position.y + (direction_y * scale))\n        new_pos = Point(int(round(new_x)), int(round(new_y)))\n        return Vertex(new_pos, store_connectivity=True)\n\n\n\n\n    def _extract_and_smooth_path(self, goal_vertex: Vertex) -> None:\n        path = []\n        current = goal_vertex\n        while current.parents:\n            path.append(current.position)\n            current = next(iter(current.parents))\n        path.append(current.position)\n        path.reverse()\n        smoothed_path = [path[0]]\n        grid = self._get_grid()\n        i = 0\n        while (i < (len(path) - 1)):\n            j = (len(path) - 1)\n            while (j > (i + 1)):\n                line_seq = grid.get_line_sequence(path[i], path[j])\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed_path.append(path[j])\n            i = j\n        self._last_path = smoothed_path\n        for point in smoothed_path:\n            self.move_agent(point)\n            self.key_frame()\n\n\n\n\n    def sqrt(value: float) -> float:\n        return (value ** 0.5)\n",
     "objective": 8228.94,
     "other_inf": null,
     "results": {
          "goal_found_perc": 94.67,
          "average_steps": 10.87,
          "average_distance": 11.53,
          "average_smoothness": 0.34,
          "average_clearance": 2.16,
          "average_time": 0.3019,
          "average_distance_from_goal": 0.47,
          "average_original_distance_from_goal": 8.42,
          "average memory": 337.93,
          "goal_found_perc_improvement": -2.73,
          "average_steps_improvement": -20.91,
          "average_distance_improvement": -21.62,
          "average_smoothness_improvement": -30.77,
          "average_clearance_improvement": 6.93,
          "average_time_improvement": -4212.86,
          "average_distance_from_goal_improvement": -135.0,
          "average_path_deviation": 2.049999999999999,
          "average_memory_improvement": -807.93
     }
}
