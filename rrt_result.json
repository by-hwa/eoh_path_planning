{
    "algorithm": "RRT",
    "algorithm_description": "RRT*",
    "code": "\n# --- Node class ---\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def distance(self, other: 'Node') -> float:\n        return math.dist(self.position, other.position)\n\n\n# --- Planner class implementing basic RRT ---\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 1.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        root = Node(start_position)\n        nodes: List[Node] = [root]\n\n        for _ in range(self.max_iter):\n            # 1. Sample random point\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            # 2. Find nearest node\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # 3. Steer\n            new_position = self._steer(nearest.position, sample, self.step_size)\n            new_node = Node(new_position, parent=nearest, cost=nearest.cost + math.dist(nearest.position, new_position))\n\n            # 4. Collision check\n            if not self._is_in_obstacle(new_position, obstacles, is_3d):\n                nearest.children.append(new_node)\n                nodes.append(new_node)\n\n                # 5. Check goal reached\n                if math.dist(new_position, goal_position) <= self.step_size:\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.children.append(goal_node)\n                    nodes.append(goal_node)\n\n                    path = self._extract_path(goal_node)\n                    edges = [(node.parent, node) for node in nodes if node.parent]\n                    return PlannerResult(True, path, nodes, edges)\n\n        # No valid path\n        edges = [(node.parent, node) for node in nodes if node.parent]\n        return PlannerResult(False, [], nodes, edges)\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], step_size: float) -> Tuple[float, ...]:\n        vec = [t - f for f, t in zip(from_pos, to_pos)]\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        scale = step_size / dist\n        return tuple(f + scale * d for f, d in zip(from_pos, vec))\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _extract_path(self, node: Node) -> List[Tuple[float, ...]]:\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n    "
}