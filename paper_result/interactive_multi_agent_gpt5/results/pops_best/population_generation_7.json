{
     "operator": "time_expert",
     "algorithm_description": "TIDAL-BiRRT: Time-Optimized Directional Adaptive Lazy BiRRT. It accelerates planning via slab-based exact collision tests with obstacle spatial hashing (cell-indexed AABBs) to cut collision checks, a tight hashed-grid nearest search, goal/line-of-sight biased sampling with direct long steps when visible, and a fast greedy multi-step connect that minimizes iterations. Lightweight visibility prune plus micro-shortcutting returns a short, smooth path with minimal overhead.",
     "planning_mechanism": "Alternate expanding start/goal trees. Each iteration samples (goal/line/uniform), finds a hashed-grid nearest, and, if the straight segment is free, takes a long step (up to the sample), else a capped step. After insertion, the other tree greedily extends toward the new node for a few steps using exact slab checks against only nearby obstacles via a spatial hash; if visible within a step, trees meet and the path is extracted and lightly smoothed.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=7000,\n                 step_size=6.0,\n                 goal_bias=0.30,\n                 line_bias=0.20,\n                 search_r_max=2,\n                 connect_steps=10,\n                 smoothing_iters=8):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.search_r_max = search_r_max\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n\n        # RNG\n        self._lcg_state = 2463534242\n\n        # Obstacle spatial hash\n        self._obs_grid = {}\n        self._obs_cell = 10.0\n        self._obstacles = []\n        self._is_3d = False\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self._is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        self._obstacles = list(map.obstacles)\n\n        # RNG reset\n        self._lcg_state = 2463534242\n\n        # Build obstacle spatial hash\n        self._obs_cell = max(6.0, self.step_size * 2.0)\n        self._build_obstacle_grid()\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacles(start) or self._point_in_obstacles(goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight line\n        if not self._edge_blocked(start, goal):\n            n0 = Node(start)\n            n1 = Node(goal, parent=n0, cost=self._dist(start, goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [start, goal], [n0, n1], [(n0, n1)])\n\n        # Trees and node grids\n        node_cell = max(1.0, self.step_size)\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes_all = [start_root, goal_root]\n        edges_all = []\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root, node_cell)\n        self._grid_add(grid_goal, goal_root, node_cell)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            # Sampling: goal bias, line-of-sight line bias, else uniform\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = root_other\n            elif r < self.goal_bias + self.line_bias:\n                x_rand = self._sample_on_line(start, goal)\n            else:\n                x_rand = self._sample_free()\n\n            nearest = self._nearest_hashed(grid_a, tree_a, x_rand, node_cell)\n            if nearest is None:\n                continue\n\n            # Try long step directly to sample if visible; else capped step\n            d_ns = self._dist(nearest.position, x_rand)\n            direct_allowed = (d_ns <= self.step_size * 1.8) and (not self._edge_blocked(nearest.position, x_rand))\n            new_pos = x_rand if direct_allowed else self._steer(nearest.position, x_rand, self.step_size)\n\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._edge_blocked(nearest.position, new_pos):\n                continue\n            # light dedup near check\n            if self._near_dup(grid_a, new_pos, node_cell, 0.2 * self.step_size):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes_all.append(new_node)\n            edges_all.append((nearest, new_node))\n            self._grid_add(grid_a, new_node, node_cell)\n\n            # Greedy bounded connect from other tree toward new_node\n            meet = self._greedy_connect(tree_b, grid_b, new_node.position, node_cell)\n            if meet is not None:\n                # Confirm final visibility (already enforced inside), extract and smooth\n                path = self._extract_path(new_node, meet, active_start)\n                path = self._visibility_prune(path)\n                path = self._shortcut_smooth(path, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges_all)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges_all)\n\n    # ---------------- RNG ----------------\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry --------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / max(d, 1e-9)\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # --------- Obstacle grid -------------\n    def _obs_key(self, p):\n        if self._is_3d:\n            return (int(p[0] // self._obs_cell), int(p[1] // self._obs_cell), int(p[2] // self._obs_cell))\n        else:\n            return (int(p[0] // self._obs_cell), int(p[1] // self._obs_cell))\n\n    def _build_obstacle_grid(self):\n        self._obs_grid = {}\n        cell = self._obs_cell\n        if self._is_3d:\n            for idx, o in enumerate(self._obstacles):\n                x, y, z, w, h, d = o\n                x0 = int(x // cell); x1 = int((x + w) // cell)\n                y0 = int(y // cell); y1 = int((y + h) // cell)\n                z0 = int(z // cell); z1 = int((z + d) // cell)\n                for i in range(x0, x1 + 1):\n                    for j in range(y0, y1 + 1):\n                        for k in range(z0, z1 + 1):\n                            self._obs_grid.setdefault((i, j, k), []).append(idx)\n        else:\n            for idx, o in enumerate(self._obstacles):\n                x, y, w, h = o\n                x0 = int(x // cell); x1 = int((x + w) // cell)\n                y0 = int(y // cell); y1 = int((y + h) // cell)\n                for i in range(x0, x1 + 1):\n                    for j in range(y0, y1 + 1):\n                        self._obs_grid.setdefault((i, j), []).append(idx)\n\n    def _point_in_obstacles(self, p):\n        # Query only obstacles in the point's cell\n        key = self._obs_key(p)\n        idxs = self._obs_grid.get(key, [])\n        if self._is_3d:\n            px, py, pz = p\n            for idx in idxs:\n                x, y, z, w, h, d = self._obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = p\n            for idx in idxs:\n                x, y, w, h = self._obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_candidates(self, a, b):\n        # Collect obstacles from all grid cells overlapping the segment AABB\n        cell = self._obs_cell\n        if self._is_3d:\n            minx = min(a[0], b[0]); maxx = max(a[0], b[0])\n            miny = min(a[1], b[1]); maxy = max(a[1], b[1])\n            minz = min(a[2], b[2]); maxz = max(a[2], b[2])\n            x0 = int(minx // cell); x1 = int(maxx // cell)\n            y0 = int(miny // cell); y1 = int(maxy // cell)\n            z0 = int(minz // cell); z1 = int(maxz // cell)\n            seen = set()\n            res = []\n            for i in range(x0, x1 + 1):\n                for j in range(y0, y1 + 1):\n                    for k in range(z0, z1 + 1):\n                        lst = self._obs_grid.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                if idx not in seen:\n                                    seen.add(idx)\n                                    res.append(idx)\n            return res\n        else:\n            minx = min(a[0], b[0]); maxx = max(a[0], b[0])\n            miny = min(a[1], b[1]); maxy = max(a[1], b[1])\n            x0 = int(minx // cell); x1 = int(maxx // cell)\n            y0 = int(miny // cell); y1 = int(maxy // cell)\n            seen = set()\n            res = []\n            for i in range(x0, x1 + 1):\n                for j in range(y0, y1 + 1):\n                    lst = self._obs_grid.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            if idx not in seen:\n                                seen.add(idx)\n                                res.append(idx)\n            return res\n\n    def _edge_blocked(self, a, b):\n        cand = self._segment_candidates(a, b)\n        if not cand:\n            return False\n        if self._is_3d:\n            for idx in cand:\n                x, y, z, w, h, d = self._obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n        else:\n            for idx in cand:\n                x, y, w, h = self._obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y), (x + w, y + h)):\n                    return True\n        return False\n\n    def _seg_aabb_intersect(self, p0, p1, bmin, bmax):\n        # Slab method for 2D/3D\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(self.dim):\n            a = p0[i]\n            b = p1[i]\n            d = b - a\n            if abs(d) < 1e-12:\n                if a < bmin[i] or a > bmax[i]:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (bmin[i] - a) * inv\n                t2 = (bmax[i] - a) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return (tmin <= tmax) and (tmax >= 0.0) and (tmin <= 1.0)\n\n    # ------------- Sampling --------------\n    def _sample_free(self):\n        # Try bounded attempts; fallback to unconditional loop\n        for _ in range(64):\n            if self._is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._point_in_obstacles(p):\n                return p\n        while True:\n            if self._is_3d:\n                p = (self.bounds[0] * self._rand(),\n                     self.bounds[1] * self._rand(),\n                     self.bounds[2] * self._rand())\n            else:\n                p = (self.bounds[0] * self._rand(),\n                     self.bounds[1] * self._rand())\n            if not self._point_in_obstacles(p):\n                return p\n\n    def _sample_on_line(self, s, g):\n        t = self._rand()\n        p = tuple(s[i] + (g[i] - s[i]) * t for i in range(self.dim))\n        p = self._clamp(p)\n        if not self._point_in_obstacles(p):\n            return p\n        return self._sample_free()\n\n    # ------------- Node grid -------------\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        res = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        res.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            res.extend(b)\n        return res\n\n    def _nearest_hashed(self, grid, tree, pos, cell):\n        key = self._grid_key(pos, cell)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, self.search_r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback random probing\n        if tree:\n            trials = min(32, len(tree))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _near_dup(self, grid, pos, cell, radius):\n        key = self._grid_key(pos, cell)\n        cand = self._grid_ring_collect(grid, key, 1)\n        rr = max(radius, 1e-6)\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # ------------- Connect & Path -------------\n    def _greedy_connect(self, tree_b, grid_b, target, cell):\n        cur = self._nearest_hashed(grid_b, tree_b, target, cell)\n        if cur is None:\n            return None\n        # If within one step and visible\n        if self._dist(cur.position, target) <= self.step_size and (not self._edge_blocked(cur.position, target)):\n            return cur\n        steps = 0\n        while steps < self.connect_steps:\n            steps += 1\n            if self._dist(cur.position, target) <= self.step_size:\n                if not self._edge_blocked(cur.position, target):\n                    return cur\n                else:\n                    break\n            nxt_pos = self._steer(cur.position, target, self.step_size)\n            if not self._in_bounds(nxt_pos):\n                break\n            if self._point_in_obstacles(nxt_pos):\n                break\n            if self._edge_blocked(cur.position, nxt_pos):\n                break\n            nxt = Node(nxt_pos, parent=cur, cost=cur.cost + self._dist(cur.position, nxt_pos))\n            cur.add_child(nxt)\n            tree_b.append(nxt)\n            self._grid_add(grid_b, nxt, cell)\n            cur = nxt\n        return None\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    # ------------- Smoothing -------------\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j]):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, iters):\n        if len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 2, n))  # ensure at least one point skipped and allow last index\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j - 1]):\n                pts = pts[:i + 1] + pts[j - 1:]\n        return pts",
     "objective": -40.43025,
     "time_improvement": 70.0,
     "length_improvement": 17.0,
     "smoothness_improvement": 1875.0,
     "node_improvement": 81.0,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.008312249183654785,
               "num_nodes_avg": 62.0,
               "path_length_avg": 156.69148465051805,
               "smoothness_avg": 0.038492658323530965,
               "success_improvement": 0.0,
               "time_improvement": 69.86334643481058,
               "node_improvement": 84.38680433140266,
               "length_improvement": 14.114914327586433,
               "smoothness_improvement": 502.49369090868373,
               "objective_score": 31.940420981538455
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.03631515502929687,
               "num_nodes_avg": 250.0,
               "path_length_avg": 241.12950159214583,
               "smoothness_avg": 0.12182159461241919,
               "success_improvement": 0.0,
               "time_improvement": 78.05451619363491,
               "node_improvement": 83.20231136195659,
               "length_improvement": 19.504031840666407,
               "smoothness_improvement": 3034.5573739254837,
               "objective_score": 50.29156083211774
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.02010810375213623,
               "num_nodes_avg": 186.0,
               "path_length_avg": 124.86780284803544,
               "smoothness_avg": 0.1720857560769434,
               "success_improvement": 0.0,
               "time_improvement": 61.24308687730198,
               "node_improvement": 76.35092180546727,
               "length_improvement": 17.068750914146232,
               "smoothness_improvement": 2088.918115249488,
               "objective_score": 39.058767187925774
          }
     ],
     "success_rate": 1.0
}