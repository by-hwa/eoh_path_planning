{
     "operator": "m3",
     "algorithm_description": "SAGE-Connect*: Simple Adaptive Grid Explorer with Informed Bidirectional Growth, Gentle Rewiring, and Fast Smoothing. It builds two trees from start and goal using a compact spatial hash, adaptive neighbor radius, LOS-aware stepping, lightweight k-best parenting, capped local rewiring, and a restrained greedy connect. Once a valid bridge is found, the path is shortcut-pruned and elastically smoothed with collision-aware line search for robust, short, and smooth trajectories.",
     "planning_mechanism": "Alternate expanding start/goal trees. Each iteration: draw a target (goal/segment/uniform; switch to informed-ellipse once a path exists), pick nearest via grid, steer with LOS-adaptive step, enforce node and edge collision checks, suppress duplicates, select a low-cost parent from nearby nodes, add the node, and locally rewire a few neighbors if the new route is cheaper (cycle-safe, edge-checked). Attempt a short greedy connect from the other tree; on success, assemble the bidirectional path, then apply shortcutting and visibility pruning followed by elastic midpoint smoothing before returning.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step=6.0,\n        connect_factor=1.9,\n        goal_bias=0.16,\n        line_bias=0.22,\n        informed_bias=0.45,\n        grid_cell_factor=1.6,\n        neighbor_radius_scale=3.0,\n        dupe_ratio=0.4,\n        rewire_cap=12,\n        connect_steps=12,\n        shortcut_attempts=90,\n        smooth_passes=6\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.connect_step = float(step * connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_radius_scale = float(neighbor_radius_scale)\n        self.dupe_ratio = float(dupe_ratio)\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(1, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 123456789\n        self._eindex = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._eindex = {}\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            self._edges_add(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Trees and grids\n        Ta, Tb = [], []\n        Ga, Gb = {}, {}\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta.append(start_root)\n        Tb.append(goal_root)\n        nodes.extend([start_root, goal_root])\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            # Sample a common target for both directions for coherence\n            sample = self._sample_target(best_len)\n            if sample is None:\n                continue\n\n            # Expand from start side\n            res = self._expand_and_maybe_connect(Ta, Ga, Tb, Gb, sample, nodes, edges)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n            # Expand from goal side\n            res = self._expand_and_maybe_connect(Tb, Gb, Ta, Ga, sample, nodes, edges)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # Core expansion and connection\n    def _expand_and_maybe_connect(self, Ta, Ga, Tb, Gb, target, nodes, edges):\n        na = self._nearest(Ga, target)\n        if na is None:\n            return None\n        q_new = self._steer_dynamic(na.position, target)\n        if (not self._in_bounds(q_new)) or self._point_blocked(q_new):\n            return None\n        if self._too_close(Ga, q_new, self.dupe_radius):\n            return None\n\n        parent = self._select_parent(Ga, q_new, na)\n        if parent is None:\n            return None\n        # Both checks before adding node/edge\n        if self._point_blocked(q_new) or (not self._edge_free(parent.position, q_new)):\n            return None\n\n        cost = parent.cost + self._dist(parent.position, q_new)\n        nn = Node(q_new, parent, cost)\n        parent.add_child(nn)\n        Ta.append(nn)\n        nodes.append(nn)\n        self._grid_add(Ga, nn)\n        self._edges_add(edges, parent, nn)\n\n        # Gentle local rewiring\n        if self.rewire_cap > 0:\n            self._rewire_neighbors(Ga, nn, edges, self.rewire_cap)\n\n        # Try greedy connect from the opposite tree\n        meet, ok = self._greedy_connect(Tb, Gb, nn.position, nodes, edges)\n        if ok:\n            pa = nn.path_to_root()\n            pb = meet.path_to_root()\n            # Determine which root belongs to which\n            if Ta[0].position == self.start:\n                # pa: start->..., pb: goal->...\n                path = pa + pb[-2::-1]\n            else:\n                # pa: goal->..., pb: start->...\n                path = pb + pa[-2::-1]\n            L = self._path_len(path)\n            return (self._dedup(path), L)\n        return None\n\n    # RNG\n    def _seed_rng(self):\n        s = 2166136261\n        for v in self.start + self.goal:\n            s ^= int(v * 10007 + 0.5) & 0xffffffff\n            s = (s * 16777619) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Sampling\n    def _sample_target(self, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._sample_informed_ellipse(self.start, self.goal, best_len * 1.01)\n            if p is not None and self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return self.goal\n        if r2 < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t,\n                     self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t)\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_informed_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and (not self._point_blocked(p)):\n                return p\n        return None\n\n    # Geometry helpers\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(self._lerp(a, b, r))\n\n    def _steer_dynamic(self, a, b):\n        if self._edge_free(a, b):\n            d = self._dist(a, b)\n            step = self.connect_step if d > self.connect_step else d\n            return self._steer(a, b, step)\n        return self._steer(a, b, self.step)\n\n    # Node grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n            if best is not None:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        seen = {}\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            i2 = id(n)\n                            if i2 in seen:\n                                continue\n                            seen[i2] = True\n                            d2 = 0.0\n                            p = n.position\n                            for i in range(self.dim):\n                                di = p[i] - pos[i]\n                                d2 += di * di\n                            if d2 <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        i2 = id(n)\n                        if i2 in seen:\n                            continue\n                        seen[i2] = True\n                        d2 = 0.0\n                        p = n.position\n                        for i in range(self.dim):\n                            di = p[i] - pos[i]\n                            d2 += di * di\n                        if d2 <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _adaptive_radius(self, n_nodes):\n        t = float(max(1, n_nodes))\n        base = 1.2 * self.step\n        extra = self.neighbor_radius_scale * self.step / ((1.0 + t) ** (1.0 / 3.0))\n        r = base + extra\n        if r < 1.05 * self.step:\n            r = 1.05 * self.step\n        return r\n\n    def _too_close(self, grid, pos, radius):\n        nb = self._neighbors_within(grid, pos, radius, 1)\n        return len(nb) > 0\n\n    # Parent selection\n    def _select_parent(self, grid, newp, fallback_near):\n        r = self._adaptive_radius(len(grid))\n        neigh = self._neighbors_within(grid, newp, r, 96)\n        best = fallback_near\n        best_cost = fallback_near.cost + self._dist(fallback_near.position, newp)\n        for n in neigh:\n            if n is fallback_near:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = c\n        return best\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _rewire_neighbors(self, grid, node, edges, cap):\n        r = self._adaptive_radius(len(grid))\n        neigh = self._neighbors_within(grid, node.position, r, 128)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            if self._point_blocked(nb.position) or self._point_blocked(node.position):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            newc = node.cost + self._dist(node.position, nb.position)\n            if newc + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= cap:\n                    break\n\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        if self._point_blocked(child.position) or self._point_blocked(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._edges_remove(edges, old, child)\n        new_parent.add_child(child)\n        self._edges_add(edges, new_parent, child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            for c in n.children:\n                stack.append(c)\n\n    # Greedy connect\n    def _greedy_connect(self, T, G, target_pos, nodes, edges):\n        cur = self._nearest(G, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < self.connect_steps:\n            # Visible? insert exact meeting point\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                    if not self._too_close(G, target_pos, 0.75 * self.dupe_radius):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                            return cur, True\n                        cur.add_child(nn)\n                        T.append(nn)\n                        nodes.append(nn)\n                        self._grid_add(G, nn)\n                        self._edges_add(edges, cur, nn)\n                        return nn, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(G, nxt, 0.75 * self.dupe_radius):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                return cur, False\n            cur.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            self._grid_add(G, nn)\n            self._edges_add(edges, cur, nn)\n            cur = nn\n            steps += 1\n        # Final visibility check\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                if not self._too_close(G, target_pos, 0.75 * self.dupe_radius):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                        return cur, True\n                    cur.add_child(nn)\n                    T.append(nn)\n                    nodes.append(nn)\n                    self._grid_add(G, nn)\n                    self._edges_add(edges, cur, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(3.5, self.step * 1.6)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Edge bookkeeping\n    def _edges_add(self, edges, parent, child):\n        key = (id(parent), id(child))\n        if key in self._eindex:\n            return\n        edges.append((parent, child))\n        self._eindex[key] = len(edges) - 1\n\n    def _edges_remove(self, edges, parent, child):\n        key = (id(parent), id(child))\n        idx = self._eindex.get(key)\n        if idx is None:\n            return\n        last = len(edges) - 1\n        if idx != last:\n            edges[idx] = edges[last]\n            pk, ck = id(edges[idx][0]), id(edges[idx][1])\n            self._eindex[(pk, ck)] = idx\n        edges.pop()\n        self._eindex.pop(key, None)\n\n    # Path utilities and smoothing\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _elastic_smooth(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                target = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                t = 1.0\n                best = b\n                while t > 1e-3:\n                    cand = tuple(b[k] + (target[k] - b[k]) * t for k in range(self.dim))\n                    cand = self._clamp(cand)\n                    if (not self._point_blocked(cand)) and self._edge_free(a, cand) and self._edge_free(cand, c):\n                        best = cand\n                        break\n                    t *= 0.5\n                if best != b:\n                    cur[i] = best\n                    moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._shortcut(path, self.shortcut_attempts)\n        p2 = self._visibility_prune(p1)\n        p3 = self._elastic_smooth(p2, self.smooth_passes)\n        return self._dedup(p3)",
     "objective": -47.53913,
     "time_improvement": 86.0,
     "length_improvement": 21.0,
     "smoothness_improvement": 1812.0,
     "node_improvement": 93.0,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.004579019546508789,
               "num_nodes_avg": 30.0,
               "path_length_avg": 146.96078572191126,
               "smoothness_avg": 0.03859037591406768,
               "success_improvement": 0.0,
               "time_improvement": 81.43988774523116,
               "node_improvement": 92.44522790229162,
               "length_improvement": 19.448464603147585,
               "smoothness_improvement": 504.0231833977275,
               "objective_score": 38.621161002446534
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.023305273056030272,
               "num_nodes_avg": 122.0,
               "path_length_avg": 229.66193713526982,
               "smoothness_avg": 0.11885248032537557,
               "success_improvement": 0.0,
               "time_improvement": 86.065738755588,
               "node_improvement": 91.80272794463482,
               "length_improvement": 23.332234931912975,
               "smoothness_improvement": 2958.1599247532718,
               "objective_score": 54.609862209590545
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.004154682159423828,
               "num_nodes_avg": 32.0,
               "path_length_avg": 120.49632735979439,
               "smoothness_avg": 0.1630888303105967,
               "success_improvement": 0.0,
               "time_improvement": 91.76911192279043,
               "node_improvement": 95.93134138588684,
               "length_improvement": 19.972076786142434,
               "smoothness_improvement": 1974.4778835855395,
               "objective_score": 49.38636906645029
          }
     ],
     "success_rate": 1.0
}