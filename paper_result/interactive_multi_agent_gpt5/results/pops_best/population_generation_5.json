{
     "operator": "m3",
     "algorithm_description": "BiCon-Lite*: Simplified Bi-directional RRT-Connect with local best-parent and light rewiring. It grows two trees from start and goal using uniform sampling with small goal bias and informed sampling once a path bound is known. Each added node is chosen from a few nearest candidates by lowest path cost if the edge is collision-free; after insertion, nearby nodes can be rewired if cheaper. Trees greedily connect toward each other; upon connection, the path is visibility-pruned and shortcut for length and smoothness.",
     "planning_mechanism": "Alternate expanding start/goal trees. For each iteration: sample a target (uniform, goal-biased, or informed ellipse), steer one step from the nearest node, reject if outside/duplicate/colliding, then pick a best feasible parent among k-nearest to insert. Lightly rewire nearby neighbors if the new route is cheaper (cycle-safe). Attempt a greedy connect from the opposite tree toward the new node by incremental steps; if it reaches within one step and the final edge is free, extract the full path (start-to-A, cross-edge, B-to-goal), then prune and shortcut. Always check node and edge collisions before adding any node or edge.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n\n    def attach(self, new_parent):\n        if new_parent is self.parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            if self not in new_parent.children:\n                new_parent.children.append(self)\n\n    def is_ancestor_of(self, other):\n        cur = other\n        while cur is not None:\n            if cur is self:\n                return True\n            cur = cur.parent\n        return False\n\n    def propagate_cost(self, delta):\n        if delta == 0.0:\n            return\n        self.cost += delta\n        for c in self.children:\n            c.propagate_cost(delta)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=10.0,\n        goal_bias=0.1,\n        informed_bias=0.5,\n        dupe_radius_ratio=0.5,\n        neighbor_radius_factor=2.5,\n        k_near=5,\n        shortcut_attempts=80\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.neighbor_radius_factor = float(neighbor_radius_factor)\n        self.k_near = int(k_near)\n        self.shortcut_attempts = int(shortcut_attempts)\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacle(self.start) or self._point_in_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._seed_rng()\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.neighbor_radius = max(self.step_size * 1.5, self.step_size * self.neighbor_radius_factor)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            edges = [(n0, n1)]\n            return PlannerResult(True, self._finalize_path([self.start, self.goal]), [n0, n1], edges)\n\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        A = [a_root]\n        B = [b_root]\n\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            grow_A = (it % 2 == 0)\n            T = A if grow_A else B\n            O = B if grow_A else A\n            attractor = self.goal if grow_A else self.start\n\n            qrand = self._sample(attractor, best_len)\n            if qrand is None:\n                continue\n\n            qnear = self._nearest_in(T, qrand)\n            if qnear is None:\n                continue\n\n            qnew_pos = self._steer(qnear.position, qrand)\n            if not self._in_bounds(qnew_pos):\n                continue\n            if self._point_in_obstacle(qnew_pos):\n                continue\n            if self._has_near_in(T, qnew_pos, self.dupe_radius):\n                continue\n\n            parent = self._best_parent(T, qnew_pos, qnear)\n            if parent is None:\n                continue\n            if not self._edge_free(parent.position, qnew_pos):\n                continue\n\n            qnew_cost = parent.cost + self._dist(parent.position, qnew_pos)\n            qnew = Node(qnew_pos, parent, qnew_cost)\n            T.append(qnew)\n            nodes.append(qnew)\n            edges.append((parent, qnew))\n\n            self._light_rewire(T, qnew, edges)\n\n            ok, last_other, added = self._connect_toward(O, qnew.position, nodes, edges)\n            if ok and last_other is not None:\n                edges.append((last_other, qnew))\n                path = self._extract_path(qnew, last_other)\n                best_len = self._path_len(path)\n                return PlannerResult(True, self._finalize_path(path), nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0xA5A5A5A5\n        for v in self.start + self.goal:\n            s ^= (int(v * 1315423911) + (s << 7) + (s >> 3)) & 0xffffffff\n            s &= 0xffffffff\n        s ^= (len(self.obstacles) * 0x9E3779B9) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            tgt = a\n        elif d <= self.step_size:\n            tgt = b\n        else:\n            r = self.step_size / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n        out = tuple(max(0.0, min(tgt[i], self.bounds[i])) for i in range(self.dims))\n        return out\n\n    # Nearest and neighbors\n    def _nearest_in(self, nodes_list, pos):\n        best = None\n        bd = 1e100\n        for n in nodes_list:\n            d = self._dist(n.position, pos)\n            if d < bd:\n                bd = d\n                best = n\n        return best\n\n    def _k_nearest_in(self, nodes_list, pos, k):\n        if not nodes_list:\n            return []\n        pairs = []\n        for n in nodes_list:\n            pairs.append((self._dist(n.position, pos), n))\n        pairs.sort(key=lambda x: x[0])\n        out = [n for _, n in pairs[:max(1, k)]]\n        return out\n\n    def _neighbors_radius(self, nodes_list, pos, radius):\n        out = []\n        r = float(radius)\n        for n in nodes_list:\n            if self._dist(n.position, pos) <= r:\n                out.append(n)\n        return out\n\n    def _has_near_in(self, nodes_list, pos, radius):\n        r = float(radius)\n        for n in nodes_list:\n            if self._dist(n.position, pos) <= r:\n                return True\n        return False\n\n    # Parent selection\n    def _best_parent(self, nodes_list, qpos, fallback):\n        cands = self._k_nearest_in(nodes_list, qpos, self.k_near)\n        if fallback not in cands:\n            cands.append(fallback)\n        best = None\n        best_cost = 1e100\n        for p in cands:\n            if not self._edge_free(p.position, qpos):\n                continue\n            c = p.cost + self._dist(p.position, qpos)\n            if c < best_cost:\n                best_cost = c\n                best = p\n        return best\n\n    # Light rewiring\n    def _light_rewire(self, nodes_list, qnew, edges):\n        nbrs = self._neighbors_radius(nodes_list, qnew.position, self.neighbor_radius)\n        rewired = 0\n        for w in nbrs:\n            if w is qnew or w is qnew.parent:\n                continue\n            if w.is_ancestor_of(qnew):\n                continue\n            d = self._dist(qnew.position, w.position)\n            cand_cost = qnew.cost + d\n            if cand_cost + 1e-12 < w.cost and self._edge_free(qnew.position, w.position):\n                oldp = w.parent\n                self._replace_edge(edges, oldp, w, qnew)\n                w.attach(qnew)\n                delta = cand_cost - w.cost\n                w.propagate_cost(delta)\n                rewired += 1\n                if rewired >= 10:\n                    break\n\n    # Connect toward a target (other tree growth)\n    def _connect_toward(self, tree_nodes, target_pos, all_nodes, edges):\n        if not tree_nodes:\n            return False, None, []\n        cur = self._nearest_in(tree_nodes, target_pos)\n        added = []\n        for _ in range(1000):\n            nxt = self._steer(cur.position, target_pos)\n            if self._dist(cur.position, nxt) <= 1e-9:\n                break\n            if not self._in_bounds(nxt):\n                break\n            if self._point_in_obstacle(nxt):\n                break\n            if self._has_near_in(tree_nodes, nxt, self.dupe_radius):\n                # If very close to some node, snap to the nearest and continue\n                cur = self._nearest_in(tree_nodes, nxt)\n                if self._dist(cur.position, target_pos) <= self.step_size and self._edge_free(cur.position, target_pos):\n                    return True, cur, added\n                continue\n            if not self._edge_free(cur.position, nxt):\n                break\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            q = Node(nxt, cur, new_cost)\n            tree_nodes.append(q)\n            all_nodes.append(q)\n            edges.append((cur, q))\n            added.append(q)\n            cur = q\n            if self._dist(cur.position, target_pos) <= self.step_size and self._edge_free(cur.position, target_pos):\n                return True, cur, added\n        return False, cur, added\n\n    # Collision\n    def _point_in_obstacle(self, p):\n        if self.is3d:\n            px, py, pz = p\n            for x, y, z, w, h, d in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for x, y, w, h in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        if self.is3d:\n            for x, y, z, w, h, d in self.obstacles:\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return False\n            return True\n        else:\n            for x, y, w, h in self.obstacles:\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return False\n            return True\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Edges\n    def _replace_edge(self, edges, old_parent, child, new_parent):\n        if old_parent is not None:\n            rm = -1\n            for i, (u, v) in enumerate(edges):\n                if u is old_parent and v is child:\n                    rm = i\n                    break\n            if rm >= 0:\n                edges.pop(rm)\n        if new_parent is not None:\n            exists = False\n            for u, v in edges:\n                if u is new_parent and v is child:\n                    exists = True\n                    break\n            if not exists:\n                edges.append((new_parent, child))\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        for _ in range(24):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p is not None and not self._point_in_obstacle(p):\n                    return p\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._in_bounds(p) and not self._point_in_obstacle(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(16):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path ops\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        return pa + pb[::-1]\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pruned[-1], path[j]):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_L = self._path_len(pts)\n        tries = 0\n        while tries < attempts and len(pts) > 2:\n            n = len(pts)\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best_L + 1e-12:\n                    pts = cand\n                    best_L = L\n            tries += 1\n        return pts\n\n    def _finalize_path(self, path):\n        if not path:\n            return []\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        return p",
     "objective": -42.61971,
     "time_improvement": 88.0,
     "length_improvement": 13.0,
     "smoothness_improvement": 1715.0,
     "node_improvement": 94.0,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.005434727668762207,
               "num_nodes_avg": 33.0,
               "path_length_avg": 172.03461483544805,
               "smoothness_avg": 0.051447969062332066,
               "success_improvement": 0.0,
               "time_improvement": 77.97145118473429,
               "node_improvement": 91.68975069252078,
               "length_improvement": 5.705101545770078,
               "smoothness_improvement": 705.2724368784732,
               "objective_score": 30.3408584672747
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.012911844253540038,
               "num_nodes_avg": 78.0,
               "path_length_avg": 254.30361579440722,
               "smoothness_avg": 0.12651907716440625,
               "success_improvement": 0.0,
               "time_improvement": 92.27998699936137,
               "node_improvement": 94.75912114493046,
               "length_improvement": 15.106133324099327,
               "smoothness_improvement": 3155.4269834480324,
               "objective_score": 52.52481101150817
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.0025941610336303713,
               "num_nodes_avg": 30.0,
               "path_length_avg": 125.19016890049133,
               "smoothness_avg": 0.10884440067125287,
               "success_improvement": 0.0,
               "time_improvement": 94.86067807289716,
               "node_improvement": 96.18563254926892,
               "length_improvement": 16.854650731526867,
               "smoothness_improvement": 1284.492742480391,
               "objective_score": 44.99345757318722
          }
     ],
     "success_rate": 1.0
}