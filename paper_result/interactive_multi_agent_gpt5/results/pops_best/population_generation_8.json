{
     "operator": "m1",
     "algorithm_description": "LION-ABiRT*: Lazy Informed Ordered-Neighbors Anytime Bi-directional RRT*. It alternates growth of two trees using ring-hash nearest lookup, adaptive step steering, and lazy parent selection that orders k-nearest candidates by a cost+smoothness surrogate and collision-checks only until a feasible parent is found. A dynamic A*-like f=g+h gate with informed (elliptical) and corridor-biased sampling focuses search once an incumbent path exists. Local, bounded rewiring improves costs with capped subtree propagation. Cross-tree connection ranks opposite-tree candidates by estimated total cost and tests only the best few, with short micro-bridges when needed. On success, a light visibility prune, targeted shortcuts, and curvature-aware elastic smoothing produce a short, smooth path. It warm-starts from a previously valid solution when possible and returns the first improved feasible path to reduce time.",
     "planning_mechanism": "Mechanism: Initialize two trees at start/goal. Per iteration: sample (goal/informed-ellipse/corridor/low-discrepancy/uniform), find a near node via ring-hash, adaptively steer with decreasing step until a valid edge is found, gate by f-bound, and lazily choose a smooth, low-cost parent among ordered k-neighbors with a single successful collision test. Insert, then locally rewire k neighbors with capped cost propagation. Try to connect to the opposite tree by testing the top-ranked beam candidates; otherwise, insert a few guided micro-steps from the other tree toward the new node and retry. When bridged, assemble, prune, shortcut around largest bends, smooth elastically under collision and bounds, and return.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = set()\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.add(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_min=3.0,\n                 step_max=7.0,\n                 neighbor_k=14,\n                 ring_max=2,\n                 goal_bias=0.18,\n                 informed_bias=0.65,\n                 corridor_bias=0.55,\n                 beam_k=8,\n                 connect_steps=3,\n                 grid_cell_factor=1.10,\n                 gate_init=1.25,\n                 gate_final=1.05,\n                 angle_weight=0.035,\n                 dupe_ratio_far=0.50,\n                 dupe_ratio_near=0.22,\n                 anchor_stride=16,\n                 smoothing_trials=60,\n                 smooth_passes=3,\n                 edge_cache_max=20000):\n        self.max_iter = max_iter\n        self.step_min = step_min\n        self.step_max = step_max\n        self.neighbor_k = neighbor_k\n        self.ring_max = ring_max\n        self.goal_bias = goal_bias\n        self.informed_bias = informed_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.connect_steps = connect_steps\n        self.grid_cell_factor = grid_cell_factor\n        self.gate_init = gate_init\n        self.gate_final = gate_final\n        self.angle_weight = angle_weight\n        self.dupe_ratio_far = dupe_ratio_far\n        self.dupe_ratio_near = dupe_ratio_near\n        self.anchor_stride = max(1, int(anchor_stride))\n        self.smoothing_trials = smoothing_trials\n        self.smooth_passes = smooth_passes\n        self.edge_cache_max = max(2000, int(edge_cache_max))\n\n        # runtime state\n        self.dim = 2\n        self.bounds = None\n        self.cell = 1.0\n        self._seed = 7\n        self._halton_idx = 1\n        self._edge_cache = {}\n        self._cache_bin = 1.0\n        self.prev_path = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obs(start, obstacles, is_3d) or self._point_in_obs(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # warm-start with previous solution if still valid\n        if self.prev_path and self._same_ends(self.prev_path, start, goal):\n            if self._path_free(self.prev_path, obstacles, is_3d):\n                nodes = []\n                edges = []\n                s = Node(start, None, 0.0)\n                nodes.append(s)\n                last = s\n                cost = 0.0\n                for i in range(1, len(self.prev_path)):\n                    p = self.prev_path[i]\n                    n = Node(p, None, 0.0)\n                    cost += self._dist(last.position, p)\n                    n.cost = cost\n                    n.attach(last)\n                    nodes.append(n)\n                    last = n\n                for n in nodes:\n                    if n.parent is not None:\n                        edges.append((n.parent, n))\n                return PlannerResult(True, list(self.prev_path), nodes, edges)\n\n        # direct LOS early exit\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.add(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            path = [start, goal]\n            self.prev_path = path\n            return PlannerResult(True, path, nodes, edges)\n\n        # setup discretizations and caches\n        self.cell = max(1.0, self.step_max * self.grid_cell_factor)\n        self._seed = 7\n        self._halton_idx = 1\n        self._edge_cache = {}\n        self._cache_bin = max(0.5, 0.1 * self.step_max)\n\n        # init trees\n        a_root = Node(start, None, 0.0)\n        b_root = Node(goal, None, 0.0)\n        tree_a, tree_b = [a_root], [b_root]\n        grid_a, grid_b = {}, {}\n        anchors_a, anchors_b = [a_root], [b_root]\n        self._grid_add(grid_a, a_root)\n        self._grid_add(grid_b, b_root)\n        all_nodes = [a_root, b_root]\n\n        best_path = None\n        c_best = float('inf')\n        sg_dist = self._dist(start, goal)\n\n        for it in range(self.max_iter):\n            from_start = (it % 2 == 0)\n            if from_start:\n                tree_x, tree_y = tree_a, tree_b\n                grid_x, grid_y = grid_a, grid_b\n                anchors_x, anchors_y = anchors_a, anchors_b\n                root_x, root_y = a_root, b_root\n                attractor = goal\n            else:\n                tree_x, tree_y = tree_b, tree_a\n                grid_x, grid_y = grid_b, grid_a\n                anchors_x, anchors_y = anchors_b, anchors_a\n                root_x, root_y = b_root, a_root\n                attractor = start\n\n            # sample\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = attractor\n            else:\n                used_informed = (c_best < float('inf') and self._rand() < self.informed_bias)\n                if used_informed:\n                    x_rand = self._ellipse_sample(root_x.position, root_y.position, c_best, 8)\n                else:\n                    if self._rand() < self.corridor_bias:\n                        width = max(self.step_max, 0.2 * (sg_dist if c_best == float('inf') else c_best))\n                        x_rand = self._corridor_sample(root_x.position, root_y.position, width, obstacles, is_3d)\n                    else:\n                        if self._rand() < 0.6:\n                            x_rand = self._halton_sample()\n                        else:\n                            x_rand = self._uniform_free(obstacles, is_3d)\n\n            # nearest\n            n_near = self._nearest_hashed(grid_x, tree_x, anchors_x, x_rand)\n            if n_near is None:\n                continue\n\n            # adaptive steer (shortening until feasible)\n            tried = False\n            x_new_pos = None\n            for scale in (1.1, 1.0, 0.7, 0.45):\n                step = max(self.step_min, min(self.step_max, scale * self.step_max))\n                tgt = self._steer(n_near.position, x_rand, step)\n                if not self._in_bounds(tgt) or self._point_in_obs(tgt, obstacles, is_3d):\n                    continue\n                tried = True\n                if not self._edge_blocked(n_near.position, tgt, obstacles, is_3d):\n                    x_new_pos = tgt\n                    break\n            if not tried or x_new_pos is None:\n                continue\n\n            # heuristic gate\n            if c_best < float('inf'):\n                g_tent = n_near.cost + self._dist(n_near.position, x_new_pos)\n                f_tent = g_tent + self._dist(x_new_pos, root_y.position)\n                if f_tent >= self._interp_gate(it) * c_best:\n                    continue\n\n            # per-cell throttle via duplicate suppression radius\n            kcell = self._grid_key(x_new_pos)\n            near_ratio = self.dupe_ratio_near if c_best < float('inf') else self.dupe_ratio_far\n            if self._exists_close(grid_x, x_new_pos, self.step_max * near_ratio):\n                continue\n\n            # choose parent lazily among ordered neighbors\n            neigh = self._k_nearest_nodes(grid_x, x_new_pos, self.neighbor_k)\n            parent, new_cost = self._lazy_choose_parent(x_new_pos, n_near, neigh, obstacles, is_3d, attractor)\n\n            if parent is None:\n                continue\n\n            # final checks before insertion\n            if self._point_in_obs(x_new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked(parent.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            # insert\n            x_new = Node(x_new_pos, None, new_cost)\n            x_new.attach(parent)\n            tree_x.append(x_new)\n            all_nodes.append(x_new)\n            self._grid_add(grid_x, x_new)\n            if len(tree_x) % self.anchor_stride == 0:\n                anchors_x.append(x_new)\n\n            # local rewiring with capped propagation\n            self._rewire_local(x_new, neigh, obstacles, is_3d, cap_updates=48)\n\n            # attempt to connect to other tree\n            bridge = None\n            beam = self._k_nearest_nodes(grid_y, x_new.position, min(self.beam_k, max(1, len(tree_y))))\n            # rank beam by estimated total cost\n            scored = []\n            for cand in beam:\n                est = x_new.cost + self._dist(x_new.position, cand.position) + cand.cost\n                scored.append((est, cand))\n            scored.sort(key=lambda t: t[0])\n\n            best_total = float('inf')\n            best_cand = None\n            for _, cand in scored:\n                if not self._edge_blocked(x_new.position, cand.position, obstacles, is_3d):\n                    total = x_new.cost + self._dist(x_new.position, cand.position) + cand.cost\n                    if total < best_total:\n                        best_total = total\n                        best_cand = cand\n                        bridge = cand\n                        break  # accept first feasible best-ranked\n            # guided micro-bridge from other tree if no direct bridge\n            if bridge is None and scored:\n                cur = scored[0][1]\n                steps = 0\n                while steps < self.connect_steps and bridge is None:\n                    step_try = self._steer(cur.position, x_new.position, max(self.step_min, 0.8 * self.step_max))\n                    if not self._in_bounds(step_try) or self._point_in_obs(step_try, obstacles, is_3d):\n                        break\n                    # heuristic gate on other side\n                    if c_best < float('inf'):\n                        g2 = cur.cost + self._dist(cur.position, step_try)\n                        f2 = g2 + self._dist(step_try, root_x.position)\n                        if f2 >= self._interp_gate(it) * c_best:\n                            break\n                    # dupe suppression for other side\n                    if self._exists_close(grid_y, step_try, self.step_max * near_ratio):\n                        break\n                    neigh_b = self._k_nearest_nodes(grid_y, step_try, self.neighbor_k)\n                    p_b, c_b = self._lazy_choose_parent(step_try, cur, neigh_b, obstacles, is_3d, x_new.position)\n                    if p_b is None:\n                        break\n                    if self._point_in_obs(step_try, obstacles, is_3d) or self._edge_blocked(p_b.position, step_try, obstacles, is_3d):\n                        break\n                    nxt = Node(step_try, None, c_b)\n                    nxt.attach(p_b)\n                    tree_y.append(nxt)\n                    all_nodes.append(nxt)\n                    self._grid_add(grid_y, nxt)\n                    if len(tree_y) % self.anchor_stride == 0:\n                        anchors_y.append(nxt)\n                    self._rewire_local(nxt, neigh_b, obstacles, is_3d, cap_updates=32)\n                    if not self._edge_blocked(nxt.position, x_new.position, obstacles, is_3d):\n                        bridge = nxt\n                        break\n                    cur = nxt\n                    steps += 1\n\n            if bridge is not None:\n                # assemble path\n                pa = self._trace_positions(x_new)\n                pb = self._trace_positions(bridge)\n                if from_start:\n                    path = pa + list(reversed(pb))\n                else:\n                    path = pb + list(reversed(pa))\n                # post-process\n                path = self._vis_prune(path, obstacles, is_3d)\n                path = self._shortcut_curvature_focused(path, obstacles, is_3d, self.smoothing_trials)\n                path = self._elastic_smooth(path, obstacles, is_3d, self.smooth_passes)\n                L = self._path_length(path)\n                if L < c_best:\n                    c_best = L\n                    best_path = path\n                # build coherent edges\n                edges = []\n                for n in all_nodes:\n                    if n.parent is not None:\n                        edges.append((n.parent, n))\n                self.prev_path = best_path\n                return PlannerResult(True, best_path, all_nodes, edges)\n\n        edges = []\n        for n in all_nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        ok = best_path is not None\n        if ok:\n            self.prev_path = best_path\n        return PlannerResult(ok, best_path if ok else [], all_nodes, edges)\n\n    # RNG / sampling\n    def _rand(self):\n        self._seed = (1103515245 * self._seed + 12345) % (1 << 31)\n        return self._seed / float(1 << 31)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _halton(self, index, base):\n        f = 1.0\n        r = 0.0\n        i = index\n        while i > 0:\n            f *= 1.0 / base\n            r += f * (i % base)\n            i //= base\n        return r\n\n    def _halton_sample(self):\n        bases = [2, 3, 5]\n        idx = self._halton_idx\n        self._halton_idx += 1\n        coords = []\n        for d in range(self.dim):\n            u = self._halton(idx, bases[d])\n            coords.append(u * self.bounds[d])\n        return tuple(coords)\n\n    def _uniform_free(self, obstacles, is_3d):\n        for _ in range(8):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._point_in_obs(p, obstacles, is_3d):\n                return p\n        return self._halton_sample()\n\n    def _ellipse_sample(self, a, b, c_best, tries):\n        if c_best == float('inf'):\n            return self._halton_sample()\n        for _ in range(tries):\n            p = self._halton_sample()\n            if self._dist(p, a) + self._dist(p, b) <= c_best + 1e-9:\n                return p\n        return self._halton_sample()\n\n    def _corridor_sample(self, a, b, width, obstacles, is_3d):\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n        if self.dim == 2:\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy))\n                    if not self._point_in_obs(p, obstacles, is_3d):\n                        return p\n        else:\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._point_in_obs(p, obstacles, is_3d):\n                        return p\n        return self._uniform_free(obstacles, is_3d)\n\n    # Geometry / utilities\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5 if s > 0.0 else 0.0\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        out = []\n        for i in range(self.dim):\n            v = p[i]\n            if v < 0.0:\n                v = 0.0\n            if v > self.bounds[i]:\n                v = self.bounds[i]\n            out.append(v)\n        return tuple(out)\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _same_ends(self, path, start, goal):\n        if not path or len(path) < 2:\n            return False\n        return path[0] == start and path[-1] == goal\n\n    # Obstacles/collisions\n    def _point_in_obs(self, p, obstacles, is_3d):\n        if is_3d:\n            x, y, z = p\n            for o in obstacles:\n                ox, oy, oz, w, h, d = o\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n        else:\n            x, y = p\n            for o in obstacles:\n                ox, oy, w, h = o\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        q = self._cache_bin\n        if self.dim == 3:\n            qa = (int(a[0] / q + 0.5), int(a[1] / q + 0.5), int(a[2] / q + 0.5))\n            qb = (int(b[0] / q + 0.5), int(b[1] / q + 0.5), int(b[2] / q + 0.5))\n        else:\n            qa = (int(a[0] / q + 0.5), int(a[1] / q + 0.5))\n            qb = (int(b[0] / q + 0.5), int(b[1] / q + 0.5))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        key = self._edge_key(a, b)\n        state = self._edge_cache.get(key)\n        if state is not None:\n            return state == 1\n        blocked = False\n        if is_3d:\n            ax, ay, az = a\n            bx, by, bz = b\n            minx = ax if ax < bx else bx\n            maxx = ax if ax > bx else bx\n            miny = ay if ay < by else by\n            maxy = ay if ay > by else by\n            minz = az if az < bz else bz\n            maxz = az if az > bz else bz\n            for box in obstacles:\n                ox, oy, oz, w, h, d = box\n                bx0, bx1 = ox, ox + w\n                by0, by1 = oy, oy + h\n                bz0, bz1 = oz, oz + d\n                if maxx < bx0 or bx1 < minx or maxy < by0 or by1 < miny or maxz < bz0 or bz1 < minz:\n                    continue\n                if self._seg_box_intersect_3d(a, b, box):\n                    blocked = True\n                    break\n        else:\n            ax, ay = a\n            bx, by = b\n            minx = ax if ax < bx else bx\n            maxx = ax if ax > bx else bx\n            miny = ay if ay < by else by\n            maxy = ay if ay > by else by\n            for box in obstacles:\n                ox, oy, w, h = box\n                bx0, bx1 = ox, ox + w\n                by0, by1 = oy, oy + h\n                if maxx < bx0 or bx1 < minx or maxy < by0 or by1 < miny:\n                    continue\n                if self._seg_box_intersect_2d(a, b, box):\n                    blocked = True\n                    break\n        self._edge_cache[key] = 1 if blocked else 2\n        if len(self._edge_cache) > self.edge_cache_max:\n            self._prune_edge_cache()\n        return blocked\n\n    def _prune_edge_cache(self):\n        # remove roughly half of entries by skipping every other key\n        to_del = []\n        c = 0\n        for k in self._edge_cache:\n            if (c & 1) == 0:\n                to_del.append(k)\n            c += 1\n            if len(to_del) >= self.edge_cache_max // 2:\n                break\n        for k in to_del:\n            try:\n                del self._edge_cache[k]\n            except:\n                pass\n\n    def _seg_box_intersect_2d(self, a, b, box):\n        x, y, w, h = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        ax, ay = a\n        bx, by = b\n        dx = bx - ax\n        dy = by - ay\n        tmin, tmax = 0.0, 1.0\n\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            t1 = (minx - ax) * inv\n            t2 = (maxx - ax) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            t1 = (miny - ay) * inv\n            t2 = (maxy - ay) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    def _seg_box_intersect_3d(self, a, b, box):\n        x, y, z, w, h, d = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        minz, maxz = z, z + d\n        ax, ay, az = a\n        bx, by, bz = b\n        dx = bx - ax\n        dy = by - ay\n        dz = bz - az\n        tmin, tmax = 0.0, 1.0\n\n        # X\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            t1 = (minx - ax) * inv\n            t2 = (maxx - ax) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        # Y\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            t1 = (miny - ay) * inv\n            t2 = (maxy - ay) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        # Z\n        if dz == 0.0:\n            if az < minz or az > maxz:\n                return False\n        else:\n            inv = 1.0 / dz\n            t1 = (minz - az) * inv\n            t2 = (maxz - az) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    def _path_free(self, path, obstacles, is_3d):\n        if not path or len(path) < 2:\n            return False\n        for p in path:\n            if not self._in_bounds(p) or self._point_in_obs(p, obstacles, is_3d):\n                return False\n        for i in range(1, len(path)):\n            if self._edge_blocked(path[i - 1], path[i], obstacles, is_3d):\n                return False\n        return True\n\n    # Spatial hashing\n    def _grid_key(self, pos):\n        if self.dim == 3:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        else:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, nodes, anchors, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.ring_max + 1):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # anchor fallback\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        # lightweight strided scan fallback\n        if best is None and nodes:\n            stride = max(1, len(nodes) // min(64, len(nodes)))\n            for i in range(0, len(nodes), stride):\n                n = nodes[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _k_nearest_nodes(self, grid, pos, kcap):\n        key = self._grid_key(pos)\n        items = []\n        ring = 0\n        while len(items) < kcap and ring <= self.ring_max:\n            cand = self._collect_ring(grid, key, ring)\n            for n in cand:\n                items.append((self._dist(n.position, pos), n))\n            ring += 1\n        if not items:\n            return []\n        items.sort(key=lambda x: x[0])\n        res = []\n        seen = set()\n        for d, n in items:\n            if n in seen:\n                continue\n            seen.add(n)\n            res.append(n)\n            if len(res) >= kcap:\n                break\n        return res\n\n    def _exists_close(self, grid, pos, radius):\n        cand = self._collect_ring(grid, self._grid_key(pos), 1)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Parent selection, rewiring\n    def _angle_penalty(self, parent, new_pos):\n        if parent is None or parent.parent is None:\n            return 0.0\n        a = parent.parent.position\n        b = parent.position\n        c = new_pos\n        v1 = tuple(b[i] - a[i] for i in range(self.dim))\n        v2 = tuple(c[i] - b[i] for i in range(self.dim))\n        n1 = 0.0\n        n2 = 0.0\n        dot = 0.0\n        for i in range(self.dim):\n            n1 += v1[i] * v1[i]\n            n2 += v2[i] * v2[i]\n            dot += v1[i] * v2[i]\n        if n1 <= 1e-12 or n2 <= 1e-12:\n            return 0.0\n        cs = dot / ((n1 ** 0.5) * (n2 ** 0.5))\n        if cs > 1.0:\n            cs = 1.0\n        if cs < -1.0:\n            cs = -1.0\n        return (1.0 - cs)\n\n    def _lazy_choose_parent(self, new_pos, fallback, neighbors, obstacles, is_3d, attractor):\n        # order candidates by g + dist + smoothness surrogate to reduce collision checks\n        beta = self.angle_weight * max(1.0, self.step_max)\n        cand = [fallback] + neighbors\n        scored = []\n        seen = set()\n        for p in cand:\n            if p in seen:\n                continue\n            seen.add(p)\n            d = self._dist(p.position, new_pos)\n            g = p.cost + d\n            smooth = beta * self._angle_penalty(p, new_pos)\n            # small bias toward pointing to attractor\n            to_attr = 0.0\n            if attractor is not None:\n                to_attr = 0.02 * self._dist(new_pos, attractor)\n            scored.append((g + smooth + to_attr, p, g))\n        scored.sort(key=lambda t: t[0])\n        for _, p, g in scored:\n            if not self._edge_blocked(p.position, new_pos, obstacles, is_3d):\n                return p, g\n        return None, float('inf')\n\n    def _propagate_delta(self, node, delta, cap_updates):\n        # bounded subtree cost propagation\n        stack = [node]\n        updates = 0\n        while stack and updates < cap_updates:\n            cur = stack.pop()\n            for ch in list(cur.children):\n                ch.cost += delta\n                updates += 1\n                if updates >= cap_updates:\n                    break\n                stack.append(ch)\n\n    def _rewire_local(self, new_node, neighbors, obstacles, is_3d, cap_updates=48):\n        updates_left = cap_updates\n        for m in neighbors:\n            if m is new_node or m is new_node.parent:\n                continue\n            alt = new_node.cost + self._dist(new_node.position, m.position)\n            if alt + 1e-12 < m.cost:\n                if not self._edge_blocked(new_node.position, m.position, obstacles, is_3d):\n                    delta = alt - m.cost\n                    old_parent = m.parent\n                    m.attach(new_node)\n                    m.cost = alt\n                    if delta != 0.0 and updates_left > 0:\n                        used_before = cap_updates - updates_left\n                        self._propagate_delta(m, delta, updates_left)\n                        used_after = cap_updates - updates_left\n                        updates_left -= max(1, used_after - used_before)\n\n    # Heuristic gate schedule\n    def _interp_gate(self, it):\n        if self.max_iter <= 1:\n            return self.gate_final\n        t = min(1.0, max(0.0, it / float(self.max_iter - 1)))\n        return self.gate_init + (self.gate_final - self.gate_init) * t\n\n    # Path helpers and post-processing\n    def _trace_positions(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        out.reverse()\n        return out\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _vis_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(pruned[-1], path[j], obstacles, is_3d):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut_curvature_focused(self, path, obstacles, is_3d, trials):\n        if not path or len(path) < 3:\n            return list(path)\n        pts = list(path)\n        n = len(pts)\n        for _ in range(trials):\n            if n < 3:\n                break\n            # bias toward larger bends\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            # prefer skipping around corners\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts\n\n    def _elastic_smooth(self, path, obstacles, is_3d, passes):\n        if not path or len(path) < 3:\n            return list(path)\n        pts = list(path)\n        alpha = 0.32\n        lam_curv = 0.30\n        for _ in range(passes):\n            changed = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                b = pts[i]\n                c = pts[i + 1]\n                # curvature proxy\n                v1 = tuple(b[d] - a[d] for d in range(self.dim))\n                v2 = tuple(c[d] - b[d] for d in range(self.dim))\n                n1 = 0.0\n                n2 = 0.0\n                dot = 0.0\n                for d in range(self.dim):\n                    n1 += v1[d] * v1[d]\n                    n2 += v2[d] * v2[d]\n                    dot += v1[d] * v2[d]\n                curv = 0.0\n                if n1 > 1e-12 and n2 > 1e-12:\n                    cs = dot / ((n1 ** 0.5) * (n2 ** 0.5))\n                    if cs > 1.0:\n                        cs = 1.0\n                    if cs < -1.0:\n                        cs = -1.0\n                    curv = (1.0 - cs)\n                # elastic update\n                newp = tuple(b[d] - alpha * (a[d] - 2.0 * b[d] + c[d]) for d in range(self.dim))\n                newp = self._clamp(newp)\n                if self._point_in_obs(newp, obstacles, is_3d):\n                    continue\n                if self._edge_blocked(a, newp, obstacles, is_3d) or self._edge_blocked(newp, c, obstacles, is_3d):\n                    continue\n                old_len = self._dist(a, b) + self._dist(b, c)\n                new_len = self._dist(a, newp) + self._dist(newp, c)\n                if new_len + lam_curv * curv <= old_len + lam_curv * curv + 1e-9 or new_len <= old_len - 1e-6:\n                    pts[i] = newp\n                    changed = True\n            if not changed:\n                break\n        return pts",
     "objective": -43.64906,
     "time_improvement": 86.0,
     "length_improvement": 17.0,
     "smoothness_improvement": 1496.0,
     "node_improvement": 96.0,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.007047319412231445,
               "num_nodes_avg": 24.1,
               "path_length_avg": 155.28141234263038,
               "smoothness_avg": 0.03865255099982554,
               "success_improvement": 0.0,
               "time_improvement": 71.98348501765808,
               "node_improvement": 93.93099974817426,
               "length_improvement": 14.887797303565245,
               "smoothness_improvement": 504.99635850519775,
               "objective_score": 33.052705679962564
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.00686192512512207,
               "num_nodes_avg": 27.8,
               "path_length_avg": 236.27561310776304,
               "smoothness_avg": 0.12059056051198921,
               "success_improvement": 0.0,
               "time_improvement": 95.71693654634275,
               "node_improvement": 98.13209702344957,
               "length_improvement": 21.124399528186895,
               "smoothness_improvement": 3002.881979843398,
               "objective_score": 56.404130580031946
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.004746818542480468,
               "num_nodes_avg": 23.7,
               "path_length_avg": 126.69003120079826,
               "smoothness_avg": 0.08501065961584595,
               "success_improvement": 0.0,
               "time_improvement": 90.2286090089029,
               "node_improvement": 96.98664971392243,
               "length_improvement": 15.85851360743081,
               "smoothness_improvement": 981.3293154793831,
               "objective_score": 41.49033744452626
          }
     ],
     "success_rate": 1.0
}