{
     "operator": "m3",
     "algorithm_description": "SIMPLE-BiRRT-i: a simplified informed bi-directional RRT with spatial hashing and ghost-connect. It grows two trees from start and goal with small-step steering, hashed nearest search, light duplicate suppression, and early termination upon a valid bridge. It maintains coherence (node/edge checks before add), avoids heavy rewiring/compression, and performs greedy visibility pruning followed by bounded shortcut smoothing for shorter, smoother paths.",
     "planning_mechanism": "Alternate expanding start and goal trees. Each iteration: sample uniformly with goal-bias and optionally inside the informed ellipse if a path bound exists; choose a hashed-nearest parent; steer one step; validate node and edge; insert into the active tree. Try to connect to the opposite tree by direct line or a ghost (non-committal) short-step chain; if feasible, commit the chain, extract the bi-tree path, prune by visibility, shortcut, and return.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        goal_bias=0.15,\n        informed_bias=0.5,\n        dupe_radius_ratio=0.35,\n        connect_radius_factor=3.0,\n        connect_steps=6,\n        smoothing_iters=60,\n        cell_factor=1.0\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.connect_radius_factor = float(connect_radius_factor)\n        self.connect_steps = int(connect_steps)\n        self.smoothing_iters = int(smoothing_iters)\n        self.cell_factor = float(cell_factor)\n        self._rng = 1234567\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Direct path early exit\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        self.cell_size = max(1.0, self.step_size * self.cell_factor)\n        self.dupe_radius = max(0.25, self.step_size * self.dupe_radius_ratio)\n        self.connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n\n        # Trees\n        nodes = []\n        edges = []\n\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        nodes.extend([root_a, root_b])\n        edges.extend([])\n\n        tree_a, tree_b = [root_a], [root_b]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, root_a)\n        self._grid_insert(grid_b, root_b)\n\n        best_len = float('inf')  # enables informed sampling when a bound appears\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            tree = tree_a if side_a else tree_b\n            other_tree = tree_b if side_a else tree_a\n            grid = grid_a if side_a else grid_b\n            other_grid = grid_b if side_a else grid_a\n            attractor = self.goal if side_a else self.start\n\n            s = self._sample(attractor, best_len)\n            if s is None:\n                continue\n\n            parent = self._nearest_hashed(grid, tree, s, 2)\n            if parent is None:\n                continue\n\n            new_pos = self._steer(parent.position, s)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n            if self._has_nearby(grid, new_pos, self.dupe_radius):\n                continue\n\n            new_node = Node(new_pos, parent, parent.cost + self._dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(grid, new_node)\n\n            # Try to connect directly to nearest in the opposite tree\n            near_other = self._nearest_hashed(other_grid, other_tree, new_node.position, 2)\n            if near_other is not None:\n                if self._dist(near_other.position, new_node.position) <= self.connect_radius and self._edge_free(near_other.position, new_node.position):\n                    path = self._extract_path(new_node, near_other, side_a)\n                    path = self._finalize_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n                # Ghost-connect: plan a short chain without committing, commit only if bridging succeeds\n                ok, chain_positions, last_pos = self._ghost_connect_positions(near_other.position, new_node.position, other_grid)\n                if ok and self._edge_free(last_pos, new_node.position):\n                    # Commit chain into the opposite tree\n                    prev = near_other\n                    for p in chain_positions:\n                        if self._has_nearby(other_grid, p, self.dupe_radius):\n                            prev = self._nearest_hashed(other_grid, other_tree, p, 1)\n                            if prev is None:\n                                prev = near_other\n                            continue\n                        if self._point_in_obstacles(p):\n                            ok = False\n                            break\n                        if not self._edge_free(prev.position, p):\n                            ok = False\n                            break\n                        q = Node(p, prev, prev.cost + self._dist(prev.position, p))\n                        prev.add_child(q)\n                        other_tree.append(q)\n                        nodes.append(q)\n                        edges.append((prev, q))\n                        self._grid_insert(other_grid, q)\n                        prev = q\n                    if ok and self._edge_free(prev.position, new_node.position):\n                        # We do not add a cross-tree edge; extract bi-tree path\n                        path = self._extract_path(new_node, prev, side_a)\n                        L = self._path_len(path)\n                        if L < best_len:\n                            best_len = L\n                        path = self._finalize_path(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1103515245 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761\n        if s == 0:\n            s = 1234567\n        self._rng = s & 0x7fffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0x7fffffff\n        return self._rng / float(1 << 31)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= self.step_size:\n            return tuple(b)\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n\n    # Obstacles\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            px, py, pz = p\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for o in self.obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            for o in self.obstacles:\n                x, y, w, h = o\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Spatial hashing\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, tree, pos, max_rings):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        any_found = False\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n                    any_found = True\n        if any_found:\n            return best\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n            if p and self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        if r < self.goal_bias:\n            p = attractor\n        else:\n            p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n        if self._in_bounds(p) and not self._point_in_obstacles(p):\n            return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [half] * self.dim\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dim))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Ghost connect (non-committal)\n    def _ghost_connect_positions(self, from_pos, to_pos, other_grid):\n        chain = []\n        cur = from_pos\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(cur, to_pos)\n            if not self._in_bounds(nxt):\n                return False, None, None\n            if self._point_in_obstacles(nxt):\n                return False, None, None\n            if not self._edge_free(cur, nxt):\n                return False, None, None\n            if self._has_nearby(other_grid, nxt, self.dupe_radius):\n                return False, None, None\n            chain.append(nxt)\n            cur = nxt\n            if self._dist(cur, to_pos) <= self.step_size or self._edge_free(cur, to_pos):\n                return True, chain, cur\n            steps += 1\n        return False, None, None\n\n    # Paths and smoothing\n    def _path_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _extract_path(self, a_node, b_node, a_forward=True):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return (pa + pb[::-1]) if a_forward else (pb + pa[::-1])\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pruned[-1], path[j]):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_L = self._path_len(pts)\n        for _ in range(self.smoothing_iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best_L + 1e-12:\n                    pts = new_pts\n                    best_L = L\n        return pts\n\n    def _finalize_path(self, path):\n        if not path:\n            return []\n        p = self._visibility_prune(path)\n        p = self._shortcut(p)\n        return p",
     "objective": -40.79252,
     "time_improvement": 68.0,
     "length_improvement": 13.0,
     "smoothness_improvement": 2580.0,
     "node_improvement": 82.0,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.007870960235595702,
               "num_nodes_avg": 48.0,
               "path_length_avg": 179.5861954290845,
               "smoothness_avg": 0.06548709066523807,
               "success_improvement": 0.0,
               "time_improvement": 68.09668444484818,
               "node_improvement": 87.91236464366659,
               "length_improvement": 1.565960559945877,
               "smoothness_improvement": 925.0151764044653,
               "objective_score": 25.993657551444304
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.0211273193359375,
               "num_nodes_avg": 158.0,
               "path_length_avg": 237.3530114017347,
               "smoothness_avg": 0.18862965381071545,
               "success_improvement": 0.0,
               "time_improvement": 87.36794088130645,
               "node_improvement": 89.38386078075656,
               "length_improvement": 20.764732966468724,
               "smoothness_improvement": 4753.576856997666,
               "objective_score": 62.437106329261496
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.026227736473083497,
               "num_nodes_avg": 250.0,
               "path_length_avg": 127.39626037258856,
               "smoothness_avg": 0.16982997215257256,
               "success_improvement": 0.0,
               "time_improvement": 48.039932985286335,
               "node_improvement": 68.21360457724094,
               "length_improvement": 15.389469818547017,
               "smoothness_improvement": 2060.2247102361403,
               "objective_score": 33.94678533789481
          }
     ],
     "success_rate": 1.0
}