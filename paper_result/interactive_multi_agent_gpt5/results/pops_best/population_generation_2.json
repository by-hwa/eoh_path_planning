{
     "operator": "time_expert",
     "algorithm_description": "HASTE-BiRRT: Hashed, Anytime, Saturation\u2011Throttled, Efficient BiRRT-Connect. It accelerates bidirectional RRT with cached collision tests, hashed nearest search with leader fallbacks, per-cell growth throttling, and duplicate-suppressed commit-only connections. A light visibility prune plus brief shortcutting refines the path while keeping postprocessing costs low.",
     "planning_mechanism": "Alternate expanding start/goal trees with goal-biased sampling; find nearest via grid rings, else leader-guided buckets; steer one step and validate with cached edge checks; suppress inserts in saturated/duplicate cells; attempt a single, commit-only direct bridge to the opposite tree, skipping known-blocked cell pairs; upon success, extract start-to-goal path, visibility-prune, then run a few shortcuts; terminate on success or iteration cap.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=7.0,\n                 goal_bias=0.25,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=40,\n                 max_per_cell=6,\n                 search_r_max=2,\n                 leader_stride=25):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.max_per_cell = max_per_cell\n        self.search_r_max = search_r_max\n        self.leader_stride = leader_stride\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # Caches\n        self._edge_blocked_cache = set()   # quantized blocked segments (safe to reuse only for blocked)\n        self._edge_exact_cache = {}        # exact endpoint pairs -> bool\n        self._connect_blocked_cells = set()  # (cellA, cellB) pairs known to fail direct connect\n\n    # ------------- Public API -------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Parameters derived\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.5)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Reset caches\n        self._edge_blocked_cache = set()\n        self._edge_exact_cache = {}\n        self._connect_blocked_cells = set()\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Grids and counts\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        self._grid_add(grid_start, counts_start, start_root)\n        self._grid_add(grid_goal, counts_goal, goal_root)\n\n        # Leaders\n        leaders_start = [start_root]\n        leaders_goal = [goal_root]\n        inserted_since_leader_start = 0\n        inserted_since_leader_goal = 0\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            grid_a = grid_start if active_start else grid_goal\n            counts_a = counts_start if active_start else counts_goal\n            leaders_a = leaders_start if active_start else leaders_goal\n\n            tree_b = goal_tree if active_start else start_tree\n            grid_b = grid_goal if active_start else grid_start\n            counts_b = counts_goal if active_start else counts_start\n            leaders_b = leaders_goal if active_start else leaders_start\n\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest lookup\n            nearest = self._nearest_hashed(grid_a, leaders_a, tree_a, x_rand)\n            if nearest is None:\n                continue\n\n            # Steer\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Per-cell throttling and duplicate suppression\n            key_new = self._grid_key(new_pos)\n            if self._cell_count(counts_a, key_new) >= self.max_per_cell:\n                continue\n            if self._near_duplicate(grid_a, new_pos, dup_radius=0.7 * self.step_size):\n                continue\n\n            # Insert node and edge\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, counts_a, new_node)\n\n            # Leader sampling\n            if active_start:\n                inserted_since_leader_start += 1\n                if inserted_since_leader_start >= self.leader_stride:\n                    leaders_start.append(new_node)\n                    inserted_since_leader_start = 0\n            else:\n                inserted_since_leader_goal += 1\n                if inserted_since_leader_goal >= self.leader_stride:\n                    leaders_goal.append(new_node)\n                    inserted_since_leader_goal = 0\n\n            # Try commit-only direct connection to the other tree (with cell-pair de-dup)\n            other_near = self._nearest_hashed(grid_b, leaders_b, tree_b, new_node.position)\n            if other_near is not None:\n                pair_key = (self._grid_key(new_node.position), self._grid_key(other_near.position))\n                if pair_key not in self._connect_blocked_cells:\n                    if not self._edge_blocked(new_node.position, other_near.position, obstacles, is_3d):\n                        path = self._extract_path(new_node, other_near, a_is_start_tree=active_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n                    else:\n                        # cache blocked cell pair to avoid repeating futile checks\n                        self._connect_blocked_cells.add(pair_key)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ------------- Random -------------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry -------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ------------- Collision & caches -------------\n    def _quant(self, p, q=1.5):\n        # Quantize for blocked-segment cache; coarse to avoid false frees; safe for blocked reuse only\n        if self.dim == 3:\n            return (int(p[0] // q), int(p[1] // q), int(p[2] // q))\n        else:\n            return (int(p[0] // q), int(p[1] // q))\n\n    def _seg_key_exact(self, a, b):\n        # Canonicalize order for undirected segment\n        if a <= b:\n            return (a, b)\n        else:\n            return (b, a)\n\n    def _seg_key_quant_blocked(self, a, b):\n        qa = self._quant(a)\n        qb = self._quant(b)\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        # Exact cache check\n        k_exact = self._seg_key_exact(a, b)\n        cached = self._edge_exact_cache.get(k_exact)\n        if cached is not None:\n            return cached\n        # Blocked quantized cache\n        kq = self._seg_key_quant_blocked(a, b)\n        if kq in self._edge_blocked_cache:\n            self._edge_exact_cache[k_exact] = True\n            return True\n        # Compute\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n        # Update caches\n        self._edge_exact_cache[k_exact] = blocked\n        if blocked:\n            self._edge_blocked_cache.add(kq)\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ------------- Sampling -------------\n    def _sample_free(self, obstacles, is_3d):\n        # Rejection sampling within bounds until a free point is found\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ------------- Grid / NN -------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n\n    def _cell_count(self, counts, key):\n        return counts.get(key, 0)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, leaders, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Local rings\n        for r in range(0, self.search_r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Leader fallback\n        if leaders:\n            lead_best = None\n            lead_bestd = float('inf')\n            for n in leaders:\n                d = self._dist(n.position, pos)\n                if d < lead_bestd:\n                    lead_bestd = d\n                    lead_best = n\n            if lead_best is not None:\n                # Search around leader cell for neighbors\n                lk = self._grid_key(lead_best.position)\n                for r in range(0, min(2, self.search_r_max) + 1):\n                    cand = self._grid_ring_collect(grid, lk, r)\n                    for n in cand:\n                        d = self._dist(n.position, pos)\n                        if d < bestd:\n                            bestd = d\n                            best = n\n                if best is not None:\n                    return best\n        # Sparse random subset fallback (avoid full scan)\n        if tree:\n            trials = min(64, len(tree))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            if best is not None:\n                return best\n        return None\n\n    def _near_duplicate(self, grid, pos, dup_radius):\n        key = self._grid_key(pos)\n        r = 1\n        cand = self._grid_ring_collect(grid, key, r)\n        rr = dup_radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # ------------- Path -------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            # start-tree path to meet, then meet->goal via reversed goal-tree path\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
     "objective": -35.78786,
     "time_improvement": 66.0,
     "length_improvement": 12.0,
     "smoothness_improvement": 1772.0,
     "node_improvement": 88.0,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.016536712646484375,
               "num_nodes_avg": 67.3,
               "path_length_avg": 176.25078259592178,
               "smoothness_avg": 0.05067539409595988,
               "success_improvement": 0.0,
               "time_improvement": 35.1470831615236,
               "node_improvement": 83.05212792747419,
               "length_improvement": 3.3941531868009323,
               "smoothness_improvement": 693.1799609813568,
               "objective_score": 16.046516665444422
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.023010659217834472,
               "num_nodes_avg": 105.2,
               "path_length_avg": 247.25890321415372,
               "smoothness_avg": 0.1191098532602342,
               "success_improvement": 0.0,
               "time_improvement": 85.63605318102866,
               "node_improvement": 92.93153262111133,
               "length_improvement": 17.45786115419664,
               "smoothness_improvement": 2964.7823157454163,
               "objective_score": 50.989444225553655
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.011754655838012695,
               "num_nodes_avg": 94.4,
               "path_length_avg": 127.41557160345823,
               "smoothness_avg": 0.13822063405561777,
               "success_improvement": 0.0,
               "time_improvement": 76.0361625858193,
               "node_improvement": 87.99745708836618,
               "length_improvement": 15.376644218505373,
               "smoothness_improvement": 1658.156262801516,
               "objective_score": 40.327616620856595
          }
     ],
     "success_rate": 1.0
}