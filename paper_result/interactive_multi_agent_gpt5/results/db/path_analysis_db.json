[
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -24.971436625701273,
                "time_improvement": 62.0,
                "length_improvement": 9.0,
                "smoothness_improvement": 168.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.009481477737426757,
                        "num_nodes_avg": 112.0,
                        "path_length_avg": 170.25136521926942,
                        "smoothness_avg": 0.017004537999713392,
                        "success_improvement": 0.0,
                        "time_improvement": 62.815977978432855,
                        "node_improvement": 71.7955175018887,
                        "length_improvement": 6.682528917796031,
                        "smoothness_improvement": 166.15794564080122,
                        "objective_score": 23.68510047241148
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.0245816707611084,
                        "num_nodes_avg": 299.2,
                        "path_length_avg": 258.5973544494462,
                        "smoothness_avg": 0.010851066788952054,
                        "success_improvement": 0.0,
                        "time_improvement": 84.6553804394982,
                        "node_improvement": 79.89652623798965,
                        "length_improvement": 13.67275977263268,
                        "smoothness_improvement": 179.20576418723118,
                        "objective_score": 34.496298816365226
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.030178475379943847,
                        "num_nodes_avg": 287.8,
                        "path_length_avg": 139.5271231166937,
                        "smoothness_avg": 0.020290033291575655,
                        "success_improvement": 0.0,
                        "time_improvement": 38.47611641047452,
                        "node_improvement": 63.40750158931977,
                        "length_improvement": 7.332728393521491,
                        "smoothness_improvement": 158.08772581437248,
                        "objective_score": 16.732910588327112
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm with post-optimization: a single-tree, asymptotically optimal sampler that, after the first feasible path, restricts sampling to a start\u2013goal prolate hyperspheroid to accelerate convergence while continuing local rewiring to reduce path cost.",
                "planning_mechanism": "Mechanism: (1) Grow one tree from the start using uniform sampling; (2) when a goal-connecting edge is found, record the best cost and switch to informed sampling inside the ellipsoid defined by start, goal, and current best path length; (3) for each sample, steer a step from the nearest node, then select the lowest-cost parent among nearby nodes and rewire neighbors if the new node offers cheaper paths; (4) whenever the new node lies within one step of the goal and the edge is collision-free, connect and update the best path; (5) after the first solution, continue only a limited number of additional iterations or until no further improvements occur; (6) every candidate node and edge is validated against obstacle occupancy and line-segment collisions, and results include the best path found within the iteration budget.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 post_opt_iters: int = 500, max_no_improve: int = 150,\n                 improve_tol: float = 1e-6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        goal_node = Node(goal)\n        nodes.append(root)\n        tree = [root]\n\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        c_min = math.dist(start, goal)\n\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        for _ in range(self.max_iter):\n            x_rand = self._sample(start, goal, best_cost, c_min, is_3d, bounds)\n\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n            x_new_pos = self._steer(x_nearest.position, x_rand)\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            x_new = Node(x_new_pos)\n            near_nodes = [n for n in tree if math.dist(n.position, x_new_pos) <= 20.0]\n\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near_nodes:\n                new_cost = n.cost + math.dist(n.position, x_new_pos)\n                if new_cost < min_cost and not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d):\n                    best_parent = n\n                    min_cost = new_cost\n\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            x_new.parent = best_parent\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            for n in near_nodes:\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost + 1e-12 < n.cost and not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        if n in n.parent.children:\n                            n.parent.children.remove(n)\n                    n.parent = x_new\n                    n.cost = alt_cost\n                    x_new.add_child(n)\n                    edges.append((x_new, n))\n\n            if math.dist(x_new.position, goal) < self.step_size and                not self._is_edge_in_obstacle(x_new.position, goal, obstacles, is_3d):\n                # \uc0c8 \ud574 \ud6c4\ubcf4\n                goal_node = Node(goal)  # \ubaa9\ud45c \ub178\ub4dc\ub294 \uc0c8\ub85c \ub9cc\ub4e4\uc5b4 \uba85\ud655\ud788 \uc5f0\uacb0\n                goal_node.parent = x_new\n                goal_node.cost = x_new.cost + math.dist(x_new.position, goal)\n                nodes.append(goal_node)\n                edges.append((x_new, goal_node))\n\n                if goal_node.cost + self.improve_tol < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    no_improve_streak = 0  \n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0  \n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        if success_state and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample(self, start, goal, c_best, c_min, is_3d, bounds):\n        import numpy as np\n        import math, random\n\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        dim = len(start)\n        L = np.diag([c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1))\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        a1 = a1 / np.linalg.norm(a1)\n        I = np.eye(dim)\n        M = np.outer(a1, I[:, 0])\n        U, _, Vt = np.linalg.svd(M)\n        C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm = np.linalg.norm(x_ball)\n            if norm > 1e-6:\n                x_ball = x_ball / norm * random.random() ** (1.0 / dim)\n            x_rand = np.dot(C, np.dot(L, x_ball)) + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * self.step_size / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    \n",
                "objective": 235.19094231666816,
                "time_improvement": -789.0,
                "length_improvement": 22.0,
                "smoothness_improvement": 930.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 0.9,
                        "time_avg": 0.5344432830810547,
                        "num_nodes_avg": 947.3,
                        "path_length_avg": 150.99345481570086,
                        "smoothness_avg": 0.12670700736095167,
                        "success_improvement": -9.999999999999998,
                        "time_improvement": -1995.9550143665665,
                        "node_improvement": -138.55452027197177,
                        "length_improvement": 17.23809477111046,
                        "smoothness_improvement": 1883.2398138692852,
                        "objective_score": -629.0274483779572
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.324963641166687,
                        "num_nodes_avg": 1167.4,
                        "path_length_avg": 222.04248618414317,
                        "smoothness_avg": 0.02144857764536279,
                        "success_improvement": 0.0,
                        "time_improvement": -102.85209631021006,
                        "node_improvement": 21.561513135792506,
                        "length_improvement": 25.875826973134497,
                        "smoothness_improvement": 451.887351601218,
                        "objective_score": -13.07069595117623
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.1799778699874878,
                        "num_nodes_avg": 857.0,
                        "path_length_avg": 114.63448492005905,
                        "smoothness_avg": 0.04372194350556986,
                        "success_improvement": 0.0,
                        "time_improvement": -266.91507381979466,
                        "node_improvement": -8.963763509218055,
                        "length_improvement": 23.865233423673267,
                        "smoothness_improvement": 456.139894172678,
                        "objective_score": -63.47468262087104
                    }
                ],
                "success_rate": 0.9666666666666667
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "Bi-Informed Dual-Tree RRT*-Connect with Adaptive Neighborhoods and Shortcut Smoothing: a bidirectional planner that alternates growing optimized trees from start and goal, uses adaptive near-radius rewiring, informed rejection sampling after the first solution, and a connection step akin to RRT-Connect, followed by fast shortcut smoothing.",
            "planning_mechanism": "Mechanism: alternate tree expansion with goal-biased, bounds-respecting sampling; steer a step, validate node and edge, choose the lowest-cost parent among adaptive-radius neighbors, rewire and propagate costs; attempt to connect to the opposite tree via progressive extensions; upon any feasible join, update the incumbent cost and restrict future samples to the prolate hyperspheroid defined by start, goal, and best cost; terminate after a post-optimization budget or stagnation and return a smoothed path.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=5.0,\n                 base_radius=25.0,\n                 min_radius=6.0,\n                 goal_bias=0.12,\n                 post_opt_iters=800,\n                 max_no_improve=200,\n                 smoothing_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.goal_bias = goal_bias\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_cell = max(self.step_size, self.base_radius * 0.5)\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root, grid_cell)\n        self._grid_add(grid_goal, goal_root, grid_cell)\n\n        success = False\n        best_cost = float('inf')\n        best_join = (None, None)\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            active_first = (it % 2 == 0)\n            for which in (0, 1):\n                tree_a = start_tree if (active_first ^ (which == 1)) else goal_tree\n                tree_b = goal_tree if (tree_a is start_tree) else start_tree\n                grid_a = grid_start if (tree_a is start_tree) else grid_goal\n                grid_b = grid_goal if (tree_b is goal_tree) else grid_start\n\n                x_rand = self._sample(start, goal, best_cost, is_3d)\n                if self._rand() < self.goal_bias:\n                    x_rand = goal if (tree_a is start_tree) else start\n\n                x_nearest = self._nearest_grid(grid_a, tree_a, x_rand, grid_cell)\n                x_new_pos = self._steer(x_nearest.position, x_rand, self.step_size)\n\n                if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n                    continue\n                if self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n                    continue\n\n                x_new = Node(x_new_pos)\n                n_nodes = len(tree_a) + 1\n                r_near = self._adaptive_radius(n_nodes)\n                near_nodes = self._near_grid(grid_a, x_new_pos, r_near, grid_cell)\n\n                best_parent = x_nearest\n                best_pc = x_nearest.cost + self._dist(x_nearest.position, x_new_pos)\n                for nn in near_nodes:\n                    cand_cost = nn.cost + self._dist(nn.position, x_new_pos)\n                    if cand_cost < best_pc and not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d):\n                        best_parent = nn\n                        best_pc = cand_cost\n\n                best_parent.add_child(x_new)\n                x_new.cost = best_pc\n                tree_a.append(x_new)\n                nodes.append(x_new)\n                edges.append((best_parent, x_new))\n                self._grid_add(grid_a, x_new, grid_cell)\n\n                for nn in near_nodes:\n                    alt = x_new.cost + self._dist(x_new.position, nn.position)\n                    if alt + 1e-12 < nn.cost and not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d):\n                        op = nn.parent\n                        if op is not None:\n                            try:\n                                edges.remove((op, nn))\n                            except:\n                                pass\n                            try:\n                                op.children.remove(nn)\n                            except:\n                                pass\n                        x_new.add_child(nn)\n                        nn.cost = alt\n                        edges.append((x_new, nn))\n                        self._propagate_costs_from(nn, edges)\n\n                connect_success, meet_a, meet_b = self._connect_trees(x_new, tree_b, grid_b, obstacles, is_3d, grid_cell, nodes, edges)\n                if connect_success:\n                    path_cost = meet_a.cost + self._dist(meet_a.position, meet_b.position) + meet_b.cost\n                    if path_cost + 1e-12 < best_cost:\n                        best_cost = path_cost\n                        best_join = (meet_a, meet_b)\n                        success = True\n                        found_first = True\n                        post_iters = 0\n                        no_improve = 0\n                    else:\n                        if found_first:\n                            post_iters += 1\n                            no_improve += 1\n                else:\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n\n                if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                    break\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        path = []\n        if success and best_join[0] is not None:\n            path = self._extract_path(best_join[0], best_join[1])\n            path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _rand(self):\n        try:\n            return random.random()\n        except:\n            # fallback LCG if random unavailable\n            if not hasattr(self, \"_lcg_state\"):\n                self._lcg_state = 1234567\n            self._lcg_state = (1103515245 * self._lcg_state + 12345) % (1 << 31)\n            return (self._lcg_state / float(1 << 31))\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = (a[i] - b[i])\n            s += d * d\n        return s ** 0.5\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        ratio = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(self.dim))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=1.0):\n        d = self._dist(a, b)\n        steps = int(d / resolution)\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _sample(self, start, goal, c_best, is_3d):\n        for _ in range(50):\n            p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n            if c_best < float('inf'):\n                if self._dist(p, start) + self._dist(p, goal) <= c_best and self._in_bounds(p):\n                    return p\n            else:\n                if self._in_bounds(p):\n                    return p\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _adaptive_radius(self, n):\n        if n <= 1:\n            return max(self.min_radius, self.base_radius)\n        r = self.base_radius * (n ** (-1.0 / max(2, self.dim)))\n        if r < self.min_radius:\n            r = self.min_radius\n        return r\n\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        key = self._grid_key(node.position, cell)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_gather(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos, cell):\n        # Expand rings until any candidates are found; fallback to linear scan\n        rng = 0\n        best = None\n        bestd = float('inf')\n        while rng < 6:\n            radius = (rng + 1) * cell\n            cand = self._grid_gather(grid, pos, radius, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                return best\n            rng += 1\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_grid(self, grid, pos, radius, cell):\n        cand = self._grid_gather(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _connect_trees(self, node_a, tree_b, grid_b, obstacles, is_3d, cell, nodes, edges):\n        target = node_a.position\n        nnear = self._nearest_grid(grid_b, tree_b, target, cell)\n        current = nnear\n        last_new = None\n        max_steps = int((self._dist(current.position, target) / self.step_size)) + 2\n        for _ in range(max_steps):\n            new_pos = self._steer(current.position, target, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False, None, None\n            if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                return False, None, None\n            new_node = Node(new_pos)\n            new_node.cost = current.cost + self._dist(current.position, new_pos)\n            current.add_child(new_node)\n            tree_b.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_add(grid_b, new_node, cell)\n            last_new = new_node\n            current = new_node\n            if self._dist(current.position, target) <= self.step_size and not self._is_edge_in_obstacle(current.position, target, obstacles, is_3d):\n                meet_b = current\n                meet_a = node_a\n                return True, meet_a, meet_b\n        if last_new is not None and self._dist(last_new.position, target) <= self.step_size and not self._is_edge_in_obstacle(last_new.position, target, obstacles, is_3d):\n            return True, node_a, last_new\n        return False, None, None\n\n    def _path_to_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        path.reverse()\n        return path\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        # meet_b is on the tree rooted at goal; follow parents to goal\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # path_a ends at meet_a; path_b starts at meet_b; edge between them is implicit\n        return path_a + path_b\n\n    def _propagate_costs_from(self, node, edges):\n        q = []\n        for c in node.children:\n            q.append(c)\n        while q:\n            u = q.pop(0)\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                q.append(c)\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                new_pts = pts[:i + 1] + pts[j:]\n                pts = new_pts\n                n = len(pts)\n        return pts",
            "objective": 13.17506,
            "time_improvement": -100.0,
            "length_improvement": 18.0,
            "smoothness_improvement": 1141.0,
            "node_improvement": -19.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04533350467681885,
                    "num_nodes_avg": 475.2,
                    "path_length_avg": 160.00839630243624,
                    "smoothness_avg": 0.03538840033717765,
                    "success_improvement": 0.0,
                    "time_improvement": -77.78684746193773,
                    "node_improvement": -19.66759002770082,
                    "length_improvement": 12.296862491341491,
                    "smoothness_improvement": 453.90531241814347,
                    "objective_score": -13.688410181685704
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.14875941276550292,
                    "num_nodes_avg": 1244.7,
                    "path_length_avg": 229.2684850165445,
                    "smoothness_avg": 0.07592744364942347,
                    "success_improvement": 0.0,
                    "time_improvement": 7.13989227527299,
                    "node_improvement": 16.367667808909488,
                    "length_improvement": 23.463580574034797,
                    "smoothness_improvement": 1853.6678134268077,
                    "objective_score": 25.48845509413681
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1614241361618042,
                    "num_nodes_avg": 1203.4,
                    "path_length_avg": 120.8833554675142,
                    "smoothness_avg": 0.09548517805346257,
                    "success_improvement": 0.0,
                    "time_improvement": -229.0901755878243,
                    "node_improvement": -53.00699300699302,
                    "length_improvement": 19.715031145292965,
                    "smoothness_improvement": 1114.5644168573392,
                    "objective_score": -51.32521190488481
                }
            ],
            "success_rate": 1.0
        },
        "objective": 12.399999999999999,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Early termination at first feasible join without post-optimization or smoothing, preserving zig-zag and detour segments\n   - Fixed-radius rewiring and lack of cost propagation to descendants, leaving stale costs and blocking cascading improvements\n   - Weak or absent goal-bias/informed focus; sampling remains broad, so refinement around the optimal corridor is limited\n   - Connection policy tied to short step thresholds, missing direct joins and forcing longer, piecewise connections\n   - Inefficient neighbor retrieval limits high-quality parent selection and rewiring within the compute budget"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Bidirectional growth with progressive connect steps producing more direct, straighter joins\n   - Adaptive neighborhood radius enabling effective parent selection early and precise local rewiring later\n   - Explicit cost propagation after rewires to update entire subtrees\n   - Informed sampling conditioned on the incumbent cost plus goal bias to focus on the near-optimal corridor\n   - Shortcut smoothing to remove redundant waypoints and collapse detours\n   - Spatial hashing for fast nearest/near queries, increasing opportunities for high-quality rewires\n2. Expected mechanism of impact:\n   - More direct cross-tree connections and focused sampling reduce detours and total path length\n   - Cascading rewires tighten entire branches toward lower-cost parents, shortening the final route\n   - Smoothing replaces multi-turn polylines with longer collision-free segments, cutting unnecessary length\n   - Adaptive neighbor sets balance global improvement early with fine-grained local optimization later\n   - Faster neighbor access enables more beneficial rewires within the same budget, accelerating convergence to shorter paths"
        }
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
                "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -20.90414805532173,
                "time_improvement": 74.0,
                "length_improvement": -3.0,
                "smoothness_improvement": 81.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.009906005859375,
                        "num_nodes_avg": 119.0,
                        "path_length_avg": 191.04302473496983,
                        "smoothness_avg": 0.011270904212760589,
                        "success_improvement": 0.0,
                        "time_improvement": 61.15108317274382,
                        "node_improvement": 70.03273734575673,
                        "length_improvement": -4.713709127687822,
                        "smoothness_improvement": 76.41412608993974,
                        "objective_score": 15.899170105660149
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.018079090118408202,
                        "num_nodes_avg": 263.8,
                        "path_length_avg": 304.060897710979,
                        "smoothness_avg": 0.007193047909992605,
                        "success_improvement": 0.0,
                        "time_improvement": 88.71448720621899,
                        "node_improvement": 82.2750789491366,
                        "length_improvement": -1.5042795636027118,
                        "smoothness_improvement": 85.08230366710401,
                        "objective_score": 26.13718994203959
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.013434433937072754,
                        "num_nodes_avg": 198.2,
                        "path_length_avg": 154.3877135428638,
                        "smoothness_avg": 0.014383244909940574,
                        "success_improvement": 0.0,
                        "time_improvement": 72.61165319885777,
                        "node_improvement": 74.79974570883661,
                        "length_improvement": -2.536968182267624,
                        "smoothness_improvement": 82.95381359374001,
                        "objective_score": 20.676084118265454
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional, asymptotically optimal planner that blends RRT-Connect\u2019s fast greedy tree-connection with RRT*\u2019s cost-optimal rewiring, and\u2014after an initial solution\u2014focuses sampling within the prolate hyperspheroid (ellipsoid) defined by the start, goal, and current best path length to accelerate convergence.",
                "planning_mechanism": "The planner grows two trees from start and goal. Each iteration: (1) sample uniformly until a first solution is found, then sample inside the informed ellipsoid; (2) extend one tree toward the sample using RRT*-style best-parent selection and local rewiring; (3) greedily \u201cconnect\u201d the opposite tree toward the new node, also rewiring locally; (4) if trees meet, update the best path and continue only a limited number of post-optimization iterations (user-tunable). Every node and edge is checked for point-in-obstacle and edge-obstacle collisions, positions are clamped to bounds, and a hard 30-second time limit halts the search and returns the best path found so far.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cumulative path cost from the root of its tree\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        neighbor_radius: float = 25.0,\n        post_opt_iters: int = 400,      # extra iterations after first solution\n        max_no_improve: int = 150,      # stop early if no improvement for this many iters\n        improve_tol: float = 1e-6,      # minimal improvement to count\n        time_limit_sec: float = 30.0,   # hard wall time limit\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Core data\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_cost = float('inf')\n        best_path = []\n        c_min = math.dist(start_position, goal_position)\n\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            # Enforce 30s time limit\n            if time.time() - start_time > self.time_limit_sec:\n                return PlannerResult(\n                    success=success_state,\n                    path=best_path if success_state else [],\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            # Alternate trees (RRT-Connect style)\n            tree_a, tree_b = (start_tree, goal_tree) if (it % 2 == 0) else (goal_tree, start_tree)\n\n            # Informed sampling: uniform before first solution; ellipsoid after\n            x_rand = self._sample_informed(start_position, goal_position, best_cost, c_min, bounds)\n\n            # Extend tree_a one step with RRT* best-parent + local rewire\n            a_nearest = self._nearest(tree_a, x_rand)\n            a_new_pos = self._steer(a_nearest.position, x_rand)\n\n            if not self._within_bounds(a_new_pos, bounds):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                if found_first_solution and (post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve):\n                    break\n                continue\n\n            if self._is_in_obstacle(a_new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(a_nearest.position, a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                if found_first_solution and (post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve):\n                    break\n                continue\n\n            a_new, a_neighbors = self._add_with_best_parent(tree_a, a_new_pos, obstacles, is_3d, nodes, edges)\n            self._rewire_from(a_new, a_neighbors, obstacles, is_3d, edges)\n\n            # Greedy connect tree_b toward a_new (RRT-Connect) with local RRT* rewiring\n            b_meet = self._connect_with_rewire(tree_b, a_new, obstacles, is_3d, nodes, edges, bounds)\n\n            if b_meet is not None:\n                # Build full path depending on which side expanded\n                if it % 2 == 0:\n                    path_a = a_new.path_from_root()       # start side\n                    path_b = b_meet.path_from_root()      # goal side\n                else:\n                    path_a = b_meet.path_from_root()       # start side\n                    path_b = a_new.path_from_root()        # goal side\n\n                # Merge (avoid double-counting the joint if equal)\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged = path_a + path_b[-2::-1]\n                else:\n                    merged = path_a + path_b[::-1]\n\n                cost = self._path_cost(merged)\n\n                if cost + self.improve_tol < best_cost:\n                    best_cost = cost\n                    best_path = merged\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0\n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------------- Helpers ----------------------\n    def _within_bounds(self, pos, bounds):\n        return all(0.0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _path_cost(self, path):\n        return sum(math.dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _neighbors(self, tree, pos):\n        return [n for n in tree if math.dist(n.position, pos) <= self.neighbor_radius]\n\n    def _add_with_best_parent(self, tree, new_pos, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, new_pos)\n        candidates = self._neighbors(tree, new_pos)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in candidates:\n            if self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                continue\n            cand_cost = nb.cost + math.dist(nb.position, new_pos)\n            if cand_cost < min_cost:\n                min_cost = cand_cost\n                best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, candidates\n\n    def _rewire_from(self, pivot: Node, neighbors, obstacles, is_3d, edges):\n        for nb in neighbors:\n            if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                continue\n            new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n            if new_cost + 1e-12 < nb.cost:\n                if nb.parent is not None:\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    if nb in nb.parent.children:\n                        nb.parent.children.remove(nb)\n                pivot.add_child(nb)\n                nb.cost = new_cost\n                edges.append((pivot, nb))\n\n    def _connect_with_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        \"\"\"\n        Greedily advance 'tree' toward 'target_node' like RRT-Connect.\n        At each step, insert with best parent and locally rewire.\n        Return the final node in 'tree' placed at target_node.position (if reached), else None.\n        \"\"\"\n        current = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(current.position, target_node.position)\n\n            if not self._within_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node, neighbors = self._add_with_best_parent(tree, new_pos, obstacles, is_3d, nodes, edges)\n            self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(new_node.position, target_node.position) <= self.step_size:\n                # final short edge\n                if not self._is_edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d) and target_node.valid:\n                    final_node = Node(\n                        target_node.position,\n                        parent=None,\n                        cost=new_node.cost + math.dist(new_node.position, target_node.position)\n                    )\n                    new_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                return None\n\n            current = new_node\n\n    # ------------------ Informed Sampling ------------------\n    def _sample_informed(self, start, goal, c_best, c_min, bounds):\n        \"\"\"Uniform before first solution; prolate hyperspheroid after (supports 2D/3D).\"\"\"\n        dim = len(bounds)\n        if c_best == float('inf') or c_min <= 1e-12:\n            # uniform in bounds\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # radii along orthonormal basis aligned with start->goal\n        r1 = c_best / 2.0\n        r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n        r_other = math.sqrt(r_other_sq) / 2.0\n\n        # center\n        center = tuple((s + g) / 2.0 for s, g in zip(start, goal))\n        # first axis (unit)\n        a1_vec = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n        # orthonormal basis\n        if dim == 2:\n            a2_vec = (-a1_vec[1], a1_vec[0])\n            basis = (a1_vec, a2_vec)\n            radii = (r1, r_other)\n        else:  # dim == 3\n            # pick any non-parallel vector\n            ref = (1.0, 0.0, 0.0) if abs(a1_vec[0]) < 0.9 else (0.0, 1.0, 0.0)\n            # b2 = normalize(cross(a1, ref)), b3 = cross(a1, b2)\n            b2 = self._normalize(self._cross(a1_vec, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._normalize(self._cross(a1_vec, ref))\n            b3 = self._cross(a1_vec, b2)\n            basis = (a1_vec, b2, b3)\n            radii = (r1, r_other, r_other)\n\n        # sample unit ball\n        u = self._sample_unit_ball(dim)\n\n        # map: x = center + sum_i (basis_i * radii_i * u_i)\n        mapped = []\n        for d in range(dim):\n            val = center[d]\n            for i in range(dim):\n                val += basis[i][d] * radii[i] * u[i]\n            mapped.append(val)\n\n        # clamp to bounds to be safe\n        mapped = tuple(min(max(mapped[d], 0.0), bounds[d]) for d in range(dim))\n        return mapped\n\n    def _sample_unit_ball(self, dim):\n        # Draw direction from normal distribution and radius with correct PDF\n        while True:\n            vec = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(v * v for v in vec))\n            if n > 1e-12:\n                vec = [v / n for v in vec]\n                r = random.random() ** (1.0 / dim)\n                return tuple(vec[i] * r for i in range(dim))\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)\n\n    # ------------------ Collision Utilities ------------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": 518.1211228589663,
                "time_improvement": -1783.0,
                "length_improvement": 22.0,
                "smoothness_improvement": 648.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.9512754917144776,
                        "num_nodes_avg": 539.7,
                        "path_length_avg": 146.95278540397857,
                        "smoothness_avg": 0.035670720596744435,
                        "success_improvement": 0.0,
                        "time_improvement": -3630.668342220689,
                        "node_improvement": -35.91035003777387,
                        "length_improvement": 19.45284970417965,
                        "smoothness_improvement": 458.32423754861986,
                        "objective_score": -1075.2371716559555
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.4313333034515381,
                        "num_nodes_avg": 595.7,
                        "path_length_avg": 229.86311266595635,
                        "smoothness_avg": 0.028909493641293648,
                        "success_improvement": 0.0,
                        "time_improvement": -169.25124453745204,
                        "node_improvement": 59.97446751327017,
                        "length_improvement": 23.265076749253225,
                        "smoothness_improvement": 643.8620940570969,
                        "objective_score": -33.59701684139819
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.8084268569946289,
                        "num_nodes_avg": 639.6,
                        "path_length_avg": 113.69137900509236,
                        "smoothness_avg": 0.07405674090515976,
                        "success_improvement": 0.0,
                        "time_improvement": -1548.1137371650768,
                        "node_improvement": 18.67768595041322,
                        "length_improvement": 24.491599466516433,
                        "smoothness_improvement": 841.9962780136293,
                        "objective_score": -445.52918007954503
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "Bi-Guide ARC: A bidirectional, goal-aware RRT*-Connect with Adaptive Radius, spatial hashing, subtree cost propagation, and post-planning shortcut smoothing. It balances fast greedy connections with cost-optimal rewiring, focuses samples within an informed ellipsoid after the first solution, and uses a lightweight grid index for efficient nearest/near queries to improve path length and smoothness with lower planning time.",
            "planning_mechanism": "Alternate growing start/goal trees: sample (goal-biased; informed after first path), steer one step, select best parent within an adaptive radius, add if both node and edge are collision-free, locally rewire with subtree cost updates, then attempt a bounded greedy connect of the opposite tree to the new node. Maintain best path and stop upon time/iteration/no-improvement limits; finally apply randomized shortcut smoothing to the best path.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def detach_from_parent(self):\n        if self.parent is not None and self in self.parent.children:\n            self.parent.children.remove(self)\n        self.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 6000,\n        step_size: float = 5.0,\n        goal_bias: float = 0.15,\n        base_radius: float = 35.0,\n        max_radius: float = 60.0,\n        connect_steps: int = 20,\n        post_opt_iters: int = 300,\n        no_improve_limit: int = 180,\n        time_limit_sec: float = 20.0,\n        smooth_attempts: int = 120\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.base_radius = base_radius\n        self.max_radius = max_radius\n        self.connect_steps = connect_steps\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.time_limit_sec = time_limit_sec\n        self.smooth_attempts = smooth_attempts\n\n        # Spatial hash cell size\n        self.cell_size = max(8.0, step_size * 2.0)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Core containers\n        nodes = []\n        edges = []\n        success_state = False\n        best_path = []\n        best_cost = float('inf')\n\n        # Initialize trees and spatial hashes\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Dist between start and goal\n        c_min = self._dist(start_position, goal_position)\n\n        # States\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            # Alternate expansion direction\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n                grid_a, grid_b = grid_start, grid_goal\n                root_a, root_b = start_root, goal_root\n                sample_goal = goal_position\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n                grid_a, grid_b = grid_goal, grid_start\n                root_a, root_b = goal_root, start_root\n                sample_goal = start_position\n\n            # Sampling with goal bias and informed focus\n            x_rand = self._sample(bounds, obstacles, is_3d, start_position, goal_position, best_cost, c_min, sample_goal)\n\n            # Nearest in tree_a\n            a_near = self._nearest(grid_a, tree_a, x_rand, bounds)\n            a_new_pos = self._steer(a_near.position, x_rand, self.step_size)\n\n            # Bound check\n            if not self._in_bounds(a_new_pos, bounds):\n                self._advance_counters(found_first, True)\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Node and edge collision checks before adding\n            if self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n            if self._hit_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Best parent selection within adaptive radius\n            rad = self._adaptive_radius(len(tree_a), dim)\n            neighbors = self._grid_neighbors(grid_a, a_new_pos, rad)\n            if not neighbors:\n                neighbors = [a_near]\n\n            best_parent = None\n            best_g = float('inf')\n            for cand in neighbors:\n                if self._hit_obstacle(cand.position, a_new_pos, obstacles, is_3d):\n                    continue\n                g = cand.cost + self._dist(cand.position, a_new_pos)\n                if g < best_g:\n                    best_g = g\n                    best_parent = cand\n\n            if best_parent is None:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Add new node to tree_a\n            a_new = Node(a_new_pos, parent=None, cost=best_g)\n            best_parent.add_child(a_new)\n            tree_a.append(a_new)\n            nodes.append(a_new)\n            edges.append((best_parent, a_new))\n            self._grid_add(grid_a, a_new)\n\n            # Local rewiring from a_new\n            self._rewire_from(a_new, neighbors, obstacles, is_3d, edges)\n\n            # Attempt to connect tree_b to a_new (bounded)\n            b_meet = self._attempt_connect(tree_b, grid_b, a_new, obstacles, is_3d, bounds, nodes, edges, dim)\n\n            if b_meet is not None:\n                # Merge full path\n                if root_a is start_root:\n                    path_a = a_new.path_from_root()\n                    path_b = b_meet.path_from_root()\n                else:\n                    path_a = b_meet.path_from_root()\n                    path_b = a_new.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged = path_a + path_b[-2::-1]\n                else:\n                    merged = path_a + path_b[::-1]\n\n                cost = self._path_cost(merged)\n                if cost < best_cost - 1e-9:\n                    best_cost = cost\n                    best_path = merged\n                    success_state = True\n                    no_improve = 0\n                else:\n                    no_improve += 1\n\n                if not found_first:\n                    found_first = True\n                    post_iters = 0\n                else:\n                    post_iters += 1\n\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n            else:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n\n        # Final smoothing of best path\n        if success_state and best_path:\n            best_path = self._shortcut_smooth(best_path, obstacles, is_3d, attempts=self.smooth_attempts)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ------------------ Spatial Hash ------------------\n    def _key(self, pos):\n        return tuple(int(pos[d] // self.cell_size) for d in range(len(pos)))\n\n    def _grid_add(self, grid, node):\n        k = self._key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_neighbors(self, grid, pos, radius):\n        # Collect nodes in cells within radius\n        dim = len(pos)\n        span = int(max(1, math.ceil(radius / self.cell_size)))\n        key_center = self._key(pos)\n        result = []\n        if dim == 2:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    k = (key_center[0] + dx, key_center[1] + dy)\n                    if k in grid:\n                        for n in grid[k]:\n                            if self._dist(n.position, pos) <= radius:\n                                result.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        k = (key_center[0] + dx, key_center[1] + dy, key_center[2] + dz)\n                        if k in grid:\n                            for n in grid[k]:\n                                if self._dist(n.position, pos) <= radius:\n                                    result.append(n)\n        return result\n\n    def _nearest(self, grid, tree, pos, bounds):\n        # Try increasing radii using grid; fallback to full scan\n        radius = self.cell_size\n        for _ in range(4):\n            cands = self._grid_neighbors(grid, pos, radius)\n            if cands:\n                return min(cands, key=lambda n: self._dist(n.position, pos))\n            radius *= 2.0\n        return min(tree, key=lambda n: self._dist(n.position, pos))\n\n    # ------------------ Connect Attempt ------------------\n    def _attempt_connect(self, tree, grid, target_node, obstacles, is_3d, bounds, nodes, edges, dim):\n        target_pos = target_node.position\n\n        # Direct connect via best parent in radius\n        rad = self._adaptive_radius(len(tree), dim)\n        neigh = self._grid_neighbors(grid, target_pos, rad)\n        if not neigh:\n            # include nearest if none\n            neigh = [self._nearest(grid, tree, target_pos, bounds)]\n        best_parent = None\n        best_cost = float('inf')\n        for cand in neigh:\n            if self._hit_obstacle(cand.position, target_pos, obstacles, is_3d):\n                continue\n            g = cand.cost + self._dist(cand.position, target_pos)\n            if g < best_cost:\n                best_cost = g\n                best_parent = cand\n        if best_parent is not None and not self._is_in_obstacle(target_pos, obstacles, is_3d):\n            meet = Node(target_pos, parent=None, cost=best_cost)\n            best_parent.add_child(meet)\n            tree.append(meet)\n            nodes.append(meet)\n            edges.append((best_parent, meet))\n            self._grid_add(grid, meet)\n            # Local rewiring at seam improves junction quality\n            seam_neighbors = self._grid_neighbors(grid, target_pos, rad)\n            self._rewire_from(meet, seam_neighbors, obstacles, is_3d, edges)\n            return meet\n\n        # Greedy bounded stepping toward target\n        current = self._nearest(grid, tree, target_pos, bounds)\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(current.position, target_pos, self.step_size)\n            if not self._in_bounds(nxt, bounds):\n                return None\n            if self._is_in_obstacle(nxt, obstacles, is_3d):\n                return None\n            if self._hit_obstacle(current.position, nxt, obstacles, is_3d):\n                return None\n\n            # Insert with best parent among neighbors around nxt\n            neigh2 = self._grid_neighbors(grid, nxt, rad)\n            if not neigh2:\n                neigh2 = [current]\n            best_p = None\n            best_g2 = float('inf')\n            for cand in neigh2:\n                if self._hit_obstacle(cand.position, nxt, obstacles, is_3d):\n                    continue\n                g2 = cand.cost + self._dist(cand.position, nxt)\n                if g2 < best_g2:\n                    best_g2 = g2\n                    best_p = cand\n            if best_p is None:\n                return None\n\n            new_b = Node(nxt, parent=None, cost=best_g2)\n            best_p.add_child(new_b)\n            tree.append(new_b)\n            nodes.append(new_b)\n            edges.append((best_p, new_b))\n            self._grid_add(grid, new_b)\n\n            self._rewire_from(new_b, neigh2, obstacles, is_3d, edges)\n\n            if self._dist(new_b.position, target_pos) <= self.step_size:\n                if (not self._is_in_obstacle(target_pos, obstacles, is_3d)) and (not self._hit_obstacle(new_b.position, target_pos, obstacles, is_3d)):\n                    final_b = Node(target_pos, parent=None, cost=new_b.cost + self._dist(new_b.position, target_pos))\n                    new_b.add_child(final_b)\n                    tree.append(final_b)\n                    nodes.append(final_b)\n                    edges.append((new_b, final_b))\n                    self._grid_add(grid, final_b)\n                    return final_b\n                return None\n\n            current = new_b\n            steps += 1\n\n        return None\n\n    # ------------------ Rewiring ------------------\n    def _rewire_from(self, pivot, neighbors, obstacles, is_3d, edges):\n        for nb in neighbors:\n            if nb is pivot or nb.parent is None:\n                continue\n            if self._hit_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                continue\n            new_cost = pivot.cost + self._dist(pivot.position, nb.position)\n            if new_cost + 1e-12 < nb.cost:\n                old_parent = nb.parent\n                nb.detach_from_parent()\n                pivot.add_child(nb)\n                try:\n                    edges.remove((old_parent, nb))\n                except Exception:\n                    pass\n                edges.append((pivot, nb))\n                delta = new_cost - nb.cost\n                nb.cost = new_cost\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        # BFS update costs down the subtree to maintain coherence\n        queue = [node]\n        while queue:\n            cur = queue.pop(0)\n            for ch in cur.children:\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                queue.append(ch)\n\n    # ------------------ Sampling ------------------\n    def _sample(self, bounds, obstacles, is_3d, start, goal, c_best, c_min, biased_goal):\n        dim = len(bounds)\n        # Goal bias\n        if random.random() < self.goal_bias:\n            target = goal if biased_goal == goal else start\n            if not self._is_in_obstacle(target, obstacles, is_3d):\n                return target\n\n        # Informed sampling after first solution\n        if c_best < float('inf') and c_min > 1e-12:\n            for _ in range(50):\n                x = self._sample_informed_ellipsoid(start, goal, c_best, c_min, bounds)\n                if not self._is_in_obstacle(x, obstacles, is_3d):\n                    return x\n\n        # Uniform fallback\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]), random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_informed_ellipsoid(self, start, goal, c_best, c_min, bounds):\n        # Prolate ellipsoid with foci at start and goal\n        dim = len(bounds)\n        r1 = c_best / 2.0\n        r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        a1 = self._unit(self._vec(goal, start))\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r2)\n        else:\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._unit(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._unit(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r2, r2)\n\n        u = self._sample_unit_ball(dim)\n        x = [center[d] for d in range(dim)]\n        for i in range(dim):\n            for d in range(dim):\n                x[d] += basis[i][d] * radii[i] * u[i]\n        # Clamp to bounds\n        x = tuple(min(max(x[d], 0.0), bounds[d]) for d in range(dim))\n        return x\n\n    def _sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(vi * vi for vi in v))\n            if n > 1e-12:\n                v = [vi / n for vi in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    # ------------------ Geometry/Collision ------------------\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _vec(self, a, b):\n        return tuple(a[i] - b[i] for i in range(len(a)))\n\n    def _norm(self, v):\n        return math.sqrt(sum(vi * vi for vi in v))\n\n    def _unit(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return tuple(0.0 for _ in v)\n        return tuple(vi / n for vi in v)\n\n    def _cross(self, a, b):\n        # Only used in 3D informed sampling\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0.0 <= pos[i] <= bounds[i] for i in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _hit_obstacle(self, a, b, obstacles, is_3d, res=1.0):\n        L = self._dist(a, b)\n        steps = max(1, int(L / res))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(len(a)))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _path_cost(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(len(path) - 1):\n            s += self._dist(path[i], path[i + 1])\n        return s\n\n    # ------------------ Controls ------------------\n    def _adaptive_radius(self, n, dim):\n        if n <= 1:\n            return self.base_radius\n        # RRT* style shrinkage\n        r = self.base_radius * (math.log(n + 1) / (n + 1)) ** (1.0 / dim)\n        r = max(self.step_size * 1.5, min(self.max_radius, r))\n        return r\n\n    def _post_update(self, found_first, post_iters, no_improve):\n        if found_first:\n            post_iters += 1\n            no_improve += 1\n        return post_iters, no_improve\n\n    def _should_stop(self, found_first, post_iters, no_improve):\n        if not found_first:\n            return False\n        if post_iters >= self.post_opt_iters:\n            return True\n        if no_improve >= self.no_improve_limit:\n            return True\n        return False\n\n    # ------------------ Smoothing ------------------\n    def _shortcut_smooth(self, path, obstacles, is_3d, attempts=100):\n        if len(path) < 3:\n            return path[:]\n        best = path[:]\n        best_cost = self._path_cost(best)\n        n = len(best)\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = best[i]\n            b = best[j]\n            if not self._hit_obstacle(a, b, obstacles, is_3d):\n                # shortcut\n                new_path = best[:i + 1] + best[j:]\n                new_cost = self._path_cost(new_path)\n                if new_cost < best_cost - 1e-9:\n                    best = new_path\n                    best_cost = new_cost\n                    n = len(best)\n        # Greedy corner culling\n        changed = True\n        while changed and len(best) > 2:\n            changed = False\n            k = 1\n            while k < len(best) - 1:\n                if not self._hit_obstacle(best[k - 1], best[k + 1], obstacles, is_3d):\n                    best.pop(k)\n                    changed = True\n                else:\n                    k += 1\n        return best",
            "objective": 14.38104,
            "time_improvement": -107.0,
            "length_improvement": 18.0,
            "smoothness_improvement": 1417.0,
            "node_improvement": 44.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.11155118942260742,
                    "num_nodes_avg": 362.3,
                    "path_length_avg": 155.15168551902272,
                    "smoothness_avg": 0.04619305292125599,
                    "success_improvement": 0.0,
                    "time_improvement": -337.47630895645335,
                    "node_improvement": 8.76353563334173,
                    "length_improvement": 14.95890263123767,
                    "smoothness_improvement": 623.021588037589,
                    "objective_score": -89.15244316800546
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08458755016326905,
                    "num_nodes_avg": 414.7,
                    "path_length_avg": 238.39539805931153,
                    "smoothness_avg": 0.09691449918612544,
                    "success_improvement": 0.0,
                    "time_improvement": 47.197902476841236,
                    "node_improvement": 72.13599408721359,
                    "length_improvement": 20.416754296733227,
                    "smoothness_improvement": 2393.679868751244,
                    "objective_score": 38.37782266484852
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06439132690429687,
                    "num_nodes_avg": 395.9,
                    "path_length_avg": 123.34270106287966,
                    "smoothness_avg": 0.1047845601402689,
                    "success_improvement": 0.0,
                    "time_improvement": -31.272519594143017,
                    "node_improvement": 49.66306420851876,
                    "length_improvement": 18.081650902303785,
                    "smoothness_improvement": 1232.8518705925312,
                    "objective_score": 7.631494016102023
                }
            ],
            "success_rate": 1.0
        },
        "objective": 12.399999999999999,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient exploration without consistent goal bias or informed focusing, causing long detours before reaching a usable corridor\n   - Limited or missing edge rewiring and absent cost propagation to descendants, leaving suboptimal parents and stale costs in the trees\n   - Non-adaptive neighborhood selection (fixed radius/linear scans), weakening optimal-parent selection and creating zigzags\n   - Greedy tree-connection that overextends, duplicates seam nodes, and lacks cross-tree refinement, inflating junction curvature and path length\n   - No post-planning shortcutting/smoothing, preserving unnecessary bends from discretized steering and collision sampling"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Adaptive best-parent selection with local rewiring and subtree cost propagation\n   - Informed sampling (start\u2013goal ellipsoid) with modest goal bias\n   - Bounded bidirectional connect with seam rewiring\n   - Post-planning shortcut smoothing and corner culling\n   - Lightweight spatial indexing enabling effective, locality-aware neighbor queries\n2. Expected mechanism of impact:\n   - Rewiring with correct cost propagation systematically replaces detours with lower-cost parents, shortening accumulated path length\n   - Informed, goal-biased samples concentrate expansions in the promising corridor, reducing wandering and unnecessary turns\n   - Controlled connect steps and seam refinement remove overextension and kinked junctions, producing straighter joins\n   - Shortcutting prunes superfluous waypoints via collision-free chords, directly reducing total path length and curvature\n   - Efficient neighbor retrieval supports frequent cost-improving rewires within the iteration/time budget, enhancing final path quality"
        }
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -24.971436625701273,
                "time_improvement": 62.0,
                "length_improvement": 9.0,
                "smoothness_improvement": 168.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.009481477737426757,
                        "num_nodes_avg": 112.0,
                        "path_length_avg": 170.25136521926942,
                        "smoothness_avg": 0.017004537999713392,
                        "success_improvement": 0.0,
                        "time_improvement": 62.815977978432855,
                        "node_improvement": 71.7955175018887,
                        "length_improvement": 6.682528917796031,
                        "smoothness_improvement": 166.15794564080122,
                        "objective_score": 23.68510047241148
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.0245816707611084,
                        "num_nodes_avg": 299.2,
                        "path_length_avg": 258.5973544494462,
                        "smoothness_avg": 0.010851066788952054,
                        "success_improvement": 0.0,
                        "time_improvement": 84.6553804394982,
                        "node_improvement": 79.89652623798965,
                        "length_improvement": 13.67275977263268,
                        "smoothness_improvement": 179.20576418723118,
                        "objective_score": 34.496298816365226
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.030178475379943847,
                        "num_nodes_avg": 287.8,
                        "path_length_avg": 139.5271231166937,
                        "smoothness_avg": 0.020290033291575655,
                        "success_improvement": 0.0,
                        "time_improvement": 38.47611641047452,
                        "node_improvement": 63.40750158931977,
                        "length_improvement": 7.332728393521491,
                        "smoothness_improvement": 158.08772581437248,
                        "objective_score": 16.732910588327112
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm with post-optimization limits: a two-tree, asymptotically optimal planner that, after finding a first feasible path, continues improving within the start\u2013goal ellipsoid for only a user-defined number of extra iterations (or until no improvement is observed), then stops.",
                "planning_mechanism": "Mechanism: Alternate expanding start/goal trees with RRT* best-parent selection and local rewiring; greedily connect the opposite tree; upon first connection, switch to informed (ellipsoidal) sampling and keep optimizing for N additional iterations (or until M consecutive non-improvements), always enforcing node and edge collision checks, bounds, and a strict 30 s time limit that returns the best path so far.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        neighbor_radius: float = 25.0,\n        post_opt_iters: int = 400,    # extra iterations after first solution\n        max_no_improve: int = 150,    # stop early if this many consecutive iterations show no improvement\n        improve_tol: float = 1e-6,    # minimal cost drop to count as improvement\n        time_limit_sec: float = 30.0  # hard wall time limit\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map: Map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks / boxes\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Core data\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        # Initialize two trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root  = Node(goal_position,  cost=0.0)\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # RRT* neighborhood (practical clamp)\n        gamma_rrt_star = 60.0\n        max_radius = max(bounds) * 0.30\n        min_radius = max(10.0, self.step_size * 2.0)\n\n        # Best solution & informed sampling params\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n        c_min = math.dist(start_position, goal_position)\n\n        # Post-optimization control\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        # Time guard\n        start_time = time.time()\n\n        # ---------- Helpers ----------\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def nearest(tree, pt):\n            return min(tree, key=lambda n: math.dist(n.position, pt))\n\n        def steer(from_pos, to_pos):\n            d = math.dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            r = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(dim))\n\n        def neighbor_radius_fn(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return min_radius\n            r_theory = gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(min_radius, min(max_radius, r_theory))\n\n        def near_nodes(tree, pos, radius):\n            return [nd for nd in tree if math.dist(nd.position, pos) <= radius]\n\n        def add_with_best_parent(tree, new_pos):\n            \"\"\"Insert new_pos using RRT* best-parent selection; return (new_node, neighbors) or (None, []).\"\"\"\n            r = neighbor_radius_fn(len(tree))\n            neigh = near_nodes(tree, new_pos, r)\n            parent_candidates = neigh if neigh else [nearest(tree, new_pos)]\n            parent_candidates = [nb for nb in parent_candidates\n                                 if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d)]\n            if not parent_candidates:\n                return None, []\n            parent = min(parent_candidates, key=lambda nb: nb.cost + math.dist(nb.position, new_pos))\n            new_node = Node(new_pos, parent=None, cost=parent.cost + math.dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neigh\n\n        def rewire_from(pivot: Node, neigh: List[Node]):\n            for nb in neigh:\n                if nb is pivot:\n                    continue\n                if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    continue\n                new_c = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_c + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_c\n                    edges.append((pivot, nb))\n\n        def stitch_paths(meet_a: Node, meet_b: Node, a_is_start_side: bool) -> List[Tuple[float, ...]]:\n            \"\"\"Create full path from start to goal using meeting nodes from both trees.\"\"\"\n            path_a = meet_a.path_from_root()\n            path_b = meet_b.path_from_root()\n            if path_a and path_b and path_a[-1] == path_b[-1]:\n                merged = path_a + path_b[-2::-1]\n            else:\n                merged = path_a + path_b[::-1]\n            return merged if a_is_start_side else merged[::-1]\n\n        def path_cost(path):\n            return sum(math.dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        # ---------- Main loop ----------\n        for it in range(self.max_iter):\n            # Hard time limit\n            if time.time() - start_time > self.time_limit_sec:\n                return PlannerResult(\n                    success=(len(best_path) > 0),\n                    path=best_path if best_path else [],\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            # Choose expansion/connection sides\n            if it % 2 == 0:\n                grow_tree, other_tree = tree_a, tree_b\n                a_is_start_side = True\n            else:\n                grow_tree, other_tree = tree_b, tree_a\n                a_is_start_side = False\n\n            # Informed sampling (uniform before first solution; ellipsoid after)\n            sample = self._sample_informed(start_position, goal_position, best_cost, c_min, bounds)\n\n            # Extend grow_tree toward sample\n            a_near = nearest(grow_tree, sample)\n            a_new_pos = steer(a_near.position, sample)\n\n            if (not within_bounds(a_new_pos)) or self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                # count post-optimization iterations if already in post phase\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            if self._is_edge_in_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            a_new, a_neigh = add_with_best_parent(grow_tree, a_new_pos)\n            if a_new is None:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            rewire_from(a_new, a_neigh)\n\n            # Greedy connect other_tree toward a_new, with local rewiring each step\n            b_near = nearest(other_tree, a_new.position)\n            current = b_near\n            connected_b = None\n\n            while True:\n                step_pos = steer(current.position, a_new.position)\n                if (not within_bounds(step_pos)) or self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                    break\n\n                b_new, b_neigh = add_with_best_parent(other_tree, step_pos)\n                if b_new is None:\n                    break\n                rewire_from(b_new, b_neigh)\n                current = b_new\n\n                # Try a final short bridge\n                if math.dist(current.position, a_new.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(current.position, a_new.position, obstacles, is_3d) and a_new.valid:\n                        final_b = Node(\n                            a_new.position,\n                            parent=None,\n                            cost=current.cost + math.dist(current.position, a_new.position)\n                        )\n                        current.add_child(final_b)\n                        other_tree.append(final_b)\n                        nodes.append(final_b)\n                        edges.append((current, final_b))\n                        connected_b = final_b\n                    break\n\n            # If a connection was made, evaluate and manage post-optimization counters\n            if connected_b is not None:\n                candidate_path = stitch_paths(a_new, connected_b, a_is_start_side)\n                cand_cost = path_cost(candidate_path)\n\n                if cand_cost + self.improve_tol < best_cost:\n                    best_cost = cand_cost\n                    best_path = candidate_path\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0\n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                # No successful connection this iteration\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------- Informed Sampling ----------------\n    def _sample_informed(self, start, goal, c_best, c_min, bounds):\n        \"\"\"Uniform in bounds if no solution; otherwise sample within the start\u2013goal ellipsoid.\"\"\"\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_min <= 1e-12:\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        # Ellipsoid radii\n        r1 = c_best / 2.0\n        r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n        r_other = math.sqrt(r_other_sq) / 2.0\n\n        # Center and first axis (unit)\n        center = tuple((s + g) / 2.0 for s, g in zip(start, goal))\n        a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n        # Orthonormal basis aligned with a1\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r_other)\n        else:  # 3D\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._normalize(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._normalize(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r_other, r_other)\n\n        u = self._sample_unit_ball(dim)\n\n        mapped = []\n        for d in range(dim):\n            val = center[d]\n            for i in range(dim):\n                val += basis[i][d] * radii[i] * u[i]\n            mapped.append(val)\n\n        mapped = tuple(min(max(mapped[d], 0.0), bounds[d]) for d in range(dim))\n        return mapped\n\n    def _sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(x * x for x in v))\n            if n > 1e-12:\n                v = [x / n for x in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)\n\n    # ---------------- Collision Utilities ----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": 69.74757337278861,
                "time_improvement": -274.0,
                "length_improvement": 18.0,
                "smoothness_improvement": 381.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.20740196704864503,
                        "num_nodes_avg": 464.8,
                        "path_length_avg": 153.4709982687105,
                        "smoothness_avg": 0.03085475415564487,
                        "success_improvement": 0.0,
                        "time_improvement": -713.3794671700809,
                        "node_improvement": -17.04860236716192,
                        "length_improvement": 15.880113945327547,
                        "smoothness_improvement": 382.94390470689814,
                        "objective_score": -202.57105226029324
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.08997392654418945,
                        "num_nodes_avg": 441.1,
                        "path_length_avg": 251.56015784219002,
                        "smoothness_avg": 0.017353540123566623,
                        "success_improvement": 0.0,
                        "time_improvement": 43.83556404272378,
                        "node_improvement": 70.3621581670362,
                        "length_improvement": 16.02197855460819,
                        "smoothness_improvement": 346.51908662909676,
                        "objective_score": 24.496451778727533
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.12373163700103759,
                        "num_nodes_avg": 510.6,
                        "path_length_avg": 119.34242112432332,
                        "smoothness_avg": 0.04030087577217426,
                        "success_improvement": 0.0,
                        "time_improvement": -152.24769427061182,
                        "node_improvement": 35.0794659885569,
                        "length_improvement": 20.738446364632033,
                        "smoothness_improvement": 412.6241651208389,
                        "objective_score": -31.168119636800128
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "GB-RRT* Connect with bounded rewiring and informed goal bias: a bidirectional, RRT*-style planner that alternates growing start/goal trees using k-nearest best-parent selection and local rewiring, uses goal/informed sampling for fast convergence, caches edge checks, and applies shortcut smoothing; it lazily bridges trees without duplicating meeting nodes and limits post-solution optimization for efficiency.",
            "planning_mechanism": "Alternate expanding the two trees toward informed/goal-biased samples; for each new node, pick the lowest-cost collision-free parent among k nearest neighbors, rewire locally with cost propagation, and attempt a short greedy connection to the opposite tree. Upon first connection, switch to ellipsoidal informed sampling and continue for a bounded number of iterations or until no improvement. Edge checks are cached; final path is shortcut-smoothed before returning.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        neighbor_k: int = 18,\n        time_limit_sec: float = 30.0,\n        goal_bias: float = 0.10,\n        post_opt_iters: int = 300,\n        no_improve_limit: int = 120,\n        smooth_iters: int = 120\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_k = neighbor_k\n        self.time_limit_sec = time_limit_sec\n        self.goal_bias = goal_bias\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.smooth_iters = smooth_iters\n\n        self._edge_cache = {}\n        self._edge_cache_limit = 50000\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n        success = False\n        best_path = []\n        best_cost = float(\"inf\")\n\n        # Early infeasible start/goal\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early direct connection\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d):\n            return PlannerResult(True, [start, goal], [Node(start), Node(goal)], [(Node(start), Node(goal))])\n\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        c_min = self._dist(start, goal)\n        start_time = self._now()\n\n        # RRT* neighborhood parameters\n        gamma_rrt = 60.0\n        max_radius = max(bounds) * 0.20\n        min_radius = max(self.step_size * 1.5, 5.0)\n\n        # Post-optimization bookkeeping\n        found_solution = False\n        post_iter = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            if self._now() - start_time > self.time_limit_sec:\n                break\n\n            # Alternate growing sides\n            if it % 2 == 0:\n                grow_tree, other_tree = tree_a, tree_b\n                a_is_start_side = True\n            else:\n                grow_tree, other_tree = tree_b, tree_a\n                a_is_start_side = False\n\n            # Sample with goal/informed bias\n            sample = self._sample_informed(start, goal, best_cost, c_min, bounds, obstacles, is_3d, found_solution)\n\n            # Extend grow_tree\n            a_near = self._nearest(grow_tree, sample)\n            a_new_pos = self._steer(a_near.position, sample, self.step_size)\n            if (not self._in_bounds(a_new_pos, bounds)) or self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                if found_solution:\n                    post_iter += 1\n                    no_improve += 1\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve >= self.no_improve_limit):\n                    break\n                continue\n            if self._is_edge_in_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                if found_solution:\n                    post_iter += 1\n                    no_improve += 1\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve >= self.no_improve_limit):\n                    break\n                continue\n\n            # Insert with best-parent among k-nearest inside adaptive radius\n            r_n = self._neighbor_radius(len(grow_tree), dim, gamma_rrt, min_radius, max_radius)\n            a_new, a_neigh = self._add_with_best_parent(grow_tree, nodes, edges, a_new_pos, obstacles, is_3d, r_n)\n            if a_new is None:\n                if found_solution:\n                    post_iter += 1\n                    no_improve += 1\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve >= self.no_improve_limit):\n                    break\n                continue\n\n            # Local rewiring around the inserted node with cost propagation\n            self._rewire_from(a_new, a_neigh, edges, obstacles, is_3d)\n\n            # Try short greedy connection from other_tree to a_new\n            connected_b = self._greedy_connect(other_tree, a_new.position, nodes, edges, obstacles, is_3d, dim, gamma_rrt, min_radius, max_radius, max_steps=3)\n\n            # Attempt final bridge if close\n            candidate_path = None\n            if connected_b is not None:\n                if self._dist(connected_b.position, a_new.position) <= self.step_size and not self._is_edge_in_obstacle(connected_b.position, a_new.position, obstacles, is_3d):\n                    # Add a visual bridge edge without altering parents (lazy bridge)\n                    edges.append((connected_b, a_new))\n                    # Stitch paths for evaluation\n                    path_a = a_new.path_from_root()\n                    path_b = connected_b.path_from_root()\n                    merged = path_a + path_b[-2::-1] if (path_a and path_b and path_a[-1] == path_b[-1]) else path_a + path_b[::-1]\n                    candidate_path = merged if a_is_start_side else merged[::-1]\n\n            if candidate_path:\n                cand_cost = self._path_cost(candidate_path)\n                if cand_cost + 1e-9 < best_cost:\n                    best_cost = cand_cost\n                    best_path = candidate_path\n                    success = True\n                    found_solution = True\n                    post_iter = 0\n                    no_improve = 0\n                else:\n                    if found_solution:\n                        post_iter += 1\n                        no_improve += 1\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve >= self.no_improve_limit):\n                    break\n            else:\n                if found_solution:\n                    post_iter += 1\n                    no_improve += 1\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve >= self.no_improve_limit):\n                    break\n\n        # Final smoothing\n        if success and len(best_path) >= 2:\n            best_path = self._shortcut_smooth(best_path, obstacles, is_3d, self.smooth_iters)\n\n        return PlannerResult(success, best_path if success else [], nodes, edges)\n\n    # ---------- Geometry / Utility ----------\n    def _now(self):\n        return time.time()\n\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _in_bounds(self, p, bounds):\n        for d in range(len(bounds)):\n            if p[d] < 0.0 or p[d] > bounds[d]:\n                return False\n        return True\n\n    def _nearest(self, tree, pt):\n        return min(tree, key=lambda n: self._dist(n.position, pt))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _neighbor_radius(self, n_nodes, dim, gamma, rmin, rmax):\n        if n_nodes < 2:\n            return rmin\n        val = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n        return max(rmin, min(rmax, val))\n\n    def _k_nearest_within(self, tree, pos, k, radius):\n        # Filter by radius then choose up to k nearest\n        pairs = []\n        for nd in tree:\n            d = self._dist(nd.position, pos)\n            if d <= radius:\n                pairs.append((d, nd))\n        if not pairs:\n            return []\n        pairs.sort(key=lambda x: x[0])\n        return [nd for _, nd in pairs[:min(k, len(pairs))]]\n\n    def _add_with_best_parent(self, tree, nodes, edges, new_pos, obstacles, is_3d, radius):\n        # Parent candidates among k-nearest inside radius; ensure edge collision free\n        neigh = self._k_nearest_within(tree, new_pos, self.neighbor_k, radius)\n        if not neigh:\n            # fallback to nearest\n            neigh = [self._nearest(tree, new_pos)]\n        parent_candidates = [nb for nb in neigh if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d)]\n        if not parent_candidates:\n            return None, []\n        best_parent = min(parent_candidates, key=lambda nb: nb.cost + self._dist(nb.position, new_pos))\n        new_node = Node(new_pos, parent=None, cost=best_parent.cost + self._dist(best_parent.position, new_pos))\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neigh\n\n    def _rewire_from(self, pivot, neigh, edges, obstacles, is_3d):\n        for nb in neigh:\n            if nb is pivot:\n                continue\n            if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                continue\n            new_cost = pivot.cost + self._dist(pivot.position, nb.position)\n            if new_cost + 1e-12 < nb.cost:\n                old_parent = nb.parent\n                if old_parent is not None:\n                    # Remove old edge if present\n                    try:\n                        edges.remove((old_parent, nb))\n                    except ValueError:\n                        pass\n                    try:\n                        old_parent.children.remove(nb)\n                    except ValueError:\n                        pass\n                pivot.add_child(nb)\n                nb.cost = new_cost\n                edges.append((pivot, nb))\n                self._propagate_cost_from(nb, edges)\n\n    def _propagate_cost_from(self, node, edges):\n        # Update costs in subtree after rewiring\n        queue = [node]\n        while queue:\n            cur = queue.pop(0)\n            for ch in cur.children:\n                new_c = cur.cost + self._dist(cur.position, ch.position)\n                if abs(new_c - ch.cost) > 1e-12:\n                    ch.cost = new_c\n                    queue.append(ch)\n\n    def _greedy_connect(self, tree, target_pos, nodes, edges, obstacles, is_3d, dim, gamma_rrt, rmin, rmax, max_steps=3):\n        current = self._nearest(tree, target_pos)\n        steps = 0\n        last_new = None\n        while steps < max_steps:\n            steps += 1\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                break\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                break\n            radius = self._neighbor_radius(len(tree), dim, gamma_rrt, rmin, rmax)\n            new_node, neigh = self._add_with_best_parent(tree, nodes, edges, step_pos, obstacles, is_3d, radius)\n            if new_node is None:\n                break\n            self._rewire_from(new_node, neigh, edges, obstacles, is_3d)\n            current = new_node\n            last_new = new_node\n            if self._dist(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    def _path_cost(self, path):\n        total = 0.0\n        for i in range(len(path) - 1):\n            total += self._dist(path[i], path[i + 1])\n        return total\n\n    # ---------- Sampling ----------\n    def _sample_informed(self, start, goal, c_best, c_min, bounds, obstacles, is_3d, have_solution):\n        dim = len(bounds)\n        # Try a few times to avoid sampling inside obstacles\n        for _ in range(50):\n            if not have_solution or c_best == float(\"inf\") or c_min <= 1e-12:\n                # Pre-solution: goal bias\n                if random.random() < self.goal_bias:\n                    sample = goal\n                else:\n                    sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            else:\n                # Post-solution: informed ellipsoidal sampling with some uniform escape\n                if random.random() < 0.80:\n                    sample = self._sample_ellipsoid(start, goal, c_best, c_min, bounds)\n                else:\n                    sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            if self._in_bounds(sample, bounds) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                return sample\n        # Fallback uniform\n        return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n    def _sample_ellipsoid(self, start, goal, c_best, c_min, bounds):\n        dim = len(bounds)\n        center = tuple((s + g) / 2.0 for s, g in zip(start, goal))\n        a1 = tuple((goal[d] - start[d]) / (c_min if c_min > 1e-12 else 1.0) for d in range(dim))\n        r1 = c_best / 2.0\n        r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n        r_other = math.sqrt(r_other_sq) / 2.0\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r_other)\n        else:\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._normalize(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._normalize(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r_other, r_other)\n        u = self._sample_unit_ball(dim)\n        mapped = []\n        for d in range(dim):\n            val = center[d]\n            for i in range(dim):\n                val += basis[i][d] * radii[i] * u[i]\n            # Clamp to bounds\n            val = min(max(val, 0.0), bounds[d])\n            mapped.append(val)\n        return tuple(mapped)\n\n    def _sample_unit_ball(self, dim):\n        # Gaussian direction + radius^(1/d)\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(x * x for x in v))\n            if n > 1e-12:\n                v = [x / n for x in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for x, y, z, w, h, d in obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for x, y, w, h in obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        # Direction-agnostic key with rounding to reduce duplicates\n        ra = tuple(round(c, 2) for c in a)\n        rb = tuple(round(c, 2) for c in b)\n        return (ra, rb) if ra <= rb else (rb, ra)\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        key = self._edge_key(from_pos, to_pos)\n        hit = self._edge_cache.get(key, None)\n        if hit is not None:\n            return hit\n        distance = self._dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                self._edge_cache[key] = True\n                if len(self._edge_cache) > self._edge_cache_limit:\n                    self._edge_cache.clear()\n                return True\n        self._edge_cache[key] = False\n        if len(self._edge_cache) > self._edge_cache_limit:\n            self._edge_cache.clear()\n        return False\n\n    # ---------- Smoothing ----------\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d):\n                # Shortcut\n                new_pts = pts[:i + 1] + pts[j:]\n                pts = new_pts\n                n = len(pts)\n        return pts",
            "objective": 23.10764,
            "time_improvement": -139.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1239.0,
            "node_improvement": 31.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.13042638301849366,
                    "num_nodes_avg": 488.2,
                    "path_length_avg": 150.21700760008898,
                    "smoothness_avg": 0.03945954965394641,
                    "success_improvement": 0.0,
                    "time_improvement": -411.50017251100286,
                    "node_improvement": -22.941324603374454,
                    "length_improvement": 17.663677793580806,
                    "smoothness_improvement": 517.6276398678153,
                    "objective_score": -110.2637068778133
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08705599308013916,
                    "num_nodes_avg": 504.4,
                    "path_length_avg": 233.63485048296306,
                    "smoothness_avg": 0.08420769273445602,
                    "success_improvement": 0.0,
                    "time_improvement": 45.6570260313673,
                    "node_improvement": 66.10898340388363,
                    "length_improvement": 22.005962102482787,
                    "smoothness_improvement": 2066.7245864070437,
                    "objective_score": 37.23430800293508
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07347123622894287,
                    "num_nodes_avg": 396.5,
                    "path_length_avg": 117.99846302312123,
                    "smoothness_avg": 0.09690125523828255,
                    "success_improvement": 0.0,
                    "time_improvement": -49.783437632906015,
                    "node_improvement": 49.586776859504134,
                    "length_improvement": 21.63103934304284,
                    "smoothness_improvement": 1132.5768141243043,
                    "objective_score": 3.7064763865754218
                }
            ],
            "success_rate": 1.0
        },
        "objective": 11.2,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Early termination at first feasible connection with minimal post-solution refinement, yielding unnecessarily long routes\n   - Weak or absent goal/informed sampling bias, causing meandering exploration and longer connections\n   - Rewiring without proper subtree cost propagation, leaving stale costs that misguide parent selection\n   - Large/unbounded neighbor sets and long greedy connects that introduce detours and zig\u2011zags\n   - Bridge construction duplicating meeting nodes, adding redundant waypoints\n   - No path shortcut/smoothing to remove jagged segments"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Goal\u2011biased sampling before the first solution and informed (ellipsoidal) sampling afterward\n   - Best\u2011parent selection among k\u2011nearest neighbors within an adaptive radius, followed by local rewiring with subtree cost propagation\n   - Bounded greedy connection and lazy bridging (no node duplication)\n   - Final shortcut smoothing of the returned path\n2. Expected mechanism of impact:\n   - Focused sampling concentrates growth in the start\u2013goal corridor, reducing detours\n   - Accurate cumulative costs enable selecting truly lower\u2011cost parents, producing straighter, shorter trees\n   - Limiting connect steps and avoiding duplicate meeting nodes prevent redundant bends and waypoints\n   - Smoothing eliminates zig\u2011zags and shortens the polyline, improving overall path length"
        }
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
                "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": 40.329779996976704,
                "time_improvement": -177.0,
                "length_improvement": 20.0,
                "smoothness_improvement": 159.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.07894549369812012,
                        "num_nodes_avg": 472.0,
                        "path_length_avg": 157.32038918113068,
                        "smoothness_avg": 0.014606659642752063,
                        "success_improvement": 0.0,
                        "time_improvement": -209.60479552537316,
                        "node_improvement": -18.86174767061193,
                        "length_improvement": 13.770201788727634,
                        "smoothness_improvement": 128.6259422781621,
                        "objective_score": -53.97618787298455
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.46640329360961913,
                        "num_nodes_avg": 1739.6,
                        "path_length_avg": 225.40943011339232,
                        "smoothness_avg": 0.011026273197920444,
                        "success_improvement": 0.0,
                        "time_improvement": -191.14298908956366,
                        "node_improvement": -16.885036618961227,
                        "length_improvement": 24.75184417744357,
                        "smoothness_improvement": 183.71395128606335,
                        "objective_score": -41.57322046397263
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.11344788074493409,
                        "num_nodes_avg": 800.3,
                        "path_length_avg": 117.65534395554543,
                        "smoothness_avg": 0.020903807431829922,
                        "success_improvement": 0.0,
                        "time_improvement": -131.28253235311988,
                        "node_improvement": -1.7546090273362944,
                        "length_improvement": 21.85892269015246,
                        "smoothness_improvement": 165.8948875743123,
                        "objective_score": -25.439931653972927
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "path_expert",
                "algorithm_description": "Cross-Tree Rewired Informed RRT* (CTR-iRRT*): a bidirectional, cost-guided planner that minimizes path length by informed sampling, logarithmic-neighborhood RRT* rewiring, and low-overhead cross-tree connections. It avoids long connection chains by testing best-cost direct links to the opposite tree and, if needed, adds at most one assistance step there. Edges and costs are kept coherent with fast, stack-based propagation, and the final path is greedily compressed and shortcut-smoothed.",
                "planning_mechanism": "Mechanism: alternate tree growth with ellipse- and line-corridor-biased sampling; steer one step, validate node and edge, pick the cheapest parent among logarithmic-radius neighbors, then rewire cheaper neighbors; attempt a direct best-cost connection to the other tree within an adaptive radius, else create a single assist step toward the meeting point and retry; upon any improvement, restrict sampling to a prolate hyperspheroid of the incumbent cost; terminate after a focused post-optimization budget or stagnation and return a smoothed path.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=4.0,\n                 gamma_radius=80.0,\n                 min_radius=4.0,\n                 goal_bias=0.08,\n                 line_bias=0.28,\n                 r_connect_factor=1.6,\n                 post_opt_iters=700,\n                 max_no_improve=260,\n                 smoothing_iters=200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_radius = gamma_radius\n        self.min_radius = min_radius\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.r_connect_factor = r_connect_factor\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n\n        # Spatial hash grids for fast NN and near queries\n        cell = max(1.0, self.step_size)\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root, cell)\n        self._grid_add(grid_goal, goal_root, cell)\n\n        success = False\n        best_cost = float('inf')\n        best_pair = (None, None)\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            active_first = (it % 2 == 0)\n            for which in (0, 1):\n                tree_a = start_tree if (active_first ^ (which == 1)) else goal_tree\n                tree_b = goal_tree if (tree_a is start_tree) else start_tree\n                grid_a = grid_start if (tree_a is start_tree) else grid_goal\n                grid_b = grid_goal if (tree_b is goal_tree) else grid_start\n\n                # Sample\n                x_rand = self._sample_biased(start, goal, best_cost)\n                if self._rand() < self.goal_bias:\n                    x_rand = goal if (tree_a is start_tree) else start\n\n                # Nearest and steer\n                n_near = self._nearest_grid(grid_a, tree_a, x_rand, cell)\n                x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n                # Validate node and incoming edge\n                if not self._in_bounds(x_new_pos):\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n                    continue\n                if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n                    continue\n                if self._is_edge_in_obstacle(n_near.position, x_new_pos, obstacles, is_3d):\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n                    continue\n\n                x_new = Node(x_new_pos)\n                # Choose best parent within adaptive RRT* radius\n                n_nodes = max(2, len(tree_a) + len(tree_b))\n                r_near = self._rrtstar_radius(n_nodes)\n                near_nodes = self._near_grid(grid_a, x_new_pos, r_near, cell)\n\n                best_parent = n_near\n                best_pc = n_near.cost + self._dist(n_near.position, x_new_pos)\n                for nn in near_nodes:\n                    cand = nn.cost + self._dist(nn.position, x_new_pos)\n                    if cand + 1e-12 < best_pc and not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d):\n                        best_parent = nn\n                        best_pc = cand\n\n                # Commit new node (checks again were done above for the chosen parent edge)\n                best_parent.add_child(x_new)\n                x_new.cost = best_pc\n                tree_a.append(x_new)\n                nodes.append(x_new)\n                self._grid_add(grid_a, x_new, cell)\n\n                # Rewire\n                for nn in near_nodes:\n                    alt = x_new.cost + self._dist(x_new.position, nn.position)\n                    if alt + 1e-12 < nn.cost and not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d):\n                        op = nn.parent\n                        if op is not None:\n                            # update child lists\n                            try:\n                                op.children.remove(nn)\n                            except:\n                                pass\n                        x_new.add_child(nn)\n                        nn.cost = alt\n                        self._propagate_costs_from(nn)\n\n                # Cross-tree connection: direct best-cost within radius; else single assist step\n                improved = False\n                r_conn = max(r_near, self.step_size * self.r_connect_factor)\n                # 1) Try direct links to best-cost neighbor(s) in the other tree\n                cand_b = self._near_grid(grid_b, x_new_pos, r_conn, cell)\n                meet = None\n                best_join_cost = best_cost\n                for nb in cand_b:\n                    if not self._is_edge_in_obstacle(x_new_pos, nb.position, obstacles, is_3d):\n                        path_cost = x_new.cost + self._dist(x_new_pos, nb.position) + nb.cost\n                        if path_cost + 1e-12 < best_join_cost:\n                            best_join_cost = path_cost\n                            meet = nb\n                if meet is not None:\n                    best_cost = best_join_cost\n                    best_pair = (x_new, meet)\n                    success = True\n                    found_first = True\n                    post_iters = 0\n                    no_improve = 0\n                    improved = True\n                else:\n                    # 2) Single assist step from the other tree toward x_new\n                    nb_near = self._nearest_grid(grid_b, tree_b, x_new_pos, cell)\n                    assist_pos = self._steer(nb_near.position, x_new_pos, self.step_size)\n                    if self._in_bounds(assist_pos) and not self._is_in_obstacle(assist_pos, obstacles, is_3d):\n                        if not self._is_edge_in_obstacle(nb_near.position, assist_pos, obstacles, is_3d):\n                            assist = Node(assist_pos)\n                            # local best parent in tree_b for assist\n                            near_b = self._near_grid(grid_b, assist_pos, r_near, cell)\n                            best_pb = nb_near\n                            best_bc = nb_near.cost + self._dist(nb_near.position, assist_pos)\n                            for nb in near_b:\n                                cbc = nb.cost + self._dist(nb.position, assist_pos)\n                                if cbc + 1e-12 < best_bc and not self._is_edge_in_obstacle(nb.position, assist_pos, obstacles, is_3d):\n                                    best_pb = nb\n                                    best_bc = cbc\n                            best_pb.add_child(assist)\n                            assist.cost = best_bc\n                            tree_b.append(assist)\n                            nodes.append(assist)\n                            self._grid_add(grid_b, assist, cell)\n\n                            # local rewire around assist (limited to near_b)\n                            for nb in near_b:\n                                altb = assist.cost + self._dist(assist.position, nb.position)\n                                if altb + 1e-12 < nb.cost and not self._is_edge_in_obstacle(assist.position, nb.position, obstacles, is_3d):\n                                    obp = nb.parent\n                                    if obp is not None:\n                                        try:\n                                            obp.children.remove(nb)\n                                        except:\n                                            pass\n                                    assist.add_child(nb)\n                                    nb.cost = altb\n                                    self._propagate_costs_from(nb)\n\n                            # retry direct connect with the new assist node considered\n                            cand2 = self._near_grid(grid_b, x_new_pos, r_conn, cell)\n                            meet2 = None\n                            best_join_cost2 = best_cost\n                            for nb in cand2:\n                                if not self._is_edge_in_obstacle(x_new_pos, nb.position, obstacles, is_3d):\n                                    path_cost = x_new.cost + self._dist(x_new_pos, nb.position) + nb.cost\n                                    if path_cost + 1e-12 < best_join_cost2:\n                                        best_join_cost2 = path_cost\n                                        meet2 = nb\n                            if meet2 is not None:\n                                best_cost = best_join_cost2\n                                best_pair = (x_new, meet2)\n                                success = True\n                                found_first = True\n                                post_iters = 0\n                                no_improve = 0\n                                improved = True\n\n                if found_first and not improved:\n                    post_iters += 1\n                    no_improve += 1\n\n                if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                    break\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        path = []\n        if success and best_pair[0] is not None:\n            path = self._extract_path(best_pair[0], best_pair[1])\n            path = self._greedy_compress(path, obstacles, is_3d)\n            path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n\n        # materialize edges coherently from parent/children\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---------- Utilities ----------\n    def _rand(self):\n        try:\n            return random.random()\n        except:\n            if not hasattr(self, \"_lcg_state\"):\n                self._lcg_state = 2463534242\n            self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n            return (self._lcg_state / float(1 << 32))\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = (a[i] - b[i])\n            s += d * d\n        return s ** 0.5\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        # ln(n) \u2248 bit_length(n) * ln(2)\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    def _rrtstar_radius(self, n):\n        if n <= 2:\n            return max(self.min_radius, self.step_size)\n        r = self.gamma_radius * ((self._log_approx(n) / float(n)) ** (1.0 / max(2, self.dim)))\n        if r < self.min_radius:\n            r = self.min_radius\n        return r\n\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _grid_gather(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos, cell):\n        best = None\n        bestd = float('inf')\n        # Expand rings up to a safe bound\n        max_rings = int((max(self.bounds) / cell)) + 2\n        for ring in range(1, max_rings + 1):\n            cand = self._grid_gather(grid, pos, ring * cell, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_grid(self, grid, pos, radius, cell):\n        cand = self._grid_gather(grid, pos, radius, cell)\n        out = []\n        r2 = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _sample_biased(self, start, goal, c_best):\n        # Informed rejection inside prolate hyperspheroid after first solution; else mixture of uniform and line-corridor\n        use_line = (self._rand() < self.line_bias)\n        if c_best < float('inf'):\n            # informed rejection: accept if within start-goal ellipse\n            for _ in range(60):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._dist(p, start) + self._dist(p, goal) <= c_best and self._in_bounds(p):\n                    return p\n        if use_line:\n            # sample along the start-goal line with small jitter to favor short paths\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jitter = 0.5 * self.step_size\n            p = tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n            return p\n        # uniform fallback\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _path_to_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        path.reverse()\n        return path\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)  # start -> meet_a\n        # meet_b to goal along its tree (goal-rooted)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # Concatenate; edge between meet_a and meet_b is implicit\n        return path_a + path_b\n\n    def _propagate_costs_from(self, node):\n        stack = []\n        for c in node.children:\n            stack.append(c)\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                stack.append(c)\n\n    def _greedy_compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            # try the farthest reachable\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
                "objective": 139.64039,
                "time_improvement": -532.0,
                "length_improvement": 22.0,
                "smoothness_improvement": 1266.0,
                "node_improvement": -22.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.3195624828338623,
                        "num_nodes_avg": 602.0,
                        "path_length_avg": 147.59826910995267,
                        "smoothness_avg": 0.04229611616050018,
                        "success_improvement": 0.0,
                        "time_improvement": -1153.2454041479311,
                        "node_improvement": -51.599093427348265,
                        "length_improvement": 19.099049856591378,
                        "smoothness_improvement": 562.0260653981402,
                        "objective_score": -331.7040610034338
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.39352576732635497,
                        "num_nodes_avg": 1492.2,
                        "path_length_avg": 223.7879408686806,
                        "smoothness_avg": 0.0890195817850141,
                        "success_improvement": 0.0,
                        "time_improvement": -145.6506413075557,
                        "node_improvement": -0.2620439427534832,
                        "length_improvement": 25.293143959308452,
                        "smoothness_improvement": 2190.537957541495,
                        "objective_score": -17.566616228974162
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.1941249132156372,
                        "num_nodes_avg": 898.0,
                        "path_length_avg": 115.8304308545075,
                        "smoothness_avg": 0.09015448143133267,
                        "success_improvement": 0.0,
                        "time_improvement": -295.75619417947627,
                        "node_improvement": -14.17673235855054,
                        "length_improvement": 23.070943078838237,
                        "smoothness_improvement": 1046.7583492949423,
                        "objective_score": -69.65050066006523
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "UniGrid Informed RRT*-Fast (UG-IRRT*-F): a single-tree, cost-optimal planner that uses a uniform spatial hash for O(1)-average neighbor queries, \u03b3(log n/n)^(1/d) adaptive neighborhoods, informed ellipsoidal sampling after the first solution, duplicate-node suppression, lazy rewires with incremental cost push, and goal-side best-parent connection; it continues optimizing under a focused post-optimization budget and returns a compressed, shortcut-smoothed path.",
            "planning_mechanism": "At each iteration, sample (goal/line/ellipse-biased), steer one step from the nearest node, validate node and edge, choose the lowest-cost valid parent within an adaptive radius, add the node, and lazily rewire cheaper neighbors. If close to the goal, select the best-cost valid parent for the goal among nearby nodes and update the incumbent path. After finding a solution, restrict sampling to the informed set and terminate on a time/no-improvement budget, then compress and shortcut the path.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4200,\n                 step_size=5.0,\n                 gamma_radius=55.0,\n                 min_radius_factor=1.0,\n                 goal_bias=0.12,\n                 line_bias=0.38,\n                 connect_factor=2.0,\n                 near_cap=64,\n                 post_opt_iters=450,\n                 max_no_improve=180,\n                 smoothing_iters=160):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_radius = gamma_radius\n        self.min_radius_factor = min_radius_factor\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_factor = connect_factor\n        self.near_cap = near_cap\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        root = Node(start, None, 0.0)\n        nodes = [root]\n\n        # spatial hash grid\n        cell = max(1.0, 0.8 * self.step_size)\n        grid = {}\n        self._grid_add(grid, root, cell)\n\n        # coarse occupancy to suppress duplicates\n        occ_cell = max(0.5, 0.6 * self.step_size)\n        occ = {self._occ_key(start, occ_cell): True}\n\n        success = False\n        best_cost = float('inf')\n        goal_node = None\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            # sample\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                x_rand = self._sample_biased(start, goal, best_cost)\n\n            # nearest\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n            # bounds and node collision\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # duplicate suppression\n            k_occ = self._occ_key(x_new_pos, occ_cell)\n            if k_occ in occ:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # incoming edge collision\n            if self._is_edge_in_obstacle(n_near.position, x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # choose best parent within adaptive radius\n            r_near = self._rrtstar_radius(max(2, len(nodes)))\n            near_nodes = self._near(grid, x_new_pos, r_near, cell)\n            if near_nodes:\n                near_nodes = self._limit_by_distance(near_nodes, x_new_pos, self.near_cap)\n            best_parent = n_near\n            best_pc = n_near.cost + self._dist(n_near.position, x_new_pos)\n            for nn in near_nodes:\n                if nn is n_near:\n                    continue\n                c = nn.cost + self._dist(nn.position, x_new_pos)\n                if c + 1e-12 < best_pc:\n                    if not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d):\n                        best_pc = c\n                        best_parent = nn\n\n            # commit new node (both checks were done above for chosen parent)\n            x_new = Node(x_new_pos, None, best_pc)\n            x_new.attach(best_parent)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            occ[k_occ] = True\n\n            # rewire nearby nodes\n            for nn in near_nodes:\n                if nn is best_parent or nn is x_new:\n                    continue\n                alt = x_new.cost + self._dist(x_new.position, nn.position)\n                if alt + 1e-12 < nn.cost:\n                    if not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d):\n                        nn.attach(x_new)\n                        self._propagate_costs_from(nn)\n\n            # goal-side best-parent connection when close\n            improved = False\n            r_conn = max(r_near, self.connect_factor * self.step_size)\n            if self._dist(x_new.position, goal) <= r_conn:\n                if not self._is_in_obstacle(goal, obstacles, is_3d):\n                    # consider best parent among nodes near goal (including x_new)\n                    cand = self._near(grid, goal, r_conn, cell)\n                    if x_new not in cand:\n                        cand.append(x_new)\n                    best_parent_goal = None\n                    best_goal_cost = best_cost\n                    for p in cand:\n                        if not self._is_edge_in_obstacle(p.position, goal, obstacles, is_3d):\n                            ctot = p.cost + self._dist(p.position, goal)\n                            if ctot + 1e-12 < best_goal_cost:\n                                best_goal_cost = ctot\n                                best_parent_goal = p\n                    if best_parent_goal is not None:\n                        if goal_node is None:\n                            goal_node = Node(goal, None, best_goal_cost)\n                            goal_node.attach(best_parent_goal)\n                            nodes.append(goal_node)\n                        else:\n                            goal_node.cost = best_goal_cost\n                            goal_node.attach(best_parent_goal)\n                        best_cost = best_goal_cost\n                        success = True\n                        found_first = True\n                        improved = True\n                        post_iters = 0\n                        no_improve = 0\n\n            if found_first and not improved:\n                post_iters += 1\n                no_improve += 1\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        path = []\n        if success and goal_node is not None:\n            # extract\n            cur = goal_node\n            while cur is not None:\n                path.append(cur.position)\n                cur = cur.parent\n            path.reverse()\n            # postprocess\n            path = self._compress(path, obstacles, is_3d)\n            path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n\n        # build edges from parent pointers\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---------- Utilities ----------\n    def _rand(self):\n        try:\n            return self._lcg_next()\n        except:\n            return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 1103515245\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    def _rrtstar_radius(self, n):\n        r = self.gamma_radius\n        if n > 2:\n            expo = 1.0 / float(max(2, self.dim))\n            r = self.gamma_radius * ((self._log_approx(n) / float(n)) ** expo)\n        rmin = max(self.min_radius_factor * self.step_size, 1e-6)\n        if r < rmin:\n            r = rmin\n        return r\n\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        # exponential expansion until candidates appear\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        max_span = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > max_span:\n                max_span = self.bounds[i]\n        limit = max_span * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # fallback linear scan\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _limit_by_distance(self, nodes, center, k):\n        # partial selection of up to k nearest without full sort when large\n        if len(nodes) <= k:\n            return nodes\n        # simple reservoir based on distance threshold\n        # compute distances\n        idx = []\n        for i, n in enumerate(nodes):\n            idx.append((self._dist(n.position, center), i))\n        # partial selection: nth-element by repeated scanning (k small)\n        # choose k smallest by single pass selection\n        # fallback: simple sort when moderate\n        if len(nodes) <= 4 * k:\n            idx.sort(key=lambda t: t[0])\n            sel = [nodes[t[1]] for t in idx[:k]]\n            return sel\n        # approximate: pick k minima by iterative pass\n        sel = []\n        used = [False] * len(nodes)\n        for _ in range(k):\n            best = -1\n            bestd = float('inf')\n            for j, (d, i) in enumerate(idx):\n                if not used[j] and d < bestd:\n                    bestd = d\n                    best = j\n            if best == -1:\n                break\n            used[best] = True\n            sel.append(nodes[idx[best][1]])\n        return sel\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _sample_biased(self, start, goal, c_best):\n        # informed ellipsoidal rejection after first solution; else line/uniform mix\n        if c_best < float('inf'):\n            for _ in range(20):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._dist(p, start) + self._dist(p, goal) <= c_best and self._in_bounds(p):\n                    return p\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jitter = 0.5 * self.step_size\n            p = tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n            return p\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _propagate_costs_from(self, node):\n        stack = []\n        for c in node.children:\n            stack.append(c)\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                stack.append(c)\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
            "objective": -3.65664,
            "time_improvement": -50.0,
            "length_improvement": 19.0,
            "smoothness_improvement": 1436.0,
            "node_improvement": 46.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06231374740600586,
                    "num_nodes_avg": 244.5,
                    "path_length_avg": 159.99708988452147,
                    "smoothness_avg": 0.04079917273665813,
                    "success_improvement": 0.0,
                    "time_improvement": -144.3791801192523,
                    "node_improvement": 38.42860740367666,
                    "length_improvement": 12.303059718162231,
                    "smoothness_improvement": 538.5956501503387,
                    "objective_score": -33.238939954126664
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.11423308849334717,
                    "num_nodes_avg": 663.4,
                    "path_length_avg": 229.07326285952672,
                    "smoothness_avg": 0.10084089211799352,
                    "success_improvement": 0.0,
                    "time_improvement": 28.69226420016899,
                    "node_improvement": 55.42565343008802,
                    "length_improvement": 23.528751349205564,
                    "smoothness_improvement": 2494.7087869547277,
                    "objective_score": 35.19847400434767
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06615550518035888,
                    "num_nodes_avg": 438.5,
                    "path_length_avg": 117.70760748606574,
                    "smoothness_avg": 0.108123212990666,
                    "success_improvement": 0.0,
                    "time_improvement": -34.86909289750288,
                    "node_improvement": 44.24666242848061,
                    "length_improvement": 21.824211741702758,
                    "smoothness_improvement": 1275.3192884158632,
                    "objective_score": 9.010395617850108
                }
            ],
            "success_rate": 1.0
        },
        "objective": 12.600000000000001,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Premature termination after the first feasible goal connection, with limited or no post-solution optimization; goal often attached to the latest expansion rather than the best local parent near the goal.\n   - Non-adaptive or mis-scaled neighbor selection and incomplete subtree cost propagation after rewires, leading to stale costs and suboptimal parent choices.\n   - Inefficient or biased nearest-neighbor queries that can favor non-ideal parents in cluttered regions.\n   - Lack of duplicate-state suppression, causing dense, redundant node clusters that hinder discovery of shorter connectors.\n   - Weak or absent path post-processing (compression/shortcutting), leaving detours and unnecessary waypoints in the final path."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Goal-side best-parent selection among nodes near the goal before attaching the goal.\n   - Continued optimization with informed (ellipse/line/goal-biased) sampling after the first solution under a no-improvement/time budget.\n   - Duplicate-node suppression via coarse occupancy to prevent redundant expansions.\n   - Adaptive neighborhood radius with a cap on nearby candidates and spatial hashing for focused, high-quality rewiring.\n   - Correct cost propagation through subtrees after rewires.\n   - Path compression and randomized shortcut smoothing.\n2. Expected mechanism of impact:\n   - Selecting the best local goal parent reduces terminal overhang and immediately shortens the goal connection.\n   - Informed, post-solution sampling concentrates exploration in promising regions, steadily replacing detours with shorter chords.\n   - Suppressing duplicates frees capacity for novel connectors that create shorter hops and better rewiring opportunities.\n   - Properly scaled and capped neighbor sets emphasize high-quality parents, yielding lower-cost attachments and effective local rewires.\n   - Propagating reduced costs makes descendants eligible as better parents later, compounding path shortening across the tree.\n   - Compression and shortcuts remove superfluous waypoints and long segments, directly decreasing total path length."
        }
    },
    {
        "parents": [
            {
                "operator": "path_expert",
                "algorithm_description": "Informed Dual-Tree RRT* with Commit-Only Connect and Grandparent Line-of-Sight Rewiring (IDT-RRT*++): a bidirectional, asymptotically optimal planner focused on minimizing path length. It uses an r(n) \u221d (log n / n)^(1/d) neighborhood for high-quality parent selection and rewiring, performs zero-bloat \u201ccommit-only\u201d tree connection (adds no nodes on failed connects), prunes expansions with an admissible cost-to-go bound once a path exists, and applies grandparent line-of-sight rewiring to remove zig-zags. Informed rejection sampling inside the prolate hyperspheroid rapidly tightens the incumbent cost, while anytime shortcut smoothing further reduces length during and after planning.",
                "planning_mechanism": "Mechanism: alternate growing start/goal trees with informed sampling; steer, validate node and edge, choose the least-cost parent among r(n) neighbors, apply LOS-to-grandparent improvement and rewire; attempt direct, collision-free joining to the opposite tree without committing nodes unless the join succeeds; upon any improvement, prune by cost-to-go and restrict future samples to the hyperspheroid; periodically perform shortcut attempts on the current best path; terminate on budget or stagnation and return the shortest smoothed path.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=7000,\n                 step_size=5.0,\n                 goal_bias=0.15,\n                 base_radius=30.0,\n                 min_radius=6.0,\n                 collision_step=1.0,\n                 post_opt_iters=1000,\n                 max_no_improve=300,\n                 smoothing_iters=180,\n                 min_separation_ratio=0.35,\n                 per_iter_shortcuts=2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.collision_step = collision_step\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.min_separation_ratio = min_separation_ratio\n        self.per_iter_shortcuts = per_iter_shortcuts\n\n        self.dim = 2\n        self.bounds = None\n\n    # ------------- Core planning -------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Space scale estimates\n        self.space_diam = self._dist(tuple(0.0 for _ in range(self.dim)), tuple(self.bounds[i] for i in range(self.dim)))\n        r_max = max(self.min_radius, self.base_radius)\n        self.grid_cell = max(self.step_size * 1.25, r_max * 0.5)\n        self.min_separation = max(1.0, self.step_size * self.min_separation_ratio)\n        self.edge_res = max(0.5, min(self.collision_step, self.step_size / 4.0))\n\n        # Trees, grids, and edge maps (child -> parent)\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        parent_of = {start_root: None, goal_root: None}\n\n        # Planning state\n        success = False\n        best_cost = float('inf')\n        best_join = (None, None)\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n        incumbent_path = []\n\n        # Alternate expansion\n        for it in range(self.max_iter):\n            for which in (0, 1):\n                active_start = ((it + which) % 2 == 0)\n                tree_a = start_tree if active_start else goal_tree\n                tree_b = goal_tree if active_start else start_tree\n                grid_a = grid_start if active_start else grid_goal\n                grid_b = grid_goal if active_start else grid_start\n                root_other = goal if active_start else start\n\n                # Sample (informed if path known), with occasional bias to the opposite root\n                if self._rand() < self.goal_bias:\n                    x_rand = root_other\n                else:\n                    x_rand = self._sample(start, goal, best_cost, obstacles, is_3d)\n\n                # Nearest and steer\n                x_nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n                x_new_pos = self._steer(x_nearest.position, x_rand, self.step_size)\n                if not self._in_bounds(x_new_pos):\n                    continue\n                if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                    continue\n\n                # Separation: avoid adding nodes too close to existing ones\n                if self._dist(x_nearest.position, x_new_pos) < self.min_separation:\n                    continue\n\n                # Choose best parent among near neighbors with RRT* radius\n                n_nodes = len(tree_a) + 1\n                r_near = self._rrtstar_radius(n_nodes)\n                near_nodes = self._near_grid(grid_a, x_new_pos, r_near)\n                if x_nearest not in near_nodes:\n                    near_nodes.append(x_nearest)\n\n                best_parent = None\n                best_pc = float('inf')\n                for nn in near_nodes:\n                    # Prune by admissible bound once a path exists\n                    if found_first:\n                        # Active tree cost-to-go to opposite root (start-tree -> goal, goal-tree -> start)\n                        if nn.cost + self._dist(nn.position, root_other) >= best_cost - 1e-9:\n                            continue\n                    cand_cost = nn.cost + self._dist(nn.position, x_new_pos)\n                    if cand_cost < best_pc and not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                        best_parent = nn\n                        best_pc = cand_cost\n\n                if best_parent is None:\n                    continue\n\n                # Grandparent line-of-sight (LOS) shortcut: try to reduce zig-zag and path length\n                improved = True\n                gp_parent = best_parent.parent\n                cur_parent = best_parent\n                cur_cost = best_pc\n                while improved and gp_parent is not None:\n                    gp_cost = gp_parent.cost + self._dist(gp_parent.position, x_new_pos)\n                    if gp_cost + 1e-12 < cur_cost and not self._is_edge_in_obstacle(gp_parent.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                        cur_parent = gp_parent\n                        cur_cost = gp_cost\n                        gp_parent = cur_parent.parent\n                    else:\n                        improved = False\n                best_parent = cur_parent\n                best_pc = cur_cost\n\n                # Create and insert node\n                x_new = Node(x_new_pos)\n                x_new.cost = best_pc\n                best_parent.add_child(x_new)\n                tree_a.append(x_new)\n                nodes.append(x_new)\n                parent_of[x_new] = best_parent\n                self._grid_add(grid_a, x_new)\n\n                # Rewire neighbors through x_new\n                for nn in near_nodes:\n                    if nn is best_parent or nn is x_new:\n                        continue\n                    # Prune by admissible bound once a path exists\n                    if found_first:\n                        if x_new.cost + self._dist(x_new.position, root_other) >= best_cost - 1e-9:\n                            continue\n                    alt = x_new.cost + self._dist(x_new.position, nn.position)\n                    if alt + 1e-12 < nn.cost and not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d, self.edge_res):\n                        oldp = parent_of.get(nn, nn.parent)\n                        if oldp is not None:\n                            # Detach from old parent\n                            try:\n                                oldp.children.remove(nn)\n                            except:\n                                pass\n                        x_new.add_child(nn)\n                        nn.cost = alt\n                        parent_of[nn] = x_new\n                        self._propagate_costs_from(nn)\n\n                # Try commit-only direct connection to closest node in the opposite tree\n                nnear_b = self._nearest_grid(grid_b, tree_b, x_new.position)\n                if nnear_b is not None:\n                    if not self._is_edge_in_obstacle(x_new.position, nnear_b.position, obstacles, is_3d, self.edge_res):\n                        path_cost = x_new.cost + self._dist(x_new.position, nnear_b.position) + nnear_b.cost\n                        if path_cost + 1e-12 < best_cost:\n                            best_cost = path_cost\n                            best_join = (x_new, nnear_b)\n                            success = True\n                            found_first = True\n                            post_iters = 0\n                            no_improve = 0\n                            incumbent_path = self._extract_path(best_join[0], best_join[1])\n                        else:\n                            no_improve += 1\n                        post_iters += 1\n                    else:\n                        if found_first:\n                            post_iters += 1\n                            no_improve += 1\n                else:\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n\n                # Anytime shortcut attempts to shave length during planning\n                if found_first and incumbent_path:\n                    for _ in range(self.per_iter_shortcuts):\n                        incumbent_path = self._shortcut_once(incumbent_path, obstacles, is_3d)\n                    new_len = self._path_length(incumbent_path)\n                    if new_len + 1e-12 < best_cost:\n                        best_cost = new_len\n                        no_improve = 0\n                        post_iters = 0\n\n                # Early termination on post-optimization budget or stagnation\n                if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                    break\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        # Final path and smoothing\n        path = []\n        if success and best_join[0] is not None:\n            path = self._extract_path(best_join[0], best_join[1])\n            path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n\n        # Build coherent edges list from parent map\n        edges = []\n        for n, p in list(parent_of.items()):\n            if p is not None:\n                edges.append((p, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ------------- Utilities -------------\n    def _rand(self):\n        try:\n            return random.random()\n        except:\n            if not hasattr(self, \"_lcg_state\"):\n                self._lcg_state = 2463534242\n            self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n            return (self._lcg_state / float(1 << 32))\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = (a[i] - b[i])\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        ratio = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(self.dim)))\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # ------------- Collision checks -------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-6, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ------------- Sampling -------------\n    def _sample(self, start, goal, c_best, obstacles, is_3d):\n        # Informed rejection sampling inside prolate hyperspheroid via distance-sum <= c_best\n        # Avoid obstacles with a few retries; fall back to uniform in-bounds\n        attempts = 0\n        max_attempts = 200\n        while attempts < max_attempts:\n            attempts += 1\n            p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n            if not self._in_bounds(p):\n                continue\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                continue\n            if c_best < float('inf'):\n                if self._dist(p, start) + self._dist(p, goal) <= c_best + 1e-9:\n                    return p\n            else:\n                return p\n        # Fallback uniform valid point\n        while True:\n            p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ------------- Neighborhoods -------------\n    def _rrtstar_radius(self, n):\n        if n <= 2:\n            return max(self.min_radius, self.base_radius)\n        # ln(n) via log2 approximation: ln(n) = log2(n) * ln(2)\n        log2n = max(1.0, float(n.bit_length() - 1))\n        ln2 = 0.6931471805599453\n        ln_n = log2n * ln2\n        dim = max(2, self.dim)\n        gamma = 1.5 * (self.space_diam)  # scale with space size\n        r = gamma * ((ln_n / float(n)) ** (1.0 / dim))\n        r = max(self.min_radius, min(self.base_radius, r))\n        return r\n\n    # ------------- Grid indexing -------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        key = self._grid_key(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_gather(self, grid, center_pos, radius):\n        rng = int(radius // self.grid_cell) + 1\n        key = self._grid_key(center_pos)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    b = grid.get(k)\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        b = grid.get(k)\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        # expand a few rings; fallback scan if needed\n        best = None\n        bestd = float('inf')\n        for rng in range(1, 5):\n            cand = self._grid_gather(grid, pos, rng * self.grid_cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                return best\n        # fallback\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_grid(self, grid, pos, radius):\n        cand = self._grid_gather(grid, pos, radius)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                di = (n.position[i] - pos[i])\n                d += di * di\n            if d <= r2:\n                out.append(n)\n        return out\n\n    # ------------- Path utilities -------------\n    def _propagate_costs_from(self, node):\n        stack = []\n        for c in node.children:\n            stack.append(c)\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                stack.append(c)\n\n    def _path_to_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        path.reverse()\n        return path\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        # meet_b belongs to opposite tree whose root is goal; climb to its root\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut_once(self, path, obstacles, is_3d):\n        n = len(path)\n        if n < 3:\n            return path\n        i = int(self._uniform(0, n - 2))\n        j = int(self._uniform(i + 1, n - 1))\n        if j <= i + 1:\n            return path\n        a = path[i]\n        b = path[j]\n        if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n            return path[:i + 1] + path[j:]\n        return path\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            new_pts = self._shortcut_once(pts, obstacles, is_3d)\n            if len(new_pts) == len(pts):\n                # try small local smoothing by greedily removing a middle point\n                k = int(self._uniform(1, max(2, len(pts) - 1)))\n                i = k - 1\n                j = k + 1 if k + 1 < len(pts) else k\n                if j < len(pts) and i >= 0 and j > i and not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d, self.edge_res):\n                    pts = pts[:i + 1] + pts[j:]\n            else:\n                pts = new_pts\n            if len(pts) < 3:\n                break\n        return pts",
                "objective": 903.65932,
                "time_improvement": -3080.0,
                "length_improvement": 24.0,
                "smoothness_improvement": 1125.0,
                "node_improvement": -60.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 1.9191562414169312,
                        "num_nodes_avg": 1078.5,
                        "path_length_avg": 144.84467816258504,
                        "smoothness_avg": 0.04086584566813316,
                        "success_improvement": 0.0,
                        "time_improvement": -7426.4584192382035,
                        "node_improvement": -171.59405691261645,
                        "length_improvement": 20.60833668828437,
                        "smoothness_improvement": 539.6392263105108,
                        "objective_score": -2212.8743276269374
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.919565224647522,
                        "num_nodes_avg": 1254.0,
                        "path_length_avg": 217.8194732486166,
                        "smoothness_avg": 0.07114963536651986,
                        "success_improvement": 0.0,
                        "time_improvement": -474.02032068577586,
                        "node_improvement": 15.742793791574277,
                        "length_improvement": 27.285590243700952,
                        "smoothness_improvement": 1730.7313649914906,
                        "objective_score": -117.18108523455474
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.7055335283279419,
                        "num_nodes_avg": 971.1,
                        "path_length_avg": 112.77685375486826,
                        "smoothness_avg": 0.09469551316670241,
                        "success_improvement": 0.0,
                        "time_improvement": -1338.3484294307068,
                        "node_improvement": -23.47107438016529,
                        "length_improvement": 25.098983592702577,
                        "smoothness_improvement": 1104.519937784749,
                        "objective_score": -380.92253898466674
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
                "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -20.90414805532173,
                "time_improvement": 74.0,
                "length_improvement": -3.0,
                "smoothness_improvement": 81.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.009906005859375,
                        "num_nodes_avg": 119.0,
                        "path_length_avg": 191.04302473496983,
                        "smoothness_avg": 0.011270904212760589,
                        "success_improvement": 0.0,
                        "time_improvement": 61.15108317274382,
                        "node_improvement": 70.03273734575673,
                        "length_improvement": -4.713709127687822,
                        "smoothness_improvement": 76.41412608993974,
                        "objective_score": 15.899170105660149
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.018079090118408202,
                        "num_nodes_avg": 263.8,
                        "path_length_avg": 304.060897710979,
                        "smoothness_avg": 0.007193047909992605,
                        "success_improvement": 0.0,
                        "time_improvement": 88.71448720621899,
                        "node_improvement": 82.2750789491366,
                        "length_improvement": -1.5042795636027118,
                        "smoothness_improvement": 85.08230366710401,
                        "objective_score": 26.13718994203959
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.013434433937072754,
                        "num_nodes_avg": 198.2,
                        "path_length_avg": 154.3877135428638,
                        "smoothness_avg": 0.014383244909940574,
                        "success_improvement": 0.0,
                        "time_improvement": 72.61165319885777,
                        "node_improvement": 74.79974570883661,
                        "length_improvement": -2.536968182267624,
                        "smoothness_improvement": 82.95381359374001,
                        "objective_score": 20.676084118265454
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "Adaptive Goal-Biased Grid BiRRT (AG-GBiRRT): a simplified, robust bidirectional RRT with commit-only connection, grid-accelerated nearest search, and light post-connection shortcut smoothing. It alternates growing two trees, uses uniform-with-goal-bias sampling, single-step steering with strict node/edge collision checks, and an early straight-line test. Upon any successful bridge between trees, it extracts the path and performs a few inexpensive shortcuts for smoothness, returning quickly without extra rewiring or bloat.",
            "planning_mechanism": "Mechanism: alternate start/goal tree expansion; sample (goal-biased), find nearest via grid, steer one step, validate node and edge, add node and edge, attempt a direct, collision-free bridge to the opposite tree (commit-only); on success, extract [start\u2192\u2026\u2192meetA, meetB\u2192\u2026\u2192goal] and run brief shortcut smoothing; terminate on success or iteration budget.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.0)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                continue\n\n            # Insert node (both node and edge validated)\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Try commit-only direct connection to the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None:\n                if not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, other_near)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        try:\n            return self._lcg_next()\n        except:\n            return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Sampling ----------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ---------- Grid nearest ----------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # ---------- Path ----------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # path_a ends at meet_a; we then go straight to meet_b and up to other root\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            # pick two indices i < j with at least one point between\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
            "objective": -32.96764,
            "time_improvement": 69.0,
            "length_improvement": 11.0,
            "smoothness_improvement": 1142.0,
            "node_improvement": 82.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01299290657043457,
                    "num_nodes_avg": 78.8,
                    "path_length_avg": 167.86786188508313,
                    "smoothness_avg": 0.03825680999831742,
                    "success_improvement": 0.0,
                    "time_improvement": 49.04501835909778,
                    "node_improvement": 80.15613195668597,
                    "length_improvement": 7.988964864290817,
                    "smoothness_improvement": 498.8021524662562,
                    "objective_score": 22.000895188635106
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02625594139099121,
                    "num_nodes_avg": 208.9,
                    "path_length_avg": 244.3021244779086,
                    "smoothness_avg": 0.07331771296729457,
                    "success_improvement": 0.0,
                    "time_improvement": 83.61025026480232,
                    "node_improvement": 85.96385137405093,
                    "length_improvement": 18.444919002512343,
                    "smoothness_improvement": 1786.5175632625994,
                    "objective_score": 45.082614297261095
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01305999755859375,
                    "num_nodes_avg": 163.0,
                    "path_length_avg": 140.27860161008172,
                    "smoothness_avg": 0.09759083301298958,
                    "success_improvement": 0.0,
                    "time_improvement": 73.37500455677744,
                    "node_improvement": 79.27527018436109,
                    "length_improvement": 6.833632159773637,
                    "smoothness_improvement": 1141.348192519241,
                    "objective_score": 31.819421625493614
                }
            ],
            "success_rate": 1.0
        },
        "objective": 11.8,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Incremental cross-tree connections created ladder-like joins or failed to use the actual straight bridge in the final path, inflating total length.\n   - Missing or insufficient post-processing left zig-zag segments and redundant waypoints unpruned.\n   - Rigid node-spacing or conservative insertion rules prevented short corrective connectors near corners/obstacles, blocking corner-cutting.\n   - Coarse, fixed step expansions without local shortcutting produced jagged trajectories.\n   - Suboptimal nearest/parent choices from coarse locality search or early ring exits introduced detours before connection.\n   - Weak or absent goal/target bias delayed direct progress toward the meeting region, increasing path bends."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Commit-only, straight-line cross-tree connection upon collision-free check, avoiding stepwise ladder joins.\n   - Early straight-line test that immediately returns the optimal two-point path when feasible.\n   - Moderate goal/opposite-root bias to drive trees toward each other and reduce pre-connection detours.\n   - Grid-accelerated nearest lookup for more local parent selection.\n   - Lightweight shortcut smoothing on the extracted path to prune redundant vertices and remove zig-zags.\n   - Allowing short connectors (no strict minimum-separation constraint) to cut corners near obstacles.\n2. Expected mechanism of impact:\n   - Direct bridging and early straight-line detection replace long, incremental joins with a single minimal-length segment.\n   - Sampling bias and local nearest selection align expansions toward the straight line between roots, reducing unnecessary bends before meeting.\n   - Shortcut smoothing collapses polyline kinks into fewer, longer segments, shortening the total path.\n   - Permitting short corrective steps enables corner-cutting near obstacles, further reducing overall length."
        }
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "Fast Informed BiRRT*-Connect (FIBRC-Lite): a time-focused bidirectional planner that mixes cheap RRT-Connect growth with light RRT* improvements and informed sampling. It accelerates nearest/near queries with a fine spatial hash, selects best parents within a small adaptive neighborhood, performs capped local rewires, and attempts short greedy bridges to the opposite tree. Upon first feasible join it extracts and quickly shortens the path with bounded shortcutting and a final line-of-sight collapse, returning early to minimize compute.",
                "planning_mechanism": "Alternate expanding start/goal trees; sample with goal and informed biases; find nearest via grid; steer once; validate node and edge; choose best parent among near neighbors; insert and perform small-budget rewires; try greedy connect to the other tree (few steps); if join succeeds, extract [start\u2192...\u2192A, B\u2192...\u2192goal], run bounded shortcut smoothing and return; otherwise loop up to iteration budget.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=6.0,\n                 goal_bias=0.25,\n                 informed_bias=0.6,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=60,\n                 rewire_budget=6,\n                 connect_steps=8,\n                 min_sep_ratio=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.informed_bias = informed_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.rewire_budget = rewire_budget\n        self.connect_steps = connect_steps\n        self.min_sep_ratio = min_sep_ratio\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size)\n        self.edge_res = max(0.5, min(self.collision_step, self.step_size * 0.5))\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._is_edge_in_obstacle(self.start, self.goal, obstacles, is_3d, self.edge_res):\n            path = [self.start, self.goal]\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, path, nodes, [])\n\n        # Initialize trees, grids, edges\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes_all = [start_root, goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Best-so-far path length for informed sampling\n        c_best = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = self.goal if active_start else self.start\n\n            # Sampling with goal bias and informed bias (if an incumbent path exists)\n            r = self._rand()\n            if c_best < float('inf') and r < self.informed_bias:\n                x_rand = self._sample_informed(c_best, obstacles, is_3d)\n            elif r < self.informed_bias + self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                continue\n\n            # Best-parent selection in a compact neighborhood\n            r_near = self._neighbor_radius(len(tree_a))\n            candidates = self._nearby_nodes(grid_a, tree_a, new_pos, r_near)\n            best_parent = None\n            best_cost = float('inf')\n            for q in candidates:\n                edge_len = self._dist(q.position, new_pos)\n                cand_cost = q.cost + edge_len\n                if cand_cost < best_cost:\n                    if not self._is_edge_in_obstacle(q.position, new_pos, obstacles, is_3d, self.edge_res):\n                        best_cost = cand_cost\n                        best_parent = q\n            if best_parent is None:\n                best_parent = nearest\n                best_cost = nearest.cost + self._dist(nearest.position, new_pos)\n\n            # Insert node (both node and parent->child edge validated)\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes_all.append(new_node)\n            self._edges_add(edges, best_parent, new_node)\n            self._grid_add(grid_a, new_node)\n\n            # Limited rewiring to improve local path quality\n            rewired = 0\n            for q in candidates:\n                if rewired >= self.rewire_budget or q is best_parent or q is new_node:\n                    continue\n                alt_cost = new_node.cost + self._dist(new_node.position, q.position)\n                if alt_cost + 1e-9 < q.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, q.position, obstacles, is_3d, self.edge_res):\n                        old_parent = q.parent\n                        if old_parent is not None:\n                            old_parent.remove_child(q)\n                            self._edges_remove(edges, old_parent, q)\n                        new_node.add_child(q)\n                        cost_delta = alt_cost - q.cost\n                        q.cost = alt_cost\n                        self._edges_add(edges, new_node, q)\n                        self._propagate_cost_from(q, cost_delta)\n                        rewired += 1\n\n            # Try commit-only direct connection to the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None and not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                path = self._extract_path(new_node, other_near)\n                c_best = self._path_length(path)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Greedy short connect from the other tree toward new_node\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if self._dist(p.position, to_pos) < self.step_size * self.min_sep_ratio:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(p.position, to_pos, obstacles, is_3d, self.edge_res):\n                    break\n                # Attach greedily to p (node and edge validated)\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                nodes_all.append(q)\n                self._edges_add(edges, p, q)\n                self._grid_add(grid_b, q)\n                p = q\n                steps += 1\n\n                # Check if we can bridge now\n                if not self._is_edge_in_obstacle(new_node.position, p.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, p)\n                    c_best = self._path_length(path)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Sampling ----------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_informed(self, c_best, obstacles, is_3d):\n        # Axis-aligned bounding box enclosing start-goal with margin proportional to current best\n        dsg = self._dist(self.start, self.goal)\n        margin = max(0.0, (c_best - dsg)) * 0.5 + self.step_size\n        low = []\n        high = []\n        for i in range(self.dim):\n            a = self.start[i]\n            b = self.goal[i]\n            lo = min(a, b) - margin\n            hi = max(a, b) + margin\n            lo = 0.0 if lo < 0.0 else lo\n            hi = self.bounds[i] if hi > self.bounds[i] else hi\n            low.append(lo)\n            high.append(hi)\n        # Rejection sample inside the AABB\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(low[0], high[0]),\n                     self._uniform(low[1], high[1]),\n                     self._uniform(low[2], high[2]))\n            else:\n                p = (self._uniform(low[0], high[0]),\n                     self._uniform(low[1], high[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ---------- Grid and neighbor queries ----------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # expand rings until at least one candidate found or capped radius\n        for r in range(0, 5):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _nearby_nodes(self, grid, tree, pos, radius):\n        key = self._grid_key(pos)\n        # Convert radius to grid cells (ceil approx)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        res = []\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                res.append(n)\n        if not res:\n            # ensure at least nearest is considered\n            res = [self._nearest_grid(grid, tree, pos)]\n        return res\n\n    def _neighbor_radius(self, n_nodes):\n        # Compact adaptive radius in [1.5, 3.0] * step_size shrinking with growth\n        base = 3.0 * self.step_size / (1.0 + 0.01 * max(1, n_nodes))\n        r = base if base > 1.5 * self.step_size else 1.5 * self.step_size\n        if r > 3.0 * self.step_size:\n            r = 3.0 * self.step_size\n        return r\n\n    # ---------- Edges and costs ----------\n    def _edges_add(self, edges, parent, child):\n        edges.append((parent, child))\n\n    def _edges_remove(self, edges, parent, child):\n        # remove first occurrence\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_cost_from(self, node, delta):\n        if delta == 0.0:\n            return\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    # ---------- Path ----------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)  # start -> ... -> meet_a (or goal side if swapped)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # path_a already ends at meet_a; append meet_b->...->root_other\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        nstall = 0\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n                nstall = 0\n            else:\n                nstall += 1\n                if nstall > 12:\n                    break\n        # Final pass: line-of-sight collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            for k in range(1, len(pts) - 1):\n                nxt = pts[k + 1]\n                if not self._is_edge_in_obstacle(last, nxt, obstacles, is_3d, self.edge_res):\n                    continue\n                else:\n                    collapsed.append(pts[k])\n                    last = pts[k]\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
                "objective": 54.38004,
                "time_improvement": -43.0,
                "length_improvement": 14.0,
                "smoothness_improvement": 3325.0,
                "node_improvement": 81.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.0447272777557373,
                        "num_nodes_avg": 62.9,
                        "path_length_avg": 172.72321740556453,
                        "smoothness_avg": 0.04175474386966843,
                        "success_improvement": 0.0,
                        "time_improvement": -75.40937468735302,
                        "node_improvement": 84.16016116847143,
                        "length_improvement": 5.32766756548325,
                        "smoothness_improvement": 553.5524134378776,
                        "objective_score": -16.65844979972657
                    },
                    {
                        "map_id": 1,
                        "success_rate": 0.9,
                        "time_avg": 0.13959274291992188,
                        "num_nodes_avg": 188.6,
                        "path_length_avg": 237.8767141690268,
                        "smoothness_avg": 0.18878187016499196,
                        "success_improvement": -9.999999999999998,
                        "time_improvement": 12.862003794222588,
                        "node_improvement": 87.32782369146005,
                        "length_improvement": 20.589905908798265,
                        "smoothness_improvement": 4757.493493430209,
                        "objective_score": -9.99998784930321
                    },
                    {
                        "map_id": 2,
                        "success_rate": 0.7,
                        "time_avg": 0.0813495397567749,
                        "num_nodes_avg": 220.3,
                        "path_length_avg": 125.59197842186634,
                        "smoothness_avg": 0.37451567120397955,
                        "success_improvement": -30.000000000000004,
                        "time_improvement": -65.84468072179355,
                        "node_improvement": 71.98982835346473,
                        "length_improvement": 16.587787979542895,
                        "smoothness_improvement": 4663.811693843319,
                        "objective_score": -136.48167295959576
                    }
                ],
                "success_rate": 0.8666666666666666
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "Adaptive Beam BiRRT-Connect (AB-Connect): a lean, time-focused bidirectional planner that alternates single-step tree growth with a tiny beam of candidate samples. It uses a fine spatial hash for fast nearest queries, corridor-guided sampling around the start\u2013goal line to reduce rejection, and on-the-fly path compression to limit node bloat. A short greedy connect attempts to bridge trees early; upon success, a bounded shortcut pass cleans the path and returns immediately. By avoiding rewiring and heavy optimization while enforcing strict node/edge collision checks, AB-Connect minimizes per-iteration cost and achieves fast solutions.",
            "planning_mechanism": "Mechanism: Initialize two trees at start/goal. Each iteration (alternating trees), generate a small beam of candidate samples (goal/corridor/uniform), steer once from the nearest node, validate node and edge, discard near-duplicates, and keep the candidate that best reduces distance to the opposite tree. Insert it, attempt on-the-fly grandparent line-of-sight compression, then try a direct or short greedy connect toward the other tree. If bridged, extract the path and run bounded shortcut smoothing; else continue until the iteration budget is reached.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=8.0,\n                 goal_bias=0.18,\n                 corridor_bias=0.5,\n                 beam_k=2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=28,\n                 connect_steps=6,\n                 min_sep_ratio=0.25,\n                 dupe_radius_ratio=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.connect_steps = connect_steps\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n\n    # ---------------- Planning ----------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Setup grid resolution and collision sampling\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.6 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.4)))\n\n        # Validate start/goal and early LOS\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        if not self._is_edge_in_obstacle(self.start, self.goal, obstacles, is_3d, self.edge_res):\n            path = [self.start, self.goal]\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, path, nodes, [])\n\n        # Initialize structures\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Corridor parameters\n        dsg = self._dist(self.start, self.goal)\n        c_best = float('inf')\n        base_corridor = max(self.step_size, 0.15 * dsg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = self.goal if active_start else self.start\n\n            # Beam of candidates; keep the one that best reduces distance to the other tree\n            best_cand = None\n            best_score = float('inf')\n            other_near_hint = None\n\n            for _ in range(self.beam_k):\n                # Sampling policy: goal-biased, corridor-guided, or uniform\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = base_corridor\n                    if c_best < float('inf'):\n                        width = max(self.step_size, 0.25 * (c_best - dsg) + base_corridor)\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                    continue\n\n                # Score: distance to nearest node in the other tree after this move\n                if other_near_hint is None:\n                    other_near_hint = self._nearest_grid(grid_b, tree_b, new_pos)\n                else:\n                    # refresh if new_pos is far from hint\n                    if self._dist(other_near_hint.position, new_pos) > 2.5 * self.step_size:\n                        other_near_hint = self._nearest_grid(grid_b, tree_b, new_pos)\n                if other_near_hint is None:\n                    score = self._dist(new_pos, root_other)\n                else:\n                    score = self._dist(new_pos, other_near_hint.position)\n                if score < best_score:\n                    best_score = score\n                    best_cand = (nearest, new_pos)\n\n            if best_cand is None:\n                continue\n\n            parent_node, new_pos = best_cand\n\n            # Insert node and edge (validated already)\n            new_cost = parent_node.cost + self._dist(parent_node.position, new_pos)\n            new_node = Node(new_pos, parent=parent_node, cost=new_cost)\n            parent_node.add_child(new_node)\n            tree_a.append(new_node)\n            self._edges_add(edges, parent_node, new_node)\n            self._grid_add(grid_a, new_node)\n\n            # On-the-fly grandparent compression\n            gp = parent_node.parent\n            if gp is not None:\n                # If LOS from grandparent to new_node, bypass parent to reduce nodes and cost\n                if not self._is_edge_in_obstacle(gp.position, new_node.position, obstacles, is_3d, self.edge_res):\n                    # Update edges/children coherently\n                    parent_node.remove_child(new_node)\n                    self._edges_remove(edges, parent_node, new_node)\n                    gp.add_child(new_node)\n                    self._edges_add(edges, gp, new_node)\n                    # Update cost\n                    new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n\n            # Try direct bridge to the nearest node in the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None and not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                path = self._extract_path(new_node, other_near)\n                c_best = self._path_length(path)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Short greedy connect toward new_node from the other tree\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if self._dist(p.position, to_pos) < self.step_size * self.min_sep_ratio:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(p.position, to_pos, obstacles, is_3d, self.edge_res):\n                    break\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                self._edges_add(edges, p, q)\n                self._grid_add(grid_b, q)\n                p = q\n                steps += 1\n\n                # Check bridge now\n                if not self._is_edge_in_obstacle(new_node.position, p.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, p)\n                    c_best = self._path_length(path)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------------- RNG ----------------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------------- Geometry ----------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------------- Collision ----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------------- Sampling ----------------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        # Sample around the start-goal line with axis-aligned jitter (cheap \"corridor\")\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        # Fallback to uniform if corridor sample is invalid\n        return self._sample_free(obstacles, is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---------------- Grid and neighbors ----------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Expand rings up to modest radius; fallback linear scan if needed\n        for r in range(0, 5):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan (rare with fine grid)\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # ---------------- Edges and costs ----------------\n    def _edges_add(self, edges, parent, child):\n        edges.append((parent, child))\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # ---------------- Paths ----------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        # Path A: root_A -> meet_a\n        path_a = self._path_to_root(meet_a)\n        # Path B: meet_b -> root_B (following parent links)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # Concatenate, implying a straight edge between meet_a and meet_b (validated before)\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        # Final LOS collapse forward\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            for k in range(1, len(pts) - 1):\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d, self.edge_res):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
            "objective": -20.0019,
            "time_improvement": 15.0,
            "length_improvement": 12.0,
            "smoothness_improvement": 1665.0,
            "node_improvement": 85.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022508907318115234,
                    "num_nodes_avg": 61.9,
                    "path_length_avg": 173.37195960178056,
                    "smoothness_avg": 0.04856882636983518,
                    "success_improvement": 0.0,
                    "time_improvement": 11.725605588421473,
                    "node_improvement": 84.41198690506171,
                    "length_improvement": 4.972081687759297,
                    "smoothness_improvement": 660.2076015824708,
                    "objective_score": 9.801968697094374
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04350669384002685,
                    "num_nodes_avg": 122.6,
                    "path_length_avg": 245.93388702328062,
                    "smoothness_avg": 0.11098748565610625,
                    "success_improvement": 0.0,
                    "time_improvement": 72.84181080292292,
                    "node_improvement": 91.76241349190352,
                    "length_improvement": 17.900189697186487,
                    "smoothness_improvement": 2755.78794698629,
                    "objective_score": 46.371596794120215
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06773929595947266,
                    "num_nodes_avg": 163.7,
                    "path_length_avg": 132.06627662911285,
                    "smoothness_avg": 0.13189994478614067,
                    "success_improvement": 0.0,
                    "time_improvement": -38.09791603378091,
                    "node_improvement": 79.18626827717736,
                    "length_improvement": 12.287867383240805,
                    "smoothness_improvement": 1577.7575618385185,
                    "objective_score": 3.832133429002802
                }
            ],
            "success_rate": 1.0
        },
        "objective": 7.999999999999999,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Greedy early bridging and immediate return without adequate cost-aware refinement, yielding detouring connections and longer paths\n   - Overly aggressive endpoint/informed sampling that traps search in suboptimal homotopies and produces jagged connect chains\n   - Imprecise neighbor selection from coarse spatial hashing and lack of duplicate suppression, leading to zig\u2011zag waypoints before smoothing\n   - Inconsistent or limited local optimization (restricted neighborhood/rewire) that fails to shorten segments once a feasible route is found"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Corridor-guided sampling combined with a small beam of candidates, selecting the move that best approaches the opposite tree\n   - Duplicate-node suppression to prevent redundant, closely spaced inserts that inflate path length\n   - On\u2011the\u2011fly grandparent line\u2011of\u2011sight compression to remove unnecessary intermediate waypoints during growth\n   - Finer nearest-neighbor grid tuning and a shorter greedy connect budget to avoid overextended, curvy bridges\n   - Bounded shortcutting with a final line\u2011of\u2011sight collapse on the extracted path\n2. Expected mechanism of impact:\n   - Concentrating samples near the start\u2013goal corridor and choosing the most progress\u2011efficient candidate reduces lateral wandering, producing straighter connections\n   - Removing near-duplicate nodes and compressing via line\u2011of\u2011sight lowers waypoint count and cumulative segment length\n   - More accurate nearest selection and restrained connect steps prevent non-minimal detours at the bridge\n   - Post-extraction shortcutting eliminates residual bends, further shortening the final path"
        }
    },
    {
        "parents": [
            {
                "operator": "m2",
                "algorithm_description": "UniGrid Informed RRT*-Fast (UG-IRRT*-F): a single-tree, cost-optimal planner that uses a uniform spatial hash for O(1)-average neighbor queries, \u03b3(log n/n)^(1/d) adaptive neighborhoods, informed ellipsoidal sampling after the first solution, duplicate-node suppression, lazy rewires with incremental cost push, and goal-side best-parent connection; it continues optimizing under a focused post-optimization budget and returns a compressed, shortcut-smoothed path.",
                "planning_mechanism": "At each iteration, sample (goal/line/ellipse-biased), steer one step from the nearest node, validate node and edge, choose the lowest-cost valid parent within an adaptive radius, add the node, and lazily rewire cheaper neighbors. If close to the goal, select the best-cost valid parent for the goal among nearby nodes and update the incumbent path. After finding a solution, restrict sampling to the informed set and terminate on a time/no-improvement budget, then compress and shortcut the path.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4200,\n                 step_size=5.0,\n                 gamma_radius=55.0,\n                 min_radius_factor=1.0,\n                 goal_bias=0.12,\n                 line_bias=0.38,\n                 connect_factor=2.0,\n                 near_cap=64,\n                 post_opt_iters=450,\n                 max_no_improve=180,\n                 smoothing_iters=160):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_radius = gamma_radius\n        self.min_radius_factor = min_radius_factor\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_factor = connect_factor\n        self.near_cap = near_cap\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        root = Node(start, None, 0.0)\n        nodes = [root]\n\n        # spatial hash grid\n        cell = max(1.0, 0.8 * self.step_size)\n        grid = {}\n        self._grid_add(grid, root, cell)\n\n        # coarse occupancy to suppress duplicates\n        occ_cell = max(0.5, 0.6 * self.step_size)\n        occ = {self._occ_key(start, occ_cell): True}\n\n        success = False\n        best_cost = float('inf')\n        goal_node = None\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            # sample\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                x_rand = self._sample_biased(start, goal, best_cost)\n\n            # nearest\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n            # bounds and node collision\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # duplicate suppression\n            k_occ = self._occ_key(x_new_pos, occ_cell)\n            if k_occ in occ:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # incoming edge collision\n            if self._is_edge_in_obstacle(n_near.position, x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # choose best parent within adaptive radius\n            r_near = self._rrtstar_radius(max(2, len(nodes)))\n            near_nodes = self._near(grid, x_new_pos, r_near, cell)\n            if near_nodes:\n                near_nodes = self._limit_by_distance(near_nodes, x_new_pos, self.near_cap)\n            best_parent = n_near\n            best_pc = n_near.cost + self._dist(n_near.position, x_new_pos)\n            for nn in near_nodes:\n                if nn is n_near:\n                    continue\n                c = nn.cost + self._dist(nn.position, x_new_pos)\n                if c + 1e-12 < best_pc:\n                    if not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d):\n                        best_pc = c\n                        best_parent = nn\n\n            # commit new node (both checks were done above for chosen parent)\n            x_new = Node(x_new_pos, None, best_pc)\n            x_new.attach(best_parent)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            occ[k_occ] = True\n\n            # rewire nearby nodes\n            for nn in near_nodes:\n                if nn is best_parent or nn is x_new:\n                    continue\n                alt = x_new.cost + self._dist(x_new.position, nn.position)\n                if alt + 1e-12 < nn.cost:\n                    if not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d):\n                        nn.attach(x_new)\n                        self._propagate_costs_from(nn)\n\n            # goal-side best-parent connection when close\n            improved = False\n            r_conn = max(r_near, self.connect_factor * self.step_size)\n            if self._dist(x_new.position, goal) <= r_conn:\n                if not self._is_in_obstacle(goal, obstacles, is_3d):\n                    # consider best parent among nodes near goal (including x_new)\n                    cand = self._near(grid, goal, r_conn, cell)\n                    if x_new not in cand:\n                        cand.append(x_new)\n                    best_parent_goal = None\n                    best_goal_cost = best_cost\n                    for p in cand:\n                        if not self._is_edge_in_obstacle(p.position, goal, obstacles, is_3d):\n                            ctot = p.cost + self._dist(p.position, goal)\n                            if ctot + 1e-12 < best_goal_cost:\n                                best_goal_cost = ctot\n                                best_parent_goal = p\n                    if best_parent_goal is not None:\n                        if goal_node is None:\n                            goal_node = Node(goal, None, best_goal_cost)\n                            goal_node.attach(best_parent_goal)\n                            nodes.append(goal_node)\n                        else:\n                            goal_node.cost = best_goal_cost\n                            goal_node.attach(best_parent_goal)\n                        best_cost = best_goal_cost\n                        success = True\n                        found_first = True\n                        improved = True\n                        post_iters = 0\n                        no_improve = 0\n\n            if found_first and not improved:\n                post_iters += 1\n                no_improve += 1\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        path = []\n        if success and goal_node is not None:\n            # extract\n            cur = goal_node\n            while cur is not None:\n                path.append(cur.position)\n                cur = cur.parent\n            path.reverse()\n            # postprocess\n            path = self._compress(path, obstacles, is_3d)\n            path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n\n        # build edges from parent pointers\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---------- Utilities ----------\n    def _rand(self):\n        try:\n            return self._lcg_next()\n        except:\n            return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 1103515245\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    def _rrtstar_radius(self, n):\n        r = self.gamma_radius\n        if n > 2:\n            expo = 1.0 / float(max(2, self.dim))\n            r = self.gamma_radius * ((self._log_approx(n) / float(n)) ** expo)\n        rmin = max(self.min_radius_factor * self.step_size, 1e-6)\n        if r < rmin:\n            r = rmin\n        return r\n\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        # exponential expansion until candidates appear\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        max_span = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > max_span:\n                max_span = self.bounds[i]\n        limit = max_span * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # fallback linear scan\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _limit_by_distance(self, nodes, center, k):\n        # partial selection of up to k nearest without full sort when large\n        if len(nodes) <= k:\n            return nodes\n        # simple reservoir based on distance threshold\n        # compute distances\n        idx = []\n        for i, n in enumerate(nodes):\n            idx.append((self._dist(n.position, center), i))\n        # partial selection: nth-element by repeated scanning (k small)\n        # choose k smallest by single pass selection\n        # fallback: simple sort when moderate\n        if len(nodes) <= 4 * k:\n            idx.sort(key=lambda t: t[0])\n            sel = [nodes[t[1]] for t in idx[:k]]\n            return sel\n        # approximate: pick k minima by iterative pass\n        sel = []\n        used = [False] * len(nodes)\n        for _ in range(k):\n            best = -1\n            bestd = float('inf')\n            for j, (d, i) in enumerate(idx):\n                if not used[j] and d < bestd:\n                    bestd = d\n                    best = j\n            if best == -1:\n                break\n            used[best] = True\n            sel.append(nodes[idx[best][1]])\n        return sel\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _sample_biased(self, start, goal, c_best):\n        # informed ellipsoidal rejection after first solution; else line/uniform mix\n        if c_best < float('inf'):\n            for _ in range(20):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._dist(p, start) + self._dist(p, goal) <= c_best and self._in_bounds(p):\n                    return p\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jitter = 0.5 * self.step_size\n            p = tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n            return p\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _propagate_costs_from(self, node):\n        stack = []\n        for c in node.children:\n            stack.append(c)\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                stack.append(c)\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
                "objective": -3.65664,
                "time_improvement": -50.0,
                "length_improvement": 19.0,
                "smoothness_improvement": 1436.0,
                "node_improvement": 46.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.06231374740600586,
                        "num_nodes_avg": 244.5,
                        "path_length_avg": 159.99708988452147,
                        "smoothness_avg": 0.04079917273665813,
                        "success_improvement": 0.0,
                        "time_improvement": -144.3791801192523,
                        "node_improvement": 38.42860740367666,
                        "length_improvement": 12.303059718162231,
                        "smoothness_improvement": 538.5956501503387,
                        "objective_score": -33.238939954126664
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.11423308849334717,
                        "num_nodes_avg": 663.4,
                        "path_length_avg": 229.07326285952672,
                        "smoothness_avg": 0.10084089211799352,
                        "success_improvement": 0.0,
                        "time_improvement": 28.69226420016899,
                        "node_improvement": 55.42565343008802,
                        "length_improvement": 23.528751349205564,
                        "smoothness_improvement": 2494.7087869547277,
                        "objective_score": 35.19847400434767
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.06615550518035888,
                        "num_nodes_avg": 438.5,
                        "path_length_avg": 117.70760748606574,
                        "smoothness_avg": 0.108123212990666,
                        "success_improvement": 0.0,
                        "time_improvement": -34.86909289750288,
                        "node_improvement": 44.24666242848061,
                        "length_improvement": 21.824211741702758,
                        "smoothness_improvement": 1275.3192884158632,
                        "objective_score": 9.010395617850108
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "path_expert",
            "algorithm_description": "HF-IRRT#-OS: Heuristic-Filtered Informed RRT# with Online Shortcuts \u2014 a single-tree, cost-optimal planner that uses grid-accelerated neighbors, admissible cost+heuristic pruning, correct-cost rewiring with queued propagation, per-cell best-cost duplicate suppression, aggressive informed sampling after the first solution, and incremental shortcutting to continuously reduce path length.",
            "planning_mechanism": "At each iteration, sample (goal/line/ellipse-biased), steer a bounded step, validate node and edge, select the lowest-cost valid parent within an adaptive radius, commit the node, and rewire cheaper neighbors with proper subtree cost updates. When near the goal, connect via the best valid parent to update the incumbent path. After any improvement, perform bounded shortcuts on the current best path to tighten c_best and focus the informed set. Terminate on post-optimization or no-improvement budgets and return a compressed, smoothed path.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=4.0,\n                 gamma_radius=60.0,\n                 min_radius_factor=1.0,\n                 goal_bias=0.15,\n                 line_bias=0.35,\n                 connect_radius_factor=2.5,\n                 near_cap=72,\n                 post_opt_iters=600,\n                 max_no_improve=240,\n                 smoothing_iters=220,\n                 ellipse_tries=220,\n                 occ_gain_ratio=0.985,\n                 prune_margin=1.0005,\n                 online_shortcuts_per_improve=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_radius = gamma_radius\n        self.min_radius_factor = min_radius_factor\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_radius_factor = connect_radius_factor\n        self.near_cap = near_cap\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.ellipse_tries = ellipse_tries\n        self.occ_gain_ratio = occ_gain_ratio\n        self.prune_margin = prune_margin\n        self.online_shortcuts_per_improve = online_shortcuts_per_improve\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Early feasibility: straight line\n        if self._in_bounds(start) and self._in_bounds(goal):\n            if (not self._is_in_obstacle(start, obstacles, is_3d)) and (not self._is_in_obstacle(goal, obstacles, is_3d)):\n                if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d):\n                    s = Node(start, None, 0.0)\n                    g = Node(goal, None, self._dist(start, goal))\n                    g.attach(s)\n                    nodes = [s, g]\n                    edges = [(s, g)]\n                    path = [start, goal]\n                    return PlannerResult(success=True, path=path, nodes=nodes, edges=edges)\n\n        # Initialize\n        root = Node(start, None, 0.0)\n        nodes = [root]\n\n        # Spatial hash grid for NN queries\n        cell = max(1.0, 0.8 * self.step_size)\n        grid = {}\n        self._grid_add(grid, root, cell)\n\n        # Per-cell best-cost ledger to suppress duplicates\n        occ_cell = max(0.5, 0.6 * self.step_size)\n        occ_best_cost = {self._occ_key(start, occ_cell): 0.0}\n\n        success = False\n        goal_node = None\n        best_cost = float('inf')\n        best_path_pts = None\n\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            # Sampling\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                x_rand = self._sample(start, goal, best_cost)\n\n            # Nearest\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n            # Bounds and node collision\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Parent selection within adaptive radius\n            r_near = self._rrtstar_radius(max(2, len(nodes)))\n            near_nodes = self._near(grid, x_new_pos, r_near, cell)\n            if near_nodes:\n                near_nodes = self._k_nearest_limit(near_nodes, x_new_pos, self.near_cap)\n            # Ensure nearest is considered\n            if n_near not in near_nodes:\n                near_nodes.append(n_near)\n\n            best_parent = None\n            best_pc = float('inf')\n\n            for nn in near_nodes:\n                base_cost = nn.cost + self._dist(nn.position, x_new_pos)\n                if base_cost + 1e-12 < best_pc:\n                    # Edge collision check for candidate parent\n                    if not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d):\n                        best_parent = nn\n                        best_pc = base_cost\n\n            if best_parent is None:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Duplicate suppression using per-cell best cost\n            k_occ = self._occ_key(x_new_pos, occ_cell)\n            prev_best = occ_best_cost.get(k_occ, float('inf'))\n            if best_pc >= prev_best * self.occ_gain_ratio:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Commit new node (both checks already validated for chosen parent)\n            x_new = Node(x_new_pos, None, best_pc)\n            x_new.attach(best_parent)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            if best_pc < prev_best:\n                occ_best_cost[k_occ] = best_pc\n\n            # Rewire neighbors with admissible pruning toward path-length improvement\n            for nn in near_nodes:\n                if nn is x_new or nn is best_parent:\n                    continue\n                alt = x_new.cost + self._dist(x_new.position, nn.position)\n                if alt + 1e-12 < nn.cost:\n                    # If we already have a solution, skip rewires that cannot possibly lead to improving it\n                    if best_cost < float('inf'):\n                        h = self._dist(nn.position, goal)\n                        if alt + h >= best_cost * self.prune_margin:\n                            continue\n                    if not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d):\n                        nn.attach(x_new)\n                        nn.cost = alt\n                        self._propagate_costs_from(nn)\n\n            # Try connecting to the goal using best available parent within connection range\n            improved = False\n            r_conn = max(r_near, self.connect_radius_factor * self.step_size)\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                cand = self._near(grid, goal, r_conn, cell)\n                if x_new not in cand:\n                    cand.append(x_new)\n                best_parent_goal = None\n                best_goal_cost = best_cost\n                for p in cand:\n                    ctot = p.cost + self._dist(p.position, goal)\n                    if ctot + 1e-12 < best_goal_cost:\n                        if not self._is_edge_in_obstacle(p.position, goal, obstacles, is_3d):\n                            best_goal_cost = ctot\n                            best_parent_goal = p\n                if best_parent_goal is not None:\n                    if goal_node is None:\n                        goal_node = Node(goal, None, best_goal_cost)\n                        goal_node.attach(best_parent_goal)\n                        nodes.append(goal_node)\n                    else:\n                        goal_node.attach(best_parent_goal)\n                        goal_node.cost = best_goal_cost\n                    best_cost = best_goal_cost\n                    success = True\n                    found_first = True\n                    improved = True\n\n            # After improvement, do bounded online shortcuts to tighten c_best and focus sampling\n            if improved and goal_node is not None:\n                cur_path = self._extract_path(goal_node)\n                cur_path = self._compress(cur_path, obstacles, is_3d)\n                cur_path = self._shortcuts(cur_path, obstacles, is_3d, self.online_shortcuts_per_improve)\n                path_len = self._path_length(cur_path)\n                if path_len + 1e-12 < best_cost:\n                    best_cost = path_len\n                best_path_pts = cur_path\n                post_iters = 0\n                no_improve = 0\n            else:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        # Build final path\n        path = []\n        if success and goal_node is not None:\n            if best_path_pts is None:\n                path = self._extract_path(goal_node)\n                path = self._compress(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n            else:\n                # Final polishing\n                path = self._shortcuts(best_path_pts, obstacles, is_3d, self.smoothing_iters)\n\n        # Build edges from parent pointers\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---------- Utilities ----------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        # 32-bit LCG (Numerical Recipes variant)\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _rrtstar_radius(self, n):\n        r = self.gamma_radius\n        if n > 2:\n            expo = 1.0 / float(max(2, self.dim))\n            r = self.gamma_radius * ((self._log_approx(n) / float(n)) ** expo)\n        rmin = max(self.min_radius_factor * self.step_size, 1e-6)\n        if r < rmin:\n            r = rmin\n        return r\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        # rough ln via bit_length\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    # Spatial hashing\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        # limit expansion\n        max_span = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > max_span:\n                max_span = self.bounds[i]\n        limit = max_span * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # fallback\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _k_nearest_limit(self, nodes, center, k):\n        if len(nodes) <= k:\n            return nodes\n        # partial selection without full sort when large\n        idx = []\n        for i, n in enumerate(nodes):\n            idx.append((self._dist(n.position, center), i))\n        if len(nodes) <= 4 * k:\n            idx.sort(key=lambda t: t[0])\n            return [nodes[t[1]] for t in idx[:k]]\n        # approximate selection\n        sel = []\n        used = [False] * len(nodes)\n        for _ in range(k):\n            best = -1\n            bestd = float('inf')\n            for j, (d, i) in enumerate(idx):\n                if not used[j] and d < bestd:\n                    bestd = d\n                    best = j\n            if best == -1:\n                break\n            used[best] = True\n            sel.append(nodes[idx[best][1]])\n        return sel\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _heuristic(self, a, b):\n        return self._dist(a, b)\n\n    def _sample(self, start, goal, c_best):\n        # Informed ellipsoidal rejection after first solution; else line/uniform mix\n        if c_best < float('inf'):\n            # accept points satisfying triangle inequality gate; try more to avoid fallback\n            tries = self.ellipse_tries\n            for _ in range(tries):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p):\n                    if self._dist(p, start) + self._dist(p, goal) <= c_best:\n                        return p\n        # Line-biased sampling with jitter\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jitter = 0.5 * self.step_size\n            p = tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n            return p\n        # Uniform\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _propagate_costs_from(self, node):\n        # node.cost already set correctly by caller\n        stack = []\n        for c in node.children:\n            stack.append(c)\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                newc = u.parent.cost + self._dist(u.parent.position, u.position)\n                if abs(newc - u.cost) > 1e-12:\n                    u.cost = newc\n            for c in u.children:\n                stack.append(c)\n\n    def _extract_path(self, goal_node):\n        seq = []\n        cur = goal_node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
            "objective": 26.9043,
            "time_improvement": -154.0,
            "length_improvement": 19.0,
            "smoothness_improvement": 1520.0,
            "node_improvement": 44.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.10562500953674317,
                    "num_nodes_avg": 293.8,
                    "path_length_avg": 154.45237735825782,
                    "smoothness_avg": 0.04984145985356507,
                    "success_improvement": 0.0,
                    "time_improvement": -314.23529004756443,
                    "node_improvement": 26.013598589775878,
                    "length_improvement": 15.34220451539984,
                    "smoothness_improvement": 680.1270791706859,
                    "objective_score": -81.66462890917599
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.2455054998397827,
                    "num_nodes_avg": 623.2,
                    "path_length_avg": 228.05708400641493,
                    "smoothness_avg": 0.10153044277454511,
                    "success_improvement": 0.0,
                    "time_improvement": -53.25193033715656,
                    "node_improvement": 58.1267217630854,
                    "length_improvement": 23.867981099460806,
                    "smoothness_improvement": 2512.4514220110627,
                    "objective_score": 10.90746666858483
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09506032466888428,
                    "num_nodes_avg": 407.5,
                    "path_length_avg": 122.10575352004132,
                    "smoothness_avg": 0.1154296410531563,
                    "success_improvement": 0.0,
                    "time_improvement": -93.79641533507504,
                    "node_improvement": 48.188175460902734,
                    "length_improvement": 18.903172563144594,
                    "smoothness_improvement": 1368.2565140663191,
                    "objective_score": -9.95573849230416
                }
            ],
            "success_rate": 1.0
        },
        "objective": 11.4,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inaccurate cost maintenance during rewiring, leaving subtree costs stale and degrading parent selection and goal attachments\n   - Coarse duplicate suppression that blocks densification along promising corridors, regardless of cost\n   - Limited informed sampling attempts that frequently fall back to uninformed choices\n   - Conservative goal-connection range that misses lower-cost final links\n   - Post-processing only at the end, with no online path tightening to guide subsequent sampling"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Correct cost updates on rewiring with proper subtree propagation\n   - Cost-aware duplicate filtering that prefers lower-cost entries within cells\n   - Stronger informed sampling persistence to stay inside the cost-ellipse\n   - Expanded goal-connection search to consider better final parents\n   - Incremental shortcutting after improvements to immediately reduce path cost and refocus sampling\n   - Finer step size and slightly larger neighbor sets for better parent quality\n2. Expected mechanism of impact:\n   - Accurate rewiring yields cheaper parents and cascades shorter subtrees, directly reducing path length\n   - Cost-aware suppression promotes densification in high-quality corridors, avoiding detours\n   - More persistent informed sampling increases the rate of finding shorter segments within the ellipse\n   - Wider connection range selects lower-cost terminal links, shortening the final segment\n   - Online shortcuts tighten the incumbent path early, shrinking the informed set and accelerating further length reductions\n   - Finer resolution captures smoother, shorter turns and improves candidate parent availability"
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "Adaptive Goal-Biased Grid BiRRT (AG-GBiRRT): a simplified, robust bidirectional RRT with commit-only connection, grid-accelerated nearest search, and light post-connection shortcut smoothing. It alternates growing two trees, uses uniform-with-goal-bias sampling, single-step steering with strict node/edge collision checks, and an early straight-line test. Upon any successful bridge between trees, it extracts the path and performs a few inexpensive shortcuts for smoothness, returning quickly without extra rewiring or bloat.",
                "planning_mechanism": "Mechanism: alternate start/goal tree expansion; sample (goal-biased), find nearest via grid, steer one step, validate node and edge, add node and edge, attempt a direct, collision-free bridge to the opposite tree (commit-only); on success, extract [start\u2192\u2026\u2192meetA, meetB\u2192\u2026\u2192goal] and run brief shortcut smoothing; terminate on success or iteration budget.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.0)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                continue\n\n            # Insert node (both node and edge validated)\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Try commit-only direct connection to the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None:\n                if not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, other_near)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        try:\n            return self._lcg_next()\n        except:\n            return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Sampling ----------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ---------- Grid nearest ----------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # ---------- Path ----------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # path_a ends at meet_a; we then go straight to meet_b and up to other root\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            # pick two indices i < j with at least one point between\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
                "objective": -32.96764,
                "time_improvement": 69.0,
                "length_improvement": 11.0,
                "smoothness_improvement": 1142.0,
                "node_improvement": 82.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.01299290657043457,
                        "num_nodes_avg": 78.8,
                        "path_length_avg": 167.86786188508313,
                        "smoothness_avg": 0.03825680999831742,
                        "success_improvement": 0.0,
                        "time_improvement": 49.04501835909778,
                        "node_improvement": 80.15613195668597,
                        "length_improvement": 7.988964864290817,
                        "smoothness_improvement": 498.8021524662562,
                        "objective_score": 22.000895188635106
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.02625594139099121,
                        "num_nodes_avg": 208.9,
                        "path_length_avg": 244.3021244779086,
                        "smoothness_avg": 0.07331771296729457,
                        "success_improvement": 0.0,
                        "time_improvement": 83.61025026480232,
                        "node_improvement": 85.96385137405093,
                        "length_improvement": 18.444919002512343,
                        "smoothness_improvement": 1786.5175632625994,
                        "objective_score": 45.082614297261095
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.01305999755859375,
                        "num_nodes_avg": 163.0,
                        "path_length_avg": 140.27860161008172,
                        "smoothness_avg": 0.09759083301298958,
                        "success_improvement": 0.0,
                        "time_improvement": 73.37500455677744,
                        "node_improvement": 79.27527018436109,
                        "length_improvement": 6.833632159773637,
                        "smoothness_improvement": 1141.348192519241,
                        "objective_score": 31.819421625493614
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "path_expert",
                "algorithm_description": "HF-IRRT#-OS: Heuristic-Filtered Informed RRT# with Online Shortcuts \u2014 a single-tree, cost-optimal planner that uses grid-accelerated neighbors, admissible cost+heuristic pruning, correct-cost rewiring with queued propagation, per-cell best-cost duplicate suppression, aggressive informed sampling after the first solution, and incremental shortcutting to continuously reduce path length.",
                "planning_mechanism": "At each iteration, sample (goal/line/ellipse-biased), steer a bounded step, validate node and edge, select the lowest-cost valid parent within an adaptive radius, commit the node, and rewire cheaper neighbors with proper subtree cost updates. When near the goal, connect via the best valid parent to update the incumbent path. After any improvement, perform bounded shortcuts on the current best path to tighten c_best and focus the informed set. Terminate on post-optimization or no-improvement budgets and return a compressed, smoothed path.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=4.0,\n                 gamma_radius=60.0,\n                 min_radius_factor=1.0,\n                 goal_bias=0.15,\n                 line_bias=0.35,\n                 connect_radius_factor=2.5,\n                 near_cap=72,\n                 post_opt_iters=600,\n                 max_no_improve=240,\n                 smoothing_iters=220,\n                 ellipse_tries=220,\n                 occ_gain_ratio=0.985,\n                 prune_margin=1.0005,\n                 online_shortcuts_per_improve=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_radius = gamma_radius\n        self.min_radius_factor = min_radius_factor\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_radius_factor = connect_radius_factor\n        self.near_cap = near_cap\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.ellipse_tries = ellipse_tries\n        self.occ_gain_ratio = occ_gain_ratio\n        self.prune_margin = prune_margin\n        self.online_shortcuts_per_improve = online_shortcuts_per_improve\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Early feasibility: straight line\n        if self._in_bounds(start) and self._in_bounds(goal):\n            if (not self._is_in_obstacle(start, obstacles, is_3d)) and (not self._is_in_obstacle(goal, obstacles, is_3d)):\n                if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d):\n                    s = Node(start, None, 0.0)\n                    g = Node(goal, None, self._dist(start, goal))\n                    g.attach(s)\n                    nodes = [s, g]\n                    edges = [(s, g)]\n                    path = [start, goal]\n                    return PlannerResult(success=True, path=path, nodes=nodes, edges=edges)\n\n        # Initialize\n        root = Node(start, None, 0.0)\n        nodes = [root]\n\n        # Spatial hash grid for NN queries\n        cell = max(1.0, 0.8 * self.step_size)\n        grid = {}\n        self._grid_add(grid, root, cell)\n\n        # Per-cell best-cost ledger to suppress duplicates\n        occ_cell = max(0.5, 0.6 * self.step_size)\n        occ_best_cost = {self._occ_key(start, occ_cell): 0.0}\n\n        success = False\n        goal_node = None\n        best_cost = float('inf')\n        best_path_pts = None\n\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            # Sampling\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                x_rand = self._sample(start, goal, best_cost)\n\n            # Nearest\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n            # Bounds and node collision\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Parent selection within adaptive radius\n            r_near = self._rrtstar_radius(max(2, len(nodes)))\n            near_nodes = self._near(grid, x_new_pos, r_near, cell)\n            if near_nodes:\n                near_nodes = self._k_nearest_limit(near_nodes, x_new_pos, self.near_cap)\n            # Ensure nearest is considered\n            if n_near not in near_nodes:\n                near_nodes.append(n_near)\n\n            best_parent = None\n            best_pc = float('inf')\n\n            for nn in near_nodes:\n                base_cost = nn.cost + self._dist(nn.position, x_new_pos)\n                if base_cost + 1e-12 < best_pc:\n                    # Edge collision check for candidate parent\n                    if not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d):\n                        best_parent = nn\n                        best_pc = base_cost\n\n            if best_parent is None:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Duplicate suppression using per-cell best cost\n            k_occ = self._occ_key(x_new_pos, occ_cell)\n            prev_best = occ_best_cost.get(k_occ, float('inf'))\n            if best_pc >= prev_best * self.occ_gain_ratio:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Commit new node (both checks already validated for chosen parent)\n            x_new = Node(x_new_pos, None, best_pc)\n            x_new.attach(best_parent)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            if best_pc < prev_best:\n                occ_best_cost[k_occ] = best_pc\n\n            # Rewire neighbors with admissible pruning toward path-length improvement\n            for nn in near_nodes:\n                if nn is x_new or nn is best_parent:\n                    continue\n                alt = x_new.cost + self._dist(x_new.position, nn.position)\n                if alt + 1e-12 < nn.cost:\n                    # If we already have a solution, skip rewires that cannot possibly lead to improving it\n                    if best_cost < float('inf'):\n                        h = self._dist(nn.position, goal)\n                        if alt + h >= best_cost * self.prune_margin:\n                            continue\n                    if not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d):\n                        nn.attach(x_new)\n                        nn.cost = alt\n                        self._propagate_costs_from(nn)\n\n            # Try connecting to the goal using best available parent within connection range\n            improved = False\n            r_conn = max(r_near, self.connect_radius_factor * self.step_size)\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                cand = self._near(grid, goal, r_conn, cell)\n                if x_new not in cand:\n                    cand.append(x_new)\n                best_parent_goal = None\n                best_goal_cost = best_cost\n                for p in cand:\n                    ctot = p.cost + self._dist(p.position, goal)\n                    if ctot + 1e-12 < best_goal_cost:\n                        if not self._is_edge_in_obstacle(p.position, goal, obstacles, is_3d):\n                            best_goal_cost = ctot\n                            best_parent_goal = p\n                if best_parent_goal is not None:\n                    if goal_node is None:\n                        goal_node = Node(goal, None, best_goal_cost)\n                        goal_node.attach(best_parent_goal)\n                        nodes.append(goal_node)\n                    else:\n                        goal_node.attach(best_parent_goal)\n                        goal_node.cost = best_goal_cost\n                    best_cost = best_goal_cost\n                    success = True\n                    found_first = True\n                    improved = True\n\n            # After improvement, do bounded online shortcuts to tighten c_best and focus sampling\n            if improved and goal_node is not None:\n                cur_path = self._extract_path(goal_node)\n                cur_path = self._compress(cur_path, obstacles, is_3d)\n                cur_path = self._shortcuts(cur_path, obstacles, is_3d, self.online_shortcuts_per_improve)\n                path_len = self._path_length(cur_path)\n                if path_len + 1e-12 < best_cost:\n                    best_cost = path_len\n                best_path_pts = cur_path\n                post_iters = 0\n                no_improve = 0\n            else:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        # Build final path\n        path = []\n        if success and goal_node is not None:\n            if best_path_pts is None:\n                path = self._extract_path(goal_node)\n                path = self._compress(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n            else:\n                # Final polishing\n                path = self._shortcuts(best_path_pts, obstacles, is_3d, self.smoothing_iters)\n\n        # Build edges from parent pointers\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---------- Utilities ----------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        # 32-bit LCG (Numerical Recipes variant)\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _rrtstar_radius(self, n):\n        r = self.gamma_radius\n        if n > 2:\n            expo = 1.0 / float(max(2, self.dim))\n            r = self.gamma_radius * ((self._log_approx(n) / float(n)) ** expo)\n        rmin = max(self.min_radius_factor * self.step_size, 1e-6)\n        if r < rmin:\n            r = rmin\n        return r\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        # rough ln via bit_length\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    # Spatial hashing\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        # limit expansion\n        max_span = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > max_span:\n                max_span = self.bounds[i]\n        limit = max_span * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # fallback\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _k_nearest_limit(self, nodes, center, k):\n        if len(nodes) <= k:\n            return nodes\n        # partial selection without full sort when large\n        idx = []\n        for i, n in enumerate(nodes):\n            idx.append((self._dist(n.position, center), i))\n        if len(nodes) <= 4 * k:\n            idx.sort(key=lambda t: t[0])\n            return [nodes[t[1]] for t in idx[:k]]\n        # approximate selection\n        sel = []\n        used = [False] * len(nodes)\n        for _ in range(k):\n            best = -1\n            bestd = float('inf')\n            for j, (d, i) in enumerate(idx):\n                if not used[j] and d < bestd:\n                    bestd = d\n                    best = j\n            if best == -1:\n                break\n            used[best] = True\n            sel.append(nodes[idx[best][1]])\n        return sel\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _heuristic(self, a, b):\n        return self._dist(a, b)\n\n    def _sample(self, start, goal, c_best):\n        # Informed ellipsoidal rejection after first solution; else line/uniform mix\n        if c_best < float('inf'):\n            # accept points satisfying triangle inequality gate; try more to avoid fallback\n            tries = self.ellipse_tries\n            for _ in range(tries):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p):\n                    if self._dist(p, start) + self._dist(p, goal) <= c_best:\n                        return p\n        # Line-biased sampling with jitter\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jitter = 0.5 * self.step_size\n            p = tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n            return p\n        # Uniform\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _propagate_costs_from(self, node):\n        # node.cost already set correctly by caller\n        stack = []\n        for c in node.children:\n            stack.append(c)\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                newc = u.parent.cost + self._dist(u.parent.position, u.position)\n                if abs(newc - u.cost) > 1e-12:\n                    u.cost = newc\n            for c in u.children:\n                stack.append(c)\n\n    def _extract_path(self, goal_node):\n        seq = []\n        cur = goal_node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
                "objective": 26.9043,
                "time_improvement": -154.0,
                "length_improvement": 19.0,
                "smoothness_improvement": 1520.0,
                "node_improvement": 44.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.10562500953674317,
                        "num_nodes_avg": 293.8,
                        "path_length_avg": 154.45237735825782,
                        "smoothness_avg": 0.04984145985356507,
                        "success_improvement": 0.0,
                        "time_improvement": -314.23529004756443,
                        "node_improvement": 26.013598589775878,
                        "length_improvement": 15.34220451539984,
                        "smoothness_improvement": 680.1270791706859,
                        "objective_score": -81.66462890917599
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.2455054998397827,
                        "num_nodes_avg": 623.2,
                        "path_length_avg": 228.05708400641493,
                        "smoothness_avg": 0.10153044277454511,
                        "success_improvement": 0.0,
                        "time_improvement": -53.25193033715656,
                        "node_improvement": 58.1267217630854,
                        "length_improvement": 23.867981099460806,
                        "smoothness_improvement": 2512.4514220110627,
                        "objective_score": 10.90746666858483
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.09506032466888428,
                        "num_nodes_avg": 407.5,
                        "path_length_avg": 122.10575352004132,
                        "smoothness_avg": 0.1154296410531563,
                        "success_improvement": 0.0,
                        "time_improvement": -93.79641533507504,
                        "node_improvement": 48.188175460902734,
                        "length_improvement": 18.903172563144594,
                        "smoothness_improvement": 1368.2565140663191,
                        "objective_score": -9.95573849230416
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "cross_over",
            "algorithm_description": "BCI-BiRRT: Beam-Compressed Informed BiRRT \u2014 a bidirectional planner that uses small-beam guided sampling, per-cell duplicate suppression, line-of-sight ancestor compression, grid-accelerated nearest/near queries, and k-near minimal-cost bridging with post-connection informed shortcuts to deliver fast, short, and smooth paths.",
            "planning_mechanism": "Mechanism: adaptively choose a tree to expand; sample a small beam (goal/line/informed-biased), steer and validate candidates, select the one that most reduces distance to the opposite tree, compress the parent via line-of-sight to an ancestor, commit the node (after node+edge checks and duplicate pruning), then attempt a k-near bridge to the opposite tree minimizing total start-to-goal cost; upon success, extract [start\u2192\u2026\u2192meetA, meetB\u2192\u2026\u2192goal], compress and shortcut, and return.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=6.0,\n                 beam_k=3,\n                 goal_bias=0.18,\n                 line_bias=0.35,\n                 connect_radius_factor=3.0,\n                 k_bridge=6,\n                 occ_gain_ratio=0.99,\n                 compress_depth=3,\n                 smoothing_iters=100,\n                 ellipse_tries=90,\n                 switch_fail_thresh=6,\n                 grid_cell=None):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_radius_factor = connect_radius_factor\n        self.k_bridge = k_bridge\n        self.occ_gain_ratio = occ_gain_ratio\n        self.compress_depth = compress_depth\n        self.smoothing_iters = smoothing_iters\n        self.ellipse_tries = ellipse_tries\n        self.switch_fail_thresh = switch_fail_thresh\n        self.grid_cell = grid_cell\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Basic parameters\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.edge_res = max(0.5, min(1.0, 0.5 * self.step_size))\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line check\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # Initialize trees (start-rooted, goal-rooted)\n        s_root = Node(start, None, 0.0)\n        g_root = Node(goal, None, 0.0)\n        start_tree = [s_root]\n        goal_tree = [g_root]\n        edges = []\n\n        grid_s = {}\n        grid_g = {}\n        self._grid_add(grid_s, s_root, self.grid_cell)\n        self._grid_add(grid_g, g_root, self.grid_cell)\n\n        # Per-cell best cost to suppress near-duplicates\n        occ_cell = max(0.5, 0.7 * self.step_size)\n        occ_s = {self._occ_key(start, occ_cell): 0.0}\n        occ_g = {self._occ_key(goal, occ_cell): 0.0}\n\n        # Bookkeeping\n        failed_s = 0\n        failed_g = 0\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            # Choose which tree to grow (adaptive alternation)\n            active_start = (it % 2 == 0)\n            if (active_start and failed_s >= self.switch_fail_thresh) or ((not active_start) and failed_g >= self.switch_fail_thresh):\n                active_start = not active_start\n\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_s if active_start else grid_g\n            grid_b = grid_g if active_start else grid_s\n            occ_a = occ_s if active_start else occ_g\n            root_other = goal if active_start else start\n            root_self = start if active_start else goal\n\n            # Beam sampling\n            candidates = []\n            for _ in range(self.beam_k):\n                x_rand = None\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                else:\n                    # informed ellipsoid after first solution\n                    if best_len < float('inf'):\n                        got = False\n                        for _t in range(self.ellipse_tries):\n                            p = self._uniform_point()\n                            if self._in_bounds(p):\n                                if self._dist(p, start) + self._dist(p, goal) <= best_len:\n                                    x_rand = p\n                                    got = True\n                                    break\n                        if not got:\n                            x_rand = self._uniform_point()\n                    else:\n                        if self._rand() < self.line_bias:\n                            # line-biased with jitter\n                            t = self._uniform(0.0, 1.0)\n                            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n                            jit = 0.5 * self.step_size\n                            x_rand = tuple(self._clip(base[i] + self._uniform(-jit, jit), 0.0, self.bounds[i]) for i in range(self.dim))\n                        else:\n                            x_rand = self._uniform_point()\n\n                # Nearest and steer\n                n_near = self._nearest(grid_a, tree_a, x_rand, self.grid_cell)\n                x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n                if not self._in_bounds(x_new_pos):\n                    continue\n                if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(n_near.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                    continue\n\n                # Line-of-sight ancestor compression (limited depth)\n                best_parent = n_near\n                best_cost = n_near.cost + self._dist(n_near.position, x_new_pos)\n                anc = n_near.parent\n                depth = 0\n                while anc is not None and depth < self.compress_depth:\n                    if not self._is_edge_in_obstacle(anc.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                        alt = anc.cost + self._dist(anc.position, x_new_pos)\n                        if alt + 1e-12 < best_cost:\n                            best_cost = alt\n                            best_parent = anc\n                    anc = anc.parent\n                    depth += 1\n\n                # Duplicate suppression in occupancy grid\n                k_occ = self._occ_key(x_new_pos, occ_cell)\n                prev_best = occ_a.get(k_occ, float('inf'))\n                if best_cost >= prev_best * self.occ_gain_ratio:\n                    continue\n\n                # Progress score: distance to other tree after extension\n                other_near = self._nearest(grid_b, tree_b, x_new_pos, self.grid_cell)\n                score = self._dist(x_new_pos, other_near.position) if other_near is not None else self._dist(x_new_pos, root_other)\n                candidates.append((score, x_new_pos, best_parent, best_cost))\n\n            if not candidates:\n                if active_start:\n                    failed_s += 1\n                else:\n                    failed_g += 1\n                continue\n\n            # Commit the best candidate\n            candidates.sort(key=lambda t: t[0])\n            _, new_pos, parent, new_cost = candidates[0]\n\n            new_node = Node(new_pos, None, new_cost)\n            new_node.attach(parent)\n            tree_a.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid_a, new_node, self.grid_cell)\n            k_occ_new = self._occ_key(new_pos, occ_cell)\n            if new_cost < occ_a.get(k_occ_new, float('inf')):\n                occ_a[k_occ_new] = new_cost\n\n            if active_start:\n                failed_s = 0\n            else:\n                failed_g = 0\n\n            # Attempt k-near best-cost bridge to the other tree\n            r_conn = max(self.connect_radius_factor * self.step_size, self.step_size)\n            near_b = self._near(grid_b, new_pos, r_conn, self.grid_cell)\n            if not near_b:\n                nn_b = self._nearest(grid_b, tree_b, new_pos, self.grid_cell)\n                if nn_b is not None:\n                    near_b = [nn_b]\n\n            # Select up to k closest in Euclidean distance to new_pos\n            if len(near_b) > self.k_bridge:\n                # partial selection\n                dist_idx = [(self._dist(n.position, new_pos), i) for i, n in enumerate(near_b)]\n                dist_idx.sort(key=lambda t: t[0])\n                near_b = [near_b[i] for (_, i) in dist_idx[:self.k_bridge]]\n\n            best_bridge = None\n            best_total = best_len\n            for nb in near_b:\n                if not self._is_edge_in_obstacle(new_pos, nb.position, obstacles, is_3d, self.edge_res):\n                    total = new_node.cost + self._dist(new_pos, nb.position) + nb.cost\n                    if total + 1e-12 < best_total:\n                        best_total = total\n                        best_bridge = nb\n\n            if best_bridge is not None:\n                # Extract path\n                if active_start:\n                    meet_a = new_node\n                    meet_b = best_bridge\n                else:\n                    meet_a = best_bridge\n                    meet_b = new_node\n\n                path = self._extract_path(meet_a, meet_b)\n                path = self._compress(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n                plen = self._path_length(path)\n                if plen < best_len:\n                    best_len = plen\n                    best_path = path\n                return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        # If loop ends without connection\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _uniform_point(self):\n        if self.dim == 3:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]),\n                    self._uniform(0.0, self.bounds[2]))\n        else:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]))\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return tuple(self._clip(to_pos[i], 0.0, self.bounds[i]) for i in range(self.dim))\n        r = step / d\n        return tuple(self._clip(from_pos[i] + (to_pos[i] - from_pos[i]) * r, 0.0, self.bounds[i]) for i in range(self.dim))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Spatial hash ----------\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        # Expand radius until found, then fallback to scan\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        limit = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > limit:\n                limit = self.bounds[i]\n        limit = limit * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # Fallback\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        r2 = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    # ---------- Path utilities ----------\n    def _path_to_root(self, node):\n        seq = []\n        cur = node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _extract_path(self, meet_a, meet_b):\n        # meet_a is in start-tree side, meet_b is in goal-tree side\n        path_a = self._path_to_root(meet_a)\n        # ascend from meet_b to goal root\n        tail = []\n        cur = meet_b\n        while cur is not None:\n            tail.append(cur.position)\n            cur = cur.parent\n        # path: start ... meet_a, then straight to meet_b (implied), then ... goal\n        return path_a + tail\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.edge_res):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
            "objective": -4.32865,
            "time_improvement": -45.0,
            "length_improvement": 16.0,
            "smoothness_improvement": 1649.0,
            "node_improvement": 81.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05528700351715088,
                    "num_nodes_avg": 52.7,
                    "path_length_avg": 159.23267345792033,
                    "smoothness_avg": 0.04720018064341601,
                    "success_improvement": 0.0,
                    "time_improvement": -116.82202007111755,
                    "node_improvement": 86.72878368169226,
                    "length_improvement": 12.722048474535743,
                    "smoothness_improvement": 638.7853239022464,
                    "objective_score": -24.219450317102588
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.128195858001709,
                    "num_nodes_avg": 251.0,
                    "path_length_avg": 244.97426414775782,
                    "smoothness_avg": 0.11245472368962676,
                    "success_improvement": 0.0,
                    "time_improvement": 19.976282760218798,
                    "node_improvement": 83.13512060740442,
                    "length_improvement": 18.22053943424897,
                    "smoothness_improvement": 2793.541038397612,
                    "objective_score": 30.89291368060308
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06766645908355713,
                    "num_nodes_avg": 219.1,
                    "path_length_avg": 125.15812725071248,
                    "smoothness_avg": 0.12691495233302894,
                    "success_improvement": 0.0,
                    "time_improvement": -37.949425846041684,
                    "node_improvement": 72.14240305149396,
                    "length_improvement": 16.875931269650575,
                    "smoothness_improvement": 1514.3488257888052,
                    "objective_score": 6.312475136921865
                }
            ],
            "success_rate": 1.0
        },
        "objective": 10.8,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Greedy, single-candidate expansions and nearest-only inter-tree connections produce arbitrary junctions and long detours.\n   - Missing or weak structure-improving steps (no rewiring or line-of-sight compression) leave redundant bends and zigzags in the tree.\n   - Rigid tree alternation and poor dead-end handling yield low-quality meeting geometry between search frontiers.\n   - Coarse steering and edge checking reduce feasible shortcuts and create jagged paths that smoothing cannot fully fix.\n   - Over-strict/approximate neighbor selection and duplicate filtering discard near-equal-cost states that could lead to globally shorter routes."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Cost-aware k-near bridging that selects the best total start-to-goal connection rather than the nearest-only junction.\n   - Line-of-sight ancestor compression before committing nodes to remove unnecessary intermediate vertices.\n   - Small-beam, progress-scored candidate selection with line-biased and informed sampling to target straighter connections.\n   - Per-cell best-cost duplicate suppression tuned to keep only superior representatives without over-pruning.\n   - Post-connection path compression followed by bounded shortcut smoothing.\n2. Expected mechanism of impact:\n   - Cost-minimizing bridges directly reduce detours at the meeting point of the search fronts.\n   - Ancestor compression shortens segments by bypassing local zigzags, yielding straighter subpaths.\n   - Beam-guided growth improves encounter geometry between trees, enabling shorter, more direct inter-tree links.\n   - Duplicate suppression preserves lower-cost frontiers in each region, biasing subsequent expansions toward shorter routes.\n   - Compression and shortcuts transform near-collinear waypoint chains into direct edges, tightening total length and improving smoothness."
        }
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional, asymptotically optimal planner that blends RRT-Connect\u2019s fast greedy tree-connection with RRT*\u2019s cost-optimal rewiring, and\u2014after an initial solution\u2014focuses sampling within the prolate hyperspheroid (ellipsoid) defined by the start, goal, and current best path length to accelerate convergence.",
                "planning_mechanism": "The planner grows two trees from start and goal. Each iteration: (1) sample uniformly until a first solution is found, then sample inside the informed ellipsoid; (2) extend one tree toward the sample using RRT*-style best-parent selection and local rewiring; (3) greedily \u201cconnect\u201d the opposite tree toward the new node, also rewiring locally; (4) if trees meet, update the best path and continue only a limited number of post-optimization iterations (user-tunable). Every node and edge is checked for point-in-obstacle and edge-obstacle collisions, positions are clamped to bounds, and a hard 30-second time limit halts the search and returns the best path found so far.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cumulative path cost from the root of its tree\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        neighbor_radius: float = 25.0,\n        post_opt_iters: int = 400,      # extra iterations after first solution\n        max_no_improve: int = 150,      # stop early if no improvement for this many iters\n        improve_tol: float = 1e-6,      # minimal improvement to count\n        time_limit_sec: float = 30.0,   # hard wall time limit\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Core data\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_cost = float('inf')\n        best_path = []\n        c_min = math.dist(start_position, goal_position)\n\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            # Enforce 30s time limit\n            if time.time() - start_time > self.time_limit_sec:\n                return PlannerResult(\n                    success=success_state,\n                    path=best_path if success_state else [],\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            # Alternate trees (RRT-Connect style)\n            tree_a, tree_b = (start_tree, goal_tree) if (it % 2 == 0) else (goal_tree, start_tree)\n\n            # Informed sampling: uniform before first solution; ellipsoid after\n            x_rand = self._sample_informed(start_position, goal_position, best_cost, c_min, bounds)\n\n            # Extend tree_a one step with RRT* best-parent + local rewire\n            a_nearest = self._nearest(tree_a, x_rand)\n            a_new_pos = self._steer(a_nearest.position, x_rand)\n\n            if not self._within_bounds(a_new_pos, bounds):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                if found_first_solution and (post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve):\n                    break\n                continue\n\n            if self._is_in_obstacle(a_new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(a_nearest.position, a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                if found_first_solution and (post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve):\n                    break\n                continue\n\n            a_new, a_neighbors = self._add_with_best_parent(tree_a, a_new_pos, obstacles, is_3d, nodes, edges)\n            self._rewire_from(a_new, a_neighbors, obstacles, is_3d, edges)\n\n            # Greedy connect tree_b toward a_new (RRT-Connect) with local RRT* rewiring\n            b_meet = self._connect_with_rewire(tree_b, a_new, obstacles, is_3d, nodes, edges, bounds)\n\n            if b_meet is not None:\n                # Build full path depending on which side expanded\n                if it % 2 == 0:\n                    path_a = a_new.path_from_root()       # start side\n                    path_b = b_meet.path_from_root()      # goal side\n                else:\n                    path_a = b_meet.path_from_root()       # start side\n                    path_b = a_new.path_from_root()        # goal side\n\n                # Merge (avoid double-counting the joint if equal)\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged = path_a + path_b[-2::-1]\n                else:\n                    merged = path_a + path_b[::-1]\n\n                cost = self._path_cost(merged)\n\n                if cost + self.improve_tol < best_cost:\n                    best_cost = cost\n                    best_path = merged\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0\n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------------- Helpers ----------------------\n    def _within_bounds(self, pos, bounds):\n        return all(0.0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _path_cost(self, path):\n        return sum(math.dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _neighbors(self, tree, pos):\n        return [n for n in tree if math.dist(n.position, pos) <= self.neighbor_radius]\n\n    def _add_with_best_parent(self, tree, new_pos, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, new_pos)\n        candidates = self._neighbors(tree, new_pos)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in candidates:\n            if self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                continue\n            cand_cost = nb.cost + math.dist(nb.position, new_pos)\n            if cand_cost < min_cost:\n                min_cost = cand_cost\n                best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, candidates\n\n    def _rewire_from(self, pivot: Node, neighbors, obstacles, is_3d, edges):\n        for nb in neighbors:\n            if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                continue\n            new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n            if new_cost + 1e-12 < nb.cost:\n                if nb.parent is not None:\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    if nb in nb.parent.children:\n                        nb.parent.children.remove(nb)\n                pivot.add_child(nb)\n                nb.cost = new_cost\n                edges.append((pivot, nb))\n\n    def _connect_with_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        \"\"\"\n        Greedily advance 'tree' toward 'target_node' like RRT-Connect.\n        At each step, insert with best parent and locally rewire.\n        Return the final node in 'tree' placed at target_node.position (if reached), else None.\n        \"\"\"\n        current = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(current.position, target_node.position)\n\n            if not self._within_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node, neighbors = self._add_with_best_parent(tree, new_pos, obstacles, is_3d, nodes, edges)\n            self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(new_node.position, target_node.position) <= self.step_size:\n                # final short edge\n                if not self._is_edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d) and target_node.valid:\n                    final_node = Node(\n                        target_node.position,\n                        parent=None,\n                        cost=new_node.cost + math.dist(new_node.position, target_node.position)\n                    )\n                    new_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                return None\n\n            current = new_node\n\n    # ------------------ Informed Sampling ------------------\n    def _sample_informed(self, start, goal, c_best, c_min, bounds):\n        \"\"\"Uniform before first solution; prolate hyperspheroid after (supports 2D/3D).\"\"\"\n        dim = len(bounds)\n        if c_best == float('inf') or c_min <= 1e-12:\n            # uniform in bounds\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # radii along orthonormal basis aligned with start->goal\n        r1 = c_best / 2.0\n        r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n        r_other = math.sqrt(r_other_sq) / 2.0\n\n        # center\n        center = tuple((s + g) / 2.0 for s, g in zip(start, goal))\n        # first axis (unit)\n        a1_vec = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n        # orthonormal basis\n        if dim == 2:\n            a2_vec = (-a1_vec[1], a1_vec[0])\n            basis = (a1_vec, a2_vec)\n            radii = (r1, r_other)\n        else:  # dim == 3\n            # pick any non-parallel vector\n            ref = (1.0, 0.0, 0.0) if abs(a1_vec[0]) < 0.9 else (0.0, 1.0, 0.0)\n            # b2 = normalize(cross(a1, ref)), b3 = cross(a1, b2)\n            b2 = self._normalize(self._cross(a1_vec, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._normalize(self._cross(a1_vec, ref))\n            b3 = self._cross(a1_vec, b2)\n            basis = (a1_vec, b2, b3)\n            radii = (r1, r_other, r_other)\n\n        # sample unit ball\n        u = self._sample_unit_ball(dim)\n\n        # map: x = center + sum_i (basis_i * radii_i * u_i)\n        mapped = []\n        for d in range(dim):\n            val = center[d]\n            for i in range(dim):\n                val += basis[i][d] * radii[i] * u[i]\n            mapped.append(val)\n\n        # clamp to bounds to be safe\n        mapped = tuple(min(max(mapped[d], 0.0), bounds[d]) for d in range(dim))\n        return mapped\n\n    def _sample_unit_ball(self, dim):\n        # Draw direction from normal distribution and radius with correct PDF\n        while True:\n            vec = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(v * v for v in vec))\n            if n > 1e-12:\n                vec = [v / n for v in vec]\n                r = random.random() ** (1.0 / dim)\n                return tuple(vec[i] * r for i in range(dim))\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)\n\n    # ------------------ Collision Utilities ------------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": 518.1211228589663,
                "time_improvement": -1783.0,
                "length_improvement": 22.0,
                "smoothness_improvement": 648.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.9512754917144776,
                        "num_nodes_avg": 539.7,
                        "path_length_avg": 146.95278540397857,
                        "smoothness_avg": 0.035670720596744435,
                        "success_improvement": 0.0,
                        "time_improvement": -3630.668342220689,
                        "node_improvement": -35.91035003777387,
                        "length_improvement": 19.45284970417965,
                        "smoothness_improvement": 458.32423754861986,
                        "objective_score": -1075.2371716559555
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.4313333034515381,
                        "num_nodes_avg": 595.7,
                        "path_length_avg": 229.86311266595635,
                        "smoothness_avg": 0.028909493641293648,
                        "success_improvement": 0.0,
                        "time_improvement": -169.25124453745204,
                        "node_improvement": 59.97446751327017,
                        "length_improvement": 23.265076749253225,
                        "smoothness_improvement": 643.8620940570969,
                        "objective_score": -33.59701684139819
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.8084268569946289,
                        "num_nodes_avg": 639.6,
                        "path_length_avg": 113.69137900509236,
                        "smoothness_avg": 0.07405674090515976,
                        "success_improvement": 0.0,
                        "time_improvement": -1548.1137371650768,
                        "node_improvement": 18.67768595041322,
                        "length_improvement": 24.491599466516433,
                        "smoothness_improvement": 841.9962780136293,
                        "objective_score": -445.52918007954503
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "path_expert",
                "algorithm_description": "HF-IRRT#-OS: Heuristic-Filtered Informed RRT# with Online Shortcuts \u2014 a single-tree, cost-optimal planner that uses grid-accelerated neighbors, admissible cost+heuristic pruning, correct-cost rewiring with queued propagation, per-cell best-cost duplicate suppression, aggressive informed sampling after the first solution, and incremental shortcutting to continuously reduce path length.",
                "planning_mechanism": "At each iteration, sample (goal/line/ellipse-biased), steer a bounded step, validate node and edge, select the lowest-cost valid parent within an adaptive radius, commit the node, and rewire cheaper neighbors with proper subtree cost updates. When near the goal, connect via the best valid parent to update the incumbent path. After any improvement, perform bounded shortcuts on the current best path to tighten c_best and focus the informed set. Terminate on post-optimization or no-improvement budgets and return a compressed, smoothed path.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=4.0,\n                 gamma_radius=60.0,\n                 min_radius_factor=1.0,\n                 goal_bias=0.15,\n                 line_bias=0.35,\n                 connect_radius_factor=2.5,\n                 near_cap=72,\n                 post_opt_iters=600,\n                 max_no_improve=240,\n                 smoothing_iters=220,\n                 ellipse_tries=220,\n                 occ_gain_ratio=0.985,\n                 prune_margin=1.0005,\n                 online_shortcuts_per_improve=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_radius = gamma_radius\n        self.min_radius_factor = min_radius_factor\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_radius_factor = connect_radius_factor\n        self.near_cap = near_cap\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.ellipse_tries = ellipse_tries\n        self.occ_gain_ratio = occ_gain_ratio\n        self.prune_margin = prune_margin\n        self.online_shortcuts_per_improve = online_shortcuts_per_improve\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Early feasibility: straight line\n        if self._in_bounds(start) and self._in_bounds(goal):\n            if (not self._is_in_obstacle(start, obstacles, is_3d)) and (not self._is_in_obstacle(goal, obstacles, is_3d)):\n                if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d):\n                    s = Node(start, None, 0.0)\n                    g = Node(goal, None, self._dist(start, goal))\n                    g.attach(s)\n                    nodes = [s, g]\n                    edges = [(s, g)]\n                    path = [start, goal]\n                    return PlannerResult(success=True, path=path, nodes=nodes, edges=edges)\n\n        # Initialize\n        root = Node(start, None, 0.0)\n        nodes = [root]\n\n        # Spatial hash grid for NN queries\n        cell = max(1.0, 0.8 * self.step_size)\n        grid = {}\n        self._grid_add(grid, root, cell)\n\n        # Per-cell best-cost ledger to suppress duplicates\n        occ_cell = max(0.5, 0.6 * self.step_size)\n        occ_best_cost = {self._occ_key(start, occ_cell): 0.0}\n\n        success = False\n        goal_node = None\n        best_cost = float('inf')\n        best_path_pts = None\n\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            # Sampling\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                x_rand = self._sample(start, goal, best_cost)\n\n            # Nearest\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n            # Bounds and node collision\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Parent selection within adaptive radius\n            r_near = self._rrtstar_radius(max(2, len(nodes)))\n            near_nodes = self._near(grid, x_new_pos, r_near, cell)\n            if near_nodes:\n                near_nodes = self._k_nearest_limit(near_nodes, x_new_pos, self.near_cap)\n            # Ensure nearest is considered\n            if n_near not in near_nodes:\n                near_nodes.append(n_near)\n\n            best_parent = None\n            best_pc = float('inf')\n\n            for nn in near_nodes:\n                base_cost = nn.cost + self._dist(nn.position, x_new_pos)\n                if base_cost + 1e-12 < best_pc:\n                    # Edge collision check for candidate parent\n                    if not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d):\n                        best_parent = nn\n                        best_pc = base_cost\n\n            if best_parent is None:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Duplicate suppression using per-cell best cost\n            k_occ = self._occ_key(x_new_pos, occ_cell)\n            prev_best = occ_best_cost.get(k_occ, float('inf'))\n            if best_pc >= prev_best * self.occ_gain_ratio:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Commit new node (both checks already validated for chosen parent)\n            x_new = Node(x_new_pos, None, best_pc)\n            x_new.attach(best_parent)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            if best_pc < prev_best:\n                occ_best_cost[k_occ] = best_pc\n\n            # Rewire neighbors with admissible pruning toward path-length improvement\n            for nn in near_nodes:\n                if nn is x_new or nn is best_parent:\n                    continue\n                alt = x_new.cost + self._dist(x_new.position, nn.position)\n                if alt + 1e-12 < nn.cost:\n                    # If we already have a solution, skip rewires that cannot possibly lead to improving it\n                    if best_cost < float('inf'):\n                        h = self._dist(nn.position, goal)\n                        if alt + h >= best_cost * self.prune_margin:\n                            continue\n                    if not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d):\n                        nn.attach(x_new)\n                        nn.cost = alt\n                        self._propagate_costs_from(nn)\n\n            # Try connecting to the goal using best available parent within connection range\n            improved = False\n            r_conn = max(r_near, self.connect_radius_factor * self.step_size)\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                cand = self._near(grid, goal, r_conn, cell)\n                if x_new not in cand:\n                    cand.append(x_new)\n                best_parent_goal = None\n                best_goal_cost = best_cost\n                for p in cand:\n                    ctot = p.cost + self._dist(p.position, goal)\n                    if ctot + 1e-12 < best_goal_cost:\n                        if not self._is_edge_in_obstacle(p.position, goal, obstacles, is_3d):\n                            best_goal_cost = ctot\n                            best_parent_goal = p\n                if best_parent_goal is not None:\n                    if goal_node is None:\n                        goal_node = Node(goal, None, best_goal_cost)\n                        goal_node.attach(best_parent_goal)\n                        nodes.append(goal_node)\n                    else:\n                        goal_node.attach(best_parent_goal)\n                        goal_node.cost = best_goal_cost\n                    best_cost = best_goal_cost\n                    success = True\n                    found_first = True\n                    improved = True\n\n            # After improvement, do bounded online shortcuts to tighten c_best and focus sampling\n            if improved and goal_node is not None:\n                cur_path = self._extract_path(goal_node)\n                cur_path = self._compress(cur_path, obstacles, is_3d)\n                cur_path = self._shortcuts(cur_path, obstacles, is_3d, self.online_shortcuts_per_improve)\n                path_len = self._path_length(cur_path)\n                if path_len + 1e-12 < best_cost:\n                    best_cost = path_len\n                best_path_pts = cur_path\n                post_iters = 0\n                no_improve = 0\n            else:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        # Build final path\n        path = []\n        if success and goal_node is not None:\n            if best_path_pts is None:\n                path = self._extract_path(goal_node)\n                path = self._compress(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n            else:\n                # Final polishing\n                path = self._shortcuts(best_path_pts, obstacles, is_3d, self.smoothing_iters)\n\n        # Build edges from parent pointers\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---------- Utilities ----------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        # 32-bit LCG (Numerical Recipes variant)\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _rrtstar_radius(self, n):\n        r = self.gamma_radius\n        if n > 2:\n            expo = 1.0 / float(max(2, self.dim))\n            r = self.gamma_radius * ((self._log_approx(n) / float(n)) ** expo)\n        rmin = max(self.min_radius_factor * self.step_size, 1e-6)\n        if r < rmin:\n            r = rmin\n        return r\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        # rough ln via bit_length\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    # Spatial hashing\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        # limit expansion\n        max_span = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > max_span:\n                max_span = self.bounds[i]\n        limit = max_span * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # fallback\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _k_nearest_limit(self, nodes, center, k):\n        if len(nodes) <= k:\n            return nodes\n        # partial selection without full sort when large\n        idx = []\n        for i, n in enumerate(nodes):\n            idx.append((self._dist(n.position, center), i))\n        if len(nodes) <= 4 * k:\n            idx.sort(key=lambda t: t[0])\n            return [nodes[t[1]] for t in idx[:k]]\n        # approximate selection\n        sel = []\n        used = [False] * len(nodes)\n        for _ in range(k):\n            best = -1\n            bestd = float('inf')\n            for j, (d, i) in enumerate(idx):\n                if not used[j] and d < bestd:\n                    bestd = d\n                    best = j\n            if best == -1:\n                break\n            used[best] = True\n            sel.append(nodes[idx[best][1]])\n        return sel\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _heuristic(self, a, b):\n        return self._dist(a, b)\n\n    def _sample(self, start, goal, c_best):\n        # Informed ellipsoidal rejection after first solution; else line/uniform mix\n        if c_best < float('inf'):\n            # accept points satisfying triangle inequality gate; try more to avoid fallback\n            tries = self.ellipse_tries\n            for _ in range(tries):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p):\n                    if self._dist(p, start) + self._dist(p, goal) <= c_best:\n                        return p\n        # Line-biased sampling with jitter\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jitter = 0.5 * self.step_size\n            p = tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n            return p\n        # Uniform\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _propagate_costs_from(self, node):\n        # node.cost already set correctly by caller\n        stack = []\n        for c in node.children:\n            stack.append(c)\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                newc = u.parent.cost + self._dist(u.parent.position, u.position)\n                if abs(newc - u.cost) > 1e-12:\n                    u.cost = newc\n            for c in u.children:\n                stack.append(c)\n\n    def _extract_path(self, goal_node):\n        seq = []\n        cur = goal_node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
                "objective": 26.9043,
                "time_improvement": -154.0,
                "length_improvement": 19.0,
                "smoothness_improvement": 1520.0,
                "node_improvement": 44.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.10562500953674317,
                        "num_nodes_avg": 293.8,
                        "path_length_avg": 154.45237735825782,
                        "smoothness_avg": 0.04984145985356507,
                        "success_improvement": 0.0,
                        "time_improvement": -314.23529004756443,
                        "node_improvement": 26.013598589775878,
                        "length_improvement": 15.34220451539984,
                        "smoothness_improvement": 680.1270791706859,
                        "objective_score": -81.66462890917599
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.2455054998397827,
                        "num_nodes_avg": 623.2,
                        "path_length_avg": 228.05708400641493,
                        "smoothness_avg": 0.10153044277454511,
                        "success_improvement": 0.0,
                        "time_improvement": -53.25193033715656,
                        "node_improvement": 58.1267217630854,
                        "length_improvement": 23.867981099460806,
                        "smoothness_improvement": 2512.4514220110627,
                        "objective_score": 10.90746666858483
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.09506032466888428,
                        "num_nodes_avg": 407.5,
                        "path_length_avg": 122.10575352004132,
                        "smoothness_avg": 0.1154296410531563,
                        "success_improvement": 0.0,
                        "time_improvement": -93.79641533507504,
                        "node_improvement": 48.188175460902734,
                        "length_improvement": 18.903172563144594,
                        "smoothness_improvement": 1368.2565140663191,
                        "objective_score": -9.95573849230416
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "GH-Connect-Lite: Guided Hash RRT-Connect Lite \u2014 a single-tree, grid-accelerated planner that combines fast goal/line-biased informed sampling, lightweight duplicate suppression, short greedy goal-connection, and bounded smoothing. It commits only validated nodes/edges, uses an occupancy-cost ledger to avoid redundant expansions, and performs micro local shortcuts and post-improvement polishing for shorter, smoother paths while keeping per-iteration work small.",
            "planning_mechanism": "Initialize with early straight-line check. Maintain a hash-grid for fast nearest queries and a per-cell best-cost ledger. Each iteration: sample (goal/line/uniform; switch to ellipsoid gating after first solution), steer one step, validate node and edge, apply duplicate-cost filter, then commit the node. Perform a tiny greedy connect toward the goal (few steps) with the same validations and a local grandparent shortcut if it lowers cost. When near the goal, attempt a direct validated bridge; on improvement, run bounded compression/shortcuts to tighten c_best and focus sampling. Use post-optimization and no-improvement budgets to terminate early and return the best path found.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=4.0,\n        goal_bias=0.2,\n        line_bias=0.35,\n        connect_steps=2,\n        connect_radius_factor=3.0,\n        occ_relax=1.02,\n        post_opt_iters=500,\n        max_no_improve=220,\n        smoothing_iters=220,\n        online_shortcuts_per_improve=40\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_steps = connect_steps\n        self.connect_radius_factor = connect_radius_factor\n        self.occ_relax = occ_relax\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.online_shortcuts_per_improve = online_shortcuts_per_improve\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Early straight-line feasibility\n        if self._in_bounds(start) and self._in_bounds(goal):\n            if (not self._is_in_obstacle(start, obstacles, is_3d)) and (not self._is_in_obstacle(goal, obstacles, is_3d)):\n                if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d):\n                    s = Node(start, None, 0.0)\n                    g = Node(goal, None, self._dist(start, goal))\n                    g.attach(s)\n                    nodes = [s, g]\n                    edges = [(s, g)]\n                    path = [start, goal]\n                    return PlannerResult(success=True, path=path, nodes=nodes, edges=edges)\n\n        root = Node(start, None, 0.0)\n        nodes = [root]\n\n        cell = max(1.0, 0.8 * self.step_size)\n        grid = {}\n        self._grid_add(grid, root, cell)\n\n        occ_cell = max(0.5, 0.6 * self.step_size)\n        occ_best = {self._grid_key(start, occ_cell): 0.0}\n\n        success = False\n        goal_node = None\n        best_cost = float('inf')\n        best_path_pts = None\n\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            # Sampling\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                x_rand = self._sample(start, goal, best_cost)\n\n            # Nearest\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n            # Bounds and node collision\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Edge collision for candidate parent\n            if self._is_edge_in_obstacle(n_near.position, x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            base_cost = n_near.cost + self._dist(n_near.position, x_new_pos)\n\n            # Duplicate suppression\n            ok = self._occ_accept(occ_best, x_new_pos, base_cost, occ_cell, self.occ_relax)\n            if not ok:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Commit new node\n            x_new = Node(x_new_pos, None, base_cost)\n            x_new.attach(n_near)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            self._occ_update(occ_best, x_new_pos, base_cost, occ_cell)\n\n            # Local grandparent shortcut\n            gp = n_near.parent\n            if gp is not None:\n                alt = gp.cost + self._dist(gp.position, x_new.position)\n                if alt + 1e-12 < x_new.cost:\n                    if not self._is_edge_in_obstacle(gp.position, x_new.position, obstacles, is_3d):\n                        x_new.attach(gp)\n                        x_new.cost = alt\n                        self._occ_update(occ_best, x_new_pos, alt, occ_cell)\n\n            # Tiny greedy connect toward goal (few validated steps)\n            cur = x_new\n            for _ in range(self.connect_steps):\n                if self._dist(cur.position, goal) <= self.connect_radius_factor * self.step_size:\n                    break\n                step_pos = self._steer(cur.position, goal, self.step_size)\n                if not self._in_bounds(step_pos) or self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(cur.position, step_pos, obstacles, is_3d):\n                    break\n                c_cost = cur.cost + self._dist(cur.position, step_pos)\n                if not self._occ_accept(occ_best, step_pos, c_cost, occ_cell, self.occ_relax):\n                    break\n                nxt = Node(step_pos, None, c_cost)\n                nxt.attach(cur)\n                nodes.append(nxt)\n                self._grid_add(grid, nxt, cell)\n                self._occ_update(occ_best, step_pos, c_cost, occ_cell)\n                # Local grandparent shortcut for connect step\n                gp2 = cur.parent\n                if gp2 is not None:\n                    alt2 = gp2.cost + self._dist(gp2.position, nxt.position)\n                    if alt2 + 1e-12 < nxt.cost:\n                        if not self._is_edge_in_obstacle(gp2.position, nxt.position, obstacles, is_3d):\n                            nxt.attach(gp2)\n                            nxt.cost = alt2\n                            self._occ_update(occ_best, step_pos, alt2, occ_cell)\n                cur = nxt\n\n            # Try direct goal connection when near\n            improved = False\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                r_conn = self.connect_radius_factor * self.step_size\n                tip = cur\n                if self._dist(tip.position, goal) <= r_conn:\n                    if not self._is_edge_in_obstacle(tip.position, goal, obstacles, is_3d):\n                        g_cost = tip.cost + self._dist(tip.position, goal)\n                        if g_cost + 1e-12 < best_cost:\n                            if goal_node is None:\n                                goal_node = Node(goal, None, g_cost)\n                                goal_node.attach(tip)\n                                nodes.append(goal_node)\n                            else:\n                                goal_node.attach(tip)\n                                goal_node.cost = g_cost\n                            best_cost = g_cost\n                            success = True\n                            found_first = True\n                            improved = True\n\n            # Post-improvement polishing\n            if improved and goal_node is not None:\n                cur_path = self._extract_path(goal_node)\n                cur_path = self._compress(cur_path, obstacles, is_3d)\n                cur_path = self._shortcuts(cur_path, obstacles, is_3d, self.online_shortcuts_per_improve)\n                L = self._path_length(cur_path)\n                if L + 1e-12 < best_cost:\n                    best_cost = L\n                best_path_pts = cur_path\n                post_iters = 0\n                no_improve = 0\n            else:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        # Final path\n        path = []\n        if success and goal_node is not None:\n            if best_path_pts is None:\n                path = self._extract_path(goal_node)\n                path = self._compress(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n            else:\n                path = self._shortcuts(best_path_pts, obstacles, is_3d, self.smoothing_iters)\n\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # --------- Utilities ---------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 390451501\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Spatial hashing\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        limit = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > limit:\n                limit = self.bounds[i]\n        limit = limit * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # Sampling with informed gating after first solution\n    def _sample(self, start, goal, c_best):\n        if c_best < float('inf'):\n            for _ in range(120):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p):\n                    if self._dist(p, start) + self._dist(p, goal) <= c_best:\n                        return p\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jitter = 0.5 * self.step_size\n            return tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    # Occupancy cost ledger\n    def _occ_accept(self, occ_best, pos, cost, cell, relax):\n        k = self._grid_key(pos, cell)\n        prev = occ_best.get(k, float('inf'))\n        return cost < prev * relax\n\n    def _occ_update(self, occ_best, pos, cost, cell):\n        k = self._grid_key(pos, cell)\n        prev = occ_best.get(k, float('inf'))\n        if cost < prev:\n            occ_best[k] = cost\n\n    # Path utilities\n    def _extract_path(self, goal_node):\n        seq = []\n        cur = goal_node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
            "objective": 2.59026,
            "time_improvement": -73.0,
            "length_improvement": 19.0,
            "smoothness_improvement": 1563.0,
            "node_improvement": 9.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06812853813171386,
                    "num_nodes_avg": 406.1,
                    "path_length_avg": 156.52382632264067,
                    "smoothness_avg": 0.05238387996289982,
                    "success_improvement": 0.0,
                    "time_improvement": -167.18335815808737,
                    "node_improvement": -2.2664316293125157,
                    "length_improvement": 14.20681051381224,
                    "smoothness_improvement": 719.921474835408,
                    "objective_score": -38.03131376496182
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.16287810802459718,
                    "num_nodes_avg": 1172.8,
                    "path_length_avg": 229.408680422303,
                    "smoothness_avg": 0.09093924935533,
                    "success_improvement": 0.0,
                    "time_improvement": -1.673422716490134,
                    "node_improvement": 21.198683061210776,
                    "length_improvement": 23.4167793122916,
                    "smoothness_improvement": 2239.9323868063857,
                    "objective_score": 24.747702706459847
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0729496955871582,
                    "num_nodes_avg": 734.6,
                    "path_length_avg": 121.75542214035515,
                    "smoothness_avg": 0.1438275075521862,
                    "success_improvement": 0.0,
                    "time_improvement": -48.7201895619418,
                    "node_improvement": 6.598855689764778,
                    "length_improvement": 19.135845984544524,
                    "smoothness_improvement": 1729.4752798215147,
                    "objective_score": 5.512827121251748
                }
            ],
            "success_rate": 1.0
        },
        "objective": 12.600000000000001,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Suboptimal parent selection and rewiring (fixed/limited neighbor sets, missing or stale subtree cost updates) producing longer-than-necessary branches.\n   - Over-aggressive local pruning/duplicate suppression that removes near-cost alternatives in narrow corridors, blocking shorter detours.\n   - Greedy multi-step connections that commit zig-zag segments; in some cases, insufficient or delayed smoothing leaves kinks in the final path.\n   - High per-edge collision-check overhead and wide near sets limiting opportunities for iterative path straightening.\n   - Informed sampling not tightly coupled with immediate local straightening, allowing meanders to persist."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Immediate local grandparent shortcut at node insertion and during short, validated goal-directed connects.\n   - Tiny greedy connect (few steps) toward the goal to create longer straight segments without over-committing.\n   - Relaxed per-cell occupancy-cost acceptance to preserve alternative corridor nodes for later optimization.\n   - Consistent compression and bounded shortcutting after each improvement and at termination.\n   - Line/goal-biased informed sampling with a near-goal direct bridge attempt.\n2. Expected mechanism of impact:\n   - Early straightening reduces kinks and collapses unnecessary bends, directly lowering total path length.\n   - Maintaining multiple feasible traces enables post-processing to stitch straighter segments around obstacles.\n   - Short, validated goalward steps and near-goal bridging remove end-of-path meanders.\n   - Focused sampling concentrates growth along low-cost manifolds, yielding shorter connections and cleaner polylines."
        }
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -24.971436625701273,
                "time_improvement": 62.0,
                "length_improvement": 9.0,
                "smoothness_improvement": 168.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.009481477737426757,
                        "num_nodes_avg": 112.0,
                        "path_length_avg": 170.25136521926942,
                        "smoothness_avg": 0.017004537999713392,
                        "success_improvement": 0.0,
                        "time_improvement": 62.815977978432855,
                        "node_improvement": 71.7955175018887,
                        "length_improvement": 6.682528917796031,
                        "smoothness_improvement": 166.15794564080122,
                        "objective_score": 23.68510047241148
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.0245816707611084,
                        "num_nodes_avg": 299.2,
                        "path_length_avg": 258.5973544494462,
                        "smoothness_avg": 0.010851066788952054,
                        "success_improvement": 0.0,
                        "time_improvement": 84.6553804394982,
                        "node_improvement": 79.89652623798965,
                        "length_improvement": 13.67275977263268,
                        "smoothness_improvement": 179.20576418723118,
                        "objective_score": 34.496298816365226
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.030178475379943847,
                        "num_nodes_avg": 287.8,
                        "path_length_avg": 139.5271231166937,
                        "smoothness_avg": 0.020290033291575655,
                        "success_improvement": 0.0,
                        "time_improvement": 38.47611641047452,
                        "node_improvement": 63.40750158931977,
                        "length_improvement": 7.332728393521491,
                        "smoothness_improvement": 158.08772581437248,
                        "objective_score": 16.732910588327112
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
                "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -17.205069232007403,
                "time_improvement": 34.0,
                "length_improvement": 10.0,
                "smoothness_improvement": 176.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.0216599702835083,
                        "num_nodes_avg": 94.5,
                        "path_length_avg": 179.3326139424124,
                        "smoothness_avg": 0.016628736549943037,
                        "success_improvement": 0.0,
                        "time_improvement": 15.05492769030675,
                        "node_improvement": 76.20246789221858,
                        "length_improvement": 1.7049525910466614,
                        "smoothness_improvement": 160.2758368859854,
                        "objective_score": 6.340829046149949
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.02987968921661377,
                        "num_nodes_avg": 216.6,
                        "path_length_avg": 257.061927055405,
                        "smoothness_avg": 0.010384869878880055,
                        "success_improvement": 0.0,
                        "time_improvement": 81.34819768474138,
                        "node_improvement": 85.44648256399921,
                        "length_improvement": 14.185329631590712,
                        "smoothness_improvement": 167.21018190301697,
                        "objective_score": 33.75170799389193
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.046378374099731445,
                        "num_nodes_avg": 257.2,
                        "path_length_avg": 128.26306667164565,
                        "smoothness_avg": 0.023576110070462338,
                        "success_improvement": 0.0,
                        "time_improvement": 5.449905826599429,
                        "node_improvement": 67.29815638906548,
                        "length_improvement": 14.813778347593729,
                        "smoothness_improvement": 199.8863798888539,
                        "objective_score": 11.522670655980336
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "Beam-guided BiRRT with ancestor line-of-sight compression and spatial hashing (BG-Connect-LOS). The planner alternates tree growth from start and goal using a small beam of guided samples, accelerates nearest lookups with a grid hash, suppresses near-duplicate nodes, and selects a parent among recent ancestors that maintains direct line-of-sight to the new point to compress chains. A short, capped greedy connect links the two trees. Upon success, a bounded shortcut pass refines the path. This reduces expansions and collision checks while improving path quality and smoothness.",
            "planning_mechanism": "At each iteration, pick the active tree and generate a small beam of guided samples biased toward the opposite root. For each sample: find a nearby node via spatial hashing, steer by a fixed step, enforce node and edge collision checks, reject near-duplicates, and pick an ancestor parent with clear line-of-sight to minimize added cost. Insert the node and attempt a capped greedy connect from the opposite tree toward it; if the two trees meet, extract and lightly shortcut the path. Alternate trees and stop early on success.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        beam_width=3,\n        goal_bias=0.15,\n        connect_steps_limit=20,\n        min_separation_factor=0.6,\n        grid_cell_factor=1.0,\n        los_lookback_depth=8,\n        shortcut_attempts=40\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.connect_steps_limit = connect_steps_limit\n        self.min_separation_factor = min_separation_factor\n        self.grid_cell_factor = grid_cell_factor\n        self.los_lookback_depth = los_lookback_depth\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dims = len(bounds)\n        is_3d = dims == 3\n\n        # Parameters derived from step_size\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root = Node(goal_position, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root, is_3d)\n        self._grid_insert(grid_b, goal_root, is_3d)\n\n        success_state = False\n        extracted_path = []\n\n        for _ in range(self.max_iter):\n            # Alternate trees by swapping references each loop\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, goal_position),\n                (tree_b, grid_b, tree_a, grid_a, start_position),\n            ]:\n                made_progress = False\n\n                for _beam in range(self.beam_width):\n                    sample = self._sample_guided(bounds, obstacles, is_3d, attractor)\n\n                    nearest = self._nearest_by_grid(active_tree, active_grid, sample, is_3d)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos, bounds):\n                        continue\n                    if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                        continue\n                    if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                        continue\n                    if self._has_near_duplicate(active_grid, new_pos, self.min_separation, is_3d):\n                        continue\n\n                    # Choose parent among LOS-capable ancestors to compress path\n                    parent = self._choose_ancestor_parent(nearest, new_pos, obstacles, is_3d)\n                    new_cost = parent.cost + self._distance(parent.position, new_pos)\n\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node, is_3d)\n                    made_progress = True\n\n                    # Try capped greedy connect from the opposite tree toward new_node\n                    connect_node = self._attempt_connect(\n                        other_tree, other_grid, new_node.position, obstacles, is_3d, nodes, edges, bounds\n                    )\n                    if connect_node is not None:\n                        # Trees meet at new_node.position; extract path\n                        path_a = self._path_from_root(new_node)\n                        path_b = self._path_from_root(connect_node)\n                        # Remove duplicate joint if equal\n                        if path_a and path_b and path_a[-1] == path_b[-1]:\n                            path_b = path_b[:-1]\n                        raw_path = path_a + path_b[::-1]\n                        # Light shortcut smoothing\n                        smoothed = self._shortcut_path(raw_path, obstacles, is_3d, attempts=self.shortcut_attempts)\n                        extracted_path = smoothed if smoothed else raw_path\n                        success_state = True\n                        return PlannerResult(True, extracted_path, nodes, edges)\n\n                # If neither beam sample made progress for this tree, continue with the other\n                if not made_progress:\n                    continue\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # --------- Core Geometry / Utilities ---------\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _within_bounds(self, pos, bounds):\n        for i in range(len(bounds)):\n            if pos[i] < 0.0 or pos[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= 1e-9:\n            return from_pos\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * r for d in range(len(from_pos)))\n\n    def _sample_guided(self, bounds, obstacles, is_3d, target):\n        # Mild guidance: with some probability sample exactly target, else blend toward target\n        while True:\n            if random.random() < self.goal_bias:\n                p = target\n            else:\n                rand = tuple(random.uniform(0.0, bounds[d]) for d in range(len(bounds)))\n                alpha = 0.2\n                p = tuple(alpha * target[d] + (1.0 - alpha) * rand[d] for d in range(len(bounds)))\n            if self._within_bounds(p, bounds) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _path_from_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\n\n    # --------- Spatial Hash (Grid) ---------\n\n    def _cell_of(self, pos):\n        # integer grid cell indices\n        if len(pos) == 3:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        else:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node, is_3d):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _has_near_duplicate(self, grid, pos, radius, is_3d):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    def _nearest_by_grid(self, tree, grid, pos, is_3d, ring_limit=3):\n        # Search neighborhood rings; fallback to linear scan if not found\n        cell = self._cell_of(pos)\n        best = None\n        best_d = float(\"inf\")\n\n        if is_3d:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best_d = d\n                                        best = n\n                                        found = True\n                if found and best is not None:\n                    return best\n        else:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                                    found = True\n                if found and best is not None:\n                    return best\n\n        # Fallback\n        if not tree:\n            return None\n        return min(tree, key=lambda n: self._distance(n.position, pos))\n\n    # --------- Parent selection via LOS to ancestors ---------\n\n    def _choose_ancestor_parent(self, nearest, new_pos, obstacles, is_3d):\n        best_parent = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        steps = 0\n        cur = nearest\n        while cur is not None and steps < self.los_lookback_depth:\n            if not self._is_edge_in_obstacle(cur.position, new_pos, obstacles, is_3d):\n                cand_cost = cur.cost + self._distance(cur.position, new_pos)\n                if cand_cost < best_cost:\n                    best_cost = cand_cost\n                    best_parent = cur\n            cur = cur.parent\n            steps += 1\n        return best_parent\n\n    # --------- Connect attempt ---------\n\n    def _attempt_connect(self, tree, grid, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest_by_grid(tree, grid, target_pos, is_3d)\n        if nearest is None:\n            return None\n\n        current = nearest\n        for _ in range(self.connect_steps_limit):\n            step_pos = self._steer(current.position, target_pos)\n            if not self._within_bounds(step_pos, bounds):\n                return None\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                return None\n\n            # If close enough to target and direct edge exists, finalize with exact target node\n            if self._distance(step_pos, target_pos) <= 1e-6 or (\n                self._distance(step_pos, target_pos) <= self.step_size and\n                not self._is_edge_in_obstacle(step_pos, target_pos, obstacles, is_3d) and\n                not self._is_in_obstacle(target_pos, obstacles, is_3d)\n            ):\n                # Add intermediate step node if it is not exactly current\n                if self._distance(current.position, step_pos) > 1e-9:\n                    if not self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                        new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n                        current.add_child(new_node)\n                        tree.append(new_node)\n                        nodes.append(new_node)\n                        edges.append((current, new_node))\n                        self._grid_insert(grid, new_node, is_3d)\n                        current = new_node\n                    else:\n                        # If duplicate exists, try using current as is\n                        pass\n                # Add final node at the exact target position to guarantee path merge\n                final_node = Node(target_pos, parent=current, cost=current.cost + self._distance(current.position, target_pos))\n                current.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((current, final_node))\n                self._grid_insert(grid, final_node, is_3d)\n                return final_node\n\n            # Regular step addition with duplicate suppression\n            if self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                # Progress is negligible; stop trying to avoid loops\n                return None\n\n            new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node, is_3d)\n            current = new_node\n\n        return None\n\n    # --------- Collision Checking ---------\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d):\n        distance = self._distance(from_pos, to_pos)\n        resolution = max(0.5, min(1.0, self.step_size * 0.5))\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    # --------- Shortcut Smoothing (bounded) ---------\n\n    def _shortcut_path(self, path, obstacles, is_3d, attempts=40):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        n = len(pts)\n        tries = 0\n        i = 0\n        # Greedy forward skipping with bounded iterations\n        while i < len(pts) - 2 and tries < attempts:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                    # Remove intermediates\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n            tries += 1\n        return pts",
            "objective": -28.86257,
            "time_improvement": 43.0,
            "length_improvement": 15.0,
            "smoothness_improvement": 1410.0,
            "node_improvement": 90.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03400664329528809,
                    "num_nodes_avg": 52.1,
                    "path_length_avg": 171.51876006638196,
                    "smoothness_avg": 0.050501544373221775,
                    "success_improvement": 0.0,
                    "time_improvement": -33.36568499023374,
                    "node_improvement": 86.87987912364643,
                    "length_improvement": 5.987849718937115,
                    "smoothness_improvement": 690.45883529979,
                    "objective_score": -2.964701489208901
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030187082290649415,
                    "num_nodes_avg": 92.2,
                    "path_length_avg": 234.31486940525366,
                    "smoothness_avg": 0.08620583217892899,
                    "success_improvement": 0.0,
                    "time_improvement": 81.1563136658539,
                    "node_improvement": 93.8050124302896,
                    "length_improvement": 21.77895221296278,
                    "smoothness_improvement": 2118.138153515002,
                    "objective_score": 48.004956195108846
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009754443168640136,
                    "num_nodes_avg": 73.2,
                    "path_length_avg": 124.45355479806292,
                    "smoothness_avg": 0.11960663519260235,
                    "success_improvement": 0.0,
                    "time_improvement": 80.11393158758125,
                    "node_improvement": 90.69294342021614,
                    "length_improvement": 17.343874744565582,
                    "smoothness_improvement": 1421.3875712064366,
                    "objective_score": 41.54744217904591
                }
            ],
            "success_rate": 1.0
        },
        "objective": 7.0,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Limited parent selection to local neighbors without leveraging line-of-sight to deeper ancestors, leaving avoidable kinks\n   - Weak or fixed rewiring neighborhoods and no descendant cost propagation, reducing chances to shorten existing branches\n   - Early termination on first feasible connection with no continued refinement\n   - Absence of shortcut/smoothing post-processing, preserving unnecessary waypoints\n   - Short, incremental steering that accumulates zig-zag segments, inflating path length\n   - Uninformed or weakly guided sampling that induces detours in cluttered regions"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Target-biased bidirectional growth that favors progress toward the opposite root\n   - Line-of-sight reparenting to recent ancestors for path compression\n   - Near-duplicate suppression to prevent redundant, closely spaced nodes\n   - Greedy, directed connection between trees with final direct-link checks\n   - Bounded shortcut/smoothing on the extracted path\n2. Expected mechanism of impact:\n   - Fewer kinks and detours by preferring straight, obstacle-free ancestor links\n   - More direct tree merges due to guided expansion and targeted connecting moves\n   - Reduced waypoint count and eliminated micro-oscillations via duplicate suppression\n   - Post-processing removes remaining unnecessary segments, shortening the final path"
        }
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -24.971436625701273,
                "time_improvement": 62.0,
                "length_improvement": 9.0,
                "smoothness_improvement": 168.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.009481477737426757,
                        "num_nodes_avg": 112.0,
                        "path_length_avg": 170.25136521926942,
                        "smoothness_avg": 0.017004537999713392,
                        "success_improvement": 0.0,
                        "time_improvement": 62.815977978432855,
                        "node_improvement": 71.7955175018887,
                        "length_improvement": 6.682528917796031,
                        "smoothness_improvement": 166.15794564080122,
                        "objective_score": 23.68510047241148
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.0245816707611084,
                        "num_nodes_avg": 299.2,
                        "path_length_avg": 258.5973544494462,
                        "smoothness_avg": 0.010851066788952054,
                        "success_improvement": 0.0,
                        "time_improvement": 84.6553804394982,
                        "node_improvement": 79.89652623798965,
                        "length_improvement": 13.67275977263268,
                        "smoothness_improvement": 179.20576418723118,
                        "objective_score": 34.496298816365226
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.030178475379943847,
                        "num_nodes_avg": 287.8,
                        "path_length_avg": 139.5271231166937,
                        "smoothness_avg": 0.020290033291575655,
                        "success_improvement": 0.0,
                        "time_improvement": 38.47611641047452,
                        "node_improvement": 63.40750158931977,
                        "length_improvement": 7.332728393521491,
                        "smoothness_improvement": 158.08772581437248,
                        "objective_score": 16.732910588327112
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m3",
                "algorithm_description": "Bi-Guide ARC: A bidirectional, goal-aware RRT*-Connect with Adaptive Radius, spatial hashing, subtree cost propagation, and post-planning shortcut smoothing. It balances fast greedy connections with cost-optimal rewiring, focuses samples within an informed ellipsoid after the first solution, and uses a lightweight grid index for efficient nearest/near queries to improve path length and smoothness with lower planning time.",
                "planning_mechanism": "Alternate growing start/goal trees: sample (goal-biased; informed after first path), steer one step, select best parent within an adaptive radius, add if both node and edge are collision-free, locally rewire with subtree cost updates, then attempt a bounded greedy connect of the opposite tree to the new node. Maintain best path and stop upon time/iteration/no-improvement limits; finally apply randomized shortcut smoothing to the best path.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def detach_from_parent(self):\n        if self.parent is not None and self in self.parent.children:\n            self.parent.children.remove(self)\n        self.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 6000,\n        step_size: float = 5.0,\n        goal_bias: float = 0.15,\n        base_radius: float = 35.0,\n        max_radius: float = 60.0,\n        connect_steps: int = 20,\n        post_opt_iters: int = 300,\n        no_improve_limit: int = 180,\n        time_limit_sec: float = 20.0,\n        smooth_attempts: int = 120\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.base_radius = base_radius\n        self.max_radius = max_radius\n        self.connect_steps = connect_steps\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.time_limit_sec = time_limit_sec\n        self.smooth_attempts = smooth_attempts\n\n        # Spatial hash cell size\n        self.cell_size = max(8.0, step_size * 2.0)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Core containers\n        nodes = []\n        edges = []\n        success_state = False\n        best_path = []\n        best_cost = float('inf')\n\n        # Initialize trees and spatial hashes\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Dist between start and goal\n        c_min = self._dist(start_position, goal_position)\n\n        # States\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            # Alternate expansion direction\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n                grid_a, grid_b = grid_start, grid_goal\n                root_a, root_b = start_root, goal_root\n                sample_goal = goal_position\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n                grid_a, grid_b = grid_goal, grid_start\n                root_a, root_b = goal_root, start_root\n                sample_goal = start_position\n\n            # Sampling with goal bias and informed focus\n            x_rand = self._sample(bounds, obstacles, is_3d, start_position, goal_position, best_cost, c_min, sample_goal)\n\n            # Nearest in tree_a\n            a_near = self._nearest(grid_a, tree_a, x_rand, bounds)\n            a_new_pos = self._steer(a_near.position, x_rand, self.step_size)\n\n            # Bound check\n            if not self._in_bounds(a_new_pos, bounds):\n                self._advance_counters(found_first, True)\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Node and edge collision checks before adding\n            if self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n            if self._hit_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Best parent selection within adaptive radius\n            rad = self._adaptive_radius(len(tree_a), dim)\n            neighbors = self._grid_neighbors(grid_a, a_new_pos, rad)\n            if not neighbors:\n                neighbors = [a_near]\n\n            best_parent = None\n            best_g = float('inf')\n            for cand in neighbors:\n                if self._hit_obstacle(cand.position, a_new_pos, obstacles, is_3d):\n                    continue\n                g = cand.cost + self._dist(cand.position, a_new_pos)\n                if g < best_g:\n                    best_g = g\n                    best_parent = cand\n\n            if best_parent is None:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Add new node to tree_a\n            a_new = Node(a_new_pos, parent=None, cost=best_g)\n            best_parent.add_child(a_new)\n            tree_a.append(a_new)\n            nodes.append(a_new)\n            edges.append((best_parent, a_new))\n            self._grid_add(grid_a, a_new)\n\n            # Local rewiring from a_new\n            self._rewire_from(a_new, neighbors, obstacles, is_3d, edges)\n\n            # Attempt to connect tree_b to a_new (bounded)\n            b_meet = self._attempt_connect(tree_b, grid_b, a_new, obstacles, is_3d, bounds, nodes, edges, dim)\n\n            if b_meet is not None:\n                # Merge full path\n                if root_a is start_root:\n                    path_a = a_new.path_from_root()\n                    path_b = b_meet.path_from_root()\n                else:\n                    path_a = b_meet.path_from_root()\n                    path_b = a_new.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged = path_a + path_b[-2::-1]\n                else:\n                    merged = path_a + path_b[::-1]\n\n                cost = self._path_cost(merged)\n                if cost < best_cost - 1e-9:\n                    best_cost = cost\n                    best_path = merged\n                    success_state = True\n                    no_improve = 0\n                else:\n                    no_improve += 1\n\n                if not found_first:\n                    found_first = True\n                    post_iters = 0\n                else:\n                    post_iters += 1\n\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n            else:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n\n        # Final smoothing of best path\n        if success_state and best_path:\n            best_path = self._shortcut_smooth(best_path, obstacles, is_3d, attempts=self.smooth_attempts)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ------------------ Spatial Hash ------------------\n    def _key(self, pos):\n        return tuple(int(pos[d] // self.cell_size) for d in range(len(pos)))\n\n    def _grid_add(self, grid, node):\n        k = self._key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_neighbors(self, grid, pos, radius):\n        # Collect nodes in cells within radius\n        dim = len(pos)\n        span = int(max(1, math.ceil(radius / self.cell_size)))\n        key_center = self._key(pos)\n        result = []\n        if dim == 2:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    k = (key_center[0] + dx, key_center[1] + dy)\n                    if k in grid:\n                        for n in grid[k]:\n                            if self._dist(n.position, pos) <= radius:\n                                result.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        k = (key_center[0] + dx, key_center[1] + dy, key_center[2] + dz)\n                        if k in grid:\n                            for n in grid[k]:\n                                if self._dist(n.position, pos) <= radius:\n                                    result.append(n)\n        return result\n\n    def _nearest(self, grid, tree, pos, bounds):\n        # Try increasing radii using grid; fallback to full scan\n        radius = self.cell_size\n        for _ in range(4):\n            cands = self._grid_neighbors(grid, pos, radius)\n            if cands:\n                return min(cands, key=lambda n: self._dist(n.position, pos))\n            radius *= 2.0\n        return min(tree, key=lambda n: self._dist(n.position, pos))\n\n    # ------------------ Connect Attempt ------------------\n    def _attempt_connect(self, tree, grid, target_node, obstacles, is_3d, bounds, nodes, edges, dim):\n        target_pos = target_node.position\n\n        # Direct connect via best parent in radius\n        rad = self._adaptive_radius(len(tree), dim)\n        neigh = self._grid_neighbors(grid, target_pos, rad)\n        if not neigh:\n            # include nearest if none\n            neigh = [self._nearest(grid, tree, target_pos, bounds)]\n        best_parent = None\n        best_cost = float('inf')\n        for cand in neigh:\n            if self._hit_obstacle(cand.position, target_pos, obstacles, is_3d):\n                continue\n            g = cand.cost + self._dist(cand.position, target_pos)\n            if g < best_cost:\n                best_cost = g\n                best_parent = cand\n        if best_parent is not None and not self._is_in_obstacle(target_pos, obstacles, is_3d):\n            meet = Node(target_pos, parent=None, cost=best_cost)\n            best_parent.add_child(meet)\n            tree.append(meet)\n            nodes.append(meet)\n            edges.append((best_parent, meet))\n            self._grid_add(grid, meet)\n            # Local rewiring at seam improves junction quality\n            seam_neighbors = self._grid_neighbors(grid, target_pos, rad)\n            self._rewire_from(meet, seam_neighbors, obstacles, is_3d, edges)\n            return meet\n\n        # Greedy bounded stepping toward target\n        current = self._nearest(grid, tree, target_pos, bounds)\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(current.position, target_pos, self.step_size)\n            if not self._in_bounds(nxt, bounds):\n                return None\n            if self._is_in_obstacle(nxt, obstacles, is_3d):\n                return None\n            if self._hit_obstacle(current.position, nxt, obstacles, is_3d):\n                return None\n\n            # Insert with best parent among neighbors around nxt\n            neigh2 = self._grid_neighbors(grid, nxt, rad)\n            if not neigh2:\n                neigh2 = [current]\n            best_p = None\n            best_g2 = float('inf')\n            for cand in neigh2:\n                if self._hit_obstacle(cand.position, nxt, obstacles, is_3d):\n                    continue\n                g2 = cand.cost + self._dist(cand.position, nxt)\n                if g2 < best_g2:\n                    best_g2 = g2\n                    best_p = cand\n            if best_p is None:\n                return None\n\n            new_b = Node(nxt, parent=None, cost=best_g2)\n            best_p.add_child(new_b)\n            tree.append(new_b)\n            nodes.append(new_b)\n            edges.append((best_p, new_b))\n            self._grid_add(grid, new_b)\n\n            self._rewire_from(new_b, neigh2, obstacles, is_3d, edges)\n\n            if self._dist(new_b.position, target_pos) <= self.step_size:\n                if (not self._is_in_obstacle(target_pos, obstacles, is_3d)) and (not self._hit_obstacle(new_b.position, target_pos, obstacles, is_3d)):\n                    final_b = Node(target_pos, parent=None, cost=new_b.cost + self._dist(new_b.position, target_pos))\n                    new_b.add_child(final_b)\n                    tree.append(final_b)\n                    nodes.append(final_b)\n                    edges.append((new_b, final_b))\n                    self._grid_add(grid, final_b)\n                    return final_b\n                return None\n\n            current = new_b\n            steps += 1\n\n        return None\n\n    # ------------------ Rewiring ------------------\n    def _rewire_from(self, pivot, neighbors, obstacles, is_3d, edges):\n        for nb in neighbors:\n            if nb is pivot or nb.parent is None:\n                continue\n            if self._hit_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                continue\n            new_cost = pivot.cost + self._dist(pivot.position, nb.position)\n            if new_cost + 1e-12 < nb.cost:\n                old_parent = nb.parent\n                nb.detach_from_parent()\n                pivot.add_child(nb)\n                try:\n                    edges.remove((old_parent, nb))\n                except Exception:\n                    pass\n                edges.append((pivot, nb))\n                delta = new_cost - nb.cost\n                nb.cost = new_cost\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        # BFS update costs down the subtree to maintain coherence\n        queue = [node]\n        while queue:\n            cur = queue.pop(0)\n            for ch in cur.children:\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                queue.append(ch)\n\n    # ------------------ Sampling ------------------\n    def _sample(self, bounds, obstacles, is_3d, start, goal, c_best, c_min, biased_goal):\n        dim = len(bounds)\n        # Goal bias\n        if random.random() < self.goal_bias:\n            target = goal if biased_goal == goal else start\n            if not self._is_in_obstacle(target, obstacles, is_3d):\n                return target\n\n        # Informed sampling after first solution\n        if c_best < float('inf') and c_min > 1e-12:\n            for _ in range(50):\n                x = self._sample_informed_ellipsoid(start, goal, c_best, c_min, bounds)\n                if not self._is_in_obstacle(x, obstacles, is_3d):\n                    return x\n\n        # Uniform fallback\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]), random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_informed_ellipsoid(self, start, goal, c_best, c_min, bounds):\n        # Prolate ellipsoid with foci at start and goal\n        dim = len(bounds)\n        r1 = c_best / 2.0\n        r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        a1 = self._unit(self._vec(goal, start))\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r2)\n        else:\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._unit(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._unit(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r2, r2)\n\n        u = self._sample_unit_ball(dim)\n        x = [center[d] for d in range(dim)]\n        for i in range(dim):\n            for d in range(dim):\n                x[d] += basis[i][d] * radii[i] * u[i]\n        # Clamp to bounds\n        x = tuple(min(max(x[d], 0.0), bounds[d]) for d in range(dim))\n        return x\n\n    def _sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(vi * vi for vi in v))\n            if n > 1e-12:\n                v = [vi / n for vi in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    # ------------------ Geometry/Collision ------------------\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _vec(self, a, b):\n        return tuple(a[i] - b[i] for i in range(len(a)))\n\n    def _norm(self, v):\n        return math.sqrt(sum(vi * vi for vi in v))\n\n    def _unit(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return tuple(0.0 for _ in v)\n        return tuple(vi / n for vi in v)\n\n    def _cross(self, a, b):\n        # Only used in 3D informed sampling\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0.0 <= pos[i] <= bounds[i] for i in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _hit_obstacle(self, a, b, obstacles, is_3d, res=1.0):\n        L = self._dist(a, b)\n        steps = max(1, int(L / res))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(len(a)))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _path_cost(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(len(path) - 1):\n            s += self._dist(path[i], path[i + 1])\n        return s\n\n    # ------------------ Controls ------------------\n    def _adaptive_radius(self, n, dim):\n        if n <= 1:\n            return self.base_radius\n        # RRT* style shrinkage\n        r = self.base_radius * (math.log(n + 1) / (n + 1)) ** (1.0 / dim)\n        r = max(self.step_size * 1.5, min(self.max_radius, r))\n        return r\n\n    def _post_update(self, found_first, post_iters, no_improve):\n        if found_first:\n            post_iters += 1\n            no_improve += 1\n        return post_iters, no_improve\n\n    def _should_stop(self, found_first, post_iters, no_improve):\n        if not found_first:\n            return False\n        if post_iters >= self.post_opt_iters:\n            return True\n        if no_improve >= self.no_improve_limit:\n            return True\n        return False\n\n    # ------------------ Smoothing ------------------\n    def _shortcut_smooth(self, path, obstacles, is_3d, attempts=100):\n        if len(path) < 3:\n            return path[:]\n        best = path[:]\n        best_cost = self._path_cost(best)\n        n = len(best)\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = best[i]\n            b = best[j]\n            if not self._hit_obstacle(a, b, obstacles, is_3d):\n                # shortcut\n                new_path = best[:i + 1] + best[j:]\n                new_cost = self._path_cost(new_path)\n                if new_cost < best_cost - 1e-9:\n                    best = new_path\n                    best_cost = new_cost\n                    n = len(best)\n        # Greedy corner culling\n        changed = True\n        while changed and len(best) > 2:\n            changed = False\n            k = 1\n            while k < len(best) - 1:\n                if not self._hit_obstacle(best[k - 1], best[k + 1], obstacles, is_3d):\n                    best.pop(k)\n                    changed = True\n                else:\n                    k += 1\n        return best",
                "objective": 14.38104,
                "time_improvement": -107.0,
                "length_improvement": 18.0,
                "smoothness_improvement": 1417.0,
                "node_improvement": 44.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.11155118942260742,
                        "num_nodes_avg": 362.3,
                        "path_length_avg": 155.15168551902272,
                        "smoothness_avg": 0.04619305292125599,
                        "success_improvement": 0.0,
                        "time_improvement": -337.47630895645335,
                        "node_improvement": 8.76353563334173,
                        "length_improvement": 14.95890263123767,
                        "smoothness_improvement": 623.021588037589,
                        "objective_score": -89.15244316800546
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.08458755016326905,
                        "num_nodes_avg": 414.7,
                        "path_length_avg": 238.39539805931153,
                        "smoothness_avg": 0.09691449918612544,
                        "success_improvement": 0.0,
                        "time_improvement": 47.197902476841236,
                        "node_improvement": 72.13599408721359,
                        "length_improvement": 20.416754296733227,
                        "smoothness_improvement": 2393.679868751244,
                        "objective_score": 38.37782266484852
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.06439132690429687,
                        "num_nodes_avg": 395.9,
                        "path_length_avg": 123.34270106287966,
                        "smoothness_avg": 0.1047845601402689,
                        "success_improvement": 0.0,
                        "time_improvement": -31.272519594143017,
                        "node_improvement": 49.66306420851876,
                        "length_improvement": 18.081650902303785,
                        "smoothness_improvement": 1232.8518705925312,
                        "objective_score": 7.631494016102023
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "BG-BiRRT-LC: Beam-Guided Bidirectional RRT-Connect with Line-of-Sight Compression, Duplicate Suppression, Spatial Hashing, and Informed Sampling. It prioritizes time efficiency by limiting neighbor/rewire costs, pruning near-duplicates, compressing parents via direct line-of-sight, and using a beam of goal-directed samples with a lightweight grid for fast nearest/near queries.",
            "planning_mechanism": "Alternate expanding start/goal trees: for each side, beam-sample k candidates (goal-biased and informed after first path), pick the most promising, steer one step, validate node and edge, suppress near-duplicates, pick a best parent from a tiny local set, then compress to an ancestor if line-of-sight holds. Attempt a bounded greedy connect from the other tree to the new node. Upon a connection, merge paths and optionally continue a few refinement iterations; finally apply capped shortcut smoothing.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def detach_from_parent(self):\n        if self.parent is not None and self in self.parent.children:\n            self.parent.children.remove(self)\n        self.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 9.0,\n        goal_bias: float = 0.12,\n        beam_k: int = 3,\n        parent_k: int = 5,\n        connect_steps: int = 6,\n        time_limit_sec: float = 15.0,\n        smooth_attempts: int = 80,\n        post_opt_iters: int = 120,\n        no_improve_limit: int = 80,\n        compress_ancestors: int = 3\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.beam_k = max(1, beam_k)\n        self.parent_k = max(1, parent_k)\n        self.connect_steps = connect_steps\n        self.time_limit_sec = time_limit_sec\n        self.smooth_attempts = smooth_attempts\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.compress_ancestors = compress_ancestors\n\n        # Spatial hash cell size and duplicate suppression radii\n        self.cell_size = max(6.0, step_size * 1.5)\n        self.dup_radius = step_size * 1.25\n        self.dup_thresh = step_size * 0.6\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n        success_state = False\n        best_path = []\n        best_cost = float('inf')\n\n        # Roots\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Spatial hashes\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        c_min = self._dist(start_position, goal_position)\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        t0 = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - t0 > self.time_limit_sec:\n                break\n\n            # Alternate expansion\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n                grid_a, grid_b = grid_start, grid_goal\n                root_a, root_b = start_root, goal_root\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n                grid_a, grid_b = grid_goal, grid_start\n                root_a, root_b = goal_root, start_root\n\n            # Beam-guided sampling\n            x_rand = self._beam_sample(bounds, obstacles, is_3d, root_a.position, root_b.position, best_cost, c_min, grid_a, tree_a)\n\n            # Nearest and steer\n            a_near = self._nearest(grid_a, tree_a, x_rand, bounds)\n            a_new_pos = self._steer(a_near.position, x_rand, self.step_size)\n\n            # Bounds and collision checks before adding\n            if not self._in_bounds(a_new_pos, bounds):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n            if self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n            if self._hit_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Duplicate/near-duplicate suppression\n            near_dups = self._grid_neighbors(grid_a, a_new_pos, self.dup_radius)\n            skip = False\n            for nb in near_dups:\n                if self._dist(nb.position, a_new_pos) <= self.dup_thresh:\n                    skip = True\n                    break\n            if skip:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Parent selection among a tiny local set\n            parent_radius = max(self.step_size * 2.0, 12.0)\n            neighbors = self._grid_neighbors(grid_a, a_new_pos, parent_radius)\n            if not neighbors:\n                neighbors = [a_near]\n            # Choose up to parent_k closest neighbors\n            neighbors.sort(key=lambda n: self._dist(n.position, a_new_pos))\n            candidates = neighbors[:self.parent_k]\n\n            best_parent = None\n            best_g = float('inf')\n            for cand in candidates:\n                if self._hit_obstacle(cand.position, a_new_pos, obstacles, is_3d):\n                    continue\n                g = cand.cost + self._dist(cand.position, a_new_pos)\n                if g < best_g:\n                    best_g = g\n                    best_parent = cand\n\n            if best_parent is None:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Line-of-sight compression to ancestors\n            best_parent, best_g = self._compress_parent(best_parent, a_new_pos, best_g, obstacles, is_3d)\n\n            # Add node to tree_a\n            a_new = Node(a_new_pos, parent=None, cost=best_g)\n            best_parent.add_child(a_new)\n            tree_a.append(a_new)\n            nodes.append(a_new)\n            edges.append((best_parent, a_new))\n            self._grid_add(grid_a, a_new)\n\n            # Attempt to connect other tree to this new node\n            b_meet = self._try_connect(tree_b, grid_b, a_new, obstacles, is_3d, bounds, nodes, edges)\n            if b_meet is not None:\n                # Merge path start->goal\n                pathA = a_new.path_from_root()\n                pathB = b_meet.path_from_root()\n                if root_a is start_root:\n                    merged = pathA + pathB[-2::-1]\n                else:\n                    merged = pathB + pathA[-2::-1]\n\n                cost = self._path_cost(merged)\n                if cost < best_cost - 1e-9:\n                    best_cost = cost\n                    best_path = merged\n                    success_state = True\n                    no_improve = 0\n                else:\n                    no_improve += 1\n\n                if not found_first:\n                    found_first = True\n                    post_iters = 0\n                else:\n                    post_iters += 1\n\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n            else:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n\n        # Final smoothing\n        if success_state and best_path:\n            best_path = self._shortcut_smooth(best_path, obstacles, is_3d, attempts=self.smooth_attempts)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------- Spatial Hash ----------------\n    def _key(self, pos):\n        return tuple(int(pos[d] // self.cell_size) for d in range(len(pos)))\n\n    def _grid_add(self, grid, node):\n        k = self._key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_neighbors(self, grid, pos, radius):\n        dim = len(pos)\n        span = int(max(1, math.ceil(radius / self.cell_size)))\n        kc = self._key(pos)\n        result = []\n        if dim == 2:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    k = (kc[0] + dx, kc[1] + dy)\n                    if k in grid:\n                        for n in grid[k]:\n                            if self._dist(n.position, pos) <= radius:\n                                result.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        k = (kc[0] + dx, kc[1] + dy, kc[2] + dz)\n                        if k in grid:\n                            for n in grid[k]:\n                                if self._dist(n.position, pos) <= radius:\n                                    result.append(n)\n        return result\n\n    def _nearest(self, grid, tree, pos, bounds):\n        radius = self.cell_size\n        for _ in range(4):\n            cands = self._grid_neighbors(grid, pos, radius)\n            if cands:\n                return min(cands, key=lambda n: self._dist(n.position, pos))\n            radius *= 2.0\n        return min(tree, key=lambda n: self._dist(n.position, pos))\n\n    # --------------- Beam-Guided Sampling ---------------\n    def _beam_sample(self, bounds, obstacles, is_3d, root_a, root_b, c_best, c_min, grid_a, tree_a):\n        # Goal bias\n        if random.random() < self.goal_bias:\n            goal_tgt = root_b\n            if not self._is_in_obstacle(goal_tgt, obstacles, is_3d):\n                return goal_tgt\n\n        best = None\n        best_score = float('inf')\n        for _ in range(self.beam_k):\n            if c_best < float('inf') and c_min > 1e-12:\n                x = self._sample_informed_ellipsoid(root_a, root_b, c_best, c_min, bounds)\n            else:\n                x = self._sample_uniform_free(bounds, obstacles, is_3d)\n            # Score: favor closeness to opposite root and ease of reaching from current tree\n            near = self._nearest(grid_a, tree_a, x, bounds)\n            score = self._dist(x, root_b) + 0.3 * self._dist(near.position, x)\n            if score < best_score:\n                best_score = score\n                best = x\n        return best\n\n    def _sample_uniform_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]), random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_informed_ellipsoid(self, start, goal, c_best, c_min, bounds):\n        dim = len(bounds)\n        # Prolate ellipsoid with foci at start and goal\n        r1 = c_best / 2.0\n        r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n        center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n        a1 = self._unit(self._vec(goal, start))\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r2)\n        else:\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._unit(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._unit(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r2, r2)\n\n        u = self._sample_unit_ball(dim)\n        x = [center[d] for d in range(dim)]\n        for i in range(dim):\n            for d in range(dim):\n                x[d] += basis[i][d] * radii[i] * u[i]\n        x = tuple(min(max(x[d], 0.0), bounds[d]) for d in range(dim))\n        return x\n\n    def _sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(vi * vi for vi in v))\n            if n > 1e-12:\n                v = [vi / n for vi in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    # --------------- Parent Compression ---------------\n    def _compress_parent(self, parent, new_pos, current_g, obstacles, is_3d):\n        # Try a few ancestors for direct line-of-sight to reduce chain depth\n        anc = parent\n        best_parent = parent\n        best_g = current_g\n        steps = 0\n        while anc is not None and anc.parent is not None and steps < self.compress_ancestors:\n            grand = anc.parent\n            if not self._hit_obstacle(grand.position, new_pos, obstacles, is_3d):\n                g = grand.cost + self._dist(grand.position, new_pos)\n                if g + 1e-12 < best_g:\n                    best_g = g\n                    best_parent = grand\n            anc = grand\n            steps += 1\n        return best_parent, best_g\n\n    # --------------- Connect Attempt ---------------\n    def _try_connect(self, tree, grid, target_node, obstacles, is_3d, bounds, nodes, edges):\n        target_pos = target_node.position\n        connect_thresh = self.step_size * 1.2\n\n        # Try direct connect via best local parent\n        rad = max(self.step_size * 2.0, 12.0)\n        neigh = self._grid_neighbors(grid, target_pos, rad)\n        if not neigh:\n            neigh = [self._nearest(grid, tree, target_pos, bounds)]\n        neigh.sort(key=lambda n: self._dist(n.position, target_pos))\n        candidates = neigh[:self.parent_k]\n        best_parent = None\n        best_g = float('inf')\n        for cand in candidates:\n            if self._hit_obstacle(cand.position, target_pos, obstacles, is_3d):\n                continue\n            g = cand.cost + self._dist(cand.position, target_pos)\n            if g < best_g:\n                best_g = g\n                best_parent = cand\n        if best_parent is not None:\n            if (not self._is_in_obstacle(target_pos, obstacles, is_3d)):\n                meet = Node(target_pos, parent=None, cost=best_g)\n                best_parent.add_child(meet)\n                tree.append(meet)\n                nodes.append(meet)\n                edges.append((best_parent, meet))\n                self._grid_add(grid, meet)\n                return meet\n\n        # Greedy bounded stepping toward target\n        current = self._nearest(grid, tree, target_pos, bounds)\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(current.position, target_pos, self.step_size)\n            if not self._in_bounds(nxt, bounds):\n                return None\n            if self._is_in_obstacle(nxt, obstacles, is_3d):\n                return None\n            if self._hit_obstacle(current.position, nxt, obstacles, is_3d):\n                return None\n\n            # Duplicate suppression in other tree\n            near_dups = self._grid_neighbors(grid, nxt, self.dup_radius)\n            dup = False\n            for nb in near_dups:\n                if self._dist(nb.position, nxt) <= self.dup_thresh:\n                    dup = True\n                    break\n            if dup:\n                return None\n\n            # Choose local parent\n            neigh2 = self._grid_neighbors(grid, nxt, rad)\n            if not neigh2:\n                neigh2 = [current]\n            neigh2.sort(key=lambda n: self._dist(n.position, nxt))\n            cand2 = neigh2[:self.parent_k]\n\n            best_p = None\n            best_g2 = float('inf')\n            for cand in cand2:\n                if self._hit_obstacle(cand.position, nxt, obstacles, is_3d):\n                    continue\n                g2 = cand.cost + self._dist(cand.position, nxt)\n                if g2 < best_g2:\n                    best_g2 = g2\n                    best_p = cand\n            if best_p is None:\n                return None\n\n            new_b = Node(nxt, parent=None, cost=best_g2)\n            best_p.add_child(new_b)\n            tree.append(new_b)\n            nodes.append(new_b)\n            edges.append((best_p, new_b))\n            self._grid_add(grid, new_b)\n\n            # Close enough for final snap\n            if self._dist(new_b.position, target_pos) <= connect_thresh:\n                if (not self._is_in_obstacle(target_pos, obstacles, is_3d)) and (not self._hit_obstacle(new_b.position, target_pos, obstacles, is_3d)):\n                    final_b = Node(target_pos, parent=None, cost=new_b.cost + self._dist(new_b.position, target_pos))\n                    new_b.add_child(final_b)\n                    tree.append(final_b)\n                    nodes.append(final_b)\n                    edges.append((new_b, final_b))\n                    self._grid_add(grid, final_b)\n                    return final_b\n                return None\n\n            current = new_b\n            steps += 1\n\n        return None\n\n    # --------------- Utilities ---------------\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _vec(self, a, b):\n        return tuple(a[i] - b[i] for i in range(len(a)))\n\n    def _norm(self, v):\n        return math.sqrt(sum(vi * vi for vi in v))\n\n    def _unit(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return tuple(0.0 for _ in v)\n        return tuple(vi / n for vi in v)\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0.0 <= pos[i] <= bounds[i] for i in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _hit_obstacle(self, a, b, obstacles, is_3d, res=1.0):\n        L = self._dist(a, b)\n        steps = max(1, int(L / res))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(len(a)))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _path_cost(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(len(path) - 1):\n            s += self._dist(path[i], path[i + 1])\n        return s\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, attempts=80):\n        if len(path) < 3:\n            return path[:]\n        best = path[:]\n        best_cost = self._path_cost(best)\n        n = len(best)\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = best[i]\n            b = best[j]\n            if not self._hit_obstacle(a, b, obstacles, is_3d):\n                new_path = best[:i + 1] + best[j:]\n                new_cost = self._path_cost(new_path)\n                if new_cost < best_cost - 1e-9:\n                    best = new_path\n                    best_cost = new_cost\n                    n = len(best)\n        # Greedy corner culling\n        changed = True\n        while changed and len(best) > 2:\n            changed = False\n            k = 1\n            while k < len(best) - 1:\n                if not self._hit_obstacle(best[k - 1], best[k + 1], obstacles, is_3d):\n                    best.pop(k)\n                    changed = True\n                else:\n                    k += 1\n        return best\n\n    # --------------- Controls ---------------\n    def _post_update(self, found_first, post_iters, no_improve):\n        if found_first:\n            post_iters += 1\n            no_improve += 1\n        return post_iters, no_improve\n\n    def _should_stop(self, found_first, post_iters, no_improve):\n        if not found_first:\n            return False\n        if post_iters >= self.post_opt_iters:\n            return True\n        if no_improve >= self.no_improve_limit:\n            return True\n        return False",
            "objective": -12.24798,
            "time_improvement": -23.0,
            "length_improvement": 19.0,
            "smoothness_improvement": 1613.0,
            "node_improvement": 89.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.044426774978637694,
                    "num_nodes_avg": 56.4,
                    "path_length_avg": 157.31603480322116,
                    "smoothness_avg": 0.04606013663224119,
                    "success_improvement": 0.0,
                    "time_improvement": -74.23087675795257,
                    "node_improvement": 85.79702845630824,
                    "length_improvement": 13.772588492259377,
                    "smoothness_improvement": 620.9411594821662,
                    "objective_score": -10.901004134619315
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.16415343284606934,
                    "num_nodes_avg": 126.7,
                    "path_length_avg": 235.87995732976475,
                    "smoothness_avg": 0.12420346154518477,
                    "success_improvement": 0.0,
                    "time_improvement": -2.469518896922128,
                    "node_improvement": 91.4869313982396,
                    "length_improvement": 21.256480815202853,
                    "smoothness_improvement": 3095.8445256949494,
                    "objective_score": 27.49225544851982
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.045468711853027345,
                    "num_nodes_avg": 87.9,
                    "path_length_avg": 119.57596595535551,
                    "smoothness_avg": 0.09609107280574067,
                    "success_improvement": 0.0,
                    "time_improvement": 7.30440488486542,
                    "node_improvement": 88.82390336935792,
                    "length_improvement": 20.583337008070234,
                    "smoothness_improvement": 1122.2713533838182,
                    "objective_score": 20.152680437220855
                }
            ],
            "success_rate": 1.0
        },
        "objective": 11.0,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient exploration in cluttered regions due to largely unguided sampling, leading to meandering growth and longer routes.\n   - Limited or poorly tuned connection logic (short-range connect-only thresholds), producing jagged joins and missed straighter merges.\n   - Suboptimal parent choices from static/large neighbor sets or inconsistent cost maintenance, yielding detours and longer chains.\n   - Redundant node placement without duplicate suppression, creating over-segmented, zigzag paths.\n   - Insufficient or late-stage smoothing, leaving many removable corners in the final trajectory."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Beam-guided, informed sampling that favors states closer to the opposite tree while being easy to reach from the current tree.\n   - Local best-parent selection with cost evaluation among a small, nearest set plus line-of-sight compression to higher ancestors.\n   - Near-duplicate suppression to avoid placing nodes that do not add new geometry.\n   - Bounded greedy connect with a local best-parent snap near the meeting point.\n   - Shortcut smoothing with corner culling; moderately larger step size and connect threshold to favor straighter segments.\n2. Expected mechanism of impact:\n   - Guided samples reduce detours and align growth toward the meeting region, shortening the overall route.\n   - Selecting low-cost parents and compressing to visible ancestors removes unnecessary intermediate vertices and path bends.\n   - Suppressing near-duplicates prevents zigzags and keeps the path skeleton minimal.\n   - Improved connect logic forms straighter, cheaper junctions between trees.\n   - Post-processing eliminates residual corners and replaces multi-segment bends with direct, obstacle-free chords, further cutting path length."
        }
    },
    {
        "parents": [
            {
                "operator": "path_expert",
                "algorithm_description": "HF-IRRT#-OS: Heuristic-Filtered Informed RRT# with Online Shortcuts \u2014 a single-tree, cost-optimal planner that uses grid-accelerated neighbors, admissible cost+heuristic pruning, correct-cost rewiring with queued propagation, per-cell best-cost duplicate suppression, aggressive informed sampling after the first solution, and incremental shortcutting to continuously reduce path length.",
                "planning_mechanism": "At each iteration, sample (goal/line/ellipse-biased), steer a bounded step, validate node and edge, select the lowest-cost valid parent within an adaptive radius, commit the node, and rewire cheaper neighbors with proper subtree cost updates. When near the goal, connect via the best valid parent to update the incumbent path. After any improvement, perform bounded shortcuts on the current best path to tighten c_best and focus the informed set. Terminate on post-optimization or no-improvement budgets and return a compressed, smoothed path.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=4.0,\n                 gamma_radius=60.0,\n                 min_radius_factor=1.0,\n                 goal_bias=0.15,\n                 line_bias=0.35,\n                 connect_radius_factor=2.5,\n                 near_cap=72,\n                 post_opt_iters=600,\n                 max_no_improve=240,\n                 smoothing_iters=220,\n                 ellipse_tries=220,\n                 occ_gain_ratio=0.985,\n                 prune_margin=1.0005,\n                 online_shortcuts_per_improve=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_radius = gamma_radius\n        self.min_radius_factor = min_radius_factor\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_radius_factor = connect_radius_factor\n        self.near_cap = near_cap\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.ellipse_tries = ellipse_tries\n        self.occ_gain_ratio = occ_gain_ratio\n        self.prune_margin = prune_margin\n        self.online_shortcuts_per_improve = online_shortcuts_per_improve\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Early feasibility: straight line\n        if self._in_bounds(start) and self._in_bounds(goal):\n            if (not self._is_in_obstacle(start, obstacles, is_3d)) and (not self._is_in_obstacle(goal, obstacles, is_3d)):\n                if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d):\n                    s = Node(start, None, 0.0)\n                    g = Node(goal, None, self._dist(start, goal))\n                    g.attach(s)\n                    nodes = [s, g]\n                    edges = [(s, g)]\n                    path = [start, goal]\n                    return PlannerResult(success=True, path=path, nodes=nodes, edges=edges)\n\n        # Initialize\n        root = Node(start, None, 0.0)\n        nodes = [root]\n\n        # Spatial hash grid for NN queries\n        cell = max(1.0, 0.8 * self.step_size)\n        grid = {}\n        self._grid_add(grid, root, cell)\n\n        # Per-cell best-cost ledger to suppress duplicates\n        occ_cell = max(0.5, 0.6 * self.step_size)\n        occ_best_cost = {self._occ_key(start, occ_cell): 0.0}\n\n        success = False\n        goal_node = None\n        best_cost = float('inf')\n        best_path_pts = None\n\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            # Sampling\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                x_rand = self._sample(start, goal, best_cost)\n\n            # Nearest\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n            # Bounds and node collision\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Parent selection within adaptive radius\n            r_near = self._rrtstar_radius(max(2, len(nodes)))\n            near_nodes = self._near(grid, x_new_pos, r_near, cell)\n            if near_nodes:\n                near_nodes = self._k_nearest_limit(near_nodes, x_new_pos, self.near_cap)\n            # Ensure nearest is considered\n            if n_near not in near_nodes:\n                near_nodes.append(n_near)\n\n            best_parent = None\n            best_pc = float('inf')\n\n            for nn in near_nodes:\n                base_cost = nn.cost + self._dist(nn.position, x_new_pos)\n                if base_cost + 1e-12 < best_pc:\n                    # Edge collision check for candidate parent\n                    if not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d):\n                        best_parent = nn\n                        best_pc = base_cost\n\n            if best_parent is None:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Duplicate suppression using per-cell best cost\n            k_occ = self._occ_key(x_new_pos, occ_cell)\n            prev_best = occ_best_cost.get(k_occ, float('inf'))\n            if best_pc >= prev_best * self.occ_gain_ratio:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Commit new node (both checks already validated for chosen parent)\n            x_new = Node(x_new_pos, None, best_pc)\n            x_new.attach(best_parent)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            if best_pc < prev_best:\n                occ_best_cost[k_occ] = best_pc\n\n            # Rewire neighbors with admissible pruning toward path-length improvement\n            for nn in near_nodes:\n                if nn is x_new or nn is best_parent:\n                    continue\n                alt = x_new.cost + self._dist(x_new.position, nn.position)\n                if alt + 1e-12 < nn.cost:\n                    # If we already have a solution, skip rewires that cannot possibly lead to improving it\n                    if best_cost < float('inf'):\n                        h = self._dist(nn.position, goal)\n                        if alt + h >= best_cost * self.prune_margin:\n                            continue\n                    if not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d):\n                        nn.attach(x_new)\n                        nn.cost = alt\n                        self._propagate_costs_from(nn)\n\n            # Try connecting to the goal using best available parent within connection range\n            improved = False\n            r_conn = max(r_near, self.connect_radius_factor * self.step_size)\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                cand = self._near(grid, goal, r_conn, cell)\n                if x_new not in cand:\n                    cand.append(x_new)\n                best_parent_goal = None\n                best_goal_cost = best_cost\n                for p in cand:\n                    ctot = p.cost + self._dist(p.position, goal)\n                    if ctot + 1e-12 < best_goal_cost:\n                        if not self._is_edge_in_obstacle(p.position, goal, obstacles, is_3d):\n                            best_goal_cost = ctot\n                            best_parent_goal = p\n                if best_parent_goal is not None:\n                    if goal_node is None:\n                        goal_node = Node(goal, None, best_goal_cost)\n                        goal_node.attach(best_parent_goal)\n                        nodes.append(goal_node)\n                    else:\n                        goal_node.attach(best_parent_goal)\n                        goal_node.cost = best_goal_cost\n                    best_cost = best_goal_cost\n                    success = True\n                    found_first = True\n                    improved = True\n\n            # After improvement, do bounded online shortcuts to tighten c_best and focus sampling\n            if improved and goal_node is not None:\n                cur_path = self._extract_path(goal_node)\n                cur_path = self._compress(cur_path, obstacles, is_3d)\n                cur_path = self._shortcuts(cur_path, obstacles, is_3d, self.online_shortcuts_per_improve)\n                path_len = self._path_length(cur_path)\n                if path_len + 1e-12 < best_cost:\n                    best_cost = path_len\n                best_path_pts = cur_path\n                post_iters = 0\n                no_improve = 0\n            else:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        # Build final path\n        path = []\n        if success and goal_node is not None:\n            if best_path_pts is None:\n                path = self._extract_path(goal_node)\n                path = self._compress(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n            else:\n                # Final polishing\n                path = self._shortcuts(best_path_pts, obstacles, is_3d, self.smoothing_iters)\n\n        # Build edges from parent pointers\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---------- Utilities ----------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        # 32-bit LCG (Numerical Recipes variant)\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _rrtstar_radius(self, n):\n        r = self.gamma_radius\n        if n > 2:\n            expo = 1.0 / float(max(2, self.dim))\n            r = self.gamma_radius * ((self._log_approx(n) / float(n)) ** expo)\n        rmin = max(self.min_radius_factor * self.step_size, 1e-6)\n        if r < rmin:\n            r = rmin\n        return r\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        # rough ln via bit_length\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    # Spatial hashing\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        # limit expansion\n        max_span = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > max_span:\n                max_span = self.bounds[i]\n        limit = max_span * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # fallback\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _k_nearest_limit(self, nodes, center, k):\n        if len(nodes) <= k:\n            return nodes\n        # partial selection without full sort when large\n        idx = []\n        for i, n in enumerate(nodes):\n            idx.append((self._dist(n.position, center), i))\n        if len(nodes) <= 4 * k:\n            idx.sort(key=lambda t: t[0])\n            return [nodes[t[1]] for t in idx[:k]]\n        # approximate selection\n        sel = []\n        used = [False] * len(nodes)\n        for _ in range(k):\n            best = -1\n            bestd = float('inf')\n            for j, (d, i) in enumerate(idx):\n                if not used[j] and d < bestd:\n                    bestd = d\n                    best = j\n            if best == -1:\n                break\n            used[best] = True\n            sel.append(nodes[idx[best][1]])\n        return sel\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _heuristic(self, a, b):\n        return self._dist(a, b)\n\n    def _sample(self, start, goal, c_best):\n        # Informed ellipsoidal rejection after first solution; else line/uniform mix\n        if c_best < float('inf'):\n            # accept points satisfying triangle inequality gate; try more to avoid fallback\n            tries = self.ellipse_tries\n            for _ in range(tries):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p):\n                    if self._dist(p, start) + self._dist(p, goal) <= c_best:\n                        return p\n        # Line-biased sampling with jitter\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jitter = 0.5 * self.step_size\n            p = tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n            return p\n        # Uniform\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _propagate_costs_from(self, node):\n        # node.cost already set correctly by caller\n        stack = []\n        for c in node.children:\n            stack.append(c)\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                newc = u.parent.cost + self._dist(u.parent.position, u.position)\n                if abs(newc - u.cost) > 1e-12:\n                    u.cost = newc\n            for c in u.children:\n                stack.append(c)\n\n    def _extract_path(self, goal_node):\n        seq = []\n        cur = goal_node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
                "objective": 26.9043,
                "time_improvement": -154.0,
                "length_improvement": 19.0,
                "smoothness_improvement": 1520.0,
                "node_improvement": 44.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.10562500953674317,
                        "num_nodes_avg": 293.8,
                        "path_length_avg": 154.45237735825782,
                        "smoothness_avg": 0.04984145985356507,
                        "success_improvement": 0.0,
                        "time_improvement": -314.23529004756443,
                        "node_improvement": 26.013598589775878,
                        "length_improvement": 15.34220451539984,
                        "smoothness_improvement": 680.1270791706859,
                        "objective_score": -81.66462890917599
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.2455054998397827,
                        "num_nodes_avg": 623.2,
                        "path_length_avg": 228.05708400641493,
                        "smoothness_avg": 0.10153044277454511,
                        "success_improvement": 0.0,
                        "time_improvement": -53.25193033715656,
                        "node_improvement": 58.1267217630854,
                        "length_improvement": 23.867981099460806,
                        "smoothness_improvement": 2512.4514220110627,
                        "objective_score": 10.90746666858483
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.09506032466888428,
                        "num_nodes_avg": 407.5,
                        "path_length_avg": 122.10575352004132,
                        "smoothness_avg": 0.1154296410531563,
                        "success_improvement": 0.0,
                        "time_improvement": -93.79641533507504,
                        "node_improvement": 48.188175460902734,
                        "length_improvement": 18.903172563144594,
                        "smoothness_improvement": 1368.2565140663191,
                        "objective_score": -9.95573849230416
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m3",
                "algorithm_description": "Hash-Informed RRT* with Collision Cache and Cell Throttling (HI-RRT*-C2): a single-tree, adaptive-neighborhood optimizer that uses a uniform spatial hash for fast neighbor/nearest queries, per-cell saturation to curb redundant growth, quantized segment-collision caching to avoid repeated checks, informed ellipsoidal sampling after the first solution, and selective rewiring with incremental cost updates; it returns a visibility-compressed and shortcut-smoothed path",
                "planning_mechanism": "Grow one tree from start with mild goal/line bias. For each sample, steer a bounded step from the hashed-nearest node, validate node and edge, then pick the lowest-cost valid parent among adaptively-sized nearby nodes (capped by K). Insert the node if its cell is unsaturated, rewire cheaper neighbors, and opportunistically connect the goal using nearby parents. After the first solution, restrict sampling to the informed set and stop on a post-optimization budget. Use cached collision results for edges, then compress and shortcut the final path.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=3500,\n                 step_size=6.0,\n                 goal_bias=0.18,\n                 line_bias=0.35,\n                 gamma_radius=60.0,\n                 min_radius_factor=1.0,\n                 near_cap=48,\n                 cell_cap=4,\n                 post_opt_iters=400,\n                 no_improve_limit=160,\n                 smoothing_iters=140):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.gamma_radius = gamma_radius\n        self.min_radius_factor = min_radius_factor\n        self.near_cap = near_cap\n        self.cell_cap = cell_cap\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # validate endpoints\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(success=False, path=[], nodes=[], edges=[])\n\n        # init RNG and caches\n        self._init_rng()\n        self._edge_cache = {}\n        self._seg_qres = max(0.25, 0.5 * self.step_size)\n\n        # spatial hash\n        cell = max(1.0, 0.9 * self.step_size)\n        grid = {}\n        occ = {}\n        occ_cap = max(1, self.cell_cap)\n\n        root = Node(start, None, 0.0)\n        nodes = [root]\n        self._grid_add(grid, root, cell)\n        self._occ_inc(occ, self._grid_key(start, cell))\n\n        best_cost = float('inf')\n        goal_node = None\n        success = False\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            # sampling\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                x_rand = self._sample_biased(start, goal, best_cost)\n\n            # nearest via grid\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n            # bounds and node collision check\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # per-cell throttling and near-duplicate suppression\n            kcell = self._grid_key(x_new_pos, cell)\n            if occ.get(kcell, 0) >= occ_cap:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # incoming edge collision check (cached)\n            if self._edge_blocked(n_near.position, x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # choose best parent within adaptive neighborhood\n            r_near = self._rrtstar_radius(max(2, len(nodes)))\n            cand = self._near(grid, x_new_pos, r_near, cell)\n            if cand:\n                cand = self._k_nearest(cand, x_new_pos, self.near_cap)\n            best_parent = n_near\n            best_pc = n_near.cost + self._dist(n_near.position, x_new_pos)\n\n            for p in cand:\n                if p is n_near:\n                    continue\n                c = p.cost + self._dist(p.position, x_new_pos)\n                if c + 1e-12 < best_pc:\n                    if not self._edge_blocked(p.position, x_new_pos, obstacles, is_3d):\n                        best_pc = c\n                        best_parent = p\n\n            # final edge check for the chosen parent (already done above, but ensure both checks)\n            if self._edge_blocked(best_parent.position, x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # commit node (both checks satisfied)\n            x_new = Node(x_new_pos, None, best_pc)\n            x_new.attach(best_parent)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            self._occ_inc(occ, kcell)\n\n            # rewire neighbors\n            for q in cand:\n                if q is x_new or q is best_parent:\n                    continue\n                alt = x_new.cost + self._dist(x_new.position, q.position)\n                if alt + 1e-12 < q.cost:\n                    if not self._edge_blocked(x_new.position, q.position, obstacles, is_3d):\n                        q.attach(x_new)\n                        self._propagate_costs_from(q)\n\n            # goal connection via best nearby parent\n            improved = False\n            r_conn = max(r_near, 2.0 * self.step_size)\n            if self._dist(x_new.position, goal) <= r_conn and (not self._is_in_obstacle(goal, obstacles, is_3d)):\n                cand_goal = self._near(grid, goal, r_conn, cell)\n                if x_new not in cand_goal:\n                    cand_goal.append(x_new)\n                best_goal_parent = None\n                best_goal_cost = best_cost\n                for p in cand_goal:\n                    if not self._edge_blocked(p.position, goal, obstacles, is_3d):\n                        ctot = p.cost + self._dist(p.position, goal)\n                        if ctot + 1e-12 < best_goal_cost:\n                            best_goal_cost = ctot\n                            best_goal_parent = p\n                if best_goal_parent is not None:\n                    if goal_node is None:\n                        goal_node = Node(goal, None, best_goal_cost)\n                        goal_node.attach(best_goal_parent)\n                        nodes.append(goal_node)\n                    else:\n                        goal_node.cost = best_goal_cost\n                        goal_node.attach(best_goal_parent)\n                    best_cost = best_goal_cost\n                    success = True\n                    found_first = True\n                    improved = True\n                    post_iters = 0\n                    no_improve = 0\n\n            if found_first and not improved:\n                post_iters += 1\n                no_improve += 1\n                if post_iters >= self.post_opt_iters or no_improve >= self.no_improve_limit:\n                    break\n\n        # extract and post-process path\n        path = []\n        if success and goal_node is not None:\n            cur = goal_node\n            while cur is not None:\n                path.append(cur.position)\n                cur = cur.parent\n            path.reverse()\n            path = self._compress_visibility(path, obstacles, is_3d)\n            path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n\n        # build edges from parent pointers\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---- Utilities ----\n    def _init_rng(self):\n        self._lcg_state = 1103515245\n\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / max(1e-12, d)\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # cached edge query\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._seg_key(a, b, self._seg_qres)\n        if k in self._edge_cache:\n            return self._edge_cache[k]\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, resolution=min(1.0, 0.5 * self.step_size))\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _seg_key(self, a, b, q):\n        ka = tuple(int(x // q) for x in a)\n        kb = tuple(int(x // q) for x in b)\n        if ka <= kb:\n            return (ka, kb)\n        else:\n            return (kb, ka)\n\n    # spatial hash\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _occ_inc(self, occ, key):\n        occ[key] = occ.get(key, 0) + 1\n\n    def _gather_cells(self, grid, center, radius, cell):\n        rng = int(radius // cell) + 1\n        base = self._grid_key(center, cell)\n        out = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (base[0] + dx, base[1] + dy)\n                    if k in grid:\n                        out.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (base[0] + dx, base[1] + dy, base[2] + dz)\n                        if k in grid:\n                            out.extend(grid[k])\n        return out\n\n    def _nearest(self, grid, nodes, pos, cell):\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        span = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > span:\n                span = self.bounds[i]\n        limit = span * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # fallback\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _k_nearest(self, nodes, center, k):\n        if len(nodes) <= k:\n            return nodes\n        # partial selection by distances\n        dlist = []\n        for n in nodes:\n            dlist.append((self._dist(n.position, center), n))\n        # simple selection for moderate sizes\n        dlist.sort(key=lambda t: t[0])\n        return [t[1] for t in dlist[:k]]\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    def _rrtstar_radius(self, n):\n        r = self.gamma_radius\n        if n > 2:\n            expo = 1.0 / float(max(2, self.dim))\n            r = self.gamma_radius * ((self._log_approx(n) / float(n)) ** expo)\n        rmin = max(self.min_radius_factor * self.step_size, 1e-6)\n        if r < rmin:\n            r = rmin\n        return r\n\n    def _sample_biased(self, start, goal, c_best):\n        # informed rejection sampling inside prolate ellipsoid after first solution\n        if c_best < float('inf'):\n            for _ in range(24):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._dist(p, start) + self._dist(p, goal) <= c_best and self._in_bounds(p):\n                    return p\n        # line-biased sample with jitter\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jit = 0.5 * self.step_size\n            return tuple(self._clip(base[i] + self._uniform(-jit, jit), 0.0, self.bounds[i]) for i in range(self.dim))\n        # uniform\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _propagate_costs_from(self, node):\n        stack = []\n        for c in node.children:\n            stack.append(c)\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                stack.append(c)\n\n    def _compress_visibility(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._edge_blocked(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
                "objective": 16.60646,
                "time_improvement": -112.0,
                "length_improvement": 19.0,
                "smoothness_improvement": 1152.0,
                "node_improvement": 8.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.10469622611999511,
                        "num_nodes_avg": 527.0,
                        "path_length_avg": 168.0750761001771,
                        "smoothness_avg": 0.06111375392817124,
                        "success_improvement": 0.0,
                        "time_improvement": -310.59283008741494,
                        "node_improvement": -32.7121631830773,
                        "length_improvement": 7.875387469478444,
                        "smoothness_improvement": 856.5629596166424,
                        "objective_score": -84.1698017464542
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.13574841022491455,
                        "num_nodes_avg": 958.0,
                        "path_length_avg": 225.05727082236268,
                        "smoothness_avg": 0.06861621576132221,
                        "success_improvement": 0.0,
                        "time_improvement": 15.261752096206042,
                        "node_improvement": 35.63125713901767,
                        "length_improvement": 24.869405085132428,
                        "smoothness_improvement": 1665.5446538013703,
                        "objective_score": 27.82789194894812
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.06941454410552979,
                        "num_nodes_avg": 624.0,
                        "path_length_avg": 114.65111819862268,
                        "smoothness_avg": 0.08119520302962734,
                        "success_improvement": 0.0,
                        "time_improvement": -41.51319035178322,
                        "node_improvement": 20.66115702479339,
                        "length_improvement": 23.854186392042912,
                        "smoothness_improvement": 932.7969893303921,
                        "objective_score": 6.522539676342741
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "C3-IRRT#-Beam: Cached, Cell-Capped Informed RRT# with Beamed Rewiring and LOS Bridging \u2014 a single-tree, cost-optimal planner that combines quantized collision caching across all phases, tuned spatial hashing, per-cell admission with best-cost ledgers, admissible heuristic pruning, correct-cost rewiring with on-node propagation, and early-terminating cached smoothing to deliver faster solves and shorter, smoother paths.",
            "planning_mechanism": "At each iteration, sample with goal/line bias and informed-ellipse gating after the first solution; steer a bounded step from the hashed-nearest node; validate node and edge (with cache); select the lowest-cost valid parent within an adaptive neighborhood under heuristic pruning and per-cell cost admission; commit the node, then rewire a small beam of cheaper neighbors with cost-correct subtree updates. Opportunistically perform direct line-of-sight goal bridging from nearby nodes. After improvements, run a few cached shortcuts to contract c_best and focus the informed set. Stop on post-optimization budgets and return a compressed, smoothed path.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n        self.parent = new_parent\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=3800,\n                 step_size=5.0,\n                 goal_bias=0.22,\n                 line_bias=0.40,\n                 gamma_radius=70.0,\n                 min_radius_factor=1.0,\n                 near_cap=56,\n                 cell_cap=3,\n                 admit_gain_ratio=0.99,\n                 prune_margin=1.001,\n                 rewire_cap=14,\n                 post_opt_iters=360,\n                 no_improve_limit=160,\n                 smoothing_iters=160,\n                 ellipse_tries=64,\n                 online_shortcuts_per_improve=32):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.gamma_radius = gamma_radius\n        self.min_radius_factor = min_radius_factor\n        self.near_cap = near_cap\n        self.cell_cap = cell_cap\n        self.admit_gain_ratio = admit_gain_ratio\n        self.prune_margin = prune_margin\n        self.rewire_cap = rewire_cap\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.smoothing_iters = smoothing_iters\n        self.ellipse_tries = ellipse_tries\n        self.online_shortcuts_per_improve = online_shortcuts_per_improve\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Endpoint validation\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(success=False, path=[], nodes=[], edges=[])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(success=False, path=[], nodes=[], edges=[])\n\n        # RNG and caches\n        self._init_rng()\n        self._edge_cache = {}\n        self._seg_qres = max(0.25, 0.5 * self.step_size)\n\n        # Early straight-line solution\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            path = [start, goal]\n            return PlannerResult(success=True, path=path, nodes=nodes, edges=edges)\n\n        # Initialize structures\n        root = Node(start, None, 0.0)\n        nodes = [root]\n\n        cell = max(1.0, 1.25 * self.step_size)\n        grid = {}\n        self._grid_add(grid, root, cell)\n\n        # Per-cell throttling and cost-ledger\n        occ = {}\n        self._occ_inc(occ, self._grid_key(start, cell))\n        dup_cell = max(0.5, 0.6 * self.step_size)\n        occ_best_cost = {self._occ_key(start, dup_cell): 0.0}\n\n        best_cost = float('inf')\n        goal_node = None\n        success = False\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n        best_path_pts = None\n\n        for it in range(self.max_iter):\n            # Sampling\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                x_rand = self._sample(start, goal, best_cost)\n\n            # Nearest\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n            # Bounds and node collision\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Cell throttling\n            kcell = self._grid_key(x_new_pos, cell)\n            if occ.get(kcell, 0) >= max(1, self.cell_cap):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Edge collision from nearest (cached)\n            if self._edge_blocked(n_near.position, x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Parent selection within adaptive radius, heuristic-pruned\n            r_near = self._rrtstar_radius(max(2, len(nodes)))\n            near_nodes = self._near(grid, x_new_pos, r_near, cell)\n            if n_near not in near_nodes:\n                near_nodes.append(n_near)\n            if near_nodes:\n                near_nodes = self._k_nearest_limit(near_nodes, x_new_pos, self.near_cap)\n\n            best_parent = None\n            best_pc = float('inf')\n\n            for p in near_nodes:\n                # Heuristic pruning against current best solution\n                base = p.cost + self._dist(p.position, x_new_pos)\n                if best_cost < float('inf'):\n                    h = self._dist(x_new_pos, goal)\n                    if base + h >= best_cost * self.prune_margin:\n                        continue\n                if base + 1e-12 < best_pc:\n                    if not self._edge_blocked(p.position, x_new_pos, obstacles, is_3d):\n                        best_pc = base\n                        best_parent = p\n\n            if best_parent is None:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Per-cell best-cost duplicate suppression\n            kdup = self._occ_key(x_new_pos, dup_cell)\n            prev_best = occ_best_cost.get(kdup, float('inf'))\n            if best_pc >= prev_best * self.admit_gain_ratio:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Commit node (node and edge checks satisfied)\n            x_new = Node(x_new_pos, None, best_pc)\n            x_new.attach(best_parent)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            self._occ_inc(occ, kcell)\n            if best_pc < prev_best:\n                occ_best_cost[kdup] = best_pc\n\n            # Rewire a small beam of neighbors for efficiency\n            # Select promising neighbors by potential gain\n            rewire_cands = []\n            for q in near_nodes:\n                if q is x_new or q is best_parent:\n                    continue\n                alt = x_new.cost + self._dist(x_new.position, q.position)\n                if alt + 1e-12 < q.cost:\n                    if best_cost < float('inf'):\n                        # prune rewires unlikely to improve final cost\n                        h = self._dist(q.position, goal)\n                        if alt + h >= best_cost * self.prune_margin:\n                            continue\n                    rewire_cands.append((q.cost - alt, q, alt))\n            # Process up to rewire_cap best gains\n            if rewire_cands:\n                rewire_cands.sort(key=lambda t: t[0], reverse=True)\n                for _, q, alt in rewire_cands[:max(1, self.rewire_cap)]:\n                    if not self._edge_blocked(x_new.position, q.position, obstacles, is_3d):\n                        q.attach(x_new)\n                        q.cost = alt\n                        self._propagate_costs_from(q)\n\n            # Goal bridging via best nearby parent\n            improved = False\n            r_conn = max(r_near, 2.0 * self.step_size)\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                cand_goal = self._near(grid, goal, r_conn, cell)\n                if x_new not in cand_goal:\n                    cand_goal.append(x_new)\n                best_goal_parent = None\n                best_goal_cost = best_cost\n                for p in cand_goal:\n                    gcost = p.cost + self._dist(p.position, goal)\n                    if gcost + 1e-12 < best_goal_cost:\n                        if not self._edge_blocked(p.position, goal, obstacles, is_3d):\n                            best_goal_cost = gcost\n                            best_goal_parent = p\n                if best_goal_parent is not None:\n                    if goal_node is None:\n                        goal_node = Node(goal, best_goal_parent, best_goal_cost)\n                        best_goal_parent.children.append(goal_node)\n                        nodes.append(goal_node)\n                    else:\n                        goal_node.attach(best_goal_parent)\n                        goal_node.cost = best_goal_cost\n                    best_cost = best_goal_cost\n                    success = True\n                    found_first = True\n                    improved = True\n\n            # Online smoothing after improvement\n            if improved and goal_node is not None:\n                cur_path = self._extract_path(goal_node)\n                cur_path = self._compress_visibility(cur_path, obstacles, is_3d)\n                cur_path = self._shortcuts(cur_path, obstacles, is_3d, self.online_shortcuts_per_improve)\n                plen = self._path_length(cur_path)\n                if plen + 1e-12 < best_cost:\n                    best_cost = plen\n                best_path_pts = cur_path\n                post_iters = 0\n                no_improve = 0\n            else:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                    if post_iters >= self.post_opt_iters or no_improve >= self.no_improve_limit:\n                        break\n\n        # Build final path\n        path = []\n        if success and goal_node is not None:\n            if best_path_pts is None:\n                path = self._extract_path(goal_node)\n                path = self._compress_visibility(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n            else:\n                path = self._shortcuts(best_path_pts, obstacles, is_3d, self.smoothing_iters)\n\n        # Build edges\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---------- Utilities ----------\n    def _init_rng(self):\n        self._lcg_state = 2862933555777941757 % (1 << 32)\n\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / max(1e-12, d)\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Cached edge query\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._seg_key(a, b, self._seg_qres)\n        if k in self._edge_cache:\n            return self._edge_cache[k]\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, resolution=min(1.0, 0.5 * self.step_size))\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _seg_key(self, a, b, q):\n        ka = tuple(int(x // q) for x in a)\n        kb = tuple(int(x // q) for x in b)\n        return (ka, kb) if ka <= kb else (kb, ka)\n\n    # Spatial hashing\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _occ_inc(self, occ, key):\n        occ[key] = occ.get(key, 0) + 1\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        base = self._grid_key(center_pos, cell)\n        out = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (base[0] + dx, base[1] + dy)\n                    if k in grid:\n                        out.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (base[0] + dx, base[1] + dy, base[2] + dz)\n                        if k in grid:\n                            out.extend(grid[k])\n        return out\n\n    def _nearest(self, grid, nodes, pos, cell):\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        span = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > span:\n                span = self.bounds[i]\n        limit = span * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # fallback\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _k_nearest_limit(self, nodes, center, k):\n        if len(nodes) <= k:\n            return nodes\n        dist_idx = []\n        for n in nodes:\n            dist_idx.append((self._dist(n.position, center), n))\n        dist_idx.sort(key=lambda t: t[0])\n        return [t[1] for t in dist_idx[:k]]\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _heuristic(self, a, b):\n        return self._dist(a, b)\n\n    def _sample(self, start, goal, c_best):\n        # Informed ellipsoidal gate after first solution\n        if c_best < float('inf'):\n            for _ in range(self.ellipse_tries):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p):\n                    if self._dist(p, start) + self._dist(p, goal) <= c_best:\n                        return p\n        # Line-biased sample with jitter\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jit = 0.5 * self.step_size\n            return tuple(self._clip(base[i] + self._uniform(-jit, jit), 0.0, self.bounds[i]) for i in range(self.dim))\n        # Uniform\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    def _rrtstar_radius(self, n):\n        r = self.gamma_radius\n        if n > 2:\n            expo = 1.0 / float(max(2, self.dim))\n            r = self.gamma_radius * ((self._log_approx(n) / float(n)) ** expo)\n        rmin = max(self.min_radius_factor * self.step_size, 1e-6)\n        if r < rmin:\n            r = rmin\n        return r\n\n    def _propagate_costs_from(self, node):\n        # Update node and all descendants to maintain consistent costs\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                stack.append(c)\n\n    def _extract_path(self, goal_node):\n        seq = []\n        cur = goal_node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _compress_visibility(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._edge_blocked(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        no_gain = 0\n        for _ in range(iters):\n            if n < 3 or no_gain > max(8, iters // 10):\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                before = self._dist(pts[i], pts[i + 1]) + self._dist(pts[j - 1], pts[j])\n                after = self._dist(pts[i], pts[j])\n                if after + 1e-12 < before:\n                    pts = pts[:i + 1] + pts[j:]\n                    n = len(pts)\n                    no_gain = 0\n                else:\n                    no_gain += 1\n            else:\n                no_gain += 1\n        return pts",
            "objective": -11.31791,
            "time_improvement": -29.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1637.0,
            "node_improvement": 66.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04869384765625,
                    "num_nodes_avg": 142.0,
                    "path_length_avg": 156.94171771174342,
                    "smoothness_avg": 0.05000575517450624,
                    "success_improvement": 0.0,
                    "time_improvement": -90.96528555012308,
                    "node_improvement": 64.24074540418032,
                    "length_improvement": 13.977757621532207,
                    "smoothness_improvement": 682.698657716415,
                    "objective_score": -15.489437803535523
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.11519887447357177,
                    "num_nodes_avg": 403.0,
                    "path_length_avg": 229.3729522589852,
                    "smoothness_avg": 0.11782822378241282,
                    "success_improvement": 0.0,
                    "time_improvement": 28.089391491172343,
                    "node_improvement": 72.92212591547404,
                    "length_improvement": 23.42870640158524,
                    "smoothness_improvement": 2931.805066160672,
                    "objective_score": 37.14306661910621
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.060450196266174316,
                    "num_nodes_avg": 306.0,
                    "path_length_avg": 118.47542861631464,
                    "smoothness_avg": 0.10979481191774568,
                    "success_improvement": 0.0,
                    "time_improvement": -23.237863782732852,
                    "node_improvement": 61.09345200254291,
                    "length_improvement": 21.314261506704646,
                    "smoothness_improvement": 1296.5819033837186,
                    "objective_score": 12.300107286121523
                }
            ],
            "success_rate": 1.0
        },
        "objective": 11.6,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inconsistent or delayed cost updates after rewires, producing inaccurate cost-to-come and misguiding later parent/goal selection.\n   - Weak or purely count-based duplicate suppression in local regions, allowing higher-cost near-duplicates to crowd out better connectors.\n   - Candidate-parent neighborhoods constrained or approximated, sometimes omitting the true lowest-cost parent and inducing zig-zag parent chains.\n   - Rewiring not prioritized by expected gain and/or pruned with overly rigid thresholds, skipping beneficial micro-improvements that would cumulatively shorten paths.\n   - Limited or non-adaptive post-processing (compression/shortcuts), leaving superfluous waypoints and unnecessary curvature.\n   - Lenient link maintenance permitting stale child references, degrading subtree integrity and cost propagation."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Correct-on-node cost propagation during rewires, immediately updating the rewired node and all descendants.\n   - Combined per-cell throttling with a per-cell best-cost ledger and a modest admission threshold to retain only improving representatives.\n   - Heuristic pruning of candidate parents/rewires relative to the current best solution, with focused line/goal bias and adequate neighbor coverage.\n   - Beam-restricted, gain-sorted rewiring to apply the highest-impact local improvements first.\n   - Cached visibility checks reused across edge tests, compression, and shortcuts.\n   - Incremental online smoothing after improvements, followed by final progress-aware shortcutting.\n   - Robust parent-child attach that prevents stale children lists.\n2. Expected mechanism of impact:\n   - Accurate costs enable selection of truly lower-cost parents and better goal attachments, reducing detours and zig-zagging.\n   - Local duplicate control preserves the lowest-cost connectors in each area, improving global parent choices and shortening the final route.\n   - Heuristic focus and adequate neighbor sets prioritize branches capable of beating the current best, increasing discovery of shorter segments.\n   - Gain-prioritized rewiring realizes small cumulative cost reductions earlier, tightening the path before final smoothing.\n   - Efficient LOS-based compression and selective shortcuts remove unnecessary waypoints, contracting the path toward near-geodesic feasible lines.\n   - Clean tree structure ensures reliable propagation and rewiring cascades, avoiding lock-in to longer parent chains."
        }
    },
    {
        "parents": [
            {
                "operator": "cross_over",
                "algorithm_description": "LHRR*-Connect: Layered-Hash RRT* Connect with bounded-parent search, greedy cross-tree growth, and cache-reused visibility smoothing. It accelerates bidirectional planning with deduplicated ring-hash NN, per-cell cost-gated admission, exact edge-collision memoization, local rewiring with cost propagation, and short greedy connectors; parent edges obey a radius bound for smoother, shorter paths; on first successful bridge it visibility-prunes and shortcuts the path and returns early.",
                "planning_mechanism": "Alternate growing start/goal trees: sample goal/informed-biased points; find a near node via ring-hash; steer one step; choose the best-cost parent among line-of-sight neighbors within a bounded radius; insert if node/edge are collision-free and cell gate accepts; locally rewire cheaper neighbors; then try a few greedy steps from the opposite tree toward the new node and bridge if a direct, collision-free edge fits; upon connection, extract, visibility-prune, and shortcut-smooth the path, returning immediately.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=6.0,\n        goal_bias=0.25,\n        grid_cell_factor=1.8,\n        max_per_cell=7,\n        ring_max=3,\n        parent_radius_factor=2.5,\n        rewire_radius_factor=2.2,\n        connect_steps=3,\n        smoothing_iters=80\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.max_per_cell = max_per_cell\n        self.ring_max = ring_max\n        self.parent_radius_factor = parent_radius_factor\n        self.rewire_radius_factor = rewire_radius_factor\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        self._lcg_state = 2463534242\n        self._edge_cache = {}\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Derived params\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.edge_res = max(0.5, min(1.0, self.step_size * 0.5))\n        parent_radius = max(self.step_size * self.parent_radius_factor, self.step_size + 1e-6)\n        rewire_radius = max(self.step_size * self.rewire_radius_factor, self.step_size + 1e-6)\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            path = self._visibility_prune(path, obstacles, is_3d)\n            path = self._shortcut_smooth(path, obstacles, is_3d, min(30, self.smoothing_iters))\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        bestcost_start = {}\n        bestcost_goal = {}\n\n        self._grid_add(grid_start, counts_start, bestcost_start, start_root)\n        self._grid_add(grid_goal, counts_goal, bestcost_goal, goal_root)\n\n        success = False\n        best_path = []\n\n        for it in range(self.max_iter):\n            a_is_start = (it % 2 == 0)\n            tree_a = start_tree if a_is_start else goal_tree\n            tree_b = goal_tree if a_is_start else start_tree\n            grid_a = grid_start if a_is_start else grid_goal\n            grid_b = grid_goal if a_is_start else grid_start\n            counts_a = counts_start if a_is_start else counts_goal\n            counts_b = counts_goal if a_is_start else counts_start\n            bestcost_a = bestcost_start if a_is_start else bestcost_goal\n            bestcost_b = bestcost_goal if a_is_start else bestcost_start\n            attractor = goal if a_is_start else start\n\n            # Sample with mild goal bias; after a few iters, bias stronger toward opposite root\n            x_rand = self._sample_biased(obstacles, is_3d, attractor)\n\n            # Nearest and steer\n            nearest = self._nearest_hashed(grid_a, tree_a, x_rand)\n            if nearest is None:\n                continue\n            new_pos = self._steer(nearest.position, x_rand)\n            if (not self._in_bounds(new_pos)) or self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                continue\n            if self._near_duplicate(grid_a, new_pos, self.step_size * 0.6):\n                continue\n\n            # Best parent among LOS neighbors within bounded radius\n            parent = self._choose_parent_local(grid_a, new_pos, nearest, obstacles, is_3d, parent_radius)\n            if self._edge_blocked(parent.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n            # Per-cell cost-gated admission\n            key_new = self._grid_key(new_pos)\n            ccount = counts_a.get(key_new, 0)\n            bestc = bestcost_a.get(key_new, float('inf'))\n            if ccount >= self.max_per_cell and not (new_cost + 1e-9 < bestc):\n                continue\n\n            # Insert node (node and edge checks already done)\n            a_new = Node(new_pos, parent=parent, cost=new_cost)\n            parent.add_child(a_new)\n            tree_a.append(a_new)\n            nodes.append(a_new)\n            edges.append((parent, a_new))\n            self._grid_add(grid_a, counts_a, bestcost_a, a_new)\n\n            # Local rewiring\n            self._rewire_local(grid_a, a_new, edges, obstacles, is_3d, rewire_radius)\n\n            # Try to bridge to other tree: direct or short greedy steps\n            bridged = False\n\n            # Direct attempt to nearest in other tree\n            b_near = self._nearest_hashed(grid_b, tree_b, a_new.position)\n            if b_near is not None:\n                if self._dist(b_near.position, a_new.position) <= self.step_size and not self._edge_blocked(b_near.position, a_new.position, obstacles, is_3d):\n                    # Add a visual bridge edge for output; path extraction uses parents\n                    edges.append((b_near, a_new))\n                    path = self._extract_path(a_new, b_near, a_is_start)\n                    path = self._visibility_prune(path, obstacles, is_3d)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, nodes, edges)\n\n            # Greedy connect from other tree toward a_new\n            current_target = a_new.position\n            b_last = None\n            for _ in range(self.connect_steps):\n                b_near = self._nearest_hashed(grid_b, tree_b, current_target)\n                if b_near is None:\n                    break\n                step_to = self._steer(b_near.position, current_target)\n                if (not self._in_bounds(step_to)) or self._is_in_obstacle(step_to, obstacles, is_3d):\n                    break\n                if self._edge_blocked(b_near.position, step_to, obstacles, is_3d):\n                    break\n                # Parent selection in other tree\n                b_parent = self._choose_parent_local(grid_b, step_to, b_near, obstacles, is_3d, parent_radius)\n                if self._edge_blocked(b_parent.position, step_to, obstacles, is_3d):\n                    break\n                # Insert into other tree\n                b_new = Node(step_to, parent=b_parent, cost=b_parent.cost + self._dist(b_parent.position, step_to))\n                b_parent.add_child(b_new)\n                tree_b.append(b_new)\n                nodes.append(b_new)\n                edges.append((b_parent, b_new))\n                self._grid_add(grid_b, counts_b, bestcost_b, b_new)\n                self._rewire_local(grid_b, b_new, edges, obstacles, is_3d, rewire_radius)\n                b_last = b_new\n\n                # Check final bridge\n                if self._dist(b_new.position, a_new.position) <= self.step_size and not self._edge_blocked(b_new.position, a_new.position, obstacles, is_3d):\n                    edges.append((b_new, a_new))\n                    path = self._extract_path(a_new, b_new, a_is_start)\n                    path = self._visibility_prune(path, obstacles, is_3d)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(success, best_path if success else [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-9:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision and caching\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        hit = self._edge_cache.get(k)\n        if hit is not None:\n            return hit\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Sampling\n    def _sample_biased(self, obstacles, is_3d, attractor):\n        if self._rand() < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Slight pull toward attractor\n        alpha = 0.25\n        if self.dim == 3:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]),\n                   self._uniform(0.0, self.bounds[2]))\n            p = (alpha * attractor[0] + (1.0 - alpha) * rnd[0],\n                 alpha * attractor[1] + (1.0 - alpha) * rnd[1],\n                 alpha * attractor[2] + (1.0 - alpha) * rnd[2])\n        else:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]))\n            p = (alpha * attractor[0] + (1.0 - alpha) * rnd[0],\n                 alpha * attractor[1] + (1.0 - alpha) * rnd[1])\n        if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        # Fallback uniform free sample\n        while True:\n            if self.dim == 3:\n                q = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                q = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(q) and not self._is_in_obstacle(q, obstacles, is_3d):\n                return q\n\n    # Grid / NN\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n        bc = bestcost.get(k)\n        if bc is None or node.cost < bc:\n            bestcost[k] = node.cost\n\n    def _ring_cells(self, key, r):\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        yield (key[0] + dx, key[1] + dy, key[2] + dz)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    yield (key[0] + dx, key[1] + dy)\n\n    def _grid_ring_collect_unique(self, grid, key, r):\n        cand = []\n        seen = set()\n        for cell in self._ring_cells(key, r):\n            bucket = grid.get(cell)\n            if bucket:\n                for n in bucket:\n                    if id(n) not in seen:\n                        seen.add(id(n))\n                        cand.append(n)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.ring_max + 1):\n            cand = self._grid_ring_collect_unique(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback random subset if grid empty nearby\n        if not tree:\n            return None\n        tries = min(64, len(tree))\n        for i in range(tries):\n            idx = int(self._uniform(0, len(tree)))\n            n = tree[idx]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        cand = self._grid_ring_collect_unique(grid, key, 1)\n        rr = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # Parent selection among LOS neighbors with bounded radius\n    def _choose_parent_local(self, grid, new_pos, fallback_nearest, obstacles, is_3d, radius_bound):\n        key = self._grid_key(new_pos)\n        best_parent = fallback_nearest\n        best_cost = fallback_nearest.cost + self._dist(fallback_nearest.position, new_pos)\n        max_r = max(1, self.ring_max)\n        for r in range(0, max_r + 1):\n            cand = self._grid_ring_collect_unique(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                if n is fallback_nearest or n is best_parent:\n                    continue\n                dnp = self._dist(n.position, new_pos)\n                if dnp > radius_bound:\n                    continue\n                if self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                    continue\n                c = n.cost + dnp\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best_parent = n\n        return best_parent\n\n    # Local rewiring\n    def _rewire_local(self, grid, pivot, edges, obstacles, is_3d, radius):\n        key = self._grid_key(pivot.position)\n        neighbors = []\n        for r in range(0, max(1, self.ring_max) + 1):\n            cand = self._grid_ring_collect_unique(grid, key, r)\n            if not cand:\n                continue\n            for nb in cand:\n                if nb is pivot or nb.parent is pivot:\n                    continue\n                if self._dist(nb.position, pivot.position) > radius:\n                    continue\n                if self._edge_blocked(pivot.position, nb.position, obstacles, is_3d):\n                    continue\n                new_cost = pivot.cost + self._dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    old_parent = nb.parent\n                    if old_parent is not None:\n                        # remove old edge if present\n                        try:\n                            edges.remove((old_parent, nb))\n                        except Exception:\n                            pass\n                        try:\n                            old_parent.children.remove(nb)\n                        except Exception:\n                            pass\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n                    self._propagate_cost_from(nb)\n\n    def _propagate_cost_from(self, node):\n        # BFS with index to avoid O(n^2) pops\n        queue = [node]\n        qi = 0\n        while qi < len(queue):\n            cur = queue[qi]\n            qi += 1\n            for ch in cur.children:\n                new_c = cur.cost + self._dist(cur.position, ch.position)\n                if abs(new_c - ch.cost) > 1e-12:\n                    ch.cost = new_c\n                    queue.append(ch)\n\n    # Path\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
                "objective": -28.44215,
                "time_improvement": 35.0,
                "length_improvement": 18.0,
                "smoothness_improvement": 1400.0,
                "node_improvement": 87.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.010955095291137695,
                        "num_nodes_avg": 37.0,
                        "path_length_avg": 160.2836074021365,
                        "smoothness_avg": 0.054405545983368185,
                        "success_improvement": 0.0,
                        "time_improvement": 55.59577846304899,
                        "node_improvement": 90.68244774615965,
                        "length_improvement": 12.146014926596825,
                        "smoothness_improvement": 751.5649381737678,
                        "objective_score": 27.72416718574163
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.13319723606109618,
                        "num_nodes_avg": 188.0,
                        "path_length_avg": 238.3577898561583,
                        "smoothness_avg": 0.08697469464231324,
                        "success_improvement": 0.0,
                        "time_improvement": 20.361152609250986,
                        "node_improvement": 87.36813814419135,
                        "length_improvement": 20.429308997437886,
                        "smoothness_improvement": 2137.921538487127,
                        "objective_score": 29.05553887367366
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.035448455810546876,
                        "num_nodes_avg": 130.0,
                        "path_length_avg": 117.7905993166418,
                        "smoothness_avg": 0.11090475199382802,
                        "success_improvement": 0.0,
                        "time_improvement": 29.772661038652487,
                        "node_improvement": 83.47107438016529,
                        "length_improvement": 21.769092519480434,
                        "smoothness_improvement": 1310.7002592242316,
                        "objective_score": 28.546755119405166
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "cross_over",
            "algorithm_description": "IBiHRRT*-Connect: Informed Bidirectional Hash RRT* Connect with cycle-safe rewiring, bounded parent search, and early visibility pruning. It accelerates planning via deduplicated ring-hash nearest neighbors, LOS-bounded parent/rewire radii, exact edge-collision memoization, and a direct/greedy bridge. After the first solution it visibility-prunes and shortcuts for length and smoothness; optional informed sampling focuses subsequent expansions inside the prolate hyperspheroid for faster, shorter improvements.",
            "planning_mechanism": "Alternate growing start/goal trees. Sample goal/informed-biased points (post-solution uses an exact ellipsoid aligned to start\u2013goal). Find a near node via ring-hash; steer one step; choose the lowest-cost LOS parent within a radius; insert only if node and edge are collision-free and grid gate admits; locally rewire cheaper LOS neighbors with ancestor-guarded cost propagation. Attempt to connect the opposite tree directly or via a few greedy steps. On connection, extract the path by parents, visibility-prune, and run shortcut smoothing, then return.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=5.0,\n        goal_bias=0.18,\n        grid_cell_factor=2.0,\n        max_per_cell=7,\n        ring_max=3,\n        parent_radius_factor=2.2,\n        rewire_radius_factor=2.0,\n        connect_steps=4,\n        smoothing_iters=120,\n        post_solution_improve_iters=0\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.max_per_cell = max_per_cell\n        self.ring_max = ring_max\n        self.parent_radius_factor = parent_radius_factor\n        self.rewire_radius_factor = rewire_radius_factor\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n        self.post_solution_improve_iters = post_solution_improve_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self._lcg_state = 123456789\n        self._edge_cache = {}\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Derived params\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.edge_res = max(0.5, min(1.0, self.step_size * 0.5))\n        parent_radius = max(self.step_size * self.parent_radius_factor, self.step_size + 1e-6)\n        rewire_radius = max(self.step_size * self.rewire_radius_factor, self.step_size + 1e-6)\n        self._edge_cache = {}\n        self._lcg_state = 123456789\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            path = self._visibility_prune(path, obstacles, is_3d)\n            path = self._shortcut_smooth(path, obstacles, is_3d, min(60, self.smoothing_iters))\n            nodes = [Node(start), Node(goal)]\n            edges = [(nodes[0], nodes[1])]\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and hashed grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        nodes = [start_root, goal_root]\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        bestcost_start = {}\n        bestcost_goal = {}\n\n        self._grid_add(grid_start, counts_start, bestcost_start, start_root)\n        self._grid_add(grid_goal, counts_goal, bestcost_goal, goal_root)\n\n        # Informed sampling params\n        c_best = float('inf')\n        c_min = self._dist(start, goal)\n        have_solution = False\n        best_path_pts = []\n        best_end_nodes = (None, None)  # (a_last, b_last)\n\n        total_iters = self.max_iter\n\n        it = 0\n        while it < total_iters:\n            a_is_start = (it % 2 == 0)\n            tree_a = start_tree if a_is_start else goal_tree\n            tree_b = goal_tree if a_is_start else start_tree\n            grid_a = grid_start if a_is_start else grid_goal\n            grid_b = grid_goal if a_is_start else grid_start\n            counts_a = counts_start if a_is_start else counts_goal\n            bestcost_a = bestcost_start if a_is_start else bestcost_goal\n            attractor = goal if a_is_start else start\n\n            # Sample: informed ellipsoid if we have a solution, else mild goal bias\n            if have_solution:\n                x_rand = self._sample_informed(obstacles, is_3d, start, goal, c_best, c_min)\n            else:\n                x_rand = self._sample_biased(obstacles, is_3d, attractor)\n\n            # Nearest and steer\n            nearest = self._nearest_hashed(grid_a, tree_a, x_rand)\n            if nearest is None:\n                it += 1\n                continue\n            new_pos = self._steer(nearest.position, x_rand)\n            if (not self._in_bounds(new_pos)) or self._is_in_obstacle(new_pos, obstacles, is_3d):\n                it += 1\n                continue\n            if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                it += 1\n                continue\n            if self._near_duplicate(grid_a, new_pos, self.step_size * 0.6):\n                it += 1\n                continue\n\n            # Choose parent among local LOS neighbors within bounded radius\n            parent = self._choose_parent_local(grid_a, new_pos, nearest, obstacles, is_3d, parent_radius)\n            if self._edge_blocked(parent.position, new_pos, obstacles, is_3d):\n                it += 1\n                continue\n\n            new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n            # Grid admission gate\n            key_new = self._grid_key(new_pos)\n            ccount = counts_a.get(key_new, 0)\n            bestc = bestcost_a.get(key_new, float('inf'))\n            # Allow insertion if cell not full or cost improves best seen in cell\n            if ccount >= self.max_per_cell and not (new_cost + 1e-9 < bestc):\n                it += 1\n                continue\n\n            # Insert node\n            a_new = Node(new_pos, parent=parent, cost=new_cost)\n            parent.add_child(a_new)\n            tree_a.append(a_new)\n            nodes.append(a_new)\n            self._grid_add(grid_a, counts_a, bestcost_a, a_new)\n\n            # Local rewiring with ancestor guard\n            self._rewire_local(grid_a, a_new, obstacles, is_3d, rewire_radius)\n\n            # Try to bridge to other tree: direct or greedy connect\n            bridged = False\n            b_near = self._nearest_hashed(grid_b, tree_b, a_new.position)\n            if b_near is not None:\n                # Direct short bridge if feasible\n                if self._dist(b_near.position, a_new.position) <= self.step_size and not self._edge_blocked(b_near.position, a_new.position, obstacles, is_3d):\n                    # Choose better parent side for final short edge by cost\n                    # No need to alter tree structure; path extraction uses parents and the loose bridge\n                    path = self._extract_path_with_bridge(a_new, b_near, a_is_start)\n                    path = self._visibility_prune(path, obstacles, is_3d)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    plen = self._path_length(path)\n                    if plen + 1e-9 < c_best:\n                        c_best = plen\n                        have_solution = True\n                        best_path_pts = path\n                        best_end_nodes = (a_new, b_near) if a_is_start else (b_near, a_new)\n                        if self.post_solution_improve_iters <= 0:\n                            edges = self._collect_edges(nodes)\n                            return PlannerResult(True, best_path_pts, nodes, edges)\n                        total_iters = it + self.post_solution_improve_iters\n                    bridged = True\n\n            # Greedy connect steps from other tree toward a_new\n            if not bridged:\n                current_target = a_new.position\n                for _ in range(self.connect_steps):\n                    b_near = self._nearest_hashed(grid_b, tree_b, current_target)\n                    if b_near is None:\n                        break\n                    step_to = self._steer(b_near.position, current_target)\n                    if (not self._in_bounds(step_to)) or self._is_in_obstacle(step_to, obstacles, is_3d):\n                        break\n                    if self._edge_blocked(b_near.position, step_to, obstacles, is_3d):\n                        break\n                    # Select parent in other tree for the step\n                    b_parent = self._choose_parent_local(grid_b, step_to, b_near, obstacles, is_3d, parent_radius)\n                    if self._edge_blocked(b_parent.position, step_to, obstacles, is_3d):\n                        break\n                    b_new = Node(step_to, parent=b_parent, cost=b_parent.cost + self._dist(b_parent.position, step_to))\n                    b_parent.add_child(b_new)\n                    tree_b.append(b_new)\n                    nodes.append(b_new)\n                    self._grid_add(grid_b, counts_goal if a_is_start else counts_start, bestcost_goal if a_is_start else bestcost_start, b_new)\n                    self._rewire_local(grid_b, b_new, obstacles, is_3d, rewire_radius)\n\n                    # Final short bridge\n                    if self._dist(b_new.position, a_new.position) <= self.step_size and not self._edge_blocked(b_new.position, a_new.position, obstacles, is_3d):\n                        path = self._extract_path_with_bridge(a_new, b_new, a_is_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        plen = self._path_length(path)\n                        if plen + 1e-9 < c_best:\n                            c_best = plen\n                            have_solution = True\n                            best_path_pts = path\n                            best_end_nodes = (a_new, b_new) if a_is_start else (b_new, a_new)\n                            if self.post_solution_improve_iters <= 0:\n                                edges = self._collect_edges(nodes)\n                                return PlannerResult(True, best_path_pts, nodes, edges)\n                            total_iters = it + self.post_solution_improve_iters\n                        break\n\n            it += 1\n\n        # Finalize\n        if have_solution:\n            edges = self._collect_edges(nodes)\n            return PlannerResult(True, best_path_pts, nodes, edges)\n        edges = self._collect_edges(nodes)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-9:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision and caching\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        hit = self._edge_cache.get(k)\n        if hit is not None:\n            return hit\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Sampling\n    def _sample_biased(self, obstacles, is_3d, attractor):\n        if self._rand() < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        alpha = 0.25\n        if self.dim == 3:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]),\n                   self._uniform(0.0, self.bounds[2]))\n            p = (alpha * attractor[0] + (1.0 - alpha) * rnd[0],\n                 alpha * attractor[1] + (1.0 - alpha) * rnd[1],\n                 alpha * attractor[2] + (1.0 - alpha) * rnd[2])\n        else:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]))\n            p = (alpha * attractor[0] + (1.0 - alpha) * rnd[0],\n                 alpha * attractor[1] + (1.0 - alpha) * rnd[1])\n        if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        # Fallback uniform free sample\n        while True:\n            if self.dim == 3:\n                q = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                q = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(q) and not self._is_in_obstacle(q, obstacles, is_3d):\n                return q\n\n    def _sample_informed(self, obstacles, is_3d, start, goal, c_best, c_min):\n        # If no improvement possible, fallback\n        if not (c_best < float('inf')) or c_best <= c_min + 1e-9:\n            return self._sample_biased(obstacles, is_3d, goal)\n        # Center and unit major axis a_hat\n        center = tuple((start[i] + goal[i]) * 0.5 for i in range(self.dim))\n        a_vec = tuple(goal[i] - start[i] for i in range(self.dim))\n        a_norm = self._norm(a_vec)\n        if a_norm <= 1e-12:\n            return self._sample_biased(obstacles, is_3d, goal)\n        a_hat = tuple(a_vec[i] / a_norm for i in range(self.dim))\n        # Semi-axes\n        r1 = c_best * 0.5\n        if c_best <= c_min:\n            r2 = 0.0\n        else:\n            r2 = (c_best * c_best - c_min * c_min) ** 0.5 * 0.5\n        # Generate a uniform unit n-ball sample\n        for _ in range(50):\n            if self.dim == 3:\n                x = self._uniform(-1.0, 1.0)\n                y = self._uniform(-1.0, 1.0)\n                z = self._uniform(-1.0, 1.0)\n                r2sq = x * x + y * y + z * z\n                if r2sq > 1.0 or r2sq <= 1e-12:\n                    continue\n                # Scale to ellipsoid axes\n                # Build orthonormal basis [a_hat, v, w]\n                u = (1.0, 0.0, 0.0)\n                if abs(a_hat[0]) > 0.9:\n                    u = (0.0, 1.0, 0.0)\n                v = self._normalize(self._cross(a_hat, u))\n                if self._norm(v) <= 1e-12:\n                    v = (0.0, 0.0, 1.0)\n                w = self._cross(a_hat, v)\n                # Compose point\n                # Map unit ball sample to ellipsoid using radii [r1, r2, r2]\n                # First, a random direction on unit ball is (x,y,z) with |.|<=1; keep distribution via cube sampling\n                # Use as coordinates in basis\n                px = r1 * x\n                py = r2 * y\n                pz = r2 * z\n                ex = center[0] + px * a_hat[0] + py * v[0] + pz * w[0]\n                ey = center[1] + px * a_hat[1] + py * v[1] + pz * w[1]\n                ez = center[2] + px * a_hat[2] + py * v[2] + pz * w[2]\n                p = (ex, ey, ez)\n            else:\n                x = self._uniform(-1.0, 1.0)\n                y = self._uniform(-1.0, 1.0)\n                if x * x + y * y > 1.0:\n                    continue\n                # 2D orthonormal basis: a_hat and its perpendicular\n                perp = (-a_hat[1], a_hat[0])\n                px = r1 * x\n                py = r2 * y\n                ex = center[0] + px * a_hat[0] + py * perp[0]\n                ey = center[1] + px * a_hat[1] + py * perp[1]\n                p = (ex, ey)\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Fallback\n        return self._sample_biased(obstacles, is_3d, goal)\n\n    def _norm(self, v):\n        s = 0.0\n        for i in range(len(v)):\n            s += v[i] * v[i]\n        return s ** 0.5\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n <= 1e-12:\n            if len(v) == 3:\n                return (1.0, 0.0, 0.0)\n            return (1.0, 0.0)\n        return tuple(v[i] / n for i in range(len(v)))\n\n    def _cross(self, a, b):\n        return (a[1] * b[2] - a[2] * b[1],\n                a[2] * b[0] - a[0] * b[2],\n                a[0] * b[1] - a[1] * b[0])\n\n    # Grid / NN\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n        bc = bestcost.get(k)\n        if bc is None or node.cost < bc:\n            bestcost[k] = node.cost\n\n    def _ring_cells(self, key, r):\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        yield (key[0] + dx, key[1] + dy, key[2] + dz)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    yield (key[0] + dx, key[1] + dy)\n\n    def _grid_ring_collect_unique(self, grid, key, r):\n        cand = []\n        seen = set()\n        for cell in self._ring_cells(key, r):\n            bucket = grid.get(cell)\n            if bucket:\n                for n in bucket:\n                    nid = id(n)\n                    if nid not in seen:\n                        seen.add(nid)\n                        cand.append(n)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.ring_max + 1):\n            cand = self._grid_ring_collect_unique(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback random subset if grid sparse\n        if not tree:\n            return None\n        tries = min(64, len(tree))\n        for _ in range(tries):\n            idx = int(self._uniform(0, len(tree)))\n            n = tree[idx]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        cand = self._grid_ring_collect_unique(grid, key, 1)\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                return True\n        return False\n\n    # Parent selection among LOS neighbors with bounded radius\n    def _choose_parent_local(self, grid, new_pos, fallback_nearest, obstacles, is_3d, radius_bound):\n        key = self._grid_key(new_pos)\n        best_parent = fallback_nearest\n        best_cost = fallback_nearest.cost + self._dist(fallback_nearest.position, new_pos)\n        max_r = max(1, self.ring_max)\n        for r in range(0, max_r + 1):\n            cand = self._grid_ring_collect_unique(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                if n is fallback_nearest or n is best_parent:\n                    continue\n                dnp = self._dist(n.position, new_pos)\n                if dnp > radius_bound:\n                    continue\n                if self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                    continue\n                c = n.cost + dnp\n                if c + 1e-12 < best_cost:\n                    best_cost = c\n                    best_parent = n\n        return best_parent\n\n    # Local rewiring with ancestor guard\n    def _rewire_local(self, grid, pivot, obstacles, is_3d, radius):\n        key = self._grid_key(pivot.position)\n        for r in range(0, max(1, self.ring_max) + 1):\n            cand = self._grid_ring_collect_unique(grid, key, r)\n            if not cand:\n                continue\n            for nb in cand:\n                if nb is pivot or nb.parent is pivot:\n                    continue\n                if self._dist(nb.position, pivot.position) > radius:\n                    continue\n                if self._is_ancestor(nb, pivot):\n                    continue\n                if self._edge_blocked(pivot.position, nb.position, obstacles, is_3d):\n                    continue\n                new_cost = pivot.cost + self._dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    old_parent = nb.parent\n                    if old_parent is not None:\n                        try:\n                            old_parent.children.remove(nb)\n                        except Exception:\n                            pass\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    self._propagate_cost_from(nb)\n\n    def _is_ancestor(self, node, potential_child):\n        cur = potential_child\n        while cur is not None:\n            if cur is node:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_cost_from(self, node):\n        queue = [node]\n        qi = 0\n        while qi < len(queue):\n            cur = queue[qi]\n            qi += 1\n            for ch in cur.children:\n                new_c = cur.cost + self._dist(cur.position, ch.position)\n                if abs(new_c - ch.cost) > 1e-12:\n                    ch.cost = new_c\n                    queue.append(ch)\n\n    # Path utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path_with_bridge(self, a_node, b_node, a_is_start_tree):\n        path_a = self._path_to_root(a_node)\n        path_b = self._path_to_root(b_node)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        # Deterministic forward pass then random refinements\n        changed = True\n        passes = 0\n        while changed and passes < 3:\n            changed = False\n            i = 0\n            while i < len(pts) - 2:\n                a = pts[i]\n                k = len(pts) - 1\n                improved = False\n                while k > i + 1:\n                    b = pts[k]\n                    if not self._edge_blocked(a, b, obstacles, is_3d):\n                        mid_len = 0.0\n                        for t in range(i + 1, k + 1):\n                            mid_len += self._dist(pts[t - 1], pts[t])\n                        if self._dist(a, b) + 1e-9 < mid_len:\n                            pts = pts[:i + 1] + pts[k:]\n                            changed = True\n                            improved = True\n                            break\n                    k -= 1\n                if not improved:\n                    i += 1\n            passes += 1\n        # Random pair shortcuts\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts\n\n    def _collect_edges(self, nodes):\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return edges",
            "objective": -29.84512,
            "time_improvement": 32.0,
            "length_improvement": 21.0,
            "smoothness_improvement": 1485.0,
            "node_improvement": 87.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01609337329864502,
                    "num_nodes_avg": 47.0,
                    "path_length_avg": 148.48852810021452,
                    "smoothness_avg": 0.041946328850586606,
                    "success_improvement": 0.0,
                    "time_improvement": 34.76882726816771,
                    "node_improvement": 88.16419038025687,
                    "length_improvement": 18.611084796972406,
                    "smoothness_improvement": 556.551134422692,
                    "objective_score": 24.38005473074722
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.15710897445678712,
                    "num_nodes_avg": 225.0,
                    "path_length_avg": 230.98780524572462,
                    "smoothness_avg": 0.11927323645742623,
                    "success_improvement": 0.0,
                    "time_improvement": 6.0642847367940815,
                    "node_improvement": 84.88208022576093,
                    "length_improvement": 22.889621993645612,
                    "smoothness_improvement": 2968.9862830893276,
                    "objective_score": 30.397990032672226
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022504901885986327,
                    "num_nodes_avg": 105.0,
                    "path_length_avg": 116.73701153822624,
                    "smoothness_avg": 0.08099784362284458,
                    "success_improvement": 0.0,
                    "time_improvement": 55.41528292555973,
                    "node_improvement": 86.6497139224412,
                    "length_improvement": 22.46883535544535,
                    "smoothness_improvement": 930.2865922436716,
                    "objective_score": 34.75731905215349
                }
            ],
            "success_rate": 1.0
        },
        "objective": 11.399999999999999,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Coarse expansion steps and limited short-range connection depth produce kinked joins and longer polyline routes around obstacles.\n   - Goal-directed sampling is overly aggressive, biasing growth into blocked fronts and missing shorter feasible corridors.\n   - Local rewiring lacks cycle protection, risking malformed parent-child relations that suppress or undo cost-reducing rewires.\n   - Post-connection smoothing is weak (random-only, fewer passes), leaving redundant vertices and detours in the final path."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Finer step size with slightly deeper short-range connection attempts.\n   - Moderated goal bias for more balanced exploration around obstacles.\n   - Cycle-safe local rewiring that reliably accepts cheaper parents and propagates cost decreases.\n   - Stronger shortcutting (deterministic forward passes plus more iterations) before returning the solution.\n   - Tighter local parent/rewire radii that favor nearer, straighter segments.\n2. Expected mechanism of impact:\n   - Denser, more accurate expansions and longer local connects reduce zig-zagging and shorten the bridge between trees.\n   - Less greedy sampling uncovers tighter corridors and avoids detours, lowering total path length.\n   - Reliable rewiring realizes local cost improvements, straightening subtrees and trimming excess length.\n   - Deterministic then stochastic shortcutting removes superfluous waypoints and long detours, contracting the polyline.\n   - Preference for nearby line-of-sight parents curbs long, indirect edges, yielding more direct, shorter polylines."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "IRRT*-Balance: Simplified Informed BiRRT* with neighbor choose-parent, bounded local rewiring, obstacle-grid accelerated collision checks, and balanced connect. It minimizes per-iteration work while improving path length and smoothness by selecting optimal parents over nearby nodes and applying light two-stage shortcutting.",
                "planning_mechanism": "At each iteration, expand the smaller tree: draw a guided sample (uniform/corridor; ellipse after a first solution), steer one step, verify node and edge, choose the cheapest collision-free parent among nearby nodes, insert, and rewire cheaper neighbors. Greedily connect the opposite tree toward the new node; if a final collision-free chord exists, extract and shortcut the path, then return.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3500,\n        step_size=6.0,\n        beam_k=2,\n        goal_bias=0.2,\n        corridor_bias=0.35,\n        rewire_radius_factor=2.0,\n        min_sep_ratio=0.3,\n        grid_cell_factor=1.0,\n        connect_steps=28,\n        shortcut_attempts=70\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.rewire_radius_factor = rewire_radius_factor\n        self.min_sep_ratio = min_sep_ratio\n        self.grid_cell_factor = grid_cell_factor\n        self.connect_steps = connect_steps\n        self.shortcut_attempts = shortcut_attempts\n        self._rnd_state = 123456789\n\n    def plan(self, map):\n        # Scene\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # Derived\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_ratio)\n        self.rewire_radius = max(self.step_size * 1.2, self.step_size * self.rewire_radius_factor)\n\n        # Seed PRNG\n        self._seed_from_scene()\n\n        nodes = []\n        edges = []\n\n        # Validate start/goal\n        if (not self._within_bounds(self.start)) or (not self._within_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Build obstacle grid and validate start/goal clearance\n        self._build_obstacle_grid()\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Init trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_len = None\n\n        # Main loop\n        for _ in range(self.max_iter):\n            # Balance: expand smaller tree\n            if len(tree_a) <= len(tree_b):\n                active_tree, active_grid = tree_a, grid_a\n                passive_tree, passive_grid = tree_b, grid_b\n                attractor = self.goal\n            else:\n                active_tree, active_grid = tree_b, grid_b\n                passive_tree, passive_grid = tree_a, grid_a\n                attractor = self.start\n\n            last_new = None\n\n            for _b in range(self.beam_k):\n                s = self._guided_sample(attractor, best_len)\n                if s is None:\n                    continue\n\n                nearest = self._nearest_in_grid(active_grid, s)\n                if nearest is None:\n                    continue\n\n                new_pos = self._steer(nearest.position, s, self.step_size)\n                if not self._within_bounds(new_pos):\n                    continue\n                if self._point_in_obstacles(new_pos):\n                    continue\n                # Suppress near-duplicate only within active grid (avoid over-pruning)\n                if self._has_nearby(active_grid, new_pos, self.min_sep):\n                    continue\n\n                # Choose parent over nearby neighbors (RRT* choose-parent)\n                neigh = self._nearby_nodes(active_grid, new_pos, self.rewire_radius)\n                parent, parent_cost = self._choose_parent(nearest, neigh, new_pos)\n                if parent is None:\n                    continue\n\n                # Final checks before insertion (both checks)\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if not self._edge_free(parent.position, new_pos):\n                    continue\n\n                # Insert node\n                new_cost = parent_cost\n                new_node = Node(new_pos, parent, new_cost)\n                parent.add_child(new_node)\n                active_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((parent, new_node))\n                self._grid_insert(active_grid, new_node)\n                last_new = new_node\n\n                # Local rewiring\n                self._rewire_neighbors(new_node, neigh, edges)\n\n                # Attempt connect from passive tree toward new node\n                meet = self._connect_toward(passive_tree, passive_grid, new_node.position, nodes, edges)\n                if meet is not None and self._edge_free(meet.position, new_node.position):\n                    # Extract path\n                    path = self._extract_path(new_node, meet)\n                    best_len = self._path_len(path)\n                    path = self._shortcut(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n            if last_new is None:\n                continue\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # ---------- PRNG ----------\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 1000 + 0.5)) & 0x7fffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0x7fffffff\n        self._rnd_state = (s ^ 0x9E3779B9) & 0x7fffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 123456789\n\n    def _rand(self):\n        self._rnd_state = (1103515245 * self._rnd_state + 12345) & 0x7fffffff\n        return self._rnd_state / 2147483647.0\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        q = []\n        for i in range(self.dims):\n            v = p[i]\n            if v < 0.0:\n                v = 0.0\n            elif v > self.bounds[i]:\n                v = self.bounds[i]\n            q.append(v)\n        return tuple(q)\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # ---------- Node spatial grid ----------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        cand = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        return cand\n\n    def _nearest_in_grid(self, grid, pos, max_ring=4):\n        key = self._cell_of(pos)\n        best = None\n        bestd2 = 1e100\n        for r in range(0, max_ring + 1):\n            cand = self._ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            if best is not None:\n                return best\n        # Fallback: approximate by random in buckets\n        buckets = list(grid.values())\n        if not buckets:\n            return None\n        trials = 0\n        while trials < 24:\n            bucket = buckets[int(self._rand() * len(buckets)) % max(1, len(buckets))]\n            if bucket:\n                n = bucket[int(self._rand() * len(bucket)) % max(1, len(bucket))]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            trials += 1\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        rc = int(radius // self.cell_size) + 1\n        r2 = radius * radius\n        cand = self._ring_collect(grid, key, rc)\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                return True\n        return False\n\n    def _nearby_nodes(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        rc = int(radius // self.cell_size) + 1\n        r2 = radius * radius\n        cand = self._ring_collect(grid, key, rc)\n        out = []\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    # ---------- Obstacle spatial grid ----------\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            key = (cx, cy, cz)\n                            bucket = self.obs_grid.get(key)\n                            if bucket is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                bucket.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        key = (cx, cy)\n                        bucket = self.obs_grid.get(key)\n                        if bucket is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    # ---------- Collision ----------\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bucket = self.obs_grid.get((cx, cy, cz))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bucket = self.obs_grid.get((cx, cy))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # ---------- Parent selection and rewiring ----------\n    def _choose_parent(self, nearest, neigh, new_pos):\n        best_parent = None\n        best_cost = 1e100\n        # Always consider nearest\n        cand = [nearest] + [n for n in neigh if n is not nearest]\n        for n in cand:\n            # Edge collision check to candidate parent\n            if not self._edge_free(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-9 < best_cost:\n                best_cost = c\n                best_parent = n\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    def _rewire_neighbors(self, new_node, neigh, edges):\n        for nb in neigh:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            # Avoid cycles: don't rewire ancestors of new_node\n            if self._is_ancestor(new_node, nb):\n                continue\n            cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand_cost + 1e-9 < nb.cost and self._edge_free(new_node.position, nb.position):\n                # Perform rewiring (edge already collision-validated)\n                old_parent = nb.parent\n                if old_parent is not None:\n                    try:\n                        old_parent.children.remove(nb)\n                    except:\n                        pass\n                    self._remove_edge(edges, (old_parent, nb))\n                new_node.add_child(nb)\n                delta = cand_cost - nb.cost\n                nb.cost = cand_cost\n                edges.append((new_node, nb))\n                self._propagate_cost(nb, delta)\n\n    def _is_ancestor(self, node, candidate_ancestor):\n        cur = node.parent\n        while cur is not None:\n            if cur is candidate_ancestor:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_cost(self, node, delta):\n        stack = [node]\n        while stack:\n            n = stack.pop()\n            n.cost += delta\n            for c in n.children:\n                stack.append(c)\n\n    def _remove_edge(self, edges, pair):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is pair[0] and edges[i][1] is pair[1]:\n                del edges[i]\n                break\n\n    # ---------- Connect attempt ----------\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        near = self._nearest_in_grid(grid, target_pos)\n        if near is None:\n            return None\n        cur = near\n        steps = 0\n        last_added = None\n        while steps < self.connect_steps:\n            nxt_pos = self._steer(cur.position, target_pos, self.step_size)\n            # Stop if movement is negligible\n            if self._dist2(cur.position, nxt_pos) < (self.min_sep * self.min_sep * 0.25):\n                break\n            if not self._within_bounds(nxt_pos):\n                break\n            if self._point_in_obstacles(nxt_pos):\n                break\n            if self._has_nearby(grid, nxt_pos, self.min_sep):\n                break\n            if not self._edge_free(cur.position, nxt_pos):\n                break\n            # Insert step node (both checks satisfied)\n            new_cost = cur.cost + self._dist(cur.position, nxt_pos)\n            q = Node(nxt_pos, cur, new_cost)\n            cur.add_child(q)\n            tree.append(q)\n            nodes.append(q)\n            edges.append((cur, q))\n            self._grid_insert(grid, q)\n            last_added = q\n            cur = q\n            steps += 1\n            # If close enough and final chord to target is free, return meeting node\n            if self._dist2(cur.position, target_pos) <= (self.step_size * self.step_size) and self._edge_free(cur.position, target_pos):\n                return cur\n        return last_added\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, attractor, incumbent_len):\n        # Mixture: direct attractor, corridor along start-goal, or uniform; ellipse after first path\n        for _ in range(20):\n            r = self._rand()\n            if incumbent_len is not None and self._dist(self.start, self.goal) > 1e-9 and r < 0.6:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_sample()\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if p is not None and self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        # Fallback\n        if self._within_bounds(attractor) and not self._point_in_obstacles(attractor):\n            return attractor\n        return None\n\n    def _corridor_sample(self):\n        # Sample around the line segment between start and goal\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        dsg = self._dist(self.start, self.goal)\n        width = max(self.step_size, 0.08 * dsg)\n        if self.is_3d:\n            p = (self._clamp_val(base[0] + self._rand_range(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._rand_range(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._rand_range(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._rand_range(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._rand_range(-width, width), 0.0, self.bounds[1]))\n        return p\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        ext = [max(self.step_size, half)] * self.dims\n        for _ in range(18):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum_dist and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---------- Path handling ----------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        pb_rev = pb[::-1]\n        if pa and pb_rev and pa[-1] == pb_rev[0]:\n            pb_rev = pb_rev[1:]\n        return pa + pb_rev\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        # Greedy long-span removal\n        i = 0\n        while i < len(pts) - 2:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n        # Randomized refinement\n        attempts = 0\n        while attempts < self.shortcut_attempts and len(pts) > 2:\n            i = int(self._rand_range(0, len(pts) - 2))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                attempts += 1\n                continue\n            # Prefer longer spans\n            if (j - i) < 3 and self._rand() < 0.6:\n                attempts += 1\n                continue\n            if self._edge_free(pts[i], pts[j]):\n                pts = pts[:i + 1] + pts[j:]\n            attempts += 1\n        return pts",
                "objective": -30.89253,
                "time_improvement": 40.0,
                "length_improvement": 17.0,
                "smoothness_improvement": 1691.0,
                "node_improvement": 84.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.024645376205444335,
                        "num_nodes_avg": 76.0,
                        "path_length_avg": 151.74061274417835,
                        "smoothness_avg": 0.04953752500528684,
                        "success_improvement": 0.0,
                        "time_improvement": 0.10504556967652061,
                        "node_improvement": 80.86124401913875,
                        "length_improvement": 16.828565671036927,
                        "smoothness_improvement": 675.3698387900448,
                        "objective_score": 13.505502267475338
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.04964156150817871,
                        "num_nodes_avg": 186.0,
                        "path_length_avg": 250.78572879945872,
                        "smoothness_avg": 0.12425595091598525,
                        "success_improvement": 0.0,
                        "time_improvement": 70.31922840069336,
                        "node_improvement": 87.5025196532957,
                        "length_improvement": 16.28050525977595,
                        "smoothness_improvement": 3097.1951150122113,
                        "objective_score": 46.35004725113463
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.024727296829223634,
                        "num_nodes_avg": 132.0,
                        "path_length_avg": 122.93086491206807,
                        "smoothness_avg": 0.11014540994501384,
                        "success_improvement": 0.0,
                        "time_improvement": 51.01247102822808,
                        "node_improvement": 83.21678321678321,
                        "length_improvement": 18.355172864142737,
                        "smoothness_improvement": 1301.041484412115,
                        "objective_score": 32.822052449014635
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "SIBiRRT-Connect-Lite: A streamlined balanced informed BiRRT-Connect with light neighbor parent selection, grid-accelerated proximity/collision, and two-phase shortcut refinement for faster search, shorter paths, and improved smoothness.",
            "planning_mechanism": "Per iteration, expand the smaller tree: sample from a mixed distribution (uniform/corridor/goal; ellipse after a first solution), steer one bounded step, validate node and edge, pick the cheapest feasible parent among the nearest few neighbors, insert, then greedily connect the opposite tree toward it until blocked. On connection, extract and shortcut the path and return.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=6.0,\n        goal_bias=0.25,\n        corridor_bias=0.35,\n        grid_cell_factor=1.0,\n        min_sep_ratio=0.3,\n        neighbor_radius_factor=2.0,\n        neighbor_cap=6,\n        connect_steps=32,\n        shortcut_attempts=80\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.min_sep_ratio = min_sep_ratio\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.neighbor_cap = neighbor_cap\n        self.connect_steps = connect_steps\n        self.shortcut_attempts = shortcut_attempts\n        self._rnd_state = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_ratio)\n        self.neighbor_radius = max(self.step_size * 1.2, self.step_size * self.neighbor_radius_factor)\n\n        self._seed_from_scene()\n\n        nodes = []\n        edges = []\n\n        if (not self._within_bounds(self.start)) or (not self._within_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._build_obstacle_grid()\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        incumbent_len = None\n\n        for _ in range(self.max_iter):\n            if len(tree_a) <= len(tree_b):\n                active_tree, active_grid = tree_a, grid_a\n                passive_tree, passive_grid = tree_b, grid_b\n                attractor = self.goal\n            else:\n                active_tree, active_grid = tree_b, grid_b\n                passive_tree, passive_grid = tree_a, grid_a\n                attractor = self.start\n\n            s = self._sample(attractor, incumbent_len)\n            if s is None:\n                continue\n\n            nearest = self._nearest_in_grid(active_grid, s)\n            if nearest is None:\n                continue\n\n            new_pos = self._steer(nearest.position, s, self.step_size)\n            if not self._within_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._has_nearby(active_grid, new_pos, self.min_sep):\n                continue\n\n            parent, new_cost = self._choose_parent_light(active_grid, nearest, new_pos)\n            if parent is None:\n                continue\n\n            if self._point_in_obstacles(new_pos):\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(active_grid, new_node)\n\n            meet = self._connect_toward(passive_tree, passive_grid, new_node.position, nodes, edges)\n            if meet is not None and self._edge_free(meet.position, new_node.position):\n                path = self._extract_path(new_node, meet)\n                incumbent_len = self._path_len(path)\n                path = self._shortcut(path)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0x7fffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0x7fffffff\n        self._rnd_state = (s ^ 0x9E3779B9) & 0x7fffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 123456789\n\n    def _rand(self):\n        self._rnd_state = (1103515245 * self._rnd_state + 12345) & 0x7fffffff\n        return self._rnd_state / 2147483647.0\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            q = []\n            for i in range(self.dims):\n                q.append(self._clamp_val(b[i], 0.0, self.bounds[i]))\n            return tuple(q)\n        d = d2 ** 0.5\n        r = step / d\n        q = []\n        for i in range(self.dims):\n            v = a[i] + (b[i] - a[i]) * r\n            q.append(self._clamp_val(v, 0.0, self.bounds[i]))\n        return tuple(q)\n\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_in_grid(self, grid, pos, max_ring=4):\n        key = self._cell_of(pos)\n        best = None\n        bestd2 = 1e100\n        for r in range(0, max_ring + 1):\n            cand = self._ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            if best is not None:\n                return best\n        buckets = list(grid.values())\n        if not buckets:\n            return None\n        trials = 0\n        while trials < 24:\n            b = buckets[int(self._rand() * len(buckets)) % max(1, len(buckets))]\n            if b:\n                n = b[int(self._rand() * len(b)) % max(1, len(b))]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            trials += 1\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        rc = int(radius // self.cell_size) + 1\n        r2 = radius * radius\n        for n in self._ring_collect(grid, key, rc):\n            if self._dist2(n.position, pos) <= r2:\n                return True\n        return False\n\n    def _nearby_nodes(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        rc = int(radius // self.cell_size) + 1\n        r2 = radius * radius\n        out = []\n        for n in self._ring_collect(grid, key, rc):\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy, cz))\n            if not b:\n                return False\n            px, py, pz = p\n            for idx in b:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy))\n            if not b:\n                return False\n            px, py = p\n            for idx in b:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _choose_parent_light(self, grid, nearest, new_pos):\n        neigh = self._nearby_nodes(grid, new_pos, self.neighbor_radius)\n        if nearest not in neigh:\n            neigh.append(nearest)\n        neigh.sort(key=lambda n: self._dist2(n.position, new_pos))\n        cand = neigh[:max(1, self.neighbor_cap)]\n        best_parent = None\n        best_cost = 1e100\n        for n in cand:\n            if not self._edge_free(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-9 < best_cost:\n                best_cost = c\n                best_parent = n\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        near = self._nearest_in_grid(grid, target_pos)\n        if near is None:\n            return None\n        cur = near\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(cur.position, target_pos, self.step_size)\n            if self._dist2(cur.position, nxt) < (self.min_sep * self.min_sep * 0.25):\n                break\n            if not self._within_bounds(nxt):\n                break\n            if self._point_in_obstacles(nxt):\n                break\n            if self._has_nearby(grid, nxt, self.min_sep):\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            q = Node(nxt, cur, new_cost)\n            cur.add_child(q)\n            tree.append(q)\n            nodes.append(q)\n            edges.append((cur, q))\n            self._grid_insert(grid, q)\n            cur = q\n            steps += 1\n            if self._dist2(cur.position, target_pos) <= (self.step_size * self.step_size) and self._edge_free(cur.position, target_pos):\n                return cur\n        return None\n\n    def _sample(self, attractor, incumbent_len):\n        for _ in range(20):\n            r = self._rand()\n            if incumbent_len is not None and r < 0.55:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_sample()\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if p is not None and self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        if self._within_bounds(attractor) and not self._point_in_obstacles(attractor):\n            return attractor\n        return None\n\n    def _corridor_sample(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        dsg = self._dist(self.start, self.goal)\n        width = max(self.step_size, 0.08 * dsg)\n        if self.is_3d:\n            return (\n                self._clamp_val(base[0] + self._rand_range(-width, width), 0.0, self.bounds[0]),\n                self._clamp_val(base[1] + self._rand_range(-width, width), 0.0, self.bounds[1]),\n                self._clamp_val(base[2] + self._rand_range(-width, width), 0.0, self.bounds[2]),\n            )\n        else:\n            return (\n                self._clamp_val(base[0] + self._rand_range(-width, width), 0.0, self.bounds[0]),\n                self._clamp_val(base[1] + self._rand_range(-width, width), 0.0, self.bounds[1]),\n            )\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        ext = [max(self.step_size, half)] * self.dims\n        for _ in range(18):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum_dist and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        pb.reverse()\n        if pa and pb and pa[-1] == pb[0]:\n            pb = pb[1:]\n        return pa + pb\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        i = 0\n        while i < len(pts) - 2:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n        attempts = 0\n        while attempts < self.shortcut_attempts and len(pts) > 2:\n            i = int(self._rand_range(0, len(pts) - 2))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                attempts += 1\n                continue\n            if self._edge_free(pts[i], pts[j]):\n                pts = pts[:i + 1] + pts[j:]\n            attempts += 1\n        return pts",
            "objective": -37.09124,
            "time_improvement": 61.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1377.0,
            "node_improvement": 87.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011144709587097169,
                    "num_nodes_avg": 49.0,
                    "path_length_avg": 150.61019244127573,
                    "smoothness_avg": 0.04827733550563596,
                    "success_improvement": 0.0,
                    "time_improvement": 54.82721598316178,
                    "node_improvement": 87.6605389070763,
                    "length_improvement": 17.448166951713837,
                    "smoothness_improvement": 655.6451365752101,
                    "objective_score": 30.195290648852886
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04703662395477295,
                    "num_nodes_avg": 160.0,
                    "path_length_avg": 222.69131300634007,
                    "smoothness_avg": 0.08728289130799861,
                    "success_improvement": 0.0,
                    "time_improvement": 71.87672486543198,
                    "node_improvement": 89.24947927165222,
                    "length_improvement": 25.65922990444059,
                    "smoothness_improvement": 2145.851660680297,
                    "objective_score": 47.68781370569543
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02253601551055908,
                    "num_nodes_avg": 116.0,
                    "path_length_avg": 125.1119046359757,
                    "smoothness_avg": 0.11227318427452833,
                    "success_improvement": 0.0,
                    "time_improvement": 55.35364337006359,
                    "node_improvement": 85.2511125238398,
                    "length_improvement": 16.906630129474358,
                    "smoothness_improvement": 1328.1066168275754,
                    "objective_score": 33.39060417284157
                }
            ],
            "success_rate": 1.0
        },
        "objective": 10.8,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Large neighbor sets with full rewiring increase per-insert cost, reducing exploration density and missing cheaper homotopies.\n   - Multi-branch expansion produces redundant near-duplicate rejections and excess collision checks, limiting effective progress per iteration.\n   - Strong ellipse/corridor focus after a first solution causes premature commitment to suboptimal corridors.\n   - Shorter connect horizon and early halts near existing nodes reduce opportunities to realize long, straight chords between trees.\n   - Approximate nearest queries over broad neighborhoods can attach to distant or obstructed parents, introducing detours that increase path length."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Lightweight parent selection capped to the nearest few candidates, emphasizing close, low-cost attachments.\n   - Single-sample expansion (no beam), reducing duplicate rejections and concentrating computation on deeper, productive extensions.\n   - Slightly stronger goal attraction and a longer connect horizon to encourage straighter, longer free-space merges.\n   - Reduced ellipse emphasis to maintain sampling diversity and avoid locking into suboptimal corridors.\n   - Increased shortcut attempts to remove residual bends and detours.\n2. Expected mechanism of impact:\n   - Lower per-insert overhead yields more successful extensions within the iteration budget, increasing chances of near-straight connections and shorter initial paths.\n   - Capped neighbor consideration avoids distant or obstructed parents, producing tighter, more direct tree geometry and reduced total length.\n   - Extended connect steps and stronger goal-directed growth create longer straight chords at meeting time, cutting intermediate waypoints and overall distance.\n   - Sustained sampling diversity after an incumbent path helps discover shorter homotopies missed by more biased strategies.\n   - Additional shortcutting opportunistically replaces multi-turn segments with single chords, further trimming path length."
        }
    },
    {
        "parents": [
            {
                "operator": "cross_over",
                "algorithm_description": "ARC-BiRRT: Adaptive Reuse-Cached, Ring-Hashed, Cost-Gated BiRRT-Connect. It accelerates bidirectional planning with exact edge-collision memoization, ring-hash nearest search, local LOS parent selection, per-cell cost-gated admission, and single-shot tree bridging; upon success it applies cache-reused visibility pruning and bounded shortcut smoothing for shorter, smoother paths.",
                "planning_mechanism": "Alternate expanding start/goal trees with small-beam guided sampling (goal/corridor bias); find a near node via ring-hash, steer one step, enforce node+edge checks and near-duplicate rejection; pick a best-cost parent among nearby ring neighbors that see the new point; admit only if per-cell capacity or cost improves; after insertion, attempt a direct LOS bridge to the opposite tree; on success, extract and cache-prune/shortcut the path and stop early.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.5,\n        beam_width=2,\n        goal_bias=0.3,\n        grid_cell_factor=1.6,\n        ring_max=3,\n        max_per_cell=6,\n        min_sep_factor=0.5,\n        los_neighbor_rings=1,\n        smoothing_iters=50,\n        corridor_bias=0.5\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.ring_max = ring_max\n        self.max_per_cell = max_per_cell\n        self.min_sep_factor = min_sep_factor\n        self.los_neighbor_rings = los_neighbor_rings\n        self.smoothing_iters = smoothing_iters\n        self.corridor_bias = corridor_bias\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # RNG state\n        self._lcg_state = 2463534242\n\n        # Caches\n        self._edge_cache = {}  # exact endpoints (ordered) -> bool blocked\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Derived params\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.3, self.step_size * self.min_sep_factor)\n        self.edge_res = max(0.5, min(1.0, self.step_size * 0.5))\n\n        # Reset caches\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            path = self._visibility_prune(path, obstacles, is_3d)\n            path = self._shortcut_smooth(path, obstacles, is_3d, iters=min(10, self.smoothing_iters))\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        bestcost_start = {}\n        bestcost_goal = {}\n\n        self._grid_add(grid_start, counts_start, bestcost_start, start_root)\n        self._grid_add(grid_goal, counts_goal, bestcost_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n\n            tree_a = start_tree if active_start else goal_tree\n            grid_a = grid_start if active_start else grid_goal\n            counts_a = counts_start if active_start else counts_goal\n            bestcost_a = bestcost_start if active_start else bestcost_goal\n\n            tree_b = goal_tree if active_start else start_tree\n            grid_b = grid_goal if active_start else grid_start\n            counts_b = counts_goal if active_start else counts_start\n            bestcost_b = bestcost_goal if active_start else bestcost_start\n\n            attractor = goal if active_start else start\n\n            for _ in range(self.beam_width):\n                x_rand = self._guided_sample(obstacles, is_3d, attractor)\n\n                nearest = self._nearest_hashed(grid_a, tree_a, x_rand)\n                if nearest is None:\n                    continue\n\n                new_pos = self._steer(nearest.position, x_rand)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                if self._near_duplicate(grid_a, new_pos, self.min_sep):\n                    continue\n\n                # Choose a parent among local neighbors with LOS (limited rings) for better path cost\n                parent = self._choose_parent_local(grid_a, new_pos, nearest, obstacles, is_3d)\n                if self._edge_blocked(parent.position, new_pos, obstacles, is_3d):\n                    continue  # safety\n\n                new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n                # Per-cell cost-gated admission\n                key_new = self._grid_key(new_pos)\n                ccount = counts_a.get(key_new, 0)\n                bestc = bestcost_a.get(key_new, float('inf'))\n                if ccount >= self.max_per_cell and not (new_cost + 1e-9 < bestc):\n                    continue\n\n                # Insert node\n                new_node = Node(new_pos, parent=parent, cost=new_cost)\n                parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((parent, new_node))\n                self._grid_add(grid_a, counts_a, bestcost_a, new_node)\n\n                # Try single-shot direct bridge to the other tree\n                other_near = self._nearest_hashed(grid_b, tree_b, new_node.position)\n                if other_near is not None:\n                    if not self._edge_blocked(new_node.position, other_near.position, obstacles, is_3d):\n                        path = self._extract_path(new_node, other_near, a_is_start_tree=active_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-9:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision and caching\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        if k in self._edge_cache:\n            return self._edge_cache[k]\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _guided_sample(self, obstacles, is_3d, attractor):\n        # Goal-biased with optional corridor pull (activated only after success; here kept generic)\n        if self._rand() < self.goal_bias:\n            p = attractor\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Mild blend toward attractor\n        alpha = 0.2\n        if self.dim == 3:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]),\n                   self._uniform(0.0, self.bounds[2]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(3))\n        else:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(2))\n        if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    # Grid / NN\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n        bc = bestcost.get(k)\n        if bc is None or node.cost < bc:\n            bestcost[k] = node.cost\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.ring_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback to limited random subset to avoid O(N)\n        if not tree:\n            return None\n        trials = min(64, len(tree))\n        for _ in range(trials):\n            idx = int(self._uniform(0, len(tree)))\n            n = tree[idx]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r = 1\n        cand = self._grid_ring_collect(grid, key, r)\n        rr = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # Parent selection among local neighbors with LOS\n    def _choose_parent_local(self, grid, new_pos, fallback_nearest, obstacles, is_3d):\n        key = self._grid_key(new_pos)\n        best_parent = fallback_nearest\n        best_cost = fallback_nearest.cost + self._dist(fallback_nearest.position, new_pos)\n        max_r = max(1, self.los_neighbor_rings)\n        for r in range(0, max_r + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            for n in cand:\n                if n is fallback_nearest or n is best_parent:\n                    pass\n                # Check LOS\n                if not self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                    c = n.cost + self._dist(n.position, new_pos)\n                    if c + 1e-9 < best_cost:\n                        best_cost = c\n                        best_parent = n\n        return best_parent\n\n    # Path\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
                "objective": -33.74569,
                "time_improvement": 58.0,
                "length_improvement": 18.0,
                "smoothness_improvement": 1051.0,
                "node_improvement": 90.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.010497808456420898,
                        "num_nodes_avg": 34.0,
                        "path_length_avg": 154.57051194099205,
                        "smoothness_avg": 0.03958955729868922,
                        "success_improvement": 0.0,
                        "time_improvement": 58.830179046785545,
                        "node_improvement": 91.4379249559305,
                        "length_improvement": 15.277453078640955,
                        "smoothness_improvement": 519.6625418241595,
                        "objective_score": 29.41383827034103
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.049208974838256835,
                        "num_nodes_avg": 116.0,
                        "path_length_avg": 236.11546529476226,
                        "smoothness_avg": 0.06943512420354042,
                        "success_improvement": 0.0,
                        "time_improvement": 69.28227518814471,
                        "node_improvement": 92.20587247194786,
                        "length_improvement": 21.177861477765767,
                        "smoothness_improvement": 1686.6157578555544,
                        "objective_score": 41.92447823238064
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.026494455337524415,
                        "num_nodes_avg": 117.0,
                        "path_length_avg": 122.03531483713664,
                        "smoothness_avg": 0.08227711903121854,
                        "success_improvement": 0.0,
                        "time_improvement": 45.98660915000911,
                        "node_improvement": 85.12396694214877,
                        "length_improvement": 18.94995458240024,
                        "smoothness_improvement": 946.5588810119002,
                        "objective_score": 29.898749899502377
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "cross_over",
                "algorithm_description": "BCI-BiRRT: Beam-Compressed Informed BiRRT \u2014 a bidirectional planner that uses small-beam guided sampling, per-cell duplicate suppression, line-of-sight ancestor compression, grid-accelerated nearest/near queries, and k-near minimal-cost bridging with post-connection informed shortcuts to deliver fast, short, and smooth paths.",
                "planning_mechanism": "Mechanism: adaptively choose a tree to expand; sample a small beam (goal/line/informed-biased), steer and validate candidates, select the one that most reduces distance to the opposite tree, compress the parent via line-of-sight to an ancestor, commit the node (after node+edge checks and duplicate pruning), then attempt a k-near bridge to the opposite tree minimizing total start-to-goal cost; upon success, extract [start\u2192\u2026\u2192meetA, meetB\u2192\u2026\u2192goal], compress and shortcut, and return.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=6.0,\n                 beam_k=3,\n                 goal_bias=0.18,\n                 line_bias=0.35,\n                 connect_radius_factor=3.0,\n                 k_bridge=6,\n                 occ_gain_ratio=0.99,\n                 compress_depth=3,\n                 smoothing_iters=100,\n                 ellipse_tries=90,\n                 switch_fail_thresh=6,\n                 grid_cell=None):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_radius_factor = connect_radius_factor\n        self.k_bridge = k_bridge\n        self.occ_gain_ratio = occ_gain_ratio\n        self.compress_depth = compress_depth\n        self.smoothing_iters = smoothing_iters\n        self.ellipse_tries = ellipse_tries\n        self.switch_fail_thresh = switch_fail_thresh\n        self.grid_cell = grid_cell\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Basic parameters\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.edge_res = max(0.5, min(1.0, 0.5 * self.step_size))\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line check\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # Initialize trees (start-rooted, goal-rooted)\n        s_root = Node(start, None, 0.0)\n        g_root = Node(goal, None, 0.0)\n        start_tree = [s_root]\n        goal_tree = [g_root]\n        edges = []\n\n        grid_s = {}\n        grid_g = {}\n        self._grid_add(grid_s, s_root, self.grid_cell)\n        self._grid_add(grid_g, g_root, self.grid_cell)\n\n        # Per-cell best cost to suppress near-duplicates\n        occ_cell = max(0.5, 0.7 * self.step_size)\n        occ_s = {self._occ_key(start, occ_cell): 0.0}\n        occ_g = {self._occ_key(goal, occ_cell): 0.0}\n\n        # Bookkeeping\n        failed_s = 0\n        failed_g = 0\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            # Choose which tree to grow (adaptive alternation)\n            active_start = (it % 2 == 0)\n            if (active_start and failed_s >= self.switch_fail_thresh) or ((not active_start) and failed_g >= self.switch_fail_thresh):\n                active_start = not active_start\n\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_s if active_start else grid_g\n            grid_b = grid_g if active_start else grid_s\n            occ_a = occ_s if active_start else occ_g\n            root_other = goal if active_start else start\n            root_self = start if active_start else goal\n\n            # Beam sampling\n            candidates = []\n            for _ in range(self.beam_k):\n                x_rand = None\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                else:\n                    # informed ellipsoid after first solution\n                    if best_len < float('inf'):\n                        got = False\n                        for _t in range(self.ellipse_tries):\n                            p = self._uniform_point()\n                            if self._in_bounds(p):\n                                if self._dist(p, start) + self._dist(p, goal) <= best_len:\n                                    x_rand = p\n                                    got = True\n                                    break\n                        if not got:\n                            x_rand = self._uniform_point()\n                    else:\n                        if self._rand() < self.line_bias:\n                            # line-biased with jitter\n                            t = self._uniform(0.0, 1.0)\n                            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n                            jit = 0.5 * self.step_size\n                            x_rand = tuple(self._clip(base[i] + self._uniform(-jit, jit), 0.0, self.bounds[i]) for i in range(self.dim))\n                        else:\n                            x_rand = self._uniform_point()\n\n                # Nearest and steer\n                n_near = self._nearest(grid_a, tree_a, x_rand, self.grid_cell)\n                x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n                if not self._in_bounds(x_new_pos):\n                    continue\n                if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(n_near.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                    continue\n\n                # Line-of-sight ancestor compression (limited depth)\n                best_parent = n_near\n                best_cost = n_near.cost + self._dist(n_near.position, x_new_pos)\n                anc = n_near.parent\n                depth = 0\n                while anc is not None and depth < self.compress_depth:\n                    if not self._is_edge_in_obstacle(anc.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                        alt = anc.cost + self._dist(anc.position, x_new_pos)\n                        if alt + 1e-12 < best_cost:\n                            best_cost = alt\n                            best_parent = anc\n                    anc = anc.parent\n                    depth += 1\n\n                # Duplicate suppression in occupancy grid\n                k_occ = self._occ_key(x_new_pos, occ_cell)\n                prev_best = occ_a.get(k_occ, float('inf'))\n                if best_cost >= prev_best * self.occ_gain_ratio:\n                    continue\n\n                # Progress score: distance to other tree after extension\n                other_near = self._nearest(grid_b, tree_b, x_new_pos, self.grid_cell)\n                score = self._dist(x_new_pos, other_near.position) if other_near is not None else self._dist(x_new_pos, root_other)\n                candidates.append((score, x_new_pos, best_parent, best_cost))\n\n            if not candidates:\n                if active_start:\n                    failed_s += 1\n                else:\n                    failed_g += 1\n                continue\n\n            # Commit the best candidate\n            candidates.sort(key=lambda t: t[0])\n            _, new_pos, parent, new_cost = candidates[0]\n\n            new_node = Node(new_pos, None, new_cost)\n            new_node.attach(parent)\n            tree_a.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid_a, new_node, self.grid_cell)\n            k_occ_new = self._occ_key(new_pos, occ_cell)\n            if new_cost < occ_a.get(k_occ_new, float('inf')):\n                occ_a[k_occ_new] = new_cost\n\n            if active_start:\n                failed_s = 0\n            else:\n                failed_g = 0\n\n            # Attempt k-near best-cost bridge to the other tree\n            r_conn = max(self.connect_radius_factor * self.step_size, self.step_size)\n            near_b = self._near(grid_b, new_pos, r_conn, self.grid_cell)\n            if not near_b:\n                nn_b = self._nearest(grid_b, tree_b, new_pos, self.grid_cell)\n                if nn_b is not None:\n                    near_b = [nn_b]\n\n            # Select up to k closest in Euclidean distance to new_pos\n            if len(near_b) > self.k_bridge:\n                # partial selection\n                dist_idx = [(self._dist(n.position, new_pos), i) for i, n in enumerate(near_b)]\n                dist_idx.sort(key=lambda t: t[0])\n                near_b = [near_b[i] for (_, i) in dist_idx[:self.k_bridge]]\n\n            best_bridge = None\n            best_total = best_len\n            for nb in near_b:\n                if not self._is_edge_in_obstacle(new_pos, nb.position, obstacles, is_3d, self.edge_res):\n                    total = new_node.cost + self._dist(new_pos, nb.position) + nb.cost\n                    if total + 1e-12 < best_total:\n                        best_total = total\n                        best_bridge = nb\n\n            if best_bridge is not None:\n                # Extract path\n                if active_start:\n                    meet_a = new_node\n                    meet_b = best_bridge\n                else:\n                    meet_a = best_bridge\n                    meet_b = new_node\n\n                path = self._extract_path(meet_a, meet_b)\n                path = self._compress(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n                plen = self._path_length(path)\n                if plen < best_len:\n                    best_len = plen\n                    best_path = path\n                return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        # If loop ends without connection\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _uniform_point(self):\n        if self.dim == 3:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]),\n                    self._uniform(0.0, self.bounds[2]))\n        else:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]))\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return tuple(self._clip(to_pos[i], 0.0, self.bounds[i]) for i in range(self.dim))\n        r = step / d\n        return tuple(self._clip(from_pos[i] + (to_pos[i] - from_pos[i]) * r, 0.0, self.bounds[i]) for i in range(self.dim))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Spatial hash ----------\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        # Expand radius until found, then fallback to scan\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        limit = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > limit:\n                limit = self.bounds[i]\n        limit = limit * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # Fallback\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        r2 = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    # ---------- Path utilities ----------\n    def _path_to_root(self, node):\n        seq = []\n        cur = node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _extract_path(self, meet_a, meet_b):\n        # meet_a is in start-tree side, meet_b is in goal-tree side\n        path_a = self._path_to_root(meet_a)\n        # ascend from meet_b to goal root\n        tail = []\n        cur = meet_b\n        while cur is not None:\n            tail.append(cur.position)\n            cur = cur.parent\n        # path: start ... meet_a, then straight to meet_b (implied), then ... goal\n        return path_a + tail\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.edge_res):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
                "objective": -4.32865,
                "time_improvement": -45.0,
                "length_improvement": 16.0,
                "smoothness_improvement": 1649.0,
                "node_improvement": 81.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.05528700351715088,
                        "num_nodes_avg": 52.7,
                        "path_length_avg": 159.23267345792033,
                        "smoothness_avg": 0.04720018064341601,
                        "success_improvement": 0.0,
                        "time_improvement": -116.82202007111755,
                        "node_improvement": 86.72878368169226,
                        "length_improvement": 12.722048474535743,
                        "smoothness_improvement": 638.7853239022464,
                        "objective_score": -24.219450317102588
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.128195858001709,
                        "num_nodes_avg": 251.0,
                        "path_length_avg": 244.97426414775782,
                        "smoothness_avg": 0.11245472368962676,
                        "success_improvement": 0.0,
                        "time_improvement": 19.976282760218798,
                        "node_improvement": 83.13512060740442,
                        "length_improvement": 18.22053943424897,
                        "smoothness_improvement": 2793.541038397612,
                        "objective_score": 30.89291368060308
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.06766645908355713,
                        "num_nodes_avg": 219.1,
                        "path_length_avg": 125.15812725071248,
                        "smoothness_avg": 0.12691495233302894,
                        "success_improvement": 0.0,
                        "time_improvement": -37.949425846041684,
                        "node_improvement": 72.14240305149396,
                        "length_improvement": 16.875931269650575,
                        "smoothness_improvement": 1514.3488257888052,
                        "objective_score": 6.312475136921865
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "cross_over",
            "algorithm_description": "FIBER-Connect*: Fast Informed Bidirectional RRT*-Connect with Cached Collisions and Local Rewiring \u2014 a bidirectional planner that blends informed sampling, grid-accelerated near/nearest, per-cell cost gating, limited RRT* rewiring, and multi-step connect-extend bridging; it maintains an edge-collision cache and applies visibility pruning plus shortcuts for short, smooth paths with low planning time.",
            "planning_mechanism": "Alternate expanding the two trees; sample with goal/line bias and informed-ellipsoid once a path exists; find nearest via grid rings, steer, and validate; select the lowest-cost parent among radius neighbors (LOS) and insert under per-cell cost gates; locally rewire a few neighbors to reduce path cost; then attempt multi-step connect from the opposite tree toward the new node and bridge on first free LOS; upon success, extract start\u2192meetA + meetB\u2192goal, visibility-prune and shortcut, and return.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.22,\n                 line_bias=0.30,\n                 informed_tries=80,\n                 grid_cell_factor=1.5,\n                 max_per_cell=6,\n                 duplicate_radius_factor=0.5,\n                 rewire_k=10,\n                 rewire_depth=5,\n                 neighbor_radius_factor=3.0,\n                 connect_steps=6,\n                 smoothing_iters=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.informed_tries = informed_tries\n        self.grid_cell_factor = grid_cell_factor\n        self.max_per_cell = max_per_cell\n        self.duplicate_radius_factor = duplicate_radius_factor\n        self.rewire_k = rewire_k\n        self.rewire_depth = rewire_depth\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        self.edge_res = max(0.5, min(1.0, 0.5 * self.step_size))\n        self.cell_size = max(1.0, self.grid_cell_factor * self.step_size)\n        self.min_sep = max(0.3, self.duplicate_radius_factor * self.step_size)\n\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            return PlannerResult(True, [start, goal], [s, g], [(s, g)])\n\n        s_root = Node(start, None, 0.0)\n        g_root = Node(goal, None, 0.0)\n\n        start_tree = [s_root]\n        goal_tree = [g_root]\n        nodes = [s_root, g_root]\n        edges = []\n\n        grid_s = {}\n        grid_g = {}\n        counts_s = {}\n        counts_g = {}\n        bestcost_s = {}\n        bestcost_g = {}\n\n        self._grid_add(grid_s, counts_s, bestcost_s, s_root)\n        self._grid_add(grid_g, counts_g, bestcost_g, g_root)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_s if active_start else grid_g\n            grid_b = grid_g if active_start else grid_s\n            counts_a = counts_s if active_start else counts_g\n            counts_b = counts_g if active_start else counts_s\n            bestcost_a = bestcost_s if active_start else bestcost_g\n            bestcost_b = bestcost_g if active_start else bestcost_s\n            root_other = goal if active_start else start\n\n            x_rand = self._sample(obstacles, is_3d, start, goal, best_len, root_other)\n\n            n_near = self._nearest(grid_a, tree_a, x_rand)\n            x_new = self._steer(n_near.position, x_rand)\n            if not self._in_bounds(x_new):\n                continue\n            if self._is_in_obstacle(x_new, obstacles, is_3d):\n                continue\n            if self._edge_blocked(n_near.position, x_new, obstacles, is_3d):\n                continue\n            if self._near_duplicate(grid_a, x_new, self.min_sep):\n                continue\n\n            r_near = max(self.neighbor_radius_factor * self.step_size, self.step_size)\n            neigh = self._near(grid_a, x_new, r_near)\n            parent, new_cost = self._choose_parent(neigh, n_near, x_new, obstacles, is_3d)\n\n            key_new = self._grid_key(x_new)\n            ccount = counts_a.get(key_new, 0)\n            bestc = bestcost_a.get(key_new, float('inf'))\n            if ccount >= self.max_per_cell and not (new_cost + 1e-12 < bestc):\n                continue\n\n            new_node = Node(x_new, None, new_cost)\n            new_node.attach(parent)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid_a, counts_a, bestcost_a, new_node)\n\n            if neigh:\n                self._rewire(new_node, neigh, obstacles, is_3d, edges)\n\n            meet_b, bridged = self._connect_toward(tree_b, grid_b, counts_b, bestcost_b, new_node.position, obstacles, is_3d)\n            if meet_b is None:\n                meet_candidate = self._nearest(grid_b, tree_b, new_node.position)\n                if meet_candidate is not None and not self._edge_blocked(new_node.position, meet_candidate.position, obstacles, is_3d):\n                    meet_b = meet_candidate\n                    bridged = True\n\n            if bridged and meet_b is not None:\n                if active_start:\n                    a = new_node\n                    b = meet_b\n                else:\n                    a = meet_b\n                    b = new_node\n                if not self._edge_blocked(a.position, b.position, obstacles, is_3d):\n                    edges.append((a, b))\n                    path = self._extract_path(a, b)\n                    path = self._visibility_prune(path, obstacles, is_3d)\n                    path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _uniform_point(self):\n        if self.dim == 3:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]),\n                    self._uniform(0.0, self.bounds[2]))\n        else:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]))\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-12:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        if k in self._edge_cache:\n            return self._edge_cache[k]\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._grid_key(node.position)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n        counts[k] = counts.get(k, 0) + 1\n        prev = bestcost.get(k, None)\n        if prev is None or node.cost < prev:\n            bestcost[k] = node.cost\n\n    def _grid_collect_ring(self, grid, key, r):\n        cand = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        return cand\n\n    def _nearest(self, grid, nodes, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        cand_total = []\n        r = 0\n        max_r = 4\n        while r <= max_r and len(cand_total) < 12:\n            cand_total.extend(self._grid_collect_ring(grid, key, r))\n            r += 1\n        if cand_total:\n            for n in cand_total:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            return best\n        if nodes:\n            trials = min(64, len(nodes))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(nodes)))\n                n = nodes[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _near(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        rng = int(max(1, radius // self.cell_size)) + 1\n        cand = []\n        if self.dim == 3:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        cand = self._grid_collect_ring(grid, key, 1)\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                return True\n        return False\n\n    def _choose_parent(self, neighbors, fallback_near, new_pos, obstacles, is_3d):\n        best_parent = fallback_near\n        best_cost = fallback_near.cost + self._dist(fallback_near.position, new_pos)\n        for n in neighbors:\n            if n is fallback_near:\n                continue\n            if not self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                c = n.cost + self._dist(n.position, new_pos)\n                if c + 1e-12 < best_cost:\n                    best_cost = c\n                    best_parent = n\n        return best_parent, best_cost\n\n    def _can_rewire(self, node, new_parent):\n        cur = new_parent\n        while cur is not None:\n            if cur is node:\n                return False\n            cur = cur.parent\n        return True\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                edges.pop(i)\n                break\n\n    def _propagate_cost(self, node, edges, depth):\n        if depth <= 0:\n            return\n        for ch in node.children:\n            old = ch.cost\n            ch.cost = node.cost + self._dist(node.position, ch.position)\n            if abs(ch.cost - old) > 1e-12:\n                self._propagate_cost(ch, edges, depth - 1)\n\n    def _rewire(self, new_node, neighbors, obstacles, is_3d, edges):\n        if not neighbors:\n            return\n        cand = []\n        for n in neighbors:\n            if n is new_node or n is new_node.parent:\n                continue\n            cand.append((self._dist(n.position, new_node.position), n))\n        cand.sort(key=lambda t: t[0])\n        limit = min(self.rewire_k, len(cand))\n        for i in range(limit):\n            n = cand[i][1]\n            if not self._can_rewire(n, new_node):\n                continue\n            if self._edge_blocked(new_node.position, n.position, obstacles, is_3d):\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, n.position)\n            if new_cost + 1e-12 < n.cost:\n                old_parent = n.parent\n                n.attach(new_node)\n                n.cost = new_cost\n                if old_parent is not None:\n                    self._remove_edge(edges, old_parent, n)\n                edges.append((new_node, n))\n                self._propagate_cost(n, edges, self.rewire_depth)\n\n    def _extend_toward(self, tree, grid, counts, bestcost, target_pos, obstacles, is_3d):\n        current = self._nearest(grid, tree, target_pos)\n        last = current\n        for _ in range(self.connect_steps):\n            nxt = self._steer(current.position, target_pos)\n            if not self._in_bounds(nxt):\n                break\n            if self._is_in_obstacle(nxt, obstacles, is_3d):\n                break\n            if self._edge_blocked(current.position, nxt, obstacles, is_3d):\n                break\n            if self._near_duplicate(grid, nxt, self.min_sep):\n                break\n            r_near = max(self.neighbor_radius_factor * self.step_size, self.step_size)\n            neigh = self._near(grid, nxt, r_near)\n            parent, new_cost = self._choose_parent(neigh, current, nxt, obstacles, is_3d)\n            key_new = self._grid_key(nxt)\n            ccount = counts.get(key_new, 0)\n            bestc = bestcost.get(key_new, float('inf'))\n            if ccount >= self.max_per_cell and not (new_cost + 1e-12 < bestc):\n                break\n            newn = Node(nxt, None, new_cost)\n            newn.attach(parent)\n            tree.append(newn)\n            self._grid_add(grid, counts, bestcost, newn)\n            last = newn\n            current = newn\n            if self._dist(nxt, target_pos) <= self.step_size:\n                break\n        return last\n\n    def _connect_toward(self, tree_b, grid_b, counts_b, bestcost_b, a_pos, obstacles, is_3d):\n        last = self._extend_toward(tree_b, grid_b, counts_b, bestcost_b, a_pos, obstacles, is_3d)\n        if last is None:\n            return None, False\n        if not self._edge_blocked(last.position, a_pos, obstacles, is_3d):\n            return last, True\n        return last, False\n\n    def _path_to_root(self, node):\n        seq = []\n        cur = node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _extract_path(self, meet_a, meet_b):\n        pa = self._path_to_root(meet_a)\n        pb = []\n        cur = meet_b\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        return pa + pb\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        n = len(path)\n        i = 0\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts\n\n    def _sample(self, obstacles, is_3d, start, goal, best_len, attractor):\n        r = self._rand()\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        if best_len < float('inf'):\n            for _ in range(self.informed_tries):\n                p = self._uniform_point()\n                if self._dist(p, start) + self._dist(p, goal) <= best_len and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jit = 0.5 * self.step_size\n            if self.dim == 3:\n                p = (self._clamp((base[0] + self._uniform(-jit, jit), base[1] + self._uniform(-jit, jit), base[2] + self._uniform(-jit, jit))))\n            else:\n                p = (min(max(base[0] + self._uniform(-jit, jit), 0.0), self.bounds[0]),\n                     min(max(base[1] + self._uniform(-jit, jit), 0.0), self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        while True:\n            p = self._uniform_point()\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p",
            "objective": -35.01262,
            "time_improvement": 55.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1329.0,
            "node_improvement": 90.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016425013542175293,
                    "num_nodes_avg": 47.0,
                    "path_length_avg": 154.62508050902176,
                    "smoothness_avg": 0.04071980109549708,
                    "success_improvement": 0.0,
                    "time_improvement": 33.4245918733191,
                    "node_improvement": 88.16419038025687,
                    "length_improvement": 15.247543181809576,
                    "smoothness_improvement": 537.3533116078908,
                    "objective_score": 21.86267002912093
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04094517230987549,
                    "num_nodes_avg": 124.0,
                    "path_length_avg": 229.46535757937585,
                    "smoothness_avg": 0.08684323820145955,
                    "success_improvement": 0.0,
                    "time_improvement": 75.51881386278623,
                    "node_improvement": 91.66834643553047,
                    "length_improvement": 23.397858845899172,
                    "smoothness_improvement": 2134.539069579714,
                    "objective_score": 47.36705481427394
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.022255563735961915,
                    "num_nodes_avg": 88.0,
                    "path_length_avg": 119.3089523489693,
                    "smoothness_avg": 0.11130492356865981,
                    "success_improvement": 0.0,
                    "time_improvement": 55.909249570294364,
                    "node_improvement": 88.81118881118881,
                    "length_improvement": 20.760674731610354,
                    "smoothness_improvement": 1315.790412118499,
                    "objective_score": 35.80813177064702
                }
            ],
            "success_rate": 1.0
        },
        "objective": 11.2,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Limited or absent rewiring, preventing post-insertion cost improvement along existing branches.\n   - Constrained parent selection (small or ring-limited neighborhoods) that misses lower-cost parents just outside the queried cells.\n   - Biased nearest-neighbor retrieval that often returns non-nearest vertices, yielding suboptimal extensions and longer paths.\n   - Early stop at the first feasible bridge and single-shot joins that introduce kinks and longer connections.\n   - Coarse waypoint growth and weak duplicate control that create zig-zag structures and detours before smoothing."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Cost-aware parent selection over a broader, radius-based neighbor set with line-of-sight checks.\n   - Local rewiring of nearby vertices to adopt lower-cost parents and propagate reduced costs.\n   - Multi-step connect/extend bridging toward the opposite tree, producing shorter, better-aligned joins.\n   - Informed and line-biased sampling toward the start\u2013goal corridor once a bound exists.\n   - Per-cell cost gating and duplicate suppression that favor lower-cost insertions and reduce meandering.\n   - Post-connection visibility pruning and shortcutting with sufficient iterations.\n2. Expected mechanism of impact:\n   - Lower initial edge costs and subsequent rewiring reduce cumulative path cost from start to goal.\n   - Better join geometry and progressive connection avoid kinked, lengthy bridges and shorten the meeting segment.\n   - Focused sampling in the informed region and along the start\u2013goal line reduces detours and creates straighter trees.\n   - Enforcing best-cost representatives per region limits redundant, higher-cost vertices, preserving direct routes.\n   - Aggressive pruning and shortcuts remove unnecessary turns and intermediate waypoints, contracting the final path length."
        }
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "HB-EdgeSieve BiRRT (HB-ESBiRRT): A heuristic-biased, bidirectional RRT that uses an obstacle grid with slab-based segment checks, quantized edge-collision caching, and cost-gated sparse hashing to minimize planning time while preserving robustness and path quality. It grows two trees toward each other with a single, high-yield sample per side, selects a cheap line-of-sight ancestor over a short lookback, and attempts direct bridging to the other tree. After the first solution, informed ellipse sampling narrows exploration and a cache-reusing greedy shortcutting finalizes the path.",
                "planning_mechanism": "Mechanism: Each iteration alternates trees. A guided sample (goal-biased or ellipse-informed) is steered from the nearest grid-bucket node. Before inserting, both node and edge are collision-checked. Edge checks use a memoized cache and fast slab intersections against only nearby obstacles fetched from an obstacle spatial grid. Parent compression considers a few visible ancestors to cut depth and cost. On each insertion, the planner tries a zero-step line-of-sight connect to the other tree's nearest node. A per-cell cap with cost admission curbs local redundancy. If a path appears, shortcutting reuses the same cached edge tests to converge quickly.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        goal_bias=0.35,\n        beam_width=1,\n        lookback_depth=4,\n        grid_cell_factor=1.5,\n        per_cell_cap=10,\n        min_separation_factor=0.6,\n        edge_cache_capacity=30000,\n        edge_cache_quant_factor=0.6,\n        shortcut_attempts=60,\n        no_improve_stop=10\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.beam_width = beam_width\n        self.lookback_depth = lookback_depth\n        self.grid_cell_factor = grid_cell_factor\n        self.per_cell_cap = per_cell_cap\n        self.min_separation_factor = min_separation_factor\n        self.edge_cache_capacity = edge_cache_capacity\n        self.edge_cache_quant_factor = edge_cache_quant_factor\n        self.shortcut_attempts = shortcut_attempts\n        self.no_improve_stop = no_improve_stop\n\n        # PRNG state\n        self._rnd_state = 1234567\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # Early exit if trivial\n        if self._dist(self.start, self.goal) <= 1e-9:\n            path = [self.start, self.goal]\n            return PlannerResult(True, path, [], [])\n\n        # Initialize parameters\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n\n        # Initialize PRNG with scene-dependent seed\n        self._seed_from_scene()\n\n        # Edge collision cache (LRU-ish via ticks)\n        self._tick = 0\n        self._last_prune_size = 0\n        self.ecache = {}\n        self.ecache_quant = max(0.25, self.step_size * self.edge_cache_quant_factor)\n\n        # Build obstacle spatial grid for fast queries\n        self._build_obstacle_grid()\n\n        nodes = []\n        edges = []\n\n        # Validate start/goal points\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        start_root = Node(self.start, parent=None, cost=0.0)\n        goal_root = Node(self.goal, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_path = None\n        incumbent_len = None\n\n        for _ in range(self.max_iter):\n            # Alternate growth between the two trees\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, self.goal),\n                (tree_b, grid_b, tree_a, grid_a, self.start)\n            ]:\n                progressed = False\n                for _b in range(self.beam_width):\n                    sample = self._sample(attractor, incumbent_len)\n                    if sample is None:\n                        continue\n\n                    nearest = self._nearest_in_grid(active_grid, sample)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos):\n                        continue\n                    # Node collision check\n                    if self._point_in_obstacles(new_pos):\n                        continue\n                    # Edge collision check to nearest\n                    if not self._edge_free(nearest.position, new_pos):\n                        continue\n                    # Suppress near-duplicates\n                    if self._has_nearby(active_grid, new_pos, self.min_separation):\n                        continue\n\n                    # Limited lookback LOS parent selection\n                    parent = self._best_parent_los(nearest, new_pos)\n                    new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n                    # Per-cell cap with cost admission\n                    cell_key = self._cell_of(new_pos)\n                    bucket = active_grid.get(cell_key)\n                    if bucket and len(bucket) >= self.per_cell_cap:\n                        best_bucket_cost = min(n.cost for n in bucket)\n                        if new_cost >= best_bucket_cost - 1e-9:\n                            continue\n\n                    # Insert node\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node)\n                    progressed = True\n\n                    # Try direct bridge to the other tree\n                    other_near = self._nearest_in_grid(other_grid, new_node.position)\n                    if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                        # Build raw path\n                        path_a = self._path_to_root(new_node)\n                        path_b = self._path_to_root(other_near)\n                        raw_path = path_a + path_b[::-1]\n                        # Deduplicate meeting point if coincident\n                        if len(raw_path) >= 2 and self._dist(raw_path[-1], raw_path[-2]) <= 1e-12:\n                            raw_path.pop()\n                        # Shortcut with cached collision checks\n                        final_path = self._shortcut(raw_path)\n                        best_path = final_path\n                        incumbent_len = self._path_len(final_path)\n                        return PlannerResult(True, final_path, nodes, edges)\n\n                if not progressed:\n                    continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # ---------- PRNG ----------\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 1000 + 0.5)) & 0x7fffffff\n        s ^= len(self.obstacles) * 2654435761\n        self._rnd_state = (s ^ 0xA5A5A5) & 0x7fffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 1234567\n\n    def _rand(self):\n        # LCG: x_{n+1} = (a x_n + c) mod m\n        self._rnd_state = (1103515245 * self._rnd_state + 12345) & 0x7fffffff\n        return (self._rnd_state / 2147483647.0)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return a\n        if d <= self.step_size:\n            return b\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # ---------- Sampling ----------\n    def _sample(self, attractor, incumbent_len):\n        # Guided: ellipse if incumbent known, else uniform with goal bias\n        for _ in range(20):\n            if incumbent_len is not None and self._dist(self.start, self.goal) > 1e-9:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.03)\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if p is None:\n                continue\n            if self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        # Fallback\n        return attractor if self._within_bounds(attractor) and not self._point_in_obstacles(attractor) else None\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        # Rejection sample around the segment f1-f2\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        ext = [half] * self.dims\n        for _ in range(16):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum_dist and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # ---------- Grid spatial hash for nodes ----------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_in_grid(self, grid, pos, max_ring=5):\n        cell = self._cell_of(pos)\n        best = None\n        best_d = 1e100\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if not bucket:\n                                continue\n                            for n in bucket:\n                                d = self._dist(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                                    found = True\n                if found:\n                    return best\n        else:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            d = self._dist(n.position, pos)\n                            if d < best_d:\n                                best_d = d\n                                best = n\n                                found = True\n                if found:\n                    return best\n        # Fallback: scan all\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < best_d:\n                    best_d = d\n                    best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if not bucket:\n                        continue\n                    for n in bucket:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # ---------- Obstacle spatial grid ----------\n    def _build_obstacle_grid(self):\n        # Choose obstacle cell size proportional to step for balanced performance\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}  # cell -> list of obstacle indices\n        self._obs_is_3d = self.is_3d\n        for idx, obs in enumerate(self.obstacles):\n            if self._obs_is_3d:\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            key = (cx, cy, cz)\n                            bucket = self.obs_grid.get(key)\n                            if bucket is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                bucket.append(idx)\n            else:\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        key = (cx, cy)\n                        bucket = self.obs_grid.get(key)\n                        if bucket is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self._obs_is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    # ---------- Edge checks with cache ----------\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.ecache_quant) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.ecache_quant) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        if len(self.ecache) - self._last_prune_size > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self.ecache:\n            return\n        # Drop the oldest ~40%\n        cutoff = self._tick - 2000\n        to_del = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            # Fallback: remove every 3rd entry to bound size\n            i = 0\n            for k in list(self.ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune_size = len(self.ecache)\n\n    # ---------- Segment vs obstacle (slab) accelerated by obstacle grid ----------\n    def _segment_hits_obstacle(self, a, b):\n        # Gather obstacles intersecting the bounding box of segment\n        if self._obs_is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bucket = self.obs_grid.get((cx, cy, cz))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bucket = self.obs_grid.get((cx, cy))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # ---------- Parent selection (short LOS lookback) ----------\n    def _best_parent_los(self, nearest, new_pos):\n        best = nearest\n        best_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        cur = nearest\n        depth = 0\n        while cur is not None and depth < self.lookback_depth:\n            if self._edge_free(cur.position, new_pos):\n                c = cur.cost + self._dist(cur.position, new_pos)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best = cur\n            cur = cur.parent\n            depth += 1\n        return best\n\n    # ---------- Shortcut smoothing ----------\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_improve = 0\n        i = 0\n        while attempts < self.shortcut_attempts and i < len(pts) - 2:\n            improved = False\n            j = len(pts) - 1\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    improved = True\n                    no_improve = 0\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n                no_improve += 1\n            attempts += 1\n            if no_improve >= self.no_improve_stop:\n                break\n        return pts",
                "objective": -26.29094,
                "time_improvement": 61.0,
                "length_improvement": -0.0,
                "smoothness_improvement": 1630.0,
                "node_improvement": 90.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.024515295028686525,
                        "num_nodes_avg": 73.0,
                        "path_length_avg": 235.8280485058371,
                        "smoothness_avg": 0.03800756828685148,
                        "success_improvement": 0.0,
                        "time_improvement": 3.857046817335618,
                        "node_improvement": 81.6167212289096,
                        "length_improvement": -29.261090320615313,
                        "smoothness_improvement": 494.90097844477503,
                        "objective_score": -13.925035254944627
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.023125672340393068,
                        "num_nodes_avg": 110.0,
                        "path_length_avg": 245.0393031205978,
                        "smoothness_avg": 0.12370286737465501,
                        "success_improvement": 0.0,
                        "time_improvement": 85.56425852446206,
                        "node_improvement": 92.6090169992609,
                        "length_improvement": 18.19882755307195,
                        "smoothness_improvement": 3082.9638771238115,
                        "objective_score": 52.003393474800845
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.0030002355575561523,
                        "num_nodes_avg": 35.0,
                        "path_length_avg": 135.33178973135438,
                        "smoothness_avg": 0.1109750714335361,
                        "success_improvement": 0.0,
                        "time_improvement": 93.88351661704843,
                        "node_improvement": 95.54990464081374,
                        "length_improvement": 10.119069067755975,
                        "smoothness_improvement": 1311.5947173068773,
                        "objective_score": 40.7944700123025
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m3",
                "algorithm_description": "Algorithm description: SWIFT-BiRRT-LOS \u2014 Simple, Weighted-bias, Informed, Fast Triaged Bi-directional RRT with hashed-near lookup, near-duplicate suppression, on-the-fly line-of-sight grandparent compression, light bounded connect-extend, and capped shortcut smoothing for faster, shorter, and smoother paths.",
                "planning_mechanism": "Planning mechanism: Alternate growing two trees with balanced goal/corridor/informed-biased samples. For each sample, find a hashed-nearest node, steer once, check node and edge collisions, insert if not near-duplicate and the cell is not saturated, then immediately try LOS compression to the grandparent to shorten chains. Attempt to connect to the opposite tree using a costless direct check first, then a few bounded, collision-checked extend steps. On success, merge trees and return a visibility-pruned, lightly-shortcutted path; otherwise stop on budget or stall.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=10.0,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 rings_near=2,\n                 goal_bias=0.2,\n                 corridor_bias=0.4,\n                 informed_bias=0.5,\n                 dupe_radius_ratio=0.6,\n                 cell_cap=10,\n                 connect_radius_factor=4.0,\n                 connect_steps=3,\n                 smoothing_attempts=24,\n                 stall_limit=700,\n                 edge_cache_limit=30000):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.collision_step = float(collision_step)\n        self.grid_cell = grid_cell\n        self.rings_near = int(max(1, rings_near))\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.cell_cap = int(max(2, cell_cap))\n        self.connect_radius_factor = float(max(1.0, connect_radius_factor))\n        self.connect_steps = int(max(0, connect_steps))\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self.stall_limit = int(max(100, stall_limit))\n        self.edge_cache_limit = int(max(2000, edge_cache_limit))\n\n        self.bounds = None\n        self.dim = 2\n        self.start = None\n        self.goal = None\n        self.edge_cache = None\n        self.edge_stamp = 0\n        self.edge_res = 1.0\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.8 * self.step_size)\n        self.edge_res = max(0.5, min(self.collision_step, 0.5 * self.step_size))\n\n        self.edge_cache = {}\n        self.edge_stamp = 0\n\n        # Early direct connection\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            edges = [(n0, n1)]\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], edges)\n\n        # Initialize trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n\n        dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n        dsg = self._dist(self.start, self.goal)\n        corridor_base = max(self.step_size, 0.2 * dsg)\n\n        best_path = None\n        best_len = float('inf')\n        last_improve = 0\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            other_root = self.goal if active_start else self.start\n\n            # Sampling strategy\n            if best_path is not None and self._rand() < self.informed_bias:\n                x_rand = self._sample_informed(best_len, obstacles, is_3d)\n            else:\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = other_root\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = max(self.step_size, corridor_base + (0.1 * (best_len - dsg) if best_path is not None else 0.0))\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            nearest = self._nearest(grid1, tree1, x_rand)\n            if nearest is None:\n                continue\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._exists_close(grid1, new_pos, dupe_radius):\n                continue\n            if not self._cell_accept(grid1, new_pos):\n                continue\n            if self._edge_blocked_memo(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            self._grid_add(grid1, new_node)\n            edges.append((nearest, new_node))\n\n            # LOS grandparent compression\n            gp = nearest.parent\n            if gp is not None and not self._edge_blocked_memo(gp.position, new_pos, obstacles, is_3d):\n                # reparent new_node to grandparent\n                try:\n                    nearest.children.remove(new_node)\n                except:\n                    pass\n                self._remove_edge(edges, nearest, new_node)\n                gp.add_child(new_node)\n                new_node.cost = gp.cost + self._dist(gp.position, new_pos)\n                edges.append((gp, new_node))\n\n            # Try connect to opposite tree (direct first, then bounded extend)\n            qnear = self._nearest(grid2, tree2, new_node.position)\n            if qnear is not None and self._dist(qnear.position, new_node.position) <= connect_radius:\n                if not self._edge_blocked_memo(new_node.position, qnear.position, obstacles, is_3d):\n                    a_end = new_node\n                    b_end = qnear\n                else:\n                    a_end, b_end = self._bounded_connect_extend(new_node, tree2, grid2, dupe_radius, obstacles, is_3d, edges, nodes)\n                if a_end is not None and b_end is not None:\n                    path = self._merge_paths(a_end, b_end) if active_start else self._merge_paths(b_end, a_end)\n                    plen = self._path_length(path)\n                    if plen < best_len:\n                        best_path = path\n                        best_len = plen\n                        last_improve = it\n                    final = self._finalize_path(best_path, obstacles, is_3d)\n                    return PlannerResult(True, final, nodes, edges)\n\n            if best_path is not None and (it - last_improve) >= self.stall_limit:\n                final = self._finalize_path(best_path, obstacles, is_3d)\n                return PlannerResult(True, final, nodes, edges)\n\n        if best_path is not None:\n            final = self._finalize_path(best_path, obstacles, is_3d)\n            return PlannerResult(True, final, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG (deterministic)\n    def _rand(self):\n        if not hasattr(self, \"_rng\"):\n            self._rng = 987654321\n        self._rng = (1103515245 * self._rng + 12345) % (1 << 31)\n        return (self._rng & 0x7fffffff) / float(1 << 31)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp_tuple(b)\n        if d <= 1e-12:\n            return self._clamp_tuple(a)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_exact(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_exact(a, b)\n        st = self.edge_cache.get(key)\n        if st is not None:\n            return st[0] == 1\n        blocked = self._edge_blocked(a, b, obstacles, is_3d)\n        self.edge_stamp += 1\n        self.edge_cache[key] = (1 if blocked else 2, self.edge_stamp)\n        if len(self.edge_cache) > self.edge_cache_limit:\n            cutoff = self.edge_stamp - (self.edge_cache_limit // 2)\n            self.edge_cache = {k: v for k, v in self.edge_cache.items() if v[1] >= cutoff}\n        return blocked\n\n    # Spatial hashing\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.rings_near + 1):\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback random subset\n        if tree:\n            k = min(16, len(tree))\n            for _ in range(k):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx % len(tree)]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius // self.grid_cell) + 1\n        cand = self._ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    def _cell_accept(self, grid, pos):\n        key = self._grid_key(pos)\n        lst = grid.get(key)\n        if lst is None:\n            return True\n        return len(lst) < self.cell_cap\n\n    # Connect helpers\n    def _bounded_connect_extend(self, new_node, other_tree, other_grid, dupe_radius, obstacles, is_3d, edges, nodes):\n        q = self._nearest(other_grid, other_tree, new_node.position)\n        if q is None:\n            return (None, None)\n        cur = q\n        for _ in range(self.connect_steps):\n            nxt_pos = self._steer(cur.position, new_node.position, self.step_size)\n            if not self._in_bounds(nxt_pos):\n                break\n            if self._is_in_obstacle(nxt_pos, obstacles, is_3d):\n                break\n            if self._exists_close(other_grid, nxt_pos, dupe_radius):\n                break\n            if self._edge_blocked_memo(cur.position, nxt_pos, obstacles, is_3d):\n                break\n            nxt = Node(nxt_pos, cur, cur.cost + self._dist(cur.position, nxt_pos))\n            cur.add_child(nxt)\n            other_tree.append(nxt)\n            nodes.append(nxt)\n            self._grid_add(other_grid, nxt)\n            edges.append((cur, nxt))\n            # LOS compression toward grandparent\n            gp = cur.parent\n            if gp is not None and not self._edge_blocked_memo(gp.position, nxt_pos, obstacles, is_3d):\n                try:\n                    cur.children.remove(nxt)\n                except:\n                    pass\n                self._remove_edge(edges, cur, nxt)\n                gp.add_child(nxt)\n                nxt.cost = gp.cost + self._dist(gp.position, nxt_pos)\n                edges.append((gp, nxt))\n            cur = nxt\n            if not self._edge_blocked_memo(cur.position, new_node.position, obstacles, is_3d):\n                return (new_node, cur)\n        return (None, None)\n\n    # Path utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_paths(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        pb.reverse()\n        return pa + pb\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _remove_edge(self, edges, a, b):\n        for i in range(len(edges)):\n            if edges[i][0] is a and edges[i][1] is b:\n                edges.pop(i)\n                return\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked_memo(pruned[-1], path[j], obstacles, is_3d):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _smooth_path(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return list(path)\n        pts = list(path)\n        best_len = self._path_length(pts)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and n >= 3:\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked_memo(a, b, obstacles, is_3d):\n                new_pts = pts[:i + 1] + pts[j:]\n                new_len = self._path_length(new_pts)\n                if new_len + 1e-9 < best_len:\n                    pts = new_pts\n                    best_len = new_len\n                    n = len(pts)\n            tries += 1\n        return pts\n\n    def _finalize_path(self, path, obstacles, is_3d):\n        if not path:\n            return []\n        pruned = self._visibility_prune(path, obstacles, is_3d)\n        return self._smooth_path(pruned, obstacles, is_3d, self.smoothing_attempts)\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        for _ in range(64):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        if self.dim == 3:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5, self.bounds[2] * 0.5)\n        else:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5)\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        tries = 0\n        while tries < 24:\n            if self.dim == 3:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                else:\n                    tries += 1\n                    continue\n            else:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                else:\n                    tries += 1\n                    continue\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n            tries += 1\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        for _ in range(48):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if (self._dist(self.start, p) + self._dist(p, self.goal) <= best_len + 1e-9 and\n                not self._is_in_obstacle(p, obstacles, is_3d)):\n                return p\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)",
                "objective": -32.12619,
                "time_improvement": 59.0,
                "length_improvement": 9.0,
                "smoothness_improvement": 1812.0,
                "node_improvement": 91.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.01643836498260498,
                        "num_nodes_avg": 47.5,
                        "path_length_avg": 172.57597716951437,
                        "smoothness_avg": 0.055340882959087935,
                        "success_improvement": 0.0,
                        "time_improvement": 35.532778493067305,
                        "node_improvement": 88.03827751196172,
                        "length_improvement": 5.408372272033185,
                        "smoothness_improvement": 766.2049929605337,
                        "objective_score": 17.73588187594277
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.024622559547424316,
                        "num_nodes_avg": 81.2,
                        "path_length_avg": 250.16418359040821,
                        "smoothness_avg": 0.12448872572717391,
                        "success_improvement": 0.0,
                        "time_improvement": 84.62985642705796,
                        "node_improvement": 94.5441107303635,
                        "length_improvement": 16.487994940743906,
                        "smoothness_improvement": 3103.1845785650153,
                        "objective_score": 50.7976767853888
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.020916748046875,
                        "num_nodes_avg": 75.5,
                        "path_length_avg": 143.54340806097915,
                        "smoothness_avg": 0.13110948178151688,
                        "success_improvement": 0.0,
                        "time_improvement": 57.35770095388541,
                        "node_improvement": 90.40050858232676,
                        "length_improvement": 4.665303168464438,
                        "smoothness_improvement": 1567.7029307656137,
                        "objective_score": 27.845006841072355
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "XR-IBiRRT*: eXtended Rewiring Informed Bi-directional RRT with neighbor-based optimal parent selection, soft-cap hashed nearest, adaptive bounded-extend bridging, LRU-quantized edge cache, and post-solution informed refinement. It reduces time via obstacle-grid-accelerated slab checks and cache reuse, improves length via local RRT*-lite rewiring and LOS ancestor compression, and increases smoothness by visibility pruning and shortcutting while avoiding early return.",
            "planning_mechanism": "Mechanism: Alternate tree growth. For each informed/corridor/uniform sample, steer once, verify node and edge, then choose the cheapest collision-free parent among k-near grid neighbors plus a short ancestor lookback; insert and rewire cheaper neighbors. Immediately attempt to connect to the opposite tree by direct check or short bounded extensions. Maintain best path and continue a short informed phase for refinement. All node/edge insertions pass both point and segment collision checks using an obstacle spatial grid and LRU-quantized edge-cache. Final path is visibility-pruned and shortcut-smoothed.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=8.0,\n                 goal_bias=0.25,\n                 informed_bias=0.5,\n                 corridor_bias=0.35,\n                 lookback_depth=4,\n                 rewire_radius_factor=3.0,\n                 k_near_max=24,\n                 dupe_radius_factor=0.6,\n                 grid_cell_factor=1.4,\n                 bucket_soft_cap=10,\n                 connect_radius_factor=5.0,\n                 connect_trials=4,\n                 shortcut_attempts=80,\n                 stall_after=500,\n                 edge_cache_capacity=40000,\n                 edge_cache_quant=0.5):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.lookback_depth = int(max(0, lookback_depth))\n        self.rewire_radius_factor = float(max(1.0, rewire_radius_factor))\n        self.k_near_max = int(max(4, k_near_max))\n        self.dupe_radius_factor = float(max(0.1, dupe_radius_factor))\n        self.grid_cell_factor = float(max(0.5, grid_cell_factor))\n        self.bucket_soft_cap = int(max(2, bucket_soft_cap))\n        self.connect_radius_factor = float(max(1.0, connect_radius_factor))\n        self.connect_trials = int(max(0, connect_trials))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.stall_after = int(max(100, stall_after))\n        self.edge_cache_capacity = int(max(5000, edge_cache_capacity))\n        self.edge_cache_quant = float(max(0.1, edge_cache_quant))\n\n        self._rng = 1234567\n\n    # -------------------- Public API --------------------\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        # Build spatial acceleration\n        self._build_obstacle_grid()\n        # Early invalid\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n        # Trivial\n        if self._dist(self.start, self.goal) <= 1e-12:\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, 0.0)\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Parameters\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_factor)\n        self.connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n        self.rewire_radius = max(self.step_size, self.rewire_radius_factor * self.step_size)\n        self._seed_from_scene()\n\n        # Edge cache\n        self._tick = 0\n        self._last_prune_size = 0\n        self.ecache = {}\n        self.ecache_quant = float(max(0.1, self.edge_cache_quant))\n\n        # Trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_path = None\n        best_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        last_improve_iter = 0\n\n        for it in range(self.max_iter):\n            active_from_start = (it % 2 == 0)\n            tree1 = tree_a if active_from_start else tree_b\n            tree2 = tree_b if active_from_start else tree_a\n            grid1 = grid_a if active_from_start else grid_b\n            grid2 = grid_b if active_from_start else grid_a\n            attractor = self.goal if active_from_start else self.start\n\n            # Sample\n            if best_path is not None and self._rand() < self.informed_bias:\n                x_rand = self._sample_informed(best_len)\n            else:\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    x_rand = self._sample_corridor(d_sg)\n                else:\n                    x_rand = self._sample_free()\n            if x_rand is None:\n                continue\n\n            # Nearest\n            qnear = self._nearest_in_grid(grid1, x_rand)\n            if qnear is None:\n                continue\n\n            # Steer and pre-insert checks\n            x_new = self._steer(qnear.position, x_rand, self.step_size)\n            if not self._in_bounds(x_new):\n                continue\n            if self._point_in_obstacles(x_new):\n                continue\n            if self._has_nearby(grid1, x_new, self.dupe_radius):\n                continue\n            if not self._edge_free(qnear.position, x_new):\n                continue\n\n            # Choose best parent among neighbors and short lookback\n            parent, new_cost = self._choose_parent(grid1, qnear, x_new)\n\n            # Soft cap admission\n            if not self._bucket_accept(grid1, x_new, new_cost):\n                continue\n\n            # Insert node (ensuring both checks already passed)\n            new_node = Node(x_new, parent, new_cost)\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(grid1, new_node)\n\n            # Rewire cheaper neighbors\n            nbrs = self._neighbors_in_radius(grid1, x_new, self.rewire_radius, self.k_near_max)\n            for nb in nbrs:\n                if nb is new_node or nb is parent:\n                    continue\n                cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n                if cand_cost + 1e-9 < nb.cost and self._edge_free(new_node.position, nb.position):\n                    # Perform rewiring\n                    oldp = nb.parent\n                    if oldp is not None:\n                        try:\n                            oldp.children.remove(nb)\n                        except:\n                            pass\n                    self._remove_edge(edges, oldp, nb)\n                    new_node.add_child(nb)\n                    nb.cost = cand_cost\n                    edges.append((new_node, nb))\n                    self._propagate_costs(nb, edges)\n\n            # Try to connect to the other tree\n            a_end, b_end = self._try_connect(new_node, tree2, grid2, nodes, edges)\n            if a_end is not None and b_end is not None:\n                path = self._merge_paths(a_end, b_end, active_from_start)\n                plen = self._path_len(path)\n                if plen + 1e-9 < best_len:\n                    best_path = path\n                    best_len = plen\n                    last_improve_iter = it\n\n            # Early refinement stop if no improvement\n            if best_path is not None and (it - last_improve_iter) >= self.stall_after:\n                final = self._finalize_path(best_path)\n                return PlannerResult(True, final, nodes, edges)\n\n        if best_path is not None:\n            final = self._finalize_path(best_path)\n            return PlannerResult(True, final, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # -------------------- RNG --------------------\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0x7fffffff\n        s ^= len(self.obstacles) * 2654435761\n        self._rng = (s ^ 0x9E3779B9) & 0x7fffffff\n        if self._rng == 0:\n            self._rng = 1234567\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0x7fffffff\n        return (self._rng / 2147483647.0)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # -------------------- Geometry --------------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= step:\n            return self._clamp_tuple(b)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_paths(self, a_end, b_end, active_from_start):\n        pa = self._path_to_root(a_end)\n        pb = self._path_to_root(b_end)\n        if active_from_start:\n            pb.reverse()\n            return pa + pb\n        else:\n            pa.reverse()\n            return pb + pa\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # -------------------- Sampling --------------------\n    def _sample_free(self):\n        for _ in range(64):\n            if self.dims == 3:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _sample_corridor(self, dsg):\n        t = self._rand()\n        seg = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        width = max(self.step_size, 0.15 * dsg)\n        for _ in range(24):\n            if self.dims == 3:\n                ox = self._rand_range(-width, width)\n                oy = self._rand_range(-width, width)\n                oz = self._rand_range(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((seg[0] + ox, seg[1] + oy, seg[2] + oz))\n                else:\n                    continue\n            else:\n                ox = self._rand_range(-width, width)\n                oy = self._rand_range(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((seg[0] + ox, seg[1] + oy))\n                else:\n                    continue\n            if not self._point_in_obstacles(p):\n                return p\n        return self._sample_free()\n\n    def _sample_informed(self, best_len):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dims))\n        a = 0.5 * best_len\n        for _ in range(64):\n            if self.dims == 3:\n                p = (self._rand_range(c[0] - a, c[0] + a),\n                     self._rand_range(c[1] - a, c[1] + a),\n                     self._rand_range(c[2] - a, c[2] + a))\n            else:\n                p = (self._rand_range(c[0] - a, c[0] + a),\n                     self._rand_range(c[1] - a, c[1] + a))\n            if not self._in_bounds(p):\n                continue\n            if self._dist(self.start, p) + self._dist(p, self.goal) <= best_len + 1e-9 and not self._point_in_obstacles(p):\n                return p\n        return self._sample_corridor(self._dist(self.start, self.goal))\n\n    # -------------------- Node spatial grid --------------------\n    def _cell_of(self, pos):\n        if self.dims == 3:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        else:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        lst = grid.get(key)\n        if lst is None:\n            grid[key] = [node]\n        else:\n            lst.append(node)\n\n    def _nearest_in_grid(self, grid, pos, max_ring=6):\n        cell = self._cell_of(pos)\n        best = None\n        bestd = 1e100\n        if self.dims == 3:\n            for r in range(0, max_ring + 1):\n                found = False\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            b = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if not b:\n                                continue\n                            for n in b:\n                                d = self._dist(n.position, pos)\n                                if d < bestd:\n                                    bestd = d\n                                    best = n\n                                    found = True\n                if found:\n                    return best\n        else:\n            for r in range(0, max_ring + 1):\n                found = False\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        b = grid.get((cell[0] + dx, cell[1] + dy))\n                        if not b:\n                            continue\n                        for n in b:\n                            d = self._dist(n.position, pos)\n                            if d < bestd:\n                                bestd = d\n                                best = n\n                                found = True\n                if found:\n                    return best\n        # Fallback: return any from all buckets\n        for b in grid.values():\n            for n in b:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, kmax):\n        cell = self._cell_of(pos)\n        r_cells = int(max(1, radius // self.cell_size) + 1)\n        cand = []\n        if self.dims == 3:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((cell[0] + dx, cell[1] + dy))\n                    if b:\n                        cand.extend(b)\n        # Sort by distance and cap to kmax\n        tmp = []\n        for n in cand:\n            tmp.append((self._dist(n.position, pos), n))\n        tmp.sort(key=lambda x: x[0])\n        out = []\n        for i in range(min(kmax, len(tmp))):\n            out.append(tmp[i][1])\n        return out\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        r_cells = int(max(1, radius // self.cell_size) + 1)\n        r2 = radius * radius\n        if self.dims == 3:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._sqdist(n.position, pos) <= r2:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((cell[0] + dx, cell[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._sqdist(n.position, pos) <= r2:\n                            return True\n        return False\n\n    def _sqdist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _bucket_accept(self, grid, pos, new_cost):\n        key = self._cell_of(pos)\n        b = grid.get(key)\n        if not b:\n            return True\n        if len(b) < self.bucket_soft_cap:\n            return True\n        # Soft admission: allow if it improves the worst cost in bucket\n        worst = -1e100\n        for n in b:\n            if n.cost > worst:\n                worst = n.cost\n        return new_cost + 1e-9 < worst\n\n    # -------------------- Obstacle spatial grid and collision --------------------\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.dims == 3:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            key = (cx, cy, cz)\n                            lst = self.obs_grid.get(key)\n                            if lst is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        key = (cx, cy)\n                        lst = self.obs_grid.get(key)\n                        if lst is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.dims == 3:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.ecache_quant) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.ecache_quant) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        if len(self.ecache) - self._last_prune_size > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self.ecache:\n            return\n        cutoff = self._tick - 3000\n        to_del = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            i = 0\n            for k in list(self.ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune_size = len(self.ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(self.dims):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # -------------------- Parent selection and rewiring --------------------\n    def _choose_parent(self, grid, qnear, x_new):\n        best_parent = qnear\n        best_cost = qnear.cost + self._dist(qnear.position, x_new)\n\n        # Neighbor-based selection\n        nbrs = self._neighbors_in_radius(grid, x_new, self.rewire_radius, self.k_near_max)\n        for n in nbrs:\n            if self._edge_free(n.position, x_new):\n                c = n.cost + self._dist(n.position, x_new)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best_parent = n\n\n        # Short ancestor lookback from qnear\n        cur = qnear\n        depth = 0\n        while cur is not None and depth < self.lookback_depth:\n            if self._edge_free(cur.position, x_new):\n                c = cur.cost + self._dist(cur.position, x_new)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best_parent = cur\n            cur = cur.parent\n            depth += 1\n\n        return best_parent, best_cost\n\n    def _propagate_costs(self, node, edges):\n        # Recompute costs of subtree from current parent downwards\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is not None:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            # children unchanged structurally; push to update\n            for ch in cur.children:\n                stack.append(ch)\n\n    # -------------------- Connect attempt --------------------\n    def _try_connect(self, new_node, other_tree, other_grid, nodes, edges):\n        qnear = self._nearest_in_grid(other_grid, new_node.position)\n        if qnear is None:\n            return (None, None)\n        # Direct edge\n        if self._edge_free(new_node.position, qnear.position):\n            return (new_node, qnear)\n\n        # Bounded extend toward new_node\n        cur = qnear\n        trials = 0\n        while trials < self.connect_trials:\n            nxt_pos = self._steer(cur.position, new_node.position, self.step_size)\n            if not self._in_bounds(nxt_pos):\n                break\n            if self._point_in_obstacles(nxt_pos):\n                break\n            if self._has_nearby(other_grid, nxt_pos, self.dupe_radius):\n                break\n            if not self._edge_free(cur.position, nxt_pos):\n                break\n            # Insert extension node (both checks satisfied)\n            nxt = Node(nxt_pos, cur, cur.cost + self._dist(cur.position, nxt_pos))\n            cur.add_child(nxt)\n            other_tree.append(nxt)\n            nodes.append(nxt)\n            edges.append((cur, nxt))\n            self._grid_insert(other_grid, nxt)\n            # Short LOS compression toward grandparent\n            gp = cur.parent\n            if gp is not None and self._edge_free(gp.position, nxt_pos):\n                try:\n                    cur.children.remove(nxt)\n                except:\n                    pass\n                self._remove_edge(edges, cur, nxt)\n                gp.add_child(nxt)\n                nxt.cost = gp.cost + self._dist(gp.position, nxt_pos)\n                edges.append((gp, nxt))\n            cur = nxt\n            trials += 1\n            # Check direct connect now\n            if self._edge_free(cur.position, new_node.position):\n                return (new_node, cur)\n        return (None, None)\n\n    def _remove_edge(self, edges, a, b):\n        if a is None or b is None:\n            return\n        for i in range(len(edges)):\n            if edges[i][0] is a and edges[i][1] is b:\n                edges.pop(i)\n                return\n\n    # -------------------- Path finalization --------------------\n    def _finalize_path(self, path):\n        if not path:\n            return []\n        pruned = self._visibility_prune(path)\n        return self._shortcut(pruned)\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, path):\n        if len(path) < 3 or self.shortcut_attempts <= 0:\n            return list(path)\n        pts = list(path)\n        best_len = self._path_len(pts)\n        tries = 0\n        while tries < self.shortcut_attempts and len(pts) >= 3:\n            i = int(self._rand_range(0, len(pts) - 2))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(pts[i], pts[j]):\n                new_pts = pts[:i + 1] + pts[j:]\n                new_len = self._path_len(new_pts)\n                if new_len + 1e-9 < best_len:\n                    pts = new_pts\n                    best_len = new_len\n            tries += 1\n        return pts",
            "objective": -11.32774,
            "time_improvement": -33.0,
            "length_improvement": 22.0,
            "smoothness_improvement": 1573.0,
            "node_improvement": 73.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.046834897994995114,
                    "num_nodes_avg": 130.0,
                    "path_length_avg": 149.32993104614934,
                    "smoothness_avg": 0.036661498379251534,
                    "success_improvement": 0.0,
                    "time_improvement": -89.83560899854946,
                    "node_improvement": 67.26265424326367,
                    "length_improvement": 18.149898509422645,
                    "smoothness_improvement": 473.83206135324673,
                    "objective_score": -13.691583287145015
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07827587127685547,
                    "num_nodes_avg": 198.0,
                    "path_length_avg": 225.8643764569522,
                    "smoothness_avg": 0.11752863025941271,
                    "success_improvement": 0.0,
                    "time_improvement": 53.19872730590275,
                    "node_improvement": 86.69623059866962,
                    "length_improvement": 24.599969993058853,
                    "smoothness_improvement": 2924.096309025387,
                    "objective_score": 45.34008173273307
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08122072219848633,
                    "num_nodes_avg": 265.0,
                    "path_length_avg": 115.44527293294735,
                    "smoothness_avg": 0.11180648037432621,
                    "success_improvement": 0.0,
                    "time_improvement": -60.90729647020259,
                    "node_improvement": 66.3064208518754,
                    "length_improvement": 23.326746631089154,
                    "smoothness_improvement": 1322.170177665503,
                    "objective_score": 2.3347099259202304
                }
            ],
            "success_rate": 1.0
        },
        "objective": 7.999999999999999,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Early termination after the first cross-tree connection, preventing further improvement and informed refinement\n   - Lack of true rewiring; only shallow line-of-sight compression, leading to suboptimal parent choices and longer detours\n   - Nearest-node selection confined to small grid rings or coarse fallbacks, often missing the best anchor\n   - Connection attempts gated by short radii and few steps, skipping longer valid shortcuts between trees\n   - Aggressive duplicate-radius and hard per-cell caps that block densification along optimal corridors\n   - Greedy sampling (high goal bias) with fixed step size that preserves zig-zags and increases path length\n   - Sparse, early-stopping shortcutting that leaves many redundant waypoints"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Neighbor-based optimal parent selection plus short ancestor lookback\n   - Local rewiring within a radius (cost-improving reparenting of nearby nodes)\n   - Soft bucket admission in crowded cells to allow better-cost nodes into optimal corridors\n   - Multi-trial, larger-radius cross-tree bridging with bounded extensions\n   - Informed and corridor-biased sampling focused around the current best path\n   - Continued refinement after the first solution until a stall condition\n   - Stronger post-processing via visibility pruning and increased shortcut attempts\n2. Expected mechanism of impact:\n   - Better parent selection and rewiring reduce cost-to-come at insertion and retroactively, eliminating detours\n   - Allowing densification in high-value regions enables straighter connectors and future rewires\n   - More aggressive and repeated cross-tree connections discover longer, obstacle-free shortcuts that cut corners\n   - Focused sampling concentrates growth inside promising ellipses/corridors, accelerating convergence to shorter paths\n   - Ongoing refinement replaces the initial feasible route with progressively shorter alternatives\n   - Post-processing removes redundant vertices and collapses visible segments, shortening the final path length"
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "BASIL-RRT: Bi-directional Adaptive Simplified Informed Lite with Rewire and Visibility. Two trees grow toward each other with simple grid-accelerated nearest search, duplicate suppression, best-parent selection, visibility jumps to higher ancestors, and light local rewiring. Guided sampling uses corridor and informed-ellipse biases to shorten routes. On connection, deterministic visibility compression, shortcutting, and elastic smoothing yield short, smooth paths efficiently.",
                "planning_mechanism": "Initialize bidirectional trees and spatial hashes. Repeat: sample a biased target (goal/corridor/informed/uniform), pick the nearest via grid, steer by a fixed step, and validate both node and edge. Choose the least-cost feasible parent from nearby nodes, insert, then visibility-jump to a visible ancestor and locally rewire cheaper neighbors. Probe the opposite tree for a direct or short bridge; if connected, assemble the path and postprocess with visibility compression, randomized shortcuts, and elastic smoothing. Maintain an incumbent best path for informed sampling.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.0,\n        goal_bias=0.15,\n        corridor_bias=0.45,\n        informed_bias=0.5,\n        cell_size_factor=1.2,\n        dupe_ratio=0.3,\n        connect_dist_factor=2.5,\n        rewire_mult=2.5,\n        neighbor_cap=32,\n        shortcuts=120,\n        elastic_iters=10\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.cell_size_factor = float(cell_size_factor)\n        self.dupe_ratio = float(dupe_ratio)\n        self.connect_dist_factor = float(connect_dist_factor)\n        self.rewire_mult = float(rewire_mult)\n        self.neighbor_cap = int(neighbor_cap)\n        self.shortcuts = int(max(0, shortcuts))\n        self.elastic_iters = int(max(0, elastic_iters))\n        self._rnd = 2463534242\n\n    # Public entry\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._seed_from_scene()\n        self._build_obstacle_grid()\n\n        # Endpoint validity\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Parameters\n        self.cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_ratio)\n        self.connect_dist = max(self.step_size, self.connect_dist_factor * self.step_size)\n        corridor_w = max(self.step_size, 0.2 * self._dist(self.start, self.goal))\n\n        # Trees and grids\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_insert(Ga, a_root)\n        self._grid_insert(Gb, b_root)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            T = Ta if side_a else Tb\n            G = Ga if side_a else Gb\n            T_opp = Tb if side_a else Ta\n            G_opp = Gb if side_a else Ga\n            attractor = self.goal if side_a else self.start\n\n            # Target sampling\n            target = self._sample_target(attractor, best_len, corridor_w)\n            if target is None:\n                continue\n\n            # Nearest and steer\n            near = self._nearest_grid(G, target)\n            if near is None:\n                continue\n            new_pos = self._steer(near.position, target)\n            if not self._within_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._has_nearby(G, new_pos, self.dupe_radius):\n                continue\n\n            # Best-parent selection with local neighbors\n            parent, new_cost = self._choose_parent(T, G, new_pos)\n            if parent is None:\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            T.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(G, new_node)\n\n            # Visibility jump to a cheaper visible ancestor\n            self._visibility_jump(new_node, edges)\n\n            # Local rewiring (length/cost reduction)\n            self._rewire_neighbors(G, new_node, edges)\n\n            # Try connect to opposite tree\n            other_near = self._nearest_grid(G_opp, new_node.position)\n            if other_near is not None:\n                dno = self._dist(new_node.position, other_near.position)\n                if dno <= self.connect_dist and self._edge_free(new_node.position, other_near.position):\n                    path = self._assemble_path(new_node, other_near, side_a)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # One-step probe from opposite tree\n                step_p = self._steer(other_near.position, new_node.position)\n                if self._within_bounds(step_p) and not self._point_in_obstacles(step_p):\n                    if not self._has_nearby(G_opp, step_p, self.dupe_radius):\n                        if self._edge_free(other_near.position, step_p):\n                            q = Node(step_p, other_near, other_near.cost + self._dist(other_near.position, step_p))\n                            other_near.add_child(q)\n                            T_opp.append(q)\n                            nodes.append(q)\n                            edges.append((other_near, q))\n                            self._grid_insert(G_opp, q)\n                            self._visibility_jump(q, edges)\n                            self._rewire_neighbors(G_opp, q, edges)\n                            if self._edge_free(new_node.position, q.position):\n                                path = self._assemble_path(new_node, q, side_a)\n                                path = self._postprocess(path)\n                                return PlannerResult(True, path, nodes, edges)\n\n            # Maintain incumbent best for informed sampling\n            if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                tmp = self._assemble_path(new_node, other_near, side_a)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._postprocess(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761\n        self._rnd = (s ^ 0x9E3779B9) & 0xffffffff\n        if self._rnd == 0:\n            self._rnd = 2463534242\n\n    def _rand(self):\n        self._rnd = (1664525 * self._rnd + 1013904223) & 0xffffffff\n        return self._rnd / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Sampling\n    def _sample_target(self, attractor, best_len, corridor_w):\n        for _ in range(16):\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p is not None and not self._point_in_obstacles(p):\n                    return p\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            elif r < self.goal_bias + self.corridor_bias:\n                t = self._rand()\n                base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n                if self.dims == 3:\n                    p = (self._rand_range(base[0] - corridor_w, base[0] + corridor_w),\n                         self._rand_range(base[1] - corridor_w, base[1] + corridor_w),\n                         self._rand_range(base[2] - corridor_w, base[2] + corridor_w))\n                else:\n                    p = (self._rand_range(base[0] - corridor_w, base[0] + corridor_w),\n                         self._rand_range(base[1] - corridor_w, base[1] + corridor_w))\n            else:\n                p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            p = self._clamp(p)\n            if not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if self._within_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Node spatial grid\n    def _cell_of(self, pos, cell=None):\n        cs = self.cell_size if cell is None else cell\n        if self.dims == 3:\n            return (int(pos[0] // cs), int(pos[1] // cs), int(pos[2] // cs))\n        return (int(pos[0] // cs), int(pos[1] // cs))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_grid(self, grid, pos):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        # Expand rings up to 3\n        for r in range(0, 4):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback: scan all buckets\n        for b in grid.values():\n            for n in b:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.dims == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _neighbors_within_radius(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        out = []\n        rr = radius * radius\n        for n in cand:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_nearby(self, grid, pos, radius):\n        neigh = self._neighbors_within_radius(grid, pos, radius, self.neighbor_cap)\n        return len(neigh) > 0\n\n    # Parent selection and optimization\n    def _choose_parent(self, tree, grid, new_pos):\n        n = len(tree)\n        # Dynamic radius ~ n^{-1/d}\n        dyn_r = max(self.step_size, self.rewire_mult * self.step_size * (1.0 / (1.0 + n)) ** (1.0 / max(1, self.dims)))\n        neigh = self._neighbors_within_radius(grid, new_pos, dyn_r, self.neighbor_cap)\n        if not neigh:\n            near = None\n            bestd = 1e100\n            for m in tree:\n                d = self._dist(m.position, new_pos)\n                if d < bestd:\n                    bestd = d\n                    near = m\n            neigh = [near] if near is not None else []\n        best_parent = None\n        best_cost = 1e100\n        for p in neigh:\n            d = self._dist(p.position, new_pos)\n            if d > dyn_r + 1e-9:\n                continue\n            if not self._edge_free(p.position, new_pos):\n                continue\n            gc = p.cost + d\n            if gc < best_cost:\n                best_cost = gc\n                best_parent = p\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    def _visibility_jump(self, node, edges):\n        cur_parent = node.parent\n        if cur_parent is None:\n            return\n        best_parent = cur_parent\n        best_cost = node.cost\n        anc = cur_parent.parent\n        while anc is not None:\n            if self._edge_free(anc.position, node.position):\n                c = anc.cost + self._dist(anc.position, node.position)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best_parent = anc\n            anc = anc.parent\n        if best_parent is not cur_parent:\n            self._reparent(node, best_parent, edges)\n\n    def _rewire_neighbors(self, grid, node, edges):\n        # Use same dynamic radius as parent selection from this node's tree size (approx via node.cost order not needed)\n        radius = max(self.step_size, self.rewire_mult * self.step_size * 0.9)\n        neigh = self._neighbors_within_radius(grid, node.position, radius, self.neighbor_cap)\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if node.cost + d + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        if child.parent is new_parent:\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old_parent = child.parent\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is parent and e[1] is child:\n                edges.pop(i)\n                break\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if abs(newc - ch.cost) > 1e-12:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    # Obstacles\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.dims == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.dims == 3:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Path assembly and post-process\n    def _assemble_path(self, u, v, side_a):\n        # u in current tree, v in opposite\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if side_a:\n            # start -> u then v -> goal\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _postprocess(self, path):\n        if len(path) < 2:\n            return path[:]\n        p = self._visibility_compress(path)\n        p = self._shortcut(p, self.shortcuts)\n        p = self._elastic(p, self.elastic_iters)\n        return p\n\n    def _visibility_compress(self, path):\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        while i < len(path):\n            far = i\n            j = i\n            while j < len(path):\n                if self._edge_free(anchor, path[j]):\n                    far = j\n                    j += 1\n                else:\n                    break\n            out.append(path[far])\n            anchor = path[far]\n            i = far + 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        best = self._path_len(pts)\n        n = len(pts)\n        noimp = 0\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n:\n                noimp += 1\n                if noimp > 16:\n                    break\n                continue\n            a, b = pts[i], pts[j - 1]\n            if self._edge_free(a, b):\n                candidate = pts[:i + 1] + pts[j - 1:]\n                L = self._path_len(candidate)\n                if L <= best + 1e-12:\n                    pts = candidate\n                    best = L\n                    n = len(pts)\n                    noimp = 0\n                else:\n                    noimp += 1\n            else:\n                noimp += 1\n            if noimp > 24:\n                break\n        return pts\n\n    def _elastic(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dims))\n                if self._point_in_obstacles(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if mid != pts[i]:\n                        pts[i] = mid\n                        moved = True\n            if not moved:\n                break\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts",
                "objective": -37.60553,
                "time_improvement": 63.0,
                "length_improvement": 17.0,
                "smoothness_improvement": 1737.0,
                "node_improvement": 84.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.01027677059173584,
                        "num_nodes_avg": 56.0,
                        "path_length_avg": 152.97087548687767,
                        "smoothness_avg": 0.05880624031240139,
                        "success_improvement": 0.0,
                        "time_improvement": 58.34522786771023,
                        "node_improvement": 85.89775875094435,
                        "length_improvement": 16.154239167002743,
                        "smoothness_improvement": 820.4453606838263,
                        "objective_score": 31.298338663933844
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.048004674911499026,
                        "num_nodes_avg": 233.0,
                        "path_length_avg": 260.1076340388263,
                        "smoothness_avg": 0.1240816945243068,
                        "success_improvement": 0.0,
                        "time_improvement": 71.29792559985403,
                        "node_improvement": 84.34455418934354,
                        "length_improvement": 13.168584974709937,
                        "smoothness_improvement": 3092.7113725425193,
                        "objective_score": 44.754085527494766
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.021122431755065917,
                        "num_nodes_avg": 136.0,
                        "path_length_avg": 118.36585536678952,
                        "smoothness_avg": 0.1098386556019516,
                        "success_improvement": 0.0,
                        "time_improvement": 58.154110224750575,
                        "node_improvement": 82.70820089001907,
                        "length_improvement": 21.38703484172179,
                        "smoothness_improvement": 1297.1395918106139,
                        "objective_score": 36.764151931511314
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "cross_over",
                "algorithm_description": "ARC-BiRRT: Adaptive Reuse-Cached, Ring-Hashed, Cost-Gated BiRRT-Connect. It accelerates bidirectional planning with exact edge-collision memoization, ring-hash nearest search, local LOS parent selection, per-cell cost-gated admission, and single-shot tree bridging; upon success it applies cache-reused visibility pruning and bounded shortcut smoothing for shorter, smoother paths.",
                "planning_mechanism": "Alternate expanding start/goal trees with small-beam guided sampling (goal/corridor bias); find a near node via ring-hash, steer one step, enforce node+edge checks and near-duplicate rejection; pick a best-cost parent among nearby ring neighbors that see the new point; admit only if per-cell capacity or cost improves; after insertion, attempt a direct LOS bridge to the opposite tree; on success, extract and cache-prune/shortcut the path and stop early.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.5,\n        beam_width=2,\n        goal_bias=0.3,\n        grid_cell_factor=1.6,\n        ring_max=3,\n        max_per_cell=6,\n        min_sep_factor=0.5,\n        los_neighbor_rings=1,\n        smoothing_iters=50,\n        corridor_bias=0.5\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.ring_max = ring_max\n        self.max_per_cell = max_per_cell\n        self.min_sep_factor = min_sep_factor\n        self.los_neighbor_rings = los_neighbor_rings\n        self.smoothing_iters = smoothing_iters\n        self.corridor_bias = corridor_bias\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # RNG state\n        self._lcg_state = 2463534242\n\n        # Caches\n        self._edge_cache = {}  # exact endpoints (ordered) -> bool blocked\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Derived params\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.3, self.step_size * self.min_sep_factor)\n        self.edge_res = max(0.5, min(1.0, self.step_size * 0.5))\n\n        # Reset caches\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            path = self._visibility_prune(path, obstacles, is_3d)\n            path = self._shortcut_smooth(path, obstacles, is_3d, iters=min(10, self.smoothing_iters))\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        bestcost_start = {}\n        bestcost_goal = {}\n\n        self._grid_add(grid_start, counts_start, bestcost_start, start_root)\n        self._grid_add(grid_goal, counts_goal, bestcost_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n\n            tree_a = start_tree if active_start else goal_tree\n            grid_a = grid_start if active_start else grid_goal\n            counts_a = counts_start if active_start else counts_goal\n            bestcost_a = bestcost_start if active_start else bestcost_goal\n\n            tree_b = goal_tree if active_start else start_tree\n            grid_b = grid_goal if active_start else grid_start\n            counts_b = counts_goal if active_start else counts_start\n            bestcost_b = bestcost_goal if active_start else bestcost_start\n\n            attractor = goal if active_start else start\n\n            for _ in range(self.beam_width):\n                x_rand = self._guided_sample(obstacles, is_3d, attractor)\n\n                nearest = self._nearest_hashed(grid_a, tree_a, x_rand)\n                if nearest is None:\n                    continue\n\n                new_pos = self._steer(nearest.position, x_rand)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                if self._near_duplicate(grid_a, new_pos, self.min_sep):\n                    continue\n\n                # Choose a parent among local neighbors with LOS (limited rings) for better path cost\n                parent = self._choose_parent_local(grid_a, new_pos, nearest, obstacles, is_3d)\n                if self._edge_blocked(parent.position, new_pos, obstacles, is_3d):\n                    continue  # safety\n\n                new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n                # Per-cell cost-gated admission\n                key_new = self._grid_key(new_pos)\n                ccount = counts_a.get(key_new, 0)\n                bestc = bestcost_a.get(key_new, float('inf'))\n                if ccount >= self.max_per_cell and not (new_cost + 1e-9 < bestc):\n                    continue\n\n                # Insert node\n                new_node = Node(new_pos, parent=parent, cost=new_cost)\n                parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((parent, new_node))\n                self._grid_add(grid_a, counts_a, bestcost_a, new_node)\n\n                # Try single-shot direct bridge to the other tree\n                other_near = self._nearest_hashed(grid_b, tree_b, new_node.position)\n                if other_near is not None:\n                    if not self._edge_blocked(new_node.position, other_near.position, obstacles, is_3d):\n                        path = self._extract_path(new_node, other_near, a_is_start_tree=active_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-9:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision and caching\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        if k in self._edge_cache:\n            return self._edge_cache[k]\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _guided_sample(self, obstacles, is_3d, attractor):\n        # Goal-biased with optional corridor pull (activated only after success; here kept generic)\n        if self._rand() < self.goal_bias:\n            p = attractor\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Mild blend toward attractor\n        alpha = 0.2\n        if self.dim == 3:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]),\n                   self._uniform(0.0, self.bounds[2]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(3))\n        else:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(2))\n        if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    # Grid / NN\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n        bc = bestcost.get(k)\n        if bc is None or node.cost < bc:\n            bestcost[k] = node.cost\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.ring_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback to limited random subset to avoid O(N)\n        if not tree:\n            return None\n        trials = min(64, len(tree))\n        for _ in range(trials):\n            idx = int(self._uniform(0, len(tree)))\n            n = tree[idx]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r = 1\n        cand = self._grid_ring_collect(grid, key, r)\n        rr = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # Parent selection among local neighbors with LOS\n    def _choose_parent_local(self, grid, new_pos, fallback_nearest, obstacles, is_3d):\n        key = self._grid_key(new_pos)\n        best_parent = fallback_nearest\n        best_cost = fallback_nearest.cost + self._dist(fallback_nearest.position, new_pos)\n        max_r = max(1, self.los_neighbor_rings)\n        for r in range(0, max_r + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            for n in cand:\n                if n is fallback_nearest or n is best_parent:\n                    pass\n                # Check LOS\n                if not self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                    c = n.cost + self._dist(n.position, new_pos)\n                    if c + 1e-9 < best_cost:\n                        best_cost = c\n                        best_parent = n\n        return best_parent\n\n    # Path\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
                "objective": -33.74569,
                "time_improvement": 58.0,
                "length_improvement": 18.0,
                "smoothness_improvement": 1051.0,
                "node_improvement": 90.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.010497808456420898,
                        "num_nodes_avg": 34.0,
                        "path_length_avg": 154.57051194099205,
                        "smoothness_avg": 0.03958955729868922,
                        "success_improvement": 0.0,
                        "time_improvement": 58.830179046785545,
                        "node_improvement": 91.4379249559305,
                        "length_improvement": 15.277453078640955,
                        "smoothness_improvement": 519.6625418241595,
                        "objective_score": 29.41383827034103
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.049208974838256835,
                        "num_nodes_avg": 116.0,
                        "path_length_avg": 236.11546529476226,
                        "smoothness_avg": 0.06943512420354042,
                        "success_improvement": 0.0,
                        "time_improvement": 69.28227518814471,
                        "node_improvement": 92.20587247194786,
                        "length_improvement": 21.177861477765767,
                        "smoothness_improvement": 1686.6157578555544,
                        "objective_score": 41.92447823238064
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.026494455337524415,
                        "num_nodes_avg": 117.0,
                        "path_length_avg": 122.03531483713664,
                        "smoothness_avg": 0.08227711903121854,
                        "success_improvement": 0.0,
                        "time_improvement": 45.98660915000911,
                        "node_improvement": 85.12396694214877,
                        "length_improvement": 18.94995458240024,
                        "smoothness_improvement": 946.5588810119002,
                        "objective_score": 29.898749899502377
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e1",
            "algorithm_description": "AURORA-BiRRT*: Adaptive Unified Rewire-Optimized Receding-Envelope BiRRT with Curvature-Aware Smoothing. It grows two trees with adaptive step sizing in clutter, dynamic-radius best-parent selection, bounded rewiring, and multi-step micro-bridging. Sampling blends goal, corridor, and informed prolate-ellipse regions using an incumbent path. A voxelized obstacle index accelerates exact slab-based segment-AABB checks. On connection, visibility compression, probabilistic shortcuts, and an angle-aware elastic smoother produce shorter, smoother paths quickly and robustly.",
            "planning_mechanism": "Alternate expanding start/goal trees. Each iteration: biased target sampling (goal/corridor/informed/uniform), ring-hash nearest, adaptive steer with local clutter feedback, and strict node+edge collision checks. Select a least-cost parent from radius-limited neighbors, insert, then leap to a visible ancestor and rewire a few cheaper neighbors. Attempt direct or multi-step micro-bridge to the opposite tree. Maintain an incumbent best length to focus informed sampling. On success, assemble and postprocess the path (visibility prune, bounded shortcuts, curvature-aware elastic smoothing) and return.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        pts = []\n        cur = self\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=7.0,\n        goal_bias=0.2,\n        corridor_bias=0.4,\n        informed_bias=0.5,\n        grid_cell_factor=1.25,\n        dupe_radius_factor=0.35,\n        connect_factor=2.75,\n        rewire_radius_mult=2.0,\n        neighbor_cap=48,\n        bridge_trials=2,\n        rewire_cap=8,\n        shortcut_trials=120,\n        smooth_iters=18\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dupe_radius_factor = float(dupe_radius_factor)\n        self.connect_factor = float(connect_factor)\n        self.rewire_radius_mult = float(rewire_radius_mult)\n        self.neighbor_cap = int(neighbor_cap)\n        self.bridge_trials = int(max(0, bridge_trials))\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.shortcut_trials = int(max(0, shortcut_trials))\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        # Validate endpoints\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_rng()\n        self._build_obs_index()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if self._segment_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Derived params\n        self.cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_r = max(0.5, self.step_size * self.dupe_radius_factor)\n        self.connect_dist = max(self.step_size, self.connect_factor * self.step_size)\n        self.corridor_w = max(self.step_size, 0.2 * self._dist(self.start, self.goal))\n\n        # Trees and grids\n        nodes = []\n        edges = []\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_put(Ga, a_root)\n        self._grid_put(Gb, b_root)\n\n        best_len = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            grow_a = (it % 2 == 0)\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n\n            target = self._sample_target(attractor, best_len)\n            if target is None:\n                continue\n\n            near = self._nearest(G, target, T)\n            if near is None:\n                continue\n\n            new_pos = self._steer_adaptive(near.position, target)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_blocked(new_pos):\n                continue\n            if self._has_duplicate(G, new_pos, self.dupe_r):\n                continue\n\n            parent, new_cost = self._choose_parent(G, T, new_pos)\n            if parent is None:\n                continue\n            if self._point_blocked(new_pos) or not self._segment_free(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            T.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_put(G, new_node)\n\n            # Ancestor visibility leap\n            self._ancestor_leap(new_node, edges)\n\n            # Local bounded rewiring\n            self._rewire_local(G, new_node, edges)\n\n            # Try to connect to the opposite tree\n            other = self._nearest(Gopp, new_node.position, Topp)\n            connected = False\n            end_node = None\n            if other is not None:\n                if self._dist(new_node.position, other.position) <= self.connect_dist and self._segment_free(new_node.position, other.position):\n                    connected = True\n                    end_node = other\n                else:\n                    # Micro-bridge steps from the opposite tree\n                    head = other\n                    for _ in range(self.bridge_trials):\n                        step_p = self._steer_adaptive(head.position, new_node.position)\n                        if not self._in_bounds(step_p) or self._point_blocked(step_p):\n                            break\n                        if self._has_duplicate(Gopp, step_p, self.dupe_r):\n                            break\n                        if not self._segment_free(head.position, step_p):\n                            break\n                        q = Node(step_p, head, head.cost + self._dist(head.position, step_p))\n                        head.add_child(q)\n                        Topp.append(q)\n                        nodes.append(q)\n                        edges.append((head, q))\n                        self._grid_put(Gopp, q)\n                        self._ancestor_leap(q, edges)\n                        self._rewire_local(Gopp, q, edges)\n                        head = q\n                        if self._segment_free(new_node.position, head.position):\n                            connected = True\n                            end_node = head\n                            break\n\n            if connected and end_node is not None:\n                path = self._assemble(new_node, end_node, grow_a)\n                path = self._postprocess(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Maintain incumbent for informed sampling\n            if other is not None and self._segment_free(new_node.position, other.position):\n                tmp = self._assemble(new_node, other, grow_a)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._postprocess(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s = (s * 2654435761 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 13) * 1103515245\n        self._rng = s if s != 0 else 2463534242\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and bounds\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer_adaptive(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        # Base step\n        step = self.step_size if d > self.step_size else d\n        # Estimate local clutter by obstacle index buckets overlapped by tentative step box\n        dirv = tuple((b[i] - a[i]) / d for i in range(self.dims))\n        trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n        clutter = self._box_bucket_density(a, trial)\n        if clutter > 10 and step > 0.5 * self.step_size:\n            step *= 0.6\n            trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n            clutter = self._box_bucket_density(a, trial)\n            if clutter > 14 and step > 0.3 * self.step_size:\n                step *= 0.6\n                trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n        return self._clamp(trial)\n\n    # Sampling\n    def _sample_target(self, attractor, best_len):\n        for _ in range(16):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._sample_informed(best_len * 1.02)\n                if p is not None and not self._point_blocked(p):\n                    return p\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            elif r < self.goal_bias + self.corridor_bias:\n                t = self._rand()\n                base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n                if self.dims == 3:\n                    p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                         self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w),\n                         self._rand_range(base[2] - self.corridor_w, base[2] + self.corridor_w))\n                else:\n                    p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                         self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w))\n            else:\n                if self.dims == 3:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            p = self._clamp(p)\n            if not self._point_blocked(p):\n                return p\n        return None\n\n    def _sample_informed(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        # Axis-aligned rejection in prolate envelope\n        for _ in range(24):\n            if self.dims == 3:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half),\n                     self._rand_range(c[2] - half, c[2] + half))\n            else:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half))\n            if self._in_bounds(p) and (self._dist(p, self.start) + self._dist(p, self.goal)) <= max_sum:\n                return p\n        return None\n\n    # Node grid\n    def _cell_of(self, pos):\n        return tuple(int(pos[i] // self.cell) for i in range(self.dims))\n\n    def _grid_put(self, grid, node):\n        k = self._cell_of(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_nodes(self, grid, key, r):\n        out = []\n        if self.dims == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos, tree):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        for r in range(0, 4):\n            cand = self._ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback limited scan\n        if not tree:\n            return None\n        step = max(1, len(tree) // 64)\n        for i in range(0, len(tree), step):\n            n = tree[i]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r = max(1, int(radius // self.cell) + 1)\n        cand = self._ring_nodes(grid, key, r)\n        out = []\n        rr = radius * radius\n        for n in cand:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_duplicate(self, grid, pos, radius):\n        return len(self._neighbors(grid, pos, radius, self.neighbor_cap)) > 0\n\n    # Parent selection and optimization\n    def _choose_parent(self, grid, tree, new_pos):\n        n = max(1, len(tree))\n        # RRT* radius ~ (log(n)/n)^{1/d} scaled\n        base = (self.rewire_radius_mult * self.step_size)\n        dyn_r = max(self.step_size, base * ((1.0 + self._log1p(n)) / n) ** (1.0 / max(1, self.dims)))\n        neigh = self._neighbors(grid, new_pos, dyn_r, self.neighbor_cap)\n        if not neigh:\n            # fallback to nearest in tree\n            near = None\n            bestd = 1e100\n            for m in tree:\n                d = self._dist(m.position, new_pos)\n                if d < bestd:\n                    bestd = d\n                    near = m\n            neigh = [near] if near is not None else []\n        best_p = None\n        best_c = 1e100\n        for p in neigh:\n            d = self._dist(p.position, new_pos)\n            gc = p.cost + d\n            if gc + 1e-9 < best_c and self._segment_free(p.position, new_pos):\n                best_c = gc\n                best_p = p\n        if best_p is None:\n            return None, None\n        return best_p, best_c\n\n    def _log1p(self, x):\n        # simple series for small x; adequate for our integer n\n        return 0.5 if x <= 1.0 else self._fast_log(x + 1.0)\n\n    def _fast_log(self, x):\n        # crude monotonic approximation using change-of-base and piecewise\n        y = 0.0\n        t = x\n        while t > 2.718281828:\n            t *= 0.367879441  # divide by e\n            y += 1.0\n        # linear tail\n        return y + (t - 1.0) / 2.718281828\n\n    def _ancestor_leap(self, node, edges):\n        curp = node.parent\n        if curp is None:\n            return\n        bestp = curp\n        bestc = node.cost\n        anc = curp.parent\n        while anc is not None:\n            if self._segment_free(anc.position, node.position):\n                c = anc.cost + self._dist(anc.position, node.position)\n                if c + 1e-9 < bestc:\n                    bestc = c\n                    bestp = anc\n            anc = anc.parent\n        if bestp is not curp:\n            self._reparent(node, bestp, edges)\n\n    def _rewire_local(self, grid, node, edges):\n        radius = max(self.step_size, self.rewire_radius_mult * self.step_size)\n        neigh = self._neighbors(grid, node.position, radius, self.neighbor_cap)\n        improvements = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if node.cost + d + 1e-9 < nb.cost and self._segment_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n                improvements += 1\n                if improvements >= self.rewire_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        if child.parent is new_parent:\n            return\n        if not self._segment_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._remove_edge(edges, old, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        # propagate cost to subtree\n        stack = [child]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if abs(newc - ch.cost) > 1e-12:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is p and e[1] is c:\n                edges.pop(i)\n                return\n\n    # Obstacles and collision\n    def _build_obs_index(self):\n        # Cell size for obstacle spatial index\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.dims == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obs_grid.get(key)\n                            if b is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obs_grid.get(key)\n                        if b is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_blocked(self, p):\n        if self.dims == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _segment_free(self, a, b):\n        return not self._segment_hits(a, b)\n\n    def _box_bucket_density(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            s = 0\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            s += len(bkt)\n            return s\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            s = 0\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        s += len(bkt)\n            return s\n\n    def _segment_hits(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit3d(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit2d(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit2d(self, p0, p1, bmin, bmax):\n        # Slab method\n        t0, t1 = 0.0, 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _seg_box_hit3d(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Path assembly and postprocess\n    def _assemble(self, u, v, a_side):\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if a_side:\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _postprocess(self, path):\n        if len(path) < 2:\n            return path[:]\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.shortcut_trials)\n        p = self._elastic_angle_smooth(p, self.smooth_iters)\n        return p\n\n    def _visibility_prune(self, path):\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._segment_free(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = list(path)\n        best = self._path_len(pts)\n        n = len(pts)\n        fail = 0\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1:\n                fail += 1\n                if fail > 24:\n                    break\n                continue\n            a, b = pts[i], pts[j - 1]\n            if self._segment_free(a, b):\n                cand = pts[:i + 1] + pts[j - 1:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    pts = cand\n                    best = L\n                    n = len(pts)\n                    fail = 0\n                else:\n                    fail += 1\n            else:\n                fail += 1\n            if fail > 48:\n                break\n        return pts\n\n    def _elastic_angle_smooth(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                b = pts[i]\n                c = pts[i + 1]\n                # Angle-aware midpoint pull\n                mid = tuple(0.25 * a[k] + 0.5 * b[k] + 0.25 * c[k] for k in range(self.dims))\n                if self._point_blocked(mid):\n                    continue\n                if self._segment_free(a, mid) and self._segment_free(mid, c):\n                    if mid != b:\n                        pts[i] = mid\n                        moved = True\n                # Try skip if possible\n                if self._segment_free(a, c):\n                    pts[i] = c  # will be removed next pass by neighbors\n                    moved = True\n            # Compact duplicates\n            comp = [pts[0]]\n            for p in pts[1:]:\n                if p != comp[-1]:\n                    comp.append(p)\n            pts = comp\n            if not moved:\n                break\n            if len(pts) < 3:\n                break\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts",
            "objective": -39.0221,
            "time_improvement": 68.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1312.0,
            "node_improvement": 88.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009383320808410645,
                    "num_nodes_avg": 51.0,
                    "path_length_avg": 148.31907804876715,
                    "smoothness_avg": 0.03583382190014427,
                    "success_improvement": 0.0,
                    "time_improvement": 61.966642474939334,
                    "node_improvement": 87.15688743389575,
                    "length_improvement": 18.703963055278603,
                    "smoothness_improvement": 460.8771271269766,
                    "objective_score": 32.11675621128384
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.043584227561950684,
                    "num_nodes_avg": 172.0,
                    "path_length_avg": 228.72791182641134,
                    "smoothness_avg": 0.08818936081319215,
                    "success_improvement": 0.0,
                    "time_improvement": 73.9409183696743,
                    "node_improvement": 88.44319021702614,
                    "length_improvement": 23.644039464437803,
                    "smoothness_improvement": 2169.175773952521,
                    "objective_score": 47.21457805932758
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01668705940246582,
                    "num_nodes_avg": 82.0,
                    "path_length_avg": 122.67227871244054,
                    "smoothness_avg": 0.1106371606216832,
                    "success_improvement": 0.0,
                    "time_improvement": 66.9410768359495,
                    "node_improvement": 89.57406230133503,
                    "length_improvement": 18.526913505383728,
                    "smoothness_improvement": 1307.2965167220898,
                    "objective_score": 37.73495373762554
                }
            ],
            "success_rate": 1.0
        },
        "objective": 11.2,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Restricted or approximate neighbor/nearest selection leading to suboptimal parent choice and zig-zag growth\n   - Missing or weak edge rewiring, preserving higher-cost branches after new information appears\n   - Fixed, relatively large step size and aggressive duplicate rejection reducing node density needed for shorter routes\n   - Single-shot bridging between trees, failing to form low-cost connections across narrow gaps\n   - Sampling that underutilizes incumbent-path information, spending iterations away from promising low-cost regions\n   - Post-processing limited to basic visibility pruning and coarse midpoint smoothing, leaving excess waypoints and detours\n   - Per-cell admission/gating and cost heuristics that prematurely reject nodes enabling globally cheaper paths"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Dynamic RRT*-style parent selection radius with log(n)/n scaling and collision-checked best-parent choice\n   - Ancestor visibility leaps that reattach nodes to cheaper visible ancestors\n   - Bounded local rewiring of nearby nodes to reduce accumulated path costs\n   - Incremental micro-bridging to the opposite tree instead of single-shot connect\n   - Adaptive steering that shortens valid segments in clutter and preserves longer straight moves in open space\n   - More reliable nearest-neighbor fallback and broader neighbor caps to expose better parents\n   - Stronger post-processing: targeted shortcutting plus angle-aware elastic smoothing\n   - Fast obstacle-indexed segment checks enabling more successful cost-improving operations within the iteration budget\n2. Expected mechanism of impact:\n   - Better parent selection and rewiring directly lower path cost at insertion, yielding straighter, shorter branches\n   - Visibility-based ancestor jumps remove unnecessary intermediates, shrinking overall path length\n   - Micro-bridging forms direct connections across gaps/corridors, avoiding long detours before trees meet\n   - Adaptive step sizing increases the chance of longer, collision-free edges, reducing waypoint count and distance\n   - Enhanced neighborhood coverage uncovers cheaper local connections that earlier filters or coarse rings missed\n   - Post-processing eliminates residual bends and superfluous waypoints, further shortening the final path\n   - Faster, indexed collision queries allow more iterations to realize these improvements within the same runtime"
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "CORE-BiRRT*: A lean, informed bidirectional RRT with local RRT* rewiring. It uses a simple spatial hash for nearest queries, coarse obstacle binning for fast collision tests, single-step expansion with strict node+edge checks, greedy RRT-Connect style bridging, and a light two-stage smoother (visibility + elastic midpoint + shortcuts) for shorter, smoother paths.",
                "planning_mechanism": "Alternate start/goal tree expansion: sample (uniform/goal/corridor, ellipse after first path), steer one step, pick best-cost parent among local neighbors, insert if node- and edge-free, locally rewire neighbors to reduce costs, then greedily extend the opposite tree toward the new point; upon connection, extract, prune, smooth, and return.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=6.0,\n        connect_mult=3.0,\n        goal_bias=0.25,\n        corridor_bias=0.45,\n        grid_cell_factor=1.5,\n        rewire_radius_factor=2.0,\n        connect_cap=24,\n        smooth_iters=120\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_mult = float(connect_mult)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.rewire_radius_factor = float(rewire_radius_factor)\n        self.connect_cap = int(max(1, connect_cap))\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 987654321\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # RNG seed\n        self._seed_from_scene()\n\n        # Derived params\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.rewire_radius = max(self.step * 1.1, self.step * self.rewire_radius_factor)\n        self.connect_step = max(self.step, self.step * self.connect_mult)\n        self.dup_radius = max(0.25 * self.step, 0.5)\n\n        # Build obstacle bins\n        self._build_obs_bins()\n\n        # Start/goal validity\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize bidirectional trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None  # informed bound once a solution is found (not used if early return)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = tree_start if active_start else tree_goal\n            tree_b = tree_goal if active_start else tree_start\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            attractor = self.goal if active_start else self.start\n\n            s = self._guided_sample(attractor, best_len)\n            if s is None:\n                continue\n\n            nearest = self._nearest_grid(grid_a, s)\n            if nearest is None:\n                continue\n\n            newp = self._steer(nearest.position, s, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(grid_a, newp, self.dup_radius):\n                continue\n            if not self._edge_free(nearest.position, newp):\n                continue\n\n            # Choose best parent among local neighbors (RRT* local)\n            parent, new_cost = self._choose_best_parent(grid_a, newp, nearest)\n\n            # Safety checks before commit\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            # Insert node\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            tree_a.append(nn)\n            self._grid_add(grid_a, nn)\n\n            # Local rewiring: try to improve neighbors' cost via nn\n            neigh = self._neighbors_in_radius(grid_a, nn.position, self.rewire_radius)\n            for nb in neigh:\n                if nb is nn or nb is parent:\n                    continue\n                # New path cost through nn\n                cand_cost = nn.cost + self._dist(nn.position, nb.position)\n                if cand_cost + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                    old_parent = nb.parent\n                    if old_parent is not None:\n                        old_parent.remove_child(nb)\n                        self._remove_edge(edges, (old_parent, nb))\n                    nn.add_child(nb)\n                    nb.cost = cand_cost\n                    edges.append((nn, nb))\n                    self._propagate_cost(nb)\n\n            # Try to connect from other tree toward nn (RRT-Connect style)\n            meet = self._connect_grow(tree_b, grid_b, nn.position, nodes, edges)\n            if meet is not None:\n                # Connected: build final path\n                meet_node = meet  # node in other tree closest that achieved connection\n                if active_start:\n                    pa = self._trace_to_root(nn)             # start -> ... -> nn\n                    pb = self._trace_to_root(meet_node)      # goal  -> ... -> meet\n                    path = pa + pb[::-1]                     # start -> ... nn -> meet -> ... -> goal\n                else:\n                    pa = self._trace_to_root(meet_node)      # start -> ... -> meet\n                    pb = self._trace_to_root(nn)             # goal  -> ... -> nn\n                    path = pa + pb[::-1]                     # start -> ... meet -> nn -> ... -> goal\n                # Record no duplicate consecutive points\n                path2 = []\n                for p in path:\n                    if (not path2) or (p != path2[-1]):\n                        path2.append(p)\n                final = self._finalize_path(path2)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and helpers\n    def _seed_from_scene(self):\n        s = 0xA5A5A5A5 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 11) ^ (q << 7)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 7) * 1597334677) & 0xffffffff\n        if s == 0:\n            s = 987654321\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash for nodes\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            cand.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        cand.extend(lst)\n        return cand\n\n    def _nearest_grid(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, 3):\n            cand = self._grid_ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback scan across all buckets\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        nb = self._neighbors_in_radius(grid, pos, radius)\n        return len(nb) > 0\n\n    # Obstacles binning and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obin.get(key)\n                            if b is None:\n                                self.obin[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obin.get(key)\n                        if b is None:\n                            self.obin[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parent selection with local neighbors\n    def _choose_best_parent(self, grid, newp, fallback):\n        parent = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        neigh = self._neighbors_in_radius(grid, newp, self.rewire_radius)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                parent = n\n                best_cost = c\n        return parent, best_cost\n\n    # Connect step: RRT-Connect style growth from tree toward target\n    def _connect_grow(self, tree, grid, target_pos, nodes, edges):\n        # Start from nearest node in other tree\n        start = self._nearest_grid(grid, target_pos)\n        if start is None:\n            return None\n        cur = start\n        steps = 0\n        while steps < self.connect_cap:\n            # If direct connection possible, finish\n            if self._edge_free(cur.position, target_pos):\n                return cur\n            nxtp = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxtp)) or self._point_in_obstacles(nxtp):\n                return None\n            if not self._edge_free(cur.position, nxtp):\n                return None\n            # Commit this connect step\n            new_cost = cur.cost + self._dist(cur.position, nxtp)\n            nn = Node(nxtp, cur, new_cost)\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n        # Final try after cap\n        if self._edge_free(cur.position, target_pos):\n            return cur\n        return None\n\n    # Path handling\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _remove_edge(self, edges, e):\n        # e is (u, v)\n        try:\n            idx = edges.index(e)\n            edges.pop(idx)\n        except:\n            pass\n\n    def _propagate_cost(self, node):\n        # Update costs of subtree after rewiring\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    # Sampling\n    def _guided_sample(self, attractor, best_len):\n        r = self._rand()\n        # Informed sampling after first solution bound (ellipse around start-goal)\n        if best_len is not None and r < 0.6:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        # Goal/corridor biased sampling\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        if r < self.goal_bias + self.corridor_bias:\n            return self._corridor_point()\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.06 * sg)\n        if self.is3:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            oz = self._rand_range(-w, w)\n            p = (base[0] + ox, base[1] + oy, base[2] + oz)\n        else:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            p = (base[0] + ox, base[1] + oy)\n        return self._clamp(p)\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(20):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Smoothing\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _elastic_midpoint(self, pts, iters=2):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(iters):\n            changed = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if mid != b and self._edge_free(a, mid) and self._edge_free(mid, c):\n                    cur[i] = mid\n                    changed = True\n            if not changed:\n                break\n        return cur\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._visibility_prune(path)\n        p1 = self._elastic_midpoint(p0, iters=3)\n        p2 = self._shortcut(p1, self.smooth_iters)\n        p3 = self._visibility_prune(p2)\n        return p3",
                "objective": -30.28934,
                "time_improvement": 51.0,
                "length_improvement": 12.0,
                "smoothness_improvement": 1570.0,
                "node_improvement": 82.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.016851282119750975,
                        "num_nodes_avg": 79.0,
                        "path_length_avg": 190.23640673379288,
                        "smoothness_avg": 0.03324330254781312,
                        "success_improvement": 0.0,
                        "time_improvement": 31.696800023966244,
                        "node_improvement": 80.10576680936792,
                        "length_improvement": -4.271589019562566,
                        "smoothness_improvement": 420.3298738601826,
                        "objective_score": 9.047735964753246
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.059451723098754884,
                        "num_nodes_avg": 262.0,
                        "path_length_avg": 235.58120329866102,
                        "smoothness_avg": 0.12047403072161833,
                        "success_improvement": 0.0,
                        "time_improvement": 64.45371658607792,
                        "node_improvement": 82.39602230733051,
                        "length_improvement": 21.356213509943267,
                        "smoothness_improvement": 2999.8835844041396,
                        "objective_score": 47.14926100381003
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.02198073863983154,
                        "num_nodes_avg": 139.0,
                        "path_length_avg": 122.23450723412502,
                        "smoothness_avg": 0.109187917398101,
                        "success_improvement": 0.0,
                        "time_improvement": 56.4537086938224,
                        "node_improvement": 82.32676414494597,
                        "length_improvement": 18.81766047684322,
                        "smoothness_improvement": 1288.8622498901318,
                        "objective_score": 34.67102014370331
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "SAGE-Connect: A simplified adaptive BiRRT-Connect with local cost-aware parenting and light rewiring. It uses a uniform spatial hash for nearest/neighbor queries, coarse obstacle binning for fast collision checks, adaptive rewire radius, and minimal biased/informed sampling. It inserts only strictly node- and edge-free states, creates the exact meeting node to reduce kinks, and applies a compact densify+shortcut+visibility smoother for short, smooth paths.",
            "planning_mechanism": "Alternate growth from start/goal trees: sample (uniform with small goal bias; ellipse after first solution), steer one step, choose the best-cost parent among nearby nodes, add after node+edge checks, locally rewire cheaper neighbors, then greedily extend the opposite tree toward the new node and insert the exact meeting point; upon connection, extract, densify, shortcut, visibility-prune, and return.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=6.0,\n        connect_mult=2.0,\n        goal_bias=0.12,\n        grid_cell_factor=1.6,\n        rewire_base=2.2,\n        smooth_iters=120\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_mult = float(connect_mult)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.rewire_base = float(rewire_base)\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.connect_step = max(self.step, self.step * self.connect_mult)\n        self.dup_radius = max(0.5, 0.4 * self.step)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            Ta = tree_a if active_start else tree_b\n            Tb = tree_b if active_start else tree_a\n            Ga = grid_a if active_start else grid_b\n            Gb = grid_b if active_start else grid_a\n            attractor = self.goal if active_start else self.start\n\n            sample = self._sample(attractor, best_len)\n            if sample is None:\n                continue\n\n            na = self._nearest(Ga, sample)\n            if na is None:\n                continue\n\n            newp = self._steer(na.position, sample, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(Ga, newp, self.dup_radius):\n                continue\n            if not self._edge_free(na.position, newp):\n                continue\n\n            rew_rad = self._adaptive_rewire_radius(len(Ta))\n            parent, new_cost = self._choose_parent(Ga, newp, na, rew_rad)\n\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            Ta.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(Ga, nn)\n\n            self._local_rewire(Ga, nn, rew_rad, edges)\n\n            meet_node, reached = self._connect_toward(Tb, Gb, nn.position, nodes, edges)\n            if reached:\n                if active_start:\n                    pa = self._trace_to_root(nn)        # start -> ... -> nn\n                    pb = self._trace_to_root(meet_node) # goal  -> ... -> nn\n                    path = pa + pb[-2::-1]              # avoid duplicate nn\n                else:\n                    pa = self._trace_to_root(meet_node) # start -> ... -> nn\n                    pb = self._trace_to_root(nn)        # goal  -> ... -> nn\n                    path = pa + pb[-2::-1]\n\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 13) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found_any = False\n        for r in range(0, 4):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found_any = True\n            if found_any:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius)) > 0\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.2)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parenting and rewiring\n    def _choose_parent(self, grid, newp, fallback, radius):\n        parent = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        neigh = self._neighbors_in_radius(grid, newp, radius)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                parent = n\n                best_cost = c\n        return parent, best_cost\n\n    def _local_rewire(self, grid, nn, radius, edges):\n        neigh = self._neighbors_in_radius(grid, nn.position, radius)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            cand = nn.cost + self._dist(nn.position, nb.position)\n            if cand + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                nn.add_child(nb)\n                nb.cost = cand\n                edges.append((nn, nb))\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        try:\n            idx = edges.index(e)\n            edges.pop(idx)\n        except:\n            pass\n\n    def _adaptive_rewire_radius(self, n_nodes):\n        # Shrink with tree size without log; simple exponential decay\n        base = max(self.step * 1.2, self.step * self.rewire_base)\n        decay = pow(0.5, n_nodes / 2500.0)\n        return max(self.step * 1.2, base * decay)\n\n    # BiRRT-Connect growth from other tree toward target; insert exact meeting node if visible\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < 64:\n            if self._edge_free(cur.position, target_pos):\n                # Insert the exact meeting point for a clean junction\n                if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                    if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        cur.add_child(nn)\n                        tree.append(nn)\n                        nodes.append(nn)\n                        edges.append((cur, nn))\n                        self._grid_add(grid, nn)\n                        return nn, True\n                # If too close, treat current as meeting node\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(grid, nxt, self.dup_radius * 0.75):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n        # Final try after capped steps\n        if self._edge_free(cur.position, target_pos):\n            if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    edges.append((cur, nn))\n                    self._grid_add(grid, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.55:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _densify(self, pts, seg_len):\n        if len(pts) < 2:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts)):\n            a = out[-1]\n            b = pts[i]\n            d = self._dist(a, b)\n            if d <= seg_len * 1.05:\n                out.append(b)\n                continue\n            nseg = int(d / seg_len)\n            if nseg < 1:\n                out.append(b)\n                continue\n            for k in range(1, nseg + 1):\n                t = k / float(nseg + 1)\n                inter = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n                if self._edge_free(out[-1], inter):\n                    out.append(inter)\n                else:\n                    break\n            if self._edge_free(out[-1], b):\n                out.append(b)\n            else:\n                out.append(b)\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._densify(path, seg_len=max(1.0, 0.5 * self.step))\n        p1 = self._shortcut(p0, self.smooth_iters)\n        p2 = self._visibility_prune(p1)\n        p3 = self._shortcut(p2, max(20, self.smooth_iters // 2))\n        return self._dedup(p3)",
            "objective": -39.95809,
            "time_improvement": 69.0,
            "length_improvement": 21.0,
            "smoothness_improvement": 1361.0,
            "node_improvement": 85.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008446240425109863,
                    "num_nodes_avg": 40.0,
                    "path_length_avg": 154.00203649529243,
                    "smoothness_avg": 0.0463463750398735,
                    "success_improvement": 0.0,
                    "time_improvement": 65.76490472936995,
                    "node_improvement": 89.92697053638882,
                    "length_improvement": 15.589043478498803,
                    "smoothness_improvement": 625.4214121382626,
                    "objective_score": 32.21000456660158
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02304682731628418,
                    "num_nodes_avg": 136.0,
                    "path_length_avg": 230.09301068249903,
                    "smoothness_avg": 0.08849989105200873,
                    "success_improvement": 0.0,
                    "time_improvement": 86.220263890156,
                    "node_improvement": 90.86205738090439,
                    "length_improvement": 23.188330174083777,
                    "smoothness_improvement": 2177.1659406631616,
                    "objective_score": 50.66490697481287
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02282891273498535,
                    "num_nodes_avg": 204.0,
                    "path_length_avg": 115.03810237530747,
                    "smoothness_avg": 0.10863321186734835,
                    "success_improvement": 0.0,
                    "time_improvement": 54.77338134763434,
                    "node_improvement": 74.06230133502861,
                    "length_improvement": 23.597169928095134,
                    "smoothness_improvement": 1281.8064364830614,
                    "objective_score": 36.99934854356269
                }
            ],
            "success_rate": 1.0
        },
        "objective": 9.0,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Imprecise tree connection that stops at a nearby node instead of creating the exact meeting state, yielding longer bridge joins.\n   - Over-aggressive goal/corridor bias leading to detoured first solutions and reduced exploration of more direct routes.\n   - Coarse connection steps that terminate early, forcing longer meeting segments and unnecessary detours.\n   - Fixed rewiring radius that does not adapt with tree size, leaving suboptimal parents and preserving longer subtrees.\n   - Smoothing pipeline that skips early densification and applies greedy visibility first, limiting shortcut opportunities and retaining excess path length."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Exact insertion of the meeting state during bidirectional connection.\n   - Reduced goal bias and removal of corridor-focused sampling, with more uniform exploration.\n   - Smaller connection step and deeper connect growth for finer approach.\n   - Adaptive (shrinking) rewiring radius enabling stronger early cost improvements.\n   - Densify-then-shortcut smoothing with an additional shortcut stage.\n2. Expected mechanism of impact:\n   - Creating the exact junction eliminates redundant segments at the join, shortening the bridge.\n   - More uniform sampling discovers straighter passages sooner, avoiding biased detours.\n   - Finer connection steps reach closer to the target direction, reducing unnecessary path length.\n   - Early larger rewiring neighborhoods replace costly parents, contracting the tree around shorter routes.\n   - Densification increases candidate pairs for collision-free shortcuts, removing superfluous waypoints and edges to shorten the final path."
        }
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "EC-Guide BiRRT with Edge-Cached LOS Compression and Elliptic Focus (EC-GBiRRT). This planner grows two trees from start and goal using a small beam of guided samples, compresses each new extension via multi-ancestor line-of-sight (LOS) with a shared edge-collision memo cache, and attempts a zero-step direct connect to the other tree. After a first path, sampling narrows to a prolate ellipse corridor to accelerate convergence. Early-terminating forward LOS shortcutting finalizes the path. These choices cut repeated collision checks, reduce tree depth, and avoid micro-step connects, improving planning time and path quality.",
                "planning_mechanism": "Each iteration alternates trees: generate a few biased samples, pick a nearby node via a grid hash, steer one step, and validate node/edge. Select the cheapest LOS-ancestor parent using cached edge checks, insert the node, then try a direct LOS link to the other tree\u2019s nearest node; if it succeeds, extract and lightly shortcut the path. A shared bounded edge-cache stores free/blocked results, multi-ancestor compression shortens chains, a per-cell cap limits redundant local growth, and corridor-biased sampling activates once a provisional path exists.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        beam_width=2,\n        goal_bias=0.2,\n        los_lookback_depth=10,\n        min_separation_factor=0.6,\n        grid_cell_factor=1.2,\n        per_cell_cap=12,\n        edge_cache_capacity=20000,\n        shortcut_attempts=60,\n        no_improve_stop=12\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.los_lookback_depth = los_lookback_depth\n        self.min_separation_factor = min_separation_factor\n        self.grid_cell_factor = grid_cell_factor\n        self.per_cell_cap = per_cell_cap\n        self.edge_cache_capacity = edge_cache_capacity\n        self.shortcut_attempts = shortcut_attempts\n        self.no_improve_stop = no_improve_stop\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dims = len(self.bounds)\n        self.is_3d = self.dims == 3\n        self.obstacles = map.obstacles\n        self.start = map.start\n        self.goal = map.goal\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n        self.ecache = {}\n        self._tick = 0\n        self._last_prune = 0\n        self.ecache_quant = max(0.5, self.step_size * 0.5)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(self.start, parent=None, cost=0.0)\n        goal_root = Node(self.goal, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        incumbent_len = None\n        best_path = None\n\n        for _ in range(self.max_iter):\n            # Alternate trees each loop\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, self.goal),\n                (tree_b, grid_b, tree_a, grid_a, self.start),\n            ]:\n                progress = False\n                for _b in range(self.beam_width):\n                    sample = self._guided_sample(attractor, incumbent_len)\n                    if sample is None:\n                        continue\n\n                    nearest = self._nearest_in_grid(active_grid, sample)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos):\n                        continue\n                    if self._in_obstacle(new_pos):\n                        continue\n                    # Check edge to nearest; required before any parent selection\n                    if not self._edge_free(nearest.position, new_pos):\n                        continue\n                    # Duplicate suppression\n                    if self._has_nearby(active_grid, new_pos, self.min_separation):\n                        continue\n\n                    # Parent selection via LOS ancestors using cached edge checks\n                    parent = self._select_parent(nearest, new_pos)\n                    if parent is None:\n                        # Safety: though nearest->new_pos was free, parent selection failed; fallback\n                        parent = nearest\n\n                    # Per-cell growth limit; allow insert if bucket light or cost improves the bucket\n                    cell_key = self._cell_of(new_pos)\n                    bucket = active_grid.get(cell_key)\n                    if bucket and len(bucket) >= self.per_cell_cap:\n                        # Allow only if this is significantly cheaper than the best in bucket\n                        best_bucket_cost = min(n.cost for n in bucket)\n                        cand_cost = parent.cost + self._distance(parent.position, new_pos)\n                        if cand_cost >= best_bucket_cost - 1e-6:\n                            continue\n\n                    new_cost = parent.cost + self._distance(parent.position, new_pos)\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node)\n                    progress = True\n\n                    # Attempt direct LOS connect (no micro-steps)\n                    other_near = self._nearest_in_grid(other_grid, new_node.position)\n                    if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                        path_a = self._path_from_root(new_node)\n                        path_b = self._path_from_root(other_near)\n                        # Merge with direct bridge segment ensured free\n                        raw_path = path_a + path_b[::-1]\n                        # Path might duplicate joint if new_node coincides with other_near; dedup\n                        if len(raw_path) >= 2 and self._distance(raw_path[-1], raw_path[-2]) <= 1e-9:\n                            raw_path.pop()  # remove duplicate\n                        smoothed = self._shortcut(raw_path)\n                        final_path = smoothed if smoothed else raw_path\n                        best_path = final_path\n                        incumbent_len = self._path_length(final_path)\n                        return PlannerResult(True, final_path, nodes, edges)\n\n                # If we found no progress from this side in this alternation, continue to the other\n                if not progress:\n                    continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # ---------- Geometry and metrics ----------\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._distance(a, b)\n        if d <= 1e-12:\n            return a\n        if d <= self.step_size:\n            return b\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n\n    def _path_from_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        length = 0.0\n        for i in range(1, len(path)):\n            length += self._distance(path[i - 1], path[i])\n        return length\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, attractor, incumbent_len):\n        # Corridor-biased sampling if incumbent exists; else mild goal bias\n        # Try limited attempts to avoid heavy rejection\n        for _ in range(20):\n            if incumbent_len is not None and self._distance(self.start, self.goal) > 1e-9:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.05)\n                if p is None:\n                    continue\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if self._within_bounds(p) and not self._in_obstacle(p):\n                return p\n        # Fallback hard-attractor\n        return attractor if self._within_bounds(attractor) and not self._in_obstacle(attractor) else None\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        # Rejection sample in the bounding box of the ellipse/spheroid\n        # Limited attempts for speed; returns None on failure\n        cx = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        # Direction vector and its norm\n        v = tuple(f2[i] - f1[i] for i in range(self.dims))\n        vd = self._distance(f1, f2)\n        # Bounding box extents\n        ext = [half, half, half] if self.is_3d else [half, half]\n        # Try a few samples\n        for _ in range(12):\n            p = tuple(cx[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            # ellipse condition: dist(p,f1)+dist(p,f2) <= max_sum_dist\n            if self._distance(p, f1) + self._distance(p, f2) <= max_sum_dist and not self._in_obstacle(p):\n                return p\n        return None\n\n    # ---------- Grid spatial hash ----------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    def _nearest_in_grid(self, grid, pos, max_ring=5):\n        cell = self._cell_of(pos)\n        best = None\n        best_d = 1e100\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best = n\n                                        best_d = d\n                                        found = True\n                if found:\n                    return best\n        else:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best = n\n                                    best_d = d\n                                    found = True\n                if found:\n                    return best\n        # Rare fallback: scan all buckets\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._distance(n.position, pos)\n                if d < best_d:\n                    best = n\n                    best_d = d\n        return best\n\n    # ---------- Obstacles ----------\n    def _in_obstacle(self, pos):\n        if self.is_3d:\n            px, py, pz = pos\n            for obs in self.obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in self.obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.ecache_quant) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.ecache_quant) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]  # True if free, False if blocked\n        # Compute and cache\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        # Bounded pruning\n        if len(self.ecache) - self._last_prune > self.edge_cache_capacity:\n            self._prune_cache()\n        return free\n\n    def _prune_cache(self):\n        # Drop roughly oldest 40%\n        if not self.ecache:\n            return\n        cutoff = self._tick - 2000\n        to_remove = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_remove.append(k)\n        if not to_remove:\n            # If nothing older than cutoff, remove every 3rd entry to bound size\n            i = 0\n            for k in list(self.ecache.keys()):\n                if i % 3 == 0:\n                    to_remove.append(k)\n                i += 1\n        for k in to_remove:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune = len(self.ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        dist = self._distance(a, b)\n        # Resolution tuned for speed while preserving safety\n        resolution = max(0.5, min(1.0, self.step_size * 0.5))\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(self.dims))\n            if self._in_obstacle(p):\n                return True\n        return False\n\n    # ---------- Parent selection ----------\n    def _select_parent(self, nearest, new_pos):\n        best = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        cur = nearest\n        depth = 0\n        while cur is not None and depth < self.los_lookback_depth:\n            if self._edge_free(cur.position, new_pos):\n                cand = cur.cost + self._distance(cur.position, new_pos)\n                if cand + 1e-9 < best_cost:\n                    best_cost = cand\n                    best = cur\n            cur = cur.parent\n            depth += 1\n        return best\n\n    # ---------- Shortcut smoothing ----------\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_improve = 0\n        i = 0\n        while attempts < self.shortcut_attempts and i < len(pts) - 2:\n            improved = False\n            # Try to jump from i to a farther j\n            j = len(pts) - 1\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    # Remove intermediates\n                    del pts[i + 1:j]\n                    improved = True\n                    no_improve = 0\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n                no_improve += 1\n            attempts += 1\n            if no_improve >= self.no_improve_stop:\n                break\n        return pts\n\n    # ---------- Random helpers ----------\n    def _rand(self):\n        # expects 'random' module available\n        return random.random()\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()",
                "objective": -29.11471,
                "time_improvement": 51.0,
                "length_improvement": 10.0,
                "smoothness_improvement": 1571.0,
                "node_improvement": 89.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.02822730541229248,
                        "num_nodes_avg": 65.6,
                        "path_length_avg": 182.96020324956595,
                        "smoothness_avg": 0.05732726413788967,
                        "success_improvement": 0.0,
                        "time_improvement": -10.700544274551492,
                        "node_improvement": 83.48023167967766,
                        "length_improvement": -0.28338659103527,
                        "smoothness_improvement": 797.2961719045505,
                        "objective_score": 0.6062856225361433
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.01984243392944336,
                        "num_nodes_avg": 86.6,
                        "path_length_avg": 243.5413235727727,
                        "smoothness_avg": 0.09042567896577892,
                        "success_improvement": 0.0,
                        "time_improvement": 87.61375486797985,
                        "node_improvement": 94.18128065578178,
                        "length_improvement": 18.698896243086562,
                        "smoothness_improvement": 2226.7178507734366,
                        "objective_score": 48.63705346011307
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.01169896125793457,
                        "num_nodes_avg": 78.1,
                        "path_length_avg": 133.4682422714018,
                        "smoothness_avg": 0.1405957321950529,
                        "success_improvement": 0.0,
                        "time_improvement": 76.14970532839176,
                        "node_improvement": 90.06993006993007,
                        "length_improvement": 11.356748558062376,
                        "smoothness_improvement": 1688.3673358236224,
                        "objective_score": 38.100797412473064
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "e1",
                "algorithm_description": "FIBER-Connect*: Fast Informed Bi-directional Edge-Refining RRT* with priority-balanced growth, adaptive neighbor/rewire radii, short validated bridges, and online visibility-prune/shortcutting for smooth, compact paths with low search cost.",
                "planning_mechanism": "Per iteration, expand the smaller tree: sample (uniform/goal; informed ellipse after first path), steer one step, validate node and parent edge, pick the lowest-cost parent among nearby neighbors, insert, then locally rewire to reduce cost. Attempt a short, validated bridge to the opposite tree; if blocked, allow at most one assisted hop on the passive tree before retrying. On a bridge, extract the bi-tree path, apply visibility pruning and length-nonincreasing shortcuts, and return.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=5.5,\n        goal_bias=0.25,\n        informed_bias=0.6,\n        grid_cell_factor=1.0,\n        neighbor_base=3.2,\n        rewire_base=2.6,\n        connect_factor=3.0,\n        dupe_ratio=0.45,\n        ring_cap=4,\n        bridge_hops=1,\n        smooth_iters=80\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_base = float(neighbor_base)\n        self.rewire_base = float(rewire_base)\n        self.connect_factor = float(connect_factor)\n        self.dupe_ratio = float(dupe_ratio)\n        self.ring_cap = int(ring_cap)\n        self.bridge_hops = int(bridge_hops)\n        self.smooth_iters = int(smooth_iters)\n        self._rng = 123456789\n\n    def plan(self, map):\n        # Scene\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_rng()\n        # Build obstacle index and ensure start/goal free\n        self._build_obs_index()\n        if self._in_obs(self.start) or self._in_obs(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Straight line early exit\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            edges = [(n0, n1)]\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], edges)\n\n        # Parameters\n        self.space_extent = max(1.0, max(self.bounds))\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius_base = max(0.3, self.dupe_ratio * self.step_size)\n        self.connect_radius = max(self.step_size, self.connect_factor * self.step_size)\n\n        # Trees and spatial hashes\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes = [start_root, goal_root]\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        # Informed sampling bookkeeping\n        have_solution = False\n        best_path = []\n        best_len = 1e100\n        c_min = self._dist(self.start, self.goal)\n\n        for it in range(self.max_iter):\n            # Choose the tree with fewer nodes to keep balance\n            expand_a = (len(tree_a) <= len(tree_b))\n            active_tree = tree_a if expand_a else tree_b\n            passive_tree = tree_b if expand_a else tree_a\n            active_grid = grid_a if expand_a else grid_b\n            passive_grid = grid_b if expand_a else grid_a\n            attractor = self.goal if expand_a else self.start\n\n            # Radii adapt to tree size\n            n_active = max(2, len(active_tree))\n            parent_radius = self._adaptive_radius(n_active, self.neighbor_base)\n            rewire_radius = self._adaptive_radius(n_active, self.rewire_base)\n            dupe_radius = self.dupe_radius_base * (0.35 if have_solution else 1.0)\n\n            # Sample\n            x_rand = self._sample(attractor, have_solution, best_len, c_min)\n            if x_rand is None:\n                continue\n\n            # Nearest and steer\n            nearest = self._nearest(active_grid, x_rand)\n            if nearest is None:\n                continue\n            x_new = self._steer(nearest.position, x_rand, self.step_size)\n            if self._dist2(nearest.position, x_new) < 1e-10:\n                continue\n            if not self._in_bounds(x_new):\n                continue\n            if self._in_obs(x_new):\n                continue\n            if self._has_nearby(active_grid, x_new, dupe_radius):\n                continue\n\n            # Choose lowest-cost parent among neighbors (ties broken by smoother turn)\n            parent, new_cost = self._choose_parent(active_grid, x_new, nearest, parent_radius)\n            if parent is None:\n                continue\n\n            # Validate both checks before adding\n            if self._in_obs(x_new):\n                continue\n            if not self._edge_free(parent.position, x_new):\n                continue\n\n            # Insert node\n            new_node = Node(x_new, parent, new_cost)\n            parent.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            self._grid_insert(active_grid, new_node)\n\n            # Local rewiring\n            self._rewire(new_node, active_grid, rewire_radius)\n\n            # Try a short, validated bridge\n            bnode = self._best_bridge_candidate(passive_grid, new_node.position, self.connect_radius)\n            bridged = None\n            if bnode is not None and self._edge_free(bnode.position, new_node.position):\n                bridged = bnode\n            else:\n                # One assisted hop on passive tree if allowed\n                hops = 0\n                while bridged is None and hops < self.bridge_hops:\n                    hops += 1\n                    near_p = self._nearest(passive_grid, new_node.position)\n                    if near_p is None:\n                        break\n                    x_step = self._steer(near_p.position, new_node.position, self.step_size)\n                    if not self._in_bounds(x_step) or self._in_obs(x_step):\n                        break\n                    if self._has_nearby(passive_grid, x_step, dupe_radius):\n                        break\n                    # Select parent for the hop\n                    hop_parent, hop_cost = self._choose_parent(passive_grid, x_step, near_p, parent_radius)\n                    if hop_parent is None:\n                        break\n                    if not self._edge_free(hop_parent.position, x_step):\n                        break\n                    # Insert hop node in passive tree\n                    hop_node = Node(x_step, hop_parent, hop_cost)\n                    hop_parent.add_child(hop_node)\n                    passive_tree.append(hop_node)\n                    nodes.append(hop_node)\n                    self._grid_insert(passive_grid, hop_node)\n                    # Light rewiring on passive tree\n                    self._rewire(hop_node, passive_grid, rewire_radius)\n                    # Retry direct bridge\n                    if self._edge_free(hop_node.position, new_node.position):\n                        bridged = hop_node\n                        break\n\n            if bridged is not None:\n                path = self._extract_path(new_node, bridged, expand_a)\n                # Visibility prune then length-nonincreasing shortcuts\n                path = self._visibility_prune(path)\n                path = self._shortcut_nonincreasing(path, self.smooth_iters)\n                best_path = path\n                best_len = self._path_len(path)\n                edges = self._collect_edges(nodes)\n                return PlannerResult(True, best_path, nodes, edges)\n\n            # Optional online smoothing of incumbent (if already found, keep improving lightly)\n            if have_solution and best_path:\n                best_path = self._shortcut_nonincreasing(best_path, 4)\n                best_len = self._path_len(best_path)\n\n        # Finalize\n        edges = self._collect_edges(nodes)\n        if best_path:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # -------------------- RNG --------------------\n    def _seed_rng(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 17) * 2654435761\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # -------------------- Geometry --------------------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        d = d2 ** 0.5\n        if d <= step:\n            q = []\n            for i in range(self.dim):\n                v = b[i]\n                if v < 0.0:\n                    v = 0.0\n                if v > self.bounds[i]:\n                    v = self.bounds[i]\n                q.append(v)\n            return tuple(q)\n        r = step / d\n        q = []\n        for i in range(self.dim):\n            v = a[i] + (b[i] - a[i]) * r\n            if v < 0.0:\n                v = 0.0\n            if v > self.bounds[i]:\n                v = self.bounds[i]\n            q.append(v)\n        return tuple(q)\n\n    # -------------------- Obstacles --------------------\n    def _build_obs_index(self):\n        self.obs_cell = max(3.0, self.step_size * 1.3)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, ob in enumerate(self.obstacles):\n                x, y, z, w, h, d = ob\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, ob in enumerate(self.obstacles):\n                x, y, w, h = ob\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _in_obs(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy, cz))\n            if not b:\n                return False\n            px, py, pz = p\n            for idx in b:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy))\n            if not b:\n                return False\n            px, py = p\n            for idx in b:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        arr = self.obs_grid.get((cx, cy, cz))\n                        if arr:\n                            for idx in arr:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    arr = self.obs_grid.get((cx, cy))\n                    if arr:\n                        for idx in arr:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # -------------------- Spatial hashing --------------------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _neighbors_within(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        out = []\n        r2 = radius * radius\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_of(pos)\n        best = None\n        bestd2 = 1e100\n        got = False\n        for r in range(0, self.ring_cap + 1):\n            cand = []\n            if self.is_3d:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if b:\n                                cand.extend(b)\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy))\n                        if b:\n                            cand.extend(b)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n                    got = True\n            if got:\n                return best\n        # Fallback random probe\n        buckets = list(grid.values())\n        tries = 0\n        while tries < 32 and buckets:\n            b = buckets[int(self._rand_range(0, len(buckets)))]\n            if b:\n                n = b[int(self._rand_range(0, len(b)))]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            tries += 1\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        ns = self._neighbors_within(grid, pos, radius)\n        return len(ns) > 0\n\n    # -------------------- Parent selection and rewiring --------------------\n    def _choose_parent(self, grid, new_pos, fallback, radius):\n        cand = self._neighbors_within(grid, new_pos, radius)\n        if fallback not in cand:\n            cand.append(fallback)\n        best = None\n        best_cost = 1e100\n        best_smooth = -1.0\n        for n in cand:\n            if not self._edge_free(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-12 < best_cost:\n                best_cost = c\n                best = n\n                best_smooth = self._smooth_score(n, new_pos)\n            elif abs(c - best_cost) <= 1e-12:\n                sc = self._smooth_score(n, new_pos)\n                if sc > best_smooth:\n                    best_smooth = sc\n                    best = n\n        if best is None:\n            return None, None\n        return best, best_cost\n\n    def _smooth_score(self, parent, new_pos):\n        # Cosine of turn angle; higher is smoother. If no grandparent, neutral.\n        if parent.parent is None:\n            return 0.0\n        a = parent.parent.position\n        b = parent.position\n        c = new_pos\n        ab = tuple(b[i] - a[i] for i in range(self.dim))\n        bc = tuple(c[i] - b[i] for i in range(self.dim))\n        nab = self._dist(a, b)\n        nbc = self._dist(b, c)\n        if nab <= 1e-12 or nbc <= 1e-12:\n            return 0.0\n        dot = 0.0\n        for i in range(self.dim):\n            dot += ab[i] * bc[i]\n        cosang = dot / (nab * nbc)\n        if cosang < -1.0:\n            cosang = -1.0\n        if cosang > 1.0:\n            cosang = 1.0\n        return cosang\n\n    def _rewire(self, pivot, grid, radius):\n        neighbors = self._neighbors_within(grid, pivot.position, radius)\n        for nb in neighbors:\n            if nb is pivot or nb.parent is pivot:\n                continue\n            # prevent cycles: if nb is ancestor of pivot, skip\n            if self._is_ancestor(nb, pivot):\n                continue\n            if not self._edge_free(pivot.position, nb.position):\n                continue\n            new_c = pivot.cost + self._dist(pivot.position, nb.position)\n            if new_c + 1e-12 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    try:\n                        oldp.children.remove(nb)\n                    except:\n                        pass\n                pivot.add_child(nb)\n                nb.cost = new_c\n                self._propagate_cost(nb)\n\n    def _is_ancestor(self, node, potential_child):\n        cur = potential_child\n        while cur is not None:\n            if cur is node:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_cost(self, node):\n        # Update subtree costs after rewiring\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if newc + 1e-12 < ch.cost:\n                    ch.cost = newc\n                stack.append(ch)\n\n    # -------------------- Bridging and paths --------------------\n    def _best_bridge_candidate(self, grid_other, pos, radius):\n        cand = self._neighbors_within(grid_other, pos, radius)\n        if not cand:\n            return None\n        best = None\n        bestd2 = 1e100\n        for n in cand:\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd2:\n                bestd2 = d2\n                best = n\n        return best\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node, a_from_start):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if a_from_start:\n            return pa + list(reversed(pb))\n        else:\n            return pb + list(reversed(pa))\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pruned[-1], path[j]):\n                    # Accept only if not longer than original subpath\n                    seg = self._dist(pruned[-1], path[j])\n                    walk = 0.0\n                    for k in range(i + 1, j + 1):\n                        walk += self._dist(path[k - 1], path[k])\n                    if seg + 1e-9 <= walk:\n                        pruned.append(path[j])\n                        i = j\n                        advanced = True\n                        break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut_nonincreasing(self, path, iters):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        bestL = self._path_len(pts)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                newL = self._path_len(new_pts)\n                if newL <= bestL + 1e-12:\n                    pts = new_pts\n                    bestL = newL\n        return pts\n\n    def _collect_edges(self, nodes):\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return edges\n\n    # -------------------- Sampling --------------------\n    def _sample(self, attractor, informed, best_len, c_min):\n        r = self._rand()\n        if informed and best_len < 1e99 and r < self.informed_bias:\n            p = self._informed_sample(self.start, self.goal, best_len * 1.01, c_min)\n            if p is not None and self._in_bounds(p) and not self._in_obs(p):\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            return p if self._in_bounds(p) and not self._in_obs(p) else None\n        # Uniform\n        p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n        if self._in_bounds(p) and not self._in_obs(p):\n            return p\n        return None\n\n    def _informed_sample(self, f1, f2, c_best, c_min):\n        if not (c_best > c_min + 1e-9):\n            return None\n        center = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        a_vec = tuple(f2[i] - f1[i] for i in range(self.dim))\n        a_len = self._dist((0.0,) * self.dim, a_vec)\n        if a_len <= 1e-12:\n            return None\n        a_hat = tuple(a_vec[i] / a_len for i in range(self.dim))\n        r1 = 0.5 * c_best\n        r2_sq = max(0.0, 0.25 * (c_best * c_best - c_min * c_min))\n        if self.is_3d:\n            # Build orthonormal basis [a_hat, v, w]\n            # Simple fixed aux and cross to form basis\n            u = (1.0, 0.0, 0.0) if abs(a_hat[0]) < 0.9 else (0.0, 1.0, 0.0)\n            v = self._normalize(self._cross(a_hat, u))\n            w = self._cross(a_hat, v)\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                z = self._rand_range(-1.0, 1.0)\n                if x * x + y * y + z * z > 1.0:\n                    continue\n                px = r1 * x\n                r2 = (r2_sq ** 0.5)\n                py = r2 * y\n                pz = r2 * z\n                ex = center[0] + px * a_hat[0] + py * v[0] + pz * w[0]\n                ey = center[1] + px * a_hat[1] + py * v[1] + pz * w[1]\n                ez = center[2] + px * a_hat[2] + py * v[2] + pz * w[2]\n                p = (ex, ey, ez)\n                if self._in_bounds(p) and not self._in_obs(p):\n                    return p\n            return None\n        else:\n            # 2D ellipse with axes r1, r2\n            perp = (-a_hat[1], a_hat[0])\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                if x * x + y * y > 1.0:\n                    continue\n                r2 = (r2_sq ** 0.5)\n                px = r1 * x\n                py = r2 * y\n                ex = center[0] + px * a_hat[0] + py * perp[0]\n                ey = center[1] + px * a_hat[1] + py * perp[1]\n                p = (ex, ey)\n                if self._in_bounds(p) and not self._in_obs(p):\n                    return p\n            return None\n\n    def _normalize(self, v):\n        n = self._dist((0.0,) * len(v), v)\n        if n <= 1e-12:\n            return v\n        return tuple(v[i] / n for i in range(len(v)))\n\n    def _cross(self, a, b):\n        return (a[1] * b[2] - a[2] * b[1],\n                a[2] * b[0] - a[0] * b[2],\n                a[0] * b[1] - a[1] * b[0])\n\n    # -------------------- Radii --------------------\n    def _adaptive_radius(self, n, base_mult):\n        # Decays with n; lower-bounded by 1.5*step_size\n        decay = (1.0 / (n ** (1.0 / max(2, self.dim))))\n        r = base_mult * self.step_size * 0.5 + self.space_extent * 0.05 * decay\n        return max(1.5 * self.step_size, r)",
                "objective": -40.1344,
                "time_improvement": 63.0,
                "length_improvement": 20.0,
                "smoothness_improvement": 1814.0,
                "node_improvement": 90.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.012674951553344726,
                        "num_nodes_avg": 45.0,
                        "path_length_avg": 153.35894992834636,
                        "smoothness_avg": 0.03846541732582647,
                        "success_improvement": 0.0,
                        "time_improvement": 48.6246954693179,
                        "node_improvement": 88.66784185343742,
                        "length_improvement": 15.941529416200709,
                        "smoothness_improvement": 502.0673101398352,
                        "objective_score": 26.66266284121497
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.05657989978790283,
                        "num_nodes_avg": 140.0,
                        "path_length_avg": 233.83827885399037,
                        "smoothness_avg": 0.11832797178444796,
                        "success_improvement": 0.0,
                        "time_improvement": 66.17078448590458,
                        "node_improvement": 90.5932943626957,
                        "length_improvement": 21.93805185687287,
                        "smoothness_improvement": 2944.6639422069725,
                        "objective_score": 47.73738617092995
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.013706851005554199,
                        "num_nodes_avg": 79.0,
                        "path_length_avg": 115.01768024557694,
                        "smoothness_avg": 0.16483033391240323,
                        "success_improvement": 0.0,
                        "time_improvement": 72.84520158496316,
                        "node_improvement": 89.95549904640814,
                        "length_improvement": 23.61073333426484,
                        "smoothness_improvement": 1996.6296808560942,
                        "objective_score": 46.003148880328325
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "IBiRRT-Lite/G2: Informed, Balanced Bi-directional RRT with bounded-nearest search, short-range cost-aware parenting, light rewiring, cached collision tests, and nonincreasing visibility pruning for fast, smooth, and short paths. Tuned radii, duplicate control, and ellipse-focused sampling after the first solution improve efficiency and robustness over parents while preserving safety.",
            "planning_mechanism": "Alternate expansion of the smaller tree: sample (uniform/goal; informed ellipse after a solution), get a bounded-ring nearest, steer one step, reject near-duplicates, pick the lowest-cost feasible parent among nearby neighbors, validate node and edge, insert and lightly rewire. Try a short direct bridge to the opposite tree; if blocked, allow one assisted hop on the passive tree and retry. On success, extract, visibility-prune, and shortcut the path, then return. Edge checks use a small LRU cache; obstacle queries use a grid index.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3500,\n        step_size=4.8,\n        goal_bias=0.18,\n        informed_bias=0.7,\n        grid_cell_factor=0.9,\n        parent_factor=2.2,\n        rewire_factor=2.4,\n        connect_factor=2.6,\n        dupe_ratio=0.35,\n        ring_cap=6,\n        per_cell_cap=24,\n        assist_hops=1,\n        smooth_iters=64,\n        edge_cache_capacity=12000\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.parent_factor = float(parent_factor)\n        self.rewire_factor = float(rewire_factor)\n        self.connect_factor = float(connect_factor)\n        self.dupe_ratio = float(dupe_ratio)\n        self.ring_cap = int(ring_cap)\n        self.per_cell_cap = int(per_cell_cap)\n        self.assist_hops = int(assist_hops)\n        self.smooth_iters = int(smooth_iters)\n        self.edge_cache_capacity = int(edge_cache_capacity)\n        self._rng = 123456789\n        self._tick = 0\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_rng()\n\n        # Build obstacle index\n        self.obs_cell = max(2.5, self.step_size * 1.1)\n        self._build_obs_index()\n\n        # Validate start/goal free\n        if self._in_obs(self.start) or self._in_obs(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Fast straight-line check\n        self._ecache = {}\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            edges = [(n0, n1)]\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], edges)\n\n        # Spatial params\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius_base = max(0.3, self.dupe_ratio * self.step_size)\n        self.connect_radius = max(self.step_size, self.connect_factor * self.step_size)\n\n        # Trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        have_solution = False\n        best_path = []\n        best_len = 1e100\n        c_min = self._dist(self.start, self.goal)\n\n        for _ in range(self.max_iter):\n            # Expand smaller tree\n            expand_a = (len(tree_a) <= len(tree_b))\n            active_tree = tree_a if expand_a else tree_b\n            passive_tree = tree_b if expand_a else tree_a\n            active_grid = grid_a if expand_a else grid_b\n            passive_grid = grid_b if expand_a else grid_a\n            attractor = self.goal if expand_a else self.start\n\n            dupe_radius = self.dupe_radius_base * (0.4 if have_solution else 1.0)\n            parent_radius = self.parent_factor * self.step_size\n            rewire_radius = self.rewire_factor * self.step_size\n\n            x_rand = self._sample(attractor, have_solution, best_len, c_min)\n            if x_rand is None:\n                continue\n\n            nearest = self._nearest_bounded(active_grid, x_rand, self.ring_cap)\n            if nearest is None:\n                continue\n\n            x_new = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(x_new) or self._in_obs(x_new):\n                continue\n            if self._dist2(nearest.position, x_new) <= 1e-14:\n                continue\n            if self._has_nearby(active_grid, x_new, dupe_radius):\n                continue\n\n            parent, new_cost = self._choose_parent(active_grid, x_new, nearest, parent_radius)\n            if parent is None:\n                continue\n\n            if self._in_obs(x_new):\n                continue\n            if not self._edge_free(parent.position, x_new):\n                continue\n\n            # Per-cell capacity with cost override\n            if not self._cell_accept(active_grid, x_new, new_cost):\n                continue\n\n            new_node = Node(x_new, parent, new_cost)\n            parent.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            self._grid_insert(active_grid, new_node)\n\n            self._rewire_light(new_node, active_grid, rewire_radius, 8)\n\n            # Try direct bridge\n            bnode = self._best_bridge_candidate(passive_grid, new_node.position, self.connect_radius)\n            bridged = None\n            if bnode is not None and self._edge_free(new_node.position, bnode.position):\n                bridged = bnode\n            else:\n                # One assisted hop if allowed\n                hops = 0\n                while bridged is None and hops < self.assist_hops:\n                    hops += 1\n                    near_p = self._nearest_bounded(passive_grid, new_node.position, self.ring_cap)\n                    if near_p is None:\n                        break\n                    x_step = self._steer(near_p.position, new_node.position, self.step_size)\n                    if not self._in_bounds(x_step) or self._in_obs(x_step):\n                        break\n                    if self._has_nearby(passive_grid, x_step, dupe_radius):\n                        break\n                    hop_parent, hop_cost = self._choose_parent(passive_grid, x_step, near_p, parent_radius)\n                    if hop_parent is None:\n                        break\n                    if not self._edge_free(hop_parent.position, x_step):\n                        break\n                    hop_node = Node(x_step, hop_parent, hop_cost)\n                    hop_parent.add_child(hop_node)\n                    passive_tree.append(hop_node)\n                    nodes.append(hop_node)\n                    self._grid_insert(passive_grid, hop_node)\n                    self._rewire_light(hop_node, passive_grid, rewire_radius, 6)\n                    if self._edge_free(hop_node.position, new_node.position):\n                        bridged = hop_node\n                        break\n\n            if bridged is not None:\n                path = self._extract_path(new_node, bridged, expand_a)\n                path = self._visibility_prune(path)\n                path = self._shortcut_nonincreasing(path, self.smooth_iters)\n                best_path = path\n                best_len = self._path_len(best_path)\n                edges = self._collect_edges(nodes)\n                return PlannerResult(True, best_path, nodes, edges)\n\n            if have_solution and best_path:\n                best_path = self._shortcut_nonincreasing(best_path, 4)\n                best_len = self._path_len(best_path)\n\n        edges = self._collect_edges(nodes)\n        if best_path:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # -------- RNG --------\n    def _seed_rng(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 29) * 2654435761\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # -------- Geometry --------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        d = d2 ** 0.5\n        if d <= step:\n            q = []\n            for i in range(self.dim):\n                v = b[i]\n                if v < 0.0:\n                    v = 0.0\n                if v > self.bounds[i]:\n                    v = self.bounds[i]\n                q.append(v)\n            return tuple(q)\n        r = step / d\n        q = []\n        for i in range(self.dim):\n            v = a[i] + (b[i] - a[i]) * r\n            if v < 0.0:\n                v = 0.0\n            if v > self.bounds[i]:\n                v = self.bounds[i]\n            q.append(v)\n        return tuple(q)\n\n    # -------- Obstacles and collision --------\n    def _build_obs_index(self):\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, ob in enumerate(self.obstacles):\n                x, y, z, w, h, d = ob\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            arr = self.obs_grid.get(k)\n                            if arr is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                arr.append(idx)\n        else:\n            for idx, ob in enumerate(self.obstacles):\n                x, y, w, h = ob\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        arr = self.obs_grid.get(k)\n                        if arr is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            arr.append(idx)\n\n    def _in_obs(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            arr = self.obs_grid.get((cx, cy, cz))\n            if not arr:\n                return False\n            px, py, pz = p\n            for idx in arr:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            arr = self.obs_grid.get((cx, cy))\n            if not arr:\n                return False\n            px, py = p\n            for idx in arr:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        q = max(0.5, self.step_size * 0.5)\n        qa = tuple(int(a[i] / q) for i in range(self.dim))\n        qb = tuple(int(b[i] / q) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self._ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self._ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self._ecache[key] = (free, self._tick)\n        if len(self._ecache) > self.edge_cache_capacity:\n            # prune ~35% oldest\n            cutoff = self._tick - 1500\n            rem = []\n            for k, v in self._ecache.items():\n                if v[1] < cutoff:\n                    rem.append(k)\n            if not rem:\n                i = 0\n                for k in list(self._ecache.keys()):\n                    if i % 3 == 0:\n                        rem.append(k)\n                    i += 1\n            for k in rem:\n                if k in self._ecache:\n                    del self._ecache[k]\n        return free\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        arr = self.obs_grid.get((cx, cy, cz))\n                        if arr:\n                            for idx in arr:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect3(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    arr = self.obs_grid.get((cx, cy))\n                    if arr:\n                        for idx in arr:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_box_intersect2(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect2(self, p0, p1, mn, mx):\n        t0 = 0.0\n        t1 = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            if abs(d) < 1e-12:\n                if p < mn[i] or p > mx[i]:\n                    return False\n            else:\n                inv = 1.0 / d\n                tmin = (mn[i] - p) * inv\n                tmax = (mx[i] - p) * inv\n                if tmin > tmax:\n                    tmin, tmax = tmax, tmin\n                if tmin > t0:\n                    t0 = tmin\n                if tmax < t1:\n                    t1 = tmax\n                if t0 > t1:\n                    return False\n        return True\n\n    def _seg_box_intersect3(self, p0, p1, mn, mx):\n        t0 = 0.0\n        t1 = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            if abs(d) < 1e-12:\n                if p < mn[i] or p > mx[i]:\n                    return False\n            else:\n                inv = 1.0 / d\n                tmin = (mn[i] - p) * inv\n                tmax = (mx[i] - p) * inv\n                if tmin > tmax:\n                    tmin, tmax = tmax, tmin\n                if tmin > t0:\n                    t0 = tmin\n                if tmax < t1:\n                    t1 = tmax\n                if t0 > t1:\n                    return False\n        return True\n\n    # -------- Spatial hashing --------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _neighbors_within(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        out = []\n        r2 = radius * radius\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _nearest_bounded(self, grid, pos, ring_cap):\n        key = self._cell_of(pos)\n        best = None\n        bestd2 = 1e100\n        visited = False\n        for r in range(0, ring_cap + 1):\n            cand = []\n            if self.is_3d:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if b:\n                                cand.extend(b)\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy))\n                        if b:\n                            cand.extend(b)\n            if not cand:\n                continue\n            visited = True\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n        if visited:\n            return best\n        # fallback random buckets\n        buckets = list(grid.values())\n        tries = 0\n        while tries < 24 and buckets:\n            b = buckets[int(self._rand_range(0, len(buckets)))]\n            if b:\n                n = b[int(self._rand_range(0, len(b)))]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            tries += 1\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        ns = self._neighbors_within(grid, pos, radius)\n        return len(ns) > 0\n\n    def _cell_accept(self, grid, pos, cand_cost):\n        key = self._cell_of(pos)\n        b = grid.get(key)\n        if not b:\n            return True\n        if len(b) < self.per_cell_cap:\n            return True\n        best = 1e100\n        for n in b:\n            if n.cost < best:\n                best = n.cost\n        return cand_cost < best - 1e-6\n\n    # -------- Parent selection and light rewiring --------\n    def _choose_parent(self, grid, new_pos, fallback, radius):\n        cand = self._neighbors_within(grid, new_pos, radius)\n        if fallback not in cand:\n            cand.append(fallback)\n        best = None\n        best_cost = 1e100\n        best_smooth = -2.0\n        for n in cand:\n            if not self._edge_free(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-12 < best_cost:\n                best_cost = c\n                best = n\n                best_smooth = self._smooth_score(n, new_pos)\n            elif abs(c - best_cost) <= 1e-12:\n                sc = self._smooth_score(n, new_pos)\n                if sc > best_smooth:\n                    best_smooth = sc\n                    best = n\n        if best is None:\n            return None, None\n        return best, best_cost\n\n    def _smooth_score(self, parent, new_pos):\n        if parent.parent is None:\n            return 0.0\n        a = parent.parent.position\n        b = parent.position\n        c = new_pos\n        ab = tuple(b[i] - a[i] for i in range(self.dim))\n        bc = tuple(c[i] - b[i] for i in range(self.dim))\n        nab = self._dist(a, b)\n        nbc = self._dist(b, c)\n        if nab <= 1e-12 or nbc <= 1e-12:\n            return 0.0\n        dot = 0.0\n        for i in range(self.dim):\n            dot += ab[i] * bc[i]\n        cs = dot / (nab * nbc)\n        if cs < -1.0:\n            cs = -1.0\n        if cs > 1.0:\n            cs = 1.0\n        return cs\n\n    def _rewire_light(self, pivot, grid, radius, limit):\n        neighbors = self._neighbors_within(grid, pivot.position, radius)\n        changed = 0\n        for nb in neighbors:\n            if nb is pivot or nb.parent is pivot:\n                continue\n            # avoid cycles\n            if self._is_ancestor(nb, pivot):\n                continue\n            if not self._edge_free(pivot.position, nb.position):\n                continue\n            new_c = pivot.cost + self._dist(pivot.position, nb.position)\n            if new_c + 1e-12 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    try:\n                        oldp.children.remove(nb)\n                    except:\n                        pass\n                pivot.add_child(nb)\n                nb.cost = new_c\n                self._propagate_cost(nb)\n                changed += 1\n                if changed >= limit:\n                    break\n\n    def _is_ancestor(self, node, potential_child):\n        cur = potential_child\n        while cur is not None:\n            if cur is node:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if newc + 1e-12 < ch.cost:\n                    ch.cost = newc\n                stack.append(ch)\n\n    # -------- Bridging and path --------\n    def _best_bridge_candidate(self, grid_other, pos, radius):\n        cand = self._neighbors_within(grid_other, pos, radius)\n        if not cand:\n            return None\n        best = None\n        bestd2 = 1e100\n        for n in cand:\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd2:\n                bestd2 = d2\n                best = n\n        return best\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node, a_from_start):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if a_from_start:\n            return pa + list(reversed(pb))\n        else:\n            return pb + list(reversed(pa))\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                a = out[-1]\n                b = path[j]\n                if self._edge_free(a, b):\n                    # ensure nonincreasing subpath length\n                    seg = self._dist(a, b)\n                    walk = 0.0\n                    for k in range(i + 1, j + 1):\n                        walk += self._dist(path[k - 1], path[k])\n                    if seg + 1e-9 <= walk:\n                        out.append(b)\n                        i = j\n                        advanced = True\n                        break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        return out\n\n    def _shortcut_nonincreasing(self, path, iters):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        bestL = self._path_len(pts)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                newL = self._path_len(new_pts)\n                if newL <= bestL + 1e-12:\n                    pts = new_pts\n                    bestL = newL\n        return pts\n\n    def _collect_edges(self, nodes):\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return edges\n\n    # -------- Sampling --------\n    def _sample(self, attractor, informed, best_len, c_min):\n        r = self._rand()\n        if informed and best_len < 1e99 and r < self.informed_bias:\n            p = self._informed_sample(self.start, self.goal, best_len * 1.01, c_min)\n            if p is not None and self._in_bounds(p) and not self._in_obs(p):\n                return p\n        if r < self.goal_bias:\n            if self._in_bounds(attractor) and not self._in_obs(attractor):\n                return attractor\n        # Uniform\n        p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n        if self._in_bounds(p) and not self._in_obs(p):\n            return p\n        return None\n\n    def _informed_sample(self, f1, f2, c_best, c_min):\n        if not (c_best > c_min + 1e-9):\n            return None\n        center = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        a_vec = tuple(f2[i] - f1[i] for i in range(self.dim))\n        a_len = self._dist((0.0,) * self.dim, a_vec)\n        if a_len <= 1e-12:\n            return None\n        a_hat = tuple(a_vec[i] / a_len for i in range(self.dim))\n        r1 = 0.5 * c_best\n        r2_sq = max(0.0, 0.25 * (c_best * c_best - c_min * c_min))\n        if self.is_3d:\n            u = (1.0, 0.0, 0.0) if abs(a_hat[0]) < 0.9 else (0.0, 1.0, 0.0)\n            v = self._normalize(self._cross(a_hat, u))\n            w = self._cross(a_hat, v)\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                z = self._rand_range(-1.0, 1.0)\n                if x * x + y * y + z * z > 1.0:\n                    continue\n                px = r1 * x\n                r2 = (r2_sq ** 0.5)\n                py = r2 * y\n                pz = r2 * z\n                qx = center[0] + px * a_hat[0] + py * v[0] + pz * w[0]\n                qy = center[1] + px * a_hat[1] + py * v[1] + pz * w[1]\n                qz = center[2] + px * a_hat[2] + py * v[2] + pz * w[2]\n                p = (qx, qy, qz)\n                if self._in_bounds(p) and not self._in_obs(p):\n                    return p\n            return None\n        else:\n            perp = (-a_hat[1], a_hat[0])\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                if x * x + y * y > 1.0:\n                    continue\n                r2 = (r2_sq ** 0.5)\n                px = r1 * x\n                py = r2 * y\n                qx = center[0] + px * a_hat[0] + py * perp[0]\n                qy = center[1] + px * a_hat[1] + py * perp[1]\n                p = (qx, qy)\n                if self._in_bounds(p) and not self._in_obs(p):\n                    return p\n            return None\n\n    def _normalize(self, v):\n        n = self._dist((0.0,) * len(v), v)\n        if n <= 1e-12:\n            return v\n        return tuple(v[i] / n for i in range(len(v)))\n\n    def _cross(self, a, b):\n        return (a[1] * b[2] - a[2] * b[1],\n                a[2] * b[0] - a[0] * b[2],\n                a[0] * b[1] - a[1] * b[0])",
            "objective": -11.57164,
            "time_improvement": -22.0,
            "length_improvement": 22.0,
            "smoothness_improvement": 969.0,
            "node_improvement": 84.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03673973083496094,
                    "num_nodes_avg": 63.0,
                    "path_length_avg": 149.69172610370086,
                    "smoothness_avg": 0.038074679665983276,
                    "success_improvement": 0.0,
                    "time_improvement": -48.91692895846401,
                    "node_improvement": 84.1349785948124,
                    "length_improvement": 17.951592905369097,
                    "smoothness_improvement": 495.95141726288006,
                    "objective_score": -1.4243658580033447
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09294075965881347,
                    "num_nodes_avg": 200.0,
                    "path_length_avg": 225.57346551196792,
                    "smoothness_avg": 0.06931150246963083,
                    "success_improvement": 0.0,
                    "time_improvement": 44.43056632606514,
                    "node_improvement": 86.56184908956529,
                    "length_improvement": 24.69708443990187,
                    "smoothness_improvement": 1683.4348816009249,
                    "objective_score": 36.56459496976529
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08128533363342286,
                    "num_nodes_avg": 148.0,
                    "path_length_avg": 114.83076641207353,
                    "smoothness_avg": 0.06516345151492713,
                    "success_improvement": 0.0,
                    "time_improvement": -61.0352989187808,
                    "node_improvement": 81.18245390972663,
                    "length_improvement": 23.734872602597505,
                    "smoothness_improvement": 728.8742934042099,
                    "objective_score": -0.42529464705468767
                }
            ],
            "success_rate": 1.0
        },
        "objective": 12.399999999999999,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inexact nearest-neighbor retrieval and premature ring early-returns, yielding non-nearest attachments and detours.\n   - Overly coarse expansion (large step/spacing) and restrictive duplicate suppression or bucket caps that block useful alternative nodes near bends and narrow passages.\n   - Limited local optimization (no/weak rewiring; parent choice constrained to line-of-sight ancestors) resulting in poor cost refinement.\n   - Bridge formation decided mainly by proximity rather than accumulated path cost, creating longer merged paths.\n   - Post-processing that removes only obvious shortcuts, with insufficient upstream structure to expose shorter visibility links."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - More thorough bounded-nearest search over multiple rings to select better attachment points.\n   - Cost-aware parent selection among nearby neighbors with a smoothness tie-breaker.\n   - Targeted light rewiring around each new node to opportunistically lower subtree costs.\n   - Finer resolution (smaller step and grid cells) with moderated duplicate control and a per-cell cap that allows cheaper replacements.\n   - Short-range, assisted bridging with moderate connection radius to favor compact, low-cost joins.\n   - Cached collision checks enabling evaluation of more candidate parents/rewires within the same iteration budget.\n2. Expected mechanism of impact:\n   - Higher-quality parent choices and localized rewiring reduce incremental and accumulated path costs.\n   - Denser, better-placed vertices enable straighter corridors and tighter turns that shorten total path length.\n   - Cost-tolerant cell admission preserves beneficial alternatives, improving route selection through clutter.\n   - Preferential short bridges and subsequent visibility pruning/length-nonincreasing shortcuts remove redundant waypoints, yielding a shorter final path."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "SIBR-VI: Simple Informed BiRRT with Visibility Insertion. A compact, general-purpose bidirectional planner that grows two balanced trees with goal-biased sampling, grid-based near queries, and visibility-based parent choice. It commits only short, validated edges and uses a minimal single-step opposite-tree probe to connect, then performs lightweight LOS collapse, shortcutting, and corner rounding for smooth paths. The design avoids rewiring and wide scans to improve robustness, speed, and generalization.",
                "planning_mechanism": "Alternate extending start/goal trees with goal-biased uniform sampling. For each sample: find a nearby node via a coarse grid, steer one step, and choose the least-cost visible parent among local neighbors (including the steer source). Insert only after node and edge collision checks. Probe the opposite tree: try a direct bridge; else attempt one short, validated step toward the new node and recheck. On success, assemble and smooth the path; otherwise continue until early success or max iterations.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            i = 0\n            while i < len(self.parent.children):\n                if self.parent.children[i] is self:\n                    self.parent.children.pop(i)\n                    break\n                i += 1\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=6.0,\n                 goal_bias=0.3,\n                 cell_factor=1.8,\n                 neighbor_radius_factor=2.0,\n                 dupe_radius_ratio=0.35,\n                 edge_res=0.8,\n                 smooth_shortcuts=50,\n                 smooth_rounds=6):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.cell_factor = float(cell_factor)\n        self.nei_factor = float(neighbor_radius_factor)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.edge_res = float(edge_res)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.smooth_rounds = int(max(0, smooth_rounds))\n        self._rng = 246813579\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if not self._edge_blocked(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Derived params\n        self.cell = max(1.0, self.step * self.cell_factor)\n        self.nei_radius = max(1.5 * self.step, self.nei_factor * self.step)\n        self.dupe_radius = max(0.4, self.dupe_ratio * self.step)\n\n        nodes = []\n        edges = []\n\n        # Initialize two trees\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        A, B = [a_root], [b_root]\n        GA, GB = {}, {}\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n        frontierA, frontierB = [a_root], [b_root]\n\n        for it in range(self.max_iter):\n            growA = (it % 2 == 0)\n            T = A if growA else B\n            O = B if growA else A\n            G = GA if growA else GB\n            GO = GB if growA else GA\n            frontier = frontierA if growA else frontierB\n            frontierO = frontierB if growA else frontierA\n            attractor = self.goal if growA else self.start\n\n            target = self._sample_target(attractor)\n            if target is None:\n                continue\n\n            qnear = self._nearest(G, frontier, target, max_rings=2)\n            if qnear is None:\n                qnear = T[-1]\n\n            qnew_pos = self._steer(qnear.position, target, self.step)\n            if not self._in_bounds(qnew_pos):\n                continue\n            if self._point_blocked(qnew_pos):\n                continue\n            if self._has_close(G, qnew_pos, self.dupe_radius):\n                continue\n\n            parent = self._choose_parent(G, qnew_pos, qnear)\n            if parent is None:\n                continue\n            if self._edge_blocked(parent.position, qnew_pos):\n                continue\n\n            qnode = Node(qnew_pos, parent, parent.cost + self._dist(parent.position, qnew_pos))\n            qnode.attach(parent)\n            T.append(qnode)\n            nodes.append(qnode)\n            edges.append((parent, qnode))\n            self._grid_add(G, qnode)\n            frontier.append(qnode)\n            if len(frontier) > 160:\n                del frontier[:16]\n\n            # Try to connect to the opposite tree\n            other_near = self._nearest(GO, frontierO, qnode.position, max_rings=2)\n            if other_near is not None:\n                # Direct bridge\n                if not self._edge_blocked(qnode.position, other_near.position):\n                    path = self._assemble_path(qnode, other_near, growA)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # Single opposite-step probe (only commit if it completes a bridge)\n                step_p = self._steer(other_near.position, qnode.position, self.step)\n                if self._in_bounds(step_p) and (not self._point_blocked(step_p)):\n                    if not self._edge_blocked(other_near.position, step_p) and not self._edge_blocked(step_p, qnode.position):\n                        # commit the opposite node and connect\n                        qopp = Node(step_p, other_near, other_near.cost + self._dist(other_near.position, step_p))\n                        qopp.attach(other_near)\n                        O.append(qopp)\n                        nodes.append(qopp)\n                        edges.append((other_near, qopp))\n                        self._grid_add(GO, qopp)\n                        frontierO.append(qopp)\n                        if len(frontierO) > 160:\n                            del frontierO[:16]\n                        path = self._assemble_path(qnode, qopp, growA)\n                        path = self._postprocess(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) % (1 << 31)\n        return self._rng / float(1 << 31)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    # Collision\n    def _point_blocked(self, p):\n        if self.is3d:\n            x0, y0, z0 = p\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if x <= x0 <= x + w and y <= y0 <= y + h and z <= z0 <= z + d:\n                    return True\n            return False\n        else:\n            x0, y0 = p\n            for o in self.obstacles:\n                x, y, w, h = o\n                if x <= x0 <= x + w and y <= y0 <= y + h:\n                    return True\n            return False\n\n    def _edge_blocked(self, a, b):\n        d = self._dist(a, b)\n        steps = max(1, int(d / max(1e-9, self.edge_res)))\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dims))\n            if self._point_blocked(p):\n                return True\n        return False\n\n    # Grid utilities\n    def _cell_key(self, pos):\n        if self.is3d:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, frontier, pos, max_rings=2):\n        k = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring(grid, k, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bd:\n                        bd = d\n                        best = n\n                if best is not None:\n                    return best\n        if frontier:\n            lim = min(24, len(frontier))\n            for i in range(lim):\n                n = frontier[-1 - i]\n                d = self._dist(n.position, pos)\n                if d < bd:\n                    bd = d\n                    best = n\n        return best\n\n    def _nearby(self, grid, pos, radius, cap=20):\n        k = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell) + 1)\n        lst = self._grid_ring(grid, k, rc)\n        out = []\n        r2 = radius * radius\n        for n in lst:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_close(self, grid, pos, radius):\n        ns = self._nearby(grid, pos, radius, cap=8)\n        return len(ns) > 0\n\n    # Parent selection: least-cost visible parent among local neighbors (+default)\n    def _choose_parent(self, grid, new_pos, default_parent):\n        cand = self._nearby(grid, new_pos, self.nei_radius, cap=20)\n        if default_parent not in cand:\n            cand.append(default_parent)\n        best = None\n        bestc = 1e100\n        for p in cand:\n            d = self._dist(p.position, new_pos)\n            if d > 1.5 * self.step:\n                continue\n            if self._edge_blocked(p.position, new_pos):\n                continue\n            c = p.cost + d\n            if c < bestc:\n                bestc = c\n                best = p\n        return best\n\n    # Sampling\n    def _sample_target(self, attractor):\n        for _ in range(24):\n            if self._rand() < self.goal_bias:\n                p = attractor\n            else:\n                p = self._random_free()\n            if p is not None:\n                return p\n        return self._random_free()\n\n    def _random_free(self):\n        for _ in range(64):\n            if self.is3d:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if not self._point_blocked(p):\n                return p\n        return None\n\n    # Path assembly and utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble_path(self, a_end, b_end, a_side_grew):\n        if a_side_grew:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pa[0] == pb[-1]:\n                pb = pb[:-1]\n            return pa + pb[::-1]\n        else:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pb[0] == pa[-1]:\n                pa = pa[:-1]\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # Smoothing\n    def _los_collapse_once(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        while i < len(path) - 1:\n            nxt = path[i + 1]\n            if not self._edge_blocked(anchor, nxt):\n                i += 1\n                continue\n            out.append(path[i])\n            anchor = path[i]\n            i += 1\n        out.append(path[-1])\n        return out\n\n    def _los_collapse_repeat(self, path, rounds=3):\n        cur = path[:]\n        for _ in range(rounds):\n            nxt = self._los_collapse_once(cur)\n            if len(nxt) == len(cur):\n                break\n            cur = nxt\n        return cur\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        best_len = self._path_len(pts)\n        tries = 0\n        n = len(pts)\n        while tries < attempts and len(pts) >= 3:\n            if len(pts) != n:\n                n = len(pts)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j >= n:\n                tries += 1\n                continue\n            a, b = pts[i], pts[j]\n            if not self._edge_blocked(a, b):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best_len + 1e-12:\n                    pts = cand\n                    best_len = L\n                    n = len(pts)\n            tries += 1\n        return pts\n\n    def _round_corners(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dims))\n                if not self._in_bounds(mid):\n                    continue\n                if self._point_blocked(mid):\n                    continue\n                if not self._edge_blocked(a, mid) and not self._edge_blocked(mid, c):\n                    if pts[i] != mid:\n                        pts[i] = mid\n                        moved = True\n            if not moved:\n                break\n        return pts\n\n    def _postprocess(self, path):\n        if len(path) < 3:\n            return path[:]\n        p = self._los_collapse_repeat(path, rounds=3)\n        p = self._shortcut(p, self.smooth_shortcuts)\n        p = self._round_corners(p, self.smooth_rounds)\n        return p",
                "objective": -31.86222,
                "time_improvement": 45.0,
                "length_improvement": 16.0,
                "smoothness_improvement": 1790.0,
                "node_improvement": 83.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.02052297592163086,
                        "num_nodes_avg": 70.5,
                        "path_length_avg": 165.63949397483105,
                        "smoothness_avg": 0.049746840403639886,
                        "success_improvement": 0.0,
                        "time_improvement": 16.814345726520084,
                        "node_improvement": 82.2462855703853,
                        "length_improvement": 9.210368626649155,
                        "smoothness_improvement": 678.6460793099327,
                        "objective_score": 13.96375529049518
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03236165046691895,
                        "num_nodes_avg": 152.8,
                        "path_length_avg": 238.58207310980575,
                        "smoothness_avg": 0.11234809730455246,
                        "success_improvement": 0.0,
                        "time_improvement": 80.65091574673843,
                        "node_improvement": 89.73325270442787,
                        "length_improvement": 20.35443679173485,
                        "smoothness_improvement": 2790.7974647097694,
                        "objective_score": 50.361924122611285
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.03200056552886963,
                        "num_nodes_avg": 169.6,
                        "path_length_avg": 123.51393483095144,
                        "smoothness_avg": 0.15722144556069123,
                        "success_improvement": 0.0,
                        "time_improvement": 36.603315688518556,
                        "node_improvement": 78.43610934520025,
                        "length_improvement": 17.96792558682632,
                        "smoothness_improvement": 1899.845182652034,
                        "objective_score": 31.260975971911527
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m1",
                "algorithm_description": "VINE-STAR: Visibility-Indexed Near-Optimal Elastic BiConnect. A bidirectional planner that fuses local RRT* optimization with single-commit elastic reconnects and a visibility-aware bridge. It maintains obstacle bins and a direction-aware edge cache, performs best-parent insertion with bounded rewiring, then tries a two-phase bridge (direct LOS, else lazy one-step commit on the opposite tree). It updates an incumbent and applies multi-pass visibility compression, shortcutting, and safe corner rounding for smooth, short paths.",
                "planning_mechanism": "Alternate expanding start/goal trees. Each cycle: informed sample (goal/corridor \u2192 ellipse after incumbent), multi-ring hash-grid nearest set, steer one step, validate node and edge, choose cheapest parent and rewire neighbors. Attempt visibility bridge to the other tree\u2019s nearest; if blocked, lazily add only the farthest valid single node toward the meet and retry. Maintain an edge cache keyed by quantized endpoints+midpoint to cut repeated collision tests. On connection, extract and refine the path, then return.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=6500,\n                 step_size=6.0,\n                 goal_bias=0.25,\n                 corridor_bias=0.35,\n                 ellipse_bias=0.55,\n                 grid_cell_factor=1.6,\n                 neighbor_radius_factor=2.2,\n                 min_sep_ratio=0.35,\n                 k_parent=6,\n                 k_rewire=6,\n                 connect_hops=2,\n                 smoothing_attempts=120):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.ellipse_bias = float(ellipse_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neigh_factor = float(neighbor_radius_factor)\n        self.min_sep_ratio = float(min_sep_ratio)\n        self.k_parent = int(max(1, k_parent))\n        self.k_rewire = int(max(0, k_rewire))\n        self.connect_hops = int(max(1, connect_hops))\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        # runtime\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self._is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        # Parameterize spatial structures\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.neigh_radius = max(self.step * 1.2, self.step * self.neigh_factor)\n        self.min_sep = max(0.5, self.step * self.min_sep_ratio)\n        self.cache_bin = max(0.75, self.step * 0.5)\n\n        # Seed RNG\n        self._seed()\n\n        # Bounds check\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Build obstacle index\n        self._build_bins()\n\n        # Validate start/goal collision-free\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight-line\n        self._free_cache = set()\n        self._blocked_cache = set()\n        if self._edge_free_cached(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._refine_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize two trees and grids\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [root_a], [root_b]\n        nodes.extend([root_a, root_b])\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, root_a)\n        self._grid_add(grid_b, root_b)\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            forward = (it % 2 == 0)\n            Ta = tree_a if forward else tree_b\n            Tb = tree_b if forward else tree_a\n            Ga = grid_a if forward else grid_b\n            Gb = grid_b if forward else grid_a\n            other_root = self.goal if forward else self.start\n\n            # Guided sampling (ellipse after incumbent)\n            sp = self._guided_sample(other_root, best_len)\n            if sp is None:\n                continue\n\n            # Nearest anchors\n            anchor = self._nearest_multi(Ga, sp)\n            if anchor is None:\n                anchor = Ta[-1]\n\n            # Steer\n            newp = self._steer(anchor.position, sp, self.step)\n            if (not self._in_bounds(newp)) or self._point_blocked(newp):\n                continue\n            if self._too_close(Ga, newp, self.min_sep):\n                continue\n            if not self._edge_free_cached(anchor.position, newp):\n                continue\n\n            # Best-parent among neighbors\n            neigh = self._neighbors(Ga, newp, self.neigh_radius)\n            if not neigh:\n                neigh = [anchor]\n            neigh = sorted(neigh, key=lambda n: self._dist2(n.position, newp))[:self.k_parent]\n            parent = anchor\n            bestc = anchor.cost + self._dist(anchor.position, newp)\n            for nb in neigh:\n                gc = nb.cost + self._dist(nb.position, newp)\n                if gc + 1e-12 < bestc and self._edge_free_cached(nb.position, newp):\n                    parent = nb\n                    bestc = gc\n\n            # Final checks before insertion (both checks enforced)\n            if self._point_blocked(newp) or (not self._edge_free_cached(parent.position, newp)):\n                continue\n\n            nn = Node(newp, parent, bestc)\n            parent.add_child(nn)\n            Ta.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(Ga, nn)\n\n            # Local rewiring (bounded)\n            if self.k_rewire > 0:\n                self._rewire_bound(nn, Ga, edges)\n\n            # Visibility-aware bridge to the opposite tree\n            near_b = self._nearest_multi(Gb, nn.position)\n            if near_b is not None:\n                # Phase 1: direct LOS\n                if self._edge_free_cached(nn.position, near_b.position):\n                    path = self._extract(nn, near_b)\n                    L = self._path_len(path)\n                    best_len = L if best_len is None or L < best_len else best_len\n                    path = self._refine_path(path)\n                    return PlannerResult(True, path, tree_a + tree_b, edges)\n                # Phase 2: elastic single-commit on opposite tree\n                q = self._elastic_single_commit(Tb, Gb, near_b, nn.position, edges)\n                if q is not None:\n                    if self._edge_free_cached(nn.position, q.position):\n                        path = self._extract(nn, q)\n                        L = self._path_len(path)\n                        best_len = L if best_len is None or L < best_len else best_len\n                        path = self._refine_path(path)\n                        return PlannerResult(True, path, tree_a + tree_b, edges)\n                    # Optional: one symmetric commit from Ta toward near_b\n                    p2 = self._elastic_single_commit(Ta, Ga, nn, near_b.position, edges)\n                    if p2 is not None:\n                        if self._edge_free_cached(p2.position, q.position):\n                            path = self._extract(p2, q)\n                            L = self._path_len(path)\n                            best_len = L if best_len is None or L < best_len else best_len\n                            path = self._refine_path(path)\n                            return PlannerResult(True, path, tree_a + tree_b, edges)\n\n        return PlannerResult(False, [], tree_a + tree_b, edges)\n\n    # -------- RNG --------\n    def _seed(self):\n        s = 0\n        for v in self.start + self.goal:\n            s ^= (int(v * 2654435761) & 0xffffffff)\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= len(self.obstacles) * 374761393\n        if s == 0:\n            s = 2463534242\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        # Xorshift32\n        x = self._rng & 0xffffffff\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # -------- Geometry --------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # -------- Node grid --------\n    def _key(self, p):\n        if self._is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        cand = []\n        if self._is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            cand.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        cand.extend(lst)\n        return cand\n\n    def _nearest_multi(self, grid, pos):\n        key = self._key(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, 5):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bd:\n                        bd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # fallback scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bd:\n                    bd = d2\n                    best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius):\n        key = self._key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self._is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors(grid, pos, radius)) > 0\n\n    # -------- Obstacles: bins and collisions --------\n    def _build_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self._obin = {}\n        if self._is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self._obin.get(key)\n                            if b is None:\n                                self._obin[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self._obin.get(key)\n                        if b is None:\n                            self._obin[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_bucket(self, p):\n        if self._is3:\n            return self._obin.get((int(p[0] // self.obs_cell), int(p[1] // self.obs_cell), int(p[2] // self.obs_cell)))\n        else:\n            return self._obin.get((int(p[0] // self.obs_cell), int(p[1] // self.obs_cell)))\n\n    def _point_blocked(self, p):\n        bucket = self._point_bucket(p)\n        if not bucket:\n            return False\n        if self._is3:\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _edge_free_cached(self, a, b):\n        key = self._edge_key(a, b)\n        if key in self._blocked_cache:\n            return False\n        if key in self._free_cache:\n            return True\n        ok = self._edge_free(a, b)\n        if ok:\n            self._free_cache.add(key)\n            return True\n        else:\n            self._blocked_cache.add(key)\n            return False\n\n    def _edge_key(self, a, b):\n        # quantize endpoints and midpoint to reduce alias errors\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        mid = tuple((a[i] + b[i]) * 0.5 for i in range(self.dim))\n        qm = tuple(int(mid[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb, qm)\n        else:\n            return (qb, qa, qm)\n\n    def _edge_free(self, a, b):\n        # candidate obstacles by segment bbox\n        if self._is3:\n            mn = (min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            iz0 = int(max(0.0, mn[2]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self._obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            mn = (min(a[0], b[0]), min(a[1], b[1]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self._obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    # -------- Rewiring --------\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _erase_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                del edges[i]\n                break\n\n    def _propagate_cost(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire_bound(self, new_node, grid, edges):\n        neigh = self._neighbors(grid, new_node.position, self.neigh_radius)\n        if not neigh:\n            return\n        neigh = sorted(neigh, key=lambda n: self._dist2(n.position, new_node.position))[:self.k_rewire]\n        for nb in neigh:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            if self._is_ancestor(nb, new_node):\n                continue\n            if not self._edge_free_cached(new_node.position, nb.position):\n                continue\n            cand = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._erase_edge(edges, oldp, nb)\n                new_node.add_child(nb)\n                edges.append((new_node, nb))\n                delta = cand - nb.cost\n                nb.cost = cand\n                self._propagate_cost(nb, delta)\n\n    # -------- Elastic single-commit toward target --------\n    def _elastic_single_commit(self, tree, grid, nearest, target, edges):\n        curp = nearest.position\n        last_ok = None\n        moved = False\n        steps = 0\n        while steps < self.connect_hops:\n            nxt = self._steer(curp, target, self.step)\n            if not self._in_bounds(nxt):\n                break\n            if self._point_blocked(nxt):\n                break\n            if self._too_close(grid, nxt, self.min_sep):\n                break\n            if not self._edge_free_cached(curp, nxt):\n                break\n            last_ok = nxt\n            curp = nxt\n            moved = True\n            steps += 1\n        if moved and last_ok is not None:\n            # Enforce both checks before adding\n            if self._point_blocked(last_ok):\n                return None\n            if not self._edge_free_cached(nearest.position, last_ok):\n                return None\n            q = Node(last_ok, nearest, nearest.cost + self._dist(nearest.position, last_ok))\n            nearest.add_child(q)\n            tree.append(q)\n            edges.append((nearest, q))\n            self._grid_add(grid, q)\n            return q\n        return None\n\n    # -------- Sampling --------\n    def _guided_sample(self, target_root, incumbent_len):\n        tries = 24\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            if incumbent_len is not None and r < self.ellipse_bias:\n                p = self._sample_ellipse(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    p = target_root\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_point()\n                else:\n                    if self._is3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._point_blocked(p):\n                return p\n        return None\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.08 * sg)\n        if self._is3:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w),\n                                base[2] + self._rand_range(-w, w)))\n        else:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w)))\n\n    def _sample_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(18):\n            if self._is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and not self._point_blocked(p):\n                return p\n        return None\n\n    # -------- Paths and smoothing --------\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract(self, meet_a, meet_b):\n        path_a = self._trace_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _vis_collapse(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = pts[:]\n        i = 0\n        while i < len(out) - 2:\n            j = len(out) - 1\n            collapsed = False\n            while j > i + 1:\n                if self._edge_free_cached(out[i], out[j]):\n                    del out[i + 1:j]\n                    collapsed = True\n                    break\n                j -= 1\n            if not collapsed:\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        stall = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 1, len(cur) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free_cached(cur[i], cur[j]):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-9 <= bestL:\n                    cur = cand\n                    bestL = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            tries += 1\n            if stall > 28:\n                break\n        return cur\n\n    def _round_corners(self, pts, passes=2):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            i = 1\n            while i < len(cur) - 1:\n                a = cur[i - 1]\n                c = cur[i + 1]\n                mid = tuple(0.5 * (a[j] + c[j]) for j in range(self.dim))\n                if self._in_bounds(mid) and (not self._point_blocked(mid)):\n                    if self._edge_free_cached(a, mid) and self._edge_free_cached(mid, c):\n                        cur[i] = mid\n                i += 1\n        return cur\n\n    def _refine_path(self, path):\n        p = self._vis_collapse(path)\n        p = self._shortcut(p, self.smoothing_attempts)\n        p = self._round_corners(p, passes=2)\n        return p",
                "objective": 2.62913,
                "time_improvement": -62.0,
                "length_improvement": 16.0,
                "smoothness_improvement": 1234.0,
                "node_improvement": 67.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.021719908714294432,
                        "num_nodes_avg": 66.0,
                        "path_length_avg": 168.9347845564268,
                        "smoothness_avg": 0.04471187024706912,
                        "success_improvement": 0.0,
                        "time_improvement": 11.962825271625425,
                        "node_improvement": 83.37950138504155,
                        "length_improvement": 7.404167641655733,
                        "smoothness_improvement": 599.8378627469067,
                        "objective_score": 11.0305374802156
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03963837623596191,
                        "num_nodes_avg": 171.0,
                        "path_length_avg": 243.761428109213,
                        "smoothness_avg": 0.08824115162490134,
                        "success_improvement": 0.0,
                        "time_improvement": 76.30014939330353,
                        "node_improvement": 88.5103809715783,
                        "length_improvement": 18.625419013464985,
                        "smoothness_improvement": 2170.5083888412123,
                        "objective_score": 44.917838170276106
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.18881816864013673,
                        "num_nodes_avg": 562.0,
                        "path_length_avg": 116.12988453990367,
                        "smoothness_avg": 0.08116327983256823,
                        "success_improvement": 0.0,
                        "time_improvement": -274.0698213208625,
                        "node_improvement": 28.544183089637638,
                        "length_improvement": 22.872060199450264,
                        "smoothness_improvement": 932.3909286201255,
                        "objective_score": -63.83575563348796
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "IBEX-Lite: Informed BiRRT* with Elastic Micro-Connect. It blends fast bidirectional growth, visibility-based best-parent insertion with light rewiring, obstacle-binned collision checks, and a commit-only micro-bridge to connect trees. After connection it runs multi-pass visibility compression, shortcutting, and safe corner rounding. The design targets high success, short and smooth paths with low planning time.",
            "planning_mechanism": "Alternate growing the two trees (balanced), sampling via goal/corridor-biased free points. For each sample: pick a nearby anchor with a hash grid, steer one step, and select the least-cost visible parent among local neighbors with a small turn-angle penalty; insert only after node and edge checks, then lightly rewire neighbors. Probe the opposite tree: first try direct LOS; else simulate a few greedy steps; if a connector exists, commit the whole micro-bridge and return the assembled, smoothed path.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            # detach from old parent\n            i = 0\n            while i < len(self.parent.children):\n                if self.parent.children[i] is self:\n                    self.parent.children.pop(i)\n                    break\n                i += 1\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=6.0,\n                 goal_bias=0.3,\n                 corridor_bias=0.25,\n                 grid_cell_factor=1.8,\n                 neighbor_radius_factor=2.2,\n                 dupe_radius_ratio=0.3,\n                 k_rewire=4,\n                 connect_hops=3,\n                 edge_res=0.8,\n                 smooth_shortcuts=80,\n                 smooth_rounds=6):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.cell_factor = float(grid_cell_factor)\n        self.nei_factor = float(neighbor_radius_factor)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.k_rewire = int(max(0, k_rewire))\n        self.connect_hops = int(max(1, connect_hops))\n        self.edge_res = float(edge_res)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.smooth_rounds = int(max(0, smooth_rounds))\n        self._rng = 123456789\n\n    def plan(self, map):\n        # Setup\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", [])) if getattr(map, \"obstacles\", None) is not None else []\n\n        self._seed_rng()\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], [], [])\n        # Build obstacle bins before collision tests\n        self._build_obs_bins()\n\n        # Validate endpoints\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        nodes = []\n        edges = []\n\n        # Early straight-line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Derived spatial params\n        self.cell = max(1.0, self.step * self.cell_factor)\n        self.nei_radius = max(1.5 * self.step, self.step * self.nei_factor)\n        self.dupe_radius = max(0.35, self.step * self.dupe_ratio)\n\n        # Initialize two trees and grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        A, B = [a_root], [b_root]\n        nodes.extend([a_root, b_root])\n        GA, GB = {}, {}\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n        frontierA, frontierB = [a_root], [b_root]\n\n        for it in range(self.max_iter):\n            # Balanced alternating\n            if it % 3 == 2:\n                growA = (len(A) <= len(B))\n            else:\n                growA = (it % 2 == 0)\n\n            T = A if growA else B\n            O = B if growA else A\n            G = GA if growA else GB\n            GO = GB if growA else GA\n            frontier = frontierA if growA else frontierB\n            frontierO = frontierB if growA else frontierA\n            attract = self.goal if growA else self.start\n\n            target = self._sample_target(attract)\n            if target is None:\n                continue\n\n            # nearest anchor\n            qnear = self._nearest(G, frontier, target, max_rings=2)\n            if qnear is None:\n                qnear = T[-1]\n\n            qnew_pos = self._steer(qnear.position, target, self.step)\n            if (not self._in_bounds(qnew_pos)) or self._point_blocked(qnew_pos):\n                continue\n            if self._has_close(G, qnew_pos, self.dupe_radius):\n                continue\n\n            parent, bestc = self._choose_parent(G, qnew_pos, qnear)\n            if parent is None:\n                continue\n\n            # Both checks before insertion\n            if self._point_blocked(qnew_pos):\n                continue\n            if not self._edge_free(parent.position, qnew_pos):\n                continue\n\n            qnode = Node(qnew_pos, parent, bestc)\n            qnode.attach(parent)\n            T.append(qnode)\n            nodes.append(qnode)\n            edges.append((parent, qnode))\n            self._grid_add(G, qnode)\n            frontier.append(qnode)\n            if len(frontier) > 160:\n                del frontier[:16]\n\n            # Local light rewiring\n            if self.k_rewire > 0:\n                self._rewire_local(qnode, G, edges, k=self.k_rewire)\n\n            # Try to connect to opposite tree\n            other_near = self._nearest(GO, frontierO, qnode.position, max_rings=2)\n            if other_near is not None:\n                # Direct bridge\n                if self._edge_free(qnode.position, other_near.position):\n                    path = self._assemble_path(qnode, other_near, growA)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # Elastic micro-bridge (commit only if it completes)\n                qlast = self._micro_bridge(O, GO, other_near, qnode.position)\n                if qlast is not None and self._edge_free(qnode.position, qlast.position):\n                    path = self._assemble_path(qnode, qlast, growA)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s ^= (int(v * 2654435761) & 0xffffffff)\n            s = (s * 1664525 + 1013904223) & 0xffffffff\n        s ^= len(self.obstacles) * 374761393\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        # xorshift32\n        x = self._rng & 0xffffffff\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Obstacle bins and collisions\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self._obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self._obin.get(key)\n                            if lst is None:\n                                self._obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self._obin.get(key)\n                        if lst is None:\n                            self._obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_bucket(self, p):\n        if self.is3:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell),\n                                   int(p[2] // self.obs_cell)))\n        else:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell)))\n\n    def _point_blocked(self, p):\n        bucket = self._point_bucket(p)\n        if not bucket:\n            return False\n        if self.is3:\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _seg_box_intersect(self, a, b, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(self.dim):\n            p = a[i]\n            d = b[i] - a[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        # Quickly reject with obstacle bin candidate list based on segment bbox coverage\n        if self.is3:\n            mn = (min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            iz0 = int(max(0.0, mn[2]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self._obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            mn = (min(a[0], b[0]), min(a[1], b[1]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self._obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    # Grid utilities\n    def _cell_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, frontier, pos, max_rings=2):\n        kk = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring(grid, kk, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bd:\n                        bd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # fallback to recent frontier\n        if frontier:\n            lim = min(24, len(frontier))\n            for i in range(lim):\n                n = frontier[-1 - i]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bd:\n                    bd = d2\n                    best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap=20):\n        kk = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((kk[0] + dx, kk[1] + dy, kk[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((kk[0] + dx, kk[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _has_close(self, grid, pos, radius):\n        ns = self._neighbors(grid, pos, radius, cap=6)\n        return len(ns) > 0\n\n    # Parent selection with small turn penalty\n    def _choose_parent(self, grid, new_pos, fallback):\n        cand = self._neighbors(grid, new_pos, self.nei_radius, cap=24)\n        if fallback not in cand:\n            cand.append(fallback)\n        best = None\n        best_cost = 1e100\n        for p in cand:\n            d = self._dist(p.position, new_pos)\n            if d > 1.6 * self.step:\n                continue\n            if not self._edge_free(p.position, new_pos):\n                continue\n            c = p.cost + d\n            # Turn penalty: prefer smoother joins\n            if p.parent is not None:\n                u = tuple(p.position[i] - p.parent.position[i] for i in range(self.dim))\n                v = tuple(new_pos[i] - p.position[i] for i in range(self.dim))\n                nu = max(1e-12, self._dist((0.0,) * self.dim, u))\n                nv = max(1e-12, self._dist((0.0,) * self.dim, v))\n                dot = 0.0\n                for i in range(self.dim):\n                    dot += u[i] * v[i]\n                cosang = max(-1.0, min(1.0, dot / (nu * nv)))\n                # angle in [0, pi]; penalty scaled by step\n                ang = (1.0 - cosang)  # cheaper than acos, monotonic\n                c += 0.08 * self.step * ang\n            if c < best_cost:\n                best_cost = c\n                best = p\n        return best, best_cost\n\n    # Light rewiring around a new node\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                edges.pop(i)\n                return\n\n    def _propagate_delta(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire_local(self, new_node, grid, edges, k=4):\n        neigh = self._neighbors(grid, new_node.position, self.nei_radius, cap=32)\n        if not neigh:\n            return\n        # Prefer closest neighbors\n        neigh.sort(key=lambda n: self._dist2(n.position, new_node.position))\n        count = 0\n        for nb in neigh:\n            if count >= k:\n                break\n            if nb is new_node or nb is new_node.parent:\n                continue\n            if self._is_ancestor(nb, new_node):\n                continue\n            # Both checks before adding new edge\n            if self._point_blocked(nb.position):\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand_cost + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    # detach from old parent\n                    i = 0\n                    while i < len(oldp.children):\n                        if oldp.children[i] is nb:\n                            oldp.children.pop(i)\n                            break\n                        i += 1\n                    self._remove_edge(edges, oldp, nb)\n                nb.attach(new_node)\n                edges.append((new_node, nb))\n                delta = cand_cost - nb.cost\n                nb.cost = cand_cost\n                self._propagate_delta(nb, delta)\n                count += 1\n\n    # Micro-bridge: simulate a few steps on opposite tree, commit only if connection completes\n    def _micro_bridge(self, tree, grid, near_node, target_pos):\n        cur = near_node.position\n        chain = []\n        success = False\n        last = None\n        for _ in range(self.connect_hops):\n            nxt = self._steer(cur, target_pos, self.step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                break\n            if self._has_close(grid, nxt, self.dupe_radius * 0.7):\n                break\n            if not self._edge_free(cur, nxt):\n                break\n            chain.append(nxt)\n            cur = nxt\n            # if we can close the final link to target, mark success\n            if self._edge_free(cur, target_pos):\n                success = True\n                last = cur\n                break\n        if not success or last is None:\n            return None\n        # Commit the chain to the opposite tree with both checks on each segment\n        prev = near_node\n        for p in chain:\n            if self._point_blocked(p):\n                return None\n            if not self._edge_free(prev.position, p):\n                return None\n            nn = Node(p, prev, prev.cost + self._dist(prev.position, p))\n            nn.attach(prev)\n            tree.append(nn)\n            self._grid_add(grid, nn)\n            prev = nn\n        return prev\n\n    # Sampling\n    def _sample_target(self, attract):\n        for _ in range(28):\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attract\n            elif r < self.goal_bias + self.corridor_bias:\n                p = self._corridor_point()\n            else:\n                if self.is3:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        return None\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.08 * sg)\n        if self.is3:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w),\n                                base[2] + self._rand_range(-w, w)))\n        else:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w)))\n\n    # Path assembly and utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble_path(self, a_end, b_end, a_side_grew):\n        if a_side_grew:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pa[0] == pb[-1]:\n                pb = pb[:-1]\n            return pa + pb[::-1]\n        else:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pb[0] == pa[-1]:\n                pa = pa[:-1]\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # Smoothing\n    def _vis_collapse(self, pts, passes=2):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            i = 0\n            changed = False\n            while i < len(cur) - 2:\n                j = len(cur) - 1\n                while j > i + 1:\n                    if self._edge_free(cur[i], cur[j]):\n                        if j > i + 1:\n                            del cur[i + 1:j]\n                            changed = True\n                        break\n                    j -= 1\n                i += 1\n            if not changed:\n                break\n        return cur\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            n = len(cur)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n - 1:\n                tries += 1\n                continue\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-12 <= bestL:\n                    cur = cand\n                    bestL = L\n            tries += 1\n        return cur\n\n    def _round_corners(self, pts, passes):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if (not self._in_bounds(mid)) or self._point_blocked(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if cur[i] != mid:\n                        cur[i] = mid\n                        moved = True\n            if not moved:\n                break\n        return cur\n\n    def _postprocess(self, path):\n        if len(path) < 3:\n            return path[:]\n        p = self._vis_collapse(path, passes=2)\n        p = self._shortcut(p, self.smooth_shortcuts)\n        p = self._round_corners(p, self.smooth_rounds)\n        return p",
            "objective": -37.68839,
            "time_improvement": 61.0,
            "length_improvement": 21.0,
            "smoothness_improvement": 1336.0,
            "node_improvement": 87.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011586189270019531,
                    "num_nodes_avg": 61.0,
                    "path_length_avg": 150.2550697876198,
                    "smoothness_avg": 0.041941448754662616,
                    "success_improvement": 0.0,
                    "time_improvement": 53.03776905243485,
                    "node_improvement": 84.63863006799295,
                    "length_improvement": 17.64281530546121,
                    "smoothness_improvement": 556.4747503241836,
                    "objective_score": 29.279393650628094
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03080716133117676,
                    "num_nodes_avg": 131.0,
                    "path_length_avg": 228.48646410685174,
                    "smoothness_avg": 0.08768701591384163,
                    "success_improvement": 0.0,
                    "time_improvement": 81.58034736794089,
                    "node_improvement": 91.19801115366526,
                    "length_improvement": 23.72464166291407,
                    "smoothness_improvement": 2156.250077867826,
                    "objective_score": 49.490139597469835
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026394367218017578,
                    "num_nodes_avg": 112.0,
                    "path_length_avg": 116.65576078031737,
                    "smoothness_avg": 0.10957624060714707,
                    "success_improvement": 0.0,
                    "time_improvement": 47.70981892140697,
                    "node_improvement": 85.75969485060394,
                    "length_improvement": 22.5227982401031,
                    "smoothness_improvement": 1293.8016924461601,
                    "objective_score": 34.29563308271475
                }
            ],
            "success_rate": 1.0
        },
        "objective": 10.6,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Limited or absent rewiring kept suboptimal parent choices and accumulated zig-zag costs.\n   - Parent selection focused on proximity without smoothness consideration, yielding longer, kinked routes.\n   - Connection strategies used short or single-step probes, meeting trees at detoured junctions.\n   - Sampling either too random or over-biased into blocked corridors, missing the shortest viable channel.\n   - Aggressive duplicate/min-separation pruning blocked local densification near turns, preventing tighter routes.\n   - Collision checks were either slow point-marching or cache-prone, discouraging or rejecting long, direct LOS edges.\n   - Post-processing relied on few LOS/shortcut attempts and coarse rounding, leaving avoidable bends and extra waypoints."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Bounded local rewiring around each new node.\n   - Visibility-aware parent choice with a small turn-angle penalty.\n   - Multi-step, commit-only micro-bridge on the opposite tree.\n   - Corridor-biased sampling with balanced bidirectional growth.\n   - Obstacle-binned edge testing enabling fast, longer LOS checks.\n   - Stronger visibility collapse and increased shortcutting; moderated duplicate threshold.\n2. Expected mechanism of impact:\n   - Rewiring re-parents nearby nodes onto cheaper routes, lowering accumulated path cost.\n   - Angle-aware parent selection favors straighter continuations, reducing polyline length and kinks.\n   - Micro-bridge connects at more direct meet points, avoiding detour-heavy junctions.\n   - Guided sampling steers growth through the shortest feasible corridor, increasing long LOS connections.\n   - Faster edge validation encourages and accepts longer valid segments, producing more direct paths.\n   - Enhanced post-processing removes redundant vertices and shortcuts bends; allowing some densification near obstacles enables tighter, shorter turns."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "BiCon-Lite*: Simplified Bi-directional RRT-Connect with local best-parent and light rewiring. It grows two trees from start and goal using uniform sampling with small goal bias and informed sampling once a path bound is known. Each added node is chosen from a few nearest candidates by lowest path cost if the edge is collision-free; after insertion, nearby nodes can be rewired if cheaper. Trees greedily connect toward each other; upon connection, the path is visibility-pruned and shortcut for length and smoothness.",
                "planning_mechanism": "Alternate expanding start/goal trees. For each iteration: sample a target (uniform, goal-biased, or informed ellipse), steer one step from the nearest node, reject if outside/duplicate/colliding, then pick a best feasible parent among k-nearest to insert. Lightly rewire nearby neighbors if the new route is cheaper (cycle-safe). Attempt a greedy connect from the opposite tree toward the new node by incremental steps; if it reaches within one step and the final edge is free, extract the full path (start-to-A, cross-edge, B-to-goal), then prune and shortcut. Always check node and edge collisions before adding any node or edge.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n\n    def attach(self, new_parent):\n        if new_parent is self.parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            if self not in new_parent.children:\n                new_parent.children.append(self)\n\n    def is_ancestor_of(self, other):\n        cur = other\n        while cur is not None:\n            if cur is self:\n                return True\n            cur = cur.parent\n        return False\n\n    def propagate_cost(self, delta):\n        if delta == 0.0:\n            return\n        self.cost += delta\n        for c in self.children:\n            c.propagate_cost(delta)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=10.0,\n        goal_bias=0.1,\n        informed_bias=0.5,\n        dupe_radius_ratio=0.5,\n        neighbor_radius_factor=2.5,\n        k_near=5,\n        shortcut_attempts=80\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.neighbor_radius_factor = float(neighbor_radius_factor)\n        self.k_near = int(k_near)\n        self.shortcut_attempts = int(shortcut_attempts)\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacle(self.start) or self._point_in_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._seed_rng()\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.neighbor_radius = max(self.step_size * 1.5, self.step_size * self.neighbor_radius_factor)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            edges = [(n0, n1)]\n            return PlannerResult(True, self._finalize_path([self.start, self.goal]), [n0, n1], edges)\n\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        A = [a_root]\n        B = [b_root]\n\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            grow_A = (it % 2 == 0)\n            T = A if grow_A else B\n            O = B if grow_A else A\n            attractor = self.goal if grow_A else self.start\n\n            qrand = self._sample(attractor, best_len)\n            if qrand is None:\n                continue\n\n            qnear = self._nearest_in(T, qrand)\n            if qnear is None:\n                continue\n\n            qnew_pos = self._steer(qnear.position, qrand)\n            if not self._in_bounds(qnew_pos):\n                continue\n            if self._point_in_obstacle(qnew_pos):\n                continue\n            if self._has_near_in(T, qnew_pos, self.dupe_radius):\n                continue\n\n            parent = self._best_parent(T, qnew_pos, qnear)\n            if parent is None:\n                continue\n            if not self._edge_free(parent.position, qnew_pos):\n                continue\n\n            qnew_cost = parent.cost + self._dist(parent.position, qnew_pos)\n            qnew = Node(qnew_pos, parent, qnew_cost)\n            T.append(qnew)\n            nodes.append(qnew)\n            edges.append((parent, qnew))\n\n            self._light_rewire(T, qnew, edges)\n\n            ok, last_other, added = self._connect_toward(O, qnew.position, nodes, edges)\n            if ok and last_other is not None:\n                edges.append((last_other, qnew))\n                path = self._extract_path(qnew, last_other)\n                best_len = self._path_len(path)\n                return PlannerResult(True, self._finalize_path(path), nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0xA5A5A5A5\n        for v in self.start + self.goal:\n            s ^= (int(v * 1315423911) + (s << 7) + (s >> 3)) & 0xffffffff\n            s &= 0xffffffff\n        s ^= (len(self.obstacles) * 0x9E3779B9) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            tgt = a\n        elif d <= self.step_size:\n            tgt = b\n        else:\n            r = self.step_size / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n        out = tuple(max(0.0, min(tgt[i], self.bounds[i])) for i in range(self.dims))\n        return out\n\n    # Nearest and neighbors\n    def _nearest_in(self, nodes_list, pos):\n        best = None\n        bd = 1e100\n        for n in nodes_list:\n            d = self._dist(n.position, pos)\n            if d < bd:\n                bd = d\n                best = n\n        return best\n\n    def _k_nearest_in(self, nodes_list, pos, k):\n        if not nodes_list:\n            return []\n        pairs = []\n        for n in nodes_list:\n            pairs.append((self._dist(n.position, pos), n))\n        pairs.sort(key=lambda x: x[0])\n        out = [n for _, n in pairs[:max(1, k)]]\n        return out\n\n    def _neighbors_radius(self, nodes_list, pos, radius):\n        out = []\n        r = float(radius)\n        for n in nodes_list:\n            if self._dist(n.position, pos) <= r:\n                out.append(n)\n        return out\n\n    def _has_near_in(self, nodes_list, pos, radius):\n        r = float(radius)\n        for n in nodes_list:\n            if self._dist(n.position, pos) <= r:\n                return True\n        return False\n\n    # Parent selection\n    def _best_parent(self, nodes_list, qpos, fallback):\n        cands = self._k_nearest_in(nodes_list, qpos, self.k_near)\n        if fallback not in cands:\n            cands.append(fallback)\n        best = None\n        best_cost = 1e100\n        for p in cands:\n            if not self._edge_free(p.position, qpos):\n                continue\n            c = p.cost + self._dist(p.position, qpos)\n            if c < best_cost:\n                best_cost = c\n                best = p\n        return best\n\n    # Light rewiring\n    def _light_rewire(self, nodes_list, qnew, edges):\n        nbrs = self._neighbors_radius(nodes_list, qnew.position, self.neighbor_radius)\n        rewired = 0\n        for w in nbrs:\n            if w is qnew or w is qnew.parent:\n                continue\n            if w.is_ancestor_of(qnew):\n                continue\n            d = self._dist(qnew.position, w.position)\n            cand_cost = qnew.cost + d\n            if cand_cost + 1e-12 < w.cost and self._edge_free(qnew.position, w.position):\n                oldp = w.parent\n                self._replace_edge(edges, oldp, w, qnew)\n                w.attach(qnew)\n                delta = cand_cost - w.cost\n                w.propagate_cost(delta)\n                rewired += 1\n                if rewired >= 10:\n                    break\n\n    # Connect toward a target (other tree growth)\n    def _connect_toward(self, tree_nodes, target_pos, all_nodes, edges):\n        if not tree_nodes:\n            return False, None, []\n        cur = self._nearest_in(tree_nodes, target_pos)\n        added = []\n        for _ in range(1000):\n            nxt = self._steer(cur.position, target_pos)\n            if self._dist(cur.position, nxt) <= 1e-9:\n                break\n            if not self._in_bounds(nxt):\n                break\n            if self._point_in_obstacle(nxt):\n                break\n            if self._has_near_in(tree_nodes, nxt, self.dupe_radius):\n                # If very close to some node, snap to the nearest and continue\n                cur = self._nearest_in(tree_nodes, nxt)\n                if self._dist(cur.position, target_pos) <= self.step_size and self._edge_free(cur.position, target_pos):\n                    return True, cur, added\n                continue\n            if not self._edge_free(cur.position, nxt):\n                break\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            q = Node(nxt, cur, new_cost)\n            tree_nodes.append(q)\n            all_nodes.append(q)\n            edges.append((cur, q))\n            added.append(q)\n            cur = q\n            if self._dist(cur.position, target_pos) <= self.step_size and self._edge_free(cur.position, target_pos):\n                return True, cur, added\n        return False, cur, added\n\n    # Collision\n    def _point_in_obstacle(self, p):\n        if self.is3d:\n            px, py, pz = p\n            for x, y, z, w, h, d in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for x, y, w, h in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        if self.is3d:\n            for x, y, z, w, h, d in self.obstacles:\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return False\n            return True\n        else:\n            for x, y, w, h in self.obstacles:\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return False\n            return True\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Edges\n    def _replace_edge(self, edges, old_parent, child, new_parent):\n        if old_parent is not None:\n            rm = -1\n            for i, (u, v) in enumerate(edges):\n                if u is old_parent and v is child:\n                    rm = i\n                    break\n            if rm >= 0:\n                edges.pop(rm)\n        if new_parent is not None:\n            exists = False\n            for u, v in edges:\n                if u is new_parent and v is child:\n                    exists = True\n                    break\n            if not exists:\n                edges.append((new_parent, child))\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        for _ in range(24):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p is not None and not self._point_in_obstacle(p):\n                    return p\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._in_bounds(p) and not self._point_in_obstacle(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(16):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path ops\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        return pa + pb[::-1]\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pruned[-1], path[j]):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_L = self._path_len(pts)\n        tries = 0\n        while tries < attempts and len(pts) > 2:\n            n = len(pts)\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best_L + 1e-12:\n                    pts = cand\n                    best_L = L\n            tries += 1\n        return pts\n\n    def _finalize_path(self, path):\n        if not path:\n            return []\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        return p",
                "objective": -42.61971,
                "time_improvement": 88.0,
                "length_improvement": 13.0,
                "smoothness_improvement": 1715.0,
                "node_improvement": 94.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.005434727668762207,
                        "num_nodes_avg": 33.0,
                        "path_length_avg": 172.03461483544805,
                        "smoothness_avg": 0.051447969062332066,
                        "success_improvement": 0.0,
                        "time_improvement": 77.97145118473429,
                        "node_improvement": 91.68975069252078,
                        "length_improvement": 5.705101545770078,
                        "smoothness_improvement": 705.2724368784732,
                        "objective_score": 30.3408584672747
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.012911844253540038,
                        "num_nodes_avg": 78.0,
                        "path_length_avg": 254.30361579440722,
                        "smoothness_avg": 0.12651907716440625,
                        "success_improvement": 0.0,
                        "time_improvement": 92.27998699936137,
                        "node_improvement": 94.75912114493046,
                        "length_improvement": 15.106133324099327,
                        "smoothness_improvement": 3155.4269834480324,
                        "objective_score": 52.52481101150817
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.0025941610336303713,
                        "num_nodes_avg": 30.0,
                        "path_length_avg": 125.19016890049133,
                        "smoothness_avg": 0.10884440067125287,
                        "success_improvement": 0.0,
                        "time_improvement": 94.86067807289716,
                        "node_improvement": 96.18563254926892,
                        "length_improvement": 16.854650731526867,
                        "smoothness_improvement": 1284.492742480391,
                        "objective_score": 44.99345757318722
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "e2",
                "algorithm_description": "Bi-Informed Dual-Tree RRT*-Connect with Adaptive Neighborhoods and Shortcut Smoothing: a bidirectional planner that alternates growing optimized trees from start and goal, uses adaptive near-radius rewiring, informed rejection sampling after the first solution, and a connection step akin to RRT-Connect, followed by fast shortcut smoothing.",
                "planning_mechanism": "Mechanism: alternate tree expansion with goal-biased, bounds-respecting sampling; steer a step, validate node and edge, choose the lowest-cost parent among adaptive-radius neighbors, rewire and propagate costs; attempt to connect to the opposite tree via progressive extensions; upon any feasible join, update the incumbent cost and restrict future samples to the prolate hyperspheroid defined by start, goal, and best cost; terminate after a post-optimization budget or stagnation and return a smoothed path.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=5.0,\n                 base_radius=25.0,\n                 min_radius=6.0,\n                 goal_bias=0.12,\n                 post_opt_iters=800,\n                 max_no_improve=200,\n                 smoothing_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.goal_bias = goal_bias\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_cell = max(self.step_size, self.base_radius * 0.5)\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root, grid_cell)\n        self._grid_add(grid_goal, goal_root, grid_cell)\n\n        success = False\n        best_cost = float('inf')\n        best_join = (None, None)\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            active_first = (it % 2 == 0)\n            for which in (0, 1):\n                tree_a = start_tree if (active_first ^ (which == 1)) else goal_tree\n                tree_b = goal_tree if (tree_a is start_tree) else start_tree\n                grid_a = grid_start if (tree_a is start_tree) else grid_goal\n                grid_b = grid_goal if (tree_b is goal_tree) else grid_start\n\n                x_rand = self._sample(start, goal, best_cost, is_3d)\n                if self._rand() < self.goal_bias:\n                    x_rand = goal if (tree_a is start_tree) else start\n\n                x_nearest = self._nearest_grid(grid_a, tree_a, x_rand, grid_cell)\n                x_new_pos = self._steer(x_nearest.position, x_rand, self.step_size)\n\n                if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n                    continue\n                if self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n                    continue\n\n                x_new = Node(x_new_pos)\n                n_nodes = len(tree_a) + 1\n                r_near = self._adaptive_radius(n_nodes)\n                near_nodes = self._near_grid(grid_a, x_new_pos, r_near, grid_cell)\n\n                best_parent = x_nearest\n                best_pc = x_nearest.cost + self._dist(x_nearest.position, x_new_pos)\n                for nn in near_nodes:\n                    cand_cost = nn.cost + self._dist(nn.position, x_new_pos)\n                    if cand_cost < best_pc and not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d):\n                        best_parent = nn\n                        best_pc = cand_cost\n\n                best_parent.add_child(x_new)\n                x_new.cost = best_pc\n                tree_a.append(x_new)\n                nodes.append(x_new)\n                edges.append((best_parent, x_new))\n                self._grid_add(grid_a, x_new, grid_cell)\n\n                for nn in near_nodes:\n                    alt = x_new.cost + self._dist(x_new.position, nn.position)\n                    if alt + 1e-12 < nn.cost and not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d):\n                        op = nn.parent\n                        if op is not None:\n                            try:\n                                edges.remove((op, nn))\n                            except:\n                                pass\n                            try:\n                                op.children.remove(nn)\n                            except:\n                                pass\n                        x_new.add_child(nn)\n                        nn.cost = alt\n                        edges.append((x_new, nn))\n                        self._propagate_costs_from(nn, edges)\n\n                connect_success, meet_a, meet_b = self._connect_trees(x_new, tree_b, grid_b, obstacles, is_3d, grid_cell, nodes, edges)\n                if connect_success:\n                    path_cost = meet_a.cost + self._dist(meet_a.position, meet_b.position) + meet_b.cost\n                    if path_cost + 1e-12 < best_cost:\n                        best_cost = path_cost\n                        best_join = (meet_a, meet_b)\n                        success = True\n                        found_first = True\n                        post_iters = 0\n                        no_improve = 0\n                    else:\n                        if found_first:\n                            post_iters += 1\n                            no_improve += 1\n                else:\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n\n                if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                    break\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        path = []\n        if success and best_join[0] is not None:\n            path = self._extract_path(best_join[0], best_join[1])\n            path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _rand(self):\n        try:\n            return random.random()\n        except:\n            # fallback LCG if random unavailable\n            if not hasattr(self, \"_lcg_state\"):\n                self._lcg_state = 1234567\n            self._lcg_state = (1103515245 * self._lcg_state + 12345) % (1 << 31)\n            return (self._lcg_state / float(1 << 31))\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = (a[i] - b[i])\n            s += d * d\n        return s ** 0.5\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        ratio = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(self.dim))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=1.0):\n        d = self._dist(a, b)\n        steps = int(d / resolution)\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _sample(self, start, goal, c_best, is_3d):\n        for _ in range(50):\n            p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n            if c_best < float('inf'):\n                if self._dist(p, start) + self._dist(p, goal) <= c_best and self._in_bounds(p):\n                    return p\n            else:\n                if self._in_bounds(p):\n                    return p\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _adaptive_radius(self, n):\n        if n <= 1:\n            return max(self.min_radius, self.base_radius)\n        r = self.base_radius * (n ** (-1.0 / max(2, self.dim)))\n        if r < self.min_radius:\n            r = self.min_radius\n        return r\n\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        key = self._grid_key(node.position, cell)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_gather(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos, cell):\n        # Expand rings until any candidates are found; fallback to linear scan\n        rng = 0\n        best = None\n        bestd = float('inf')\n        while rng < 6:\n            radius = (rng + 1) * cell\n            cand = self._grid_gather(grid, pos, radius, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                return best\n            rng += 1\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_grid(self, grid, pos, radius, cell):\n        cand = self._grid_gather(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _connect_trees(self, node_a, tree_b, grid_b, obstacles, is_3d, cell, nodes, edges):\n        target = node_a.position\n        nnear = self._nearest_grid(grid_b, tree_b, target, cell)\n        current = nnear\n        last_new = None\n        max_steps = int((self._dist(current.position, target) / self.step_size)) + 2\n        for _ in range(max_steps):\n            new_pos = self._steer(current.position, target, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False, None, None\n            if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                return False, None, None\n            new_node = Node(new_pos)\n            new_node.cost = current.cost + self._dist(current.position, new_pos)\n            current.add_child(new_node)\n            tree_b.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_add(grid_b, new_node, cell)\n            last_new = new_node\n            current = new_node\n            if self._dist(current.position, target) <= self.step_size and not self._is_edge_in_obstacle(current.position, target, obstacles, is_3d):\n                meet_b = current\n                meet_a = node_a\n                return True, meet_a, meet_b\n        if last_new is not None and self._dist(last_new.position, target) <= self.step_size and not self._is_edge_in_obstacle(last_new.position, target, obstacles, is_3d):\n            return True, node_a, last_new\n        return False, None, None\n\n    def _path_to_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        path.reverse()\n        return path\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        # meet_b is on the tree rooted at goal; follow parents to goal\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # path_a ends at meet_a; path_b starts at meet_b; edge between them is implicit\n        return path_a + path_b\n\n    def _propagate_costs_from(self, node, edges):\n        q = []\n        for c in node.children:\n            q.append(c)\n        while q:\n            u = q.pop(0)\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                q.append(c)\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                new_pts = pts[:i + 1] + pts[j:]\n                pts = new_pts\n                n = len(pts)\n        return pts",
                "objective": 13.17506,
                "time_improvement": -100.0,
                "length_improvement": 18.0,
                "smoothness_improvement": 1141.0,
                "node_improvement": -19.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.04533350467681885,
                        "num_nodes_avg": 475.2,
                        "path_length_avg": 160.00839630243624,
                        "smoothness_avg": 0.03538840033717765,
                        "success_improvement": 0.0,
                        "time_improvement": -77.78684746193773,
                        "node_improvement": -19.66759002770082,
                        "length_improvement": 12.296862491341491,
                        "smoothness_improvement": 453.90531241814347,
                        "objective_score": -13.688410181685704
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.14875941276550292,
                        "num_nodes_avg": 1244.7,
                        "path_length_avg": 229.2684850165445,
                        "smoothness_avg": 0.07592744364942347,
                        "success_improvement": 0.0,
                        "time_improvement": 7.13989227527299,
                        "node_improvement": 16.367667808909488,
                        "length_improvement": 23.463580574034797,
                        "smoothness_improvement": 1853.6678134268077,
                        "objective_score": 25.48845509413681
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.1614241361618042,
                        "num_nodes_avg": 1203.4,
                        "path_length_avg": 120.8833554675142,
                        "smoothness_avg": 0.09548517805346257,
                        "success_improvement": 0.0,
                        "time_improvement": -229.0901755878243,
                        "node_improvement": -53.00699300699302,
                        "length_improvement": 19.715031145292965,
                        "smoothness_improvement": 1114.5644168573392,
                        "objective_score": -51.32521190488481
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "cross_over",
            "algorithm_description": "Bi-Hash IRRT*-Connect with Commit-Connect and Informed Radius: a bidirectional, grid-accelerated RRT* variant that grows two optimized trees with adaptive near-radius (using a log/n heuristic), informed prolate-ellipsoid sampling after the first solution, and a commit-only connection step that simulates the entire bridge before adding any opposite-tree nodes. Nearest/neighbor queries use a spatial hash grid; parent selection prefers lowest path cost; localized rewiring improves costs. Upon any join, the incumbent cost bounds future samples; the final path is visibility-pruned and shortcut-smoothed.",
            "planning_mechanism": "Alternate expanding start/goal trees. Each cycle: sample (goal-biased, bounds-respecting; informed once a path exists), get nearest via grid, steer one step, validate node and edge, pick lowest-cost feasible parent among radius-neighbors, insert and lightly rewire. Try a commit-connect from the opposite tree by simulating the full multi-step bridge; only if the whole bridge and final edge are collision-free are those nodes added. Maintain best path and restrict sampling to its ellipsoid; terminate after a brief post-optimization budget and return a pruned, shortcut-smoothed path.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n\n    def attach(self, new_parent):\n        if new_parent is self.parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            if self not in new_parent.children:\n                new_parent.children.append(self)\n\n    def is_ancestor_of(self, other):\n        cur = other\n        while cur is not None:\n            if cur is self:\n                return True\n            cur = cur.parent\n        return False\n\n    def propagate_cost(self, delta):\n        if delta == 0.0:\n            return\n        self.cost += delta\n        for c in self.children:\n            c.propagate_cost(delta)\nclass Planner:\n    def __init__(self,\n                 max_iter=4500,\n                 step_size=8.0,\n                 goal_bias=0.15,\n                 informed_bias=0.6,\n                 gamma_radius=80.0,\n                 min_radius_factor=2.2,\n                 grid_cell_factor=1.8,\n                 dupe_radius_ratio=0.3,\n                 rewire_cap=18,\n                 post_opt_iters=280,\n                 max_no_improve=120,\n                 shortcut_attempts=140):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.gamma_radius = float(gamma_radius)\n        self.min_radius_factor = float(min_radius_factor)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.rewire_cap = int(rewire_cap)\n        self.post_opt_iters = int(post_opt_iters)\n        self.max_no_improve = int(max_no_improve)\n        self.shortcut_attempts = int(shortcut_attempts)\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacle(self.start) or self._point_in_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._seed_rng()\n        self.grid_cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.4, self.step_size * self.dupe_radius_ratio)\n        self.min_radius = max(self.step_size * self.min_radius_factor, self.step_size * 2.0)\n        self.max_radius = max(self.step_size * 6.0, self.grid_cell * 2.0)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            edges = [(n0, n1)]\n            return PlannerResult(True, self._finalize_path([self.start, self.goal]), [n0, n1], edges)\n\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        A = [a_root]\n        B = [b_root]\n        grid_A = {}\n        grid_B = {}\n        self._grid_add(grid_A, a_root)\n        self._grid_add(grid_B, b_root)\n\n        success = False\n        best_len = float('inf')\n        best_join = (None, None)\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            grow_A = (it % 2 == 0)\n            T = A if grow_A else B\n            O = B if grow_A else A\n            Gt = grid_A if grow_A else grid_B\n            Go = grid_B if grow_A else grid_A\n            attractor = self.goal if grow_A else self.start\n\n            qrand = self._sample(attractor, best_len)\n            if qrand is None:\n                continue\n\n            qnear = self._nearest_grid(Gt, T, qrand)\n            if qnear is None:\n                continue\n\n            qnew_pos = self._steer(qnear.position, qrand)\n            if not self._in_bounds(qnew_pos):\n                continue\n            if self._point_in_obstacle(qnew_pos):\n                continue\n            if self._has_near_in(Gt, qnew_pos, self.dupe_radius):\n                continue\n\n            parent, new_cost = self._choose_parent(T, Gt, qnew_pos, qnear)\n            if parent is None:\n                continue\n            if self._point_in_obstacle(qnew_pos):\n                continue\n            if not self._edge_free(parent.position, qnew_pos):\n                continue\n\n            qnew = Node(qnew_pos, parent, new_cost)\n            T.append(qnew)\n            nodes.append(qnew)\n            edges.append((parent, qnew))\n            self._grid_add(Gt, qnew)\n\n            self._rewire_local(T, Gt, qnew, edges)\n\n            ok, meet_other, staged = self._commit_connect(O, Go, qnew.position)\n            if ok and meet_other is not None:\n                for u, v in staged:\n                    edges.append((u, v))\n                    nodes.append(v)\n                # cross-edge for visualization\n                edges.append((meet_other, qnew))\n                cur_len = meet_other.cost + self._dist(meet_other.position, qnew.position) + qnew.cost\n                if cur_len + 1e-12 < best_len:\n                    best_len = cur_len\n                    best_join = (qnew, meet_other) if grow_A else (meet_other, qnew)\n                    success = True\n                    if not found_first:\n                        found_first = True\n                    post_iters = 0\n                    no_improve = 0\n                else:\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n            else:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        path = []\n        if success and best_join[0] is not None and best_join[1] is not None:\n            path = self._extract_path(best_join[0], best_join[1])\n            path = self._finalize_path(path)\n\n        return PlannerResult(success, path, nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B97F4A7C15 & 0xffffffff\n        for v in self.start + self.goal:\n            s ^= (int(v * 2654435761) + (s << 7) + (s >> 3)) & 0xffffffff\n            s &= 0xffffffff\n        s ^= (len(self.obstacles) * 1103515245) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            tgt = a\n        elif d <= self.step_size:\n            tgt = b\n        else:\n            r = self.step_size / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n        out = tuple(max(0.0, min(tgt[i], self.bounds[i])) for i in range(self.dims))\n        return out\n\n    # Grid NN\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dims))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_gather(self, grid, pos, radius):\n        rng = int(radius // self.grid_cell) + 1\n        key = self._grid_key(pos)\n        cand = []\n        if self.dims == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        best = None\n        bestd = 1e100\n        rng = 0\n        while rng < 4:\n            cand = self._grid_gather(grid, pos, (rng + 1) * self.grid_cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                return best\n            rng += 1\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors_radius(self, grid, pos, radius):\n        cand = self._grid_gather(grid, pos, radius)\n        out = []\n        r = float(radius)\n        for n in cand:\n            if self._dist(n.position, pos) <= r:\n                out.append(n)\n        return out\n\n    def _has_near_in(self, grid, pos, radius):\n        cand = self._grid_gather(grid, pos, radius)\n        r = float(radius)\n        for n in cand:\n            if self._dist(n.position, pos) <= r:\n                return True\n        return False\n\n    # Parent choice and rewiring\n    def _log(self, x):\n        if x <= 0.0:\n            return -1e9\n        ln2 = 0.6931471805599453\n        k = 0\n        while x > 1.5:\n            x *= 0.5\n            k += 1\n        while x < 0.75:\n            x *= 2.0\n            k -= 1\n        z = (x - 1.0) / (x + 1.0)\n        z2 = z * z\n        s = z\n        term = z\n        # 9 terms of the series are plenty for our ranges\n        for n in (3, 5, 7, 9, 11, 13, 15, 17, 19):\n            term *= z2\n            s += term / n\n        return 2.0 * s + k * ln2\n\n    def _adaptive_radius(self, n):\n        n = max(2, int(n))\n        val = self.gamma_radius * ((max(1e-6, self._log(n)) / n) ** (1.0 / float(self.dims)))\n        if val < self.min_radius:\n            val = self.min_radius\n        if val > self.max_radius:\n            val = self.max_radius\n        return val\n\n    def _choose_parent(self, tree_nodes, grid, qpos, fallback):\n        n_nodes = len(tree_nodes) + 1\n        r = self._adaptive_radius(n_nodes)\n        near = self._neighbors_radius(grid, qpos, r)\n        if not near:\n            near = [fallback]\n        if fallback not in near:\n            near.append(fallback)\n        best_p = None\n        best_c = 1e100\n        for p in near:\n            if not self._edge_free(p.position, qpos):\n                continue\n            c = p.cost + self._dist(p.position, qpos)\n            if c < best_c:\n                best_c = c\n                best_p = p\n        return best_p, best_c\n\n    def _rewire_local(self, tree_nodes, grid, qnew, edges):\n        r = self._adaptive_radius(len(tree_nodes))\n        nbrs = self._neighbors_radius(grid, qnew.position, r)\n        rewired = 0\n        for w in nbrs:\n            if w is qnew or w is qnew.parent:\n                continue\n            if w.is_ancestor_of(qnew):\n                continue\n            alt = qnew.cost + self._dist(qnew.position, w.position)\n            if alt + 1e-12 < w.cost and self._edge_free(qnew.position, w.position):\n                oldp = w.parent\n                self._replace_edge(edges, oldp, w, qnew)\n                w.attach(qnew)\n                delta = alt - w.cost\n                w.propagate_cost(delta)\n                rewired += 1\n                if rewired >= self.rewire_cap:\n                    break\n\n    # Commit-only connect simulation\n    def _commit_connect(self, tree_nodes, grid, target_pos):\n        if not tree_nodes:\n            return False, None, []\n        cur = self._nearest_grid(grid, tree_nodes, target_pos)\n        staged_nodes = []\n        prev = cur\n        safety = 0\n        while self._dist(prev.position, target_pos) > self.step_size:\n            safety += 1\n            if safety > 1000:\n                return False, None, []\n            nxt_pos = self._steer(prev.position, target_pos)\n            if not self._in_bounds(nxt_pos):\n                return False, None, []\n            if self._point_in_obstacle(nxt_pos):\n                return False, None, []\n            near_snap = self._nearest_grid(grid, tree_nodes, nxt_pos)\n            if near_snap is not None and self._dist(near_snap.position, nxt_pos) <= self.dupe_radius:\n                if near_snap is prev:\n                    return False, None, []\n                prev = near_snap\n                continue\n            if not self._edge_free(prev.position, nxt_pos):\n                return False, None, []\n            new_node = Node(nxt_pos, None, prev.cost + self._dist(prev.position, nxt_pos))\n            staged_nodes.append((prev, new_node))\n            prev = new_node\n        if not self._edge_free(prev.position, target_pos):\n            return False, None, []\n        # commit all staged nodes\n        for p, q in staged_nodes:\n            q.attach(p)\n            tree_nodes.append(q)\n            self._grid_add(grid, q)\n        meet = prev if staged_nodes else cur\n        return True, meet, staged_nodes\n\n    # Collision\n    def _point_in_obstacle(self, p):\n        if self.is3d:\n            px, py, pz = p\n            for x, y, z, w, h, d in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for x, y, w, h in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        if self.is3d:\n            for x, y, z, w, h, d in self.obstacles:\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return False\n            return True\n        else:\n            for x, y, w, h in self.obstacles:\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return False\n            return True\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Edges\n    def _replace_edge(self, edges, old_parent, child, new_parent):\n        if old_parent is not None:\n            rm = -1\n            for i, (u, v) in enumerate(edges):\n                if u is old_parent and v is child:\n                    rm = i\n                    break\n            if rm >= 0:\n                edges.pop(rm)\n        if new_parent is not None:\n            exists = False\n            for u, v in edges:\n                if u is new_parent and v is child:\n                    exists = True\n                    break\n            if not exists:\n                edges.append((new_parent, child))\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        for _ in range(24):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.01)\n                if p is not None and self._in_bounds(p) and not self._point_in_obstacle(p):\n                    return p\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._in_bounds(p) and not self._point_in_obstacle(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(18):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path ops\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        return pa + pb[::-1]\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pruned[-1], path[j]):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_L = self._path_len(pts)\n        tries = 0\n        while tries < attempts and len(pts) > 2:\n            n = len(pts)\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best_L + 1e-12:\n                    pts = cand\n                    best_L = L\n            tries += 1\n        return pts\n\n    def _finalize_path(self, path):\n        if not path:\n            return []\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        return p",
            "objective": -11.71686,
            "time_improvement": -22.0,
            "length_improvement": 21.0,
            "smoothness_improvement": 1173.0,
            "node_improvement": 64.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06743419170379639,
                    "num_nodes_avg": 218.0,
                    "path_length_avg": 147.43755657052654,
                    "smoothness_avg": 0.04401219961597349,
                    "success_improvement": 0.0,
                    "time_improvement": -173.33060169754415,
                    "node_improvement": 45.10198942331907,
                    "length_improvement": 19.187138946103996,
                    "smoothness_improvement": 588.8864980111664,
                    "objective_score": -37.54246465154502
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06782259941101074,
                    "num_nodes_avg": 362.0,
                    "path_length_avg": 221.63582815851981,
                    "smoothness_avg": 0.06761558537305096,
                    "success_improvement": 0.0,
                    "time_improvement": 59.448755816075185,
                    "node_improvement": 75.67694685211315,
                    "length_improvement": 26.011581127089844,
                    "smoothness_improvement": 1639.7977131862142,
                    "objective_score": 41.640563987007525
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026401686668395995,
                    "num_nodes_avg": 223.0,
                    "path_length_avg": 124.72687710116297,
                    "smoothness_avg": 0.10922219079687726,
                    "success_improvement": 0.0,
                    "time_improvement": 47.695318275018224,
                    "node_improvement": 71.64653528289891,
                    "length_improvement": 17.16234708505599,
                    "smoothness_improvement": 1289.2982049927668,
                    "objective_score": 31.052494758502895
                }
            ],
            "success_rate": 1.0
        },
        "objective": 11.399999999999999,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Premature termination on the first feasible tree connection, yielding suboptimal joins and longer overall routes.\n   - Greedy, incremental connection that commits opposite-tree nodes without validating the full bridge, producing detours and poor meet points.\n   - Limited or shrinking neighbor sets for parent choice (fixed k or radius without proper scaling) and weak/one-sided rewiring, constraining cost reduction.\n   - Over-aggressive duplicate suppression and coarse step sizes that inhibit densification near the optimal corridor.\n   - Informed sampling that is insufficiently focused or reverts to uniform too early, reducing chances to improve the incumbent path."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Cost-aware parent selection over an adaptively sized neighborhood combined with localized rewiring in both trees.\n   - Connection step that stages the entire bridge and commits only if the full path segment is valid and cost-effective.\n   - More focused informed sampling around the current best path, coupled with moderate step sizing and relaxed duplicate filtering to enable corridor densification.\n   - Use of spatial indexing for nearest/neighbor queries, enabling larger, more effective neighbor evaluations without prohibitive overhead.\n2. Expected mechanism of impact:\n   - Adaptive parent choice and rewiring systematically lower cumulative path cost, replacing longer segments with cheaper alternatives.\n   - Commit-only connections avoid low-quality joins and select lower-cost meeting points, directly shortening the final route.\n   - Concentrated sampling within the cost-bounded region increases the frequency of improvements, tightening the path around the optimal corridor.\n   - Increased node density near promising areas allows finer navigation around obstacles, reducing detours and path length."
        }
    },
    {
        "parents": [
            {
                "operator": "e2",
                "algorithm_description": "IBEX-Prime: Informed BiRRTx with Elastic Corner Smoothing. It fuses bidirectional RRT-Connect with cost-aware local parenting, lightweight RRG-style rewiring, obstacle-aware sampling (goal/line/bridge and informed ellipse after first solution), and adaptive duplicate suppression. It returns the exact meeting node to avoid kinks and continues short informed optimization after the first path. Finalization performs densify, shortcut, visibility prune, and collision-checked corner rounding for high smoothness.",
                "planning_mechanism": "Alternate dual-side expansions per iteration toward a shared sample: steer one step, pick a best-cost parent within an adaptive RRG radius, insert only if node- and edge-free, then locally rewire cheaper neighbors. Greedily connect the opposite tree with larger steps and insert the exact junction when visible. Keep the best path found, continue a bounded informed refinement, then smooth with shortcut, visibility, and corner-rounding.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=6.0,\n        connect_factor=2.2,\n        goal_bias=0.12,\n        line_bias=0.16,\n        grid_cell_factor=1.6,\n        rewire_gamma=3.2,\n        refine_iters=700,\n        smooth_attempts=140,\n        corner_round_passes=2\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = float(connect_factor) * self.step\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.rewire_gamma = float(rewire_gamma)\n        self.refine_iters = int(max(0, refine_iters))\n        self.smooth_attempts = int(max(0, smooth_attempts))\n        self.corner_round_passes = int(max(0, corner_round_passes))\n        self._rng = 135792468\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.5, 0.4 * self.step)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early direct connection\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            final = self._finalize_path(path)\n            return PlannerResult(True, final, nodes, edges)\n\n        # Initialize bidirectional trees and spatial grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [start_root], [goal_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None\n        best_path = None\n        found_iter = None\n\n        for it in range(self.max_iter):\n            # One shared sample, then grow both sides for coherence\n            sample = self._sample(best_len)\n            if sample is None:\n                continue\n\n            # Expand start tree then connect goal tree\n            path1 = self._expand_and_connect(Ta, Ga, Tb, Gb, sample, nodes, edges, True)\n            if path1 is not None:\n                L = self._path_len(path1)\n                if best_len is None or L + 1e-9 < best_len:\n                    best_len = L\n                    best_path = self._dedup(path1)\n                    if found_iter is None:\n                        found_iter = it\n\n            # Expand goal tree then connect start tree\n            path2 = self._expand_and_connect(Tb, Gb, Ta, Ga, sample, nodes, edges, False)\n            if path2 is not None:\n                L = self._path_len(path2)\n                if best_len is None or L + 1e-9 < best_len:\n                    best_len = L\n                    best_path = self._dedup(path2)\n                    if found_iter is None:\n                        found_iter = it\n\n            # Informed refinement budget after first solution\n            if best_path is not None and found_iter is not None:\n                if (it - found_iter) >= self.refine_iters:\n                    final = self._finalize_path(best_path)\n                    return PlannerResult(True, final, nodes, edges)\n\n        if best_path is not None:\n            final = self._finalize_path(best_path)\n            return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # Core expansion and connection\n    def _expand_and_connect(self, Ta, Ga, Tb, Gb, sample, nodes, edges, active_is_start):\n        na = self._nearest(Ga, sample)\n        if na is None:\n            return None\n\n        target = self._steer(na.position, sample, self.step)\n        if (not self._in_bounds(target)) or self._point_in_obstacles(target):\n            return None\n\n        # Choose parent within adaptive RRG radius\n        radius = self._rrg_radius(len(Ta))\n        parent, p_cost = self._choose_parent(Ga, target, na, radius)\n        if parent is None:\n            return None\n\n        if (not self._edge_free(parent.position, target)):\n            return None\n        if self._too_close(Ga, target, self.dup_radius):\n            return None\n\n        # Add node (both checks ensured)\n        nn = Node(target, parent, p_cost)\n        parent.add_child(nn)\n        Ta.append(nn)\n        nodes.append(nn)\n        edges.append((parent, nn))\n        self._grid_add(Ga, nn)\n\n        # Local rewiring for nearby neighbors\n        self._local_rewire(Ga, nn, radius, edges)\n\n        meet_node, reached = self._connect_toward(Tb, Gb, nn.position, nodes, edges)\n        if reached:\n            # Build path via exact meeting point\n            pa = self._trace_to_root(nn)\n            pb = self._trace_to_root(meet_node)\n            if active_is_start:\n                if pa[-1] != pb[-1]:\n                    path = pa + [pb[-1]] + pb[-2::-1]\n                else:\n                    path = pa + pb[-2::-1]\n            else:\n                if pa[-1] != pb[-1]:\n                    path = pb + [pa[-1]] + pa[-2::-1]\n                else:\n                    path = pb + pa[-2::-1]\n            return self._dedup(path)\n        return None\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0x9E3779B97F4A7C15 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int((v * 2654435761) % (1 << 32)) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 31) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 135792468\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry helpers\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, 4):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius)) > 0\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.4)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = []\n            seen = {}\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                if idx not in seen:\n                                    seen[idx] = True\n                                    cand.append(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = []\n            seen = {}\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            if idx not in seen:\n                                seen[idx] = True\n                                cand.append(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parenting and lightweight rewiring\n    def _choose_parent(self, grid, newp, fallback, radius):\n        best = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        neigh = self._neighbors_in_radius(grid, newp, radius)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = c\n        return best, best_cost\n\n    def _local_rewire(self, grid, nn, radius, edges):\n        neigh = self._neighbors_in_radius(grid, nn.position, radius)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            cand_cost = nn.cost + self._dist(nn.position, nb.position)\n            if cand_cost + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                nn.add_child(nb)\n                nb.cost = cand_cost\n                edges.append((nn, nb))\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        for i in range(len(edges)):\n            if edges[i][0] is e[0] and edges[i][1] is e[1]:\n                edges.pop(i)\n                return\n\n    def _rrg_radius(self, n_nodes):\n        n = max(1, n_nodes)\n        # gamma * (log n / n)^(1/d), clamped\n        import_log = (1.0 + (n) ** 0.0)  # trick to avoid import; placeholder 1.0\n        # Simple monotone surrogate for log: ln(n) ~ sum 1/k for small; use sqrt for cost\n        # Use sqrt surrogate to avoid log import; works as decreasing with n\n        surrogate = (n ** 0.5)  # grows, so invert\n        inv = (1.0 / max(1.0, surrogate))\n        expo = inv ** (1.0 / max(1, self.dim))\n        r = self.rewire_gamma * self.step * expo\n        return max(1.2 * self.step, min(6.0 * self.step, r))\n\n    # Greedy connect from the other tree toward a target position\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < 64:\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                    if not self._too_close(grid, target_pos, 0.75 * self.dup_radius):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        # checks satisfied above\n                        cur.add_child(nn)\n                        tree.append(nn)\n                        nodes.append(nn)\n                        edges.append((cur, nn))\n                        self._grid_add(grid, nn)\n                        return nn, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(grid, nxt, 0.75 * self.dup_radius):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n        # Final visibility try\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._too_close(grid, target_pos, 0.75 * self.dup_radius):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    edges.append((cur, nn))\n                    self._grid_add(grid, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Sampling (goal/line/uniform, bridge, informed ellipse after first path)\n    def _sample(self, best_len):\n        r = self._rand()\n        # Informed ellipse sampling once a solution is known\n        if best_len is not None and r < 0.55:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        # Goal bias\n        if r < self.goal_bias:\n            return self.goal if self._in_bounds(self.goal) and (not self._point_in_obstacles(self.goal)) else None\n        # Start-goal line bias\n        if r < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t,\n                     self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t)\n            if (not self._point_in_obstacles(p)) and self._in_bounds(p):\n                return p\n        # Bridge test near obstacles (simple)\n        if r < 0.5:\n            p = self._rand_free_point()\n            if p is not None:\n                # neighbor q nearby\n                delta = 0.8 * self.step\n                if self.is3:\n                    q = (self._clamp((p[0] + self._rand_range(-delta, delta),\n                                      p[1] + self._rand_range(-delta, delta),\n                                      p[2] + self._rand_range(-delta, delta))))\n                else:\n                    q = (self._clamp((p[0] + self._rand_range(-delta, delta),\n                                      p[1] + self._rand_range(-delta, delta))))\n                if self._in_bounds(q):\n                    if self._point_in_obstacles(p) != self._point_in_obstacles(q):\n                        return q if (not self._point_in_obstacles(q)) else p\n        # Uniform\n        return self._rand_free_point()\n\n    def _rand_free_point(self):\n        if self.is3:\n            for _ in range(16):\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n                if (not self._point_in_obstacles(p)):\n                    return p\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            for _ in range(16):\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n                if (not self._point_in_obstacles(p)):\n                    return p\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _densify(self, pts, seg_len):\n        if len(pts) < 2:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts)):\n            a = out[-1]\n            b = pts[i]\n            d = self._dist(a, b)\n            if d <= seg_len * 1.05:\n                out.append(b)\n                continue\n            nseg = int(d / seg_len)\n            if nseg < 1:\n                out.append(b)\n                continue\n            for k in range(1, nseg + 1):\n                t = k / float(nseg + 1)\n                inter = self._lerp(a, b, t)\n                if self._edge_free(out[-1], inter):\n                    out.append(inter)\n                else:\n                    break\n            if self._edge_free(out[-1], b):\n                out.append(b)\n            else:\n                out.append(b)\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _corner_round(self, pts, passes, max_trim):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            if len(cur) < 3:\n                break\n            out = [cur[0]]\n            for i in range(1, len(cur) - 1):\n                a = out[-1]\n                b = cur[i]\n                c = cur[i + 1]\n                ab = self._dist(a, b)\n                bc = self._dist(b, c)\n                if ab < 1e-9 or bc < 1e-9:\n                    out.append(b)\n                    continue\n                trim = min(0.5 * min(ab, bc), max_trim)\n                if trim <= 1e-9:\n                    out.append(b)\n                    continue\n                p = self._lerp(a, b, max(0.0, (ab - trim) / max(1e-12, ab)))\n                q = self._lerp(b, c, min(1.0, trim / max(1e-12, bc)))\n                # Ensure visibility with collision checks\n                if self._edge_free(out[-1], p) and self._edge_free(p, q) and self._edge_free(q, c):\n                    out.append(p)\n                    out.append(q)\n                else:\n                    out.append(b)\n            out.append(cur[-1])\n            cur = self._dedup(out)\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._densify(path, seg_len=max(1.0, 0.5 * self.step))\n        p1 = self._shortcut(p0, self.smooth_attempts)\n        p2 = self._visibility_prune(p1)\n        p3 = self._corner_round(p2, self.corner_round_passes, max_trim=0.9 * self.step)\n        p4 = self._shortcut(p3, max(20, self.smooth_attempts // 2))\n        return self._dedup(p4)",
                "objective": 15.33275,
                "time_improvement": -113.0,
                "length_improvement": 19.0,
                "smoothness_improvement": 1409.0,
                "node_improvement": -21.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.10324516296386718,
                        "num_nodes_avg": 783.0,
                        "path_length_avg": 162.71461229847773,
                        "smoothness_avg": 0.04360968669943322,
                        "success_improvement": 0.0,
                        "time_improvement": -318.4829950840219,
                        "node_improvement": -97.17955175018885,
                        "length_improvement": 10.813542621174498,
                        "smoothness_improvement": 582.586296796523,
                        "objective_score": -86.14384146851926
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.10963551998138428,
                        "num_nodes_avg": 933.0,
                        "path_length_avg": 223.19924544744117,
                        "smoothness_avg": 0.06768758698823484,
                        "success_improvement": 0.0,
                        "time_improvement": 34.448741560988964,
                        "node_improvement": 37.31102600282201,
                        "length_improvement": 25.48966743557635,
                        "smoothness_improvement": 1641.6503666055626,
                        "objective_score": 33.83667476267031
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.07789533138275147,
                        "num_nodes_avg": 807.0,
                        "path_length_avg": 118.97556919449559,
                        "smoothness_avg": 0.16533831721376846,
                        "success_improvement": 0.0,
                        "time_improvement": -54.31932690550065,
                        "node_improvement": -2.6064844246662426,
                        "length_improvement": 20.982091948811927,
                        "smoothness_improvement": 2003.0911909540325,
                        "objective_score": 6.308913052407123
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "FALCON-Fuse: Fast Adaptive Learned-Cell biRRT* with Obstacle-Aware Sampling and Curvature Smoothing. It merges bidirectional RRT-Connect growth with local RRT* parenting and capped rewiring, an adaptive spatial grid for nearest/duplicate checks, obstacle- and line/goal-biased sampling plus informed prolate-ellipse sampling after the first solution, exact-node junctions to avoid kinks, lightweight edge-collision caching, and a multi-pass smoothing pipeline (visibility prune, shortcutting, and collision-checked corner rounding).",
            "planning_mechanism": "Each iteration draws one shared sample. The active tree steers one step, chooses the cheapest visible parent within an adaptive RRG radius, inserts the node if both node and edge are collision-free and not a duplicate, and locally rewires cheaper neighbors. The opposite tree greedily connects toward this new node with bounded steps, inserting the exact junction (or reusing an existing node) to produce a kink-free bridge. After the first path, informed sampling focuses search and a short refinement phase improves length; the final path is smoothed with densify, visibility prune, shortcutting, and curvature-aware corner rounding.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=5.0,\n        connect_factor=1.8,\n        goal_bias=0.10,\n        line_bias=0.18,\n        grid_cell_factor=1.5,\n        rewire_gamma=2.8,\n        rewire_cap=32,\n        refine_iters=360,\n        smooth_attempts=120,\n        corner_round_passes=3\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = float(connect_factor) * self.step\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.rewire_gamma = float(rewire_gamma)\n        self.rewire_cap = int(max(1, rewire_cap))\n        self.refine_iters = int(max(0, refine_iters))\n        self.smooth_attempts = int(max(0, smooth_attempts))\n        self.corner_round_passes = int(max(0, corner_round_passes))\n        self._rng = 246813579\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_base = max(0.4, 0.5 * self.step)\n        self._build_obs_bins()\n        self.ecache = {}\n        self.ecell = max(0.5, 0.5 * self.step)\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            final = self._finalize_path(path)\n            return PlannerResult(True, final, nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [start_root], [goal_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None\n        best_path = None\n        found_iter = None\n\n        for it in range(self.max_iter):\n            s = self._sample(best_len)\n            if s is None:\n                continue\n\n            nn = self._expand_once(Ta, Ga, s, nodes, edges)\n            if nn is not None:\n                meet, ok = self._connect_exact(Tb, Gb, nn.position, nodes, edges)\n                if ok:\n                    pa = self._trace_to_root(nn)\n                    pb = self._trace_to_root(meet)\n                    path = pa + pb[::-1][1:]\n                    path = self._dedup(path)\n                    L = self._path_len(path)\n                    if best_len is None or L + 1e-9 < best_len:\n                        best_len = L\n                        best_path = path\n                        if found_iter is None:\n                            found_iter = it\n\n            nn2 = self._expand_once(Tb, Gb, s, nodes, edges)\n            if nn2 is not None:\n                meet2, ok2 = self._connect_exact(Ta, Ga, nn2.position, nodes, edges)\n                if ok2:\n                    pa = self._trace_to_root(meet2)\n                    pb = self._trace_to_root(nn2)\n                    path = pa + pb[::-1][1:]\n                    path = self._dedup(path)\n                    L = self._path_len(path)\n                    if best_len is None or L + 1e-9 < best_len:\n                        best_len = L\n                        best_path = path\n                        if found_iter is None:\n                            found_iter = it\n\n            if best_path is not None and found_iter is not None:\n                if (it - found_iter) >= self.refine_iters:\n                    final = self._finalize_path(best_path)\n                    return PlannerResult(True, final, nodes, edges)\n\n        if best_path is not None:\n            final = self._finalize_path(best_path)\n            return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _expand_once(self, T, G, sample, nodes, edges):\n        near = self._nearest(G, sample)\n        if near is None:\n            return None\n        target = self._steer(near.position, sample, self.step)\n        if (not self._in_bounds(target)) or self._point_in_obstacles(target):\n            return None\n        radius = self._rrg_radius(len(T))\n        parent, pcost = self._choose_parent(G, target, near, radius)\n        if parent is None:\n            return None\n        dup_r = self._adapt_dup_radius(target)\n        if self._too_close(G, target, dup_r):\n            return None\n        if not self._edge_free(parent.position, target):\n            return None\n        nn = Node(target, parent, pcost)\n        parent.add_child(nn)\n        T.append(nn)\n        nodes.append(nn)\n        edges.append((parent, nn))\n        self._grid_add(G, nn)\n        self._local_rewire(G, nn, radius, edges)\n        return nn\n\n    def _connect_exact(self, T, G, target_pos, nodes, edges):\n        exist = self._find_existing(G, target_pos, 0.5 * self._adapt_dup_radius(target_pos))\n        if exist is not None:\n            return exist, True\n        cur = self._nearest(G, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < 36:\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                    if not self._too_close(G, target_pos, 0.5 * self._adapt_dup_radius(target_pos)):\n                        nc = Node(target_pos, cur, cur.cost + self._dist(cur.position, target_pos))\n                        cur.add_child(nc)\n                        T.append(nc)\n                        nodes.append(nc)\n                        edges.append((cur, nc))\n                        self._grid_add(G, nc)\n                        return nc, True\n                    else:\n                        e = self._find_existing(G, target_pos, 0.75 * self._adapt_dup_radius(target_pos))\n                        if e is not None:\n                            return e, True\n                        return cur, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if self._too_close(G, nxt, 0.5 * self._adapt_dup_radius(nxt)):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            nn = Node(nxt, cur, cur.cost + self._dist(cur.position, nxt))\n            cur.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(G, nn)\n            cur = nn\n            steps += 1\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._too_close(G, target_pos, 0.5 * self._adapt_dup_radius(target_pos)):\n                    nc = Node(target_pos, cur, cur.cost + self._dist(cur.position, target_pos))\n                    cur.add_child(nc)\n                    T.append(nc)\n                    nodes.append(nc)\n                    edges.append((cur, nc))\n                    self._grid_add(G, nc)\n                    return nc, True\n                else:\n                    e = self._find_existing(G, target_pos, 0.75 * self._adapt_dup_radius(target_pos))\n                    if e is not None:\n                        return e, True\n                    return cur, True\n            return cur, True\n        return cur, False\n\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int((v * 2654435761) % (1 << 32)) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 17) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 246813579\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, 3):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        count = 0\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                count += 1\n                                if count >= (self.rewire_cap * 2):\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            count += 1\n                            if count >= (self.rewire_cap * 2):\n                                return out\n        return out\n\n    def _find_existing(self, grid, pos, radius):\n        neigh = self._neighbors_in_radius(grid, pos, radius)\n        best = None\n        bestd = 1e100\n        for n in neigh:\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _too_close(self, grid, pos, radius):\n        lst = self._neighbors_in_radius(grid, pos, radius)\n        return len(lst) > 0\n\n    def _adapt_dup_radius(self, pos):\n        if self.is3:\n            ix = int(pos[0] // self.obs_cell)\n            iy = int(pos[1] // self.obs_cell)\n            iz = int(pos[2] // self.obs_cell)\n            near = self.obin.get((ix, iy, iz)) is not None\n        else:\n            ix = int(pos[0] // self.obs_cell)\n            iy = int(pos[1] // self.obs_cell)\n            near = self.obin.get((ix, iy)) is not None\n        return self.dup_base * (0.7 if near else 1.0)\n\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.4)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        if a == b:\n            return True\n        q = self.ecell\n        if self.dim == 3:\n            qa = (int(a[0] / q), int(a[1] / q), int(a[2] / q))\n            qb = (int(b[0] / q), int(b[1] / q), int(b[2] / q))\n        else:\n            qa = (int(a[0] / q), int(a[1] / q))\n            qb = (int(b[0] / q), int(b[1] / q))\n        if qa <= qb:\n            key = (qa, qb)\n        else:\n            key = (qb, qa)\n        val = self.ecache.get(key)\n        if val is not None:\n            return val\n        hit = self._segment_hits_any(a, b)\n        if len(self.ecache) > 30000:\n            self.ecache.clear()\n        self.ecache[key] = (not hit)\n        return not hit\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = []\n            seen = {}\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                if idx not in seen:\n                                    seen[idx] = True\n                                    cand.append(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = []\n            seen = {}\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            if idx not in seen:\n                                seen[idx] = True\n                                cand.append(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _choose_parent(self, grid, newp, fallback, radius):\n        best = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        neigh = self._neighbors_in_radius(grid, newp, radius)\n        count = 0\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost:\n                if self._edge_free(n.position, newp):\n                    best = n\n                    best_cost = c\n                    count += 1\n                    if count >= self.rewire_cap:\n                        break\n        return best, best_cost\n\n    def _local_rewire(self, grid, nn, radius, edges):\n        neigh = self._neighbors_in_radius(grid, nn.position, radius)\n        rewired = 0\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            cand_cost = nn.cost + self._dist(nn.position, nb.position)\n            if cand_cost + 1e-12 < nb.cost:\n                if self._edge_free(nn.position, nb.position):\n                    oldp = nb.parent\n                    if oldp is not None:\n                        oldp.remove_child(nb)\n                        self._remove_edge(edges, (oldp, nb))\n                    nn.add_child(nb)\n                    nb.cost = cand_cost\n                    edges.append((nn, nb))\n                    self._propagate_cost(nb)\n                    rewired += 1\n                    if rewired >= self.rewire_cap:\n                        break\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        for i in range(len(edges)):\n            if edges[i][0] is e[0] and edges[i][1] is e[1]:\n                edges.pop(i)\n                return\n\n    def _rrg_radius(self, n_nodes):\n        n = float(max(1, n_nodes))\n        expo = (1.0 / (1.0 + n)) ** (1.0 / float(max(1, self.dim)))\n        r = self.rewire_gamma * self.step * (expo ** 0.5)\n        return max(1.2 * self.step, min(5.0 * self.step, r))\n\n    def _sample(self, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.6:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            if self._in_bounds(self.goal) and (not self._point_in_obstacles(self.goal)):\n                return self.goal\n        if r < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t,\n                     self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t)\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        if r < 0.5:\n            p = self._sample_bridge()\n            if p is not None:\n                return p\n        return self._rand_free_point()\n\n    def _rand_free_point(self):\n        if self.is3:\n            for _ in range(16):\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n                if (not self._point_in_obstacles(p)):\n                    return p\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            for _ in range(16):\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n                if (not self._point_in_obstacles(p)):\n                    return p\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_bridge(self):\n        if self.is3:\n            p = (self._rand_range(0.0, self.bounds[0]),\n                 self._rand_range(0.0, self.bounds[1]),\n                 self._rand_range(0.0, self.bounds[2]))\n            q = (self._clamp((p[0] + self._rand_range(-self.step, self.step),\n                              p[1] + self._rand_range(-self.step, self.step),\n                              p[2] + self._rand_range(-self.step, self.step))))\n            if not self._in_bounds(q):\n                return None\n            m = ((p[0] + q[0]) * 0.5, (p[1] + q[1]) * 0.5, (p[2] + q[2]) * 0.5)\n            if self._point_in_obstacles(p) != self._point_in_obstacles(q):\n                if self._in_bounds(m) and (not self._point_in_obstacles(m)):\n                    return m\n            return None\n        else:\n            p = (self._rand_range(0.0, self.bounds[0]),\n                 self._rand_range(0.0, self.bounds[1]))\n            q = (self._clamp((p[0] + self._rand_range(-self.step, self.step),\n                              p[1] + self._rand_range(-self.step, self.step))))\n            if not self._in_bounds(q):\n                return None\n            m = ((p[0] + q[0]) * 0.5, (p[1] + q[1]) * 0.5)\n            if self._point_in_obstacles(p) != self._point_in_obstacles(q):\n                if self._in_bounds(m) and (not self._point_in_obstacles(m)):\n                    return m\n            return None\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _densify(self, pts, seg_len):\n        if len(pts) < 2:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts)):\n            a = out[-1]\n            b = pts[i]\n            d = self._dist(a, b)\n            if d <= seg_len * 1.05:\n                out.append(b)\n                continue\n            nseg = int(d / seg_len)\n            if nseg < 1:\n                out.append(b)\n                continue\n            for k in range(1, nseg + 1):\n                t = k / float(nseg + 1)\n                inter = self._lerp(a, b, t)\n                if self._edge_free(out[-1], inter):\n                    out.append(inter)\n                else:\n                    break\n            if self._edge_free(out[-1], b):\n                out.append(b)\n            else:\n                out.append(b)\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _corner_round(self, pts, passes, max_trim):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            if len(cur) < 3:\n                break\n            out = [cur[0]]\n            for i in range(1, len(cur) - 1):\n                a = out[-1]\n                b = cur[i]\n                c = cur[i + 1]\n                ab = self._dist(a, b)\n                bc = self._dist(b, c)\n                if ab < 1e-9 or bc < 1e-9:\n                    out.append(b)\n                    continue\n                trim = min(0.5 * min(ab, bc), max_trim)\n                if trim <= 1e-9:\n                    out.append(b)\n                    continue\n                p = self._lerp(a, b, max(0.0, (ab - trim) / max(1e-12, ab)))\n                q = self._lerp(b, c, min(1.0, trim / max(1e-12, bc)))\n                if self._edge_free(out[-1], p) and self._edge_free(p, q) and self._edge_free(q, c):\n                    out.append(p)\n                    out.append(q)\n                else:\n                    out.append(b)\n            out.append(cur[-1])\n            cur = self._dedup(out)\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._densify(path, seg_len=max(0.8, 0.6 * self.step))\n        p1 = self._visibility_prune(p0)\n        p2 = self._shortcut(p1, self.smooth_attempts)\n        p3 = self._corner_round(p2, self.corner_round_passes, max_trim=self.step)\n        p4 = self._visibility_prune(p3)\n        return self._dedup(p4)",
            "objective": -12.38165,
            "time_improvement": -21.0,
            "length_improvement": 21.0,
            "smoothness_improvement": 1230.0,
            "node_improvement": 20.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04927506446838379,
                    "num_nodes_avg": 518.0,
                    "path_length_avg": 156.93946856375484,
                    "smoothness_avg": 0.047012126415704555,
                    "success_improvement": 0.0,
                    "time_improvement": -99.72632101810129,
                    "node_improvement": -30.445731553764787,
                    "length_improvement": 13.978990415184779,
                    "smoothness_improvement": 635.8418668722705,
                    "objective_score": -18.351292721958167
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0726996898651123,
                    "num_nodes_avg": 602.0,
                    "path_length_avg": 220.781836795357,
                    "smoothness_avg": 0.08602880232493275,
                    "success_improvement": 0.0,
                    "time_improvement": 56.53273537998358,
                    "node_improvement": 59.551165759591484,
                    "length_improvement": 26.296668024892057,
                    "smoothness_improvement": 2113.583047862229,
                    "objective_score": 43.30573666824145
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0602783203125,
                    "num_nodes_avg": 548.0,
                    "path_length_avg": 117.1624269068174,
                    "smoothness_avg": 0.08182669990166686,
                    "success_improvement": 0.0,
                    "time_improvement": -19.41806591606534,
                    "node_improvement": 30.324221233312144,
                    "length_improvement": 22.186294723730065,
                    "smoothness_improvement": 940.8295829304845,
                    "objective_score": 12.190504974070858
                }
            ],
            "success_rate": 1.0
        },
        "objective": 11.799999999999999,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Coarse expansion and aggressive connect steps create indirect links and longer detours around obstacles\n   - Fixed duplicate-suppression near obstacles prevents necessary densification for tight, shortening maneuvers\n   - Greedy connection that stops \u201cnear\u201d the target without inserting the exact junction produces avoidable detours\n   - Inefficient sampling around obstacle boundaries yields few entries into narrow corridors, delaying short paths\n   - Large/loosely controlled neighbor sets during parenting/rewiring can pick suboptimal parents and add noisy edges\n   - Repeated collision checks without reuse discourage trying alternative, potentially shorter connections\n   - Post-processing order favors smoothing over straight-line visibility, leaving removable segments uncut"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Finer step and smaller connect step for more precise, direct expansions\n   - Adaptive duplicate-suppression radius that relaxes near obstacles to allow local densification\n   - Exact-node junction insertion and existing-node reuse during tree connection\n   - Stronger informed sampling (ellipse focus) and a more effective bridge test around obstacle boundaries\n   - Capped, radius-based parent selection and local rewiring (rewire cap + tighter RRG radius)\n   - Edge-collision caching to cheaply re-attempt promising straight links\n   - Reordered post-processing emphasizing early visibility pruning before shortcutting\n2. Expected mechanism of impact:\n   - Increased path refinement reduces overshoot and enables straighter progress toward the goal\n   - Additional vertices near corners/constraints enable tighter turns and shorter obstacle hugs\n   - Eliminating approximate \u201cnear-meet\u201d detours shortens the bridge between trees\n   - Higher probability of sampling within the informed subset and near passage midpoints discovers shorter corridors sooner\n   - More selective neighbor consideration prefers cheaper parents and trims unnecessary edges\n   - Faster reuse of collision results encourages testing long, direct edges that cut length\n   - Early visibility passes remove superfluous waypoints, compressing the polyline into shorter, visible segments"
        }
    },
    {
        "parents": [
            {
                "operator": "e1",
                "algorithm_description": "ARROW-RRT*: Adaptive Ribbon-biTree with Weighted-Optimal Rewiring and Opportunistic Connect. It grows two informed, grid-indexed trees with dynamic long-step steering, curvature-aware parent selection, multi-hop visible-ancestor compression, and capped, cycle-safe rewiring. Admission uses a per-cell f-gate (g+h) to curb bloat, while a fast RRT-Connect-style opportunistic bridge commits only collision-free steps. Final paths are refined via visibility pruning, corner collapse, and elastic line-search smoothing. Robust node/edge collision checks are enforced at every add or reparent.",
                "planning_mechanism": "Alternate expanding start/goal trees. Each iteration: draw a target (uniform/goal/ribbon/ellipse), pick nearest via grid, long-step steer toward it, validate node and edge, gate by per-cell f = g+h, insert, compress to a visible better ancestor, then locally rewire neighbors. Try to connect directly to the other tree; otherwise greedily extend the other tree toward the new node with validated steps. On a successful merge, assemble and refine the path and return.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step=6.0,\n                 long_step_factor=2.2,\n                 goal_bias=0.18,\n                 informed_bias=0.5,\n                 ribbon_bias=0.22,\n                 grid_factor=1.4,\n                 ring_max=3,\n                 neighbor_radius_scale=3.2,\n                 dupe_ratio=0.45,\n                 cell_cap=10,\n                 gate_relax=1.25,\n                 rewire_cap=18,\n                 connect_steps=6,\n                 compress_hops=6,\n                 shortcut_attempts=100,\n                 smooth_passes=8,\n                 curvature_weight=0.1):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.long_step = float(step * long_step_factor)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.ribbon_bias = float(ribbon_bias)\n        self.grid_factor = float(grid_factor)\n        self.ring_max = int(ring_max)\n        self.neighbor_radius_scale = float(neighbor_radius_scale)\n        self.dupe_ratio = float(dupe_ratio)\n        self.cell_cap = int(cell_cap)\n        self.gate_relax = float(gate_relax)\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(1, connect_steps))\n        self.compress_hops = int(max(0, compress_hops))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self.curv_w = float(curvature_weight)\n        self._rng = 1234567\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._eindex = {}  # (id(p), id(c)) -> index in edges\n\n        # Basic validation\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self._build_obs_index()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early direct connection\n        if self._edge_free(self.start, self.goal):\n            a = Node(self.start, None, 0.0)\n            b = Node(self.goal, a, self._dist(self.start, self.goal))\n            a.add_child(b)\n            nodes.extend([a, b])\n            self._edges_add(edges, a, b)\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Structures\n        self.node_cell = max(1.0, self.step * self.grid_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        count_a, count_b = {}, {}\n        fbest_a, fbest_b = {}, {}\n\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        self._cell_inc(count_a, start_root.position)\n        self._cell_inc(count_b, goal_root.position)\n        self._cell_fbest_update(fbest_a, start_root.position, start_root.cost + self._dist(start_root.position, self.goal))\n        self._cell_fbest_update(fbest_b, goal_root.position, goal_root.cost + self._dist(goal_root.position, self.start))\n\n        best_len = float('inf')\n        sg = self._dist(self.start, self.goal)\n        corridor = max(self.step, 0.25 * sg)\n\n        for it in range(self.max_iter):\n            forward = (it % 2 == 0)\n            tree = tree_a if forward else tree_b\n            other_tree = tree_b if forward else tree_a\n            grid = grid_a if forward else grid_b\n            other_grid = grid_b if forward else grid_a\n            counts = count_a if forward else count_b\n            other_counts = count_b if forward else count_a\n            fbest = fbest_a if forward else fbest_b\n            other_fbest = fbest_b if forward else fbest_a\n            attractor = self.goal if forward else self.start\n            back = self.start if forward else self.goal\n\n            # Sample target\n            target = self._sample_target(best_len, sg, corridor, attractor)\n            if target is None:\n                continue\n\n            # Nearest and dynamic steering\n            near = self._nearest(grid, tree, target)\n            if near is None:\n                continue\n            q_new = self._steer_dynamic(near.position, target)\n            if (not self._in_bounds(q_new)) or self._point_blocked(q_new):\n                continue\n            if self._exists_close(grid, q_new, self.dupe_radius):\n                continue\n            if not self._edge_free(near.position, q_new):\n                continue\n\n            # Choose parent among neighbors with curvature penalty\n            radius = self._adaptive_radius(len(tree))\n            neigh = self._neighbors_within(grid, q_new, radius, 96)\n            parent, new_cost = self._choose_parent(neigh, near, q_new)\n\n            if parent is None:\n                continue\n            if self._point_blocked(q_new) or (not self._edge_free(parent.position, q_new)):\n                continue\n\n            # Admission gate: per-cell f = g + h\n            key = self._cell_key(q_new)\n            cc = counts.get(key, 0)\n            f_val = new_cost + self._dist(q_new, attractor)\n            fb = fbest.get(key, float('inf'))\n            if cc >= self.cell_cap and not (f_val + 1e-9 < fb * self.gate_relax):\n                continue\n\n            # Insert node (both checks passed)\n            nn = Node(q_new, parent, new_cost)\n            parent.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            self._grid_add(grid, nn)\n            self._cell_inc(counts, nn.position)\n            self._cell_fbest_update(fbest, nn.position, f_val)\n            self._edges_add(edges, parent, nn)\n\n            # Multi-hop visible ancestor compression\n            if self.compress_hops > 0:\n                self._compress_to_visible_ancestor(nn, edges, self.compress_hops)\n\n            # Local rewiring\n            if self.rewire_cap > 0:\n                self._rewire_neighbors(grid, nn, radius, edges, self.rewire_cap)\n\n            # Connection attempt to other tree\n            other_near = self._nearest(other_grid, other_tree, nn.position)\n            if other_near is not None:\n                # Direct\n                if self._edge_free(nn.position, other_near.position):\n                    path = self._assemble_path(nn, other_near, forward)\n                    best_len = self._path_len(path)\n                    path = self._refine_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # Opportunistic greedy extend from other side\n                bridged = self._greedy_extend(other_tree, other_grid, other_counts, other_fbest, other_near, nn.position, radius, edges)\n                if bridged is not None and self._edge_free(bridged.position, nn.position):\n                    path = self._assemble_path(nn, bridged, forward)\n                    L = self._path_len(path)\n                    if L < best_len:\n                        best_len = L\n                    path = self._refine_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n            # Update incumbent bound if straight link becomes available later\n            if other_near is not None and self._edge_free(nn.position, other_near.position):\n                tmp = self._assemble_path(nn, other_near, forward)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    corridor = max(self.step, 0.2 * best_len)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        v = 2166136261\n        for t in self.start + self.goal:\n            v ^= int(t * 10007 + 0.5) & 0xffffffff\n            v = (v * 16777619) & 0xffffffff\n        v ^= (len(self.obstacles) + 31) & 0xffffffff\n        self._rng = (v ^ 0x9E3779B9) & 0xffffffff\n        if self._rng == 0:\n            self._rng = 1234567\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _vec(self, a, b):\n        return tuple(b[i] - a[i] for i in range(self.dim))\n\n    def _cos(self, u, v):\n        du = 0.0\n        dv = 0.0\n        dot = 0.0\n        for i in range(self.dim):\n            ui = u[i]\n            vi = v[i]\n            dot += ui * vi\n            du += ui * ui\n            dv += vi * vi\n        if du <= 1e-18 or dv <= 1e-18:\n            return 1.0\n        c = dot / ((du ** 0.5) * (dv ** 0.5))\n        if c < -1.0:\n            c = -1.0\n        if c > 1.0:\n            c = 1.0\n        return c\n\n    # Steering\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(self._lerp(a, b, r))\n\n    def _steer_dynamic(self, a, b):\n        # If LOS, take a longer stride toward the target\n        if self._edge_free(a, b):\n            d = self._dist(a, b)\n            step = self.long_step if d > self.long_step else d\n            return self._steer(a, b, step)\n        return self._steer(a, b, self.step)\n\n    # Sampling\n    def _sample_target(self, best_len, sg, corridor, attractor):\n        for _ in range(28):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._sample_informed_ellipse(self.start, self.goal, best_len * 1.01)\n                if p is not None and not self._point_blocked(p):\n                    return p\n            elif r < self.goal_bias:\n                if not self._point_blocked(attractor):\n                    return attractor\n            elif r < self.goal_bias + self.ribbon_bias:\n                # Ribbon sampling along start-goal with bounded lateral jitter\n                t = self._rand()\n                base = self._lerp(self.start, self.goal, t)\n                w = corridor\n                if self.is3:\n                    p = (self._rand_range(base[0] - w, base[0] + w),\n                         self._rand_range(base[1] - w, base[1] + w),\n                         self._rand_range(base[2] - w, base[2] + w))\n                else:\n                    p = (self._rand_range(base[0] - w, base[0] + w),\n                         self._rand_range(base[1] - w, base[1] + w))\n                p = self._clamp(p)\n                if not self._point_blocked(p):\n                    return p\n            else:\n                if self.is3:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n                if not self._point_blocked(p):\n                    return p\n        return None\n\n    def _sample_informed_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(28):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and (not self._point_blocked(p)):\n                return p\n        return None\n\n    # Node grid\n    def _cell_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.node_cell), int(pos[1] // self.node_cell), int(pos[2] // self.node_cell))\n        return (int(pos[0] // self.node_cell), int(pos[1] // self.node_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _cell_inc(self, counts, pos):\n        k = self._cell_key(pos)\n        counts[k] = counts.get(k, 0) + 1\n\n    def _cell_fbest_update(self, fbest, pos, f):\n        k = self._cell_key(pos)\n        fb = fbest.get(k)\n        if fb is None or f + 1e-12 < fb:\n            fbest[k] = f\n\n    def _ring_cells(self, key, r):\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        yield (key[0] + dx, key[1] + dy, key[2] + dz)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    yield (key[0] + dx, key[1] + dy)\n\n    def _nearest(self, grid, tree, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, self.ring_max + 1):\n            cand = []\n            seen = set()\n            for cell in self._ring_cells(key, r):\n                b = grid.get(cell)\n                if b:\n                    for n in b:\n                        nid = id(n)\n                        if nid not in seen:\n                            seen.add(nid)\n                            cand.append(n)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        r_cells = int(radius // self.node_cell) + 1\n        r2 = radius * radius\n        cand = []\n        seen = set()\n        for cell in self._ring_cells(key, r_cells):\n            b = grid.get(cell)\n            if not b:\n                continue\n            for n in b:\n                nid = id(n)\n                if nid in seen:\n                    continue\n                seen.add(nid)\n                d2 = 0.0\n                p = n.position\n                for i in range(self.dim):\n                    di = p[i] - pos[i]\n                    d2 += di * di\n                if d2 <= r2:\n                    cand.append(n)\n                    if len(cand) >= cap:\n                        return cand\n        return cand\n\n    def _exists_close(self, grid, pos, radius):\n        nb = self._neighbors_within(grid, pos, radius, 1)\n        return len(nb) > 0\n\n    def _adaptive_radius(self, n_nodes_in_tree):\n        # Smoothly decreasing neighbor radius without log; favors early exploration, later refinement\n        t = float(n_nodes_in_tree)\n        base = 1.2 * self.step\n        extra = self.neighbor_radius_scale * self.step / ((1.0 + t) ** 0.33)\n        r = base + extra\n        if r < 1.1 * self.step:\n            r = 1.1 * self.step\n        return r\n\n    # Obstacles and collisions\n    def _build_obs_index(self):\n        self.obs_cell = max(3.0, self.step * 1.8)\n        self.ogrid = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.ogrid.get(k)\n                            if b is None:\n                                self.ogrid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.ogrid.get(k)\n                        if b is None:\n                            self.ogrid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.ogrid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.ogrid.get((cx, cy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.ogrid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.ogrid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parent selection, compression, rewiring\n    def _choose_parent(self, neighbors, fallback_near, q_new):\n        best = None\n        best_cost = 1e100\n        # include fallback_near in candidates\n        cand = list(neighbors)\n        if fallback_near not in cand:\n            cand.append(fallback_near)\n        for n in cand:\n            if not self._edge_free(n.position, q_new):\n                continue\n            base = n.cost + self._dist(n.position, q_new)\n            pen = 0.0\n            if n.parent is not None:\n                u = self._vec(n.parent.position, n.position)\n                v = self._vec(n.position, q_new)\n                c = self._cos(u, v)\n                pen = self.curv_w * self.step * max(0.0, 1.0 - c)\n            cst = base + pen\n            if cst + 1e-12 < best_cost:\n                best_cost = cst\n                best = n\n        if best is None:\n            return None, None\n        return best, best_cost\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _edges_add(self, edges, parent, child):\n        key = (id(parent), id(child))\n        if key in self._eindex:\n            return\n        edges.append((parent, child))\n        self._eindex[key] = len(edges) - 1\n\n    def _edges_remove(self, edges, parent, child):\n        key = (id(parent), id(child))\n        idx = self._eindex.get(key)\n        if idx is None:\n            return\n        last = len(edges) - 1\n        if idx != last:\n            edges[idx] = edges[last]\n            pk, ck = id(edges[idx][0]), id(edges[idx][1])\n            self._eindex[(pk, ck)] = idx\n        edges.pop()\n        self._eindex.pop(key, None)\n\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        if self._point_blocked(child.position) or self._point_blocked(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._edges_remove(edges, old, child)\n        new_parent.add_child(child)\n        self._edges_add(edges, new_parent, child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        # propagate costs\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            for c in n.children:\n                stack.append(c)\n\n    def _compress_to_visible_ancestor(self, node, edges, hop_limit):\n        curp = node.parent\n        if curp is None:\n            return\n        anc = curp.parent\n        best = curp\n        bestc = node.cost\n        hops = 0\n        while anc is not None and hops < hop_limit:\n            if self._edge_free(anc.position, node.position):\n                c = anc.cost + self._dist(anc.position, node.position)\n                if c + 1e-12 < bestc:\n                    bestc = c\n                    best = anc\n            anc = anc.parent\n            hops += 1\n        if best is not curp:\n            self._reparent(node, best, edges)\n\n    def _rewire_neighbors(self, grid, node, radius, edges, cap):\n        neigh = self._neighbors_within(grid, node.position, radius, 128)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            newc = node.cost + self._dist(node.position, nb.position)\n            if newc + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= cap:\n                    break\n\n    # Bridge\n    def _greedy_extend(self, tree, grid, counts, fbest, from_node, target_pos, radius, edges):\n        prev = from_node\n        steps = 0\n        while steps < self.connect_steps:\n            steps += 1\n            nxtp = self._steer_dynamic(prev.position, target_pos)\n            if (not self._in_bounds(nxtp)) or self._point_blocked(nxtp):\n                return None\n            if not self._edge_free(prev.position, nxtp):\n                return None\n            # choose parent among local neighbors for this side as well\n            nb = self._neighbors_within(grid, nxtp, radius, 64)\n            p, cost = self._choose_parent(nb, prev, nxtp)\n            if p is None:\n                return None\n            # admission gate on this side\n            key = self._cell_key(nxtp)\n            cc = counts.get(key, 0)\n            f_val = cost + self._dist(nxtp, (self.start if (tree[0].position == self.goal) else self.goal))\n            fb = fbest.get(key, float('inf'))\n            if cc >= self.cell_cap and not (f_val + 1e-9 < fb * self.gate_relax):\n                return prev\n            # add node with checks\n            q = Node(nxtp, p, cost)\n            if self._point_blocked(q.position) or (not self._edge_free(p.position, q.position)):\n                return None\n            p.add_child(q)\n            tree.append(q)\n            self._grid_add(grid, q)\n            self._cell_inc(counts, q.position)\n            self._cell_fbest_update(fbest, q.position, f_val)\n            self._edges_add(edges, p, q)\n            # light compression and tiny rewiring on other side chain\n            self._compress_to_visible_ancestor(q, edges, 2)\n            prev = q\n            if self._edge_free(prev.position, target_pos):\n                return prev\n        return prev\n\n    # Path assembly and refinement\n    def _assemble_path(self, a_leaf, b_leaf, a_forward):\n        pa = a_leaf.path_to_root()\n        pb = b_leaf.path_to_root()\n        if a_forward:\n            return pa + pb[::-1]\n        else:\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _refine_path(self, path):\n        if len(path) < 2:\n            return path[:]\n        p0 = self._visibility_prune(path)\n        p1 = self._corner_collapse(p0)\n        p2 = self._elastic_smooth(p1, self.smooth_passes)\n        return p2\n\n    def _visibility_prune(self, pts):\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _corner_collapse(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 2:\n            a = out[-1]\n            c = pts[i + 2]\n            if self._edge_free(a, c):\n                out.append(c)\n                i += 2\n            else:\n                out.append(pts[i + 1])\n                i += 1\n        if out[-1] != pts[-1]:\n            out.append(pts[-1])\n        return out\n\n    def _elastic_smooth(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                target = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                # line search toward target\n                t = 1.0\n                best = b\n                while t > 1e-3:\n                    cand = tuple(b[k] + (target[k] - b[k]) * t for k in range(self.dim))\n                    if (not self._point_blocked(cand)) and self._edge_free(a, cand) and self._edge_free(cand, c):\n                        best = cand\n                        break\n                    t *= 0.5\n                if best != b:\n                    cur[i] = best\n                    moved = True\n            if not moved:\n                break\n        return cur",
                "objective": -33.74014,
                "time_improvement": 54.0,
                "length_improvement": 15.0,
                "smoothness_improvement": 1770.0,
                "node_improvement": 88.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.02561943531036377,
                        "num_nodes_avg": 90.0,
                        "path_length_avg": 173.11440391725938,
                        "smoothness_avg": 0.0720177255970773,
                        "success_improvement": 0.0,
                        "time_improvement": -3.8431023136117632,
                        "node_improvement": 77.33568370687485,
                        "length_improvement": 5.113252039676346,
                        "smoothness_improvement": 1027.2337945884865,
                        "objective_score": 7.051189502664712
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.019404673576354982,
                        "num_nodes_avg": 81.0,
                        "path_length_avg": 243.30655936651905,
                        "smoothness_avg": 0.09368068120607763,
                        "success_improvement": 0.0,
                        "time_improvement": 88.39791362558161,
                        "node_improvement": 94.55754888127393,
                        "length_improvement": 18.777267292447043,
                        "smoothness_improvement": 2310.471402899671,
                        "objective_score": 49.338091477641065
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.01148691177368164,
                        "num_nodes_avg": 63.0,
                        "path_length_avg": 120.97749511986653,
                        "smoothness_avg": 0.1629992507037538,
                        "success_improvement": 0.0,
                        "time_improvement": 77.24314844458131,
                        "node_improvement": 91.98982835346472,
                        "length_improvement": 19.652508070649073,
                        "smoothness_improvement": 1973.3384375985765,
                        "objective_score": 44.83114156375672
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "time_expert",
                "algorithm_description": "FLASH-IBiRRT: A fast, informed bidirectional RRT-Connect with bounded parenting and zero-cost rewiring. It grows two trees with large-step greedy connections, uses a compact spatial hash and obstacle bins for O(1)-like queries, schedules goal/segment-biased sampling, and returns on the first valid connection. Post-processing applies a single shortcut pass and visibility pruning for quick, smooth paths.",
                "planning_mechanism": "Alternate expansions from start/goal: sample (goal/line/uniform), steer one step from the active tree, insert only if node- and edge-free, then greedily connect the opposite tree with larger steps, inserting the exact meeting point when visible. No global rewiring; a small, local best-parent choice near the extension reduces cost at negligible overhead. Early exit upon connection, followed by fast shortcut and visibility prune.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=7.5,\n        connect_factor=2.6,\n        goal_bias=0.18,\n        line_bias=0.22,\n        grid_cell_factor=2.0,\n        k_parent=6,\n        smooth_attempts=60\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = self.step * float(connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.k_parent = int(max(1, k_parent))\n        self.smooth_attempts = int(max(0, smooth_attempts))\n        self._rng = 246813579\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.4, 0.35 * self.step)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            final = self._finalize_path(path)\n            return PlannerResult(True, final, nodes, edges)\n\n        # Initialize trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [start_root], [goal_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        for it in range(self.max_iter):\n            # Two fast passes per iteration: grow both sides toward a single sample\n            attract_a = self.goal\n            attract_b = self.start\n            sample = self._sample(attract_a, attract_b)\n            if sample is None:\n                continue\n\n            # pass 1: start tree\n            res = self._expand_and_connect(Ta, Ga, Tb, Gb, sample, nodes, edges, active_is_start=True)\n            if res is not None:\n                path = res\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n            # pass 2: goal tree\n            res = self._expand_and_connect(Tb, Gb, Ta, Ga, sample, nodes, edges, active_is_start=False)\n            if res is not None:\n                path = res\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # Core expansion + connection\n    def _expand_and_connect(self, Ta, Ga, Tb, Gb, sample, nodes, edges, active_is_start):\n        na = self._nearest(Ga, sample)\n        if na is None:\n            return None\n\n        # Choose a lightweight best parent among k nearest in the grid ring\n        target = self._steer(na.position, sample, self.step)\n        if (not self._in_bounds(target)) or self._point_in_obstacles(target):\n            return None\n\n        parent = self._best_parent(Ga, target, na, self.k_parent)\n        if parent is None:\n            return None\n\n        if (not self._edge_free(parent.position, target)):\n            return None\n\n        if self._too_close(Ga, target, self.dup_radius):\n            return None\n\n        new_cost = parent.cost + self._dist(parent.position, target)\n        nn = Node(target, parent, new_cost)\n        parent.add_child(nn)\n        Ta.append(nn)\n        nodes.append(nn)\n        edges.append((parent, nn))\n        self._grid_add(Ga, nn)\n\n        meet_node, reached = self._connect_toward(Tb, Gb, nn.position, nodes, edges)\n        if reached:\n            pa = self._trace_to_root(nn)\n            pb = self._trace_to_root(meet_node)\n            if active_is_start:\n                # pa goes start->...->nn, pb goes goal->...->meet\n                # Join paths; include meet if different from nn\n                if pa[-1] != pb[-1]:\n                    path = pa + [pb[-1]] + pb[-2::-1]\n                else:\n                    path = pa + pb[-2::-1]\n            else:\n                # pa goes goal->...->nn, pb goes start->...->meet\n                if pa[-1] != pb[-1]:\n                    path = pb + [pa[-1]] + pa[-2::-1]\n                else:\n                    path = pb + pa[-2::-1]\n            return self._dedup(path)\n        return None\n\n    # RNG and sampling\n    def _seed_from_scene(self):\n        s = 0xA341316C & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 11400714819323198485 & 0xffffffff)\n            s ^= (q ^ (q >> 15) ^ ((q << 9) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 29) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 246813579\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _sample(self, attract_a, attract_b):\n        r = self._rand()\n        # Goal bias\n        if r < self.goal_bias:\n            return attract_a\n        # Segment (start-goal) bias\n        if r < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                return (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                        self.start[1] + (self.goal[1] - self.start[1]) * t,\n                        self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                return (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                        self.start[1] + (self.goal[1] - self.start[1]) * t)\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash for nodes\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _k_nearest(self, grid, pos, kmax):\n        key = self._cell_key(pos)\n        heap = []\n        # simple partial selection without imports\n        cand = []\n        for r in range(0, 2):\n            cand.extend(self._grid_collect(grid, key, r))\n        if not cand:\n            for lst in grid.values():\n                cand.extend(lst)\n        # unique nodes (avoid tiny overhead of set by ID)\n        seen = {}\n        out = []\n        for n in cand:\n            if id(n) in seen:\n                continue\n            seen[id(n)] = True\n            out.append((self._dist2(n.position, pos), n))\n        out.sort(key=lambda x: x[0])\n        return [n for (_, n) in out[:kmax]]\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Local best parent (bounded k-NN)\n    def _best_parent(self, grid, newp, fallback, kmax):\n        best = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        kn = self._k_nearest(grid, newp, kmax)\n        for n in kn:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = c\n        return best\n\n    # Greedy connect from the other tree toward a target position\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < 48:\n            if self._edge_free(cur.position, target_pos):\n                # Insert exact meeting point if sufficiently far/unique\n                if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                    if not self._too_close(grid, target_pos, 0.75 * self.dup_radius):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        cur.add_child(nn)\n                        tree.append(nn)\n                        nodes.append(nn)\n                        edges.append((cur, nn))\n                        self._grid_add(grid, nn)\n                        return nn, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(grid, nxt, 0.75 * self.dup_radius):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n        # Last visibility try\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._too_close(grid, target_pos, 0.75 * self.dup_radius):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    edges.append((cur, nn))\n                    self._grid_add(grid, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Utilities\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        nbr = self._neighbors_in_radius(grid, pos, radius)\n        return len(nbr) > 0\n\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    # Fast, light smoothing\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._shortcut(path, self.smooth_attempts)\n        p2 = self._visibility_prune(p1)\n        return self._dedup(p2)",
                "objective": -37.07801,
                "time_improvement": 75.0,
                "length_improvement": 11.0,
                "smoothness_improvement": 1629.0,
                "node_improvement": 89.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.014019584655761719,
                        "num_nodes_avg": 83.0,
                        "path_length_avg": 188.21860119077922,
                        "smoothness_avg": 0.04147767672480912,
                        "success_improvement": 0.0,
                        "time_improvement": 43.17450224151976,
                        "node_improvement": 79.0984638630068,
                        "length_improvement": -3.1655978272618333,
                        "smoothness_improvement": 549.2157109598944,
                        "objective_score": 13.799070530898302
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.009280896186828614,
                        "num_nodes_avg": 72.0,
                        "path_length_avg": 247.55425918283944,
                        "smoothness_avg": 0.12140082327282926,
                        "success_improvement": 0.0,
                        "time_improvement": 94.45093684426602,
                        "node_improvement": 95.16226567224349,
                        "length_improvement": 17.35926283049915,
                        "smoothness_improvement": 3023.7306242884893,
                        "objective_score": 53.869491873021744
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.005894255638122558,
                        "num_nodes_avg": 52.0,
                        "path_length_avg": 124.23642750462632,
                        "smoothness_avg": 0.11125496209005074,
                        "success_improvement": 0.0,
                        "time_improvement": 88.32282311998175,
                        "node_improvement": 93.38842975206612,
                        "length_improvement": 17.48808035437552,
                        "smoothness_improvement": 1315.154905798364,
                        "objective_score": 43.56546967761165
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "SAGE-Connect*: Simple Adaptive Grid Explorer with Informed Bidirectional Growth, Gentle Rewiring, and Fast Smoothing. It builds two trees from start and goal using a compact spatial hash, adaptive neighbor radius, LOS-aware stepping, lightweight k-best parenting, capped local rewiring, and a restrained greedy connect. Once a valid bridge is found, the path is shortcut-pruned and elastically smoothed with collision-aware line search for robust, short, and smooth trajectories.",
            "planning_mechanism": "Alternate expanding start/goal trees. Each iteration: draw a target (goal/segment/uniform; switch to informed-ellipse once a path exists), pick nearest via grid, steer with LOS-adaptive step, enforce node and edge collision checks, suppress duplicates, select a low-cost parent from nearby nodes, add the node, and locally rewire a few neighbors if the new route is cheaper (cycle-safe, edge-checked). Attempt a short greedy connect from the other tree; on success, assemble the bidirectional path, then apply shortcutting and visibility pruning followed by elastic midpoint smoothing before returning.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step=6.0,\n        connect_factor=1.9,\n        goal_bias=0.16,\n        line_bias=0.22,\n        informed_bias=0.45,\n        grid_cell_factor=1.6,\n        neighbor_radius_scale=3.0,\n        dupe_ratio=0.4,\n        rewire_cap=12,\n        connect_steps=12,\n        shortcut_attempts=90,\n        smooth_passes=6\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.connect_step = float(step * connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_radius_scale = float(neighbor_radius_scale)\n        self.dupe_ratio = float(dupe_ratio)\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(1, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 123456789\n        self._eindex = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._eindex = {}\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            self._edges_add(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Trees and grids\n        Ta, Tb = [], []\n        Ga, Gb = {}, {}\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta.append(start_root)\n        Tb.append(goal_root)\n        nodes.extend([start_root, goal_root])\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            # Sample a common target for both directions for coherence\n            sample = self._sample_target(best_len)\n            if sample is None:\n                continue\n\n            # Expand from start side\n            res = self._expand_and_maybe_connect(Ta, Ga, Tb, Gb, sample, nodes, edges)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n            # Expand from goal side\n            res = self._expand_and_maybe_connect(Tb, Gb, Ta, Ga, sample, nodes, edges)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # Core expansion and connection\n    def _expand_and_maybe_connect(self, Ta, Ga, Tb, Gb, target, nodes, edges):\n        na = self._nearest(Ga, target)\n        if na is None:\n            return None\n        q_new = self._steer_dynamic(na.position, target)\n        if (not self._in_bounds(q_new)) or self._point_blocked(q_new):\n            return None\n        if self._too_close(Ga, q_new, self.dupe_radius):\n            return None\n\n        parent = self._select_parent(Ga, q_new, na)\n        if parent is None:\n            return None\n        # Both checks before adding node/edge\n        if self._point_blocked(q_new) or (not self._edge_free(parent.position, q_new)):\n            return None\n\n        cost = parent.cost + self._dist(parent.position, q_new)\n        nn = Node(q_new, parent, cost)\n        parent.add_child(nn)\n        Ta.append(nn)\n        nodes.append(nn)\n        self._grid_add(Ga, nn)\n        self._edges_add(edges, parent, nn)\n\n        # Gentle local rewiring\n        if self.rewire_cap > 0:\n            self._rewire_neighbors(Ga, nn, edges, self.rewire_cap)\n\n        # Try greedy connect from the opposite tree\n        meet, ok = self._greedy_connect(Tb, Gb, nn.position, nodes, edges)\n        if ok:\n            pa = nn.path_to_root()\n            pb = meet.path_to_root()\n            # Determine which root belongs to which\n            if Ta[0].position == self.start:\n                # pa: start->..., pb: goal->...\n                path = pa + pb[-2::-1]\n            else:\n                # pa: goal->..., pb: start->...\n                path = pb + pa[-2::-1]\n            L = self._path_len(path)\n            return (self._dedup(path), L)\n        return None\n\n    # RNG\n    def _seed_rng(self):\n        s = 2166136261\n        for v in self.start + self.goal:\n            s ^= int(v * 10007 + 0.5) & 0xffffffff\n            s = (s * 16777619) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Sampling\n    def _sample_target(self, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._sample_informed_ellipse(self.start, self.goal, best_len * 1.01)\n            if p is not None and self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return self.goal\n        if r2 < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t,\n                     self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t)\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_informed_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and (not self._point_blocked(p)):\n                return p\n        return None\n\n    # Geometry helpers\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(self._lerp(a, b, r))\n\n    def _steer_dynamic(self, a, b):\n        if self._edge_free(a, b):\n            d = self._dist(a, b)\n            step = self.connect_step if d > self.connect_step else d\n            return self._steer(a, b, step)\n        return self._steer(a, b, self.step)\n\n    # Node grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n            if best is not None:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        seen = {}\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            i2 = id(n)\n                            if i2 in seen:\n                                continue\n                            seen[i2] = True\n                            d2 = 0.0\n                            p = n.position\n                            for i in range(self.dim):\n                                di = p[i] - pos[i]\n                                d2 += di * di\n                            if d2 <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        i2 = id(n)\n                        if i2 in seen:\n                            continue\n                        seen[i2] = True\n                        d2 = 0.0\n                        p = n.position\n                        for i in range(self.dim):\n                            di = p[i] - pos[i]\n                            d2 += di * di\n                        if d2 <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _adaptive_radius(self, n_nodes):\n        t = float(max(1, n_nodes))\n        base = 1.2 * self.step\n        extra = self.neighbor_radius_scale * self.step / ((1.0 + t) ** (1.0 / 3.0))\n        r = base + extra\n        if r < 1.05 * self.step:\n            r = 1.05 * self.step\n        return r\n\n    def _too_close(self, grid, pos, radius):\n        nb = self._neighbors_within(grid, pos, radius, 1)\n        return len(nb) > 0\n\n    # Parent selection\n    def _select_parent(self, grid, newp, fallback_near):\n        r = self._adaptive_radius(len(grid))\n        neigh = self._neighbors_within(grid, newp, r, 96)\n        best = fallback_near\n        best_cost = fallback_near.cost + self._dist(fallback_near.position, newp)\n        for n in neigh:\n            if n is fallback_near:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = c\n        return best\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _rewire_neighbors(self, grid, node, edges, cap):\n        r = self._adaptive_radius(len(grid))\n        neigh = self._neighbors_within(grid, node.position, r, 128)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            if self._point_blocked(nb.position) or self._point_blocked(node.position):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            newc = node.cost + self._dist(node.position, nb.position)\n            if newc + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= cap:\n                    break\n\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        if self._point_blocked(child.position) or self._point_blocked(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._edges_remove(edges, old, child)\n        new_parent.add_child(child)\n        self._edges_add(edges, new_parent, child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            for c in n.children:\n                stack.append(c)\n\n    # Greedy connect\n    def _greedy_connect(self, T, G, target_pos, nodes, edges):\n        cur = self._nearest(G, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < self.connect_steps:\n            # Visible? insert exact meeting point\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                    if not self._too_close(G, target_pos, 0.75 * self.dupe_radius):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                            return cur, True\n                        cur.add_child(nn)\n                        T.append(nn)\n                        nodes.append(nn)\n                        self._grid_add(G, nn)\n                        self._edges_add(edges, cur, nn)\n                        return nn, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(G, nxt, 0.75 * self.dupe_radius):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                return cur, False\n            cur.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            self._grid_add(G, nn)\n            self._edges_add(edges, cur, nn)\n            cur = nn\n            steps += 1\n        # Final visibility check\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                if not self._too_close(G, target_pos, 0.75 * self.dupe_radius):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                        return cur, True\n                    cur.add_child(nn)\n                    T.append(nn)\n                    nodes.append(nn)\n                    self._grid_add(G, nn)\n                    self._edges_add(edges, cur, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(3.5, self.step * 1.6)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Edge bookkeeping\n    def _edges_add(self, edges, parent, child):\n        key = (id(parent), id(child))\n        if key in self._eindex:\n            return\n        edges.append((parent, child))\n        self._eindex[key] = len(edges) - 1\n\n    def _edges_remove(self, edges, parent, child):\n        key = (id(parent), id(child))\n        idx = self._eindex.get(key)\n        if idx is None:\n            return\n        last = len(edges) - 1\n        if idx != last:\n            edges[idx] = edges[last]\n            pk, ck = id(edges[idx][0]), id(edges[idx][1])\n            self._eindex[(pk, ck)] = idx\n        edges.pop()\n        self._eindex.pop(key, None)\n\n    # Path utilities and smoothing\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _elastic_smooth(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                target = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                t = 1.0\n                best = b\n                while t > 1e-3:\n                    cand = tuple(b[k] + (target[k] - b[k]) * t for k in range(self.dim))\n                    cand = self._clamp(cand)\n                    if (not self._point_blocked(cand)) and self._edge_free(a, cand) and self._edge_free(cand, c):\n                        best = cand\n                        break\n                    t *= 0.5\n                if best != b:\n                    cur[i] = best\n                    moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._shortcut(path, self.shortcut_attempts)\n        p2 = self._visibility_prune(p1)\n        p3 = self._elastic_smooth(p2, self.smooth_passes)\n        return self._dedup(p3)",
            "objective": -47.53913,
            "time_improvement": 86.0,
            "length_improvement": 21.0,
            "smoothness_improvement": 1812.0,
            "node_improvement": 93.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.004579019546508789,
                    "num_nodes_avg": 30.0,
                    "path_length_avg": 146.96078572191126,
                    "smoothness_avg": 0.03859037591406768,
                    "success_improvement": 0.0,
                    "time_improvement": 81.43988774523116,
                    "node_improvement": 92.44522790229162,
                    "length_improvement": 19.448464603147585,
                    "smoothness_improvement": 504.0231833977275,
                    "objective_score": 38.621161002446534
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023305273056030272,
                    "num_nodes_avg": 122.0,
                    "path_length_avg": 229.66193713526982,
                    "smoothness_avg": 0.11885248032537557,
                    "success_improvement": 0.0,
                    "time_improvement": 86.065738755588,
                    "node_improvement": 91.80272794463482,
                    "length_improvement": 23.332234931912975,
                    "smoothness_improvement": 2958.1599247532718,
                    "objective_score": 54.609862209590545
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.004154682159423828,
                    "num_nodes_avg": 32.0,
                    "path_length_avg": 120.49632735979439,
                    "smoothness_avg": 0.1630888303105967,
                    "success_improvement": 0.0,
                    "time_improvement": 91.76911192279043,
                    "node_improvement": 95.93134138588684,
                    "length_improvement": 19.972076786142434,
                    "smoothness_improvement": 1974.4778835855395,
                    "objective_score": 49.38636906645029
                }
            ],
            "success_rate": 1.0
        },
        "objective": 10.2,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Limited or absent edge rewiring and small fixed-k parent selection led to suboptimal parents and inflated path costs.\n   - Oversized step/connection lengths caused late obstacle avoidance, overshoot, and longer detours around obstacles.\n   - Sampling overly biased to the start\u2013goal line or aggressive LOS strides reduced exploration of shorter homotopies and increased rejection in clutter.\n   - Coarse spatial grids, strict duplicate thresholds, and gating suppressed useful nodes in narrow passages, limiting local refinement.\n   - Early acceptance of the first bidirectional bridge with light post-processing left residual detours and unnecessary waypoints."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Gentle local rewiring with adaptive neighbor-radius parent selection to consistently choose lower-cost parents.\n   - Reduced connection stride with capped greedy-connect steps and LOS-adaptive steering for finer, less detouring bridges.\n   - Informed-ellipse sampling after an incumbent path and a shared target for both trees to focus growth along promising, shorter homotopies.\n   - Slightly denser node placement (smaller duplicate radius, tighter grid) to enable better parent options and local visibility shortcuts.\n   - Multi-stage post-processing (shortcutting + visibility pruning + elastic smoothing) to eliminate residual detours.\n2. Expected mechanism of impact:\n   - Rewiring plus broader neighbor evaluation lowers cumulative g-costs, directly shortening the final route.\n   - Finer connection steps avoid overshoot and reduce zig-zags at joins, aligning the bridge closer to the true shortest path.\n   - Focused sampling increases encounter rate along near-straight corridors, reducing unnecessary exploration of longer routes.\n   - Denser waypoint coverage near bends enables more direct LOS edges and better shortcut opportunities.\n   - Post-processing collapses superfluous waypoints and straightens segments while remaining collision-free, trimming path length further."
        }
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "FlashConnect BiRRT (FC-BiRRT): a cache-accelerated bidirectional planner with throttled growth and corridor-guided micro-batches. It couples an adaptive hashed-nearest structure with a conservative edge-collision memo (blocked-edge cache), per-cell expansion throttling, and sparse \u201cleader\u201d fallbacks to avoid O(N) scans. Direct bridges and short greedy connects are attempted with cached checks; on success, a bounded shortcut and line-of-sight collapse return a clean path fast.",
                "planning_mechanism": "Mechanism: Initialize start/goal trees with grid buckets and sparse leaders. Each iteration alternates trees, samples a tiny beam (goal/corridor/uniform), steers once from the nearest, enforces node/edge validity, prunes duplicates and saturated cells, and keeps the candidate that best reduces distance to the other tree. Insert with optional grandparent LOS compression, then attempt a direct bridge; if blocked, execute a few greedy connect steps using the blocked-edge cache. On bridge, extract and lightly smooth the path; otherwise continue until the iteration cap.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=8.0,\n                 goal_bias=0.2,\n                 corridor_bias=0.55,\n                 beam_k=2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 connect_steps=5,\n                 smoothing_iters=18,\n                 min_sep_ratio=0.25,\n                 dupe_radius_ratio=0.5,\n                 cell_expand_limit=3,\n                 leader_stride=16):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.leader_stride = max(1, int(leader_stride))\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Setup grid and edge sampling step\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.8 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.4)))\n        self.cache_bin = max(1.0, self.edge_res)  # quantization for blocked-edge cache\n\n        # Validate start/goal and early LOS\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n        if not self._is_edge_in_obstacle(self.start, self.goal, obstacles, is_3d, self.edge_res):\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, [self.start, self.goal], nodes, [])\n\n        # Initialize trees, grids, leaders, edges, caches\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start, grid_goal = {}, {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        leaders_start, leaders_goal = [start_root], [goal_root]\n        cell_expands_start, cell_expands_goal = {}, {}\n\n        blocked_edge_cache = set()\n\n        # Corridor parameters\n        dsg = self._dist(self.start, self.goal)\n        base_corridor = max(self.step_size, 0.15 * dsg)\n        best_path_len = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            leaders_a = leaders_start if active_start else leaders_goal\n            leaders_b = leaders_goal if active_start else leaders_start\n            cell_count_a = cell_expands_start if active_start else cell_expands_goal\n            root_other = self.goal if active_start else self.start\n\n            # Candidate beam; keep one that best approaches the other tree\n            best_parent = None\n            best_newpos = None\n            best_score = float('inf')\n\n            for _ in range(self.beam_k):\n                # Sampling: goal-biased, corridor-guided, or uniform\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = base_corridor\n                    if best_path_len < float('inf'):\n                        width = max(self.step_size, 0.25 * (best_path_len - dsg) + base_corridor)\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_hashed(grid_a, tree_a, leaders_a, x_rand)\n                if nearest is None:\n                    continue\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n\n                # De-duplicate and throttle saturated cells\n                if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                kcell = self._grid_key(new_pos)\n                if cell_count_a.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n\n                # Edge validity with blocked-edge cache\n                if self._is_edge_blocked_cached(nearest.position, new_pos, obstacles, is_3d, blocked_edge_cache):\n                    continue\n\n                # Score: distance to nearest in opposite tree (leaders-assisted)\n                other_near = self._nearest_hashed(grid_b, tree_b, leaders_b, new_pos)\n                if other_near is not None:\n                    score = self._dist(new_pos, other_near.position)\n                else:\n                    score = self._dist(new_pos, root_other)\n\n                if score < best_score:\n                    best_score = score\n                    best_parent = nearest\n                    best_newpos = new_pos\n\n            if best_parent is None:\n                continue\n\n            # Final validity before insertion (both checks)\n            if self._is_in_obstacle(best_newpos, obstacles, is_3d):\n                continue\n            if self._is_edge_blocked_cached(best_parent.position, best_newpos, obstacles, is_3d, blocked_edge_cache):\n                continue\n\n            # Insert node and edge\n            new_cost = best_parent.cost + self._dist(best_parent.position, best_newpos)\n            new_node = Node(best_newpos, parent=best_parent, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            self._edges_add(edges, best_parent, new_node)\n            self._grid_add(grid_a, new_node)\n            # Update per-cell throttle\n            kc = self._grid_key(new_node.position)\n            cell_count_a[kc] = cell_count_a.get(kc, 0) + 1\n            # Sparse leaders\n            if len(tree_a) % self.leader_stride == 0:\n                leaders_a.append(new_node)\n\n            # On-the-fly grandparent compression\n            gp = best_parent.parent\n            if gp is not None:\n                if not self._is_edge_blocked_cached(gp.position, new_node.position, obstacles, is_3d, blocked_edge_cache):\n                    best_parent.remove_child(new_node)\n                    self._edges_remove(edges, best_parent, new_node)\n                    gp.add_child(new_node)\n                    self._edges_add(edges, gp, new_node)\n                    new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n\n            # Attempt direct bridge to nearest in the other tree\n            other_near = self._nearest_hashed(grid_b, tree_b, leaders_b, new_node.position)\n            if other_near is not None and not self._is_edge_blocked_cached(new_node.position, other_near.position, obstacles, is_3d, blocked_edge_cache):\n                path = self._extract_path(new_node, other_near)\n                best_path_len = self._path_length(path)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Short greedy connect from the other tree toward the new node\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if self._dist(p.position, to_pos) < self.step_size * self.min_sep_ratio:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(grid_b, to_pos, self.step_size * self.dupe_radius_ratio):\n                    break\n                if self._is_edge_blocked_cached(p.position, to_pos, obstacles, is_3d, blocked_edge_cache):\n                    break\n\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                self._edges_add(edges, p, q)\n                self._grid_add(grid_b, q)\n                # leaders and per-cell throttle for tree_b\n                if len(tree_b) % self.leader_stride == 0:\n                    leaders_b.append(q)\n                kc_b = self._grid_key(q.position)\n                if active_start:\n                    cell_expands_goal[kc_b] = cell_expands_goal.get(kc_b, 0) + 1\n                else:\n                    cell_expands_start[kc_b] = cell_expands_start.get(kc_b, 0) + 1\n\n                p = q\n                steps += 1\n\n                # Check bridge now\n                if not self._is_edge_blocked_cached(new_node.position, p.position, obstacles, is_3d, blocked_edge_cache):\n                    path = self._extract_path(new_node, p)\n                    best_path_len = self._path_length(path)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # RNG\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _is_edge_blocked_cached(self, a, b, obstacles, is_3d, blocked_cache):\n        key = self._edge_key_q(a, b)\n        if key in blocked_cache:\n            return True\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n        if blocked:\n            blocked_cache.add(key)\n        return blocked\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # Grid and neighbors\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, leaders, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Limited rings, then leader fallback to avoid O(N)\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fall back to leaders (sparse)\n        for n in leaders:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # Fallback full scan (rare)\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # Edges\n    def _edges_add(self, edges, parent, child):\n        edges.append((parent, child))\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        # Forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            for k in range(1, len(pts) - 1):\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d, self.edge_res):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
                "objective": -14.73772,
                "time_improvement": 1.0,
                "length_improvement": 9.0,
                "smoothness_improvement": 1829.0,
                "node_improvement": 84.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.03957667350769043,
                        "num_nodes_avg": 89.6,
                        "path_length_avg": 173.3707237388481,
                        "smoothness_avg": 0.05077321918948241,
                        "success_improvement": 0.0,
                        "time_improvement": -55.2099725384924,
                        "node_improvement": 77.43641400151094,
                        "length_improvement": 4.972759083816072,
                        "smoothness_improvement": 694.711136125575,
                        "objective_score": -10.105780630630203
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.05332317352294922,
                        "num_nodes_avg": 145.0,
                        "path_length_avg": 246.8569464197752,
                        "smoothness_avg": 0.11933221064521529,
                        "success_improvement": 0.0,
                        "time_improvement": 66.7140684040557,
                        "node_improvement": 90.25734058993481,
                        "length_improvement": 17.592045901845015,
                        "smoothness_improvement": 2970.5037314185306,
                        "objective_score": 45.42196671941637
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.052624630928039554,
                        "num_nodes_avg": 134.3,
                        "path_length_avg": 145.60396458843502,
                        "smoothness_avg": 0.1510094522023601,
                        "success_improvement": 0.0,
                        "time_improvement": -7.284136338781219,
                        "node_improvement": 82.92434837889384,
                        "length_improvement": 3.2967796360860238,
                        "smoothness_improvement": 1820.829085655716,
                        "objective_score": 8.896972308295828
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "cross_over",
                "algorithm_description": "FIBER-Connect*: Fast Informed Bidirectional RRT*-Connect with Cached Collisions and Local Rewiring \u2014 a bidirectional planner that blends informed sampling, grid-accelerated near/nearest, per-cell cost gating, limited RRT* rewiring, and multi-step connect-extend bridging; it maintains an edge-collision cache and applies visibility pruning plus shortcuts for short, smooth paths with low planning time.",
                "planning_mechanism": "Alternate expanding the two trees; sample with goal/line bias and informed-ellipsoid once a path exists; find nearest via grid rings, steer, and validate; select the lowest-cost parent among radius neighbors (LOS) and insert under per-cell cost gates; locally rewire a few neighbors to reduce path cost; then attempt multi-step connect from the opposite tree toward the new node and bridge on first free LOS; upon success, extract start\u2192meetA + meetB\u2192goal, visibility-prune and shortcut, and return.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.22,\n                 line_bias=0.30,\n                 informed_tries=80,\n                 grid_cell_factor=1.5,\n                 max_per_cell=6,\n                 duplicate_radius_factor=0.5,\n                 rewire_k=10,\n                 rewire_depth=5,\n                 neighbor_radius_factor=3.0,\n                 connect_steps=6,\n                 smoothing_iters=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.informed_tries = informed_tries\n        self.grid_cell_factor = grid_cell_factor\n        self.max_per_cell = max_per_cell\n        self.duplicate_radius_factor = duplicate_radius_factor\n        self.rewire_k = rewire_k\n        self.rewire_depth = rewire_depth\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        self.edge_res = max(0.5, min(1.0, 0.5 * self.step_size))\n        self.cell_size = max(1.0, self.grid_cell_factor * self.step_size)\n        self.min_sep = max(0.3, self.duplicate_radius_factor * self.step_size)\n\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            return PlannerResult(True, [start, goal], [s, g], [(s, g)])\n\n        s_root = Node(start, None, 0.0)\n        g_root = Node(goal, None, 0.0)\n\n        start_tree = [s_root]\n        goal_tree = [g_root]\n        nodes = [s_root, g_root]\n        edges = []\n\n        grid_s = {}\n        grid_g = {}\n        counts_s = {}\n        counts_g = {}\n        bestcost_s = {}\n        bestcost_g = {}\n\n        self._grid_add(grid_s, counts_s, bestcost_s, s_root)\n        self._grid_add(grid_g, counts_g, bestcost_g, g_root)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_s if active_start else grid_g\n            grid_b = grid_g if active_start else grid_s\n            counts_a = counts_s if active_start else counts_g\n            counts_b = counts_g if active_start else counts_s\n            bestcost_a = bestcost_s if active_start else bestcost_g\n            bestcost_b = bestcost_g if active_start else bestcost_s\n            root_other = goal if active_start else start\n\n            x_rand = self._sample(obstacles, is_3d, start, goal, best_len, root_other)\n\n            n_near = self._nearest(grid_a, tree_a, x_rand)\n            x_new = self._steer(n_near.position, x_rand)\n            if not self._in_bounds(x_new):\n                continue\n            if self._is_in_obstacle(x_new, obstacles, is_3d):\n                continue\n            if self._edge_blocked(n_near.position, x_new, obstacles, is_3d):\n                continue\n            if self._near_duplicate(grid_a, x_new, self.min_sep):\n                continue\n\n            r_near = max(self.neighbor_radius_factor * self.step_size, self.step_size)\n            neigh = self._near(grid_a, x_new, r_near)\n            parent, new_cost = self._choose_parent(neigh, n_near, x_new, obstacles, is_3d)\n\n            key_new = self._grid_key(x_new)\n            ccount = counts_a.get(key_new, 0)\n            bestc = bestcost_a.get(key_new, float('inf'))\n            if ccount >= self.max_per_cell and not (new_cost + 1e-12 < bestc):\n                continue\n\n            new_node = Node(x_new, None, new_cost)\n            new_node.attach(parent)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid_a, counts_a, bestcost_a, new_node)\n\n            if neigh:\n                self._rewire(new_node, neigh, obstacles, is_3d, edges)\n\n            meet_b, bridged = self._connect_toward(tree_b, grid_b, counts_b, bestcost_b, new_node.position, obstacles, is_3d)\n            if meet_b is None:\n                meet_candidate = self._nearest(grid_b, tree_b, new_node.position)\n                if meet_candidate is not None and not self._edge_blocked(new_node.position, meet_candidate.position, obstacles, is_3d):\n                    meet_b = meet_candidate\n                    bridged = True\n\n            if bridged and meet_b is not None:\n                if active_start:\n                    a = new_node\n                    b = meet_b\n                else:\n                    a = meet_b\n                    b = new_node\n                if not self._edge_blocked(a.position, b.position, obstacles, is_3d):\n                    edges.append((a, b))\n                    path = self._extract_path(a, b)\n                    path = self._visibility_prune(path, obstacles, is_3d)\n                    path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _uniform_point(self):\n        if self.dim == 3:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]),\n                    self._uniform(0.0, self.bounds[2]))\n        else:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]))\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-12:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        if k in self._edge_cache:\n            return self._edge_cache[k]\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._grid_key(node.position)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n        counts[k] = counts.get(k, 0) + 1\n        prev = bestcost.get(k, None)\n        if prev is None or node.cost < prev:\n            bestcost[k] = node.cost\n\n    def _grid_collect_ring(self, grid, key, r):\n        cand = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        return cand\n\n    def _nearest(self, grid, nodes, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        cand_total = []\n        r = 0\n        max_r = 4\n        while r <= max_r and len(cand_total) < 12:\n            cand_total.extend(self._grid_collect_ring(grid, key, r))\n            r += 1\n        if cand_total:\n            for n in cand_total:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            return best\n        if nodes:\n            trials = min(64, len(nodes))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(nodes)))\n                n = nodes[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _near(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        rng = int(max(1, radius // self.cell_size)) + 1\n        cand = []\n        if self.dim == 3:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        cand = self._grid_collect_ring(grid, key, 1)\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                return True\n        return False\n\n    def _choose_parent(self, neighbors, fallback_near, new_pos, obstacles, is_3d):\n        best_parent = fallback_near\n        best_cost = fallback_near.cost + self._dist(fallback_near.position, new_pos)\n        for n in neighbors:\n            if n is fallback_near:\n                continue\n            if not self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                c = n.cost + self._dist(n.position, new_pos)\n                if c + 1e-12 < best_cost:\n                    best_cost = c\n                    best_parent = n\n        return best_parent, best_cost\n\n    def _can_rewire(self, node, new_parent):\n        cur = new_parent\n        while cur is not None:\n            if cur is node:\n                return False\n            cur = cur.parent\n        return True\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                edges.pop(i)\n                break\n\n    def _propagate_cost(self, node, edges, depth):\n        if depth <= 0:\n            return\n        for ch in node.children:\n            old = ch.cost\n            ch.cost = node.cost + self._dist(node.position, ch.position)\n            if abs(ch.cost - old) > 1e-12:\n                self._propagate_cost(ch, edges, depth - 1)\n\n    def _rewire(self, new_node, neighbors, obstacles, is_3d, edges):\n        if not neighbors:\n            return\n        cand = []\n        for n in neighbors:\n            if n is new_node or n is new_node.parent:\n                continue\n            cand.append((self._dist(n.position, new_node.position), n))\n        cand.sort(key=lambda t: t[0])\n        limit = min(self.rewire_k, len(cand))\n        for i in range(limit):\n            n = cand[i][1]\n            if not self._can_rewire(n, new_node):\n                continue\n            if self._edge_blocked(new_node.position, n.position, obstacles, is_3d):\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, n.position)\n            if new_cost + 1e-12 < n.cost:\n                old_parent = n.parent\n                n.attach(new_node)\n                n.cost = new_cost\n                if old_parent is not None:\n                    self._remove_edge(edges, old_parent, n)\n                edges.append((new_node, n))\n                self._propagate_cost(n, edges, self.rewire_depth)\n\n    def _extend_toward(self, tree, grid, counts, bestcost, target_pos, obstacles, is_3d):\n        current = self._nearest(grid, tree, target_pos)\n        last = current\n        for _ in range(self.connect_steps):\n            nxt = self._steer(current.position, target_pos)\n            if not self._in_bounds(nxt):\n                break\n            if self._is_in_obstacle(nxt, obstacles, is_3d):\n                break\n            if self._edge_blocked(current.position, nxt, obstacles, is_3d):\n                break\n            if self._near_duplicate(grid, nxt, self.min_sep):\n                break\n            r_near = max(self.neighbor_radius_factor * self.step_size, self.step_size)\n            neigh = self._near(grid, nxt, r_near)\n            parent, new_cost = self._choose_parent(neigh, current, nxt, obstacles, is_3d)\n            key_new = self._grid_key(nxt)\n            ccount = counts.get(key_new, 0)\n            bestc = bestcost.get(key_new, float('inf'))\n            if ccount >= self.max_per_cell and not (new_cost + 1e-12 < bestc):\n                break\n            newn = Node(nxt, None, new_cost)\n            newn.attach(parent)\n            tree.append(newn)\n            self._grid_add(grid, counts, bestcost, newn)\n            last = newn\n            current = newn\n            if self._dist(nxt, target_pos) <= self.step_size:\n                break\n        return last\n\n    def _connect_toward(self, tree_b, grid_b, counts_b, bestcost_b, a_pos, obstacles, is_3d):\n        last = self._extend_toward(tree_b, grid_b, counts_b, bestcost_b, a_pos, obstacles, is_3d)\n        if last is None:\n            return None, False\n        if not self._edge_blocked(last.position, a_pos, obstacles, is_3d):\n            return last, True\n        return last, False\n\n    def _path_to_root(self, node):\n        seq = []\n        cur = node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _extract_path(self, meet_a, meet_b):\n        pa = self._path_to_root(meet_a)\n        pb = []\n        cur = meet_b\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        return pa + pb\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        n = len(path)\n        i = 0\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts\n\n    def _sample(self, obstacles, is_3d, start, goal, best_len, attractor):\n        r = self._rand()\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        if best_len < float('inf'):\n            for _ in range(self.informed_tries):\n                p = self._uniform_point()\n                if self._dist(p, start) + self._dist(p, goal) <= best_len and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jit = 0.5 * self.step_size\n            if self.dim == 3:\n                p = (self._clamp((base[0] + self._uniform(-jit, jit), base[1] + self._uniform(-jit, jit), base[2] + self._uniform(-jit, jit))))\n            else:\n                p = (min(max(base[0] + self._uniform(-jit, jit), 0.0), self.bounds[0]),\n                     min(max(base[1] + self._uniform(-jit, jit), 0.0), self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        while True:\n            p = self._uniform_point()\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p",
                "objective": -35.01262,
                "time_improvement": 55.0,
                "length_improvement": 20.0,
                "smoothness_improvement": 1329.0,
                "node_improvement": 90.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.016425013542175293,
                        "num_nodes_avg": 47.0,
                        "path_length_avg": 154.62508050902176,
                        "smoothness_avg": 0.04071980109549708,
                        "success_improvement": 0.0,
                        "time_improvement": 33.4245918733191,
                        "node_improvement": 88.16419038025687,
                        "length_improvement": 15.247543181809576,
                        "smoothness_improvement": 537.3533116078908,
                        "objective_score": 21.86267002912093
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.04094517230987549,
                        "num_nodes_avg": 124.0,
                        "path_length_avg": 229.46535757937585,
                        "smoothness_avg": 0.08684323820145955,
                        "success_improvement": 0.0,
                        "time_improvement": 75.51881386278623,
                        "node_improvement": 91.66834643553047,
                        "length_improvement": 23.397858845899172,
                        "smoothness_improvement": 2134.539069579714,
                        "objective_score": 47.36705481427394
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.022255563735961915,
                        "num_nodes_avg": 88.0,
                        "path_length_avg": 119.3089523489693,
                        "smoothness_avg": 0.11130492356865981,
                        "success_improvement": 0.0,
                        "time_improvement": 55.909249570294364,
                        "node_improvement": 88.81118881118881,
                        "length_improvement": 20.760674731610354,
                        "smoothness_improvement": 1315.790412118499,
                        "objective_score": 35.80813177064702
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "cross_over",
            "algorithm_description": "QUIC-Star: Quantized-Edge Informed Connect RRT* \u2014 a bidirectional planner that couples beam-guided sampling, quantized free/blocked edge caching, grid-accelerated nearest/near queries, per-cell cost gating, choose-parent with local rewiring (both trees), and opportunistic LOS grandparent compression. It attempts multi-step connects, updates best path early, and outputs a visibility-pruned, shortcut-smoothed path.",
            "planning_mechanism": "Alternate expanding start/goal trees. For each iteration, draw a small beam of samples biased to goal/line and, once a candidate path exists, to the informed prolate ellipsoid. For the best-scoring beam candidate, find nearest, steer, validate both node and edge, choose the cheapest parent among radius neighbors, insert under per-cell cost gates, optionally compress to grandparent via LOS, and locally rewire neighbors if cheaper. From the opposite tree, perform a short connect-extend toward the new node; if a clear bridge exists, extract, prune, and shortcut the path and return. Collision checks use a quantized edge cache to avoid redundant tests; neighbor queries use grid rings for sublinear performance.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 beam_k=3,\n                 goal_bias=0.22,\n                 line_bias=0.28,\n                 informed_tries=80,\n                 grid_cell_factor=1.4,\n                 max_per_cell=6,\n                 duplicate_radius_factor=0.45,\n                 neighbor_radius_factor=3.0,\n                 rewire_k=12,\n                 rewire_depth=6,\n                 connect_steps=7,\n                 smoothing_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.informed_tries = informed_tries\n        self.grid_cell_factor = grid_cell_factor\n        self.max_per_cell = max_per_cell\n        self.duplicate_radius_factor = duplicate_radius_factor\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.rewire_k = rewire_k\n        self.rewire_depth = rewire_depth\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        self.edge_res = max(0.5, min(1.0, 0.5 * self.step_size))\n        self.cache_bin = max(1.0, self.edge_res)\n        self.cell_size = max(1.0, self.grid_cell_factor * self.step_size)\n        self.min_sep = max(0.3, self.duplicate_radius_factor * self.step_size)\n\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n        # Early direct LOS\n        if not self._edge_blocked_cached(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            return PlannerResult(True, [start, goal], [s, g], [(s, g)])\n\n        s_root = Node(start, None, 0.0)\n        g_root = Node(goal, None, 0.0)\n\n        start_tree = [s_root]\n        goal_tree = [g_root]\n        nodes_out = [s_root, g_root]\n        edges_out = []\n\n        grid_s = {}\n        grid_g = {}\n        counts_s = {}\n        counts_g = {}\n        bestcost_s = {}\n        bestcost_g = {}\n\n        self._grid_add(grid_s, counts_s, bestcost_s, s_root)\n        self._grid_add(grid_g, counts_g, bestcost_g, g_root)\n\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_s if active_start else grid_g\n            grid_b = grid_g if active_start else grid_s\n            counts_a = counts_s if active_start else counts_g\n            counts_b = counts_g if active_start else counts_s\n            bestcost_a = bestcost_s if active_start else bestcost_g\n            bestcost_b = bestcost_g if active_start else bestcost_s\n            attractor = goal if active_start else start\n\n            # Beam: pick candidate that minimizes estimated total length\n            cand_parent = None\n            cand_pos = None\n            cand_cost = None\n            cand_score = float('inf')\n\n            for _ in range(self.beam_k):\n                x_rand = self._sample(obstacles, is_3d, start, goal, best_len, attractor)\n                n_near = self._nearest(grid_a, tree_a, x_rand)\n                if n_near is None:\n                    continue\n                x_new = self._steer(n_near.position, x_rand)\n                if not self._in_bounds(x_new):\n                    continue\n                if self._is_in_obstacle(x_new, obstacles, is_3d):\n                    continue\n                if self._near_duplicate(grid_a, x_new, self.min_sep):\n                    continue\n                if self._edge_blocked_cached(n_near.position, x_new, obstacles, is_3d):\n                    continue\n\n                # Choose parent among neighbors\n                r_near = max(self.neighbor_radius_factor * self.step_size, self.step_size)\n                neigh = self._near(grid_a, x_new, r_near)\n                parent, new_cost = self._choose_parent(neigh, n_near, x_new, obstacles, is_3d)\n\n                # Per-cell gating\n                key_new = self._grid_key(x_new)\n                ccount = counts_a.get(key_new, 0)\n                bestc = bestcost_a.get(key_new, float('inf'))\n                if ccount >= self.max_per_cell and not (new_cost + 1e-12 < bestc):\n                    continue\n\n                # Heuristic score: cost-to-come + estimate to goal via opposite tree\n                near_b = self._nearest(grid_b, tree_b, x_new)\n                h = self._dist(x_new, near_b.position) if near_b is not None else self._dist(x_new, attractor)\n                score = new_cost + h\n                if score < cand_score:\n                    cand_score = score\n                    cand_parent = parent\n                    cand_pos = x_new\n                    cand_cost = new_cost\n\n            if cand_parent is None:\n                continue\n\n            # Final validations before adding node (both checks)\n            if not self._in_bounds(cand_pos):\n                continue\n            if self._is_in_obstacle(cand_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked_cached(cand_parent.position, cand_pos, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_node = Node(cand_pos, None, cand_cost)\n            new_node.attach(cand_parent)\n            tree_a.append(new_node)\n            nodes_out.append(new_node)\n            edges_out.append((cand_parent, new_node))\n            self._grid_add(grid_a, counts_a, bestcost_a, new_node)\n\n            # Opportunistic LOS grandparent compression (only if strictly cheaper)\n            gp = cand_parent.parent\n            if gp is not None:\n                if (not self._is_in_obstacle(gp.position, obstacles, is_3d)) and (not self._edge_blocked_cached(gp.position, new_node.position, obstacles, is_3d)):\n                    comp_cost = gp.cost + self._dist(gp.position, new_node.position)\n                    if comp_cost + 1e-12 < new_node.cost:\n                        old_parent = new_node.parent\n                        new_node.attach(gp)\n                        new_node.cost = comp_cost\n                        # Maintain edges list coherently\n                        self._remove_edge(edges_out, old_parent, new_node)\n                        edges_out.append((gp, new_node))\n                        # Update cell bestcost (monotonic decrease)\n                        key_new = self._grid_key(new_node.position)\n                        prev = bestcost_a.get(key_new, float('inf'))\n                        if new_node.cost + 1e-12 < prev:\n                            bestcost_a[key_new] = new_node.cost\n\n            # Local rewiring around new node\n            r_near = max(self.neighbor_radius_factor * self.step_size, self.step_size)\n            neigh = self._near(grid_a, new_node.position, r_near)\n            self._rewire(new_node, neigh, obstacles, is_3d, edges_out, bestcost_a)\n\n            # Try to connect from the opposite tree toward the new node\n            meet_b, bridged = self._connect_toward(tree_b, grid_b, counts_b, bestcost_b, new_node.position, obstacles, is_3d)\n            if meet_b is None:\n                # fallback: nearest bridge\n                meet_b = self._nearest(grid_b, tree_b, new_node.position)\n                if meet_b is not None and not self._edge_blocked_cached(meet_b.position, new_node.position, obstacles, is_3d):\n                    bridged = True\n\n            if bridged and meet_b is not None:\n                # Validate both endpoints and edge (both checks)\n                if self._is_in_obstacle(meet_b.position, obstacles, is_3d):\n                    continue\n                if self._is_in_obstacle(new_node.position, obstacles, is_3d):\n                    continue\n                if self._edge_blocked_cached(meet_b.position, new_node.position, obstacles, is_3d):\n                    continue\n                edges_out.append((meet_b, new_node) if active_start else (new_node, meet_b))\n                a = new_node if active_start else meet_b\n                b = meet_b if active_start else new_node\n                path = self._extract_path(a, b)\n                # Prune and smooth\n                path = self._visibility_prune(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges_out)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges_out)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _uniform_point(self):\n        if self.dim == 3:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]),\n                    self._uniform(0.0, self.bounds[2]))\n        else:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]))\n\n    # Geometry / distance\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-12:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_blocked_cached(self, a, b, obstacles, is_3d):\n        k = self._edge_key_q(a, b)\n        cached = self._edge_cache.get(k, None)\n        if cached is not None:\n            return cached\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    # Grid and neighbors\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._grid_key(node.position)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n        counts[k] = counts.get(k, 0) + 1\n        prev = bestcost.get(k, None)\n        if prev is None or node.cost + 1e-12 < prev:\n            bestcost[k] = node.cost\n\n    def _grid_collect_ring(self, grid, key, r):\n        cand = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        return cand\n\n    def _nearest(self, grid, nodes, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        cand_total = []\n        r = 0\n        max_r = 4\n        while r <= max_r and len(cand_total) < 16:\n            cand_total.extend(self._grid_collect_ring(grid, key, r))\n            r += 1\n        if cand_total:\n            for n in cand_total:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            return best\n        # Sparse fallback: random probes\n        if nodes:\n            trials = min(64, len(nodes))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(nodes)))\n                n = nodes[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _near(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        rng = int(max(1, radius // self.cell_size)) + 1\n        cand = []\n        if self.dim == 3:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                out.append(n)\n        return out\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        cand = self._grid_collect_ring(grid, key, 1)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # Parent selection and rewiring\n    def _choose_parent(self, neighbors, fallback_near, new_pos, obstacles, is_3d):\n        best_parent = fallback_near\n        best_cost = fallback_near.cost + self._dist(fallback_near.position, new_pos)\n        for n in neighbors:\n            if n is fallback_near:\n                continue\n            if self._is_in_obstacle(n.position, obstacles, is_3d):\n                continue\n            if self._edge_blocked_cached(n.position, new_pos, obstacles, is_3d):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-12 < best_cost:\n                best_cost = c\n                best_parent = n\n        return best_parent, best_cost\n\n    def _can_rewire(self, node, new_parent):\n        cur = new_parent\n        while cur is not None:\n            if cur is node:\n                return False\n            cur = cur.parent\n        return True\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                edges.pop(i)\n                break\n\n    def _propagate_cost(self, node, depth, bestcost):\n        if depth <= 0:\n            return\n        for ch in node.children:\n            old = ch.cost\n            ch.cost = node.cost + self._dist(node.position, ch.position)\n            if ch.cost + 1e-12 < old or abs(ch.cost - old) > 1e-12:\n                # Update cell bestcost (costs may decrease)\n                key = self._grid_key(ch.position)\n                prev = bestcost.get(key, float('inf'))\n                if ch.cost + 1e-12 < prev:\n                    bestcost[key] = ch.cost\n                self._propagate_cost(ch, depth - 1, bestcost)\n\n    def _rewire(self, new_node, neighbors, obstacles, is_3d, edges, bestcost):\n        if not neighbors:\n            return\n        cand = []\n        for n in neighbors:\n            if n is new_node or n is new_node.parent:\n                continue\n            cand.append((self._dist(n.position, new_node.position), n))\n        cand.sort(key=lambda t: t[0])\n        limit = min(self.rewire_k, len(cand))\n        for i in range(limit):\n            n = cand[i][1]\n            if self._is_in_obstacle(n.position, obstacles, is_3d):\n                continue\n            if not self._can_rewire(n, new_node):\n                continue\n            if self._edge_blocked_cached(new_node.position, n.position, obstacles, is_3d):\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, n.position)\n            if new_cost + 1e-12 < n.cost:\n                old_parent = n.parent\n                n.attach(new_node)\n                n.cost = new_cost\n                if old_parent is not None:\n                    self._remove_edge(edges, old_parent, n)\n                edges.append((new_node, n))\n                # Update cell bestcost (monotonic decrease)\n                key = self._grid_key(n.position)\n                prev = bestcost.get(key, float('inf'))\n                if new_cost + 1e-12 < prev:\n                    bestcost[key] = new_cost\n                self._propagate_cost(n, self.rewire_depth, bestcost)\n\n    # Connect/extend\n    def _extend_toward(self, tree, grid, counts, bestcost, target_pos, obstacles, is_3d):\n        current = self._nearest(grid, tree, target_pos)\n        last = current\n        for _ in range(self.connect_steps):\n            nxt = self._steer(current.position, target_pos)\n            if not self._in_bounds(nxt):\n                break\n            if self._is_in_obstacle(nxt, obstacles, is_3d):\n                break\n            if self._near_duplicate(grid, nxt, self.min_sep):\n                break\n            if self._edge_blocked_cached(current.position, nxt, obstacles, is_3d):\n                break\n\n            # choose parent among neighbors for connect step\n            r_near = max(self.neighbor_radius_factor * self.step_size, self.step_size)\n            neigh = self._near(grid, nxt, r_near)\n            parent, new_cost = self._choose_parent(neigh, current, nxt, obstacles, is_3d)\n\n            # per-cell gating\n            key_new = self._grid_key(nxt)\n            ccount = counts.get(key_new, 0)\n            bestc = bestcost.get(key_new, float('inf'))\n            if ccount >= self.max_per_cell and not (new_cost + 1e-12 < bestc):\n                break\n\n            # Final checks before adding the node/edge\n            if self._is_in_obstacle(parent.position, obstacles, is_3d):\n                break\n            if self._edge_blocked_cached(parent.position, nxt, obstacles, is_3d):\n                break\n\n            newn = Node(nxt, None, new_cost)\n            newn.attach(parent)\n            tree.append(newn)\n            self._grid_add(grid, counts, bestcost, newn)\n            last = newn\n            current = newn\n            if self._dist(nxt, target_pos) <= self.step_size:\n                break\n        return last\n\n    def _connect_toward(self, tree_b, grid_b, counts_b, bestcost_b, a_pos, obstacles, is_3d):\n        if not tree_b:\n            return None, False\n        last = self._extend_toward(tree_b, grid_b, counts_b, bestcost_b, a_pos, obstacles, is_3d)\n        if last is None:\n            return None, False\n        if not self._edge_blocked_cached(last.position, a_pos, obstacles, is_3d):\n            return last, True\n        return last, False\n\n    # Paths and smoothing\n    def _path_to_root(self, node):\n        seq = []\n        cur = node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _extract_path(self, meet_a, meet_b):\n        pa = self._path_to_root(meet_a)\n        pb = []\n        cur = meet_b\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        return pa + pb\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        n = len(path)\n        i = 0\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked_cached(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked_cached(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        # Final forward collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            anchor = pts[0]\n            for k in range(1, len(pts) - 1):\n                if self._edge_blocked_cached(anchor, pts[k + 1], obstacles, is_3d):\n                    collapsed.append(pts[k])\n                    anchor = pts[k]\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts\n\n    # Sampling\n    def _sample(self, obstacles, is_3d, start, goal, best_len, attractor):\n        r = self._rand()\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Informed prolate ellipsoid sampling if a path exists\n        if best_len < float('inf'):\n            for _ in range(self.informed_tries):\n                # rejection in bounding box\n                p = self._uniform_point()\n                if self._dist(p, start) + self._dist(p, goal) <= best_len and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n        # Line bias with jitter around start-goal segment\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jit = 0.6 * self.step_size\n            if self.dim == 3:\n                p = (min(max(base[0] + self._uniform(-jit, jit), 0.0), self.bounds[0]),\n                     min(max(base[1] + self._uniform(-jit, jit), 0.0), self.bounds[1]),\n                     min(max(base[2] + self._uniform(-jit, jit), 0.0), self.bounds[2]))\n            else:\n                p = (min(max(base[0] + self._uniform(-jit, jit), 0.0), self.bounds[0]),\n                     min(max(base[1] + self._uniform(-jit, jit), 0.0), self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Uniform fallback\n        while True:\n            p = self._uniform_point()\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p",
            "objective": -12.45599,
            "time_improvement": -19.0,
            "length_improvement": 21.0,
            "smoothness_improvement": 1172.0,
            "node_improvement": 85.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024823760986328124,
                    "num_nodes_avg": 45.0,
                    "path_length_avg": 152.2569450236729,
                    "smoothness_avg": 0.03434339152796622,
                    "success_improvement": 0.0,
                    "time_improvement": 9.99968017066785,
                    "node_improvement": 88.66784185343742,
                    "length_improvement": 16.54555576683742,
                    "smoothness_improvement": 437.5486552810345,
                    "objective_score": 15.114980787707978
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06445107460021973,
                    "num_nodes_avg": 125.0,
                    "path_length_avg": 223.22379543278936,
                    "smoothness_avg": 0.0863747761396638,
                    "success_improvement": 0.0,
                    "time_improvement": 61.05179744376999,
                    "node_improvement": 91.6011556809783,
                    "length_improvement": 25.481471943834975,
                    "smoothness_improvement": 2122.485203310125,
                    "objective_score": 44.21684841598261
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1185152530670166,
                    "num_nodes_avg": 197.0,
                    "path_length_avg": 120.97733672593594,
                    "smoothness_avg": 0.08291606758357457,
                    "success_improvement": 0.0,
                    "time_improvement": -128.42956369493342,
                    "node_improvement": 74.95232040686585,
                    "length_improvement": 19.65261326835586,
                    "smoothness_improvement": 954.6862594355925,
                    "objective_score": -21.963869850288546
                }
            ],
            "success_rate": 1.0
        },
        "objective": 12.2,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Expansion scoring favors proximity to the opposite tree over total path cost, steering growth into longer detours\n   - Missing or limited use of choose-parent and shallow/one-sided rewiring, leaving many nodes attached to suboptimal parents\n   - Greedy connect attaches via the current tip without neighbor-based parent selection, producing costlier bridges\n   - Coarse node spacing (large separation/cell sizes) restricts densification around bends and increases polyline length\n   - Early return on first feasible bridge without additional cross-tree optimization\n   - Smoothing is short and relies mainly on basic visibility/shortcutting, leaving residual kinks and extra waypoints\n   - Per-cell cost gates are not consistently updated after cost changes, allowing higher-cost nodes to persist"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Beam selection scored by cost-to-come plus an estimated cost-to-go via the opposite tree\n   - Neighbor-based choose-parent at insertion and during connect steps, with local rewiring and deeper cost propagation\n   - Opportunistic line-of-sight grandparent compression applied only when it strictly reduces cost\n   - Per-cell best-cost gating maintained during rewires and compressions to reject higher-cost insertions\n   - Increased node density via smaller duplicate radius/cell size, enabling tighter turns\n   - Stronger post-processing: visibility pruning followed by more shortcut iterations\n2. Expected mechanism of impact:\n   - Total-cost-guided expansion biases growth into shorter corridors and away from detours\n   - Choose-parent and rewiring reduce cost-to-come and open lower-cost bridges between trees\n   - Grandparent compression straightens segments by skipping unnecessary waypoints, cutting path length\n   - Accurate best-cost gates prevent proliferation of expensive nodes, keeping the tree cost-focused\n   - Denser sampling captures tighter curvature, which pruning/shortcutting then consolidates into shorter polylines\n   - Parent-aware connect produces cheaper joining segments, further reducing final path length"
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "SAGE-Connect*: Simple Adaptive Grid Explorer with Informed Bidirectional Growth, Gentle Rewiring, and Fast Smoothing. It builds two trees from start and goal using a compact spatial hash, adaptive neighbor radius, LOS-aware stepping, lightweight k-best parenting, capped local rewiring, and a restrained greedy connect. Once a valid bridge is found, the path is shortcut-pruned and elastically smoothed with collision-aware line search for robust, short, and smooth trajectories.",
                "planning_mechanism": "Alternate expanding start/goal trees. Each iteration: draw a target (goal/segment/uniform; switch to informed-ellipse once a path exists), pick nearest via grid, steer with LOS-adaptive step, enforce node and edge collision checks, suppress duplicates, select a low-cost parent from nearby nodes, add the node, and locally rewire a few neighbors if the new route is cheaper (cycle-safe, edge-checked). Attempt a short greedy connect from the other tree; on success, assemble the bidirectional path, then apply shortcutting and visibility pruning followed by elastic midpoint smoothing before returning.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step=6.0,\n        connect_factor=1.9,\n        goal_bias=0.16,\n        line_bias=0.22,\n        informed_bias=0.45,\n        grid_cell_factor=1.6,\n        neighbor_radius_scale=3.0,\n        dupe_ratio=0.4,\n        rewire_cap=12,\n        connect_steps=12,\n        shortcut_attempts=90,\n        smooth_passes=6\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.connect_step = float(step * connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_radius_scale = float(neighbor_radius_scale)\n        self.dupe_ratio = float(dupe_ratio)\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(1, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 123456789\n        self._eindex = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._eindex = {}\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            self._edges_add(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Trees and grids\n        Ta, Tb = [], []\n        Ga, Gb = {}, {}\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta.append(start_root)\n        Tb.append(goal_root)\n        nodes.extend([start_root, goal_root])\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            # Sample a common target for both directions for coherence\n            sample = self._sample_target(best_len)\n            if sample is None:\n                continue\n\n            # Expand from start side\n            res = self._expand_and_maybe_connect(Ta, Ga, Tb, Gb, sample, nodes, edges)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n            # Expand from goal side\n            res = self._expand_and_maybe_connect(Tb, Gb, Ta, Ga, sample, nodes, edges)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # Core expansion and connection\n    def _expand_and_maybe_connect(self, Ta, Ga, Tb, Gb, target, nodes, edges):\n        na = self._nearest(Ga, target)\n        if na is None:\n            return None\n        q_new = self._steer_dynamic(na.position, target)\n        if (not self._in_bounds(q_new)) or self._point_blocked(q_new):\n            return None\n        if self._too_close(Ga, q_new, self.dupe_radius):\n            return None\n\n        parent = self._select_parent(Ga, q_new, na)\n        if parent is None:\n            return None\n        # Both checks before adding node/edge\n        if self._point_blocked(q_new) or (not self._edge_free(parent.position, q_new)):\n            return None\n\n        cost = parent.cost + self._dist(parent.position, q_new)\n        nn = Node(q_new, parent, cost)\n        parent.add_child(nn)\n        Ta.append(nn)\n        nodes.append(nn)\n        self._grid_add(Ga, nn)\n        self._edges_add(edges, parent, nn)\n\n        # Gentle local rewiring\n        if self.rewire_cap > 0:\n            self._rewire_neighbors(Ga, nn, edges, self.rewire_cap)\n\n        # Try greedy connect from the opposite tree\n        meet, ok = self._greedy_connect(Tb, Gb, nn.position, nodes, edges)\n        if ok:\n            pa = nn.path_to_root()\n            pb = meet.path_to_root()\n            # Determine which root belongs to which\n            if Ta[0].position == self.start:\n                # pa: start->..., pb: goal->...\n                path = pa + pb[-2::-1]\n            else:\n                # pa: goal->..., pb: start->...\n                path = pb + pa[-2::-1]\n            L = self._path_len(path)\n            return (self._dedup(path), L)\n        return None\n\n    # RNG\n    def _seed_rng(self):\n        s = 2166136261\n        for v in self.start + self.goal:\n            s ^= int(v * 10007 + 0.5) & 0xffffffff\n            s = (s * 16777619) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Sampling\n    def _sample_target(self, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._sample_informed_ellipse(self.start, self.goal, best_len * 1.01)\n            if p is not None and self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return self.goal\n        if r2 < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t,\n                     self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t)\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_informed_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and (not self._point_blocked(p)):\n                return p\n        return None\n\n    # Geometry helpers\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(self._lerp(a, b, r))\n\n    def _steer_dynamic(self, a, b):\n        if self._edge_free(a, b):\n            d = self._dist(a, b)\n            step = self.connect_step if d > self.connect_step else d\n            return self._steer(a, b, step)\n        return self._steer(a, b, self.step)\n\n    # Node grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n            if best is not None:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        seen = {}\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            i2 = id(n)\n                            if i2 in seen:\n                                continue\n                            seen[i2] = True\n                            d2 = 0.0\n                            p = n.position\n                            for i in range(self.dim):\n                                di = p[i] - pos[i]\n                                d2 += di * di\n                            if d2 <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        i2 = id(n)\n                        if i2 in seen:\n                            continue\n                        seen[i2] = True\n                        d2 = 0.0\n                        p = n.position\n                        for i in range(self.dim):\n                            di = p[i] - pos[i]\n                            d2 += di * di\n                        if d2 <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _adaptive_radius(self, n_nodes):\n        t = float(max(1, n_nodes))\n        base = 1.2 * self.step\n        extra = self.neighbor_radius_scale * self.step / ((1.0 + t) ** (1.0 / 3.0))\n        r = base + extra\n        if r < 1.05 * self.step:\n            r = 1.05 * self.step\n        return r\n\n    def _too_close(self, grid, pos, radius):\n        nb = self._neighbors_within(grid, pos, radius, 1)\n        return len(nb) > 0\n\n    # Parent selection\n    def _select_parent(self, grid, newp, fallback_near):\n        r = self._adaptive_radius(len(grid))\n        neigh = self._neighbors_within(grid, newp, r, 96)\n        best = fallback_near\n        best_cost = fallback_near.cost + self._dist(fallback_near.position, newp)\n        for n in neigh:\n            if n is fallback_near:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = c\n        return best\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _rewire_neighbors(self, grid, node, edges, cap):\n        r = self._adaptive_radius(len(grid))\n        neigh = self._neighbors_within(grid, node.position, r, 128)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            if self._point_blocked(nb.position) or self._point_blocked(node.position):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            newc = node.cost + self._dist(node.position, nb.position)\n            if newc + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= cap:\n                    break\n\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        if self._point_blocked(child.position) or self._point_blocked(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._edges_remove(edges, old, child)\n        new_parent.add_child(child)\n        self._edges_add(edges, new_parent, child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            for c in n.children:\n                stack.append(c)\n\n    # Greedy connect\n    def _greedy_connect(self, T, G, target_pos, nodes, edges):\n        cur = self._nearest(G, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < self.connect_steps:\n            # Visible? insert exact meeting point\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                    if not self._too_close(G, target_pos, 0.75 * self.dupe_radius):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                            return cur, True\n                        cur.add_child(nn)\n                        T.append(nn)\n                        nodes.append(nn)\n                        self._grid_add(G, nn)\n                        self._edges_add(edges, cur, nn)\n                        return nn, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(G, nxt, 0.75 * self.dupe_radius):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                return cur, False\n            cur.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            self._grid_add(G, nn)\n            self._edges_add(edges, cur, nn)\n            cur = nn\n            steps += 1\n        # Final visibility check\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                if not self._too_close(G, target_pos, 0.75 * self.dupe_radius):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                        return cur, True\n                    cur.add_child(nn)\n                    T.append(nn)\n                    nodes.append(nn)\n                    self._grid_add(G, nn)\n                    self._edges_add(edges, cur, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(3.5, self.step * 1.6)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Edge bookkeeping\n    def _edges_add(self, edges, parent, child):\n        key = (id(parent), id(child))\n        if key in self._eindex:\n            return\n        edges.append((parent, child))\n        self._eindex[key] = len(edges) - 1\n\n    def _edges_remove(self, edges, parent, child):\n        key = (id(parent), id(child))\n        idx = self._eindex.get(key)\n        if idx is None:\n            return\n        last = len(edges) - 1\n        if idx != last:\n            edges[idx] = edges[last]\n            pk, ck = id(edges[idx][0]), id(edges[idx][1])\n            self._eindex[(pk, ck)] = idx\n        edges.pop()\n        self._eindex.pop(key, None)\n\n    # Path utilities and smoothing\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _elastic_smooth(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                target = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                t = 1.0\n                best = b\n                while t > 1e-3:\n                    cand = tuple(b[k] + (target[k] - b[k]) * t for k in range(self.dim))\n                    cand = self._clamp(cand)\n                    if (not self._point_blocked(cand)) and self._edge_free(a, cand) and self._edge_free(cand, c):\n                        best = cand\n                        break\n                    t *= 0.5\n                if best != b:\n                    cur[i] = best\n                    moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._shortcut(path, self.shortcut_attempts)\n        p2 = self._visibility_prune(p1)\n        p3 = self._elastic_smooth(p2, self.smooth_passes)\n        return self._dedup(p3)",
                "objective": -47.53913,
                "time_improvement": 86.0,
                "length_improvement": 21.0,
                "smoothness_improvement": 1812.0,
                "node_improvement": 93.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.004579019546508789,
                        "num_nodes_avg": 30.0,
                        "path_length_avg": 146.96078572191126,
                        "smoothness_avg": 0.03859037591406768,
                        "success_improvement": 0.0,
                        "time_improvement": 81.43988774523116,
                        "node_improvement": 92.44522790229162,
                        "length_improvement": 19.448464603147585,
                        "smoothness_improvement": 504.0231833977275,
                        "objective_score": 38.621161002446534
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.023305273056030272,
                        "num_nodes_avg": 122.0,
                        "path_length_avg": 229.66193713526982,
                        "smoothness_avg": 0.11885248032537557,
                        "success_improvement": 0.0,
                        "time_improvement": 86.065738755588,
                        "node_improvement": 91.80272794463482,
                        "length_improvement": 23.332234931912975,
                        "smoothness_improvement": 2958.1599247532718,
                        "objective_score": 54.609862209590545
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.004154682159423828,
                        "num_nodes_avg": 32.0,
                        "path_length_avg": 120.49632735979439,
                        "smoothness_avg": 0.1630888303105967,
                        "success_improvement": 0.0,
                        "time_improvement": 91.76911192279043,
                        "node_improvement": 95.93134138588684,
                        "length_improvement": 19.972076786142434,
                        "smoothness_improvement": 1974.4778835855395,
                        "objective_score": 49.38636906645029
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "path_expert",
            "algorithm_description": "L-IRRT* Dual: Length-focused Informed Bidirectional RRT* with Exact-Join, Ancestor Shortcuts, and Tight Visibility Pruning. It grows two trees with proper RRT*-style neighbor radii based on node counts (not grid cells), selects the true best-cost parent from a sorted candidate set, performs cycle-safe rewiring, applies immediate ancestor line-of-sight shortcuts to collapse detours, and only bridges trees with an exact meeting node to preserve a verified straight join. The best path is finalized by deterministic visibility funneling, randomized chord shortcutting, and elastic moves that only reduce local length.",
            "planning_mechanism": "Alternate expanding start/goal trees. Each expansion: sample (goal/line/uniform; switch to informed ellipse once a solution exists), find nearest via a compact grid, steer with LOS-adaptive step, enforce both node and edge collision checks, reject near-duplicates, pick the lowest cost parent among neighbors within a radius driven by the tree\u2019s node count, add the node, rewire cheaper neighbors, then try to connect to the opposite tree. A direct visible bridge inserts the exact meeting node into the opposite tree; otherwise a short greedy approach is attempted. Upon a successful bridge, assemble start\u2192meet\u2192goal using the exact join. Before returning, run visibility funneling, targeted random shortcutting, an elastic band that only accepts length reductions, and a final visibility pass.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step=6.0,\n        connect_factor=2.0,\n        goal_bias=0.2,\n        line_bias=0.3,\n        informed_bias=0.6,\n        grid_cell_factor=1.5,\n        dupe_ratio=0.35,\n        neighbor_cap=128,\n        rewire_cap=64,\n        connect_steps=8,\n        shortcut_attempts=140,\n        smooth_passes=4\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.connect_step = float(step * connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dupe_ratio = float(dupe_ratio)\n        self.neighbor_cap = int(max(8, neighbor_cap))\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(1, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 123456789\n        self._eindex = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._eindex = {}\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            self._edges_add(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        Ta, Tb = [], []\n        Ga, Gb = {}, {}\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta.append(start_root)\n        Tb.append(goal_root)\n        nodes.extend([start_root, goal_root])\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n\n        best_len = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            # Sample once per pair of expansions to keep both trees coherent\n            sample = self._sample_target(best_len)\n\n            res = self._expand_and_maybe_connect(Ta, Ga, Tb, Gb, sample, nodes, edges, best_len)\n            if res is not None:\n                path, L = res\n                if L < best_len:\n                    best_len = L\n                    best_path = path\n                    final = self._finalize_path(best_path)\n                    return PlannerResult(True, final, nodes, edges)\n\n            res = self._expand_and_maybe_connect(Tb, Gb, Ta, Ga, sample, nodes, edges, best_len)\n            if res is not None:\n                path, L = res\n                if L < best_len:\n                    best_len = L\n                    best_path = path\n                    final = self._finalize_path(best_path)\n                    return PlannerResult(True, final, nodes, edges)\n\n        if best_path is not None:\n            final = self._finalize_path(best_path)\n            return PlannerResult(True, final, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _expand_and_maybe_connect(self, Ta, Ga, Tb, Gb, target, nodes, edges, best_len):\n        na = self._nearest(Ga, target)\n        if na is None:\n            return None\n        q_new = self._steer_dynamic(na.position, target)\n        if (not self._in_bounds(q_new)) or self._point_blocked(q_new):\n            return None\n        if self._too_close(Ga, q_new, self.dupe_radius):\n            return None\n\n        parent = self._choose_parent(Ta, Ga, q_new, na, best_len)\n        if parent is None:\n            return None\n        if self._point_blocked(q_new) or (not self._edge_free(parent.position, q_new)):\n            return None\n\n        new_cost = parent.cost + self._dist(parent.position, q_new)\n        # Branch-and-bound against current best\n        if best_len < float('inf'):\n            if new_cost + self._dist(q_new, self._root_of(Tb).position) >= best_len * 1.0001:\n                pass\n\n        nn = Node(q_new, parent, new_cost)\n        parent.add_child(nn)\n        Ta.append(nn)\n        nodes.append(nn)\n        self._grid_add(Ga, nn)\n        self._edges_add(edges, parent, nn)\n\n        # Immediate ancestor shortcut (length-only, LOS-checked)\n        self._ancestor_shortcut(nn, edges)\n\n        # Local rewiring\n        if self.rewire_cap > 0:\n            self._rewire_neighbors(Ta, Ga, nn, edges, best_len)\n\n        # Attempt exact direct connect first\n        meet, ok = self._try_direct_bridge(Tb, Gb, nn.position, nodes, edges)\n        if ok:\n            pa = nn.path_to_root()\n            pb = meet.path_to_root()\n            path = self._assemble_path(Ta, pa, pb)\n            return (self._dedup(path), self._path_len(path))\n\n        # Short greedy connect if direct bridge fails\n        meet, ok = self._greedy_connect(Tb, Gb, nn.position, nodes, edges)\n        if ok:\n            pa = nn.path_to_root()\n            pb = meet.path_to_root()\n            path = self._assemble_path(Ta, pa, pb)\n            return (self._dedup(path), self._path_len(path))\n\n        return None\n\n    def _assemble_path(self, Ta, pa, pb):\n        # pa: rootA -> ... -> meet\n        # pb: rootB -> ... -> meet\n        if Ta and Ta[0].position == self.start:\n            # pa: start->meet, pb: goal->meet\n            return pa + pb[::-1][1:]\n        else:\n            # pa: goal->meet, pb: start->meet\n            q = pb + pa[::-1][1:]\n            # Ensure orientation start->goal\n            if q and q[0] != self.start:\n                q = q[::-1]\n            return q\n\n    # RNG\n    def _seed_rng(self):\n        s = 2166136261\n        for v in self.start + self.goal:\n            s ^= int(v * 10007 + 0.5) & 0xffffffff\n            s = (s * 16777619) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Sampling\n    def _sample_target(self, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._sample_informed_ellipse(self.start, self.goal, best_len * 1.0)\n            if p is not None:\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return self.goal\n        if r2 < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t,\n                     self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t)\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_informed_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(32):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and (not self._point_blocked(p)):\n                return p\n        return None\n\n    # Geometry helpers\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(self._lerp(a, b, r))\n\n    def _steer_dynamic(self, a, b):\n        if self._edge_free(a, b):\n            d = self._dist(a, b)\n            step = self.connect_step if d > self.connect_step else d\n            return self._steer(a, b, step)\n        return self._steer(a, b, self.step)\n\n    def _root_of(self, T):\n        return T[0] if T else None\n\n    # Node grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n            if best is not None:\n                return best\n        for lst in grid.values():\n            for n in lst:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        seen = {}\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            i2 = id(n)\n                            if i2 in seen:\n                                continue\n                            seen[i2] = True\n                            p = n.position\n                            d2 = 0.0\n                            for i in range(self.dim):\n                                di = p[i] - pos[i]\n                                d2 += di * di\n                            if d2 <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        i2 = id(n)\n                        if i2 in seen:\n                            continue\n                        seen[i2] = True\n                        p = n.position\n                        d2 = 0.0\n                        for i in range(self.dim):\n                            di = p[i] - pos[i]\n                            d2 += di * di\n                        if d2 <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _rrtstar_radius(self, n_nodes):\n        # Monotone shrinking radius based on node count (no log to avoid imports).\n        # Encourages short, high-quality connections and rewiring.\n        if n_nodes <= 1:\n            return self.step * 3.0\n        scale = self.step * 6.0\n        r = (scale / (float(n_nodes) ** (1.0 / max(2.0, float(self.dim))))) + 1.25 * self.step\n        if r < 1.05 * self.step:\n            r = 1.05 * self.step\n        return r\n\n    def _too_close(self, grid, pos, radius):\n        nb = self._neighbors_within(grid, pos, radius, 1)\n        return len(nb) > 0\n\n    # Parent selection with length-aware ordering\n    def _choose_parent(self, T, G, newp, fallback_near, best_len):\n        r = self._rrtstar_radius(len(T))\n        neigh = self._neighbors_within(G, newp, r, self.neighbor_cap)\n        # Order by tentative cost-to-come for fewer expensive checks\n        scored = []\n        base_best = fallback_near.cost + self._dist(fallback_near.position, newp)\n        for n in neigh:\n            c = n.cost + self._dist(n.position, newp)\n            scored.append((c, n))\n        scored.sort(key=lambda x: x[0])\n        best_parent = None\n        best_cost = 1e100\n        # Try neighbors first\n        for c, n in scored:\n            if c >= best_cost:\n                break\n            if self._edge_free(n.position, newp):\n                best_parent = n\n                best_cost = c\n                # continue to see if even cheaper exists\n        # Fallback to nearest if no neighbor valid\n        if best_parent is None:\n            if self._edge_free(fallback_near.position, newp):\n                best_parent = fallback_near\n                best_cost = base_best\n            else:\n                return None\n        # Branch-and-bound with best known path\n        if best_len < float('inf'):\n            if best_cost + self._dist(newp, self._root_of(T).position) >= best_len * 1.0001:\n                pass\n        return best_parent\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        if self._point_blocked(child.position) or self._point_blocked(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._edges_remove(edges, old, child)\n        new_parent.add_child(child)\n        self._edges_add(edges, new_parent, child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            for c in n.children:\n                stack.append(c)\n\n    def _ancestor_shortcut(self, node, edges):\n        # Try to attach to a visible ancestor that reduces cost\n        cur = node.parent.parent if node.parent else None\n        tries = 0\n        while cur is not None and tries < 8:\n            cand_cost = cur.cost + self._dist(cur.position, node.position)\n            if cand_cost + 1e-12 < node.cost:\n                if self._edge_free(cur.position, node.position):\n                    self._reparent(node, cur, edges)\n                    break\n            cur = cur.parent\n            tries += 1\n\n    def _rewire_neighbors(self, T, G, node, edges, best_len):\n        r = self._rrtstar_radius(len(T))\n        neigh = self._neighbors_within(G, node.position, r, self.neighbor_cap)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            if self._point_blocked(nb.position) or self._point_blocked(node.position):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            newc = node.cost + self._dist(node.position, nb.position)\n            # Bound by best path if any\n            if best_len < float('inf'):\n                if newc + self._dist(nb.position, self._root_of(T).position) >= best_len * 1.0001:\n                    continue\n            if newc + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= self.rewire_cap:\n                    break\n\n    # Bridge attempts\n    def _try_direct_bridge(self, T, G, target_pos, nodes, edges):\n        m = self._nearest(G, target_pos)\n        if m is None:\n            return None, False\n        if self._edge_free(m.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                if not self._too_close(G, target_pos, 0.6 * self.dupe_radius):\n                    new_cost = m.cost + self._dist(m.position, target_pos)\n                    nn = Node(target_pos, m, new_cost)\n                    if self._point_blocked(nn.position) or (not self._edge_free(m.position, nn.position)):\n                        return m, True\n                    m.add_child(nn)\n                    T.append(nn)\n                    nodes.append(nn)\n                    self._grid_add(G, nn)\n                    self._edges_add(edges, m, nn)\n                    return nn, True\n            return m, True\n        return m, False\n\n    def _greedy_connect(self, T, G, target_pos, nodes, edges):\n        cur = self._nearest(G, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < self.connect_steps:\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                    if not self._too_close(G, target_pos, 0.6 * self.dupe_radius):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                            return cur, True\n                        cur.add_child(nn)\n                        T.append(nn)\n                        nodes.append(nn)\n                        self._grid_add(G, nn)\n                        self._edges_add(edges, cur, nn)\n                        return nn, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(G, nxt, 0.6 * self.dupe_radius):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                return cur, False\n            cur.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            self._grid_add(G, nn)\n            self._edges_add(edges, cur, nn)\n            cur = nn\n            steps += 1\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                if not self._too_close(G, target_pos, 0.6 * self.dupe_radius):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                        return cur, True\n                    cur.add_child(nn)\n                    T.append(nn)\n                    nodes.append(nn)\n                    self._grid_add(G, nn)\n                    self._edges_add(edges, cur, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(3.5, self.step * 1.6)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Edge bookkeeping\n    def _edges_add(self, edges, parent, child):\n        key = (id(parent), id(child))\n        if key in self._eindex:\n            return\n        edges.append((parent, child))\n        self._eindex[key] = len(edges) - 1\n\n    def _edges_remove(self, edges, parent, child):\n        key = (id(parent), id(child))\n        idx = self._eindex.get(key)\n        if idx is None:\n            return\n        last = len(edges) - 1\n        if idx != last:\n            edges[idx] = edges[last]\n            pk, ck = id(edges[idx][0]), id(edges[idx][1])\n            self._eindex[(pk, ck)] = idx\n        edges.pop()\n        self._eindex.pop(key, None)\n\n    # Path utilities and length-focused smoothing\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_funnel(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            found = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    found = True\n                    break\n                j -= 1\n            if not found:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut_random(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _elastic_length_only(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            improved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                target = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                t = 1.0\n                best = b\n                best_gain = 0.0\n                base_len = self._dist(a, b) + self._dist(b, c)\n                while t > 1e-3:\n                    cand = tuple(b[k] + (target[k] - b[k]) * t for k in range(self.dim))\n                    cand = self._clamp(cand)\n                    if (not self._point_blocked(cand)) and self._edge_free(a, cand) and self._edge_free(cand, c):\n                        new_len = self._dist(a, cand) + self._dist(cand, c)\n                        gain = base_len - new_len\n                        if gain > 1e-6:\n                            best = cand\n                            best_gain = gain\n                            break\n                    t *= 0.5\n                if best != b and best_gain > 0.0:\n                    cur[i] = best\n                    improved = True\n            if not improved:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._visibility_funnel(path)\n        p2 = self._shortcut_random(p1, self.shortcut_attempts)\n        p3 = self._elastic_length_only(p2, self.smooth_passes)\n        p4 = self._visibility_funnel(p3)\n        return self._dedup(p4)",
            "objective": -42.26447,
            "time_improvement": 71.0,
            "length_improvement": 22.0,
            "smoothness_improvement": 1530.0,
            "node_improvement": 92.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012109470367431641,
                    "num_nodes_avg": 41.0,
                    "path_length_avg": 144.9927890038839,
                    "smoothness_avg": 0.03738562038885029,
                    "success_improvement": 0.0,
                    "time_improvement": 51.858978125989296,
                    "node_improvement": 89.67514479979855,
                    "length_improvement": 20.527154789201994,
                    "smoothness_improvement": 485.16614325957914,
                    "objective_score": 30.29981702761588
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02904365062713623,
                    "num_nodes_avg": 116.0,
                    "path_length_avg": 224.7502960068727,
                    "smoothness_avg": 0.0866795189248766,
                    "success_improvement": 0.0,
                    "time_improvement": 81.87158905210825,
                    "node_improvement": 92.20587247194786,
                    "length_improvement": 24.971882114323137,
                    "smoothness_improvement": 2130.3264546710066,
                    "objective_score": 50.196238257581385
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009520912170410156,
                    "num_nodes_avg": 47.0,
                    "path_length_avg": 119.70538546749144,
                    "smoothness_avg": 0.1631866982455984,
                    "success_improvement": 0.0,
                    "time_improvement": 80.40107188079743,
                    "node_improvement": 94.0241576605213,
                    "length_improvement": 20.497382730404468,
                    "smoothness_improvement": 1975.7227564949017,
                    "objective_score": 46.297364984956424
                }
            ],
            "success_rate": 1.0
        },
        "objective": 12.799999999999999,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Improperly scaled neighborhood radius and capped, unsorted neighbor sets lead to suboptimal parent selection and missed low-cost connections.\n   - Limited rewiring budget restricts propagation of cost improvements across the tree.\n   - Non-exact tree joining (splicing without the precise meeting node) introduces detours/kinks, inflating path length until post-smoothing.\n   - Greedy connection creates stair-stepped segments that persist when visibility cleanup is delayed or weak.\n   - Sampling biases insufficiently concentrate search within the informed corridor, slowing convergence to short routes.\n   - Post-processing order not strongly length-first, reducing the effectiveness of global visibility and shortcutting."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Node-count\u2013driven RRT*-style neighbor radius with cost-ordered parent selection to favor the true lowest-cost parent.\n   - Higher neighbor/rewiring capacity plus an ancestor line-of-sight shortcut to rapidly propagate cheaper connections and straighten segments.\n   - Exact meeting-node bridging and corrected path assembly to preserve a verified straight join between trees.\n   - Stronger informed/goal/line sampling biases to focus growth inside the near-optimal corridor.\n   - Length-first post-optimization pipeline (visibility funnel \u2192 randomized chord shortcuts \u2192 elastic length-only \u2192 final visibility) and a tighter duplicate threshold enabling finer refinement along the corridor.\n2. Expected mechanism of impact:\n   - More accurate and better-ordered parent choices increase straight, low-cost edges, reducing cumulative path length before smoothing.\n   - Expanded rewiring and ancestor shortcuts quickly replace detours with visible, cheaper connections, shrinking paths globally.\n   - Exact joins remove splice-induced detours, eliminating unnecessary waypoints at the tree bridge.\n   - Focused sampling increases the rate of near-straight connections across free space, accelerating convergence to shorter solutions.\n   - A length-focused smoothing order prunes long chords first and then refines locally, compounding length reductions while preserving visibility."
        }
    }
]