[
    {
        "operator": "e2",
        "algorithm_description": "Bi-Informed Dual-Tree RRT*-Connect with Adaptive Neighborhoods and Shortcut Smoothing: a bidirectional planner that alternates growing optimized trees from start and goal, uses adaptive near-radius rewiring, informed rejection sampling after the first solution, and a connection step akin to RRT-Connect, followed by fast shortcut smoothing.",
        "planning_mechanism": "Mechanism: alternate tree expansion with goal-biased, bounds-respecting sampling; steer a step, validate node and edge, choose the lowest-cost parent among adaptive-radius neighbors, rewire and propagate costs; attempt to connect to the opposite tree via progressive extensions; upon any feasible join, update the incumbent cost and restrict future samples to the prolate hyperspheroid defined by start, goal, and best cost; terminate after a post-optimization budget or stagnation and return a smoothed path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=5.0,\n                 base_radius=25.0,\n                 min_radius=6.0,\n                 goal_bias=0.12,\n                 post_opt_iters=800,\n                 max_no_improve=200,\n                 smoothing_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.goal_bias = goal_bias\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_cell = max(self.step_size, self.base_radius * 0.5)\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root, grid_cell)\n        self._grid_add(grid_goal, goal_root, grid_cell)\n\n        success = False\n        best_cost = float('inf')\n        best_join = (None, None)\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            active_first = (it % 2 == 0)\n            for which in (0, 1):\n                tree_a = start_tree if (active_first ^ (which == 1)) else goal_tree\n                tree_b = goal_tree if (tree_a is start_tree) else start_tree\n                grid_a = grid_start if (tree_a is start_tree) else grid_goal\n                grid_b = grid_goal if (tree_b is goal_tree) else grid_start\n\n                x_rand = self._sample(start, goal, best_cost, is_3d)\n                if self._rand() < self.goal_bias:\n                    x_rand = goal if (tree_a is start_tree) else start\n\n                x_nearest = self._nearest_grid(grid_a, tree_a, x_rand, grid_cell)\n                x_new_pos = self._steer(x_nearest.position, x_rand, self.step_size)\n\n                if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n                    continue\n                if self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n                    continue\n\n                x_new = Node(x_new_pos)\n                n_nodes = len(tree_a) + 1\n                r_near = self._adaptive_radius(n_nodes)\n                near_nodes = self._near_grid(grid_a, x_new_pos, r_near, grid_cell)\n\n                best_parent = x_nearest\n                best_pc = x_nearest.cost + self._dist(x_nearest.position, x_new_pos)\n                for nn in near_nodes:\n                    cand_cost = nn.cost + self._dist(nn.position, x_new_pos)\n                    if cand_cost < best_pc and not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d):\n                        best_parent = nn\n                        best_pc = cand_cost\n\n                best_parent.add_child(x_new)\n                x_new.cost = best_pc\n                tree_a.append(x_new)\n                nodes.append(x_new)\n                edges.append((best_parent, x_new))\n                self._grid_add(grid_a, x_new, grid_cell)\n\n                for nn in near_nodes:\n                    alt = x_new.cost + self._dist(x_new.position, nn.position)\n                    if alt + 1e-12 < nn.cost and not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d):\n                        op = nn.parent\n                        if op is not None:\n                            try:\n                                edges.remove((op, nn))\n                            except:\n                                pass\n                            try:\n                                op.children.remove(nn)\n                            except:\n                                pass\n                        x_new.add_child(nn)\n                        nn.cost = alt\n                        edges.append((x_new, nn))\n                        self._propagate_costs_from(nn, edges)\n\n                connect_success, meet_a, meet_b = self._connect_trees(x_new, tree_b, grid_b, obstacles, is_3d, grid_cell, nodes, edges)\n                if connect_success:\n                    path_cost = meet_a.cost + self._dist(meet_a.position, meet_b.position) + meet_b.cost\n                    if path_cost + 1e-12 < best_cost:\n                        best_cost = path_cost\n                        best_join = (meet_a, meet_b)\n                        success = True\n                        found_first = True\n                        post_iters = 0\n                        no_improve = 0\n                    else:\n                        if found_first:\n                            post_iters += 1\n                            no_improve += 1\n                else:\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n\n                if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                    break\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        path = []\n        if success and best_join[0] is not None:\n            path = self._extract_path(best_join[0], best_join[1])\n            path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _rand(self):\n        try:\n            return random.random()\n        except:\n            # fallback LCG if random unavailable\n            if not hasattr(self, \"_lcg_state\"):\n                self._lcg_state = 1234567\n            self._lcg_state = (1103515245 * self._lcg_state + 12345) % (1 << 31)\n            return (self._lcg_state / float(1 << 31))\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = (a[i] - b[i])\n            s += d * d\n        return s ** 0.5\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        ratio = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(self.dim))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=1.0):\n        d = self._dist(a, b)\n        steps = int(d / resolution)\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _sample(self, start, goal, c_best, is_3d):\n        for _ in range(50):\n            p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n            if c_best < float('inf'):\n                if self._dist(p, start) + self._dist(p, goal) <= c_best and self._in_bounds(p):\n                    return p\n            else:\n                if self._in_bounds(p):\n                    return p\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _adaptive_radius(self, n):\n        if n <= 1:\n            return max(self.min_radius, self.base_radius)\n        r = self.base_radius * (n ** (-1.0 / max(2, self.dim)))\n        if r < self.min_radius:\n            r = self.min_radius\n        return r\n\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        key = self._grid_key(node.position, cell)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_gather(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos, cell):\n        # Expand rings until any candidates are found; fallback to linear scan\n        rng = 0\n        best = None\n        bestd = float('inf')\n        while rng < 6:\n            radius = (rng + 1) * cell\n            cand = self._grid_gather(grid, pos, radius, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                return best\n            rng += 1\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_grid(self, grid, pos, radius, cell):\n        cand = self._grid_gather(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _connect_trees(self, node_a, tree_b, grid_b, obstacles, is_3d, cell, nodes, edges):\n        target = node_a.position\n        nnear = self._nearest_grid(grid_b, tree_b, target, cell)\n        current = nnear\n        last_new = None\n        max_steps = int((self._dist(current.position, target) / self.step_size)) + 2\n        for _ in range(max_steps):\n            new_pos = self._steer(current.position, target, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False, None, None\n            if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                return False, None, None\n            new_node = Node(new_pos)\n            new_node.cost = current.cost + self._dist(current.position, new_pos)\n            current.add_child(new_node)\n            tree_b.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_add(grid_b, new_node, cell)\n            last_new = new_node\n            current = new_node\n            if self._dist(current.position, target) <= self.step_size and not self._is_edge_in_obstacle(current.position, target, obstacles, is_3d):\n                meet_b = current\n                meet_a = node_a\n                return True, meet_a, meet_b\n        if last_new is not None and self._dist(last_new.position, target) <= self.step_size and not self._is_edge_in_obstacle(last_new.position, target, obstacles, is_3d):\n            return True, node_a, last_new\n        return False, None, None\n\n    def _path_to_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        path.reverse()\n        return path\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        # meet_b is on the tree rooted at goal; follow parents to goal\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # path_a ends at meet_a; path_b starts at meet_b; edge between them is implicit\n        return path_a + path_b\n\n    def _propagate_costs_from(self, node, edges):\n        q = []\n        for c in node.children:\n            q.append(c)\n        while q:\n            u = q.pop(0)\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                q.append(c)\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                new_pts = pts[:i + 1] + pts[j:]\n                pts = new_pts\n                n = len(pts)\n        return pts",
        "objective": 13.17506,
        "time_improvement": -100.0,
        "length_improvement": 18.0,
        "smoothness_improvement": 1141.0,
        "node_improvement": -19.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.04533350467681885,
                "num_nodes_avg": 475.2,
                "path_length_avg": 160.00839630243624,
                "smoothness_avg": 0.03538840033717765,
                "success_improvement": 0.0,
                "time_improvement": -77.78684746193773,
                "node_improvement": -19.66759002770082,
                "length_improvement": 12.296862491341491,
                "smoothness_improvement": 453.90531241814347,
                "objective_score": -13.688410181685704
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.14875941276550292,
                "num_nodes_avg": 1244.7,
                "path_length_avg": 229.2684850165445,
                "smoothness_avg": 0.07592744364942347,
                "success_improvement": 0.0,
                "time_improvement": 7.13989227527299,
                "node_improvement": 16.367667808909488,
                "length_improvement": 23.463580574034797,
                "smoothness_improvement": 1853.6678134268077,
                "objective_score": 25.48845509413681
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.1614241361618042,
                "num_nodes_avg": 1203.4,
                "path_length_avg": 120.8833554675142,
                "smoothness_avg": 0.09548517805346257,
                "success_improvement": 0.0,
                "time_improvement": -229.0901755878243,
                "node_improvement": -53.00699300699302,
                "length_improvement": 19.715031145292965,
                "smoothness_improvement": 1114.5644168573392,
                "objective_score": -51.32521190488481
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "Bi-Guide ARC: A bidirectional, goal-aware RRT*-Connect with Adaptive Radius, spatial hashing, subtree cost propagation, and post-planning shortcut smoothing. It balances fast greedy connections with cost-optimal rewiring, focuses samples within an informed ellipsoid after the first solution, and uses a lightweight grid index for efficient nearest/near queries to improve path length and smoothness with lower planning time.",
        "planning_mechanism": "Alternate growing start/goal trees: sample (goal-biased; informed after first path), steer one step, select best parent within an adaptive radius, add if both node and edge are collision-free, locally rewire with subtree cost updates, then attempt a bounded greedy connect of the opposite tree to the new node. Maintain best path and stop upon time/iteration/no-improvement limits; finally apply randomized shortcut smoothing to the best path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def detach_from_parent(self):\n        if self.parent is not None and self in self.parent.children:\n            self.parent.children.remove(self)\n        self.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 6000,\n        step_size: float = 5.0,\n        goal_bias: float = 0.15,\n        base_radius: float = 35.0,\n        max_radius: float = 60.0,\n        connect_steps: int = 20,\n        post_opt_iters: int = 300,\n        no_improve_limit: int = 180,\n        time_limit_sec: float = 20.0,\n        smooth_attempts: int = 120\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.base_radius = base_radius\n        self.max_radius = max_radius\n        self.connect_steps = connect_steps\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.time_limit_sec = time_limit_sec\n        self.smooth_attempts = smooth_attempts\n\n        # Spatial hash cell size\n        self.cell_size = max(8.0, step_size * 2.0)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Core containers\n        nodes = []\n        edges = []\n        success_state = False\n        best_path = []\n        best_cost = float('inf')\n\n        # Initialize trees and spatial hashes\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Dist between start and goal\n        c_min = self._dist(start_position, goal_position)\n\n        # States\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            # Alternate expansion direction\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n                grid_a, grid_b = grid_start, grid_goal\n                root_a, root_b = start_root, goal_root\n                sample_goal = goal_position\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n                grid_a, grid_b = grid_goal, grid_start\n                root_a, root_b = goal_root, start_root\n                sample_goal = start_position\n\n            # Sampling with goal bias and informed focus\n            x_rand = self._sample(bounds, obstacles, is_3d, start_position, goal_position, best_cost, c_min, sample_goal)\n\n            # Nearest in tree_a\n            a_near = self._nearest(grid_a, tree_a, x_rand, bounds)\n            a_new_pos = self._steer(a_near.position, x_rand, self.step_size)\n\n            # Bound check\n            if not self._in_bounds(a_new_pos, bounds):\n                self._advance_counters(found_first, True)\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Node and edge collision checks before adding\n            if self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n            if self._hit_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Best parent selection within adaptive radius\n            rad = self._adaptive_radius(len(tree_a), dim)\n            neighbors = self._grid_neighbors(grid_a, a_new_pos, rad)\n            if not neighbors:\n                neighbors = [a_near]\n\n            best_parent = None\n            best_g = float('inf')\n            for cand in neighbors:\n                if self._hit_obstacle(cand.position, a_new_pos, obstacles, is_3d):\n                    continue\n                g = cand.cost + self._dist(cand.position, a_new_pos)\n                if g < best_g:\n                    best_g = g\n                    best_parent = cand\n\n            if best_parent is None:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Add new node to tree_a\n            a_new = Node(a_new_pos, parent=None, cost=best_g)\n            best_parent.add_child(a_new)\n            tree_a.append(a_new)\n            nodes.append(a_new)\n            edges.append((best_parent, a_new))\n            self._grid_add(grid_a, a_new)\n\n            # Local rewiring from a_new\n            self._rewire_from(a_new, neighbors, obstacles, is_3d, edges)\n\n            # Attempt to connect tree_b to a_new (bounded)\n            b_meet = self._attempt_connect(tree_b, grid_b, a_new, obstacles, is_3d, bounds, nodes, edges, dim)\n\n            if b_meet is not None:\n                # Merge full path\n                if root_a is start_root:\n                    path_a = a_new.path_from_root()\n                    path_b = b_meet.path_from_root()\n                else:\n                    path_a = b_meet.path_from_root()\n                    path_b = a_new.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged = path_a + path_b[-2::-1]\n                else:\n                    merged = path_a + path_b[::-1]\n\n                cost = self._path_cost(merged)\n                if cost < best_cost - 1e-9:\n                    best_cost = cost\n                    best_path = merged\n                    success_state = True\n                    no_improve = 0\n                else:\n                    no_improve += 1\n\n                if not found_first:\n                    found_first = True\n                    post_iters = 0\n                else:\n                    post_iters += 1\n\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n            else:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n\n        # Final smoothing of best path\n        if success_state and best_path:\n            best_path = self._shortcut_smooth(best_path, obstacles, is_3d, attempts=self.smooth_attempts)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ------------------ Spatial Hash ------------------\n    def _key(self, pos):\n        return tuple(int(pos[d] // self.cell_size) for d in range(len(pos)))\n\n    def _grid_add(self, grid, node):\n        k = self._key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_neighbors(self, grid, pos, radius):\n        # Collect nodes in cells within radius\n        dim = len(pos)\n        span = int(max(1, math.ceil(radius / self.cell_size)))\n        key_center = self._key(pos)\n        result = []\n        if dim == 2:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    k = (key_center[0] + dx, key_center[1] + dy)\n                    if k in grid:\n                        for n in grid[k]:\n                            if self._dist(n.position, pos) <= radius:\n                                result.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        k = (key_center[0] + dx, key_center[1] + dy, key_center[2] + dz)\n                        if k in grid:\n                            for n in grid[k]:\n                                if self._dist(n.position, pos) <= radius:\n                                    result.append(n)\n        return result\n\n    def _nearest(self, grid, tree, pos, bounds):\n        # Try increasing radii using grid; fallback to full scan\n        radius = self.cell_size\n        for _ in range(4):\n            cands = self._grid_neighbors(grid, pos, radius)\n            if cands:\n                return min(cands, key=lambda n: self._dist(n.position, pos))\n            radius *= 2.0\n        return min(tree, key=lambda n: self._dist(n.position, pos))\n\n    # ------------------ Connect Attempt ------------------\n    def _attempt_connect(self, tree, grid, target_node, obstacles, is_3d, bounds, nodes, edges, dim):\n        target_pos = target_node.position\n\n        # Direct connect via best parent in radius\n        rad = self._adaptive_radius(len(tree), dim)\n        neigh = self._grid_neighbors(grid, target_pos, rad)\n        if not neigh:\n            # include nearest if none\n            neigh = [self._nearest(grid, tree, target_pos, bounds)]\n        best_parent = None\n        best_cost = float('inf')\n        for cand in neigh:\n            if self._hit_obstacle(cand.position, target_pos, obstacles, is_3d):\n                continue\n            g = cand.cost + self._dist(cand.position, target_pos)\n            if g < best_cost:\n                best_cost = g\n                best_parent = cand\n        if best_parent is not None and not self._is_in_obstacle(target_pos, obstacles, is_3d):\n            meet = Node(target_pos, parent=None, cost=best_cost)\n            best_parent.add_child(meet)\n            tree.append(meet)\n            nodes.append(meet)\n            edges.append((best_parent, meet))\n            self._grid_add(grid, meet)\n            # Local rewiring at seam improves junction quality\n            seam_neighbors = self._grid_neighbors(grid, target_pos, rad)\n            self._rewire_from(meet, seam_neighbors, obstacles, is_3d, edges)\n            return meet\n\n        # Greedy bounded stepping toward target\n        current = self._nearest(grid, tree, target_pos, bounds)\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(current.position, target_pos, self.step_size)\n            if not self._in_bounds(nxt, bounds):\n                return None\n            if self._is_in_obstacle(nxt, obstacles, is_3d):\n                return None\n            if self._hit_obstacle(current.position, nxt, obstacles, is_3d):\n                return None\n\n            # Insert with best parent among neighbors around nxt\n            neigh2 = self._grid_neighbors(grid, nxt, rad)\n            if not neigh2:\n                neigh2 = [current]\n            best_p = None\n            best_g2 = float('inf')\n            for cand in neigh2:\n                if self._hit_obstacle(cand.position, nxt, obstacles, is_3d):\n                    continue\n                g2 = cand.cost + self._dist(cand.position, nxt)\n                if g2 < best_g2:\n                    best_g2 = g2\n                    best_p = cand\n            if best_p is None:\n                return None\n\n            new_b = Node(nxt, parent=None, cost=best_g2)\n            best_p.add_child(new_b)\n            tree.append(new_b)\n            nodes.append(new_b)\n            edges.append((best_p, new_b))\n            self._grid_add(grid, new_b)\n\n            self._rewire_from(new_b, neigh2, obstacles, is_3d, edges)\n\n            if self._dist(new_b.position, target_pos) <= self.step_size:\n                if (not self._is_in_obstacle(target_pos, obstacles, is_3d)) and (not self._hit_obstacle(new_b.position, target_pos, obstacles, is_3d)):\n                    final_b = Node(target_pos, parent=None, cost=new_b.cost + self._dist(new_b.position, target_pos))\n                    new_b.add_child(final_b)\n                    tree.append(final_b)\n                    nodes.append(final_b)\n                    edges.append((new_b, final_b))\n                    self._grid_add(grid, final_b)\n                    return final_b\n                return None\n\n            current = new_b\n            steps += 1\n\n        return None\n\n    # ------------------ Rewiring ------------------\n    def _rewire_from(self, pivot, neighbors, obstacles, is_3d, edges):\n        for nb in neighbors:\n            if nb is pivot or nb.parent is None:\n                continue\n            if self._hit_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                continue\n            new_cost = pivot.cost + self._dist(pivot.position, nb.position)\n            if new_cost + 1e-12 < nb.cost:\n                old_parent = nb.parent\n                nb.detach_from_parent()\n                pivot.add_child(nb)\n                try:\n                    edges.remove((old_parent, nb))\n                except Exception:\n                    pass\n                edges.append((pivot, nb))\n                delta = new_cost - nb.cost\n                nb.cost = new_cost\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        # BFS update costs down the subtree to maintain coherence\n        queue = [node]\n        while queue:\n            cur = queue.pop(0)\n            for ch in cur.children:\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                queue.append(ch)\n\n    # ------------------ Sampling ------------------\n    def _sample(self, bounds, obstacles, is_3d, start, goal, c_best, c_min, biased_goal):\n        dim = len(bounds)\n        # Goal bias\n        if random.random() < self.goal_bias:\n            target = goal if biased_goal == goal else start\n            if not self._is_in_obstacle(target, obstacles, is_3d):\n                return target\n\n        # Informed sampling after first solution\n        if c_best < float('inf') and c_min > 1e-12:\n            for _ in range(50):\n                x = self._sample_informed_ellipsoid(start, goal, c_best, c_min, bounds)\n                if not self._is_in_obstacle(x, obstacles, is_3d):\n                    return x\n\n        # Uniform fallback\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]), random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_informed_ellipsoid(self, start, goal, c_best, c_min, bounds):\n        # Prolate ellipsoid with foci at start and goal\n        dim = len(bounds)\n        r1 = c_best / 2.0\n        r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        a1 = self._unit(self._vec(goal, start))\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r2)\n        else:\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._unit(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._unit(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r2, r2)\n\n        u = self._sample_unit_ball(dim)\n        x = [center[d] for d in range(dim)]\n        for i in range(dim):\n            for d in range(dim):\n                x[d] += basis[i][d] * radii[i] * u[i]\n        # Clamp to bounds\n        x = tuple(min(max(x[d], 0.0), bounds[d]) for d in range(dim))\n        return x\n\n    def _sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(vi * vi for vi in v))\n            if n > 1e-12:\n                v = [vi / n for vi in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    # ------------------ Geometry/Collision ------------------\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _vec(self, a, b):\n        return tuple(a[i] - b[i] for i in range(len(a)))\n\n    def _norm(self, v):\n        return math.sqrt(sum(vi * vi for vi in v))\n\n    def _unit(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return tuple(0.0 for _ in v)\n        return tuple(vi / n for vi in v)\n\n    def _cross(self, a, b):\n        # Only used in 3D informed sampling\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0.0 <= pos[i] <= bounds[i] for i in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _hit_obstacle(self, a, b, obstacles, is_3d, res=1.0):\n        L = self._dist(a, b)\n        steps = max(1, int(L / res))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(len(a)))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _path_cost(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(len(path) - 1):\n            s += self._dist(path[i], path[i + 1])\n        return s\n\n    # ------------------ Controls ------------------\n    def _adaptive_radius(self, n, dim):\n        if n <= 1:\n            return self.base_radius\n        # RRT* style shrinkage\n        r = self.base_radius * (math.log(n + 1) / (n + 1)) ** (1.0 / dim)\n        r = max(self.step_size * 1.5, min(self.max_radius, r))\n        return r\n\n    def _post_update(self, found_first, post_iters, no_improve):\n        if found_first:\n            post_iters += 1\n            no_improve += 1\n        return post_iters, no_improve\n\n    def _should_stop(self, found_first, post_iters, no_improve):\n        if not found_first:\n            return False\n        if post_iters >= self.post_opt_iters:\n            return True\n        if no_improve >= self.no_improve_limit:\n            return True\n        return False\n\n    # ------------------ Smoothing ------------------\n    def _shortcut_smooth(self, path, obstacles, is_3d, attempts=100):\n        if len(path) < 3:\n            return path[:]\n        best = path[:]\n        best_cost = self._path_cost(best)\n        n = len(best)\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = best[i]\n            b = best[j]\n            if not self._hit_obstacle(a, b, obstacles, is_3d):\n                # shortcut\n                new_path = best[:i + 1] + best[j:]\n                new_cost = self._path_cost(new_path)\n                if new_cost < best_cost - 1e-9:\n                    best = new_path\n                    best_cost = new_cost\n                    n = len(best)\n        # Greedy corner culling\n        changed = True\n        while changed and len(best) > 2:\n            changed = False\n            k = 1\n            while k < len(best) - 1:\n                if not self._hit_obstacle(best[k - 1], best[k + 1], obstacles, is_3d):\n                    best.pop(k)\n                    changed = True\n                else:\n                    k += 1\n        return best",
        "objective": 14.38104,
        "time_improvement": -107.0,
        "length_improvement": 18.0,
        "smoothness_improvement": 1417.0,
        "node_improvement": 44.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.11155118942260742,
                "num_nodes_avg": 362.3,
                "path_length_avg": 155.15168551902272,
                "smoothness_avg": 0.04619305292125599,
                "success_improvement": 0.0,
                "time_improvement": -337.47630895645335,
                "node_improvement": 8.76353563334173,
                "length_improvement": 14.95890263123767,
                "smoothness_improvement": 623.021588037589,
                "objective_score": -89.15244316800546
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.08458755016326905,
                "num_nodes_avg": 414.7,
                "path_length_avg": 238.39539805931153,
                "smoothness_avg": 0.09691449918612544,
                "success_improvement": 0.0,
                "time_improvement": 47.197902476841236,
                "node_improvement": 72.13599408721359,
                "length_improvement": 20.416754296733227,
                "smoothness_improvement": 2393.679868751244,
                "objective_score": 38.37782266484852
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06439132690429687,
                "num_nodes_avg": 395.9,
                "path_length_avg": 123.34270106287966,
                "smoothness_avg": 0.1047845601402689,
                "success_improvement": 0.0,
                "time_improvement": -31.272519594143017,
                "node_improvement": 49.66306420851876,
                "length_improvement": 18.081650902303785,
                "smoothness_improvement": 1232.8518705925312,
                "objective_score": 7.631494016102023
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "GB-RRT* Connect with bounded rewiring and informed goal bias: a bidirectional, RRT*-style planner that alternates growing start/goal trees using k-nearest best-parent selection and local rewiring, uses goal/informed sampling for fast convergence, caches edge checks, and applies shortcut smoothing; it lazily bridges trees without duplicating meeting nodes and limits post-solution optimization for efficiency.",
        "planning_mechanism": "Alternate expanding the two trees toward informed/goal-biased samples; for each new node, pick the lowest-cost collision-free parent among k nearest neighbors, rewire locally with cost propagation, and attempt a short greedy connection to the opposite tree. Upon first connection, switch to ellipsoidal informed sampling and continue for a bounded number of iterations or until no improvement. Edge checks are cached; final path is shortcut-smoothed before returning.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        neighbor_k: int = 18,\n        time_limit_sec: float = 30.0,\n        goal_bias: float = 0.10,\n        post_opt_iters: int = 300,\n        no_improve_limit: int = 120,\n        smooth_iters: int = 120\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_k = neighbor_k\n        self.time_limit_sec = time_limit_sec\n        self.goal_bias = goal_bias\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.smooth_iters = smooth_iters\n\n        self._edge_cache = {}\n        self._edge_cache_limit = 50000\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n        success = False\n        best_path = []\n        best_cost = float(\"inf\")\n\n        # Early infeasible start/goal\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early direct connection\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d):\n            return PlannerResult(True, [start, goal], [Node(start), Node(goal)], [(Node(start), Node(goal))])\n\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        c_min = self._dist(start, goal)\n        start_time = self._now()\n\n        # RRT* neighborhood parameters\n        gamma_rrt = 60.0\n        max_radius = max(bounds) * 0.20\n        min_radius = max(self.step_size * 1.5, 5.0)\n\n        # Post-optimization bookkeeping\n        found_solution = False\n        post_iter = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            if self._now() - start_time > self.time_limit_sec:\n                break\n\n            # Alternate growing sides\n            if it % 2 == 0:\n                grow_tree, other_tree = tree_a, tree_b\n                a_is_start_side = True\n            else:\n                grow_tree, other_tree = tree_b, tree_a\n                a_is_start_side = False\n\n            # Sample with goal/informed bias\n            sample = self._sample_informed(start, goal, best_cost, c_min, bounds, obstacles, is_3d, found_solution)\n\n            # Extend grow_tree\n            a_near = self._nearest(grow_tree, sample)\n            a_new_pos = self._steer(a_near.position, sample, self.step_size)\n            if (not self._in_bounds(a_new_pos, bounds)) or self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                if found_solution:\n                    post_iter += 1\n                    no_improve += 1\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve >= self.no_improve_limit):\n                    break\n                continue\n            if self._is_edge_in_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                if found_solution:\n                    post_iter += 1\n                    no_improve += 1\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve >= self.no_improve_limit):\n                    break\n                continue\n\n            # Insert with best-parent among k-nearest inside adaptive radius\n            r_n = self._neighbor_radius(len(grow_tree), dim, gamma_rrt, min_radius, max_radius)\n            a_new, a_neigh = self._add_with_best_parent(grow_tree, nodes, edges, a_new_pos, obstacles, is_3d, r_n)\n            if a_new is None:\n                if found_solution:\n                    post_iter += 1\n                    no_improve += 1\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve >= self.no_improve_limit):\n                    break\n                continue\n\n            # Local rewiring around the inserted node with cost propagation\n            self._rewire_from(a_new, a_neigh, edges, obstacles, is_3d)\n\n            # Try short greedy connection from other_tree to a_new\n            connected_b = self._greedy_connect(other_tree, a_new.position, nodes, edges, obstacles, is_3d, dim, gamma_rrt, min_radius, max_radius, max_steps=3)\n\n            # Attempt final bridge if close\n            candidate_path = None\n            if connected_b is not None:\n                if self._dist(connected_b.position, a_new.position) <= self.step_size and not self._is_edge_in_obstacle(connected_b.position, a_new.position, obstacles, is_3d):\n                    # Add a visual bridge edge without altering parents (lazy bridge)\n                    edges.append((connected_b, a_new))\n                    # Stitch paths for evaluation\n                    path_a = a_new.path_from_root()\n                    path_b = connected_b.path_from_root()\n                    merged = path_a + path_b[-2::-1] if (path_a and path_b and path_a[-1] == path_b[-1]) else path_a + path_b[::-1]\n                    candidate_path = merged if a_is_start_side else merged[::-1]\n\n            if candidate_path:\n                cand_cost = self._path_cost(candidate_path)\n                if cand_cost + 1e-9 < best_cost:\n                    best_cost = cand_cost\n                    best_path = candidate_path\n                    success = True\n                    found_solution = True\n                    post_iter = 0\n                    no_improve = 0\n                else:\n                    if found_solution:\n                        post_iter += 1\n                        no_improve += 1\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve >= self.no_improve_limit):\n                    break\n            else:\n                if found_solution:\n                    post_iter += 1\n                    no_improve += 1\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve >= self.no_improve_limit):\n                    break\n\n        # Final smoothing\n        if success and len(best_path) >= 2:\n            best_path = self._shortcut_smooth(best_path, obstacles, is_3d, self.smooth_iters)\n\n        return PlannerResult(success, best_path if success else [], nodes, edges)\n\n    # ---------- Geometry / Utility ----------\n    def _now(self):\n        return time.time()\n\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _in_bounds(self, p, bounds):\n        for d in range(len(bounds)):\n            if p[d] < 0.0 or p[d] > bounds[d]:\n                return False\n        return True\n\n    def _nearest(self, tree, pt):\n        return min(tree, key=lambda n: self._dist(n.position, pt))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _neighbor_radius(self, n_nodes, dim, gamma, rmin, rmax):\n        if n_nodes < 2:\n            return rmin\n        val = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n        return max(rmin, min(rmax, val))\n\n    def _k_nearest_within(self, tree, pos, k, radius):\n        # Filter by radius then choose up to k nearest\n        pairs = []\n        for nd in tree:\n            d = self._dist(nd.position, pos)\n            if d <= radius:\n                pairs.append((d, nd))\n        if not pairs:\n            return []\n        pairs.sort(key=lambda x: x[0])\n        return [nd for _, nd in pairs[:min(k, len(pairs))]]\n\n    def _add_with_best_parent(self, tree, nodes, edges, new_pos, obstacles, is_3d, radius):\n        # Parent candidates among k-nearest inside radius; ensure edge collision free\n        neigh = self._k_nearest_within(tree, new_pos, self.neighbor_k, radius)\n        if not neigh:\n            # fallback to nearest\n            neigh = [self._nearest(tree, new_pos)]\n        parent_candidates = [nb for nb in neigh if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d)]\n        if not parent_candidates:\n            return None, []\n        best_parent = min(parent_candidates, key=lambda nb: nb.cost + self._dist(nb.position, new_pos))\n        new_node = Node(new_pos, parent=None, cost=best_parent.cost + self._dist(best_parent.position, new_pos))\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neigh\n\n    def _rewire_from(self, pivot, neigh, edges, obstacles, is_3d):\n        for nb in neigh:\n            if nb is pivot:\n                continue\n            if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                continue\n            new_cost = pivot.cost + self._dist(pivot.position, nb.position)\n            if new_cost + 1e-12 < nb.cost:\n                old_parent = nb.parent\n                if old_parent is not None:\n                    # Remove old edge if present\n                    try:\n                        edges.remove((old_parent, nb))\n                    except ValueError:\n                        pass\n                    try:\n                        old_parent.children.remove(nb)\n                    except ValueError:\n                        pass\n                pivot.add_child(nb)\n                nb.cost = new_cost\n                edges.append((pivot, nb))\n                self._propagate_cost_from(nb, edges)\n\n    def _propagate_cost_from(self, node, edges):\n        # Update costs in subtree after rewiring\n        queue = [node]\n        while queue:\n            cur = queue.pop(0)\n            for ch in cur.children:\n                new_c = cur.cost + self._dist(cur.position, ch.position)\n                if abs(new_c - ch.cost) > 1e-12:\n                    ch.cost = new_c\n                    queue.append(ch)\n\n    def _greedy_connect(self, tree, target_pos, nodes, edges, obstacles, is_3d, dim, gamma_rrt, rmin, rmax, max_steps=3):\n        current = self._nearest(tree, target_pos)\n        steps = 0\n        last_new = None\n        while steps < max_steps:\n            steps += 1\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                break\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                break\n            radius = self._neighbor_radius(len(tree), dim, gamma_rrt, rmin, rmax)\n            new_node, neigh = self._add_with_best_parent(tree, nodes, edges, step_pos, obstacles, is_3d, radius)\n            if new_node is None:\n                break\n            self._rewire_from(new_node, neigh, edges, obstacles, is_3d)\n            current = new_node\n            last_new = new_node\n            if self._dist(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    def _path_cost(self, path):\n        total = 0.0\n        for i in range(len(path) - 1):\n            total += self._dist(path[i], path[i + 1])\n        return total\n\n    # ---------- Sampling ----------\n    def _sample_informed(self, start, goal, c_best, c_min, bounds, obstacles, is_3d, have_solution):\n        dim = len(bounds)\n        # Try a few times to avoid sampling inside obstacles\n        for _ in range(50):\n            if not have_solution or c_best == float(\"inf\") or c_min <= 1e-12:\n                # Pre-solution: goal bias\n                if random.random() < self.goal_bias:\n                    sample = goal\n                else:\n                    sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            else:\n                # Post-solution: informed ellipsoidal sampling with some uniform escape\n                if random.random() < 0.80:\n                    sample = self._sample_ellipsoid(start, goal, c_best, c_min, bounds)\n                else:\n                    sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            if self._in_bounds(sample, bounds) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                return sample\n        # Fallback uniform\n        return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n    def _sample_ellipsoid(self, start, goal, c_best, c_min, bounds):\n        dim = len(bounds)\n        center = tuple((s + g) / 2.0 for s, g in zip(start, goal))\n        a1 = tuple((goal[d] - start[d]) / (c_min if c_min > 1e-12 else 1.0) for d in range(dim))\n        r1 = c_best / 2.0\n        r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n        r_other = math.sqrt(r_other_sq) / 2.0\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r_other)\n        else:\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._normalize(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._normalize(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r_other, r_other)\n        u = self._sample_unit_ball(dim)\n        mapped = []\n        for d in range(dim):\n            val = center[d]\n            for i in range(dim):\n                val += basis[i][d] * radii[i] * u[i]\n            # Clamp to bounds\n            val = min(max(val, 0.0), bounds[d])\n            mapped.append(val)\n        return tuple(mapped)\n\n    def _sample_unit_ball(self, dim):\n        # Gaussian direction + radius^(1/d)\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(x * x for x in v))\n            if n > 1e-12:\n                v = [x / n for x in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for x, y, z, w, h, d in obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for x, y, w, h in obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        # Direction-agnostic key with rounding to reduce duplicates\n        ra = tuple(round(c, 2) for c in a)\n        rb = tuple(round(c, 2) for c in b)\n        return (ra, rb) if ra <= rb else (rb, ra)\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        key = self._edge_key(from_pos, to_pos)\n        hit = self._edge_cache.get(key, None)\n        if hit is not None:\n            return hit\n        distance = self._dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                self._edge_cache[key] = True\n                if len(self._edge_cache) > self._edge_cache_limit:\n                    self._edge_cache.clear()\n                return True\n        self._edge_cache[key] = False\n        if len(self._edge_cache) > self._edge_cache_limit:\n            self._edge_cache.clear()\n        return False\n\n    # ---------- Smoothing ----------\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d):\n                # Shortcut\n                new_pts = pts[:i + 1] + pts[j:]\n                pts = new_pts\n                n = len(pts)\n        return pts",
        "objective": 23.10764,
        "time_improvement": -139.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1239.0,
        "node_improvement": 31.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.13042638301849366,
                "num_nodes_avg": 488.2,
                "path_length_avg": 150.21700760008898,
                "smoothness_avg": 0.03945954965394641,
                "success_improvement": 0.0,
                "time_improvement": -411.50017251100286,
                "node_improvement": -22.941324603374454,
                "length_improvement": 17.663677793580806,
                "smoothness_improvement": 517.6276398678153,
                "objective_score": -110.2637068778133
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.08705599308013916,
                "num_nodes_avg": 504.4,
                "path_length_avg": 233.63485048296306,
                "smoothness_avg": 0.08420769273445602,
                "success_improvement": 0.0,
                "time_improvement": 45.6570260313673,
                "node_improvement": 66.10898340388363,
                "length_improvement": 22.005962102482787,
                "smoothness_improvement": 2066.7245864070437,
                "objective_score": 37.23430800293508
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.07347123622894287,
                "num_nodes_avg": 396.5,
                "path_length_avg": 117.99846302312123,
                "smoothness_avg": 0.09690125523828255,
                "success_improvement": 0.0,
                "time_improvement": -49.783437632906015,
                "node_improvement": 49.586776859504134,
                "length_improvement": 21.63103934304284,
                "smoothness_improvement": 1132.5768141243043,
                "objective_score": 3.7064763865754218
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "UniGrid Informed RRT*-Fast (UG-IRRT*-F): a single-tree, cost-optimal planner that uses a uniform spatial hash for O(1)-average neighbor queries, \u03b3(log n/n)^(1/d) adaptive neighborhoods, informed ellipsoidal sampling after the first solution, duplicate-node suppression, lazy rewires with incremental cost push, and goal-side best-parent connection; it continues optimizing under a focused post-optimization budget and returns a compressed, shortcut-smoothed path.",
        "planning_mechanism": "At each iteration, sample (goal/line/ellipse-biased), steer one step from the nearest node, validate node and edge, choose the lowest-cost valid parent within an adaptive radius, add the node, and lazily rewire cheaper neighbors. If close to the goal, select the best-cost valid parent for the goal among nearby nodes and update the incumbent path. After finding a solution, restrict sampling to the informed set and terminate on a time/no-improvement budget, then compress and shortcut the path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4200,\n                 step_size=5.0,\n                 gamma_radius=55.0,\n                 min_radius_factor=1.0,\n                 goal_bias=0.12,\n                 line_bias=0.38,\n                 connect_factor=2.0,\n                 near_cap=64,\n                 post_opt_iters=450,\n                 max_no_improve=180,\n                 smoothing_iters=160):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_radius = gamma_radius\n        self.min_radius_factor = min_radius_factor\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_factor = connect_factor\n        self.near_cap = near_cap\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        root = Node(start, None, 0.0)\n        nodes = [root]\n\n        # spatial hash grid\n        cell = max(1.0, 0.8 * self.step_size)\n        grid = {}\n        self._grid_add(grid, root, cell)\n\n        # coarse occupancy to suppress duplicates\n        occ_cell = max(0.5, 0.6 * self.step_size)\n        occ = {self._occ_key(start, occ_cell): True}\n\n        success = False\n        best_cost = float('inf')\n        goal_node = None\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            # sample\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                x_rand = self._sample_biased(start, goal, best_cost)\n\n            # nearest\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n            # bounds and node collision\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # duplicate suppression\n            k_occ = self._occ_key(x_new_pos, occ_cell)\n            if k_occ in occ:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # incoming edge collision\n            if self._is_edge_in_obstacle(n_near.position, x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # choose best parent within adaptive radius\n            r_near = self._rrtstar_radius(max(2, len(nodes)))\n            near_nodes = self._near(grid, x_new_pos, r_near, cell)\n            if near_nodes:\n                near_nodes = self._limit_by_distance(near_nodes, x_new_pos, self.near_cap)\n            best_parent = n_near\n            best_pc = n_near.cost + self._dist(n_near.position, x_new_pos)\n            for nn in near_nodes:\n                if nn is n_near:\n                    continue\n                c = nn.cost + self._dist(nn.position, x_new_pos)\n                if c + 1e-12 < best_pc:\n                    if not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d):\n                        best_pc = c\n                        best_parent = nn\n\n            # commit new node (both checks were done above for chosen parent)\n            x_new = Node(x_new_pos, None, best_pc)\n            x_new.attach(best_parent)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            occ[k_occ] = True\n\n            # rewire nearby nodes\n            for nn in near_nodes:\n                if nn is best_parent or nn is x_new:\n                    continue\n                alt = x_new.cost + self._dist(x_new.position, nn.position)\n                if alt + 1e-12 < nn.cost:\n                    if not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d):\n                        nn.attach(x_new)\n                        self._propagate_costs_from(nn)\n\n            # goal-side best-parent connection when close\n            improved = False\n            r_conn = max(r_near, self.connect_factor * self.step_size)\n            if self._dist(x_new.position, goal) <= r_conn:\n                if not self._is_in_obstacle(goal, obstacles, is_3d):\n                    # consider best parent among nodes near goal (including x_new)\n                    cand = self._near(grid, goal, r_conn, cell)\n                    if x_new not in cand:\n                        cand.append(x_new)\n                    best_parent_goal = None\n                    best_goal_cost = best_cost\n                    for p in cand:\n                        if not self._is_edge_in_obstacle(p.position, goal, obstacles, is_3d):\n                            ctot = p.cost + self._dist(p.position, goal)\n                            if ctot + 1e-12 < best_goal_cost:\n                                best_goal_cost = ctot\n                                best_parent_goal = p\n                    if best_parent_goal is not None:\n                        if goal_node is None:\n                            goal_node = Node(goal, None, best_goal_cost)\n                            goal_node.attach(best_parent_goal)\n                            nodes.append(goal_node)\n                        else:\n                            goal_node.cost = best_goal_cost\n                            goal_node.attach(best_parent_goal)\n                        best_cost = best_goal_cost\n                        success = True\n                        found_first = True\n                        improved = True\n                        post_iters = 0\n                        no_improve = 0\n\n            if found_first and not improved:\n                post_iters += 1\n                no_improve += 1\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        path = []\n        if success and goal_node is not None:\n            # extract\n            cur = goal_node\n            while cur is not None:\n                path.append(cur.position)\n                cur = cur.parent\n            path.reverse()\n            # postprocess\n            path = self._compress(path, obstacles, is_3d)\n            path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n\n        # build edges from parent pointers\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---------- Utilities ----------\n    def _rand(self):\n        try:\n            return self._lcg_next()\n        except:\n            return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 1103515245\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    def _rrtstar_radius(self, n):\n        r = self.gamma_radius\n        if n > 2:\n            expo = 1.0 / float(max(2, self.dim))\n            r = self.gamma_radius * ((self._log_approx(n) / float(n)) ** expo)\n        rmin = max(self.min_radius_factor * self.step_size, 1e-6)\n        if r < rmin:\n            r = rmin\n        return r\n\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        # exponential expansion until candidates appear\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        max_span = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > max_span:\n                max_span = self.bounds[i]\n        limit = max_span * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # fallback linear scan\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _limit_by_distance(self, nodes, center, k):\n        # partial selection of up to k nearest without full sort when large\n        if len(nodes) <= k:\n            return nodes\n        # simple reservoir based on distance threshold\n        # compute distances\n        idx = []\n        for i, n in enumerate(nodes):\n            idx.append((self._dist(n.position, center), i))\n        # partial selection: nth-element by repeated scanning (k small)\n        # choose k smallest by single pass selection\n        # fallback: simple sort when moderate\n        if len(nodes) <= 4 * k:\n            idx.sort(key=lambda t: t[0])\n            sel = [nodes[t[1]] for t in idx[:k]]\n            return sel\n        # approximate: pick k minima by iterative pass\n        sel = []\n        used = [False] * len(nodes)\n        for _ in range(k):\n            best = -1\n            bestd = float('inf')\n            for j, (d, i) in enumerate(idx):\n                if not used[j] and d < bestd:\n                    bestd = d\n                    best = j\n            if best == -1:\n                break\n            used[best] = True\n            sel.append(nodes[idx[best][1]])\n        return sel\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _sample_biased(self, start, goal, c_best):\n        # informed ellipsoidal rejection after first solution; else line/uniform mix\n        if c_best < float('inf'):\n            for _ in range(20):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._dist(p, start) + self._dist(p, goal) <= c_best and self._in_bounds(p):\n                    return p\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jitter = 0.5 * self.step_size\n            p = tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n            return p\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _propagate_costs_from(self, node):\n        stack = []\n        for c in node.children:\n            stack.append(c)\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                stack.append(c)\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
        "objective": -3.65664,
        "time_improvement": -50.0,
        "length_improvement": 19.0,
        "smoothness_improvement": 1436.0,
        "node_improvement": 46.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.06231374740600586,
                "num_nodes_avg": 244.5,
                "path_length_avg": 159.99708988452147,
                "smoothness_avg": 0.04079917273665813,
                "success_improvement": 0.0,
                "time_improvement": -144.3791801192523,
                "node_improvement": 38.42860740367666,
                "length_improvement": 12.303059718162231,
                "smoothness_improvement": 538.5956501503387,
                "objective_score": -33.238939954126664
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.11423308849334717,
                "num_nodes_avg": 663.4,
                "path_length_avg": 229.07326285952672,
                "smoothness_avg": 0.10084089211799352,
                "success_improvement": 0.0,
                "time_improvement": 28.69226420016899,
                "node_improvement": 55.42565343008802,
                "length_improvement": 23.528751349205564,
                "smoothness_improvement": 2494.7087869547277,
                "objective_score": 35.19847400434767
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06615550518035888,
                "num_nodes_avg": 438.5,
                "path_length_avg": 117.70760748606574,
                "smoothness_avg": 0.108123212990666,
                "success_improvement": 0.0,
                "time_improvement": -34.86909289750288,
                "node_improvement": 44.24666242848061,
                "length_improvement": 21.824211741702758,
                "smoothness_improvement": 1275.3192884158632,
                "objective_score": 9.010395617850108
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "Adaptive Goal-Biased Grid BiRRT (AG-GBiRRT): a simplified, robust bidirectional RRT with commit-only connection, grid-accelerated nearest search, and light post-connection shortcut smoothing. It alternates growing two trees, uses uniform-with-goal-bias sampling, single-step steering with strict node/edge collision checks, and an early straight-line test. Upon any successful bridge between trees, it extracts the path and performs a few inexpensive shortcuts for smoothness, returning quickly without extra rewiring or bloat.",
        "planning_mechanism": "Mechanism: alternate start/goal tree expansion; sample (goal-biased), find nearest via grid, steer one step, validate node and edge, add node and edge, attempt a direct, collision-free bridge to the opposite tree (commit-only); on success, extract [start\u2192\u2026\u2192meetA, meetB\u2192\u2026\u2192goal] and run brief shortcut smoothing; terminate on success or iteration budget.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.0)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                continue\n\n            # Insert node (both node and edge validated)\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Try commit-only direct connection to the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None:\n                if not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, other_near)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        try:\n            return self._lcg_next()\n        except:\n            return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Sampling ----------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ---------- Grid nearest ----------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # ---------- Path ----------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # path_a ends at meet_a; we then go straight to meet_b and up to other root\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            # pick two indices i < j with at least one point between\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
        "objective": -32.96764,
        "time_improvement": 69.0,
        "length_improvement": 11.0,
        "smoothness_improvement": 1142.0,
        "node_improvement": 82.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01299290657043457,
                "num_nodes_avg": 78.8,
                "path_length_avg": 167.86786188508313,
                "smoothness_avg": 0.03825680999831742,
                "success_improvement": 0.0,
                "time_improvement": 49.04501835909778,
                "node_improvement": 80.15613195668597,
                "length_improvement": 7.988964864290817,
                "smoothness_improvement": 498.8021524662562,
                "objective_score": 22.000895188635106
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02625594139099121,
                "num_nodes_avg": 208.9,
                "path_length_avg": 244.3021244779086,
                "smoothness_avg": 0.07331771296729457,
                "success_improvement": 0.0,
                "time_improvement": 83.61025026480232,
                "node_improvement": 85.96385137405093,
                "length_improvement": 18.444919002512343,
                "smoothness_improvement": 1786.5175632625994,
                "objective_score": 45.082614297261095
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.01305999755859375,
                "num_nodes_avg": 163.0,
                "path_length_avg": 140.27860161008172,
                "smoothness_avg": 0.09759083301298958,
                "success_improvement": 0.0,
                "time_improvement": 73.37500455677744,
                "node_improvement": 79.27527018436109,
                "length_improvement": 6.833632159773637,
                "smoothness_improvement": 1141.348192519241,
                "objective_score": 31.819421625493614
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "Adaptive Beam BiRRT-Connect (AB-Connect): a lean, time-focused bidirectional planner that alternates single-step tree growth with a tiny beam of candidate samples. It uses a fine spatial hash for fast nearest queries, corridor-guided sampling around the start\u2013goal line to reduce rejection, and on-the-fly path compression to limit node bloat. A short greedy connect attempts to bridge trees early; upon success, a bounded shortcut pass cleans the path and returns immediately. By avoiding rewiring and heavy optimization while enforcing strict node/edge collision checks, AB-Connect minimizes per-iteration cost and achieves fast solutions.",
        "planning_mechanism": "Mechanism: Initialize two trees at start/goal. Each iteration (alternating trees), generate a small beam of candidate samples (goal/corridor/uniform), steer once from the nearest node, validate node and edge, discard near-duplicates, and keep the candidate that best reduces distance to the opposite tree. Insert it, attempt on-the-fly grandparent line-of-sight compression, then try a direct or short greedy connect toward the other tree. If bridged, extract the path and run bounded shortcut smoothing; else continue until the iteration budget is reached.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=8.0,\n                 goal_bias=0.18,\n                 corridor_bias=0.5,\n                 beam_k=2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=28,\n                 connect_steps=6,\n                 min_sep_ratio=0.25,\n                 dupe_radius_ratio=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.connect_steps = connect_steps\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n\n    # ---------------- Planning ----------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Setup grid resolution and collision sampling\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.6 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.4)))\n\n        # Validate start/goal and early LOS\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        if not self._is_edge_in_obstacle(self.start, self.goal, obstacles, is_3d, self.edge_res):\n            path = [self.start, self.goal]\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, path, nodes, [])\n\n        # Initialize structures\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Corridor parameters\n        dsg = self._dist(self.start, self.goal)\n        c_best = float('inf')\n        base_corridor = max(self.step_size, 0.15 * dsg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = self.goal if active_start else self.start\n\n            # Beam of candidates; keep the one that best reduces distance to the other tree\n            best_cand = None\n            best_score = float('inf')\n            other_near_hint = None\n\n            for _ in range(self.beam_k):\n                # Sampling policy: goal-biased, corridor-guided, or uniform\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = base_corridor\n                    if c_best < float('inf'):\n                        width = max(self.step_size, 0.25 * (c_best - dsg) + base_corridor)\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                    continue\n\n                # Score: distance to nearest node in the other tree after this move\n                if other_near_hint is None:\n                    other_near_hint = self._nearest_grid(grid_b, tree_b, new_pos)\n                else:\n                    # refresh if new_pos is far from hint\n                    if self._dist(other_near_hint.position, new_pos) > 2.5 * self.step_size:\n                        other_near_hint = self._nearest_grid(grid_b, tree_b, new_pos)\n                if other_near_hint is None:\n                    score = self._dist(new_pos, root_other)\n                else:\n                    score = self._dist(new_pos, other_near_hint.position)\n                if score < best_score:\n                    best_score = score\n                    best_cand = (nearest, new_pos)\n\n            if best_cand is None:\n                continue\n\n            parent_node, new_pos = best_cand\n\n            # Insert node and edge (validated already)\n            new_cost = parent_node.cost + self._dist(parent_node.position, new_pos)\n            new_node = Node(new_pos, parent=parent_node, cost=new_cost)\n            parent_node.add_child(new_node)\n            tree_a.append(new_node)\n            self._edges_add(edges, parent_node, new_node)\n            self._grid_add(grid_a, new_node)\n\n            # On-the-fly grandparent compression\n            gp = parent_node.parent\n            if gp is not None:\n                # If LOS from grandparent to new_node, bypass parent to reduce nodes and cost\n                if not self._is_edge_in_obstacle(gp.position, new_node.position, obstacles, is_3d, self.edge_res):\n                    # Update edges/children coherently\n                    parent_node.remove_child(new_node)\n                    self._edges_remove(edges, parent_node, new_node)\n                    gp.add_child(new_node)\n                    self._edges_add(edges, gp, new_node)\n                    # Update cost\n                    new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n\n            # Try direct bridge to the nearest node in the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None and not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                path = self._extract_path(new_node, other_near)\n                c_best = self._path_length(path)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Short greedy connect toward new_node from the other tree\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if self._dist(p.position, to_pos) < self.step_size * self.min_sep_ratio:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(p.position, to_pos, obstacles, is_3d, self.edge_res):\n                    break\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                self._edges_add(edges, p, q)\n                self._grid_add(grid_b, q)\n                p = q\n                steps += 1\n\n                # Check bridge now\n                if not self._is_edge_in_obstacle(new_node.position, p.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, p)\n                    c_best = self._path_length(path)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------------- RNG ----------------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------------- Geometry ----------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------------- Collision ----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------------- Sampling ----------------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        # Sample around the start-goal line with axis-aligned jitter (cheap \"corridor\")\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        # Fallback to uniform if corridor sample is invalid\n        return self._sample_free(obstacles, is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---------------- Grid and neighbors ----------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Expand rings up to modest radius; fallback linear scan if needed\n        for r in range(0, 5):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan (rare with fine grid)\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # ---------------- Edges and costs ----------------\n    def _edges_add(self, edges, parent, child):\n        edges.append((parent, child))\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # ---------------- Paths ----------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        # Path A: root_A -> meet_a\n        path_a = self._path_to_root(meet_a)\n        # Path B: meet_b -> root_B (following parent links)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # Concatenate, implying a straight edge between meet_a and meet_b (validated before)\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        # Final LOS collapse forward\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            for k in range(1, len(pts) - 1):\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d, self.edge_res):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
        "objective": -20.0019,
        "time_improvement": 15.0,
        "length_improvement": 12.0,
        "smoothness_improvement": 1665.0,
        "node_improvement": 85.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.022508907318115234,
                "num_nodes_avg": 61.9,
                "path_length_avg": 173.37195960178056,
                "smoothness_avg": 0.04856882636983518,
                "success_improvement": 0.0,
                "time_improvement": 11.725605588421473,
                "node_improvement": 84.41198690506171,
                "length_improvement": 4.972081687759297,
                "smoothness_improvement": 660.2076015824708,
                "objective_score": 9.801968697094374
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04350669384002685,
                "num_nodes_avg": 122.6,
                "path_length_avg": 245.93388702328062,
                "smoothness_avg": 0.11098748565610625,
                "success_improvement": 0.0,
                "time_improvement": 72.84181080292292,
                "node_improvement": 91.76241349190352,
                "length_improvement": 17.900189697186487,
                "smoothness_improvement": 2755.78794698629,
                "objective_score": 46.371596794120215
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06773929595947266,
                "num_nodes_avg": 163.7,
                "path_length_avg": 132.06627662911285,
                "smoothness_avg": 0.13189994478614067,
                "success_improvement": 0.0,
                "time_improvement": -38.09791603378091,
                "node_improvement": 79.18626827717736,
                "length_improvement": 12.287867383240805,
                "smoothness_improvement": 1577.7575618385185,
                "objective_score": 3.832133429002802
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "HF-IRRT#-OS: Heuristic-Filtered Informed RRT# with Online Shortcuts \u2014 a single-tree, cost-optimal planner that uses grid-accelerated neighbors, admissible cost+heuristic pruning, correct-cost rewiring with queued propagation, per-cell best-cost duplicate suppression, aggressive informed sampling after the first solution, and incremental shortcutting to continuously reduce path length.",
        "planning_mechanism": "At each iteration, sample (goal/line/ellipse-biased), steer a bounded step, validate node and edge, select the lowest-cost valid parent within an adaptive radius, commit the node, and rewire cheaper neighbors with proper subtree cost updates. When near the goal, connect via the best valid parent to update the incumbent path. After any improvement, perform bounded shortcuts on the current best path to tighten c_best and focus the informed set. Terminate on post-optimization or no-improvement budgets and return a compressed, smoothed path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=4.0,\n                 gamma_radius=60.0,\n                 min_radius_factor=1.0,\n                 goal_bias=0.15,\n                 line_bias=0.35,\n                 connect_radius_factor=2.5,\n                 near_cap=72,\n                 post_opt_iters=600,\n                 max_no_improve=240,\n                 smoothing_iters=220,\n                 ellipse_tries=220,\n                 occ_gain_ratio=0.985,\n                 prune_margin=1.0005,\n                 online_shortcuts_per_improve=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_radius = gamma_radius\n        self.min_radius_factor = min_radius_factor\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_radius_factor = connect_radius_factor\n        self.near_cap = near_cap\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.ellipse_tries = ellipse_tries\n        self.occ_gain_ratio = occ_gain_ratio\n        self.prune_margin = prune_margin\n        self.online_shortcuts_per_improve = online_shortcuts_per_improve\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Early feasibility: straight line\n        if self._in_bounds(start) and self._in_bounds(goal):\n            if (not self._is_in_obstacle(start, obstacles, is_3d)) and (not self._is_in_obstacle(goal, obstacles, is_3d)):\n                if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d):\n                    s = Node(start, None, 0.0)\n                    g = Node(goal, None, self._dist(start, goal))\n                    g.attach(s)\n                    nodes = [s, g]\n                    edges = [(s, g)]\n                    path = [start, goal]\n                    return PlannerResult(success=True, path=path, nodes=nodes, edges=edges)\n\n        # Initialize\n        root = Node(start, None, 0.0)\n        nodes = [root]\n\n        # Spatial hash grid for NN queries\n        cell = max(1.0, 0.8 * self.step_size)\n        grid = {}\n        self._grid_add(grid, root, cell)\n\n        # Per-cell best-cost ledger to suppress duplicates\n        occ_cell = max(0.5, 0.6 * self.step_size)\n        occ_best_cost = {self._occ_key(start, occ_cell): 0.0}\n\n        success = False\n        goal_node = None\n        best_cost = float('inf')\n        best_path_pts = None\n\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            # Sampling\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                x_rand = self._sample(start, goal, best_cost)\n\n            # Nearest\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n            # Bounds and node collision\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Parent selection within adaptive radius\n            r_near = self._rrtstar_radius(max(2, len(nodes)))\n            near_nodes = self._near(grid, x_new_pos, r_near, cell)\n            if near_nodes:\n                near_nodes = self._k_nearest_limit(near_nodes, x_new_pos, self.near_cap)\n            # Ensure nearest is considered\n            if n_near not in near_nodes:\n                near_nodes.append(n_near)\n\n            best_parent = None\n            best_pc = float('inf')\n\n            for nn in near_nodes:\n                base_cost = nn.cost + self._dist(nn.position, x_new_pos)\n                if base_cost + 1e-12 < best_pc:\n                    # Edge collision check for candidate parent\n                    if not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d):\n                        best_parent = nn\n                        best_pc = base_cost\n\n            if best_parent is None:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Duplicate suppression using per-cell best cost\n            k_occ = self._occ_key(x_new_pos, occ_cell)\n            prev_best = occ_best_cost.get(k_occ, float('inf'))\n            if best_pc >= prev_best * self.occ_gain_ratio:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Commit new node (both checks already validated for chosen parent)\n            x_new = Node(x_new_pos, None, best_pc)\n            x_new.attach(best_parent)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            if best_pc < prev_best:\n                occ_best_cost[k_occ] = best_pc\n\n            # Rewire neighbors with admissible pruning toward path-length improvement\n            for nn in near_nodes:\n                if nn is x_new or nn is best_parent:\n                    continue\n                alt = x_new.cost + self._dist(x_new.position, nn.position)\n                if alt + 1e-12 < nn.cost:\n                    # If we already have a solution, skip rewires that cannot possibly lead to improving it\n                    if best_cost < float('inf'):\n                        h = self._dist(nn.position, goal)\n                        if alt + h >= best_cost * self.prune_margin:\n                            continue\n                    if not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d):\n                        nn.attach(x_new)\n                        nn.cost = alt\n                        self._propagate_costs_from(nn)\n\n            # Try connecting to the goal using best available parent within connection range\n            improved = False\n            r_conn = max(r_near, self.connect_radius_factor * self.step_size)\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                cand = self._near(grid, goal, r_conn, cell)\n                if x_new not in cand:\n                    cand.append(x_new)\n                best_parent_goal = None\n                best_goal_cost = best_cost\n                for p in cand:\n                    ctot = p.cost + self._dist(p.position, goal)\n                    if ctot + 1e-12 < best_goal_cost:\n                        if not self._is_edge_in_obstacle(p.position, goal, obstacles, is_3d):\n                            best_goal_cost = ctot\n                            best_parent_goal = p\n                if best_parent_goal is not None:\n                    if goal_node is None:\n                        goal_node = Node(goal, None, best_goal_cost)\n                        goal_node.attach(best_parent_goal)\n                        nodes.append(goal_node)\n                    else:\n                        goal_node.attach(best_parent_goal)\n                        goal_node.cost = best_goal_cost\n                    best_cost = best_goal_cost\n                    success = True\n                    found_first = True\n                    improved = True\n\n            # After improvement, do bounded online shortcuts to tighten c_best and focus sampling\n            if improved and goal_node is not None:\n                cur_path = self._extract_path(goal_node)\n                cur_path = self._compress(cur_path, obstacles, is_3d)\n                cur_path = self._shortcuts(cur_path, obstacles, is_3d, self.online_shortcuts_per_improve)\n                path_len = self._path_length(cur_path)\n                if path_len + 1e-12 < best_cost:\n                    best_cost = path_len\n                best_path_pts = cur_path\n                post_iters = 0\n                no_improve = 0\n            else:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        # Build final path\n        path = []\n        if success and goal_node is not None:\n            if best_path_pts is None:\n                path = self._extract_path(goal_node)\n                path = self._compress(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n            else:\n                # Final polishing\n                path = self._shortcuts(best_path_pts, obstacles, is_3d, self.smoothing_iters)\n\n        # Build edges from parent pointers\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---------- Utilities ----------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        # 32-bit LCG (Numerical Recipes variant)\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _rrtstar_radius(self, n):\n        r = self.gamma_radius\n        if n > 2:\n            expo = 1.0 / float(max(2, self.dim))\n            r = self.gamma_radius * ((self._log_approx(n) / float(n)) ** expo)\n        rmin = max(self.min_radius_factor * self.step_size, 1e-6)\n        if r < rmin:\n            r = rmin\n        return r\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        # rough ln via bit_length\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    # Spatial hashing\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        # limit expansion\n        max_span = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > max_span:\n                max_span = self.bounds[i]\n        limit = max_span * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # fallback\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _k_nearest_limit(self, nodes, center, k):\n        if len(nodes) <= k:\n            return nodes\n        # partial selection without full sort when large\n        idx = []\n        for i, n in enumerate(nodes):\n            idx.append((self._dist(n.position, center), i))\n        if len(nodes) <= 4 * k:\n            idx.sort(key=lambda t: t[0])\n            return [nodes[t[1]] for t in idx[:k]]\n        # approximate selection\n        sel = []\n        used = [False] * len(nodes)\n        for _ in range(k):\n            best = -1\n            bestd = float('inf')\n            for j, (d, i) in enumerate(idx):\n                if not used[j] and d < bestd:\n                    bestd = d\n                    best = j\n            if best == -1:\n                break\n            used[best] = True\n            sel.append(nodes[idx[best][1]])\n        return sel\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _heuristic(self, a, b):\n        return self._dist(a, b)\n\n    def _sample(self, start, goal, c_best):\n        # Informed ellipsoidal rejection after first solution; else line/uniform mix\n        if c_best < float('inf'):\n            # accept points satisfying triangle inequality gate; try more to avoid fallback\n            tries = self.ellipse_tries\n            for _ in range(tries):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p):\n                    if self._dist(p, start) + self._dist(p, goal) <= c_best:\n                        return p\n        # Line-biased sampling with jitter\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jitter = 0.5 * self.step_size\n            p = tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n            return p\n        # Uniform\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _propagate_costs_from(self, node):\n        # node.cost already set correctly by caller\n        stack = []\n        for c in node.children:\n            stack.append(c)\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                newc = u.parent.cost + self._dist(u.parent.position, u.position)\n                if abs(newc - u.cost) > 1e-12:\n                    u.cost = newc\n            for c in u.children:\n                stack.append(c)\n\n    def _extract_path(self, goal_node):\n        seq = []\n        cur = goal_node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
        "objective": 26.9043,
        "time_improvement": -154.0,
        "length_improvement": 19.0,
        "smoothness_improvement": 1520.0,
        "node_improvement": 44.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.10562500953674317,
                "num_nodes_avg": 293.8,
                "path_length_avg": 154.45237735825782,
                "smoothness_avg": 0.04984145985356507,
                "success_improvement": 0.0,
                "time_improvement": -314.23529004756443,
                "node_improvement": 26.013598589775878,
                "length_improvement": 15.34220451539984,
                "smoothness_improvement": 680.1270791706859,
                "objective_score": -81.66462890917599
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.2455054998397827,
                "num_nodes_avg": 623.2,
                "path_length_avg": 228.05708400641493,
                "smoothness_avg": 0.10153044277454511,
                "success_improvement": 0.0,
                "time_improvement": -53.25193033715656,
                "node_improvement": 58.1267217630854,
                "length_improvement": 23.867981099460806,
                "smoothness_improvement": 2512.4514220110627,
                "objective_score": 10.90746666858483
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.09506032466888428,
                "num_nodes_avg": 407.5,
                "path_length_avg": 122.10575352004132,
                "smoothness_avg": 0.1154296410531563,
                "success_improvement": 0.0,
                "time_improvement": -93.79641533507504,
                "node_improvement": 48.188175460902734,
                "length_improvement": 18.903172563144594,
                "smoothness_improvement": 1368.2565140663191,
                "objective_score": -9.95573849230416
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "BCI-BiRRT: Beam-Compressed Informed BiRRT \u2014 a bidirectional planner that uses small-beam guided sampling, per-cell duplicate suppression, line-of-sight ancestor compression, grid-accelerated nearest/near queries, and k-near minimal-cost bridging with post-connection informed shortcuts to deliver fast, short, and smooth paths.",
        "planning_mechanism": "Mechanism: adaptively choose a tree to expand; sample a small beam (goal/line/informed-biased), steer and validate candidates, select the one that most reduces distance to the opposite tree, compress the parent via line-of-sight to an ancestor, commit the node (after node+edge checks and duplicate pruning), then attempt a k-near bridge to the opposite tree minimizing total start-to-goal cost; upon success, extract [start\u2192\u2026\u2192meetA, meetB\u2192\u2026\u2192goal], compress and shortcut, and return.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=6.0,\n                 beam_k=3,\n                 goal_bias=0.18,\n                 line_bias=0.35,\n                 connect_radius_factor=3.0,\n                 k_bridge=6,\n                 occ_gain_ratio=0.99,\n                 compress_depth=3,\n                 smoothing_iters=100,\n                 ellipse_tries=90,\n                 switch_fail_thresh=6,\n                 grid_cell=None):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_radius_factor = connect_radius_factor\n        self.k_bridge = k_bridge\n        self.occ_gain_ratio = occ_gain_ratio\n        self.compress_depth = compress_depth\n        self.smoothing_iters = smoothing_iters\n        self.ellipse_tries = ellipse_tries\n        self.switch_fail_thresh = switch_fail_thresh\n        self.grid_cell = grid_cell\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Basic parameters\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.edge_res = max(0.5, min(1.0, 0.5 * self.step_size))\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line check\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # Initialize trees (start-rooted, goal-rooted)\n        s_root = Node(start, None, 0.0)\n        g_root = Node(goal, None, 0.0)\n        start_tree = [s_root]\n        goal_tree = [g_root]\n        edges = []\n\n        grid_s = {}\n        grid_g = {}\n        self._grid_add(grid_s, s_root, self.grid_cell)\n        self._grid_add(grid_g, g_root, self.grid_cell)\n\n        # Per-cell best cost to suppress near-duplicates\n        occ_cell = max(0.5, 0.7 * self.step_size)\n        occ_s = {self._occ_key(start, occ_cell): 0.0}\n        occ_g = {self._occ_key(goal, occ_cell): 0.0}\n\n        # Bookkeeping\n        failed_s = 0\n        failed_g = 0\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            # Choose which tree to grow (adaptive alternation)\n            active_start = (it % 2 == 0)\n            if (active_start and failed_s >= self.switch_fail_thresh) or ((not active_start) and failed_g >= self.switch_fail_thresh):\n                active_start = not active_start\n\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_s if active_start else grid_g\n            grid_b = grid_g if active_start else grid_s\n            occ_a = occ_s if active_start else occ_g\n            root_other = goal if active_start else start\n            root_self = start if active_start else goal\n\n            # Beam sampling\n            candidates = []\n            for _ in range(self.beam_k):\n                x_rand = None\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                else:\n                    # informed ellipsoid after first solution\n                    if best_len < float('inf'):\n                        got = False\n                        for _t in range(self.ellipse_tries):\n                            p = self._uniform_point()\n                            if self._in_bounds(p):\n                                if self._dist(p, start) + self._dist(p, goal) <= best_len:\n                                    x_rand = p\n                                    got = True\n                                    break\n                        if not got:\n                            x_rand = self._uniform_point()\n                    else:\n                        if self._rand() < self.line_bias:\n                            # line-biased with jitter\n                            t = self._uniform(0.0, 1.0)\n                            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n                            jit = 0.5 * self.step_size\n                            x_rand = tuple(self._clip(base[i] + self._uniform(-jit, jit), 0.0, self.bounds[i]) for i in range(self.dim))\n                        else:\n                            x_rand = self._uniform_point()\n\n                # Nearest and steer\n                n_near = self._nearest(grid_a, tree_a, x_rand, self.grid_cell)\n                x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n                if not self._in_bounds(x_new_pos):\n                    continue\n                if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(n_near.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                    continue\n\n                # Line-of-sight ancestor compression (limited depth)\n                best_parent = n_near\n                best_cost = n_near.cost + self._dist(n_near.position, x_new_pos)\n                anc = n_near.parent\n                depth = 0\n                while anc is not None and depth < self.compress_depth:\n                    if not self._is_edge_in_obstacle(anc.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                        alt = anc.cost + self._dist(anc.position, x_new_pos)\n                        if alt + 1e-12 < best_cost:\n                            best_cost = alt\n                            best_parent = anc\n                    anc = anc.parent\n                    depth += 1\n\n                # Duplicate suppression in occupancy grid\n                k_occ = self._occ_key(x_new_pos, occ_cell)\n                prev_best = occ_a.get(k_occ, float('inf'))\n                if best_cost >= prev_best * self.occ_gain_ratio:\n                    continue\n\n                # Progress score: distance to other tree after extension\n                other_near = self._nearest(grid_b, tree_b, x_new_pos, self.grid_cell)\n                score = self._dist(x_new_pos, other_near.position) if other_near is not None else self._dist(x_new_pos, root_other)\n                candidates.append((score, x_new_pos, best_parent, best_cost))\n\n            if not candidates:\n                if active_start:\n                    failed_s += 1\n                else:\n                    failed_g += 1\n                continue\n\n            # Commit the best candidate\n            candidates.sort(key=lambda t: t[0])\n            _, new_pos, parent, new_cost = candidates[0]\n\n            new_node = Node(new_pos, None, new_cost)\n            new_node.attach(parent)\n            tree_a.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid_a, new_node, self.grid_cell)\n            k_occ_new = self._occ_key(new_pos, occ_cell)\n            if new_cost < occ_a.get(k_occ_new, float('inf')):\n                occ_a[k_occ_new] = new_cost\n\n            if active_start:\n                failed_s = 0\n            else:\n                failed_g = 0\n\n            # Attempt k-near best-cost bridge to the other tree\n            r_conn = max(self.connect_radius_factor * self.step_size, self.step_size)\n            near_b = self._near(grid_b, new_pos, r_conn, self.grid_cell)\n            if not near_b:\n                nn_b = self._nearest(grid_b, tree_b, new_pos, self.grid_cell)\n                if nn_b is not None:\n                    near_b = [nn_b]\n\n            # Select up to k closest in Euclidean distance to new_pos\n            if len(near_b) > self.k_bridge:\n                # partial selection\n                dist_idx = [(self._dist(n.position, new_pos), i) for i, n in enumerate(near_b)]\n                dist_idx.sort(key=lambda t: t[0])\n                near_b = [near_b[i] for (_, i) in dist_idx[:self.k_bridge]]\n\n            best_bridge = None\n            best_total = best_len\n            for nb in near_b:\n                if not self._is_edge_in_obstacle(new_pos, nb.position, obstacles, is_3d, self.edge_res):\n                    total = new_node.cost + self._dist(new_pos, nb.position) + nb.cost\n                    if total + 1e-12 < best_total:\n                        best_total = total\n                        best_bridge = nb\n\n            if best_bridge is not None:\n                # Extract path\n                if active_start:\n                    meet_a = new_node\n                    meet_b = best_bridge\n                else:\n                    meet_a = best_bridge\n                    meet_b = new_node\n\n                path = self._extract_path(meet_a, meet_b)\n                path = self._compress(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n                plen = self._path_length(path)\n                if plen < best_len:\n                    best_len = plen\n                    best_path = path\n                return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        # If loop ends without connection\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _uniform_point(self):\n        if self.dim == 3:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]),\n                    self._uniform(0.0, self.bounds[2]))\n        else:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]))\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return tuple(self._clip(to_pos[i], 0.0, self.bounds[i]) for i in range(self.dim))\n        r = step / d\n        return tuple(self._clip(from_pos[i] + (to_pos[i] - from_pos[i]) * r, 0.0, self.bounds[i]) for i in range(self.dim))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Spatial hash ----------\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        # Expand radius until found, then fallback to scan\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        limit = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > limit:\n                limit = self.bounds[i]\n        limit = limit * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # Fallback\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        r2 = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    # ---------- Path utilities ----------\n    def _path_to_root(self, node):\n        seq = []\n        cur = node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _extract_path(self, meet_a, meet_b):\n        # meet_a is in start-tree side, meet_b is in goal-tree side\n        path_a = self._path_to_root(meet_a)\n        # ascend from meet_b to goal root\n        tail = []\n        cur = meet_b\n        while cur is not None:\n            tail.append(cur.position)\n            cur = cur.parent\n        # path: start ... meet_a, then straight to meet_b (implied), then ... goal\n        return path_a + tail\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.edge_res):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
        "objective": -4.32865,
        "time_improvement": -45.0,
        "length_improvement": 16.0,
        "smoothness_improvement": 1649.0,
        "node_improvement": 81.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.05528700351715088,
                "num_nodes_avg": 52.7,
                "path_length_avg": 159.23267345792033,
                "smoothness_avg": 0.04720018064341601,
                "success_improvement": 0.0,
                "time_improvement": -116.82202007111755,
                "node_improvement": 86.72878368169226,
                "length_improvement": 12.722048474535743,
                "smoothness_improvement": 638.7853239022464,
                "objective_score": -24.219450317102588
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.128195858001709,
                "num_nodes_avg": 251.0,
                "path_length_avg": 244.97426414775782,
                "smoothness_avg": 0.11245472368962676,
                "success_improvement": 0.0,
                "time_improvement": 19.976282760218798,
                "node_improvement": 83.13512060740442,
                "length_improvement": 18.22053943424897,
                "smoothness_improvement": 2793.541038397612,
                "objective_score": 30.89291368060308
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06766645908355713,
                "num_nodes_avg": 219.1,
                "path_length_avg": 125.15812725071248,
                "smoothness_avg": 0.12691495233302894,
                "success_improvement": 0.0,
                "time_improvement": -37.949425846041684,
                "node_improvement": 72.14240305149396,
                "length_improvement": 16.875931269650575,
                "smoothness_improvement": 1514.3488257888052,
                "objective_score": 6.312475136921865
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "GH-Connect-Lite: Guided Hash RRT-Connect Lite \u2014 a single-tree, grid-accelerated planner that combines fast goal/line-biased informed sampling, lightweight duplicate suppression, short greedy goal-connection, and bounded smoothing. It commits only validated nodes/edges, uses an occupancy-cost ledger to avoid redundant expansions, and performs micro local shortcuts and post-improvement polishing for shorter, smoother paths while keeping per-iteration work small.",
        "planning_mechanism": "Initialize with early straight-line check. Maintain a hash-grid for fast nearest queries and a per-cell best-cost ledger. Each iteration: sample (goal/line/uniform; switch to ellipsoid gating after first solution), steer one step, validate node and edge, apply duplicate-cost filter, then commit the node. Perform a tiny greedy connect toward the goal (few steps) with the same validations and a local grandparent shortcut if it lowers cost. When near the goal, attempt a direct validated bridge; on improvement, run bounded compression/shortcuts to tighten c_best and focus sampling. Use post-optimization and no-improvement budgets to terminate early and return the best path found.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=4.0,\n        goal_bias=0.2,\n        line_bias=0.35,\n        connect_steps=2,\n        connect_radius_factor=3.0,\n        occ_relax=1.02,\n        post_opt_iters=500,\n        max_no_improve=220,\n        smoothing_iters=220,\n        online_shortcuts_per_improve=40\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_steps = connect_steps\n        self.connect_radius_factor = connect_radius_factor\n        self.occ_relax = occ_relax\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.online_shortcuts_per_improve = online_shortcuts_per_improve\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Early straight-line feasibility\n        if self._in_bounds(start) and self._in_bounds(goal):\n            if (not self._is_in_obstacle(start, obstacles, is_3d)) and (not self._is_in_obstacle(goal, obstacles, is_3d)):\n                if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d):\n                    s = Node(start, None, 0.0)\n                    g = Node(goal, None, self._dist(start, goal))\n                    g.attach(s)\n                    nodes = [s, g]\n                    edges = [(s, g)]\n                    path = [start, goal]\n                    return PlannerResult(success=True, path=path, nodes=nodes, edges=edges)\n\n        root = Node(start, None, 0.0)\n        nodes = [root]\n\n        cell = max(1.0, 0.8 * self.step_size)\n        grid = {}\n        self._grid_add(grid, root, cell)\n\n        occ_cell = max(0.5, 0.6 * self.step_size)\n        occ_best = {self._grid_key(start, occ_cell): 0.0}\n\n        success = False\n        goal_node = None\n        best_cost = float('inf')\n        best_path_pts = None\n\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            # Sampling\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                x_rand = self._sample(start, goal, best_cost)\n\n            # Nearest\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n            # Bounds and node collision\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Edge collision for candidate parent\n            if self._is_edge_in_obstacle(n_near.position, x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            base_cost = n_near.cost + self._dist(n_near.position, x_new_pos)\n\n            # Duplicate suppression\n            ok = self._occ_accept(occ_best, x_new_pos, base_cost, occ_cell, self.occ_relax)\n            if not ok:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Commit new node\n            x_new = Node(x_new_pos, None, base_cost)\n            x_new.attach(n_near)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            self._occ_update(occ_best, x_new_pos, base_cost, occ_cell)\n\n            # Local grandparent shortcut\n            gp = n_near.parent\n            if gp is not None:\n                alt = gp.cost + self._dist(gp.position, x_new.position)\n                if alt + 1e-12 < x_new.cost:\n                    if not self._is_edge_in_obstacle(gp.position, x_new.position, obstacles, is_3d):\n                        x_new.attach(gp)\n                        x_new.cost = alt\n                        self._occ_update(occ_best, x_new_pos, alt, occ_cell)\n\n            # Tiny greedy connect toward goal (few validated steps)\n            cur = x_new\n            for _ in range(self.connect_steps):\n                if self._dist(cur.position, goal) <= self.connect_radius_factor * self.step_size:\n                    break\n                step_pos = self._steer(cur.position, goal, self.step_size)\n                if not self._in_bounds(step_pos) or self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(cur.position, step_pos, obstacles, is_3d):\n                    break\n                c_cost = cur.cost + self._dist(cur.position, step_pos)\n                if not self._occ_accept(occ_best, step_pos, c_cost, occ_cell, self.occ_relax):\n                    break\n                nxt = Node(step_pos, None, c_cost)\n                nxt.attach(cur)\n                nodes.append(nxt)\n                self._grid_add(grid, nxt, cell)\n                self._occ_update(occ_best, step_pos, c_cost, occ_cell)\n                # Local grandparent shortcut for connect step\n                gp2 = cur.parent\n                if gp2 is not None:\n                    alt2 = gp2.cost + self._dist(gp2.position, nxt.position)\n                    if alt2 + 1e-12 < nxt.cost:\n                        if not self._is_edge_in_obstacle(gp2.position, nxt.position, obstacles, is_3d):\n                            nxt.attach(gp2)\n                            nxt.cost = alt2\n                            self._occ_update(occ_best, step_pos, alt2, occ_cell)\n                cur = nxt\n\n            # Try direct goal connection when near\n            improved = False\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                r_conn = self.connect_radius_factor * self.step_size\n                tip = cur\n                if self._dist(tip.position, goal) <= r_conn:\n                    if not self._is_edge_in_obstacle(tip.position, goal, obstacles, is_3d):\n                        g_cost = tip.cost + self._dist(tip.position, goal)\n                        if g_cost + 1e-12 < best_cost:\n                            if goal_node is None:\n                                goal_node = Node(goal, None, g_cost)\n                                goal_node.attach(tip)\n                                nodes.append(goal_node)\n                            else:\n                                goal_node.attach(tip)\n                                goal_node.cost = g_cost\n                            best_cost = g_cost\n                            success = True\n                            found_first = True\n                            improved = True\n\n            # Post-improvement polishing\n            if improved and goal_node is not None:\n                cur_path = self._extract_path(goal_node)\n                cur_path = self._compress(cur_path, obstacles, is_3d)\n                cur_path = self._shortcuts(cur_path, obstacles, is_3d, self.online_shortcuts_per_improve)\n                L = self._path_length(cur_path)\n                if L + 1e-12 < best_cost:\n                    best_cost = L\n                best_path_pts = cur_path\n                post_iters = 0\n                no_improve = 0\n            else:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        # Final path\n        path = []\n        if success and goal_node is not None:\n            if best_path_pts is None:\n                path = self._extract_path(goal_node)\n                path = self._compress(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n            else:\n                path = self._shortcuts(best_path_pts, obstacles, is_3d, self.smoothing_iters)\n\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # --------- Utilities ---------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 390451501\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Spatial hashing\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        limit = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > limit:\n                limit = self.bounds[i]\n        limit = limit * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # Sampling with informed gating after first solution\n    def _sample(self, start, goal, c_best):\n        if c_best < float('inf'):\n            for _ in range(120):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p):\n                    if self._dist(p, start) + self._dist(p, goal) <= c_best:\n                        return p\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jitter = 0.5 * self.step_size\n            return tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    # Occupancy cost ledger\n    def _occ_accept(self, occ_best, pos, cost, cell, relax):\n        k = self._grid_key(pos, cell)\n        prev = occ_best.get(k, float('inf'))\n        return cost < prev * relax\n\n    def _occ_update(self, occ_best, pos, cost, cell):\n        k = self._grid_key(pos, cell)\n        prev = occ_best.get(k, float('inf'))\n        if cost < prev:\n            occ_best[k] = cost\n\n    # Path utilities\n    def _extract_path(self, goal_node):\n        seq = []\n        cur = goal_node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
        "objective": 2.59026,
        "time_improvement": -73.0,
        "length_improvement": 19.0,
        "smoothness_improvement": 1563.0,
        "node_improvement": 9.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.06812853813171386,
                "num_nodes_avg": 406.1,
                "path_length_avg": 156.52382632264067,
                "smoothness_avg": 0.05238387996289982,
                "success_improvement": 0.0,
                "time_improvement": -167.18335815808737,
                "node_improvement": -2.2664316293125157,
                "length_improvement": 14.20681051381224,
                "smoothness_improvement": 719.921474835408,
                "objective_score": -38.03131376496182
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.16287810802459718,
                "num_nodes_avg": 1172.8,
                "path_length_avg": 229.408680422303,
                "smoothness_avg": 0.09093924935533,
                "success_improvement": 0.0,
                "time_improvement": -1.673422716490134,
                "node_improvement": 21.198683061210776,
                "length_improvement": 23.4167793122916,
                "smoothness_improvement": 2239.9323868063857,
                "objective_score": 24.747702706459847
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.0729496955871582,
                "num_nodes_avg": 734.6,
                "path_length_avg": 121.75542214035515,
                "smoothness_avg": 0.1438275075521862,
                "success_improvement": 0.0,
                "time_improvement": -48.7201895619418,
                "node_improvement": 6.598855689764778,
                "length_improvement": 19.135845984544524,
                "smoothness_improvement": 1729.4752798215147,
                "objective_score": 5.512827121251748
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "Beam-guided BiRRT with ancestor line-of-sight compression and spatial hashing (BG-Connect-LOS). The planner alternates tree growth from start and goal using a small beam of guided samples, accelerates nearest lookups with a grid hash, suppresses near-duplicate nodes, and selects a parent among recent ancestors that maintains direct line-of-sight to the new point to compress chains. A short, capped greedy connect links the two trees. Upon success, a bounded shortcut pass refines the path. This reduces expansions and collision checks while improving path quality and smoothness.",
        "planning_mechanism": "At each iteration, pick the active tree and generate a small beam of guided samples biased toward the opposite root. For each sample: find a nearby node via spatial hashing, steer by a fixed step, enforce node and edge collision checks, reject near-duplicates, and pick an ancestor parent with clear line-of-sight to minimize added cost. Insert the node and attempt a capped greedy connect from the opposite tree toward it; if the two trees meet, extract and lightly shortcut the path. Alternate trees and stop early on success.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        beam_width=3,\n        goal_bias=0.15,\n        connect_steps_limit=20,\n        min_separation_factor=0.6,\n        grid_cell_factor=1.0,\n        los_lookback_depth=8,\n        shortcut_attempts=40\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.connect_steps_limit = connect_steps_limit\n        self.min_separation_factor = min_separation_factor\n        self.grid_cell_factor = grid_cell_factor\n        self.los_lookback_depth = los_lookback_depth\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dims = len(bounds)\n        is_3d = dims == 3\n\n        # Parameters derived from step_size\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root = Node(goal_position, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root, is_3d)\n        self._grid_insert(grid_b, goal_root, is_3d)\n\n        success_state = False\n        extracted_path = []\n\n        for _ in range(self.max_iter):\n            # Alternate trees by swapping references each loop\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, goal_position),\n                (tree_b, grid_b, tree_a, grid_a, start_position),\n            ]:\n                made_progress = False\n\n                for _beam in range(self.beam_width):\n                    sample = self._sample_guided(bounds, obstacles, is_3d, attractor)\n\n                    nearest = self._nearest_by_grid(active_tree, active_grid, sample, is_3d)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos, bounds):\n                        continue\n                    if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                        continue\n                    if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                        continue\n                    if self._has_near_duplicate(active_grid, new_pos, self.min_separation, is_3d):\n                        continue\n\n                    # Choose parent among LOS-capable ancestors to compress path\n                    parent = self._choose_ancestor_parent(nearest, new_pos, obstacles, is_3d)\n                    new_cost = parent.cost + self._distance(parent.position, new_pos)\n\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node, is_3d)\n                    made_progress = True\n\n                    # Try capped greedy connect from the opposite tree toward new_node\n                    connect_node = self._attempt_connect(\n                        other_tree, other_grid, new_node.position, obstacles, is_3d, nodes, edges, bounds\n                    )\n                    if connect_node is not None:\n                        # Trees meet at new_node.position; extract path\n                        path_a = self._path_from_root(new_node)\n                        path_b = self._path_from_root(connect_node)\n                        # Remove duplicate joint if equal\n                        if path_a and path_b and path_a[-1] == path_b[-1]:\n                            path_b = path_b[:-1]\n                        raw_path = path_a + path_b[::-1]\n                        # Light shortcut smoothing\n                        smoothed = self._shortcut_path(raw_path, obstacles, is_3d, attempts=self.shortcut_attempts)\n                        extracted_path = smoothed if smoothed else raw_path\n                        success_state = True\n                        return PlannerResult(True, extracted_path, nodes, edges)\n\n                # If neither beam sample made progress for this tree, continue with the other\n                if not made_progress:\n                    continue\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # --------- Core Geometry / Utilities ---------\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _within_bounds(self, pos, bounds):\n        for i in range(len(bounds)):\n            if pos[i] < 0.0 or pos[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= 1e-9:\n            return from_pos\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * r for d in range(len(from_pos)))\n\n    def _sample_guided(self, bounds, obstacles, is_3d, target):\n        # Mild guidance: with some probability sample exactly target, else blend toward target\n        while True:\n            if random.random() < self.goal_bias:\n                p = target\n            else:\n                rand = tuple(random.uniform(0.0, bounds[d]) for d in range(len(bounds)))\n                alpha = 0.2\n                p = tuple(alpha * target[d] + (1.0 - alpha) * rand[d] for d in range(len(bounds)))\n            if self._within_bounds(p, bounds) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _path_from_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\n\n    # --------- Spatial Hash (Grid) ---------\n\n    def _cell_of(self, pos):\n        # integer grid cell indices\n        if len(pos) == 3:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        else:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node, is_3d):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _has_near_duplicate(self, grid, pos, radius, is_3d):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    def _nearest_by_grid(self, tree, grid, pos, is_3d, ring_limit=3):\n        # Search neighborhood rings; fallback to linear scan if not found\n        cell = self._cell_of(pos)\n        best = None\n        best_d = float(\"inf\")\n\n        if is_3d:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best_d = d\n                                        best = n\n                                        found = True\n                if found and best is not None:\n                    return best\n        else:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                                    found = True\n                if found and best is not None:\n                    return best\n\n        # Fallback\n        if not tree:\n            return None\n        return min(tree, key=lambda n: self._distance(n.position, pos))\n\n    # --------- Parent selection via LOS to ancestors ---------\n\n    def _choose_ancestor_parent(self, nearest, new_pos, obstacles, is_3d):\n        best_parent = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        steps = 0\n        cur = nearest\n        while cur is not None and steps < self.los_lookback_depth:\n            if not self._is_edge_in_obstacle(cur.position, new_pos, obstacles, is_3d):\n                cand_cost = cur.cost + self._distance(cur.position, new_pos)\n                if cand_cost < best_cost:\n                    best_cost = cand_cost\n                    best_parent = cur\n            cur = cur.parent\n            steps += 1\n        return best_parent\n\n    # --------- Connect attempt ---------\n\n    def _attempt_connect(self, tree, grid, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest_by_grid(tree, grid, target_pos, is_3d)\n        if nearest is None:\n            return None\n\n        current = nearest\n        for _ in range(self.connect_steps_limit):\n            step_pos = self._steer(current.position, target_pos)\n            if not self._within_bounds(step_pos, bounds):\n                return None\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                return None\n\n            # If close enough to target and direct edge exists, finalize with exact target node\n            if self._distance(step_pos, target_pos) <= 1e-6 or (\n                self._distance(step_pos, target_pos) <= self.step_size and\n                not self._is_edge_in_obstacle(step_pos, target_pos, obstacles, is_3d) and\n                not self._is_in_obstacle(target_pos, obstacles, is_3d)\n            ):\n                # Add intermediate step node if it is not exactly current\n                if self._distance(current.position, step_pos) > 1e-9:\n                    if not self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                        new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n                        current.add_child(new_node)\n                        tree.append(new_node)\n                        nodes.append(new_node)\n                        edges.append((current, new_node))\n                        self._grid_insert(grid, new_node, is_3d)\n                        current = new_node\n                    else:\n                        # If duplicate exists, try using current as is\n                        pass\n                # Add final node at the exact target position to guarantee path merge\n                final_node = Node(target_pos, parent=current, cost=current.cost + self._distance(current.position, target_pos))\n                current.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((current, final_node))\n                self._grid_insert(grid, final_node, is_3d)\n                return final_node\n\n            # Regular step addition with duplicate suppression\n            if self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                # Progress is negligible; stop trying to avoid loops\n                return None\n\n            new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node, is_3d)\n            current = new_node\n\n        return None\n\n    # --------- Collision Checking ---------\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d):\n        distance = self._distance(from_pos, to_pos)\n        resolution = max(0.5, min(1.0, self.step_size * 0.5))\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    # --------- Shortcut Smoothing (bounded) ---------\n\n    def _shortcut_path(self, path, obstacles, is_3d, attempts=40):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        n = len(pts)\n        tries = 0\n        i = 0\n        # Greedy forward skipping with bounded iterations\n        while i < len(pts) - 2 and tries < attempts:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                    # Remove intermediates\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n            tries += 1\n        return pts",
        "objective": -28.86257,
        "time_improvement": 43.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 1410.0,
        "node_improvement": 90.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.03400664329528809,
                "num_nodes_avg": 52.1,
                "path_length_avg": 171.51876006638196,
                "smoothness_avg": 0.050501544373221775,
                "success_improvement": 0.0,
                "time_improvement": -33.36568499023374,
                "node_improvement": 86.87987912364643,
                "length_improvement": 5.987849718937115,
                "smoothness_improvement": 690.45883529979,
                "objective_score": -2.964701489208901
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.030187082290649415,
                "num_nodes_avg": 92.2,
                "path_length_avg": 234.31486940525366,
                "smoothness_avg": 0.08620583217892899,
                "success_improvement": 0.0,
                "time_improvement": 81.1563136658539,
                "node_improvement": 93.8050124302896,
                "length_improvement": 21.77895221296278,
                "smoothness_improvement": 2118.138153515002,
                "objective_score": 48.004956195108846
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.009754443168640136,
                "num_nodes_avg": 73.2,
                "path_length_avg": 124.45355479806292,
                "smoothness_avg": 0.11960663519260235,
                "success_improvement": 0.0,
                "time_improvement": 80.11393158758125,
                "node_improvement": 90.69294342021614,
                "length_improvement": 17.343874744565582,
                "smoothness_improvement": 1421.3875712064366,
                "objective_score": 41.54744217904591
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "BG-BiRRT-LC: Beam-Guided Bidirectional RRT-Connect with Line-of-Sight Compression, Duplicate Suppression, Spatial Hashing, and Informed Sampling. It prioritizes time efficiency by limiting neighbor/rewire costs, pruning near-duplicates, compressing parents via direct line-of-sight, and using a beam of goal-directed samples with a lightweight grid for fast nearest/near queries.",
        "planning_mechanism": "Alternate expanding start/goal trees: for each side, beam-sample k candidates (goal-biased and informed after first path), pick the most promising, steer one step, validate node and edge, suppress near-duplicates, pick a best parent from a tiny local set, then compress to an ancestor if line-of-sight holds. Attempt a bounded greedy connect from the other tree to the new node. Upon a connection, merge paths and optionally continue a few refinement iterations; finally apply capped shortcut smoothing.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def detach_from_parent(self):\n        if self.parent is not None and self in self.parent.children:\n            self.parent.children.remove(self)\n        self.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 9.0,\n        goal_bias: float = 0.12,\n        beam_k: int = 3,\n        parent_k: int = 5,\n        connect_steps: int = 6,\n        time_limit_sec: float = 15.0,\n        smooth_attempts: int = 80,\n        post_opt_iters: int = 120,\n        no_improve_limit: int = 80,\n        compress_ancestors: int = 3\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.beam_k = max(1, beam_k)\n        self.parent_k = max(1, parent_k)\n        self.connect_steps = connect_steps\n        self.time_limit_sec = time_limit_sec\n        self.smooth_attempts = smooth_attempts\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.compress_ancestors = compress_ancestors\n\n        # Spatial hash cell size and duplicate suppression radii\n        self.cell_size = max(6.0, step_size * 1.5)\n        self.dup_radius = step_size * 1.25\n        self.dup_thresh = step_size * 0.6\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n        success_state = False\n        best_path = []\n        best_cost = float('inf')\n\n        # Roots\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Spatial hashes\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        c_min = self._dist(start_position, goal_position)\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        t0 = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - t0 > self.time_limit_sec:\n                break\n\n            # Alternate expansion\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n                grid_a, grid_b = grid_start, grid_goal\n                root_a, root_b = start_root, goal_root\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n                grid_a, grid_b = grid_goal, grid_start\n                root_a, root_b = goal_root, start_root\n\n            # Beam-guided sampling\n            x_rand = self._beam_sample(bounds, obstacles, is_3d, root_a.position, root_b.position, best_cost, c_min, grid_a, tree_a)\n\n            # Nearest and steer\n            a_near = self._nearest(grid_a, tree_a, x_rand, bounds)\n            a_new_pos = self._steer(a_near.position, x_rand, self.step_size)\n\n            # Bounds and collision checks before adding\n            if not self._in_bounds(a_new_pos, bounds):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n            if self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n            if self._hit_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Duplicate/near-duplicate suppression\n            near_dups = self._grid_neighbors(grid_a, a_new_pos, self.dup_radius)\n            skip = False\n            for nb in near_dups:\n                if self._dist(nb.position, a_new_pos) <= self.dup_thresh:\n                    skip = True\n                    break\n            if skip:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Parent selection among a tiny local set\n            parent_radius = max(self.step_size * 2.0, 12.0)\n            neighbors = self._grid_neighbors(grid_a, a_new_pos, parent_radius)\n            if not neighbors:\n                neighbors = [a_near]\n            # Choose up to parent_k closest neighbors\n            neighbors.sort(key=lambda n: self._dist(n.position, a_new_pos))\n            candidates = neighbors[:self.parent_k]\n\n            best_parent = None\n            best_g = float('inf')\n            for cand in candidates:\n                if self._hit_obstacle(cand.position, a_new_pos, obstacles, is_3d):\n                    continue\n                g = cand.cost + self._dist(cand.position, a_new_pos)\n                if g < best_g:\n                    best_g = g\n                    best_parent = cand\n\n            if best_parent is None:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Line-of-sight compression to ancestors\n            best_parent, best_g = self._compress_parent(best_parent, a_new_pos, best_g, obstacles, is_3d)\n\n            # Add node to tree_a\n            a_new = Node(a_new_pos, parent=None, cost=best_g)\n            best_parent.add_child(a_new)\n            tree_a.append(a_new)\n            nodes.append(a_new)\n            edges.append((best_parent, a_new))\n            self._grid_add(grid_a, a_new)\n\n            # Attempt to connect other tree to this new node\n            b_meet = self._try_connect(tree_b, grid_b, a_new, obstacles, is_3d, bounds, nodes, edges)\n            if b_meet is not None:\n                # Merge path start->goal\n                pathA = a_new.path_from_root()\n                pathB = b_meet.path_from_root()\n                if root_a is start_root:\n                    merged = pathA + pathB[-2::-1]\n                else:\n                    merged = pathB + pathA[-2::-1]\n\n                cost = self._path_cost(merged)\n                if cost < best_cost - 1e-9:\n                    best_cost = cost\n                    best_path = merged\n                    success_state = True\n                    no_improve = 0\n                else:\n                    no_improve += 1\n\n                if not found_first:\n                    found_first = True\n                    post_iters = 0\n                else:\n                    post_iters += 1\n\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n            else:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n\n        # Final smoothing\n        if success_state and best_path:\n            best_path = self._shortcut_smooth(best_path, obstacles, is_3d, attempts=self.smooth_attempts)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------- Spatial Hash ----------------\n    def _key(self, pos):\n        return tuple(int(pos[d] // self.cell_size) for d in range(len(pos)))\n\n    def _grid_add(self, grid, node):\n        k = self._key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_neighbors(self, grid, pos, radius):\n        dim = len(pos)\n        span = int(max(1, math.ceil(radius / self.cell_size)))\n        kc = self._key(pos)\n        result = []\n        if dim == 2:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    k = (kc[0] + dx, kc[1] + dy)\n                    if k in grid:\n                        for n in grid[k]:\n                            if self._dist(n.position, pos) <= radius:\n                                result.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        k = (kc[0] + dx, kc[1] + dy, kc[2] + dz)\n                        if k in grid:\n                            for n in grid[k]:\n                                if self._dist(n.position, pos) <= radius:\n                                    result.append(n)\n        return result\n\n    def _nearest(self, grid, tree, pos, bounds):\n        radius = self.cell_size\n        for _ in range(4):\n            cands = self._grid_neighbors(grid, pos, radius)\n            if cands:\n                return min(cands, key=lambda n: self._dist(n.position, pos))\n            radius *= 2.0\n        return min(tree, key=lambda n: self._dist(n.position, pos))\n\n    # --------------- Beam-Guided Sampling ---------------\n    def _beam_sample(self, bounds, obstacles, is_3d, root_a, root_b, c_best, c_min, grid_a, tree_a):\n        # Goal bias\n        if random.random() < self.goal_bias:\n            goal_tgt = root_b\n            if not self._is_in_obstacle(goal_tgt, obstacles, is_3d):\n                return goal_tgt\n\n        best = None\n        best_score = float('inf')\n        for _ in range(self.beam_k):\n            if c_best < float('inf') and c_min > 1e-12:\n                x = self._sample_informed_ellipsoid(root_a, root_b, c_best, c_min, bounds)\n            else:\n                x = self._sample_uniform_free(bounds, obstacles, is_3d)\n            # Score: favor closeness to opposite root and ease of reaching from current tree\n            near = self._nearest(grid_a, tree_a, x, bounds)\n            score = self._dist(x, root_b) + 0.3 * self._dist(near.position, x)\n            if score < best_score:\n                best_score = score\n                best = x\n        return best\n\n    def _sample_uniform_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]), random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_informed_ellipsoid(self, start, goal, c_best, c_min, bounds):\n        dim = len(bounds)\n        # Prolate ellipsoid with foci at start and goal\n        r1 = c_best / 2.0\n        r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n        center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n        a1 = self._unit(self._vec(goal, start))\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r2)\n        else:\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._unit(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._unit(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r2, r2)\n\n        u = self._sample_unit_ball(dim)\n        x = [center[d] for d in range(dim)]\n        for i in range(dim):\n            for d in range(dim):\n                x[d] += basis[i][d] * radii[i] * u[i]\n        x = tuple(min(max(x[d], 0.0), bounds[d]) for d in range(dim))\n        return x\n\n    def _sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(vi * vi for vi in v))\n            if n > 1e-12:\n                v = [vi / n for vi in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    # --------------- Parent Compression ---------------\n    def _compress_parent(self, parent, new_pos, current_g, obstacles, is_3d):\n        # Try a few ancestors for direct line-of-sight to reduce chain depth\n        anc = parent\n        best_parent = parent\n        best_g = current_g\n        steps = 0\n        while anc is not None and anc.parent is not None and steps < self.compress_ancestors:\n            grand = anc.parent\n            if not self._hit_obstacle(grand.position, new_pos, obstacles, is_3d):\n                g = grand.cost + self._dist(grand.position, new_pos)\n                if g + 1e-12 < best_g:\n                    best_g = g\n                    best_parent = grand\n            anc = grand\n            steps += 1\n        return best_parent, best_g\n\n    # --------------- Connect Attempt ---------------\n    def _try_connect(self, tree, grid, target_node, obstacles, is_3d, bounds, nodes, edges):\n        target_pos = target_node.position\n        connect_thresh = self.step_size * 1.2\n\n        # Try direct connect via best local parent\n        rad = max(self.step_size * 2.0, 12.0)\n        neigh = self._grid_neighbors(grid, target_pos, rad)\n        if not neigh:\n            neigh = [self._nearest(grid, tree, target_pos, bounds)]\n        neigh.sort(key=lambda n: self._dist(n.position, target_pos))\n        candidates = neigh[:self.parent_k]\n        best_parent = None\n        best_g = float('inf')\n        for cand in candidates:\n            if self._hit_obstacle(cand.position, target_pos, obstacles, is_3d):\n                continue\n            g = cand.cost + self._dist(cand.position, target_pos)\n            if g < best_g:\n                best_g = g\n                best_parent = cand\n        if best_parent is not None:\n            if (not self._is_in_obstacle(target_pos, obstacles, is_3d)):\n                meet = Node(target_pos, parent=None, cost=best_g)\n                best_parent.add_child(meet)\n                tree.append(meet)\n                nodes.append(meet)\n                edges.append((best_parent, meet))\n                self._grid_add(grid, meet)\n                return meet\n\n        # Greedy bounded stepping toward target\n        current = self._nearest(grid, tree, target_pos, bounds)\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(current.position, target_pos, self.step_size)\n            if not self._in_bounds(nxt, bounds):\n                return None\n            if self._is_in_obstacle(nxt, obstacles, is_3d):\n                return None\n            if self._hit_obstacle(current.position, nxt, obstacles, is_3d):\n                return None\n\n            # Duplicate suppression in other tree\n            near_dups = self._grid_neighbors(grid, nxt, self.dup_radius)\n            dup = False\n            for nb in near_dups:\n                if self._dist(nb.position, nxt) <= self.dup_thresh:\n                    dup = True\n                    break\n            if dup:\n                return None\n\n            # Choose local parent\n            neigh2 = self._grid_neighbors(grid, nxt, rad)\n            if not neigh2:\n                neigh2 = [current]\n            neigh2.sort(key=lambda n: self._dist(n.position, nxt))\n            cand2 = neigh2[:self.parent_k]\n\n            best_p = None\n            best_g2 = float('inf')\n            for cand in cand2:\n                if self._hit_obstacle(cand.position, nxt, obstacles, is_3d):\n                    continue\n                g2 = cand.cost + self._dist(cand.position, nxt)\n                if g2 < best_g2:\n                    best_g2 = g2\n                    best_p = cand\n            if best_p is None:\n                return None\n\n            new_b = Node(nxt, parent=None, cost=best_g2)\n            best_p.add_child(new_b)\n            tree.append(new_b)\n            nodes.append(new_b)\n            edges.append((best_p, new_b))\n            self._grid_add(grid, new_b)\n\n            # Close enough for final snap\n            if self._dist(new_b.position, target_pos) <= connect_thresh:\n                if (not self._is_in_obstacle(target_pos, obstacles, is_3d)) and (not self._hit_obstacle(new_b.position, target_pos, obstacles, is_3d)):\n                    final_b = Node(target_pos, parent=None, cost=new_b.cost + self._dist(new_b.position, target_pos))\n                    new_b.add_child(final_b)\n                    tree.append(final_b)\n                    nodes.append(final_b)\n                    edges.append((new_b, final_b))\n                    self._grid_add(grid, final_b)\n                    return final_b\n                return None\n\n            current = new_b\n            steps += 1\n\n        return None\n\n    # --------------- Utilities ---------------\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _vec(self, a, b):\n        return tuple(a[i] - b[i] for i in range(len(a)))\n\n    def _norm(self, v):\n        return math.sqrt(sum(vi * vi for vi in v))\n\n    def _unit(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return tuple(0.0 for _ in v)\n        return tuple(vi / n for vi in v)\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0.0 <= pos[i] <= bounds[i] for i in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _hit_obstacle(self, a, b, obstacles, is_3d, res=1.0):\n        L = self._dist(a, b)\n        steps = max(1, int(L / res))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(len(a)))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _path_cost(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(len(path) - 1):\n            s += self._dist(path[i], path[i + 1])\n        return s\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, attempts=80):\n        if len(path) < 3:\n            return path[:]\n        best = path[:]\n        best_cost = self._path_cost(best)\n        n = len(best)\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = best[i]\n            b = best[j]\n            if not self._hit_obstacle(a, b, obstacles, is_3d):\n                new_path = best[:i + 1] + best[j:]\n                new_cost = self._path_cost(new_path)\n                if new_cost < best_cost - 1e-9:\n                    best = new_path\n                    best_cost = new_cost\n                    n = len(best)\n        # Greedy corner culling\n        changed = True\n        while changed and len(best) > 2:\n            changed = False\n            k = 1\n            while k < len(best) - 1:\n                if not self._hit_obstacle(best[k - 1], best[k + 1], obstacles, is_3d):\n                    best.pop(k)\n                    changed = True\n                else:\n                    k += 1\n        return best\n\n    # --------------- Controls ---------------\n    def _post_update(self, found_first, post_iters, no_improve):\n        if found_first:\n            post_iters += 1\n            no_improve += 1\n        return post_iters, no_improve\n\n    def _should_stop(self, found_first, post_iters, no_improve):\n        if not found_first:\n            return False\n        if post_iters >= self.post_opt_iters:\n            return True\n        if no_improve >= self.no_improve_limit:\n            return True\n        return False",
        "objective": -12.24798,
        "time_improvement": -23.0,
        "length_improvement": 19.0,
        "smoothness_improvement": 1613.0,
        "node_improvement": 89.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.044426774978637694,
                "num_nodes_avg": 56.4,
                "path_length_avg": 157.31603480322116,
                "smoothness_avg": 0.04606013663224119,
                "success_improvement": 0.0,
                "time_improvement": -74.23087675795257,
                "node_improvement": 85.79702845630824,
                "length_improvement": 13.772588492259377,
                "smoothness_improvement": 620.9411594821662,
                "objective_score": -10.901004134619315
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.16415343284606934,
                "num_nodes_avg": 126.7,
                "path_length_avg": 235.87995732976475,
                "smoothness_avg": 0.12420346154518477,
                "success_improvement": 0.0,
                "time_improvement": -2.469518896922128,
                "node_improvement": 91.4869313982396,
                "length_improvement": 21.256480815202853,
                "smoothness_improvement": 3095.8445256949494,
                "objective_score": 27.49225544851982
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.045468711853027345,
                "num_nodes_avg": 87.9,
                "path_length_avg": 119.57596595535551,
                "smoothness_avg": 0.09609107280574067,
                "success_improvement": 0.0,
                "time_improvement": 7.30440488486542,
                "node_improvement": 88.82390336935792,
                "length_improvement": 20.583337008070234,
                "smoothness_improvement": 1122.2713533838182,
                "objective_score": 20.152680437220855
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "C3-IRRT#-Beam: Cached, Cell-Capped Informed RRT# with Beamed Rewiring and LOS Bridging \u2014 a single-tree, cost-optimal planner that combines quantized collision caching across all phases, tuned spatial hashing, per-cell admission with best-cost ledgers, admissible heuristic pruning, correct-cost rewiring with on-node propagation, and early-terminating cached smoothing to deliver faster solves and shorter, smoother paths.",
        "planning_mechanism": "At each iteration, sample with goal/line bias and informed-ellipse gating after the first solution; steer a bounded step from the hashed-nearest node; validate node and edge (with cache); select the lowest-cost valid parent within an adaptive neighborhood under heuristic pruning and per-cell cost admission; commit the node, then rewire a small beam of cheaper neighbors with cost-correct subtree updates. Opportunistically perform direct line-of-sight goal bridging from nearby nodes. After improvements, run a few cached shortcuts to contract c_best and focus the informed set. Stop on post-optimization budgets and return a compressed, smoothed path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n        self.parent = new_parent\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=3800,\n                 step_size=5.0,\n                 goal_bias=0.22,\n                 line_bias=0.40,\n                 gamma_radius=70.0,\n                 min_radius_factor=1.0,\n                 near_cap=56,\n                 cell_cap=3,\n                 admit_gain_ratio=0.99,\n                 prune_margin=1.001,\n                 rewire_cap=14,\n                 post_opt_iters=360,\n                 no_improve_limit=160,\n                 smoothing_iters=160,\n                 ellipse_tries=64,\n                 online_shortcuts_per_improve=32):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.gamma_radius = gamma_radius\n        self.min_radius_factor = min_radius_factor\n        self.near_cap = near_cap\n        self.cell_cap = cell_cap\n        self.admit_gain_ratio = admit_gain_ratio\n        self.prune_margin = prune_margin\n        self.rewire_cap = rewire_cap\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.smoothing_iters = smoothing_iters\n        self.ellipse_tries = ellipse_tries\n        self.online_shortcuts_per_improve = online_shortcuts_per_improve\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Endpoint validation\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(success=False, path=[], nodes=[], edges=[])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(success=False, path=[], nodes=[], edges=[])\n\n        # RNG and caches\n        self._init_rng()\n        self._edge_cache = {}\n        self._seg_qres = max(0.25, 0.5 * self.step_size)\n\n        # Early straight-line solution\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            path = [start, goal]\n            return PlannerResult(success=True, path=path, nodes=nodes, edges=edges)\n\n        # Initialize structures\n        root = Node(start, None, 0.0)\n        nodes = [root]\n\n        cell = max(1.0, 1.25 * self.step_size)\n        grid = {}\n        self._grid_add(grid, root, cell)\n\n        # Per-cell throttling and cost-ledger\n        occ = {}\n        self._occ_inc(occ, self._grid_key(start, cell))\n        dup_cell = max(0.5, 0.6 * self.step_size)\n        occ_best_cost = {self._occ_key(start, dup_cell): 0.0}\n\n        best_cost = float('inf')\n        goal_node = None\n        success = False\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n        best_path_pts = None\n\n        for it in range(self.max_iter):\n            # Sampling\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                x_rand = self._sample(start, goal, best_cost)\n\n            # Nearest\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n            # Bounds and node collision\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Cell throttling\n            kcell = self._grid_key(x_new_pos, cell)\n            if occ.get(kcell, 0) >= max(1, self.cell_cap):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Edge collision from nearest (cached)\n            if self._edge_blocked(n_near.position, x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Parent selection within adaptive radius, heuristic-pruned\n            r_near = self._rrtstar_radius(max(2, len(nodes)))\n            near_nodes = self._near(grid, x_new_pos, r_near, cell)\n            if n_near not in near_nodes:\n                near_nodes.append(n_near)\n            if near_nodes:\n                near_nodes = self._k_nearest_limit(near_nodes, x_new_pos, self.near_cap)\n\n            best_parent = None\n            best_pc = float('inf')\n\n            for p in near_nodes:\n                # Heuristic pruning against current best solution\n                base = p.cost + self._dist(p.position, x_new_pos)\n                if best_cost < float('inf'):\n                    h = self._dist(x_new_pos, goal)\n                    if base + h >= best_cost * self.prune_margin:\n                        continue\n                if base + 1e-12 < best_pc:\n                    if not self._edge_blocked(p.position, x_new_pos, obstacles, is_3d):\n                        best_pc = base\n                        best_parent = p\n\n            if best_parent is None:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Per-cell best-cost duplicate suppression\n            kdup = self._occ_key(x_new_pos, dup_cell)\n            prev_best = occ_best_cost.get(kdup, float('inf'))\n            if best_pc >= prev_best * self.admit_gain_ratio:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Commit node (node and edge checks satisfied)\n            x_new = Node(x_new_pos, None, best_pc)\n            x_new.attach(best_parent)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            self._occ_inc(occ, kcell)\n            if best_pc < prev_best:\n                occ_best_cost[kdup] = best_pc\n\n            # Rewire a small beam of neighbors for efficiency\n            # Select promising neighbors by potential gain\n            rewire_cands = []\n            for q in near_nodes:\n                if q is x_new or q is best_parent:\n                    continue\n                alt = x_new.cost + self._dist(x_new.position, q.position)\n                if alt + 1e-12 < q.cost:\n                    if best_cost < float('inf'):\n                        # prune rewires unlikely to improve final cost\n                        h = self._dist(q.position, goal)\n                        if alt + h >= best_cost * self.prune_margin:\n                            continue\n                    rewire_cands.append((q.cost - alt, q, alt))\n            # Process up to rewire_cap best gains\n            if rewire_cands:\n                rewire_cands.sort(key=lambda t: t[0], reverse=True)\n                for _, q, alt in rewire_cands[:max(1, self.rewire_cap)]:\n                    if not self._edge_blocked(x_new.position, q.position, obstacles, is_3d):\n                        q.attach(x_new)\n                        q.cost = alt\n                        self._propagate_costs_from(q)\n\n            # Goal bridging via best nearby parent\n            improved = False\n            r_conn = max(r_near, 2.0 * self.step_size)\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                cand_goal = self._near(grid, goal, r_conn, cell)\n                if x_new not in cand_goal:\n                    cand_goal.append(x_new)\n                best_goal_parent = None\n                best_goal_cost = best_cost\n                for p in cand_goal:\n                    gcost = p.cost + self._dist(p.position, goal)\n                    if gcost + 1e-12 < best_goal_cost:\n                        if not self._edge_blocked(p.position, goal, obstacles, is_3d):\n                            best_goal_cost = gcost\n                            best_goal_parent = p\n                if best_goal_parent is not None:\n                    if goal_node is None:\n                        goal_node = Node(goal, best_goal_parent, best_goal_cost)\n                        best_goal_parent.children.append(goal_node)\n                        nodes.append(goal_node)\n                    else:\n                        goal_node.attach(best_goal_parent)\n                        goal_node.cost = best_goal_cost\n                    best_cost = best_goal_cost\n                    success = True\n                    found_first = True\n                    improved = True\n\n            # Online smoothing after improvement\n            if improved and goal_node is not None:\n                cur_path = self._extract_path(goal_node)\n                cur_path = self._compress_visibility(cur_path, obstacles, is_3d)\n                cur_path = self._shortcuts(cur_path, obstacles, is_3d, self.online_shortcuts_per_improve)\n                plen = self._path_length(cur_path)\n                if plen + 1e-12 < best_cost:\n                    best_cost = plen\n                best_path_pts = cur_path\n                post_iters = 0\n                no_improve = 0\n            else:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                    if post_iters >= self.post_opt_iters or no_improve >= self.no_improve_limit:\n                        break\n\n        # Build final path\n        path = []\n        if success and goal_node is not None:\n            if best_path_pts is None:\n                path = self._extract_path(goal_node)\n                path = self._compress_visibility(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n            else:\n                path = self._shortcuts(best_path_pts, obstacles, is_3d, self.smoothing_iters)\n\n        # Build edges\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---------- Utilities ----------\n    def _init_rng(self):\n        self._lcg_state = 2862933555777941757 % (1 << 32)\n\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / max(1e-12, d)\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Cached edge query\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._seg_key(a, b, self._seg_qres)\n        if k in self._edge_cache:\n            return self._edge_cache[k]\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, resolution=min(1.0, 0.5 * self.step_size))\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _seg_key(self, a, b, q):\n        ka = tuple(int(x // q) for x in a)\n        kb = tuple(int(x // q) for x in b)\n        return (ka, kb) if ka <= kb else (kb, ka)\n\n    # Spatial hashing\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _occ_inc(self, occ, key):\n        occ[key] = occ.get(key, 0) + 1\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        base = self._grid_key(center_pos, cell)\n        out = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (base[0] + dx, base[1] + dy)\n                    if k in grid:\n                        out.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (base[0] + dx, base[1] + dy, base[2] + dz)\n                        if k in grid:\n                            out.extend(grid[k])\n        return out\n\n    def _nearest(self, grid, nodes, pos, cell):\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        span = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > span:\n                span = self.bounds[i]\n        limit = span * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # fallback\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _k_nearest_limit(self, nodes, center, k):\n        if len(nodes) <= k:\n            return nodes\n        dist_idx = []\n        for n in nodes:\n            dist_idx.append((self._dist(n.position, center), n))\n        dist_idx.sort(key=lambda t: t[0])\n        return [t[1] for t in dist_idx[:k]]\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _heuristic(self, a, b):\n        return self._dist(a, b)\n\n    def _sample(self, start, goal, c_best):\n        # Informed ellipsoidal gate after first solution\n        if c_best < float('inf'):\n            for _ in range(self.ellipse_tries):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p):\n                    if self._dist(p, start) + self._dist(p, goal) <= c_best:\n                        return p\n        # Line-biased sample with jitter\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jit = 0.5 * self.step_size\n            return tuple(self._clip(base[i] + self._uniform(-jit, jit), 0.0, self.bounds[i]) for i in range(self.dim))\n        # Uniform\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    def _rrtstar_radius(self, n):\n        r = self.gamma_radius\n        if n > 2:\n            expo = 1.0 / float(max(2, self.dim))\n            r = self.gamma_radius * ((self._log_approx(n) / float(n)) ** expo)\n        rmin = max(self.min_radius_factor * self.step_size, 1e-6)\n        if r < rmin:\n            r = rmin\n        return r\n\n    def _propagate_costs_from(self, node):\n        # Update node and all descendants to maintain consistent costs\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                stack.append(c)\n\n    def _extract_path(self, goal_node):\n        seq = []\n        cur = goal_node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _compress_visibility(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._edge_blocked(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        no_gain = 0\n        for _ in range(iters):\n            if n < 3 or no_gain > max(8, iters // 10):\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                before = self._dist(pts[i], pts[i + 1]) + self._dist(pts[j - 1], pts[j])\n                after = self._dist(pts[i], pts[j])\n                if after + 1e-12 < before:\n                    pts = pts[:i + 1] + pts[j:]\n                    n = len(pts)\n                    no_gain = 0\n                else:\n                    no_gain += 1\n            else:\n                no_gain += 1\n        return pts",
        "objective": -11.31791,
        "time_improvement": -29.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1637.0,
        "node_improvement": 66.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.04869384765625,
                "num_nodes_avg": 142.0,
                "path_length_avg": 156.94171771174342,
                "smoothness_avg": 0.05000575517450624,
                "success_improvement": 0.0,
                "time_improvement": -90.96528555012308,
                "node_improvement": 64.24074540418032,
                "length_improvement": 13.977757621532207,
                "smoothness_improvement": 682.698657716415,
                "objective_score": -15.489437803535523
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.11519887447357177,
                "num_nodes_avg": 403.0,
                "path_length_avg": 229.3729522589852,
                "smoothness_avg": 0.11782822378241282,
                "success_improvement": 0.0,
                "time_improvement": 28.089391491172343,
                "node_improvement": 72.92212591547404,
                "length_improvement": 23.42870640158524,
                "smoothness_improvement": 2931.805066160672,
                "objective_score": 37.14306661910621
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.060450196266174316,
                "num_nodes_avg": 306.0,
                "path_length_avg": 118.47542861631464,
                "smoothness_avg": 0.10979481191774568,
                "success_improvement": 0.0,
                "time_improvement": -23.237863782732852,
                "node_improvement": 61.09345200254291,
                "length_improvement": 21.314261506704646,
                "smoothness_improvement": 1296.5819033837186,
                "objective_score": 12.300107286121523
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "IBiHRRT*-Connect: Informed Bidirectional Hash RRT* Connect with cycle-safe rewiring, bounded parent search, and early visibility pruning. It accelerates planning via deduplicated ring-hash nearest neighbors, LOS-bounded parent/rewire radii, exact edge-collision memoization, and a direct/greedy bridge. After the first solution it visibility-prunes and shortcuts for length and smoothness; optional informed sampling focuses subsequent expansions inside the prolate hyperspheroid for faster, shorter improvements.",
        "planning_mechanism": "Alternate growing start/goal trees. Sample goal/informed-biased points (post-solution uses an exact ellipsoid aligned to start\u2013goal). Find a near node via ring-hash; steer one step; choose the lowest-cost LOS parent within a radius; insert only if node and edge are collision-free and grid gate admits; locally rewire cheaper LOS neighbors with ancestor-guarded cost propagation. Attempt to connect the opposite tree directly or via a few greedy steps. On connection, extract the path by parents, visibility-prune, and run shortcut smoothing, then return.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=5.0,\n        goal_bias=0.18,\n        grid_cell_factor=2.0,\n        max_per_cell=7,\n        ring_max=3,\n        parent_radius_factor=2.2,\n        rewire_radius_factor=2.0,\n        connect_steps=4,\n        smoothing_iters=120,\n        post_solution_improve_iters=0\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.max_per_cell = max_per_cell\n        self.ring_max = ring_max\n        self.parent_radius_factor = parent_radius_factor\n        self.rewire_radius_factor = rewire_radius_factor\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n        self.post_solution_improve_iters = post_solution_improve_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self._lcg_state = 123456789\n        self._edge_cache = {}\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Derived params\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.edge_res = max(0.5, min(1.0, self.step_size * 0.5))\n        parent_radius = max(self.step_size * self.parent_radius_factor, self.step_size + 1e-6)\n        rewire_radius = max(self.step_size * self.rewire_radius_factor, self.step_size + 1e-6)\n        self._edge_cache = {}\n        self._lcg_state = 123456789\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            path = self._visibility_prune(path, obstacles, is_3d)\n            path = self._shortcut_smooth(path, obstacles, is_3d, min(60, self.smoothing_iters))\n            nodes = [Node(start), Node(goal)]\n            edges = [(nodes[0], nodes[1])]\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and hashed grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        nodes = [start_root, goal_root]\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        bestcost_start = {}\n        bestcost_goal = {}\n\n        self._grid_add(grid_start, counts_start, bestcost_start, start_root)\n        self._grid_add(grid_goal, counts_goal, bestcost_goal, goal_root)\n\n        # Informed sampling params\n        c_best = float('inf')\n        c_min = self._dist(start, goal)\n        have_solution = False\n        best_path_pts = []\n        best_end_nodes = (None, None)  # (a_last, b_last)\n\n        total_iters = self.max_iter\n\n        it = 0\n        while it < total_iters:\n            a_is_start = (it % 2 == 0)\n            tree_a = start_tree if a_is_start else goal_tree\n            tree_b = goal_tree if a_is_start else start_tree\n            grid_a = grid_start if a_is_start else grid_goal\n            grid_b = grid_goal if a_is_start else grid_start\n            counts_a = counts_start if a_is_start else counts_goal\n            bestcost_a = bestcost_start if a_is_start else bestcost_goal\n            attractor = goal if a_is_start else start\n\n            # Sample: informed ellipsoid if we have a solution, else mild goal bias\n            if have_solution:\n                x_rand = self._sample_informed(obstacles, is_3d, start, goal, c_best, c_min)\n            else:\n                x_rand = self._sample_biased(obstacles, is_3d, attractor)\n\n            # Nearest and steer\n            nearest = self._nearest_hashed(grid_a, tree_a, x_rand)\n            if nearest is None:\n                it += 1\n                continue\n            new_pos = self._steer(nearest.position, x_rand)\n            if (not self._in_bounds(new_pos)) or self._is_in_obstacle(new_pos, obstacles, is_3d):\n                it += 1\n                continue\n            if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                it += 1\n                continue\n            if self._near_duplicate(grid_a, new_pos, self.step_size * 0.6):\n                it += 1\n                continue\n\n            # Choose parent among local LOS neighbors within bounded radius\n            parent = self._choose_parent_local(grid_a, new_pos, nearest, obstacles, is_3d, parent_radius)\n            if self._edge_blocked(parent.position, new_pos, obstacles, is_3d):\n                it += 1\n                continue\n\n            new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n            # Grid admission gate\n            key_new = self._grid_key(new_pos)\n            ccount = counts_a.get(key_new, 0)\n            bestc = bestcost_a.get(key_new, float('inf'))\n            # Allow insertion if cell not full or cost improves best seen in cell\n            if ccount >= self.max_per_cell and not (new_cost + 1e-9 < bestc):\n                it += 1\n                continue\n\n            # Insert node\n            a_new = Node(new_pos, parent=parent, cost=new_cost)\n            parent.add_child(a_new)\n            tree_a.append(a_new)\n            nodes.append(a_new)\n            self._grid_add(grid_a, counts_a, bestcost_a, a_new)\n\n            # Local rewiring with ancestor guard\n            self._rewire_local(grid_a, a_new, obstacles, is_3d, rewire_radius)\n\n            # Try to bridge to other tree: direct or greedy connect\n            bridged = False\n            b_near = self._nearest_hashed(grid_b, tree_b, a_new.position)\n            if b_near is not None:\n                # Direct short bridge if feasible\n                if self._dist(b_near.position, a_new.position) <= self.step_size and not self._edge_blocked(b_near.position, a_new.position, obstacles, is_3d):\n                    # Choose better parent side for final short edge by cost\n                    # No need to alter tree structure; path extraction uses parents and the loose bridge\n                    path = self._extract_path_with_bridge(a_new, b_near, a_is_start)\n                    path = self._visibility_prune(path, obstacles, is_3d)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    plen = self._path_length(path)\n                    if plen + 1e-9 < c_best:\n                        c_best = plen\n                        have_solution = True\n                        best_path_pts = path\n                        best_end_nodes = (a_new, b_near) if a_is_start else (b_near, a_new)\n                        if self.post_solution_improve_iters <= 0:\n                            edges = self._collect_edges(nodes)\n                            return PlannerResult(True, best_path_pts, nodes, edges)\n                        total_iters = it + self.post_solution_improve_iters\n                    bridged = True\n\n            # Greedy connect steps from other tree toward a_new\n            if not bridged:\n                current_target = a_new.position\n                for _ in range(self.connect_steps):\n                    b_near = self._nearest_hashed(grid_b, tree_b, current_target)\n                    if b_near is None:\n                        break\n                    step_to = self._steer(b_near.position, current_target)\n                    if (not self._in_bounds(step_to)) or self._is_in_obstacle(step_to, obstacles, is_3d):\n                        break\n                    if self._edge_blocked(b_near.position, step_to, obstacles, is_3d):\n                        break\n                    # Select parent in other tree for the step\n                    b_parent = self._choose_parent_local(grid_b, step_to, b_near, obstacles, is_3d, parent_radius)\n                    if self._edge_blocked(b_parent.position, step_to, obstacles, is_3d):\n                        break\n                    b_new = Node(step_to, parent=b_parent, cost=b_parent.cost + self._dist(b_parent.position, step_to))\n                    b_parent.add_child(b_new)\n                    tree_b.append(b_new)\n                    nodes.append(b_new)\n                    self._grid_add(grid_b, counts_goal if a_is_start else counts_start, bestcost_goal if a_is_start else bestcost_start, b_new)\n                    self._rewire_local(grid_b, b_new, obstacles, is_3d, rewire_radius)\n\n                    # Final short bridge\n                    if self._dist(b_new.position, a_new.position) <= self.step_size and not self._edge_blocked(b_new.position, a_new.position, obstacles, is_3d):\n                        path = self._extract_path_with_bridge(a_new, b_new, a_is_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        plen = self._path_length(path)\n                        if plen + 1e-9 < c_best:\n                            c_best = plen\n                            have_solution = True\n                            best_path_pts = path\n                            best_end_nodes = (a_new, b_new) if a_is_start else (b_new, a_new)\n                            if self.post_solution_improve_iters <= 0:\n                                edges = self._collect_edges(nodes)\n                                return PlannerResult(True, best_path_pts, nodes, edges)\n                            total_iters = it + self.post_solution_improve_iters\n                        break\n\n            it += 1\n\n        # Finalize\n        if have_solution:\n            edges = self._collect_edges(nodes)\n            return PlannerResult(True, best_path_pts, nodes, edges)\n        edges = self._collect_edges(nodes)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-9:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision and caching\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        hit = self._edge_cache.get(k)\n        if hit is not None:\n            return hit\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Sampling\n    def _sample_biased(self, obstacles, is_3d, attractor):\n        if self._rand() < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        alpha = 0.25\n        if self.dim == 3:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]),\n                   self._uniform(0.0, self.bounds[2]))\n            p = (alpha * attractor[0] + (1.0 - alpha) * rnd[0],\n                 alpha * attractor[1] + (1.0 - alpha) * rnd[1],\n                 alpha * attractor[2] + (1.0 - alpha) * rnd[2])\n        else:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]))\n            p = (alpha * attractor[0] + (1.0 - alpha) * rnd[0],\n                 alpha * attractor[1] + (1.0 - alpha) * rnd[1])\n        if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        # Fallback uniform free sample\n        while True:\n            if self.dim == 3:\n                q = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                q = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(q) and not self._is_in_obstacle(q, obstacles, is_3d):\n                return q\n\n    def _sample_informed(self, obstacles, is_3d, start, goal, c_best, c_min):\n        # If no improvement possible, fallback\n        if not (c_best < float('inf')) or c_best <= c_min + 1e-9:\n            return self._sample_biased(obstacles, is_3d, goal)\n        # Center and unit major axis a_hat\n        center = tuple((start[i] + goal[i]) * 0.5 for i in range(self.dim))\n        a_vec = tuple(goal[i] - start[i] for i in range(self.dim))\n        a_norm = self._norm(a_vec)\n        if a_norm <= 1e-12:\n            return self._sample_biased(obstacles, is_3d, goal)\n        a_hat = tuple(a_vec[i] / a_norm for i in range(self.dim))\n        # Semi-axes\n        r1 = c_best * 0.5\n        if c_best <= c_min:\n            r2 = 0.0\n        else:\n            r2 = (c_best * c_best - c_min * c_min) ** 0.5 * 0.5\n        # Generate a uniform unit n-ball sample\n        for _ in range(50):\n            if self.dim == 3:\n                x = self._uniform(-1.0, 1.0)\n                y = self._uniform(-1.0, 1.0)\n                z = self._uniform(-1.0, 1.0)\n                r2sq = x * x + y * y + z * z\n                if r2sq > 1.0 or r2sq <= 1e-12:\n                    continue\n                # Scale to ellipsoid axes\n                # Build orthonormal basis [a_hat, v, w]\n                u = (1.0, 0.0, 0.0)\n                if abs(a_hat[0]) > 0.9:\n                    u = (0.0, 1.0, 0.0)\n                v = self._normalize(self._cross(a_hat, u))\n                if self._norm(v) <= 1e-12:\n                    v = (0.0, 0.0, 1.0)\n                w = self._cross(a_hat, v)\n                # Compose point\n                # Map unit ball sample to ellipsoid using radii [r1, r2, r2]\n                # First, a random direction on unit ball is (x,y,z) with |.|<=1; keep distribution via cube sampling\n                # Use as coordinates in basis\n                px = r1 * x\n                py = r2 * y\n                pz = r2 * z\n                ex = center[0] + px * a_hat[0] + py * v[0] + pz * w[0]\n                ey = center[1] + px * a_hat[1] + py * v[1] + pz * w[1]\n                ez = center[2] + px * a_hat[2] + py * v[2] + pz * w[2]\n                p = (ex, ey, ez)\n            else:\n                x = self._uniform(-1.0, 1.0)\n                y = self._uniform(-1.0, 1.0)\n                if x * x + y * y > 1.0:\n                    continue\n                # 2D orthonormal basis: a_hat and its perpendicular\n                perp = (-a_hat[1], a_hat[0])\n                px = r1 * x\n                py = r2 * y\n                ex = center[0] + px * a_hat[0] + py * perp[0]\n                ey = center[1] + px * a_hat[1] + py * perp[1]\n                p = (ex, ey)\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Fallback\n        return self._sample_biased(obstacles, is_3d, goal)\n\n    def _norm(self, v):\n        s = 0.0\n        for i in range(len(v)):\n            s += v[i] * v[i]\n        return s ** 0.5\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n <= 1e-12:\n            if len(v) == 3:\n                return (1.0, 0.0, 0.0)\n            return (1.0, 0.0)\n        return tuple(v[i] / n for i in range(len(v)))\n\n    def _cross(self, a, b):\n        return (a[1] * b[2] - a[2] * b[1],\n                a[2] * b[0] - a[0] * b[2],\n                a[0] * b[1] - a[1] * b[0])\n\n    # Grid / NN\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n        bc = bestcost.get(k)\n        if bc is None or node.cost < bc:\n            bestcost[k] = node.cost\n\n    def _ring_cells(self, key, r):\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        yield (key[0] + dx, key[1] + dy, key[2] + dz)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    yield (key[0] + dx, key[1] + dy)\n\n    def _grid_ring_collect_unique(self, grid, key, r):\n        cand = []\n        seen = set()\n        for cell in self._ring_cells(key, r):\n            bucket = grid.get(cell)\n            if bucket:\n                for n in bucket:\n                    nid = id(n)\n                    if nid not in seen:\n                        seen.add(nid)\n                        cand.append(n)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.ring_max + 1):\n            cand = self._grid_ring_collect_unique(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback random subset if grid sparse\n        if not tree:\n            return None\n        tries = min(64, len(tree))\n        for _ in range(tries):\n            idx = int(self._uniform(0, len(tree)))\n            n = tree[idx]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        cand = self._grid_ring_collect_unique(grid, key, 1)\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                return True\n        return False\n\n    # Parent selection among LOS neighbors with bounded radius\n    def _choose_parent_local(self, grid, new_pos, fallback_nearest, obstacles, is_3d, radius_bound):\n        key = self._grid_key(new_pos)\n        best_parent = fallback_nearest\n        best_cost = fallback_nearest.cost + self._dist(fallback_nearest.position, new_pos)\n        max_r = max(1, self.ring_max)\n        for r in range(0, max_r + 1):\n            cand = self._grid_ring_collect_unique(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                if n is fallback_nearest or n is best_parent:\n                    continue\n                dnp = self._dist(n.position, new_pos)\n                if dnp > radius_bound:\n                    continue\n                if self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                    continue\n                c = n.cost + dnp\n                if c + 1e-12 < best_cost:\n                    best_cost = c\n                    best_parent = n\n        return best_parent\n\n    # Local rewiring with ancestor guard\n    def _rewire_local(self, grid, pivot, obstacles, is_3d, radius):\n        key = self._grid_key(pivot.position)\n        for r in range(0, max(1, self.ring_max) + 1):\n            cand = self._grid_ring_collect_unique(grid, key, r)\n            if not cand:\n                continue\n            for nb in cand:\n                if nb is pivot or nb.parent is pivot:\n                    continue\n                if self._dist(nb.position, pivot.position) > radius:\n                    continue\n                if self._is_ancestor(nb, pivot):\n                    continue\n                if self._edge_blocked(pivot.position, nb.position, obstacles, is_3d):\n                    continue\n                new_cost = pivot.cost + self._dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    old_parent = nb.parent\n                    if old_parent is not None:\n                        try:\n                            old_parent.children.remove(nb)\n                        except Exception:\n                            pass\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    self._propagate_cost_from(nb)\n\n    def _is_ancestor(self, node, potential_child):\n        cur = potential_child\n        while cur is not None:\n            if cur is node:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_cost_from(self, node):\n        queue = [node]\n        qi = 0\n        while qi < len(queue):\n            cur = queue[qi]\n            qi += 1\n            for ch in cur.children:\n                new_c = cur.cost + self._dist(cur.position, ch.position)\n                if abs(new_c - ch.cost) > 1e-12:\n                    ch.cost = new_c\n                    queue.append(ch)\n\n    # Path utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path_with_bridge(self, a_node, b_node, a_is_start_tree):\n        path_a = self._path_to_root(a_node)\n        path_b = self._path_to_root(b_node)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        # Deterministic forward pass then random refinements\n        changed = True\n        passes = 0\n        while changed and passes < 3:\n            changed = False\n            i = 0\n            while i < len(pts) - 2:\n                a = pts[i]\n                k = len(pts) - 1\n                improved = False\n                while k > i + 1:\n                    b = pts[k]\n                    if not self._edge_blocked(a, b, obstacles, is_3d):\n                        mid_len = 0.0\n                        for t in range(i + 1, k + 1):\n                            mid_len += self._dist(pts[t - 1], pts[t])\n                        if self._dist(a, b) + 1e-9 < mid_len:\n                            pts = pts[:i + 1] + pts[k:]\n                            changed = True\n                            improved = True\n                            break\n                    k -= 1\n                if not improved:\n                    i += 1\n            passes += 1\n        # Random pair shortcuts\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts\n\n    def _collect_edges(self, nodes):\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return edges",
        "objective": -29.84512,
        "time_improvement": 32.0,
        "length_improvement": 21.0,
        "smoothness_improvement": 1485.0,
        "node_improvement": 87.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01609337329864502,
                "num_nodes_avg": 47.0,
                "path_length_avg": 148.48852810021452,
                "smoothness_avg": 0.041946328850586606,
                "success_improvement": 0.0,
                "time_improvement": 34.76882726816771,
                "node_improvement": 88.16419038025687,
                "length_improvement": 18.611084796972406,
                "smoothness_improvement": 556.551134422692,
                "objective_score": 24.38005473074722
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.15710897445678712,
                "num_nodes_avg": 225.0,
                "path_length_avg": 230.98780524572462,
                "smoothness_avg": 0.11927323645742623,
                "success_improvement": 0.0,
                "time_improvement": 6.0642847367940815,
                "node_improvement": 84.88208022576093,
                "length_improvement": 22.889621993645612,
                "smoothness_improvement": 2968.9862830893276,
                "objective_score": 30.397990032672226
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.022504901885986327,
                "num_nodes_avg": 105.0,
                "path_length_avg": 116.73701153822624,
                "smoothness_avg": 0.08099784362284458,
                "success_improvement": 0.0,
                "time_improvement": 55.41528292555973,
                "node_improvement": 86.6497139224412,
                "length_improvement": 22.46883535544535,
                "smoothness_improvement": 930.2865922436716,
                "objective_score": 34.75731905215349
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "SIBiRRT-Connect-Lite: A streamlined balanced informed BiRRT-Connect with light neighbor parent selection, grid-accelerated proximity/collision, and two-phase shortcut refinement for faster search, shorter paths, and improved smoothness.",
        "planning_mechanism": "Per iteration, expand the smaller tree: sample from a mixed distribution (uniform/corridor/goal; ellipse after a first solution), steer one bounded step, validate node and edge, pick the cheapest feasible parent among the nearest few neighbors, insert, then greedily connect the opposite tree toward it until blocked. On connection, extract and shortcut the path and return.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=6.0,\n        goal_bias=0.25,\n        corridor_bias=0.35,\n        grid_cell_factor=1.0,\n        min_sep_ratio=0.3,\n        neighbor_radius_factor=2.0,\n        neighbor_cap=6,\n        connect_steps=32,\n        shortcut_attempts=80\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.min_sep_ratio = min_sep_ratio\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.neighbor_cap = neighbor_cap\n        self.connect_steps = connect_steps\n        self.shortcut_attempts = shortcut_attempts\n        self._rnd_state = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_ratio)\n        self.neighbor_radius = max(self.step_size * 1.2, self.step_size * self.neighbor_radius_factor)\n\n        self._seed_from_scene()\n\n        nodes = []\n        edges = []\n\n        if (not self._within_bounds(self.start)) or (not self._within_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._build_obstacle_grid()\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        incumbent_len = None\n\n        for _ in range(self.max_iter):\n            if len(tree_a) <= len(tree_b):\n                active_tree, active_grid = tree_a, grid_a\n                passive_tree, passive_grid = tree_b, grid_b\n                attractor = self.goal\n            else:\n                active_tree, active_grid = tree_b, grid_b\n                passive_tree, passive_grid = tree_a, grid_a\n                attractor = self.start\n\n            s = self._sample(attractor, incumbent_len)\n            if s is None:\n                continue\n\n            nearest = self._nearest_in_grid(active_grid, s)\n            if nearest is None:\n                continue\n\n            new_pos = self._steer(nearest.position, s, self.step_size)\n            if not self._within_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._has_nearby(active_grid, new_pos, self.min_sep):\n                continue\n\n            parent, new_cost = self._choose_parent_light(active_grid, nearest, new_pos)\n            if parent is None:\n                continue\n\n            if self._point_in_obstacles(new_pos):\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(active_grid, new_node)\n\n            meet = self._connect_toward(passive_tree, passive_grid, new_node.position, nodes, edges)\n            if meet is not None and self._edge_free(meet.position, new_node.position):\n                path = self._extract_path(new_node, meet)\n                incumbent_len = self._path_len(path)\n                path = self._shortcut(path)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0x7fffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0x7fffffff\n        self._rnd_state = (s ^ 0x9E3779B9) & 0x7fffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 123456789\n\n    def _rand(self):\n        self._rnd_state = (1103515245 * self._rnd_state + 12345) & 0x7fffffff\n        return self._rnd_state / 2147483647.0\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            q = []\n            for i in range(self.dims):\n                q.append(self._clamp_val(b[i], 0.0, self.bounds[i]))\n            return tuple(q)\n        d = d2 ** 0.5\n        r = step / d\n        q = []\n        for i in range(self.dims):\n            v = a[i] + (b[i] - a[i]) * r\n            q.append(self._clamp_val(v, 0.0, self.bounds[i]))\n        return tuple(q)\n\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_in_grid(self, grid, pos, max_ring=4):\n        key = self._cell_of(pos)\n        best = None\n        bestd2 = 1e100\n        for r in range(0, max_ring + 1):\n            cand = self._ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            if best is not None:\n                return best\n        buckets = list(grid.values())\n        if not buckets:\n            return None\n        trials = 0\n        while trials < 24:\n            b = buckets[int(self._rand() * len(buckets)) % max(1, len(buckets))]\n            if b:\n                n = b[int(self._rand() * len(b)) % max(1, len(b))]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            trials += 1\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        rc = int(radius // self.cell_size) + 1\n        r2 = radius * radius\n        for n in self._ring_collect(grid, key, rc):\n            if self._dist2(n.position, pos) <= r2:\n                return True\n        return False\n\n    def _nearby_nodes(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        rc = int(radius // self.cell_size) + 1\n        r2 = radius * radius\n        out = []\n        for n in self._ring_collect(grid, key, rc):\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy, cz))\n            if not b:\n                return False\n            px, py, pz = p\n            for idx in b:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy))\n            if not b:\n                return False\n            px, py = p\n            for idx in b:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _choose_parent_light(self, grid, nearest, new_pos):\n        neigh = self._nearby_nodes(grid, new_pos, self.neighbor_radius)\n        if nearest not in neigh:\n            neigh.append(nearest)\n        neigh.sort(key=lambda n: self._dist2(n.position, new_pos))\n        cand = neigh[:max(1, self.neighbor_cap)]\n        best_parent = None\n        best_cost = 1e100\n        for n in cand:\n            if not self._edge_free(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-9 < best_cost:\n                best_cost = c\n                best_parent = n\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        near = self._nearest_in_grid(grid, target_pos)\n        if near is None:\n            return None\n        cur = near\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(cur.position, target_pos, self.step_size)\n            if self._dist2(cur.position, nxt) < (self.min_sep * self.min_sep * 0.25):\n                break\n            if not self._within_bounds(nxt):\n                break\n            if self._point_in_obstacles(nxt):\n                break\n            if self._has_nearby(grid, nxt, self.min_sep):\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            q = Node(nxt, cur, new_cost)\n            cur.add_child(q)\n            tree.append(q)\n            nodes.append(q)\n            edges.append((cur, q))\n            self._grid_insert(grid, q)\n            cur = q\n            steps += 1\n            if self._dist2(cur.position, target_pos) <= (self.step_size * self.step_size) and self._edge_free(cur.position, target_pos):\n                return cur\n        return None\n\n    def _sample(self, attractor, incumbent_len):\n        for _ in range(20):\n            r = self._rand()\n            if incumbent_len is not None and r < 0.55:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_sample()\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if p is not None and self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        if self._within_bounds(attractor) and not self._point_in_obstacles(attractor):\n            return attractor\n        return None\n\n    def _corridor_sample(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        dsg = self._dist(self.start, self.goal)\n        width = max(self.step_size, 0.08 * dsg)\n        if self.is_3d:\n            return (\n                self._clamp_val(base[0] + self._rand_range(-width, width), 0.0, self.bounds[0]),\n                self._clamp_val(base[1] + self._rand_range(-width, width), 0.0, self.bounds[1]),\n                self._clamp_val(base[2] + self._rand_range(-width, width), 0.0, self.bounds[2]),\n            )\n        else:\n            return (\n                self._clamp_val(base[0] + self._rand_range(-width, width), 0.0, self.bounds[0]),\n                self._clamp_val(base[1] + self._rand_range(-width, width), 0.0, self.bounds[1]),\n            )\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        ext = [max(self.step_size, half)] * self.dims\n        for _ in range(18):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum_dist and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        pb.reverse()\n        if pa and pb and pa[-1] == pb[0]:\n            pb = pb[1:]\n        return pa + pb\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        i = 0\n        while i < len(pts) - 2:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n        attempts = 0\n        while attempts < self.shortcut_attempts and len(pts) > 2:\n            i = int(self._rand_range(0, len(pts) - 2))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                attempts += 1\n                continue\n            if self._edge_free(pts[i], pts[j]):\n                pts = pts[:i + 1] + pts[j:]\n            attempts += 1\n        return pts",
        "objective": -37.09124,
        "time_improvement": 61.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1377.0,
        "node_improvement": 87.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.011144709587097169,
                "num_nodes_avg": 49.0,
                "path_length_avg": 150.61019244127573,
                "smoothness_avg": 0.04827733550563596,
                "success_improvement": 0.0,
                "time_improvement": 54.82721598316178,
                "node_improvement": 87.6605389070763,
                "length_improvement": 17.448166951713837,
                "smoothness_improvement": 655.6451365752101,
                "objective_score": 30.195290648852886
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04703662395477295,
                "num_nodes_avg": 160.0,
                "path_length_avg": 222.69131300634007,
                "smoothness_avg": 0.08728289130799861,
                "success_improvement": 0.0,
                "time_improvement": 71.87672486543198,
                "node_improvement": 89.24947927165222,
                "length_improvement": 25.65922990444059,
                "smoothness_improvement": 2145.851660680297,
                "objective_score": 47.68781370569543
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.02253601551055908,
                "num_nodes_avg": 116.0,
                "path_length_avg": 125.1119046359757,
                "smoothness_avg": 0.11227318427452833,
                "success_improvement": 0.0,
                "time_improvement": 55.35364337006359,
                "node_improvement": 85.2511125238398,
                "length_improvement": 16.906630129474358,
                "smoothness_improvement": 1328.1066168275754,
                "objective_score": 33.39060417284157
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "FIBER-Connect*: Fast Informed Bidirectional RRT*-Connect with Cached Collisions and Local Rewiring \u2014 a bidirectional planner that blends informed sampling, grid-accelerated near/nearest, per-cell cost gating, limited RRT* rewiring, and multi-step connect-extend bridging; it maintains an edge-collision cache and applies visibility pruning plus shortcuts for short, smooth paths with low planning time.",
        "planning_mechanism": "Alternate expanding the two trees; sample with goal/line bias and informed-ellipsoid once a path exists; find nearest via grid rings, steer, and validate; select the lowest-cost parent among radius neighbors (LOS) and insert under per-cell cost gates; locally rewire a few neighbors to reduce path cost; then attempt multi-step connect from the opposite tree toward the new node and bridge on first free LOS; upon success, extract start\u2192meetA + meetB\u2192goal, visibility-prune and shortcut, and return.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.22,\n                 line_bias=0.30,\n                 informed_tries=80,\n                 grid_cell_factor=1.5,\n                 max_per_cell=6,\n                 duplicate_radius_factor=0.5,\n                 rewire_k=10,\n                 rewire_depth=5,\n                 neighbor_radius_factor=3.0,\n                 connect_steps=6,\n                 smoothing_iters=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.informed_tries = informed_tries\n        self.grid_cell_factor = grid_cell_factor\n        self.max_per_cell = max_per_cell\n        self.duplicate_radius_factor = duplicate_radius_factor\n        self.rewire_k = rewire_k\n        self.rewire_depth = rewire_depth\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        self.edge_res = max(0.5, min(1.0, 0.5 * self.step_size))\n        self.cell_size = max(1.0, self.grid_cell_factor * self.step_size)\n        self.min_sep = max(0.3, self.duplicate_radius_factor * self.step_size)\n\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            return PlannerResult(True, [start, goal], [s, g], [(s, g)])\n\n        s_root = Node(start, None, 0.0)\n        g_root = Node(goal, None, 0.0)\n\n        start_tree = [s_root]\n        goal_tree = [g_root]\n        nodes = [s_root, g_root]\n        edges = []\n\n        grid_s = {}\n        grid_g = {}\n        counts_s = {}\n        counts_g = {}\n        bestcost_s = {}\n        bestcost_g = {}\n\n        self._grid_add(grid_s, counts_s, bestcost_s, s_root)\n        self._grid_add(grid_g, counts_g, bestcost_g, g_root)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_s if active_start else grid_g\n            grid_b = grid_g if active_start else grid_s\n            counts_a = counts_s if active_start else counts_g\n            counts_b = counts_g if active_start else counts_s\n            bestcost_a = bestcost_s if active_start else bestcost_g\n            bestcost_b = bestcost_g if active_start else bestcost_s\n            root_other = goal if active_start else start\n\n            x_rand = self._sample(obstacles, is_3d, start, goal, best_len, root_other)\n\n            n_near = self._nearest(grid_a, tree_a, x_rand)\n            x_new = self._steer(n_near.position, x_rand)\n            if not self._in_bounds(x_new):\n                continue\n            if self._is_in_obstacle(x_new, obstacles, is_3d):\n                continue\n            if self._edge_blocked(n_near.position, x_new, obstacles, is_3d):\n                continue\n            if self._near_duplicate(grid_a, x_new, self.min_sep):\n                continue\n\n            r_near = max(self.neighbor_radius_factor * self.step_size, self.step_size)\n            neigh = self._near(grid_a, x_new, r_near)\n            parent, new_cost = self._choose_parent(neigh, n_near, x_new, obstacles, is_3d)\n\n            key_new = self._grid_key(x_new)\n            ccount = counts_a.get(key_new, 0)\n            bestc = bestcost_a.get(key_new, float('inf'))\n            if ccount >= self.max_per_cell and not (new_cost + 1e-12 < bestc):\n                continue\n\n            new_node = Node(x_new, None, new_cost)\n            new_node.attach(parent)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid_a, counts_a, bestcost_a, new_node)\n\n            if neigh:\n                self._rewire(new_node, neigh, obstacles, is_3d, edges)\n\n            meet_b, bridged = self._connect_toward(tree_b, grid_b, counts_b, bestcost_b, new_node.position, obstacles, is_3d)\n            if meet_b is None:\n                meet_candidate = self._nearest(grid_b, tree_b, new_node.position)\n                if meet_candidate is not None and not self._edge_blocked(new_node.position, meet_candidate.position, obstacles, is_3d):\n                    meet_b = meet_candidate\n                    bridged = True\n\n            if bridged and meet_b is not None:\n                if active_start:\n                    a = new_node\n                    b = meet_b\n                else:\n                    a = meet_b\n                    b = new_node\n                if not self._edge_blocked(a.position, b.position, obstacles, is_3d):\n                    edges.append((a, b))\n                    path = self._extract_path(a, b)\n                    path = self._visibility_prune(path, obstacles, is_3d)\n                    path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _uniform_point(self):\n        if self.dim == 3:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]),\n                    self._uniform(0.0, self.bounds[2]))\n        else:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]))\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-12:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        if k in self._edge_cache:\n            return self._edge_cache[k]\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._grid_key(node.position)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n        counts[k] = counts.get(k, 0) + 1\n        prev = bestcost.get(k, None)\n        if prev is None or node.cost < prev:\n            bestcost[k] = node.cost\n\n    def _grid_collect_ring(self, grid, key, r):\n        cand = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        return cand\n\n    def _nearest(self, grid, nodes, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        cand_total = []\n        r = 0\n        max_r = 4\n        while r <= max_r and len(cand_total) < 12:\n            cand_total.extend(self._grid_collect_ring(grid, key, r))\n            r += 1\n        if cand_total:\n            for n in cand_total:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            return best\n        if nodes:\n            trials = min(64, len(nodes))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(nodes)))\n                n = nodes[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _near(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        rng = int(max(1, radius // self.cell_size)) + 1\n        cand = []\n        if self.dim == 3:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        cand = self._grid_collect_ring(grid, key, 1)\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                return True\n        return False\n\n    def _choose_parent(self, neighbors, fallback_near, new_pos, obstacles, is_3d):\n        best_parent = fallback_near\n        best_cost = fallback_near.cost + self._dist(fallback_near.position, new_pos)\n        for n in neighbors:\n            if n is fallback_near:\n                continue\n            if not self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                c = n.cost + self._dist(n.position, new_pos)\n                if c + 1e-12 < best_cost:\n                    best_cost = c\n                    best_parent = n\n        return best_parent, best_cost\n\n    def _can_rewire(self, node, new_parent):\n        cur = new_parent\n        while cur is not None:\n            if cur is node:\n                return False\n            cur = cur.parent\n        return True\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                edges.pop(i)\n                break\n\n    def _propagate_cost(self, node, edges, depth):\n        if depth <= 0:\n            return\n        for ch in node.children:\n            old = ch.cost\n            ch.cost = node.cost + self._dist(node.position, ch.position)\n            if abs(ch.cost - old) > 1e-12:\n                self._propagate_cost(ch, edges, depth - 1)\n\n    def _rewire(self, new_node, neighbors, obstacles, is_3d, edges):\n        if not neighbors:\n            return\n        cand = []\n        for n in neighbors:\n            if n is new_node or n is new_node.parent:\n                continue\n            cand.append((self._dist(n.position, new_node.position), n))\n        cand.sort(key=lambda t: t[0])\n        limit = min(self.rewire_k, len(cand))\n        for i in range(limit):\n            n = cand[i][1]\n            if not self._can_rewire(n, new_node):\n                continue\n            if self._edge_blocked(new_node.position, n.position, obstacles, is_3d):\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, n.position)\n            if new_cost + 1e-12 < n.cost:\n                old_parent = n.parent\n                n.attach(new_node)\n                n.cost = new_cost\n                if old_parent is not None:\n                    self._remove_edge(edges, old_parent, n)\n                edges.append((new_node, n))\n                self._propagate_cost(n, edges, self.rewire_depth)\n\n    def _extend_toward(self, tree, grid, counts, bestcost, target_pos, obstacles, is_3d):\n        current = self._nearest(grid, tree, target_pos)\n        last = current\n        for _ in range(self.connect_steps):\n            nxt = self._steer(current.position, target_pos)\n            if not self._in_bounds(nxt):\n                break\n            if self._is_in_obstacle(nxt, obstacles, is_3d):\n                break\n            if self._edge_blocked(current.position, nxt, obstacles, is_3d):\n                break\n            if self._near_duplicate(grid, nxt, self.min_sep):\n                break\n            r_near = max(self.neighbor_radius_factor * self.step_size, self.step_size)\n            neigh = self._near(grid, nxt, r_near)\n            parent, new_cost = self._choose_parent(neigh, current, nxt, obstacles, is_3d)\n            key_new = self._grid_key(nxt)\n            ccount = counts.get(key_new, 0)\n            bestc = bestcost.get(key_new, float('inf'))\n            if ccount >= self.max_per_cell and not (new_cost + 1e-12 < bestc):\n                break\n            newn = Node(nxt, None, new_cost)\n            newn.attach(parent)\n            tree.append(newn)\n            self._grid_add(grid, counts, bestcost, newn)\n            last = newn\n            current = newn\n            if self._dist(nxt, target_pos) <= self.step_size:\n                break\n        return last\n\n    def _connect_toward(self, tree_b, grid_b, counts_b, bestcost_b, a_pos, obstacles, is_3d):\n        last = self._extend_toward(tree_b, grid_b, counts_b, bestcost_b, a_pos, obstacles, is_3d)\n        if last is None:\n            return None, False\n        if not self._edge_blocked(last.position, a_pos, obstacles, is_3d):\n            return last, True\n        return last, False\n\n    def _path_to_root(self, node):\n        seq = []\n        cur = node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _extract_path(self, meet_a, meet_b):\n        pa = self._path_to_root(meet_a)\n        pb = []\n        cur = meet_b\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        return pa + pb\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        n = len(path)\n        i = 0\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts\n\n    def _sample(self, obstacles, is_3d, start, goal, best_len, attractor):\n        r = self._rand()\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        if best_len < float('inf'):\n            for _ in range(self.informed_tries):\n                p = self._uniform_point()\n                if self._dist(p, start) + self._dist(p, goal) <= best_len and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jit = 0.5 * self.step_size\n            if self.dim == 3:\n                p = (self._clamp((base[0] + self._uniform(-jit, jit), base[1] + self._uniform(-jit, jit), base[2] + self._uniform(-jit, jit))))\n            else:\n                p = (min(max(base[0] + self._uniform(-jit, jit), 0.0), self.bounds[0]),\n                     min(max(base[1] + self._uniform(-jit, jit), 0.0), self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        while True:\n            p = self._uniform_point()\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p",
        "objective": -35.01262,
        "time_improvement": 55.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1329.0,
        "node_improvement": 90.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.016425013542175293,
                "num_nodes_avg": 47.0,
                "path_length_avg": 154.62508050902176,
                "smoothness_avg": 0.04071980109549708,
                "success_improvement": 0.0,
                "time_improvement": 33.4245918733191,
                "node_improvement": 88.16419038025687,
                "length_improvement": 15.247543181809576,
                "smoothness_improvement": 537.3533116078908,
                "objective_score": 21.86267002912093
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04094517230987549,
                "num_nodes_avg": 124.0,
                "path_length_avg": 229.46535757937585,
                "smoothness_avg": 0.08684323820145955,
                "success_improvement": 0.0,
                "time_improvement": 75.51881386278623,
                "node_improvement": 91.66834643553047,
                "length_improvement": 23.397858845899172,
                "smoothness_improvement": 2134.539069579714,
                "objective_score": 47.36705481427394
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.022255563735961915,
                "num_nodes_avg": 88.0,
                "path_length_avg": 119.3089523489693,
                "smoothness_avg": 0.11130492356865981,
                "success_improvement": 0.0,
                "time_improvement": 55.909249570294364,
                "node_improvement": 88.81118881118881,
                "length_improvement": 20.760674731610354,
                "smoothness_improvement": 1315.790412118499,
                "objective_score": 35.80813177064702
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "XR-IBiRRT*: eXtended Rewiring Informed Bi-directional RRT with neighbor-based optimal parent selection, soft-cap hashed nearest, adaptive bounded-extend bridging, LRU-quantized edge cache, and post-solution informed refinement. It reduces time via obstacle-grid-accelerated slab checks and cache reuse, improves length via local RRT*-lite rewiring and LOS ancestor compression, and increases smoothness by visibility pruning and shortcutting while avoiding early return.",
        "planning_mechanism": "Mechanism: Alternate tree growth. For each informed/corridor/uniform sample, steer once, verify node and edge, then choose the cheapest collision-free parent among k-near grid neighbors plus a short ancestor lookback; insert and rewire cheaper neighbors. Immediately attempt to connect to the opposite tree by direct check or short bounded extensions. Maintain best path and continue a short informed phase for refinement. All node/edge insertions pass both point and segment collision checks using an obstacle spatial grid and LRU-quantized edge-cache. Final path is visibility-pruned and shortcut-smoothed.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=8.0,\n                 goal_bias=0.25,\n                 informed_bias=0.5,\n                 corridor_bias=0.35,\n                 lookback_depth=4,\n                 rewire_radius_factor=3.0,\n                 k_near_max=24,\n                 dupe_radius_factor=0.6,\n                 grid_cell_factor=1.4,\n                 bucket_soft_cap=10,\n                 connect_radius_factor=5.0,\n                 connect_trials=4,\n                 shortcut_attempts=80,\n                 stall_after=500,\n                 edge_cache_capacity=40000,\n                 edge_cache_quant=0.5):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.lookback_depth = int(max(0, lookback_depth))\n        self.rewire_radius_factor = float(max(1.0, rewire_radius_factor))\n        self.k_near_max = int(max(4, k_near_max))\n        self.dupe_radius_factor = float(max(0.1, dupe_radius_factor))\n        self.grid_cell_factor = float(max(0.5, grid_cell_factor))\n        self.bucket_soft_cap = int(max(2, bucket_soft_cap))\n        self.connect_radius_factor = float(max(1.0, connect_radius_factor))\n        self.connect_trials = int(max(0, connect_trials))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.stall_after = int(max(100, stall_after))\n        self.edge_cache_capacity = int(max(5000, edge_cache_capacity))\n        self.edge_cache_quant = float(max(0.1, edge_cache_quant))\n\n        self._rng = 1234567\n\n    # -------------------- Public API --------------------\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        # Build spatial acceleration\n        self._build_obstacle_grid()\n        # Early invalid\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n        # Trivial\n        if self._dist(self.start, self.goal) <= 1e-12:\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, 0.0)\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Parameters\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_factor)\n        self.connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n        self.rewire_radius = max(self.step_size, self.rewire_radius_factor * self.step_size)\n        self._seed_from_scene()\n\n        # Edge cache\n        self._tick = 0\n        self._last_prune_size = 0\n        self.ecache = {}\n        self.ecache_quant = float(max(0.1, self.edge_cache_quant))\n\n        # Trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_path = None\n        best_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        last_improve_iter = 0\n\n        for it in range(self.max_iter):\n            active_from_start = (it % 2 == 0)\n            tree1 = tree_a if active_from_start else tree_b\n            tree2 = tree_b if active_from_start else tree_a\n            grid1 = grid_a if active_from_start else grid_b\n            grid2 = grid_b if active_from_start else grid_a\n            attractor = self.goal if active_from_start else self.start\n\n            # Sample\n            if best_path is not None and self._rand() < self.informed_bias:\n                x_rand = self._sample_informed(best_len)\n            else:\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    x_rand = self._sample_corridor(d_sg)\n                else:\n                    x_rand = self._sample_free()\n            if x_rand is None:\n                continue\n\n            # Nearest\n            qnear = self._nearest_in_grid(grid1, x_rand)\n            if qnear is None:\n                continue\n\n            # Steer and pre-insert checks\n            x_new = self._steer(qnear.position, x_rand, self.step_size)\n            if not self._in_bounds(x_new):\n                continue\n            if self._point_in_obstacles(x_new):\n                continue\n            if self._has_nearby(grid1, x_new, self.dupe_radius):\n                continue\n            if not self._edge_free(qnear.position, x_new):\n                continue\n\n            # Choose best parent among neighbors and short lookback\n            parent, new_cost = self._choose_parent(grid1, qnear, x_new)\n\n            # Soft cap admission\n            if not self._bucket_accept(grid1, x_new, new_cost):\n                continue\n\n            # Insert node (ensuring both checks already passed)\n            new_node = Node(x_new, parent, new_cost)\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(grid1, new_node)\n\n            # Rewire cheaper neighbors\n            nbrs = self._neighbors_in_radius(grid1, x_new, self.rewire_radius, self.k_near_max)\n            for nb in nbrs:\n                if nb is new_node or nb is parent:\n                    continue\n                cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n                if cand_cost + 1e-9 < nb.cost and self._edge_free(new_node.position, nb.position):\n                    # Perform rewiring\n                    oldp = nb.parent\n                    if oldp is not None:\n                        try:\n                            oldp.children.remove(nb)\n                        except:\n                            pass\n                    self._remove_edge(edges, oldp, nb)\n                    new_node.add_child(nb)\n                    nb.cost = cand_cost\n                    edges.append((new_node, nb))\n                    self._propagate_costs(nb, edges)\n\n            # Try to connect to the other tree\n            a_end, b_end = self._try_connect(new_node, tree2, grid2, nodes, edges)\n            if a_end is not None and b_end is not None:\n                path = self._merge_paths(a_end, b_end, active_from_start)\n                plen = self._path_len(path)\n                if plen + 1e-9 < best_len:\n                    best_path = path\n                    best_len = plen\n                    last_improve_iter = it\n\n            # Early refinement stop if no improvement\n            if best_path is not None and (it - last_improve_iter) >= self.stall_after:\n                final = self._finalize_path(best_path)\n                return PlannerResult(True, final, nodes, edges)\n\n        if best_path is not None:\n            final = self._finalize_path(best_path)\n            return PlannerResult(True, final, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # -------------------- RNG --------------------\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0x7fffffff\n        s ^= len(self.obstacles) * 2654435761\n        self._rng = (s ^ 0x9E3779B9) & 0x7fffffff\n        if self._rng == 0:\n            self._rng = 1234567\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0x7fffffff\n        return (self._rng / 2147483647.0)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # -------------------- Geometry --------------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= step:\n            return self._clamp_tuple(b)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_paths(self, a_end, b_end, active_from_start):\n        pa = self._path_to_root(a_end)\n        pb = self._path_to_root(b_end)\n        if active_from_start:\n            pb.reverse()\n            return pa + pb\n        else:\n            pa.reverse()\n            return pb + pa\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # -------------------- Sampling --------------------\n    def _sample_free(self):\n        for _ in range(64):\n            if self.dims == 3:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _sample_corridor(self, dsg):\n        t = self._rand()\n        seg = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        width = max(self.step_size, 0.15 * dsg)\n        for _ in range(24):\n            if self.dims == 3:\n                ox = self._rand_range(-width, width)\n                oy = self._rand_range(-width, width)\n                oz = self._rand_range(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((seg[0] + ox, seg[1] + oy, seg[2] + oz))\n                else:\n                    continue\n            else:\n                ox = self._rand_range(-width, width)\n                oy = self._rand_range(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((seg[0] + ox, seg[1] + oy))\n                else:\n                    continue\n            if not self._point_in_obstacles(p):\n                return p\n        return self._sample_free()\n\n    def _sample_informed(self, best_len):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dims))\n        a = 0.5 * best_len\n        for _ in range(64):\n            if self.dims == 3:\n                p = (self._rand_range(c[0] - a, c[0] + a),\n                     self._rand_range(c[1] - a, c[1] + a),\n                     self._rand_range(c[2] - a, c[2] + a))\n            else:\n                p = (self._rand_range(c[0] - a, c[0] + a),\n                     self._rand_range(c[1] - a, c[1] + a))\n            if not self._in_bounds(p):\n                continue\n            if self._dist(self.start, p) + self._dist(p, self.goal) <= best_len + 1e-9 and not self._point_in_obstacles(p):\n                return p\n        return self._sample_corridor(self._dist(self.start, self.goal))\n\n    # -------------------- Node spatial grid --------------------\n    def _cell_of(self, pos):\n        if self.dims == 3:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        else:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        lst = grid.get(key)\n        if lst is None:\n            grid[key] = [node]\n        else:\n            lst.append(node)\n\n    def _nearest_in_grid(self, grid, pos, max_ring=6):\n        cell = self._cell_of(pos)\n        best = None\n        bestd = 1e100\n        if self.dims == 3:\n            for r in range(0, max_ring + 1):\n                found = False\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            b = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if not b:\n                                continue\n                            for n in b:\n                                d = self._dist(n.position, pos)\n                                if d < bestd:\n                                    bestd = d\n                                    best = n\n                                    found = True\n                if found:\n                    return best\n        else:\n            for r in range(0, max_ring + 1):\n                found = False\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        b = grid.get((cell[0] + dx, cell[1] + dy))\n                        if not b:\n                            continue\n                        for n in b:\n                            d = self._dist(n.position, pos)\n                            if d < bestd:\n                                bestd = d\n                                best = n\n                                found = True\n                if found:\n                    return best\n        # Fallback: return any from all buckets\n        for b in grid.values():\n            for n in b:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, kmax):\n        cell = self._cell_of(pos)\n        r_cells = int(max(1, radius // self.cell_size) + 1)\n        cand = []\n        if self.dims == 3:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((cell[0] + dx, cell[1] + dy))\n                    if b:\n                        cand.extend(b)\n        # Sort by distance and cap to kmax\n        tmp = []\n        for n in cand:\n            tmp.append((self._dist(n.position, pos), n))\n        tmp.sort(key=lambda x: x[0])\n        out = []\n        for i in range(min(kmax, len(tmp))):\n            out.append(tmp[i][1])\n        return out\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        r_cells = int(max(1, radius // self.cell_size) + 1)\n        r2 = radius * radius\n        if self.dims == 3:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._sqdist(n.position, pos) <= r2:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((cell[0] + dx, cell[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._sqdist(n.position, pos) <= r2:\n                            return True\n        return False\n\n    def _sqdist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _bucket_accept(self, grid, pos, new_cost):\n        key = self._cell_of(pos)\n        b = grid.get(key)\n        if not b:\n            return True\n        if len(b) < self.bucket_soft_cap:\n            return True\n        # Soft admission: allow if it improves the worst cost in bucket\n        worst = -1e100\n        for n in b:\n            if n.cost > worst:\n                worst = n.cost\n        return new_cost + 1e-9 < worst\n\n    # -------------------- Obstacle spatial grid and collision --------------------\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.dims == 3:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            key = (cx, cy, cz)\n                            lst = self.obs_grid.get(key)\n                            if lst is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        key = (cx, cy)\n                        lst = self.obs_grid.get(key)\n                        if lst is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.dims == 3:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.ecache_quant) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.ecache_quant) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        if len(self.ecache) - self._last_prune_size > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self.ecache:\n            return\n        cutoff = self._tick - 3000\n        to_del = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            i = 0\n            for k in list(self.ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune_size = len(self.ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(self.dims):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # -------------------- Parent selection and rewiring --------------------\n    def _choose_parent(self, grid, qnear, x_new):\n        best_parent = qnear\n        best_cost = qnear.cost + self._dist(qnear.position, x_new)\n\n        # Neighbor-based selection\n        nbrs = self._neighbors_in_radius(grid, x_new, self.rewire_radius, self.k_near_max)\n        for n in nbrs:\n            if self._edge_free(n.position, x_new):\n                c = n.cost + self._dist(n.position, x_new)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best_parent = n\n\n        # Short ancestor lookback from qnear\n        cur = qnear\n        depth = 0\n        while cur is not None and depth < self.lookback_depth:\n            if self._edge_free(cur.position, x_new):\n                c = cur.cost + self._dist(cur.position, x_new)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best_parent = cur\n            cur = cur.parent\n            depth += 1\n\n        return best_parent, best_cost\n\n    def _propagate_costs(self, node, edges):\n        # Recompute costs of subtree from current parent downwards\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is not None:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            # children unchanged structurally; push to update\n            for ch in cur.children:\n                stack.append(ch)\n\n    # -------------------- Connect attempt --------------------\n    def _try_connect(self, new_node, other_tree, other_grid, nodes, edges):\n        qnear = self._nearest_in_grid(other_grid, new_node.position)\n        if qnear is None:\n            return (None, None)\n        # Direct edge\n        if self._edge_free(new_node.position, qnear.position):\n            return (new_node, qnear)\n\n        # Bounded extend toward new_node\n        cur = qnear\n        trials = 0\n        while trials < self.connect_trials:\n            nxt_pos = self._steer(cur.position, new_node.position, self.step_size)\n            if not self._in_bounds(nxt_pos):\n                break\n            if self._point_in_obstacles(nxt_pos):\n                break\n            if self._has_nearby(other_grid, nxt_pos, self.dupe_radius):\n                break\n            if not self._edge_free(cur.position, nxt_pos):\n                break\n            # Insert extension node (both checks satisfied)\n            nxt = Node(nxt_pos, cur, cur.cost + self._dist(cur.position, nxt_pos))\n            cur.add_child(nxt)\n            other_tree.append(nxt)\n            nodes.append(nxt)\n            edges.append((cur, nxt))\n            self._grid_insert(other_grid, nxt)\n            # Short LOS compression toward grandparent\n            gp = cur.parent\n            if gp is not None and self._edge_free(gp.position, nxt_pos):\n                try:\n                    cur.children.remove(nxt)\n                except:\n                    pass\n                self._remove_edge(edges, cur, nxt)\n                gp.add_child(nxt)\n                nxt.cost = gp.cost + self._dist(gp.position, nxt_pos)\n                edges.append((gp, nxt))\n            cur = nxt\n            trials += 1\n            # Check direct connect now\n            if self._edge_free(cur.position, new_node.position):\n                return (new_node, cur)\n        return (None, None)\n\n    def _remove_edge(self, edges, a, b):\n        if a is None or b is None:\n            return\n        for i in range(len(edges)):\n            if edges[i][0] is a and edges[i][1] is b:\n                edges.pop(i)\n                return\n\n    # -------------------- Path finalization --------------------\n    def _finalize_path(self, path):\n        if not path:\n            return []\n        pruned = self._visibility_prune(path)\n        return self._shortcut(pruned)\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, path):\n        if len(path) < 3 or self.shortcut_attempts <= 0:\n            return list(path)\n        pts = list(path)\n        best_len = self._path_len(pts)\n        tries = 0\n        while tries < self.shortcut_attempts and len(pts) >= 3:\n            i = int(self._rand_range(0, len(pts) - 2))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(pts[i], pts[j]):\n                new_pts = pts[:i + 1] + pts[j:]\n                new_len = self._path_len(new_pts)\n                if new_len + 1e-9 < best_len:\n                    pts = new_pts\n                    best_len = new_len\n            tries += 1\n        return pts",
        "objective": -11.32774,
        "time_improvement": -33.0,
        "length_improvement": 22.0,
        "smoothness_improvement": 1573.0,
        "node_improvement": 73.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.046834897994995114,
                "num_nodes_avg": 130.0,
                "path_length_avg": 149.32993104614934,
                "smoothness_avg": 0.036661498379251534,
                "success_improvement": 0.0,
                "time_improvement": -89.83560899854946,
                "node_improvement": 67.26265424326367,
                "length_improvement": 18.149898509422645,
                "smoothness_improvement": 473.83206135324673,
                "objective_score": -13.691583287145015
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.07827587127685547,
                "num_nodes_avg": 198.0,
                "path_length_avg": 225.8643764569522,
                "smoothness_avg": 0.11752863025941271,
                "success_improvement": 0.0,
                "time_improvement": 53.19872730590275,
                "node_improvement": 86.69623059866962,
                "length_improvement": 24.599969993058853,
                "smoothness_improvement": 2924.096309025387,
                "objective_score": 45.34008173273307
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.08122072219848633,
                "num_nodes_avg": 265.0,
                "path_length_avg": 115.44527293294735,
                "smoothness_avg": 0.11180648037432621,
                "success_improvement": 0.0,
                "time_improvement": -60.90729647020259,
                "node_improvement": 66.3064208518754,
                "length_improvement": 23.326746631089154,
                "smoothness_improvement": 1322.170177665503,
                "objective_score": 2.3347099259202304
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "AURORA-BiRRT*: Adaptive Unified Rewire-Optimized Receding-Envelope BiRRT with Curvature-Aware Smoothing. It grows two trees with adaptive step sizing in clutter, dynamic-radius best-parent selection, bounded rewiring, and multi-step micro-bridging. Sampling blends goal, corridor, and informed prolate-ellipse regions using an incumbent path. A voxelized obstacle index accelerates exact slab-based segment-AABB checks. On connection, visibility compression, probabilistic shortcuts, and an angle-aware elastic smoother produce shorter, smoother paths quickly and robustly.",
        "planning_mechanism": "Alternate expanding start/goal trees. Each iteration: biased target sampling (goal/corridor/informed/uniform), ring-hash nearest, adaptive steer with local clutter feedback, and strict node+edge collision checks. Select a least-cost parent from radius-limited neighbors, insert, then leap to a visible ancestor and rewire a few cheaper neighbors. Attempt direct or multi-step micro-bridge to the opposite tree. Maintain an incumbent best length to focus informed sampling. On success, assemble and postprocess the path (visibility prune, bounded shortcuts, curvature-aware elastic smoothing) and return.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        pts = []\n        cur = self\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=7.0,\n        goal_bias=0.2,\n        corridor_bias=0.4,\n        informed_bias=0.5,\n        grid_cell_factor=1.25,\n        dupe_radius_factor=0.35,\n        connect_factor=2.75,\n        rewire_radius_mult=2.0,\n        neighbor_cap=48,\n        bridge_trials=2,\n        rewire_cap=8,\n        shortcut_trials=120,\n        smooth_iters=18\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dupe_radius_factor = float(dupe_radius_factor)\n        self.connect_factor = float(connect_factor)\n        self.rewire_radius_mult = float(rewire_radius_mult)\n        self.neighbor_cap = int(neighbor_cap)\n        self.bridge_trials = int(max(0, bridge_trials))\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.shortcut_trials = int(max(0, shortcut_trials))\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        # Validate endpoints\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_rng()\n        self._build_obs_index()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if self._segment_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Derived params\n        self.cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_r = max(0.5, self.step_size * self.dupe_radius_factor)\n        self.connect_dist = max(self.step_size, self.connect_factor * self.step_size)\n        self.corridor_w = max(self.step_size, 0.2 * self._dist(self.start, self.goal))\n\n        # Trees and grids\n        nodes = []\n        edges = []\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_put(Ga, a_root)\n        self._grid_put(Gb, b_root)\n\n        best_len = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            grow_a = (it % 2 == 0)\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n\n            target = self._sample_target(attractor, best_len)\n            if target is None:\n                continue\n\n            near = self._nearest(G, target, T)\n            if near is None:\n                continue\n\n            new_pos = self._steer_adaptive(near.position, target)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_blocked(new_pos):\n                continue\n            if self._has_duplicate(G, new_pos, self.dupe_r):\n                continue\n\n            parent, new_cost = self._choose_parent(G, T, new_pos)\n            if parent is None:\n                continue\n            if self._point_blocked(new_pos) or not self._segment_free(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            T.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_put(G, new_node)\n\n            # Ancestor visibility leap\n            self._ancestor_leap(new_node, edges)\n\n            # Local bounded rewiring\n            self._rewire_local(G, new_node, edges)\n\n            # Try to connect to the opposite tree\n            other = self._nearest(Gopp, new_node.position, Topp)\n            connected = False\n            end_node = None\n            if other is not None:\n                if self._dist(new_node.position, other.position) <= self.connect_dist and self._segment_free(new_node.position, other.position):\n                    connected = True\n                    end_node = other\n                else:\n                    # Micro-bridge steps from the opposite tree\n                    head = other\n                    for _ in range(self.bridge_trials):\n                        step_p = self._steer_adaptive(head.position, new_node.position)\n                        if not self._in_bounds(step_p) or self._point_blocked(step_p):\n                            break\n                        if self._has_duplicate(Gopp, step_p, self.dupe_r):\n                            break\n                        if not self._segment_free(head.position, step_p):\n                            break\n                        q = Node(step_p, head, head.cost + self._dist(head.position, step_p))\n                        head.add_child(q)\n                        Topp.append(q)\n                        nodes.append(q)\n                        edges.append((head, q))\n                        self._grid_put(Gopp, q)\n                        self._ancestor_leap(q, edges)\n                        self._rewire_local(Gopp, q, edges)\n                        head = q\n                        if self._segment_free(new_node.position, head.position):\n                            connected = True\n                            end_node = head\n                            break\n\n            if connected and end_node is not None:\n                path = self._assemble(new_node, end_node, grow_a)\n                path = self._postprocess(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Maintain incumbent for informed sampling\n            if other is not None and self._segment_free(new_node.position, other.position):\n                tmp = self._assemble(new_node, other, grow_a)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._postprocess(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s = (s * 2654435761 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 13) * 1103515245\n        self._rng = s if s != 0 else 2463534242\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and bounds\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer_adaptive(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        # Base step\n        step = self.step_size if d > self.step_size else d\n        # Estimate local clutter by obstacle index buckets overlapped by tentative step box\n        dirv = tuple((b[i] - a[i]) / d for i in range(self.dims))\n        trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n        clutter = self._box_bucket_density(a, trial)\n        if clutter > 10 and step > 0.5 * self.step_size:\n            step *= 0.6\n            trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n            clutter = self._box_bucket_density(a, trial)\n            if clutter > 14 and step > 0.3 * self.step_size:\n                step *= 0.6\n                trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n        return self._clamp(trial)\n\n    # Sampling\n    def _sample_target(self, attractor, best_len):\n        for _ in range(16):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._sample_informed(best_len * 1.02)\n                if p is not None and not self._point_blocked(p):\n                    return p\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            elif r < self.goal_bias + self.corridor_bias:\n                t = self._rand()\n                base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n                if self.dims == 3:\n                    p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                         self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w),\n                         self._rand_range(base[2] - self.corridor_w, base[2] + self.corridor_w))\n                else:\n                    p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                         self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w))\n            else:\n                if self.dims == 3:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            p = self._clamp(p)\n            if not self._point_blocked(p):\n                return p\n        return None\n\n    def _sample_informed(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        # Axis-aligned rejection in prolate envelope\n        for _ in range(24):\n            if self.dims == 3:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half),\n                     self._rand_range(c[2] - half, c[2] + half))\n            else:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half))\n            if self._in_bounds(p) and (self._dist(p, self.start) + self._dist(p, self.goal)) <= max_sum:\n                return p\n        return None\n\n    # Node grid\n    def _cell_of(self, pos):\n        return tuple(int(pos[i] // self.cell) for i in range(self.dims))\n\n    def _grid_put(self, grid, node):\n        k = self._cell_of(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_nodes(self, grid, key, r):\n        out = []\n        if self.dims == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos, tree):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        for r in range(0, 4):\n            cand = self._ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback limited scan\n        if not tree:\n            return None\n        step = max(1, len(tree) // 64)\n        for i in range(0, len(tree), step):\n            n = tree[i]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r = max(1, int(radius // self.cell) + 1)\n        cand = self._ring_nodes(grid, key, r)\n        out = []\n        rr = radius * radius\n        for n in cand:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_duplicate(self, grid, pos, radius):\n        return len(self._neighbors(grid, pos, radius, self.neighbor_cap)) > 0\n\n    # Parent selection and optimization\n    def _choose_parent(self, grid, tree, new_pos):\n        n = max(1, len(tree))\n        # RRT* radius ~ (log(n)/n)^{1/d} scaled\n        base = (self.rewire_radius_mult * self.step_size)\n        dyn_r = max(self.step_size, base * ((1.0 + self._log1p(n)) / n) ** (1.0 / max(1, self.dims)))\n        neigh = self._neighbors(grid, new_pos, dyn_r, self.neighbor_cap)\n        if not neigh:\n            # fallback to nearest in tree\n            near = None\n            bestd = 1e100\n            for m in tree:\n                d = self._dist(m.position, new_pos)\n                if d < bestd:\n                    bestd = d\n                    near = m\n            neigh = [near] if near is not None else []\n        best_p = None\n        best_c = 1e100\n        for p in neigh:\n            d = self._dist(p.position, new_pos)\n            gc = p.cost + d\n            if gc + 1e-9 < best_c and self._segment_free(p.position, new_pos):\n                best_c = gc\n                best_p = p\n        if best_p is None:\n            return None, None\n        return best_p, best_c\n\n    def _log1p(self, x):\n        # simple series for small x; adequate for our integer n\n        return 0.5 if x <= 1.0 else self._fast_log(x + 1.0)\n\n    def _fast_log(self, x):\n        # crude monotonic approximation using change-of-base and piecewise\n        y = 0.0\n        t = x\n        while t > 2.718281828:\n            t *= 0.367879441  # divide by e\n            y += 1.0\n        # linear tail\n        return y + (t - 1.0) / 2.718281828\n\n    def _ancestor_leap(self, node, edges):\n        curp = node.parent\n        if curp is None:\n            return\n        bestp = curp\n        bestc = node.cost\n        anc = curp.parent\n        while anc is not None:\n            if self._segment_free(anc.position, node.position):\n                c = anc.cost + self._dist(anc.position, node.position)\n                if c + 1e-9 < bestc:\n                    bestc = c\n                    bestp = anc\n            anc = anc.parent\n        if bestp is not curp:\n            self._reparent(node, bestp, edges)\n\n    def _rewire_local(self, grid, node, edges):\n        radius = max(self.step_size, self.rewire_radius_mult * self.step_size)\n        neigh = self._neighbors(grid, node.position, radius, self.neighbor_cap)\n        improvements = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if node.cost + d + 1e-9 < nb.cost and self._segment_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n                improvements += 1\n                if improvements >= self.rewire_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        if child.parent is new_parent:\n            return\n        if not self._segment_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._remove_edge(edges, old, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        # propagate cost to subtree\n        stack = [child]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if abs(newc - ch.cost) > 1e-12:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is p and e[1] is c:\n                edges.pop(i)\n                return\n\n    # Obstacles and collision\n    def _build_obs_index(self):\n        # Cell size for obstacle spatial index\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.dims == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obs_grid.get(key)\n                            if b is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obs_grid.get(key)\n                        if b is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_blocked(self, p):\n        if self.dims == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _segment_free(self, a, b):\n        return not self._segment_hits(a, b)\n\n    def _box_bucket_density(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            s = 0\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            s += len(bkt)\n            return s\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            s = 0\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        s += len(bkt)\n            return s\n\n    def _segment_hits(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit3d(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit2d(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit2d(self, p0, p1, bmin, bmax):\n        # Slab method\n        t0, t1 = 0.0, 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _seg_box_hit3d(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Path assembly and postprocess\n    def _assemble(self, u, v, a_side):\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if a_side:\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _postprocess(self, path):\n        if len(path) < 2:\n            return path[:]\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.shortcut_trials)\n        p = self._elastic_angle_smooth(p, self.smooth_iters)\n        return p\n\n    def _visibility_prune(self, path):\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._segment_free(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = list(path)\n        best = self._path_len(pts)\n        n = len(pts)\n        fail = 0\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1:\n                fail += 1\n                if fail > 24:\n                    break\n                continue\n            a, b = pts[i], pts[j - 1]\n            if self._segment_free(a, b):\n                cand = pts[:i + 1] + pts[j - 1:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    pts = cand\n                    best = L\n                    n = len(pts)\n                    fail = 0\n                else:\n                    fail += 1\n            else:\n                fail += 1\n            if fail > 48:\n                break\n        return pts\n\n    def _elastic_angle_smooth(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                b = pts[i]\n                c = pts[i + 1]\n                # Angle-aware midpoint pull\n                mid = tuple(0.25 * a[k] + 0.5 * b[k] + 0.25 * c[k] for k in range(self.dims))\n                if self._point_blocked(mid):\n                    continue\n                if self._segment_free(a, mid) and self._segment_free(mid, c):\n                    if mid != b:\n                        pts[i] = mid\n                        moved = True\n                # Try skip if possible\n                if self._segment_free(a, c):\n                    pts[i] = c  # will be removed next pass by neighbors\n                    moved = True\n            # Compact duplicates\n            comp = [pts[0]]\n            for p in pts[1:]:\n                if p != comp[-1]:\n                    comp.append(p)\n            pts = comp\n            if not moved:\n                break\n            if len(pts) < 3:\n                break\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts",
        "objective": -39.0221,
        "time_improvement": 68.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1312.0,
        "node_improvement": 88.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.009383320808410645,
                "num_nodes_avg": 51.0,
                "path_length_avg": 148.31907804876715,
                "smoothness_avg": 0.03583382190014427,
                "success_improvement": 0.0,
                "time_improvement": 61.966642474939334,
                "node_improvement": 87.15688743389575,
                "length_improvement": 18.703963055278603,
                "smoothness_improvement": 460.8771271269766,
                "objective_score": 32.11675621128384
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.043584227561950684,
                "num_nodes_avg": 172.0,
                "path_length_avg": 228.72791182641134,
                "smoothness_avg": 0.08818936081319215,
                "success_improvement": 0.0,
                "time_improvement": 73.9409183696743,
                "node_improvement": 88.44319021702614,
                "length_improvement": 23.644039464437803,
                "smoothness_improvement": 2169.175773952521,
                "objective_score": 47.21457805932758
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.01668705940246582,
                "num_nodes_avg": 82.0,
                "path_length_avg": 122.67227871244054,
                "smoothness_avg": 0.1106371606216832,
                "success_improvement": 0.0,
                "time_improvement": 66.9410768359495,
                "node_improvement": 89.57406230133503,
                "length_improvement": 18.526913505383728,
                "smoothness_improvement": 1307.2965167220898,
                "objective_score": 37.73495373762554
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "SAGE-Connect: A simplified adaptive BiRRT-Connect with local cost-aware parenting and light rewiring. It uses a uniform spatial hash for nearest/neighbor queries, coarse obstacle binning for fast collision checks, adaptive rewire radius, and minimal biased/informed sampling. It inserts only strictly node- and edge-free states, creates the exact meeting node to reduce kinks, and applies a compact densify+shortcut+visibility smoother for short, smooth paths.",
        "planning_mechanism": "Alternate growth from start/goal trees: sample (uniform with small goal bias; ellipse after first solution), steer one step, choose the best-cost parent among nearby nodes, add after node+edge checks, locally rewire cheaper neighbors, then greedily extend the opposite tree toward the new node and insert the exact meeting point; upon connection, extract, densify, shortcut, visibility-prune, and return.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=6.0,\n        connect_mult=2.0,\n        goal_bias=0.12,\n        grid_cell_factor=1.6,\n        rewire_base=2.2,\n        smooth_iters=120\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_mult = float(connect_mult)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.rewire_base = float(rewire_base)\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.connect_step = max(self.step, self.step * self.connect_mult)\n        self.dup_radius = max(0.5, 0.4 * self.step)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            Ta = tree_a if active_start else tree_b\n            Tb = tree_b if active_start else tree_a\n            Ga = grid_a if active_start else grid_b\n            Gb = grid_b if active_start else grid_a\n            attractor = self.goal if active_start else self.start\n\n            sample = self._sample(attractor, best_len)\n            if sample is None:\n                continue\n\n            na = self._nearest(Ga, sample)\n            if na is None:\n                continue\n\n            newp = self._steer(na.position, sample, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(Ga, newp, self.dup_radius):\n                continue\n            if not self._edge_free(na.position, newp):\n                continue\n\n            rew_rad = self._adaptive_rewire_radius(len(Ta))\n            parent, new_cost = self._choose_parent(Ga, newp, na, rew_rad)\n\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            Ta.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(Ga, nn)\n\n            self._local_rewire(Ga, nn, rew_rad, edges)\n\n            meet_node, reached = self._connect_toward(Tb, Gb, nn.position, nodes, edges)\n            if reached:\n                if active_start:\n                    pa = self._trace_to_root(nn)        # start -> ... -> nn\n                    pb = self._trace_to_root(meet_node) # goal  -> ... -> nn\n                    path = pa + pb[-2::-1]              # avoid duplicate nn\n                else:\n                    pa = self._trace_to_root(meet_node) # start -> ... -> nn\n                    pb = self._trace_to_root(nn)        # goal  -> ... -> nn\n                    path = pa + pb[-2::-1]\n\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 13) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found_any = False\n        for r in range(0, 4):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found_any = True\n            if found_any:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius)) > 0\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.2)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parenting and rewiring\n    def _choose_parent(self, grid, newp, fallback, radius):\n        parent = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        neigh = self._neighbors_in_radius(grid, newp, radius)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                parent = n\n                best_cost = c\n        return parent, best_cost\n\n    def _local_rewire(self, grid, nn, radius, edges):\n        neigh = self._neighbors_in_radius(grid, nn.position, radius)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            cand = nn.cost + self._dist(nn.position, nb.position)\n            if cand + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                nn.add_child(nb)\n                nb.cost = cand\n                edges.append((nn, nb))\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        try:\n            idx = edges.index(e)\n            edges.pop(idx)\n        except:\n            pass\n\n    def _adaptive_rewire_radius(self, n_nodes):\n        # Shrink with tree size without log; simple exponential decay\n        base = max(self.step * 1.2, self.step * self.rewire_base)\n        decay = pow(0.5, n_nodes / 2500.0)\n        return max(self.step * 1.2, base * decay)\n\n    # BiRRT-Connect growth from other tree toward target; insert exact meeting node if visible\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < 64:\n            if self._edge_free(cur.position, target_pos):\n                # Insert the exact meeting point for a clean junction\n                if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                    if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        cur.add_child(nn)\n                        tree.append(nn)\n                        nodes.append(nn)\n                        edges.append((cur, nn))\n                        self._grid_add(grid, nn)\n                        return nn, True\n                # If too close, treat current as meeting node\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(grid, nxt, self.dup_radius * 0.75):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n        # Final try after capped steps\n        if self._edge_free(cur.position, target_pos):\n            if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    edges.append((cur, nn))\n                    self._grid_add(grid, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.55:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _densify(self, pts, seg_len):\n        if len(pts) < 2:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts)):\n            a = out[-1]\n            b = pts[i]\n            d = self._dist(a, b)\n            if d <= seg_len * 1.05:\n                out.append(b)\n                continue\n            nseg = int(d / seg_len)\n            if nseg < 1:\n                out.append(b)\n                continue\n            for k in range(1, nseg + 1):\n                t = k / float(nseg + 1)\n                inter = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n                if self._edge_free(out[-1], inter):\n                    out.append(inter)\n                else:\n                    break\n            if self._edge_free(out[-1], b):\n                out.append(b)\n            else:\n                out.append(b)\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._densify(path, seg_len=max(1.0, 0.5 * self.step))\n        p1 = self._shortcut(p0, self.smooth_iters)\n        p2 = self._visibility_prune(p1)\n        p3 = self._shortcut(p2, max(20, self.smooth_iters // 2))\n        return self._dedup(p3)",
        "objective": -39.95809,
        "time_improvement": 69.0,
        "length_improvement": 21.0,
        "smoothness_improvement": 1361.0,
        "node_improvement": 85.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.008446240425109863,
                "num_nodes_avg": 40.0,
                "path_length_avg": 154.00203649529243,
                "smoothness_avg": 0.0463463750398735,
                "success_improvement": 0.0,
                "time_improvement": 65.76490472936995,
                "node_improvement": 89.92697053638882,
                "length_improvement": 15.589043478498803,
                "smoothness_improvement": 625.4214121382626,
                "objective_score": 32.21000456660158
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02304682731628418,
                "num_nodes_avg": 136.0,
                "path_length_avg": 230.09301068249903,
                "smoothness_avg": 0.08849989105200873,
                "success_improvement": 0.0,
                "time_improvement": 86.220263890156,
                "node_improvement": 90.86205738090439,
                "length_improvement": 23.188330174083777,
                "smoothness_improvement": 2177.1659406631616,
                "objective_score": 50.66490697481287
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.02282891273498535,
                "num_nodes_avg": 204.0,
                "path_length_avg": 115.03810237530747,
                "smoothness_avg": 0.10863321186734835,
                "success_improvement": 0.0,
                "time_improvement": 54.77338134763434,
                "node_improvement": 74.06230133502861,
                "length_improvement": 23.597169928095134,
                "smoothness_improvement": 1281.8064364830614,
                "objective_score": 36.99934854356269
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "IBiRRT-Lite/G2: Informed, Balanced Bi-directional RRT with bounded-nearest search, short-range cost-aware parenting, light rewiring, cached collision tests, and nonincreasing visibility pruning for fast, smooth, and short paths. Tuned radii, duplicate control, and ellipse-focused sampling after the first solution improve efficiency and robustness over parents while preserving safety.",
        "planning_mechanism": "Alternate expansion of the smaller tree: sample (uniform/goal; informed ellipse after a solution), get a bounded-ring nearest, steer one step, reject near-duplicates, pick the lowest-cost feasible parent among nearby neighbors, validate node and edge, insert and lightly rewire. Try a short direct bridge to the opposite tree; if blocked, allow one assisted hop on the passive tree and retry. On success, extract, visibility-prune, and shortcut the path, then return. Edge checks use a small LRU cache; obstacle queries use a grid index.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3500,\n        step_size=4.8,\n        goal_bias=0.18,\n        informed_bias=0.7,\n        grid_cell_factor=0.9,\n        parent_factor=2.2,\n        rewire_factor=2.4,\n        connect_factor=2.6,\n        dupe_ratio=0.35,\n        ring_cap=6,\n        per_cell_cap=24,\n        assist_hops=1,\n        smooth_iters=64,\n        edge_cache_capacity=12000\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.parent_factor = float(parent_factor)\n        self.rewire_factor = float(rewire_factor)\n        self.connect_factor = float(connect_factor)\n        self.dupe_ratio = float(dupe_ratio)\n        self.ring_cap = int(ring_cap)\n        self.per_cell_cap = int(per_cell_cap)\n        self.assist_hops = int(assist_hops)\n        self.smooth_iters = int(smooth_iters)\n        self.edge_cache_capacity = int(edge_cache_capacity)\n        self._rng = 123456789\n        self._tick = 0\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_rng()\n\n        # Build obstacle index\n        self.obs_cell = max(2.5, self.step_size * 1.1)\n        self._build_obs_index()\n\n        # Validate start/goal free\n        if self._in_obs(self.start) or self._in_obs(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Fast straight-line check\n        self._ecache = {}\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            edges = [(n0, n1)]\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], edges)\n\n        # Spatial params\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius_base = max(0.3, self.dupe_ratio * self.step_size)\n        self.connect_radius = max(self.step_size, self.connect_factor * self.step_size)\n\n        # Trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        have_solution = False\n        best_path = []\n        best_len = 1e100\n        c_min = self._dist(self.start, self.goal)\n\n        for _ in range(self.max_iter):\n            # Expand smaller tree\n            expand_a = (len(tree_a) <= len(tree_b))\n            active_tree = tree_a if expand_a else tree_b\n            passive_tree = tree_b if expand_a else tree_a\n            active_grid = grid_a if expand_a else grid_b\n            passive_grid = grid_b if expand_a else grid_a\n            attractor = self.goal if expand_a else self.start\n\n            dupe_radius = self.dupe_radius_base * (0.4 if have_solution else 1.0)\n            parent_radius = self.parent_factor * self.step_size\n            rewire_radius = self.rewire_factor * self.step_size\n\n            x_rand = self._sample(attractor, have_solution, best_len, c_min)\n            if x_rand is None:\n                continue\n\n            nearest = self._nearest_bounded(active_grid, x_rand, self.ring_cap)\n            if nearest is None:\n                continue\n\n            x_new = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(x_new) or self._in_obs(x_new):\n                continue\n            if self._dist2(nearest.position, x_new) <= 1e-14:\n                continue\n            if self._has_nearby(active_grid, x_new, dupe_radius):\n                continue\n\n            parent, new_cost = self._choose_parent(active_grid, x_new, nearest, parent_radius)\n            if parent is None:\n                continue\n\n            if self._in_obs(x_new):\n                continue\n            if not self._edge_free(parent.position, x_new):\n                continue\n\n            # Per-cell capacity with cost override\n            if not self._cell_accept(active_grid, x_new, new_cost):\n                continue\n\n            new_node = Node(x_new, parent, new_cost)\n            parent.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            self._grid_insert(active_grid, new_node)\n\n            self._rewire_light(new_node, active_grid, rewire_radius, 8)\n\n            # Try direct bridge\n            bnode = self._best_bridge_candidate(passive_grid, new_node.position, self.connect_radius)\n            bridged = None\n            if bnode is not None and self._edge_free(new_node.position, bnode.position):\n                bridged = bnode\n            else:\n                # One assisted hop if allowed\n                hops = 0\n                while bridged is None and hops < self.assist_hops:\n                    hops += 1\n                    near_p = self._nearest_bounded(passive_grid, new_node.position, self.ring_cap)\n                    if near_p is None:\n                        break\n                    x_step = self._steer(near_p.position, new_node.position, self.step_size)\n                    if not self._in_bounds(x_step) or self._in_obs(x_step):\n                        break\n                    if self._has_nearby(passive_grid, x_step, dupe_radius):\n                        break\n                    hop_parent, hop_cost = self._choose_parent(passive_grid, x_step, near_p, parent_radius)\n                    if hop_parent is None:\n                        break\n                    if not self._edge_free(hop_parent.position, x_step):\n                        break\n                    hop_node = Node(x_step, hop_parent, hop_cost)\n                    hop_parent.add_child(hop_node)\n                    passive_tree.append(hop_node)\n                    nodes.append(hop_node)\n                    self._grid_insert(passive_grid, hop_node)\n                    self._rewire_light(hop_node, passive_grid, rewire_radius, 6)\n                    if self._edge_free(hop_node.position, new_node.position):\n                        bridged = hop_node\n                        break\n\n            if bridged is not None:\n                path = self._extract_path(new_node, bridged, expand_a)\n                path = self._visibility_prune(path)\n                path = self._shortcut_nonincreasing(path, self.smooth_iters)\n                best_path = path\n                best_len = self._path_len(best_path)\n                edges = self._collect_edges(nodes)\n                return PlannerResult(True, best_path, nodes, edges)\n\n            if have_solution and best_path:\n                best_path = self._shortcut_nonincreasing(best_path, 4)\n                best_len = self._path_len(best_path)\n\n        edges = self._collect_edges(nodes)\n        if best_path:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # -------- RNG --------\n    def _seed_rng(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 29) * 2654435761\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # -------- Geometry --------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        d = d2 ** 0.5\n        if d <= step:\n            q = []\n            for i in range(self.dim):\n                v = b[i]\n                if v < 0.0:\n                    v = 0.0\n                if v > self.bounds[i]:\n                    v = self.bounds[i]\n                q.append(v)\n            return tuple(q)\n        r = step / d\n        q = []\n        for i in range(self.dim):\n            v = a[i] + (b[i] - a[i]) * r\n            if v < 0.0:\n                v = 0.0\n            if v > self.bounds[i]:\n                v = self.bounds[i]\n            q.append(v)\n        return tuple(q)\n\n    # -------- Obstacles and collision --------\n    def _build_obs_index(self):\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, ob in enumerate(self.obstacles):\n                x, y, z, w, h, d = ob\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            arr = self.obs_grid.get(k)\n                            if arr is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                arr.append(idx)\n        else:\n            for idx, ob in enumerate(self.obstacles):\n                x, y, w, h = ob\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        arr = self.obs_grid.get(k)\n                        if arr is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            arr.append(idx)\n\n    def _in_obs(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            arr = self.obs_grid.get((cx, cy, cz))\n            if not arr:\n                return False\n            px, py, pz = p\n            for idx in arr:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            arr = self.obs_grid.get((cx, cy))\n            if not arr:\n                return False\n            px, py = p\n            for idx in arr:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        q = max(0.5, self.step_size * 0.5)\n        qa = tuple(int(a[i] / q) for i in range(self.dim))\n        qb = tuple(int(b[i] / q) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self._ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self._ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self._ecache[key] = (free, self._tick)\n        if len(self._ecache) > self.edge_cache_capacity:\n            # prune ~35% oldest\n            cutoff = self._tick - 1500\n            rem = []\n            for k, v in self._ecache.items():\n                if v[1] < cutoff:\n                    rem.append(k)\n            if not rem:\n                i = 0\n                for k in list(self._ecache.keys()):\n                    if i % 3 == 0:\n                        rem.append(k)\n                    i += 1\n            for k in rem:\n                if k in self._ecache:\n                    del self._ecache[k]\n        return free\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        arr = self.obs_grid.get((cx, cy, cz))\n                        if arr:\n                            for idx in arr:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect3(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    arr = self.obs_grid.get((cx, cy))\n                    if arr:\n                        for idx in arr:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_box_intersect2(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect2(self, p0, p1, mn, mx):\n        t0 = 0.0\n        t1 = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            if abs(d) < 1e-12:\n                if p < mn[i] or p > mx[i]:\n                    return False\n            else:\n                inv = 1.0 / d\n                tmin = (mn[i] - p) * inv\n                tmax = (mx[i] - p) * inv\n                if tmin > tmax:\n                    tmin, tmax = tmax, tmin\n                if tmin > t0:\n                    t0 = tmin\n                if tmax < t1:\n                    t1 = tmax\n                if t0 > t1:\n                    return False\n        return True\n\n    def _seg_box_intersect3(self, p0, p1, mn, mx):\n        t0 = 0.0\n        t1 = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            if abs(d) < 1e-12:\n                if p < mn[i] or p > mx[i]:\n                    return False\n            else:\n                inv = 1.0 / d\n                tmin = (mn[i] - p) * inv\n                tmax = (mx[i] - p) * inv\n                if tmin > tmax:\n                    tmin, tmax = tmax, tmin\n                if tmin > t0:\n                    t0 = tmin\n                if tmax < t1:\n                    t1 = tmax\n                if t0 > t1:\n                    return False\n        return True\n\n    # -------- Spatial hashing --------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _neighbors_within(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        out = []\n        r2 = radius * radius\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _nearest_bounded(self, grid, pos, ring_cap):\n        key = self._cell_of(pos)\n        best = None\n        bestd2 = 1e100\n        visited = False\n        for r in range(0, ring_cap + 1):\n            cand = []\n            if self.is_3d:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if b:\n                                cand.extend(b)\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy))\n                        if b:\n                            cand.extend(b)\n            if not cand:\n                continue\n            visited = True\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n        if visited:\n            return best\n        # fallback random buckets\n        buckets = list(grid.values())\n        tries = 0\n        while tries < 24 and buckets:\n            b = buckets[int(self._rand_range(0, len(buckets)))]\n            if b:\n                n = b[int(self._rand_range(0, len(b)))]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            tries += 1\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        ns = self._neighbors_within(grid, pos, radius)\n        return len(ns) > 0\n\n    def _cell_accept(self, grid, pos, cand_cost):\n        key = self._cell_of(pos)\n        b = grid.get(key)\n        if not b:\n            return True\n        if len(b) < self.per_cell_cap:\n            return True\n        best = 1e100\n        for n in b:\n            if n.cost < best:\n                best = n.cost\n        return cand_cost < best - 1e-6\n\n    # -------- Parent selection and light rewiring --------\n    def _choose_parent(self, grid, new_pos, fallback, radius):\n        cand = self._neighbors_within(grid, new_pos, radius)\n        if fallback not in cand:\n            cand.append(fallback)\n        best = None\n        best_cost = 1e100\n        best_smooth = -2.0\n        for n in cand:\n            if not self._edge_free(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-12 < best_cost:\n                best_cost = c\n                best = n\n                best_smooth = self._smooth_score(n, new_pos)\n            elif abs(c - best_cost) <= 1e-12:\n                sc = self._smooth_score(n, new_pos)\n                if sc > best_smooth:\n                    best_smooth = sc\n                    best = n\n        if best is None:\n            return None, None\n        return best, best_cost\n\n    def _smooth_score(self, parent, new_pos):\n        if parent.parent is None:\n            return 0.0\n        a = parent.parent.position\n        b = parent.position\n        c = new_pos\n        ab = tuple(b[i] - a[i] for i in range(self.dim))\n        bc = tuple(c[i] - b[i] for i in range(self.dim))\n        nab = self._dist(a, b)\n        nbc = self._dist(b, c)\n        if nab <= 1e-12 or nbc <= 1e-12:\n            return 0.0\n        dot = 0.0\n        for i in range(self.dim):\n            dot += ab[i] * bc[i]\n        cs = dot / (nab * nbc)\n        if cs < -1.0:\n            cs = -1.0\n        if cs > 1.0:\n            cs = 1.0\n        return cs\n\n    def _rewire_light(self, pivot, grid, radius, limit):\n        neighbors = self._neighbors_within(grid, pivot.position, radius)\n        changed = 0\n        for nb in neighbors:\n            if nb is pivot or nb.parent is pivot:\n                continue\n            # avoid cycles\n            if self._is_ancestor(nb, pivot):\n                continue\n            if not self._edge_free(pivot.position, nb.position):\n                continue\n            new_c = pivot.cost + self._dist(pivot.position, nb.position)\n            if new_c + 1e-12 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    try:\n                        oldp.children.remove(nb)\n                    except:\n                        pass\n                pivot.add_child(nb)\n                nb.cost = new_c\n                self._propagate_cost(nb)\n                changed += 1\n                if changed >= limit:\n                    break\n\n    def _is_ancestor(self, node, potential_child):\n        cur = potential_child\n        while cur is not None:\n            if cur is node:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if newc + 1e-12 < ch.cost:\n                    ch.cost = newc\n                stack.append(ch)\n\n    # -------- Bridging and path --------\n    def _best_bridge_candidate(self, grid_other, pos, radius):\n        cand = self._neighbors_within(grid_other, pos, radius)\n        if not cand:\n            return None\n        best = None\n        bestd2 = 1e100\n        for n in cand:\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd2:\n                bestd2 = d2\n                best = n\n        return best\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node, a_from_start):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if a_from_start:\n            return pa + list(reversed(pb))\n        else:\n            return pb + list(reversed(pa))\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                a = out[-1]\n                b = path[j]\n                if self._edge_free(a, b):\n                    # ensure nonincreasing subpath length\n                    seg = self._dist(a, b)\n                    walk = 0.0\n                    for k in range(i + 1, j + 1):\n                        walk += self._dist(path[k - 1], path[k])\n                    if seg + 1e-9 <= walk:\n                        out.append(b)\n                        i = j\n                        advanced = True\n                        break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        return out\n\n    def _shortcut_nonincreasing(self, path, iters):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        bestL = self._path_len(pts)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                newL = self._path_len(new_pts)\n                if newL <= bestL + 1e-12:\n                    pts = new_pts\n                    bestL = newL\n        return pts\n\n    def _collect_edges(self, nodes):\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return edges\n\n    # -------- Sampling --------\n    def _sample(self, attractor, informed, best_len, c_min):\n        r = self._rand()\n        if informed and best_len < 1e99 and r < self.informed_bias:\n            p = self._informed_sample(self.start, self.goal, best_len * 1.01, c_min)\n            if p is not None and self._in_bounds(p) and not self._in_obs(p):\n                return p\n        if r < self.goal_bias:\n            if self._in_bounds(attractor) and not self._in_obs(attractor):\n                return attractor\n        # Uniform\n        p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n        if self._in_bounds(p) and not self._in_obs(p):\n            return p\n        return None\n\n    def _informed_sample(self, f1, f2, c_best, c_min):\n        if not (c_best > c_min + 1e-9):\n            return None\n        center = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        a_vec = tuple(f2[i] - f1[i] for i in range(self.dim))\n        a_len = self._dist((0.0,) * self.dim, a_vec)\n        if a_len <= 1e-12:\n            return None\n        a_hat = tuple(a_vec[i] / a_len for i in range(self.dim))\n        r1 = 0.5 * c_best\n        r2_sq = max(0.0, 0.25 * (c_best * c_best - c_min * c_min))\n        if self.is_3d:\n            u = (1.0, 0.0, 0.0) if abs(a_hat[0]) < 0.9 else (0.0, 1.0, 0.0)\n            v = self._normalize(self._cross(a_hat, u))\n            w = self._cross(a_hat, v)\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                z = self._rand_range(-1.0, 1.0)\n                if x * x + y * y + z * z > 1.0:\n                    continue\n                px = r1 * x\n                r2 = (r2_sq ** 0.5)\n                py = r2 * y\n                pz = r2 * z\n                qx = center[0] + px * a_hat[0] + py * v[0] + pz * w[0]\n                qy = center[1] + px * a_hat[1] + py * v[1] + pz * w[1]\n                qz = center[2] + px * a_hat[2] + py * v[2] + pz * w[2]\n                p = (qx, qy, qz)\n                if self._in_bounds(p) and not self._in_obs(p):\n                    return p\n            return None\n        else:\n            perp = (-a_hat[1], a_hat[0])\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                if x * x + y * y > 1.0:\n                    continue\n                r2 = (r2_sq ** 0.5)\n                px = r1 * x\n                py = r2 * y\n                qx = center[0] + px * a_hat[0] + py * perp[0]\n                qy = center[1] + px * a_hat[1] + py * perp[1]\n                p = (qx, qy)\n                if self._in_bounds(p) and not self._in_obs(p):\n                    return p\n            return None\n\n    def _normalize(self, v):\n        n = self._dist((0.0,) * len(v), v)\n        if n <= 1e-12:\n            return v\n        return tuple(v[i] / n for i in range(len(v)))\n\n    def _cross(self, a, b):\n        return (a[1] * b[2] - a[2] * b[1],\n                a[2] * b[0] - a[0] * b[2],\n                a[0] * b[1] - a[1] * b[0])",
        "objective": -11.57164,
        "time_improvement": -22.0,
        "length_improvement": 22.0,
        "smoothness_improvement": 969.0,
        "node_improvement": 84.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.03673973083496094,
                "num_nodes_avg": 63.0,
                "path_length_avg": 149.69172610370086,
                "smoothness_avg": 0.038074679665983276,
                "success_improvement": 0.0,
                "time_improvement": -48.91692895846401,
                "node_improvement": 84.1349785948124,
                "length_improvement": 17.951592905369097,
                "smoothness_improvement": 495.95141726288006,
                "objective_score": -1.4243658580033447
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.09294075965881347,
                "num_nodes_avg": 200.0,
                "path_length_avg": 225.57346551196792,
                "smoothness_avg": 0.06931150246963083,
                "success_improvement": 0.0,
                "time_improvement": 44.43056632606514,
                "node_improvement": 86.56184908956529,
                "length_improvement": 24.69708443990187,
                "smoothness_improvement": 1683.4348816009249,
                "objective_score": 36.56459496976529
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.08128533363342286,
                "num_nodes_avg": 148.0,
                "path_length_avg": 114.83076641207353,
                "smoothness_avg": 0.06516345151492713,
                "success_improvement": 0.0,
                "time_improvement": -61.0352989187808,
                "node_improvement": 81.18245390972663,
                "length_improvement": 23.734872602597505,
                "smoothness_improvement": 728.8742934042099,
                "objective_score": -0.42529464705468767
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "IBEX-Lite: Informed BiRRT* with Elastic Micro-Connect. It blends fast bidirectional growth, visibility-based best-parent insertion with light rewiring, obstacle-binned collision checks, and a commit-only micro-bridge to connect trees. After connection it runs multi-pass visibility compression, shortcutting, and safe corner rounding. The design targets high success, short and smooth paths with low planning time.",
        "planning_mechanism": "Alternate growing the two trees (balanced), sampling via goal/corridor-biased free points. For each sample: pick a nearby anchor with a hash grid, steer one step, and select the least-cost visible parent among local neighbors with a small turn-angle penalty; insert only after node and edge checks, then lightly rewire neighbors. Probe the opposite tree: first try direct LOS; else simulate a few greedy steps; if a connector exists, commit the whole micro-bridge and return the assembled, smoothed path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            # detach from old parent\n            i = 0\n            while i < len(self.parent.children):\n                if self.parent.children[i] is self:\n                    self.parent.children.pop(i)\n                    break\n                i += 1\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=6.0,\n                 goal_bias=0.3,\n                 corridor_bias=0.25,\n                 grid_cell_factor=1.8,\n                 neighbor_radius_factor=2.2,\n                 dupe_radius_ratio=0.3,\n                 k_rewire=4,\n                 connect_hops=3,\n                 edge_res=0.8,\n                 smooth_shortcuts=80,\n                 smooth_rounds=6):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.cell_factor = float(grid_cell_factor)\n        self.nei_factor = float(neighbor_radius_factor)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.k_rewire = int(max(0, k_rewire))\n        self.connect_hops = int(max(1, connect_hops))\n        self.edge_res = float(edge_res)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.smooth_rounds = int(max(0, smooth_rounds))\n        self._rng = 123456789\n\n    def plan(self, map):\n        # Setup\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", [])) if getattr(map, \"obstacles\", None) is not None else []\n\n        self._seed_rng()\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], [], [])\n        # Build obstacle bins before collision tests\n        self._build_obs_bins()\n\n        # Validate endpoints\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        nodes = []\n        edges = []\n\n        # Early straight-line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Derived spatial params\n        self.cell = max(1.0, self.step * self.cell_factor)\n        self.nei_radius = max(1.5 * self.step, self.step * self.nei_factor)\n        self.dupe_radius = max(0.35, self.step * self.dupe_ratio)\n\n        # Initialize two trees and grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        A, B = [a_root], [b_root]\n        nodes.extend([a_root, b_root])\n        GA, GB = {}, {}\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n        frontierA, frontierB = [a_root], [b_root]\n\n        for it in range(self.max_iter):\n            # Balanced alternating\n            if it % 3 == 2:\n                growA = (len(A) <= len(B))\n            else:\n                growA = (it % 2 == 0)\n\n            T = A if growA else B\n            O = B if growA else A\n            G = GA if growA else GB\n            GO = GB if growA else GA\n            frontier = frontierA if growA else frontierB\n            frontierO = frontierB if growA else frontierA\n            attract = self.goal if growA else self.start\n\n            target = self._sample_target(attract)\n            if target is None:\n                continue\n\n            # nearest anchor\n            qnear = self._nearest(G, frontier, target, max_rings=2)\n            if qnear is None:\n                qnear = T[-1]\n\n            qnew_pos = self._steer(qnear.position, target, self.step)\n            if (not self._in_bounds(qnew_pos)) or self._point_blocked(qnew_pos):\n                continue\n            if self._has_close(G, qnew_pos, self.dupe_radius):\n                continue\n\n            parent, bestc = self._choose_parent(G, qnew_pos, qnear)\n            if parent is None:\n                continue\n\n            # Both checks before insertion\n            if self._point_blocked(qnew_pos):\n                continue\n            if not self._edge_free(parent.position, qnew_pos):\n                continue\n\n            qnode = Node(qnew_pos, parent, bestc)\n            qnode.attach(parent)\n            T.append(qnode)\n            nodes.append(qnode)\n            edges.append((parent, qnode))\n            self._grid_add(G, qnode)\n            frontier.append(qnode)\n            if len(frontier) > 160:\n                del frontier[:16]\n\n            # Local light rewiring\n            if self.k_rewire > 0:\n                self._rewire_local(qnode, G, edges, k=self.k_rewire)\n\n            # Try to connect to opposite tree\n            other_near = self._nearest(GO, frontierO, qnode.position, max_rings=2)\n            if other_near is not None:\n                # Direct bridge\n                if self._edge_free(qnode.position, other_near.position):\n                    path = self._assemble_path(qnode, other_near, growA)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # Elastic micro-bridge (commit only if it completes)\n                qlast = self._micro_bridge(O, GO, other_near, qnode.position)\n                if qlast is not None and self._edge_free(qnode.position, qlast.position):\n                    path = self._assemble_path(qnode, qlast, growA)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s ^= (int(v * 2654435761) & 0xffffffff)\n            s = (s * 1664525 + 1013904223) & 0xffffffff\n        s ^= len(self.obstacles) * 374761393\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        # xorshift32\n        x = self._rng & 0xffffffff\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Obstacle bins and collisions\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self._obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self._obin.get(key)\n                            if lst is None:\n                                self._obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self._obin.get(key)\n                        if lst is None:\n                            self._obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_bucket(self, p):\n        if self.is3:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell),\n                                   int(p[2] // self.obs_cell)))\n        else:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell)))\n\n    def _point_blocked(self, p):\n        bucket = self._point_bucket(p)\n        if not bucket:\n            return False\n        if self.is3:\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _seg_box_intersect(self, a, b, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(self.dim):\n            p = a[i]\n            d = b[i] - a[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        # Quickly reject with obstacle bin candidate list based on segment bbox coverage\n        if self.is3:\n            mn = (min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            iz0 = int(max(0.0, mn[2]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self._obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            mn = (min(a[0], b[0]), min(a[1], b[1]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self._obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    # Grid utilities\n    def _cell_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, frontier, pos, max_rings=2):\n        kk = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring(grid, kk, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bd:\n                        bd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # fallback to recent frontier\n        if frontier:\n            lim = min(24, len(frontier))\n            for i in range(lim):\n                n = frontier[-1 - i]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bd:\n                    bd = d2\n                    best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap=20):\n        kk = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((kk[0] + dx, kk[1] + dy, kk[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((kk[0] + dx, kk[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _has_close(self, grid, pos, radius):\n        ns = self._neighbors(grid, pos, radius, cap=6)\n        return len(ns) > 0\n\n    # Parent selection with small turn penalty\n    def _choose_parent(self, grid, new_pos, fallback):\n        cand = self._neighbors(grid, new_pos, self.nei_radius, cap=24)\n        if fallback not in cand:\n            cand.append(fallback)\n        best = None\n        best_cost = 1e100\n        for p in cand:\n            d = self._dist(p.position, new_pos)\n            if d > 1.6 * self.step:\n                continue\n            if not self._edge_free(p.position, new_pos):\n                continue\n            c = p.cost + d\n            # Turn penalty: prefer smoother joins\n            if p.parent is not None:\n                u = tuple(p.position[i] - p.parent.position[i] for i in range(self.dim))\n                v = tuple(new_pos[i] - p.position[i] for i in range(self.dim))\n                nu = max(1e-12, self._dist((0.0,) * self.dim, u))\n                nv = max(1e-12, self._dist((0.0,) * self.dim, v))\n                dot = 0.0\n                for i in range(self.dim):\n                    dot += u[i] * v[i]\n                cosang = max(-1.0, min(1.0, dot / (nu * nv)))\n                # angle in [0, pi]; penalty scaled by step\n                ang = (1.0 - cosang)  # cheaper than acos, monotonic\n                c += 0.08 * self.step * ang\n            if c < best_cost:\n                best_cost = c\n                best = p\n        return best, best_cost\n\n    # Light rewiring around a new node\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                edges.pop(i)\n                return\n\n    def _propagate_delta(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire_local(self, new_node, grid, edges, k=4):\n        neigh = self._neighbors(grid, new_node.position, self.nei_radius, cap=32)\n        if not neigh:\n            return\n        # Prefer closest neighbors\n        neigh.sort(key=lambda n: self._dist2(n.position, new_node.position))\n        count = 0\n        for nb in neigh:\n            if count >= k:\n                break\n            if nb is new_node or nb is new_node.parent:\n                continue\n            if self._is_ancestor(nb, new_node):\n                continue\n            # Both checks before adding new edge\n            if self._point_blocked(nb.position):\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand_cost + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    # detach from old parent\n                    i = 0\n                    while i < len(oldp.children):\n                        if oldp.children[i] is nb:\n                            oldp.children.pop(i)\n                            break\n                        i += 1\n                    self._remove_edge(edges, oldp, nb)\n                nb.attach(new_node)\n                edges.append((new_node, nb))\n                delta = cand_cost - nb.cost\n                nb.cost = cand_cost\n                self._propagate_delta(nb, delta)\n                count += 1\n\n    # Micro-bridge: simulate a few steps on opposite tree, commit only if connection completes\n    def _micro_bridge(self, tree, grid, near_node, target_pos):\n        cur = near_node.position\n        chain = []\n        success = False\n        last = None\n        for _ in range(self.connect_hops):\n            nxt = self._steer(cur, target_pos, self.step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                break\n            if self._has_close(grid, nxt, self.dupe_radius * 0.7):\n                break\n            if not self._edge_free(cur, nxt):\n                break\n            chain.append(nxt)\n            cur = nxt\n            # if we can close the final link to target, mark success\n            if self._edge_free(cur, target_pos):\n                success = True\n                last = cur\n                break\n        if not success or last is None:\n            return None\n        # Commit the chain to the opposite tree with both checks on each segment\n        prev = near_node\n        for p in chain:\n            if self._point_blocked(p):\n                return None\n            if not self._edge_free(prev.position, p):\n                return None\n            nn = Node(p, prev, prev.cost + self._dist(prev.position, p))\n            nn.attach(prev)\n            tree.append(nn)\n            self._grid_add(grid, nn)\n            prev = nn\n        return prev\n\n    # Sampling\n    def _sample_target(self, attract):\n        for _ in range(28):\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attract\n            elif r < self.goal_bias + self.corridor_bias:\n                p = self._corridor_point()\n            else:\n                if self.is3:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        return None\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.08 * sg)\n        if self.is3:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w),\n                                base[2] + self._rand_range(-w, w)))\n        else:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w)))\n\n    # Path assembly and utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble_path(self, a_end, b_end, a_side_grew):\n        if a_side_grew:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pa[0] == pb[-1]:\n                pb = pb[:-1]\n            return pa + pb[::-1]\n        else:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pb[0] == pa[-1]:\n                pa = pa[:-1]\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # Smoothing\n    def _vis_collapse(self, pts, passes=2):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            i = 0\n            changed = False\n            while i < len(cur) - 2:\n                j = len(cur) - 1\n                while j > i + 1:\n                    if self._edge_free(cur[i], cur[j]):\n                        if j > i + 1:\n                            del cur[i + 1:j]\n                            changed = True\n                        break\n                    j -= 1\n                i += 1\n            if not changed:\n                break\n        return cur\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            n = len(cur)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n - 1:\n                tries += 1\n                continue\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-12 <= bestL:\n                    cur = cand\n                    bestL = L\n            tries += 1\n        return cur\n\n    def _round_corners(self, pts, passes):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if (not self._in_bounds(mid)) or self._point_blocked(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if cur[i] != mid:\n                        cur[i] = mid\n                        moved = True\n            if not moved:\n                break\n        return cur\n\n    def _postprocess(self, path):\n        if len(path) < 3:\n            return path[:]\n        p = self._vis_collapse(path, passes=2)\n        p = self._shortcut(p, self.smooth_shortcuts)\n        p = self._round_corners(p, self.smooth_rounds)\n        return p",
        "objective": -37.68839,
        "time_improvement": 61.0,
        "length_improvement": 21.0,
        "smoothness_improvement": 1336.0,
        "node_improvement": 87.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.011586189270019531,
                "num_nodes_avg": 61.0,
                "path_length_avg": 150.2550697876198,
                "smoothness_avg": 0.041941448754662616,
                "success_improvement": 0.0,
                "time_improvement": 53.03776905243485,
                "node_improvement": 84.63863006799295,
                "length_improvement": 17.64281530546121,
                "smoothness_improvement": 556.4747503241836,
                "objective_score": 29.279393650628094
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03080716133117676,
                "num_nodes_avg": 131.0,
                "path_length_avg": 228.48646410685174,
                "smoothness_avg": 0.08768701591384163,
                "success_improvement": 0.0,
                "time_improvement": 81.58034736794089,
                "node_improvement": 91.19801115366526,
                "length_improvement": 23.72464166291407,
                "smoothness_improvement": 2156.250077867826,
                "objective_score": 49.490139597469835
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.026394367218017578,
                "num_nodes_avg": 112.0,
                "path_length_avg": 116.65576078031737,
                "smoothness_avg": 0.10957624060714707,
                "success_improvement": 0.0,
                "time_improvement": 47.70981892140697,
                "node_improvement": 85.75969485060394,
                "length_improvement": 22.5227982401031,
                "smoothness_improvement": 1293.8016924461601,
                "objective_score": 34.29563308271475
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "Bi-Hash IRRT*-Connect with Commit-Connect and Informed Radius: a bidirectional, grid-accelerated RRT* variant that grows two optimized trees with adaptive near-radius (using a log/n heuristic), informed prolate-ellipsoid sampling after the first solution, and a commit-only connection step that simulates the entire bridge before adding any opposite-tree nodes. Nearest/neighbor queries use a spatial hash grid; parent selection prefers lowest path cost; localized rewiring improves costs. Upon any join, the incumbent cost bounds future samples; the final path is visibility-pruned and shortcut-smoothed.",
        "planning_mechanism": "Alternate expanding start/goal trees. Each cycle: sample (goal-biased, bounds-respecting; informed once a path exists), get nearest via grid, steer one step, validate node and edge, pick lowest-cost feasible parent among radius-neighbors, insert and lightly rewire. Try a commit-connect from the opposite tree by simulating the full multi-step bridge; only if the whole bridge and final edge are collision-free are those nodes added. Maintain best path and restrict sampling to its ellipsoid; terminate after a brief post-optimization budget and return a pruned, shortcut-smoothed path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n\n    def attach(self, new_parent):\n        if new_parent is self.parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            if self not in new_parent.children:\n                new_parent.children.append(self)\n\n    def is_ancestor_of(self, other):\n        cur = other\n        while cur is not None:\n            if cur is self:\n                return True\n            cur = cur.parent\n        return False\n\n    def propagate_cost(self, delta):\n        if delta == 0.0:\n            return\n        self.cost += delta\n        for c in self.children:\n            c.propagate_cost(delta)\nclass Planner:\n    def __init__(self,\n                 max_iter=4500,\n                 step_size=8.0,\n                 goal_bias=0.15,\n                 informed_bias=0.6,\n                 gamma_radius=80.0,\n                 min_radius_factor=2.2,\n                 grid_cell_factor=1.8,\n                 dupe_radius_ratio=0.3,\n                 rewire_cap=18,\n                 post_opt_iters=280,\n                 max_no_improve=120,\n                 shortcut_attempts=140):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.gamma_radius = float(gamma_radius)\n        self.min_radius_factor = float(min_radius_factor)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.rewire_cap = int(rewire_cap)\n        self.post_opt_iters = int(post_opt_iters)\n        self.max_no_improve = int(max_no_improve)\n        self.shortcut_attempts = int(shortcut_attempts)\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacle(self.start) or self._point_in_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._seed_rng()\n        self.grid_cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.4, self.step_size * self.dupe_radius_ratio)\n        self.min_radius = max(self.step_size * self.min_radius_factor, self.step_size * 2.0)\n        self.max_radius = max(self.step_size * 6.0, self.grid_cell * 2.0)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            edges = [(n0, n1)]\n            return PlannerResult(True, self._finalize_path([self.start, self.goal]), [n0, n1], edges)\n\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        A = [a_root]\n        B = [b_root]\n        grid_A = {}\n        grid_B = {}\n        self._grid_add(grid_A, a_root)\n        self._grid_add(grid_B, b_root)\n\n        success = False\n        best_len = float('inf')\n        best_join = (None, None)\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            grow_A = (it % 2 == 0)\n            T = A if grow_A else B\n            O = B if grow_A else A\n            Gt = grid_A if grow_A else grid_B\n            Go = grid_B if grow_A else grid_A\n            attractor = self.goal if grow_A else self.start\n\n            qrand = self._sample(attractor, best_len)\n            if qrand is None:\n                continue\n\n            qnear = self._nearest_grid(Gt, T, qrand)\n            if qnear is None:\n                continue\n\n            qnew_pos = self._steer(qnear.position, qrand)\n            if not self._in_bounds(qnew_pos):\n                continue\n            if self._point_in_obstacle(qnew_pos):\n                continue\n            if self._has_near_in(Gt, qnew_pos, self.dupe_radius):\n                continue\n\n            parent, new_cost = self._choose_parent(T, Gt, qnew_pos, qnear)\n            if parent is None:\n                continue\n            if self._point_in_obstacle(qnew_pos):\n                continue\n            if not self._edge_free(parent.position, qnew_pos):\n                continue\n\n            qnew = Node(qnew_pos, parent, new_cost)\n            T.append(qnew)\n            nodes.append(qnew)\n            edges.append((parent, qnew))\n            self._grid_add(Gt, qnew)\n\n            self._rewire_local(T, Gt, qnew, edges)\n\n            ok, meet_other, staged = self._commit_connect(O, Go, qnew.position)\n            if ok and meet_other is not None:\n                for u, v in staged:\n                    edges.append((u, v))\n                    nodes.append(v)\n                # cross-edge for visualization\n                edges.append((meet_other, qnew))\n                cur_len = meet_other.cost + self._dist(meet_other.position, qnew.position) + qnew.cost\n                if cur_len + 1e-12 < best_len:\n                    best_len = cur_len\n                    best_join = (qnew, meet_other) if grow_A else (meet_other, qnew)\n                    success = True\n                    if not found_first:\n                        found_first = True\n                    post_iters = 0\n                    no_improve = 0\n                else:\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n            else:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        path = []\n        if success and best_join[0] is not None and best_join[1] is not None:\n            path = self._extract_path(best_join[0], best_join[1])\n            path = self._finalize_path(path)\n\n        return PlannerResult(success, path, nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B97F4A7C15 & 0xffffffff\n        for v in self.start + self.goal:\n            s ^= (int(v * 2654435761) + (s << 7) + (s >> 3)) & 0xffffffff\n            s &= 0xffffffff\n        s ^= (len(self.obstacles) * 1103515245) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            tgt = a\n        elif d <= self.step_size:\n            tgt = b\n        else:\n            r = self.step_size / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n        out = tuple(max(0.0, min(tgt[i], self.bounds[i])) for i in range(self.dims))\n        return out\n\n    # Grid NN\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dims))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_gather(self, grid, pos, radius):\n        rng = int(radius // self.grid_cell) + 1\n        key = self._grid_key(pos)\n        cand = []\n        if self.dims == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        best = None\n        bestd = 1e100\n        rng = 0\n        while rng < 4:\n            cand = self._grid_gather(grid, pos, (rng + 1) * self.grid_cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                return best\n            rng += 1\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors_radius(self, grid, pos, radius):\n        cand = self._grid_gather(grid, pos, radius)\n        out = []\n        r = float(radius)\n        for n in cand:\n            if self._dist(n.position, pos) <= r:\n                out.append(n)\n        return out\n\n    def _has_near_in(self, grid, pos, radius):\n        cand = self._grid_gather(grid, pos, radius)\n        r = float(radius)\n        for n in cand:\n            if self._dist(n.position, pos) <= r:\n                return True\n        return False\n\n    # Parent choice and rewiring\n    def _log(self, x):\n        if x <= 0.0:\n            return -1e9\n        ln2 = 0.6931471805599453\n        k = 0\n        while x > 1.5:\n            x *= 0.5\n            k += 1\n        while x < 0.75:\n            x *= 2.0\n            k -= 1\n        z = (x - 1.0) / (x + 1.0)\n        z2 = z * z\n        s = z\n        term = z\n        # 9 terms of the series are plenty for our ranges\n        for n in (3, 5, 7, 9, 11, 13, 15, 17, 19):\n            term *= z2\n            s += term / n\n        return 2.0 * s + k * ln2\n\n    def _adaptive_radius(self, n):\n        n = max(2, int(n))\n        val = self.gamma_radius * ((max(1e-6, self._log(n)) / n) ** (1.0 / float(self.dims)))\n        if val < self.min_radius:\n            val = self.min_radius\n        if val > self.max_radius:\n            val = self.max_radius\n        return val\n\n    def _choose_parent(self, tree_nodes, grid, qpos, fallback):\n        n_nodes = len(tree_nodes) + 1\n        r = self._adaptive_radius(n_nodes)\n        near = self._neighbors_radius(grid, qpos, r)\n        if not near:\n            near = [fallback]\n        if fallback not in near:\n            near.append(fallback)\n        best_p = None\n        best_c = 1e100\n        for p in near:\n            if not self._edge_free(p.position, qpos):\n                continue\n            c = p.cost + self._dist(p.position, qpos)\n            if c < best_c:\n                best_c = c\n                best_p = p\n        return best_p, best_c\n\n    def _rewire_local(self, tree_nodes, grid, qnew, edges):\n        r = self._adaptive_radius(len(tree_nodes))\n        nbrs = self._neighbors_radius(grid, qnew.position, r)\n        rewired = 0\n        for w in nbrs:\n            if w is qnew or w is qnew.parent:\n                continue\n            if w.is_ancestor_of(qnew):\n                continue\n            alt = qnew.cost + self._dist(qnew.position, w.position)\n            if alt + 1e-12 < w.cost and self._edge_free(qnew.position, w.position):\n                oldp = w.parent\n                self._replace_edge(edges, oldp, w, qnew)\n                w.attach(qnew)\n                delta = alt - w.cost\n                w.propagate_cost(delta)\n                rewired += 1\n                if rewired >= self.rewire_cap:\n                    break\n\n    # Commit-only connect simulation\n    def _commit_connect(self, tree_nodes, grid, target_pos):\n        if not tree_nodes:\n            return False, None, []\n        cur = self._nearest_grid(grid, tree_nodes, target_pos)\n        staged_nodes = []\n        prev = cur\n        safety = 0\n        while self._dist(prev.position, target_pos) > self.step_size:\n            safety += 1\n            if safety > 1000:\n                return False, None, []\n            nxt_pos = self._steer(prev.position, target_pos)\n            if not self._in_bounds(nxt_pos):\n                return False, None, []\n            if self._point_in_obstacle(nxt_pos):\n                return False, None, []\n            near_snap = self._nearest_grid(grid, tree_nodes, nxt_pos)\n            if near_snap is not None and self._dist(near_snap.position, nxt_pos) <= self.dupe_radius:\n                if near_snap is prev:\n                    return False, None, []\n                prev = near_snap\n                continue\n            if not self._edge_free(prev.position, nxt_pos):\n                return False, None, []\n            new_node = Node(nxt_pos, None, prev.cost + self._dist(prev.position, nxt_pos))\n            staged_nodes.append((prev, new_node))\n            prev = new_node\n        if not self._edge_free(prev.position, target_pos):\n            return False, None, []\n        # commit all staged nodes\n        for p, q in staged_nodes:\n            q.attach(p)\n            tree_nodes.append(q)\n            self._grid_add(grid, q)\n        meet = prev if staged_nodes else cur\n        return True, meet, staged_nodes\n\n    # Collision\n    def _point_in_obstacle(self, p):\n        if self.is3d:\n            px, py, pz = p\n            for x, y, z, w, h, d in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for x, y, w, h in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        if self.is3d:\n            for x, y, z, w, h, d in self.obstacles:\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return False\n            return True\n        else:\n            for x, y, w, h in self.obstacles:\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return False\n            return True\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Edges\n    def _replace_edge(self, edges, old_parent, child, new_parent):\n        if old_parent is not None:\n            rm = -1\n            for i, (u, v) in enumerate(edges):\n                if u is old_parent and v is child:\n                    rm = i\n                    break\n            if rm >= 0:\n                edges.pop(rm)\n        if new_parent is not None:\n            exists = False\n            for u, v in edges:\n                if u is new_parent and v is child:\n                    exists = True\n                    break\n            if not exists:\n                edges.append((new_parent, child))\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        for _ in range(24):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.01)\n                if p is not None and self._in_bounds(p) and not self._point_in_obstacle(p):\n                    return p\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._in_bounds(p) and not self._point_in_obstacle(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(18):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path ops\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        return pa + pb[::-1]\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pruned[-1], path[j]):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_L = self._path_len(pts)\n        tries = 0\n        while tries < attempts and len(pts) > 2:\n            n = len(pts)\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best_L + 1e-12:\n                    pts = cand\n                    best_L = L\n            tries += 1\n        return pts\n\n    def _finalize_path(self, path):\n        if not path:\n            return []\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        return p",
        "objective": -11.71686,
        "time_improvement": -22.0,
        "length_improvement": 21.0,
        "smoothness_improvement": 1173.0,
        "node_improvement": 64.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.06743419170379639,
                "num_nodes_avg": 218.0,
                "path_length_avg": 147.43755657052654,
                "smoothness_avg": 0.04401219961597349,
                "success_improvement": 0.0,
                "time_improvement": -173.33060169754415,
                "node_improvement": 45.10198942331907,
                "length_improvement": 19.187138946103996,
                "smoothness_improvement": 588.8864980111664,
                "objective_score": -37.54246465154502
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.06782259941101074,
                "num_nodes_avg": 362.0,
                "path_length_avg": 221.63582815851981,
                "smoothness_avg": 0.06761558537305096,
                "success_improvement": 0.0,
                "time_improvement": 59.448755816075185,
                "node_improvement": 75.67694685211315,
                "length_improvement": 26.011581127089844,
                "smoothness_improvement": 1639.7977131862142,
                "objective_score": 41.640563987007525
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.026401686668395995,
                "num_nodes_avg": 223.0,
                "path_length_avg": 124.72687710116297,
                "smoothness_avg": 0.10922219079687726,
                "success_improvement": 0.0,
                "time_improvement": 47.695318275018224,
                "node_improvement": 71.64653528289891,
                "length_improvement": 17.16234708505599,
                "smoothness_improvement": 1289.2982049927668,
                "objective_score": 31.052494758502895
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "FALCON-Fuse: Fast Adaptive Learned-Cell biRRT* with Obstacle-Aware Sampling and Curvature Smoothing. It merges bidirectional RRT-Connect growth with local RRT* parenting and capped rewiring, an adaptive spatial grid for nearest/duplicate checks, obstacle- and line/goal-biased sampling plus informed prolate-ellipse sampling after the first solution, exact-node junctions to avoid kinks, lightweight edge-collision caching, and a multi-pass smoothing pipeline (visibility prune, shortcutting, and collision-checked corner rounding).",
        "planning_mechanism": "Each iteration draws one shared sample. The active tree steers one step, chooses the cheapest visible parent within an adaptive RRG radius, inserts the node if both node and edge are collision-free and not a duplicate, and locally rewires cheaper neighbors. The opposite tree greedily connects toward this new node with bounded steps, inserting the exact junction (or reusing an existing node) to produce a kink-free bridge. After the first path, informed sampling focuses search and a short refinement phase improves length; the final path is smoothed with densify, visibility prune, shortcutting, and curvature-aware corner rounding.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=5.0,\n        connect_factor=1.8,\n        goal_bias=0.10,\n        line_bias=0.18,\n        grid_cell_factor=1.5,\n        rewire_gamma=2.8,\n        rewire_cap=32,\n        refine_iters=360,\n        smooth_attempts=120,\n        corner_round_passes=3\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = float(connect_factor) * self.step\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.rewire_gamma = float(rewire_gamma)\n        self.rewire_cap = int(max(1, rewire_cap))\n        self.refine_iters = int(max(0, refine_iters))\n        self.smooth_attempts = int(max(0, smooth_attempts))\n        self.corner_round_passes = int(max(0, corner_round_passes))\n        self._rng = 246813579\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_base = max(0.4, 0.5 * self.step)\n        self._build_obs_bins()\n        self.ecache = {}\n        self.ecell = max(0.5, 0.5 * self.step)\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            final = self._finalize_path(path)\n            return PlannerResult(True, final, nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [start_root], [goal_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None\n        best_path = None\n        found_iter = None\n\n        for it in range(self.max_iter):\n            s = self._sample(best_len)\n            if s is None:\n                continue\n\n            nn = self._expand_once(Ta, Ga, s, nodes, edges)\n            if nn is not None:\n                meet, ok = self._connect_exact(Tb, Gb, nn.position, nodes, edges)\n                if ok:\n                    pa = self._trace_to_root(nn)\n                    pb = self._trace_to_root(meet)\n                    path = pa + pb[::-1][1:]\n                    path = self._dedup(path)\n                    L = self._path_len(path)\n                    if best_len is None or L + 1e-9 < best_len:\n                        best_len = L\n                        best_path = path\n                        if found_iter is None:\n                            found_iter = it\n\n            nn2 = self._expand_once(Tb, Gb, s, nodes, edges)\n            if nn2 is not None:\n                meet2, ok2 = self._connect_exact(Ta, Ga, nn2.position, nodes, edges)\n                if ok2:\n                    pa = self._trace_to_root(meet2)\n                    pb = self._trace_to_root(nn2)\n                    path = pa + pb[::-1][1:]\n                    path = self._dedup(path)\n                    L = self._path_len(path)\n                    if best_len is None or L + 1e-9 < best_len:\n                        best_len = L\n                        best_path = path\n                        if found_iter is None:\n                            found_iter = it\n\n            if best_path is not None and found_iter is not None:\n                if (it - found_iter) >= self.refine_iters:\n                    final = self._finalize_path(best_path)\n                    return PlannerResult(True, final, nodes, edges)\n\n        if best_path is not None:\n            final = self._finalize_path(best_path)\n            return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _expand_once(self, T, G, sample, nodes, edges):\n        near = self._nearest(G, sample)\n        if near is None:\n            return None\n        target = self._steer(near.position, sample, self.step)\n        if (not self._in_bounds(target)) or self._point_in_obstacles(target):\n            return None\n        radius = self._rrg_radius(len(T))\n        parent, pcost = self._choose_parent(G, target, near, radius)\n        if parent is None:\n            return None\n        dup_r = self._adapt_dup_radius(target)\n        if self._too_close(G, target, dup_r):\n            return None\n        if not self._edge_free(parent.position, target):\n            return None\n        nn = Node(target, parent, pcost)\n        parent.add_child(nn)\n        T.append(nn)\n        nodes.append(nn)\n        edges.append((parent, nn))\n        self._grid_add(G, nn)\n        self._local_rewire(G, nn, radius, edges)\n        return nn\n\n    def _connect_exact(self, T, G, target_pos, nodes, edges):\n        exist = self._find_existing(G, target_pos, 0.5 * self._adapt_dup_radius(target_pos))\n        if exist is not None:\n            return exist, True\n        cur = self._nearest(G, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < 36:\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                    if not self._too_close(G, target_pos, 0.5 * self._adapt_dup_radius(target_pos)):\n                        nc = Node(target_pos, cur, cur.cost + self._dist(cur.position, target_pos))\n                        cur.add_child(nc)\n                        T.append(nc)\n                        nodes.append(nc)\n                        edges.append((cur, nc))\n                        self._grid_add(G, nc)\n                        return nc, True\n                    else:\n                        e = self._find_existing(G, target_pos, 0.75 * self._adapt_dup_radius(target_pos))\n                        if e is not None:\n                            return e, True\n                        return cur, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if self._too_close(G, nxt, 0.5 * self._adapt_dup_radius(nxt)):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            nn = Node(nxt, cur, cur.cost + self._dist(cur.position, nxt))\n            cur.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(G, nn)\n            cur = nn\n            steps += 1\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._too_close(G, target_pos, 0.5 * self._adapt_dup_radius(target_pos)):\n                    nc = Node(target_pos, cur, cur.cost + self._dist(cur.position, target_pos))\n                    cur.add_child(nc)\n                    T.append(nc)\n                    nodes.append(nc)\n                    edges.append((cur, nc))\n                    self._grid_add(G, nc)\n                    return nc, True\n                else:\n                    e = self._find_existing(G, target_pos, 0.75 * self._adapt_dup_radius(target_pos))\n                    if e is not None:\n                        return e, True\n                    return cur, True\n            return cur, True\n        return cur, False\n\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int((v * 2654435761) % (1 << 32)) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 17) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 246813579\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, 3):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        count = 0\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                count += 1\n                                if count >= (self.rewire_cap * 2):\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            count += 1\n                            if count >= (self.rewire_cap * 2):\n                                return out\n        return out\n\n    def _find_existing(self, grid, pos, radius):\n        neigh = self._neighbors_in_radius(grid, pos, radius)\n        best = None\n        bestd = 1e100\n        for n in neigh:\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _too_close(self, grid, pos, radius):\n        lst = self._neighbors_in_radius(grid, pos, radius)\n        return len(lst) > 0\n\n    def _adapt_dup_radius(self, pos):\n        if self.is3:\n            ix = int(pos[0] // self.obs_cell)\n            iy = int(pos[1] // self.obs_cell)\n            iz = int(pos[2] // self.obs_cell)\n            near = self.obin.get((ix, iy, iz)) is not None\n        else:\n            ix = int(pos[0] // self.obs_cell)\n            iy = int(pos[1] // self.obs_cell)\n            near = self.obin.get((ix, iy)) is not None\n        return self.dup_base * (0.7 if near else 1.0)\n\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.4)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        if a == b:\n            return True\n        q = self.ecell\n        if self.dim == 3:\n            qa = (int(a[0] / q), int(a[1] / q), int(a[2] / q))\n            qb = (int(b[0] / q), int(b[1] / q), int(b[2] / q))\n        else:\n            qa = (int(a[0] / q), int(a[1] / q))\n            qb = (int(b[0] / q), int(b[1] / q))\n        if qa <= qb:\n            key = (qa, qb)\n        else:\n            key = (qb, qa)\n        val = self.ecache.get(key)\n        if val is not None:\n            return val\n        hit = self._segment_hits_any(a, b)\n        if len(self.ecache) > 30000:\n            self.ecache.clear()\n        self.ecache[key] = (not hit)\n        return not hit\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = []\n            seen = {}\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                if idx not in seen:\n                                    seen[idx] = True\n                                    cand.append(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = []\n            seen = {}\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            if idx not in seen:\n                                seen[idx] = True\n                                cand.append(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _choose_parent(self, grid, newp, fallback, radius):\n        best = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        neigh = self._neighbors_in_radius(grid, newp, radius)\n        count = 0\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost:\n                if self._edge_free(n.position, newp):\n                    best = n\n                    best_cost = c\n                    count += 1\n                    if count >= self.rewire_cap:\n                        break\n        return best, best_cost\n\n    def _local_rewire(self, grid, nn, radius, edges):\n        neigh = self._neighbors_in_radius(grid, nn.position, radius)\n        rewired = 0\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            cand_cost = nn.cost + self._dist(nn.position, nb.position)\n            if cand_cost + 1e-12 < nb.cost:\n                if self._edge_free(nn.position, nb.position):\n                    oldp = nb.parent\n                    if oldp is not None:\n                        oldp.remove_child(nb)\n                        self._remove_edge(edges, (oldp, nb))\n                    nn.add_child(nb)\n                    nb.cost = cand_cost\n                    edges.append((nn, nb))\n                    self._propagate_cost(nb)\n                    rewired += 1\n                    if rewired >= self.rewire_cap:\n                        break\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        for i in range(len(edges)):\n            if edges[i][0] is e[0] and edges[i][1] is e[1]:\n                edges.pop(i)\n                return\n\n    def _rrg_radius(self, n_nodes):\n        n = float(max(1, n_nodes))\n        expo = (1.0 / (1.0 + n)) ** (1.0 / float(max(1, self.dim)))\n        r = self.rewire_gamma * self.step * (expo ** 0.5)\n        return max(1.2 * self.step, min(5.0 * self.step, r))\n\n    def _sample(self, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.6:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            if self._in_bounds(self.goal) and (not self._point_in_obstacles(self.goal)):\n                return self.goal\n        if r < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t,\n                     self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t)\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        if r < 0.5:\n            p = self._sample_bridge()\n            if p is not None:\n                return p\n        return self._rand_free_point()\n\n    def _rand_free_point(self):\n        if self.is3:\n            for _ in range(16):\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n                if (not self._point_in_obstacles(p)):\n                    return p\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            for _ in range(16):\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n                if (not self._point_in_obstacles(p)):\n                    return p\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_bridge(self):\n        if self.is3:\n            p = (self._rand_range(0.0, self.bounds[0]),\n                 self._rand_range(0.0, self.bounds[1]),\n                 self._rand_range(0.0, self.bounds[2]))\n            q = (self._clamp((p[0] + self._rand_range(-self.step, self.step),\n                              p[1] + self._rand_range(-self.step, self.step),\n                              p[2] + self._rand_range(-self.step, self.step))))\n            if not self._in_bounds(q):\n                return None\n            m = ((p[0] + q[0]) * 0.5, (p[1] + q[1]) * 0.5, (p[2] + q[2]) * 0.5)\n            if self._point_in_obstacles(p) != self._point_in_obstacles(q):\n                if self._in_bounds(m) and (not self._point_in_obstacles(m)):\n                    return m\n            return None\n        else:\n            p = (self._rand_range(0.0, self.bounds[0]),\n                 self._rand_range(0.0, self.bounds[1]))\n            q = (self._clamp((p[0] + self._rand_range(-self.step, self.step),\n                              p[1] + self._rand_range(-self.step, self.step))))\n            if not self._in_bounds(q):\n                return None\n            m = ((p[0] + q[0]) * 0.5, (p[1] + q[1]) * 0.5)\n            if self._point_in_obstacles(p) != self._point_in_obstacles(q):\n                if self._in_bounds(m) and (not self._point_in_obstacles(m)):\n                    return m\n            return None\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _densify(self, pts, seg_len):\n        if len(pts) < 2:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts)):\n            a = out[-1]\n            b = pts[i]\n            d = self._dist(a, b)\n            if d <= seg_len * 1.05:\n                out.append(b)\n                continue\n            nseg = int(d / seg_len)\n            if nseg < 1:\n                out.append(b)\n                continue\n            for k in range(1, nseg + 1):\n                t = k / float(nseg + 1)\n                inter = self._lerp(a, b, t)\n                if self._edge_free(out[-1], inter):\n                    out.append(inter)\n                else:\n                    break\n            if self._edge_free(out[-1], b):\n                out.append(b)\n            else:\n                out.append(b)\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _corner_round(self, pts, passes, max_trim):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            if len(cur) < 3:\n                break\n            out = [cur[0]]\n            for i in range(1, len(cur) - 1):\n                a = out[-1]\n                b = cur[i]\n                c = cur[i + 1]\n                ab = self._dist(a, b)\n                bc = self._dist(b, c)\n                if ab < 1e-9 or bc < 1e-9:\n                    out.append(b)\n                    continue\n                trim = min(0.5 * min(ab, bc), max_trim)\n                if trim <= 1e-9:\n                    out.append(b)\n                    continue\n                p = self._lerp(a, b, max(0.0, (ab - trim) / max(1e-12, ab)))\n                q = self._lerp(b, c, min(1.0, trim / max(1e-12, bc)))\n                if self._edge_free(out[-1], p) and self._edge_free(p, q) and self._edge_free(q, c):\n                    out.append(p)\n                    out.append(q)\n                else:\n                    out.append(b)\n            out.append(cur[-1])\n            cur = self._dedup(out)\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._densify(path, seg_len=max(0.8, 0.6 * self.step))\n        p1 = self._visibility_prune(p0)\n        p2 = self._shortcut(p1, self.smooth_attempts)\n        p3 = self._corner_round(p2, self.corner_round_passes, max_trim=self.step)\n        p4 = self._visibility_prune(p3)\n        return self._dedup(p4)",
        "objective": -12.38165,
        "time_improvement": -21.0,
        "length_improvement": 21.0,
        "smoothness_improvement": 1230.0,
        "node_improvement": 20.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.04927506446838379,
                "num_nodes_avg": 518.0,
                "path_length_avg": 156.93946856375484,
                "smoothness_avg": 0.047012126415704555,
                "success_improvement": 0.0,
                "time_improvement": -99.72632101810129,
                "node_improvement": -30.445731553764787,
                "length_improvement": 13.978990415184779,
                "smoothness_improvement": 635.8418668722705,
                "objective_score": -18.351292721958167
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0726996898651123,
                "num_nodes_avg": 602.0,
                "path_length_avg": 220.781836795357,
                "smoothness_avg": 0.08602880232493275,
                "success_improvement": 0.0,
                "time_improvement": 56.53273537998358,
                "node_improvement": 59.551165759591484,
                "length_improvement": 26.296668024892057,
                "smoothness_improvement": 2113.583047862229,
                "objective_score": 43.30573666824145
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.0602783203125,
                "num_nodes_avg": 548.0,
                "path_length_avg": 117.1624269068174,
                "smoothness_avg": 0.08182669990166686,
                "success_improvement": 0.0,
                "time_improvement": -19.41806591606534,
                "node_improvement": 30.324221233312144,
                "length_improvement": 22.186294723730065,
                "smoothness_improvement": 940.8295829304845,
                "objective_score": 12.190504974070858
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "SAGE-Connect*: Simple Adaptive Grid Explorer with Informed Bidirectional Growth, Gentle Rewiring, and Fast Smoothing. It builds two trees from start and goal using a compact spatial hash, adaptive neighbor radius, LOS-aware stepping, lightweight k-best parenting, capped local rewiring, and a restrained greedy connect. Once a valid bridge is found, the path is shortcut-pruned and elastically smoothed with collision-aware line search for robust, short, and smooth trajectories.",
        "planning_mechanism": "Alternate expanding start/goal trees. Each iteration: draw a target (goal/segment/uniform; switch to informed-ellipse once a path exists), pick nearest via grid, steer with LOS-adaptive step, enforce node and edge collision checks, suppress duplicates, select a low-cost parent from nearby nodes, add the node, and locally rewire a few neighbors if the new route is cheaper (cycle-safe, edge-checked). Attempt a short greedy connect from the other tree; on success, assemble the bidirectional path, then apply shortcutting and visibility pruning followed by elastic midpoint smoothing before returning.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step=6.0,\n        connect_factor=1.9,\n        goal_bias=0.16,\n        line_bias=0.22,\n        informed_bias=0.45,\n        grid_cell_factor=1.6,\n        neighbor_radius_scale=3.0,\n        dupe_ratio=0.4,\n        rewire_cap=12,\n        connect_steps=12,\n        shortcut_attempts=90,\n        smooth_passes=6\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.connect_step = float(step * connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_radius_scale = float(neighbor_radius_scale)\n        self.dupe_ratio = float(dupe_ratio)\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(1, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 123456789\n        self._eindex = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._eindex = {}\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            self._edges_add(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Trees and grids\n        Ta, Tb = [], []\n        Ga, Gb = {}, {}\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta.append(start_root)\n        Tb.append(goal_root)\n        nodes.extend([start_root, goal_root])\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            # Sample a common target for both directions for coherence\n            sample = self._sample_target(best_len)\n            if sample is None:\n                continue\n\n            # Expand from start side\n            res = self._expand_and_maybe_connect(Ta, Ga, Tb, Gb, sample, nodes, edges)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n            # Expand from goal side\n            res = self._expand_and_maybe_connect(Tb, Gb, Ta, Ga, sample, nodes, edges)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # Core expansion and connection\n    def _expand_and_maybe_connect(self, Ta, Ga, Tb, Gb, target, nodes, edges):\n        na = self._nearest(Ga, target)\n        if na is None:\n            return None\n        q_new = self._steer_dynamic(na.position, target)\n        if (not self._in_bounds(q_new)) or self._point_blocked(q_new):\n            return None\n        if self._too_close(Ga, q_new, self.dupe_radius):\n            return None\n\n        parent = self._select_parent(Ga, q_new, na)\n        if parent is None:\n            return None\n        # Both checks before adding node/edge\n        if self._point_blocked(q_new) or (not self._edge_free(parent.position, q_new)):\n            return None\n\n        cost = parent.cost + self._dist(parent.position, q_new)\n        nn = Node(q_new, parent, cost)\n        parent.add_child(nn)\n        Ta.append(nn)\n        nodes.append(nn)\n        self._grid_add(Ga, nn)\n        self._edges_add(edges, parent, nn)\n\n        # Gentle local rewiring\n        if self.rewire_cap > 0:\n            self._rewire_neighbors(Ga, nn, edges, self.rewire_cap)\n\n        # Try greedy connect from the opposite tree\n        meet, ok = self._greedy_connect(Tb, Gb, nn.position, nodes, edges)\n        if ok:\n            pa = nn.path_to_root()\n            pb = meet.path_to_root()\n            # Determine which root belongs to which\n            if Ta[0].position == self.start:\n                # pa: start->..., pb: goal->...\n                path = pa + pb[-2::-1]\n            else:\n                # pa: goal->..., pb: start->...\n                path = pb + pa[-2::-1]\n            L = self._path_len(path)\n            return (self._dedup(path), L)\n        return None\n\n    # RNG\n    def _seed_rng(self):\n        s = 2166136261\n        for v in self.start + self.goal:\n            s ^= int(v * 10007 + 0.5) & 0xffffffff\n            s = (s * 16777619) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Sampling\n    def _sample_target(self, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._sample_informed_ellipse(self.start, self.goal, best_len * 1.01)\n            if p is not None and self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return self.goal\n        if r2 < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t,\n                     self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t)\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_informed_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and (not self._point_blocked(p)):\n                return p\n        return None\n\n    # Geometry helpers\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(self._lerp(a, b, r))\n\n    def _steer_dynamic(self, a, b):\n        if self._edge_free(a, b):\n            d = self._dist(a, b)\n            step = self.connect_step if d > self.connect_step else d\n            return self._steer(a, b, step)\n        return self._steer(a, b, self.step)\n\n    # Node grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n            if best is not None:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        seen = {}\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            i2 = id(n)\n                            if i2 in seen:\n                                continue\n                            seen[i2] = True\n                            d2 = 0.0\n                            p = n.position\n                            for i in range(self.dim):\n                                di = p[i] - pos[i]\n                                d2 += di * di\n                            if d2 <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        i2 = id(n)\n                        if i2 in seen:\n                            continue\n                        seen[i2] = True\n                        d2 = 0.0\n                        p = n.position\n                        for i in range(self.dim):\n                            di = p[i] - pos[i]\n                            d2 += di * di\n                        if d2 <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _adaptive_radius(self, n_nodes):\n        t = float(max(1, n_nodes))\n        base = 1.2 * self.step\n        extra = self.neighbor_radius_scale * self.step / ((1.0 + t) ** (1.0 / 3.0))\n        r = base + extra\n        if r < 1.05 * self.step:\n            r = 1.05 * self.step\n        return r\n\n    def _too_close(self, grid, pos, radius):\n        nb = self._neighbors_within(grid, pos, radius, 1)\n        return len(nb) > 0\n\n    # Parent selection\n    def _select_parent(self, grid, newp, fallback_near):\n        r = self._adaptive_radius(len(grid))\n        neigh = self._neighbors_within(grid, newp, r, 96)\n        best = fallback_near\n        best_cost = fallback_near.cost + self._dist(fallback_near.position, newp)\n        for n in neigh:\n            if n is fallback_near:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = c\n        return best\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _rewire_neighbors(self, grid, node, edges, cap):\n        r = self._adaptive_radius(len(grid))\n        neigh = self._neighbors_within(grid, node.position, r, 128)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            if self._point_blocked(nb.position) or self._point_blocked(node.position):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            newc = node.cost + self._dist(node.position, nb.position)\n            if newc + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= cap:\n                    break\n\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        if self._point_blocked(child.position) or self._point_blocked(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._edges_remove(edges, old, child)\n        new_parent.add_child(child)\n        self._edges_add(edges, new_parent, child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            for c in n.children:\n                stack.append(c)\n\n    # Greedy connect\n    def _greedy_connect(self, T, G, target_pos, nodes, edges):\n        cur = self._nearest(G, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < self.connect_steps:\n            # Visible? insert exact meeting point\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                    if not self._too_close(G, target_pos, 0.75 * self.dupe_radius):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                            return cur, True\n                        cur.add_child(nn)\n                        T.append(nn)\n                        nodes.append(nn)\n                        self._grid_add(G, nn)\n                        self._edges_add(edges, cur, nn)\n                        return nn, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(G, nxt, 0.75 * self.dupe_radius):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                return cur, False\n            cur.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            self._grid_add(G, nn)\n            self._edges_add(edges, cur, nn)\n            cur = nn\n            steps += 1\n        # Final visibility check\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                if not self._too_close(G, target_pos, 0.75 * self.dupe_radius):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                        return cur, True\n                    cur.add_child(nn)\n                    T.append(nn)\n                    nodes.append(nn)\n                    self._grid_add(G, nn)\n                    self._edges_add(edges, cur, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(3.5, self.step * 1.6)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Edge bookkeeping\n    def _edges_add(self, edges, parent, child):\n        key = (id(parent), id(child))\n        if key in self._eindex:\n            return\n        edges.append((parent, child))\n        self._eindex[key] = len(edges) - 1\n\n    def _edges_remove(self, edges, parent, child):\n        key = (id(parent), id(child))\n        idx = self._eindex.get(key)\n        if idx is None:\n            return\n        last = len(edges) - 1\n        if idx != last:\n            edges[idx] = edges[last]\n            pk, ck = id(edges[idx][0]), id(edges[idx][1])\n            self._eindex[(pk, ck)] = idx\n        edges.pop()\n        self._eindex.pop(key, None)\n\n    # Path utilities and smoothing\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _elastic_smooth(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                target = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                t = 1.0\n                best = b\n                while t > 1e-3:\n                    cand = tuple(b[k] + (target[k] - b[k]) * t for k in range(self.dim))\n                    cand = self._clamp(cand)\n                    if (not self._point_blocked(cand)) and self._edge_free(a, cand) and self._edge_free(cand, c):\n                        best = cand\n                        break\n                    t *= 0.5\n                if best != b:\n                    cur[i] = best\n                    moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._shortcut(path, self.shortcut_attempts)\n        p2 = self._visibility_prune(p1)\n        p3 = self._elastic_smooth(p2, self.smooth_passes)\n        return self._dedup(p3)",
        "objective": -47.53913,
        "time_improvement": 86.0,
        "length_improvement": 21.0,
        "smoothness_improvement": 1812.0,
        "node_improvement": 93.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.004579019546508789,
                "num_nodes_avg": 30.0,
                "path_length_avg": 146.96078572191126,
                "smoothness_avg": 0.03859037591406768,
                "success_improvement": 0.0,
                "time_improvement": 81.43988774523116,
                "node_improvement": 92.44522790229162,
                "length_improvement": 19.448464603147585,
                "smoothness_improvement": 504.0231833977275,
                "objective_score": 38.621161002446534
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.023305273056030272,
                "num_nodes_avg": 122.0,
                "path_length_avg": 229.66193713526982,
                "smoothness_avg": 0.11885248032537557,
                "success_improvement": 0.0,
                "time_improvement": 86.065738755588,
                "node_improvement": 91.80272794463482,
                "length_improvement": 23.332234931912975,
                "smoothness_improvement": 2958.1599247532718,
                "objective_score": 54.609862209590545
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.004154682159423828,
                "num_nodes_avg": 32.0,
                "path_length_avg": 120.49632735979439,
                "smoothness_avg": 0.1630888303105967,
                "success_improvement": 0.0,
                "time_improvement": 91.76911192279043,
                "node_improvement": 95.93134138588684,
                "length_improvement": 19.972076786142434,
                "smoothness_improvement": 1974.4778835855395,
                "objective_score": 49.38636906645029
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "QUIC-Star: Quantized-Edge Informed Connect RRT* \u2014 a bidirectional planner that couples beam-guided sampling, quantized free/blocked edge caching, grid-accelerated nearest/near queries, per-cell cost gating, choose-parent with local rewiring (both trees), and opportunistic LOS grandparent compression. It attempts multi-step connects, updates best path early, and outputs a visibility-pruned, shortcut-smoothed path.",
        "planning_mechanism": "Alternate expanding start/goal trees. For each iteration, draw a small beam of samples biased to goal/line and, once a candidate path exists, to the informed prolate ellipsoid. For the best-scoring beam candidate, find nearest, steer, validate both node and edge, choose the cheapest parent among radius neighbors, insert under per-cell cost gates, optionally compress to grandparent via LOS, and locally rewire neighbors if cheaper. From the opposite tree, perform a short connect-extend toward the new node; if a clear bridge exists, extract, prune, and shortcut the path and return. Collision checks use a quantized edge cache to avoid redundant tests; neighbor queries use grid rings for sublinear performance.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 beam_k=3,\n                 goal_bias=0.22,\n                 line_bias=0.28,\n                 informed_tries=80,\n                 grid_cell_factor=1.4,\n                 max_per_cell=6,\n                 duplicate_radius_factor=0.45,\n                 neighbor_radius_factor=3.0,\n                 rewire_k=12,\n                 rewire_depth=6,\n                 connect_steps=7,\n                 smoothing_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.informed_tries = informed_tries\n        self.grid_cell_factor = grid_cell_factor\n        self.max_per_cell = max_per_cell\n        self.duplicate_radius_factor = duplicate_radius_factor\n        self.neighbor_radius_factor = neighbor_radius_factor\n        self.rewire_k = rewire_k\n        self.rewire_depth = rewire_depth\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        self.edge_res = max(0.5, min(1.0, 0.5 * self.step_size))\n        self.cache_bin = max(1.0, self.edge_res)\n        self.cell_size = max(1.0, self.grid_cell_factor * self.step_size)\n        self.min_sep = max(0.3, self.duplicate_radius_factor * self.step_size)\n\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n        # Early direct LOS\n        if not self._edge_blocked_cached(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            return PlannerResult(True, [start, goal], [s, g], [(s, g)])\n\n        s_root = Node(start, None, 0.0)\n        g_root = Node(goal, None, 0.0)\n\n        start_tree = [s_root]\n        goal_tree = [g_root]\n        nodes_out = [s_root, g_root]\n        edges_out = []\n\n        grid_s = {}\n        grid_g = {}\n        counts_s = {}\n        counts_g = {}\n        bestcost_s = {}\n        bestcost_g = {}\n\n        self._grid_add(grid_s, counts_s, bestcost_s, s_root)\n        self._grid_add(grid_g, counts_g, bestcost_g, g_root)\n\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_s if active_start else grid_g\n            grid_b = grid_g if active_start else grid_s\n            counts_a = counts_s if active_start else counts_g\n            counts_b = counts_g if active_start else counts_s\n            bestcost_a = bestcost_s if active_start else bestcost_g\n            bestcost_b = bestcost_g if active_start else bestcost_s\n            attractor = goal if active_start else start\n\n            # Beam: pick candidate that minimizes estimated total length\n            cand_parent = None\n            cand_pos = None\n            cand_cost = None\n            cand_score = float('inf')\n\n            for _ in range(self.beam_k):\n                x_rand = self._sample(obstacles, is_3d, start, goal, best_len, attractor)\n                n_near = self._nearest(grid_a, tree_a, x_rand)\n                if n_near is None:\n                    continue\n                x_new = self._steer(n_near.position, x_rand)\n                if not self._in_bounds(x_new):\n                    continue\n                if self._is_in_obstacle(x_new, obstacles, is_3d):\n                    continue\n                if self._near_duplicate(grid_a, x_new, self.min_sep):\n                    continue\n                if self._edge_blocked_cached(n_near.position, x_new, obstacles, is_3d):\n                    continue\n\n                # Choose parent among neighbors\n                r_near = max(self.neighbor_radius_factor * self.step_size, self.step_size)\n                neigh = self._near(grid_a, x_new, r_near)\n                parent, new_cost = self._choose_parent(neigh, n_near, x_new, obstacles, is_3d)\n\n                # Per-cell gating\n                key_new = self._grid_key(x_new)\n                ccount = counts_a.get(key_new, 0)\n                bestc = bestcost_a.get(key_new, float('inf'))\n                if ccount >= self.max_per_cell and not (new_cost + 1e-12 < bestc):\n                    continue\n\n                # Heuristic score: cost-to-come + estimate to goal via opposite tree\n                near_b = self._nearest(grid_b, tree_b, x_new)\n                h = self._dist(x_new, near_b.position) if near_b is not None else self._dist(x_new, attractor)\n                score = new_cost + h\n                if score < cand_score:\n                    cand_score = score\n                    cand_parent = parent\n                    cand_pos = x_new\n                    cand_cost = new_cost\n\n            if cand_parent is None:\n                continue\n\n            # Final validations before adding node (both checks)\n            if not self._in_bounds(cand_pos):\n                continue\n            if self._is_in_obstacle(cand_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked_cached(cand_parent.position, cand_pos, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_node = Node(cand_pos, None, cand_cost)\n            new_node.attach(cand_parent)\n            tree_a.append(new_node)\n            nodes_out.append(new_node)\n            edges_out.append((cand_parent, new_node))\n            self._grid_add(grid_a, counts_a, bestcost_a, new_node)\n\n            # Opportunistic LOS grandparent compression (only if strictly cheaper)\n            gp = cand_parent.parent\n            if gp is not None:\n                if (not self._is_in_obstacle(gp.position, obstacles, is_3d)) and (not self._edge_blocked_cached(gp.position, new_node.position, obstacles, is_3d)):\n                    comp_cost = gp.cost + self._dist(gp.position, new_node.position)\n                    if comp_cost + 1e-12 < new_node.cost:\n                        old_parent = new_node.parent\n                        new_node.attach(gp)\n                        new_node.cost = comp_cost\n                        # Maintain edges list coherently\n                        self._remove_edge(edges_out, old_parent, new_node)\n                        edges_out.append((gp, new_node))\n                        # Update cell bestcost (monotonic decrease)\n                        key_new = self._grid_key(new_node.position)\n                        prev = bestcost_a.get(key_new, float('inf'))\n                        if new_node.cost + 1e-12 < prev:\n                            bestcost_a[key_new] = new_node.cost\n\n            # Local rewiring around new node\n            r_near = max(self.neighbor_radius_factor * self.step_size, self.step_size)\n            neigh = self._near(grid_a, new_node.position, r_near)\n            self._rewire(new_node, neigh, obstacles, is_3d, edges_out, bestcost_a)\n\n            # Try to connect from the opposite tree toward the new node\n            meet_b, bridged = self._connect_toward(tree_b, grid_b, counts_b, bestcost_b, new_node.position, obstacles, is_3d)\n            if meet_b is None:\n                # fallback: nearest bridge\n                meet_b = self._nearest(grid_b, tree_b, new_node.position)\n                if meet_b is not None and not self._edge_blocked_cached(meet_b.position, new_node.position, obstacles, is_3d):\n                    bridged = True\n\n            if bridged and meet_b is not None:\n                # Validate both endpoints and edge (both checks)\n                if self._is_in_obstacle(meet_b.position, obstacles, is_3d):\n                    continue\n                if self._is_in_obstacle(new_node.position, obstacles, is_3d):\n                    continue\n                if self._edge_blocked_cached(meet_b.position, new_node.position, obstacles, is_3d):\n                    continue\n                edges_out.append((meet_b, new_node) if active_start else (new_node, meet_b))\n                a = new_node if active_start else meet_b\n                b = meet_b if active_start else new_node\n                path = self._extract_path(a, b)\n                # Prune and smooth\n                path = self._visibility_prune(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges_out)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges_out)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _uniform_point(self):\n        if self.dim == 3:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]),\n                    self._uniform(0.0, self.bounds[2]))\n        else:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]))\n\n    # Geometry / distance\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-12:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_blocked_cached(self, a, b, obstacles, is_3d):\n        k = self._edge_key_q(a, b)\n        cached = self._edge_cache.get(k, None)\n        if cached is not None:\n            return cached\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    # Grid and neighbors\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._grid_key(node.position)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n        counts[k] = counts.get(k, 0) + 1\n        prev = bestcost.get(k, None)\n        if prev is None or node.cost + 1e-12 < prev:\n            bestcost[k] = node.cost\n\n    def _grid_collect_ring(self, grid, key, r):\n        cand = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        return cand\n\n    def _nearest(self, grid, nodes, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        cand_total = []\n        r = 0\n        max_r = 4\n        while r <= max_r and len(cand_total) < 16:\n            cand_total.extend(self._grid_collect_ring(grid, key, r))\n            r += 1\n        if cand_total:\n            for n in cand_total:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            return best\n        # Sparse fallback: random probes\n        if nodes:\n            trials = min(64, len(nodes))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(nodes)))\n                n = nodes[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _near(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        rng = int(max(1, radius // self.cell_size)) + 1\n        cand = []\n        if self.dim == 3:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                out.append(n)\n        return out\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        cand = self._grid_collect_ring(grid, key, 1)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # Parent selection and rewiring\n    def _choose_parent(self, neighbors, fallback_near, new_pos, obstacles, is_3d):\n        best_parent = fallback_near\n        best_cost = fallback_near.cost + self._dist(fallback_near.position, new_pos)\n        for n in neighbors:\n            if n is fallback_near:\n                continue\n            if self._is_in_obstacle(n.position, obstacles, is_3d):\n                continue\n            if self._edge_blocked_cached(n.position, new_pos, obstacles, is_3d):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-12 < best_cost:\n                best_cost = c\n                best_parent = n\n        return best_parent, best_cost\n\n    def _can_rewire(self, node, new_parent):\n        cur = new_parent\n        while cur is not None:\n            if cur is node:\n                return False\n            cur = cur.parent\n        return True\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                edges.pop(i)\n                break\n\n    def _propagate_cost(self, node, depth, bestcost):\n        if depth <= 0:\n            return\n        for ch in node.children:\n            old = ch.cost\n            ch.cost = node.cost + self._dist(node.position, ch.position)\n            if ch.cost + 1e-12 < old or abs(ch.cost - old) > 1e-12:\n                # Update cell bestcost (costs may decrease)\n                key = self._grid_key(ch.position)\n                prev = bestcost.get(key, float('inf'))\n                if ch.cost + 1e-12 < prev:\n                    bestcost[key] = ch.cost\n                self._propagate_cost(ch, depth - 1, bestcost)\n\n    def _rewire(self, new_node, neighbors, obstacles, is_3d, edges, bestcost):\n        if not neighbors:\n            return\n        cand = []\n        for n in neighbors:\n            if n is new_node or n is new_node.parent:\n                continue\n            cand.append((self._dist(n.position, new_node.position), n))\n        cand.sort(key=lambda t: t[0])\n        limit = min(self.rewire_k, len(cand))\n        for i in range(limit):\n            n = cand[i][1]\n            if self._is_in_obstacle(n.position, obstacles, is_3d):\n                continue\n            if not self._can_rewire(n, new_node):\n                continue\n            if self._edge_blocked_cached(new_node.position, n.position, obstacles, is_3d):\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, n.position)\n            if new_cost + 1e-12 < n.cost:\n                old_parent = n.parent\n                n.attach(new_node)\n                n.cost = new_cost\n                if old_parent is not None:\n                    self._remove_edge(edges, old_parent, n)\n                edges.append((new_node, n))\n                # Update cell bestcost (monotonic decrease)\n                key = self._grid_key(n.position)\n                prev = bestcost.get(key, float('inf'))\n                if new_cost + 1e-12 < prev:\n                    bestcost[key] = new_cost\n                self._propagate_cost(n, self.rewire_depth, bestcost)\n\n    # Connect/extend\n    def _extend_toward(self, tree, grid, counts, bestcost, target_pos, obstacles, is_3d):\n        current = self._nearest(grid, tree, target_pos)\n        last = current\n        for _ in range(self.connect_steps):\n            nxt = self._steer(current.position, target_pos)\n            if not self._in_bounds(nxt):\n                break\n            if self._is_in_obstacle(nxt, obstacles, is_3d):\n                break\n            if self._near_duplicate(grid, nxt, self.min_sep):\n                break\n            if self._edge_blocked_cached(current.position, nxt, obstacles, is_3d):\n                break\n\n            # choose parent among neighbors for connect step\n            r_near = max(self.neighbor_radius_factor * self.step_size, self.step_size)\n            neigh = self._near(grid, nxt, r_near)\n            parent, new_cost = self._choose_parent(neigh, current, nxt, obstacles, is_3d)\n\n            # per-cell gating\n            key_new = self._grid_key(nxt)\n            ccount = counts.get(key_new, 0)\n            bestc = bestcost.get(key_new, float('inf'))\n            if ccount >= self.max_per_cell and not (new_cost + 1e-12 < bestc):\n                break\n\n            # Final checks before adding the node/edge\n            if self._is_in_obstacle(parent.position, obstacles, is_3d):\n                break\n            if self._edge_blocked_cached(parent.position, nxt, obstacles, is_3d):\n                break\n\n            newn = Node(nxt, None, new_cost)\n            newn.attach(parent)\n            tree.append(newn)\n            self._grid_add(grid, counts, bestcost, newn)\n            last = newn\n            current = newn\n            if self._dist(nxt, target_pos) <= self.step_size:\n                break\n        return last\n\n    def _connect_toward(self, tree_b, grid_b, counts_b, bestcost_b, a_pos, obstacles, is_3d):\n        if not tree_b:\n            return None, False\n        last = self._extend_toward(tree_b, grid_b, counts_b, bestcost_b, a_pos, obstacles, is_3d)\n        if last is None:\n            return None, False\n        if not self._edge_blocked_cached(last.position, a_pos, obstacles, is_3d):\n            return last, True\n        return last, False\n\n    # Paths and smoothing\n    def _path_to_root(self, node):\n        seq = []\n        cur = node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _extract_path(self, meet_a, meet_b):\n        pa = self._path_to_root(meet_a)\n        pb = []\n        cur = meet_b\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        return pa + pb\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        n = len(path)\n        i = 0\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked_cached(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked_cached(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        # Final forward collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            anchor = pts[0]\n            for k in range(1, len(pts) - 1):\n                if self._edge_blocked_cached(anchor, pts[k + 1], obstacles, is_3d):\n                    collapsed.append(pts[k])\n                    anchor = pts[k]\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts\n\n    # Sampling\n    def _sample(self, obstacles, is_3d, start, goal, best_len, attractor):\n        r = self._rand()\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Informed prolate ellipsoid sampling if a path exists\n        if best_len < float('inf'):\n            for _ in range(self.informed_tries):\n                # rejection in bounding box\n                p = self._uniform_point()\n                if self._dist(p, start) + self._dist(p, goal) <= best_len and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n        # Line bias with jitter around start-goal segment\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jit = 0.6 * self.step_size\n            if self.dim == 3:\n                p = (min(max(base[0] + self._uniform(-jit, jit), 0.0), self.bounds[0]),\n                     min(max(base[1] + self._uniform(-jit, jit), 0.0), self.bounds[1]),\n                     min(max(base[2] + self._uniform(-jit, jit), 0.0), self.bounds[2]))\n            else:\n                p = (min(max(base[0] + self._uniform(-jit, jit), 0.0), self.bounds[0]),\n                     min(max(base[1] + self._uniform(-jit, jit), 0.0), self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Uniform fallback\n        while True:\n            p = self._uniform_point()\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p",
        "objective": -12.45599,
        "time_improvement": -19.0,
        "length_improvement": 21.0,
        "smoothness_improvement": 1172.0,
        "node_improvement": 85.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.024823760986328124,
                "num_nodes_avg": 45.0,
                "path_length_avg": 152.2569450236729,
                "smoothness_avg": 0.03434339152796622,
                "success_improvement": 0.0,
                "time_improvement": 9.99968017066785,
                "node_improvement": 88.66784185343742,
                "length_improvement": 16.54555576683742,
                "smoothness_improvement": 437.5486552810345,
                "objective_score": 15.114980787707978
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.06445107460021973,
                "num_nodes_avg": 125.0,
                "path_length_avg": 223.22379543278936,
                "smoothness_avg": 0.0863747761396638,
                "success_improvement": 0.0,
                "time_improvement": 61.05179744376999,
                "node_improvement": 91.6011556809783,
                "length_improvement": 25.481471943834975,
                "smoothness_improvement": 2122.485203310125,
                "objective_score": 44.21684841598261
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.1185152530670166,
                "num_nodes_avg": 197.0,
                "path_length_avg": 120.97733672593594,
                "smoothness_avg": 0.08291606758357457,
                "success_improvement": 0.0,
                "time_improvement": -128.42956369493342,
                "node_improvement": 74.95232040686585,
                "length_improvement": 19.65261326835586,
                "smoothness_improvement": 954.6862594355925,
                "objective_score": -21.963869850288546
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "L-IRRT* Dual: Length-focused Informed Bidirectional RRT* with Exact-Join, Ancestor Shortcuts, and Tight Visibility Pruning. It grows two trees with proper RRT*-style neighbor radii based on node counts (not grid cells), selects the true best-cost parent from a sorted candidate set, performs cycle-safe rewiring, applies immediate ancestor line-of-sight shortcuts to collapse detours, and only bridges trees with an exact meeting node to preserve a verified straight join. The best path is finalized by deterministic visibility funneling, randomized chord shortcutting, and elastic moves that only reduce local length.",
        "planning_mechanism": "Alternate expanding start/goal trees. Each expansion: sample (goal/line/uniform; switch to informed ellipse once a solution exists), find nearest via a compact grid, steer with LOS-adaptive step, enforce both node and edge collision checks, reject near-duplicates, pick the lowest cost parent among neighbors within a radius driven by the tree\u2019s node count, add the node, rewire cheaper neighbors, then try to connect to the opposite tree. A direct visible bridge inserts the exact meeting node into the opposite tree; otherwise a short greedy approach is attempted. Upon a successful bridge, assemble start\u2192meet\u2192goal using the exact join. Before returning, run visibility funneling, targeted random shortcutting, an elastic band that only accepts length reductions, and a final visibility pass.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step=6.0,\n        connect_factor=2.0,\n        goal_bias=0.2,\n        line_bias=0.3,\n        informed_bias=0.6,\n        grid_cell_factor=1.5,\n        dupe_ratio=0.35,\n        neighbor_cap=128,\n        rewire_cap=64,\n        connect_steps=8,\n        shortcut_attempts=140,\n        smooth_passes=4\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.connect_step = float(step * connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dupe_ratio = float(dupe_ratio)\n        self.neighbor_cap = int(max(8, neighbor_cap))\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(1, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 123456789\n        self._eindex = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._eindex = {}\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            self._edges_add(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        Ta, Tb = [], []\n        Ga, Gb = {}, {}\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta.append(start_root)\n        Tb.append(goal_root)\n        nodes.extend([start_root, goal_root])\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n\n        best_len = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            # Sample once per pair of expansions to keep both trees coherent\n            sample = self._sample_target(best_len)\n\n            res = self._expand_and_maybe_connect(Ta, Ga, Tb, Gb, sample, nodes, edges, best_len)\n            if res is not None:\n                path, L = res\n                if L < best_len:\n                    best_len = L\n                    best_path = path\n                    final = self._finalize_path(best_path)\n                    return PlannerResult(True, final, nodes, edges)\n\n            res = self._expand_and_maybe_connect(Tb, Gb, Ta, Ga, sample, nodes, edges, best_len)\n            if res is not None:\n                path, L = res\n                if L < best_len:\n                    best_len = L\n                    best_path = path\n                    final = self._finalize_path(best_path)\n                    return PlannerResult(True, final, nodes, edges)\n\n        if best_path is not None:\n            final = self._finalize_path(best_path)\n            return PlannerResult(True, final, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    def _expand_and_maybe_connect(self, Ta, Ga, Tb, Gb, target, nodes, edges, best_len):\n        na = self._nearest(Ga, target)\n        if na is None:\n            return None\n        q_new = self._steer_dynamic(na.position, target)\n        if (not self._in_bounds(q_new)) or self._point_blocked(q_new):\n            return None\n        if self._too_close(Ga, q_new, self.dupe_radius):\n            return None\n\n        parent = self._choose_parent(Ta, Ga, q_new, na, best_len)\n        if parent is None:\n            return None\n        if self._point_blocked(q_new) or (not self._edge_free(parent.position, q_new)):\n            return None\n\n        new_cost = parent.cost + self._dist(parent.position, q_new)\n        # Branch-and-bound against current best\n        if best_len < float('inf'):\n            if new_cost + self._dist(q_new, self._root_of(Tb).position) >= best_len * 1.0001:\n                pass\n\n        nn = Node(q_new, parent, new_cost)\n        parent.add_child(nn)\n        Ta.append(nn)\n        nodes.append(nn)\n        self._grid_add(Ga, nn)\n        self._edges_add(edges, parent, nn)\n\n        # Immediate ancestor shortcut (length-only, LOS-checked)\n        self._ancestor_shortcut(nn, edges)\n\n        # Local rewiring\n        if self.rewire_cap > 0:\n            self._rewire_neighbors(Ta, Ga, nn, edges, best_len)\n\n        # Attempt exact direct connect first\n        meet, ok = self._try_direct_bridge(Tb, Gb, nn.position, nodes, edges)\n        if ok:\n            pa = nn.path_to_root()\n            pb = meet.path_to_root()\n            path = self._assemble_path(Ta, pa, pb)\n            return (self._dedup(path), self._path_len(path))\n\n        # Short greedy connect if direct bridge fails\n        meet, ok = self._greedy_connect(Tb, Gb, nn.position, nodes, edges)\n        if ok:\n            pa = nn.path_to_root()\n            pb = meet.path_to_root()\n            path = self._assemble_path(Ta, pa, pb)\n            return (self._dedup(path), self._path_len(path))\n\n        return None\n\n    def _assemble_path(self, Ta, pa, pb):\n        # pa: rootA -> ... -> meet\n        # pb: rootB -> ... -> meet\n        if Ta and Ta[0].position == self.start:\n            # pa: start->meet, pb: goal->meet\n            return pa + pb[::-1][1:]\n        else:\n            # pa: goal->meet, pb: start->meet\n            q = pb + pa[::-1][1:]\n            # Ensure orientation start->goal\n            if q and q[0] != self.start:\n                q = q[::-1]\n            return q\n\n    # RNG\n    def _seed_rng(self):\n        s = 2166136261\n        for v in self.start + self.goal:\n            s ^= int(v * 10007 + 0.5) & 0xffffffff\n            s = (s * 16777619) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Sampling\n    def _sample_target(self, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._sample_informed_ellipse(self.start, self.goal, best_len * 1.0)\n            if p is not None:\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return self.goal\n        if r2 < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t,\n                     self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t)\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_informed_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(32):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and (not self._point_blocked(p)):\n                return p\n        return None\n\n    # Geometry helpers\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(self._lerp(a, b, r))\n\n    def _steer_dynamic(self, a, b):\n        if self._edge_free(a, b):\n            d = self._dist(a, b)\n            step = self.connect_step if d > self.connect_step else d\n            return self._steer(a, b, step)\n        return self._steer(a, b, self.step)\n\n    def _root_of(self, T):\n        return T[0] if T else None\n\n    # Node grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n            if best is not None:\n                return best\n        for lst in grid.values():\n            for n in lst:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        seen = {}\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            i2 = id(n)\n                            if i2 in seen:\n                                continue\n                            seen[i2] = True\n                            p = n.position\n                            d2 = 0.0\n                            for i in range(self.dim):\n                                di = p[i] - pos[i]\n                                d2 += di * di\n                            if d2 <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        i2 = id(n)\n                        if i2 in seen:\n                            continue\n                        seen[i2] = True\n                        p = n.position\n                        d2 = 0.0\n                        for i in range(self.dim):\n                            di = p[i] - pos[i]\n                            d2 += di * di\n                        if d2 <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _rrtstar_radius(self, n_nodes):\n        # Monotone shrinking radius based on node count (no log to avoid imports).\n        # Encourages short, high-quality connections and rewiring.\n        if n_nodes <= 1:\n            return self.step * 3.0\n        scale = self.step * 6.0\n        r = (scale / (float(n_nodes) ** (1.0 / max(2.0, float(self.dim))))) + 1.25 * self.step\n        if r < 1.05 * self.step:\n            r = 1.05 * self.step\n        return r\n\n    def _too_close(self, grid, pos, radius):\n        nb = self._neighbors_within(grid, pos, radius, 1)\n        return len(nb) > 0\n\n    # Parent selection with length-aware ordering\n    def _choose_parent(self, T, G, newp, fallback_near, best_len):\n        r = self._rrtstar_radius(len(T))\n        neigh = self._neighbors_within(G, newp, r, self.neighbor_cap)\n        # Order by tentative cost-to-come for fewer expensive checks\n        scored = []\n        base_best = fallback_near.cost + self._dist(fallback_near.position, newp)\n        for n in neigh:\n            c = n.cost + self._dist(n.position, newp)\n            scored.append((c, n))\n        scored.sort(key=lambda x: x[0])\n        best_parent = None\n        best_cost = 1e100\n        # Try neighbors first\n        for c, n in scored:\n            if c >= best_cost:\n                break\n            if self._edge_free(n.position, newp):\n                best_parent = n\n                best_cost = c\n                # continue to see if even cheaper exists\n        # Fallback to nearest if no neighbor valid\n        if best_parent is None:\n            if self._edge_free(fallback_near.position, newp):\n                best_parent = fallback_near\n                best_cost = base_best\n            else:\n                return None\n        # Branch-and-bound with best known path\n        if best_len < float('inf'):\n            if best_cost + self._dist(newp, self._root_of(T).position) >= best_len * 1.0001:\n                pass\n        return best_parent\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        if self._point_blocked(child.position) or self._point_blocked(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._edges_remove(edges, old, child)\n        new_parent.add_child(child)\n        self._edges_add(edges, new_parent, child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            for c in n.children:\n                stack.append(c)\n\n    def _ancestor_shortcut(self, node, edges):\n        # Try to attach to a visible ancestor that reduces cost\n        cur = node.parent.parent if node.parent else None\n        tries = 0\n        while cur is not None and tries < 8:\n            cand_cost = cur.cost + self._dist(cur.position, node.position)\n            if cand_cost + 1e-12 < node.cost:\n                if self._edge_free(cur.position, node.position):\n                    self._reparent(node, cur, edges)\n                    break\n            cur = cur.parent\n            tries += 1\n\n    def _rewire_neighbors(self, T, G, node, edges, best_len):\n        r = self._rrtstar_radius(len(T))\n        neigh = self._neighbors_within(G, node.position, r, self.neighbor_cap)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            if self._point_blocked(nb.position) or self._point_blocked(node.position):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            newc = node.cost + self._dist(node.position, nb.position)\n            # Bound by best path if any\n            if best_len < float('inf'):\n                if newc + self._dist(nb.position, self._root_of(T).position) >= best_len * 1.0001:\n                    continue\n            if newc + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= self.rewire_cap:\n                    break\n\n    # Bridge attempts\n    def _try_direct_bridge(self, T, G, target_pos, nodes, edges):\n        m = self._nearest(G, target_pos)\n        if m is None:\n            return None, False\n        if self._edge_free(m.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                if not self._too_close(G, target_pos, 0.6 * self.dupe_radius):\n                    new_cost = m.cost + self._dist(m.position, target_pos)\n                    nn = Node(target_pos, m, new_cost)\n                    if self._point_blocked(nn.position) or (not self._edge_free(m.position, nn.position)):\n                        return m, True\n                    m.add_child(nn)\n                    T.append(nn)\n                    nodes.append(nn)\n                    self._grid_add(G, nn)\n                    self._edges_add(edges, m, nn)\n                    return nn, True\n            return m, True\n        return m, False\n\n    def _greedy_connect(self, T, G, target_pos, nodes, edges):\n        cur = self._nearest(G, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < self.connect_steps:\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                    if not self._too_close(G, target_pos, 0.6 * self.dupe_radius):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                            return cur, True\n                        cur.add_child(nn)\n                        T.append(nn)\n                        nodes.append(nn)\n                        self._grid_add(G, nn)\n                        self._edges_add(edges, cur, nn)\n                        return nn, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(G, nxt, 0.6 * self.dupe_radius):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                return cur, False\n            cur.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            self._grid_add(G, nn)\n            self._edges_add(edges, cur, nn)\n            cur = nn\n            steps += 1\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                if not self._too_close(G, target_pos, 0.6 * self.dupe_radius):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                        return cur, True\n                    cur.add_child(nn)\n                    T.append(nn)\n                    nodes.append(nn)\n                    self._grid_add(G, nn)\n                    self._edges_add(edges, cur, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(3.5, self.step * 1.6)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Edge bookkeeping\n    def _edges_add(self, edges, parent, child):\n        key = (id(parent), id(child))\n        if key in self._eindex:\n            return\n        edges.append((parent, child))\n        self._eindex[key] = len(edges) - 1\n\n    def _edges_remove(self, edges, parent, child):\n        key = (id(parent), id(child))\n        idx = self._eindex.get(key)\n        if idx is None:\n            return\n        last = len(edges) - 1\n        if idx != last:\n            edges[idx] = edges[last]\n            pk, ck = id(edges[idx][0]), id(edges[idx][1])\n            self._eindex[(pk, ck)] = idx\n        edges.pop()\n        self._eindex.pop(key, None)\n\n    # Path utilities and length-focused smoothing\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_funnel(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            found = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    found = True\n                    break\n                j -= 1\n            if not found:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut_random(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _elastic_length_only(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            improved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                target = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                t = 1.0\n                best = b\n                best_gain = 0.0\n                base_len = self._dist(a, b) + self._dist(b, c)\n                while t > 1e-3:\n                    cand = tuple(b[k] + (target[k] - b[k]) * t for k in range(self.dim))\n                    cand = self._clamp(cand)\n                    if (not self._point_blocked(cand)) and self._edge_free(a, cand) and self._edge_free(cand, c):\n                        new_len = self._dist(a, cand) + self._dist(cand, c)\n                        gain = base_len - new_len\n                        if gain > 1e-6:\n                            best = cand\n                            best_gain = gain\n                            break\n                    t *= 0.5\n                if best != b and best_gain > 0.0:\n                    cur[i] = best\n                    improved = True\n            if not improved:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._visibility_funnel(path)\n        p2 = self._shortcut_random(p1, self.shortcut_attempts)\n        p3 = self._elastic_length_only(p2, self.smooth_passes)\n        p4 = self._visibility_funnel(p3)\n        return self._dedup(p4)",
        "objective": -42.26447,
        "time_improvement": 71.0,
        "length_improvement": 22.0,
        "smoothness_improvement": 1530.0,
        "node_improvement": 92.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.012109470367431641,
                "num_nodes_avg": 41.0,
                "path_length_avg": 144.9927890038839,
                "smoothness_avg": 0.03738562038885029,
                "success_improvement": 0.0,
                "time_improvement": 51.858978125989296,
                "node_improvement": 89.67514479979855,
                "length_improvement": 20.527154789201994,
                "smoothness_improvement": 485.16614325957914,
                "objective_score": 30.29981702761588
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02904365062713623,
                "num_nodes_avg": 116.0,
                "path_length_avg": 224.7502960068727,
                "smoothness_avg": 0.0866795189248766,
                "success_improvement": 0.0,
                "time_improvement": 81.87158905210825,
                "node_improvement": 92.20587247194786,
                "length_improvement": 24.971882114323137,
                "smoothness_improvement": 2130.3264546710066,
                "objective_score": 50.196238257581385
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.009520912170410156,
                "num_nodes_avg": 47.0,
                "path_length_avg": 119.70538546749144,
                "smoothness_avg": 0.1631866982455984,
                "success_improvement": 0.0,
                "time_improvement": 80.40107188079743,
                "node_improvement": 94.0241576605213,
                "length_improvement": 20.497382730404468,
                "smoothness_improvement": 1975.7227564949017,
                "objective_score": 46.297364984956424
            }
        ],
        "success_rate": 1.0
    }
]