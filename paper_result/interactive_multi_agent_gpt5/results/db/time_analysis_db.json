[
    {
        "parents": [
            {
                "operator": "path_expert",
                "algorithm_description": "Informed Dual-Tree RRT* with Commit-Only Connect and Grandparent Line-of-Sight Rewiring (IDT-RRT*++): a bidirectional, asymptotically optimal planner focused on minimizing path length. It uses an r(n) \u221d (log n / n)^(1/d) neighborhood for high-quality parent selection and rewiring, performs zero-bloat \u201ccommit-only\u201d tree connection (adds no nodes on failed connects), prunes expansions with an admissible cost-to-go bound once a path exists, and applies grandparent line-of-sight rewiring to remove zig-zags. Informed rejection sampling inside the prolate hyperspheroid rapidly tightens the incumbent cost, while anytime shortcut smoothing further reduces length during and after planning.",
                "planning_mechanism": "Mechanism: alternate growing start/goal trees with informed sampling; steer, validate node and edge, choose the least-cost parent among r(n) neighbors, apply LOS-to-grandparent improvement and rewire; attempt direct, collision-free joining to the opposite tree without committing nodes unless the join succeeds; upon any improvement, prune by cost-to-go and restrict future samples to the hyperspheroid; periodically perform shortcut attempts on the current best path; terminate on budget or stagnation and return the shortest smoothed path.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=7000,\n                 step_size=5.0,\n                 goal_bias=0.15,\n                 base_radius=30.0,\n                 min_radius=6.0,\n                 collision_step=1.0,\n                 post_opt_iters=1000,\n                 max_no_improve=300,\n                 smoothing_iters=180,\n                 min_separation_ratio=0.35,\n                 per_iter_shortcuts=2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.collision_step = collision_step\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.min_separation_ratio = min_separation_ratio\n        self.per_iter_shortcuts = per_iter_shortcuts\n\n        self.dim = 2\n        self.bounds = None\n\n    # ------------- Core planning -------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Space scale estimates\n        self.space_diam = self._dist(tuple(0.0 for _ in range(self.dim)), tuple(self.bounds[i] for i in range(self.dim)))\n        r_max = max(self.min_radius, self.base_radius)\n        self.grid_cell = max(self.step_size * 1.25, r_max * 0.5)\n        self.min_separation = max(1.0, self.step_size * self.min_separation_ratio)\n        self.edge_res = max(0.5, min(self.collision_step, self.step_size / 4.0))\n\n        # Trees, grids, and edge maps (child -> parent)\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        parent_of = {start_root: None, goal_root: None}\n\n        # Planning state\n        success = False\n        best_cost = float('inf')\n        best_join = (None, None)\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n        incumbent_path = []\n\n        # Alternate expansion\n        for it in range(self.max_iter):\n            for which in (0, 1):\n                active_start = ((it + which) % 2 == 0)\n                tree_a = start_tree if active_start else goal_tree\n                tree_b = goal_tree if active_start else start_tree\n                grid_a = grid_start if active_start else grid_goal\n                grid_b = grid_goal if active_start else grid_start\n                root_other = goal if active_start else start\n\n                # Sample (informed if path known), with occasional bias to the opposite root\n                if self._rand() < self.goal_bias:\n                    x_rand = root_other\n                else:\n                    x_rand = self._sample(start, goal, best_cost, obstacles, is_3d)\n\n                # Nearest and steer\n                x_nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n                x_new_pos = self._steer(x_nearest.position, x_rand, self.step_size)\n                if not self._in_bounds(x_new_pos):\n                    continue\n                if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                    continue\n\n                # Separation: avoid adding nodes too close to existing ones\n                if self._dist(x_nearest.position, x_new_pos) < self.min_separation:\n                    continue\n\n                # Choose best parent among near neighbors with RRT* radius\n                n_nodes = len(tree_a) + 1\n                r_near = self._rrtstar_radius(n_nodes)\n                near_nodes = self._near_grid(grid_a, x_new_pos, r_near)\n                if x_nearest not in near_nodes:\n                    near_nodes.append(x_nearest)\n\n                best_parent = None\n                best_pc = float('inf')\n                for nn in near_nodes:\n                    # Prune by admissible bound once a path exists\n                    if found_first:\n                        # Active tree cost-to-go to opposite root (start-tree -> goal, goal-tree -> start)\n                        if nn.cost + self._dist(nn.position, root_other) >= best_cost - 1e-9:\n                            continue\n                    cand_cost = nn.cost + self._dist(nn.position, x_new_pos)\n                    if cand_cost < best_pc and not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                        best_parent = nn\n                        best_pc = cand_cost\n\n                if best_parent is None:\n                    continue\n\n                # Grandparent line-of-sight (LOS) shortcut: try to reduce zig-zag and path length\n                improved = True\n                gp_parent = best_parent.parent\n                cur_parent = best_parent\n                cur_cost = best_pc\n                while improved and gp_parent is not None:\n                    gp_cost = gp_parent.cost + self._dist(gp_parent.position, x_new_pos)\n                    if gp_cost + 1e-12 < cur_cost and not self._is_edge_in_obstacle(gp_parent.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                        cur_parent = gp_parent\n                        cur_cost = gp_cost\n                        gp_parent = cur_parent.parent\n                    else:\n                        improved = False\n                best_parent = cur_parent\n                best_pc = cur_cost\n\n                # Create and insert node\n                x_new = Node(x_new_pos)\n                x_new.cost = best_pc\n                best_parent.add_child(x_new)\n                tree_a.append(x_new)\n                nodes.append(x_new)\n                parent_of[x_new] = best_parent\n                self._grid_add(grid_a, x_new)\n\n                # Rewire neighbors through x_new\n                for nn in near_nodes:\n                    if nn is best_parent or nn is x_new:\n                        continue\n                    # Prune by admissible bound once a path exists\n                    if found_first:\n                        if x_new.cost + self._dist(x_new.position, root_other) >= best_cost - 1e-9:\n                            continue\n                    alt = x_new.cost + self._dist(x_new.position, nn.position)\n                    if alt + 1e-12 < nn.cost and not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d, self.edge_res):\n                        oldp = parent_of.get(nn, nn.parent)\n                        if oldp is not None:\n                            # Detach from old parent\n                            try:\n                                oldp.children.remove(nn)\n                            except:\n                                pass\n                        x_new.add_child(nn)\n                        nn.cost = alt\n                        parent_of[nn] = x_new\n                        self._propagate_costs_from(nn)\n\n                # Try commit-only direct connection to closest node in the opposite tree\n                nnear_b = self._nearest_grid(grid_b, tree_b, x_new.position)\n                if nnear_b is not None:\n                    if not self._is_edge_in_obstacle(x_new.position, nnear_b.position, obstacles, is_3d, self.edge_res):\n                        path_cost = x_new.cost + self._dist(x_new.position, nnear_b.position) + nnear_b.cost\n                        if path_cost + 1e-12 < best_cost:\n                            best_cost = path_cost\n                            best_join = (x_new, nnear_b)\n                            success = True\n                            found_first = True\n                            post_iters = 0\n                            no_improve = 0\n                            incumbent_path = self._extract_path(best_join[0], best_join[1])\n                        else:\n                            no_improve += 1\n                        post_iters += 1\n                    else:\n                        if found_first:\n                            post_iters += 1\n                            no_improve += 1\n                else:\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n\n                # Anytime shortcut attempts to shave length during planning\n                if found_first and incumbent_path:\n                    for _ in range(self.per_iter_shortcuts):\n                        incumbent_path = self._shortcut_once(incumbent_path, obstacles, is_3d)\n                    new_len = self._path_length(incumbent_path)\n                    if new_len + 1e-12 < best_cost:\n                        best_cost = new_len\n                        no_improve = 0\n                        post_iters = 0\n\n                # Early termination on post-optimization budget or stagnation\n                if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                    break\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        # Final path and smoothing\n        path = []\n        if success and best_join[0] is not None:\n            path = self._extract_path(best_join[0], best_join[1])\n            path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n\n        # Build coherent edges list from parent map\n        edges = []\n        for n, p in list(parent_of.items()):\n            if p is not None:\n                edges.append((p, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ------------- Utilities -------------\n    def _rand(self):\n        try:\n            return random.random()\n        except:\n            if not hasattr(self, \"_lcg_state\"):\n                self._lcg_state = 2463534242\n            self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n            return (self._lcg_state / float(1 << 32))\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = (a[i] - b[i])\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        ratio = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(self.dim)))\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # ------------- Collision checks -------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-6, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ------------- Sampling -------------\n    def _sample(self, start, goal, c_best, obstacles, is_3d):\n        # Informed rejection sampling inside prolate hyperspheroid via distance-sum <= c_best\n        # Avoid obstacles with a few retries; fall back to uniform in-bounds\n        attempts = 0\n        max_attempts = 200\n        while attempts < max_attempts:\n            attempts += 1\n            p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n            if not self._in_bounds(p):\n                continue\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                continue\n            if c_best < float('inf'):\n                if self._dist(p, start) + self._dist(p, goal) <= c_best + 1e-9:\n                    return p\n            else:\n                return p\n        # Fallback uniform valid point\n        while True:\n            p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ------------- Neighborhoods -------------\n    def _rrtstar_radius(self, n):\n        if n <= 2:\n            return max(self.min_radius, self.base_radius)\n        # ln(n) via log2 approximation: ln(n) = log2(n) * ln(2)\n        log2n = max(1.0, float(n.bit_length() - 1))\n        ln2 = 0.6931471805599453\n        ln_n = log2n * ln2\n        dim = max(2, self.dim)\n        gamma = 1.5 * (self.space_diam)  # scale with space size\n        r = gamma * ((ln_n / float(n)) ** (1.0 / dim))\n        r = max(self.min_radius, min(self.base_radius, r))\n        return r\n\n    # ------------- Grid indexing -------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        key = self._grid_key(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_gather(self, grid, center_pos, radius):\n        rng = int(radius // self.grid_cell) + 1\n        key = self._grid_key(center_pos)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    b = grid.get(k)\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        b = grid.get(k)\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        # expand a few rings; fallback scan if needed\n        best = None\n        bestd = float('inf')\n        for rng in range(1, 5):\n            cand = self._grid_gather(grid, pos, rng * self.grid_cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                return best\n        # fallback\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_grid(self, grid, pos, radius):\n        cand = self._grid_gather(grid, pos, radius)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                di = (n.position[i] - pos[i])\n                d += di * di\n            if d <= r2:\n                out.append(n)\n        return out\n\n    # ------------- Path utilities -------------\n    def _propagate_costs_from(self, node):\n        stack = []\n        for c in node.children:\n            stack.append(c)\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                stack.append(c)\n\n    def _path_to_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        path.reverse()\n        return path\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        # meet_b belongs to opposite tree whose root is goal; climb to its root\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut_once(self, path, obstacles, is_3d):\n        n = len(path)\n        if n < 3:\n            return path\n        i = int(self._uniform(0, n - 2))\n        j = int(self._uniform(i + 1, n - 1))\n        if j <= i + 1:\n            return path\n        a = path[i]\n        b = path[j]\n        if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n            return path[:i + 1] + path[j:]\n        return path\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            new_pts = self._shortcut_once(pts, obstacles, is_3d)\n            if len(new_pts) == len(pts):\n                # try small local smoothing by greedily removing a middle point\n                k = int(self._uniform(1, max(2, len(pts) - 1)))\n                i = k - 1\n                j = k + 1 if k + 1 < len(pts) else k\n                if j < len(pts) and i >= 0 and j > i and not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d, self.edge_res):\n                    pts = pts[:i + 1] + pts[j:]\n            else:\n                pts = new_pts\n            if len(pts) < 3:\n                break\n        return pts",
                "objective": 903.65932,
                "time_improvement": -3080.0,
                "length_improvement": 24.0,
                "smoothness_improvement": 1125.0,
                "node_improvement": -60.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 1.9191562414169312,
                        "num_nodes_avg": 1078.5,
                        "path_length_avg": 144.84467816258504,
                        "smoothness_avg": 0.04086584566813316,
                        "success_improvement": 0.0,
                        "time_improvement": -7426.4584192382035,
                        "node_improvement": -171.59405691261645,
                        "length_improvement": 20.60833668828437,
                        "smoothness_improvement": 539.6392263105108,
                        "objective_score": -2212.8743276269374
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.919565224647522,
                        "num_nodes_avg": 1254.0,
                        "path_length_avg": 217.8194732486166,
                        "smoothness_avg": 0.07114963536651986,
                        "success_improvement": 0.0,
                        "time_improvement": -474.02032068577586,
                        "node_improvement": 15.742793791574277,
                        "length_improvement": 27.285590243700952,
                        "smoothness_improvement": 1730.7313649914906,
                        "objective_score": -117.18108523455474
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.7055335283279419,
                        "num_nodes_avg": 971.1,
                        "path_length_avg": 112.77685375486826,
                        "smoothness_avg": 0.09469551316670241,
                        "success_improvement": 0.0,
                        "time_improvement": -1338.3484294307068,
                        "node_improvement": -23.47107438016529,
                        "length_improvement": 25.098983592702577,
                        "smoothness_improvement": 1104.519937784749,
                        "objective_score": -380.92253898466674
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
                "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -20.90414805532173,
                "time_improvement": 74.0,
                "length_improvement": -3.0,
                "smoothness_improvement": 81.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.009906005859375,
                        "num_nodes_avg": 119.0,
                        "path_length_avg": 191.04302473496983,
                        "smoothness_avg": 0.011270904212760589,
                        "success_improvement": 0.0,
                        "time_improvement": 61.15108317274382,
                        "node_improvement": 70.03273734575673,
                        "length_improvement": -4.713709127687822,
                        "smoothness_improvement": 76.41412608993974,
                        "objective_score": 15.899170105660149
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.018079090118408202,
                        "num_nodes_avg": 263.8,
                        "path_length_avg": 304.060897710979,
                        "smoothness_avg": 0.007193047909992605,
                        "success_improvement": 0.0,
                        "time_improvement": 88.71448720621899,
                        "node_improvement": 82.2750789491366,
                        "length_improvement": -1.5042795636027118,
                        "smoothness_improvement": 85.08230366710401,
                        "objective_score": 26.13718994203959
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.013434433937072754,
                        "num_nodes_avg": 198.2,
                        "path_length_avg": 154.3877135428638,
                        "smoothness_avg": 0.014383244909940574,
                        "success_improvement": 0.0,
                        "time_improvement": 72.61165319885777,
                        "node_improvement": 74.79974570883661,
                        "length_improvement": -2.536968182267624,
                        "smoothness_improvement": 82.95381359374001,
                        "objective_score": 20.676084118265454
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "Adaptive Goal-Biased Grid BiRRT (AG-GBiRRT): a simplified, robust bidirectional RRT with commit-only connection, grid-accelerated nearest search, and light post-connection shortcut smoothing. It alternates growing two trees, uses uniform-with-goal-bias sampling, single-step steering with strict node/edge collision checks, and an early straight-line test. Upon any successful bridge between trees, it extracts the path and performs a few inexpensive shortcuts for smoothness, returning quickly without extra rewiring or bloat.",
            "planning_mechanism": "Mechanism: alternate start/goal tree expansion; sample (goal-biased), find nearest via grid, steer one step, validate node and edge, add node and edge, attempt a direct, collision-free bridge to the opposite tree (commit-only); on success, extract [start\u2192\u2026\u2192meetA, meetB\u2192\u2026\u2192goal] and run brief shortcut smoothing; terminate on success or iteration budget.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.0)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                continue\n\n            # Insert node (both node and edge validated)\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Try commit-only direct connection to the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None:\n                if not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, other_near)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        try:\n            return self._lcg_next()\n        except:\n            return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Sampling ----------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ---------- Grid nearest ----------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # ---------- Path ----------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # path_a ends at meet_a; we then go straight to meet_b and up to other root\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            # pick two indices i < j with at least one point between\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
            "objective": -32.96764,
            "time_improvement": 69.0,
            "length_improvement": 11.0,
            "smoothness_improvement": 1142.0,
            "node_improvement": 82.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01299290657043457,
                    "num_nodes_avg": 78.8,
                    "path_length_avg": 167.86786188508313,
                    "smoothness_avg": 0.03825680999831742,
                    "success_improvement": 0.0,
                    "time_improvement": 49.04501835909778,
                    "node_improvement": 80.15613195668597,
                    "length_improvement": 7.988964864290817,
                    "smoothness_improvement": 498.8021524662562,
                    "objective_score": 22.000895188635106
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02625594139099121,
                    "num_nodes_avg": 208.9,
                    "path_length_avg": 244.3021244779086,
                    "smoothness_avg": 0.07331771296729457,
                    "success_improvement": 0.0,
                    "time_improvement": 83.61025026480232,
                    "node_improvement": 85.96385137405093,
                    "length_improvement": 18.444919002512343,
                    "smoothness_improvement": 1786.5175632625994,
                    "objective_score": 45.082614297261095
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01305999755859375,
                    "num_nodes_avg": 163.0,
                    "path_length_avg": 140.27860161008172,
                    "smoothness_avg": 0.09759083301298958,
                    "success_improvement": 0.0,
                    "time_improvement": 73.37500455677744,
                    "node_improvement": 79.27527018436109,
                    "length_improvement": 6.833632159773637,
                    "smoothness_improvement": 1141.348192519241,
                    "objective_score": 31.819421625493614
                }
            ],
            "success_rate": 1.0
        },
        "objective": 43.4,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient exploration and sampling (high rejection rates, large neighborhood searches, and linear-time nearest lookups) causing many wasted iterations.\n   - Heavy per-iteration optimization overhead (rewiring, subtree cost propagation, repeated shortcut attempts and path-length recomputation).\n   - Tree bloat from retaining nodes/edges after failed connection attempts and duplicative bidirectional expansions per sample.\n   - Overly conservative acceptance policies (strict separation and dense long-edge collision checks) that reject feasible short progress near obstacles/goals.\n   - Path assembly issues and delayed smoothing that either inflate path length or incur costly late-stage processing."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Early straight-line feasibility check with immediate exit on success.\n   - Goal-biased sampling toward the opposite root.\n   - Grid-accelerated nearest-neighbor queries with limited ring expansion and cheap fallback.\n   - Commit-only direct connections that discard failures to avoid tree/edge bloat.\n   - Alternating single-tree growth per iteration with one-step steering and validated edges.\n   - Lightweight, bounded shortcut smoothing after a successful bridge.\n2. Expected mechanism of impact:\n   - Rapidly resolves easy instances and focuses expansions, reducing total iterations.\n   - Cuts per-iteration cost by avoiding rewiring/subtree updates and replacing linear scans with grid lookups.\n   - Prevents accumulation of redundant nodes/edges, lowering collision checks and memory overhead.\n   - Maintains acceptable path quality via brief smoothing without expensive anytime optimization.\n   - Produces shorter, cleaner connection segments, reducing collision-sampling workload and accelerating convergence."
        }
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "Fast Informed BiRRT*-Connect (FIBRC-Lite): a time-focused bidirectional planner that mixes cheap RRT-Connect growth with light RRT* improvements and informed sampling. It accelerates nearest/near queries with a fine spatial hash, selects best parents within a small adaptive neighborhood, performs capped local rewires, and attempts short greedy bridges to the opposite tree. Upon first feasible join it extracts and quickly shortens the path with bounded shortcutting and a final line-of-sight collapse, returning early to minimize compute.",
                "planning_mechanism": "Alternate expanding start/goal trees; sample with goal and informed biases; find nearest via grid; steer once; validate node and edge; choose best parent among near neighbors; insert and perform small-budget rewires; try greedy connect to the other tree (few steps); if join succeeds, extract [start\u2192...\u2192A, B\u2192...\u2192goal], run bounded shortcut smoothing and return; otherwise loop up to iteration budget.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=6.0,\n                 goal_bias=0.25,\n                 informed_bias=0.6,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=60,\n                 rewire_budget=6,\n                 connect_steps=8,\n                 min_sep_ratio=0.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.informed_bias = informed_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.rewire_budget = rewire_budget\n        self.connect_steps = connect_steps\n        self.min_sep_ratio = min_sep_ratio\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size)\n        self.edge_res = max(0.5, min(self.collision_step, self.step_size * 0.5))\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._is_edge_in_obstacle(self.start, self.goal, obstacles, is_3d, self.edge_res):\n            path = [self.start, self.goal]\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, path, nodes, [])\n\n        # Initialize trees, grids, edges\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes_all = [start_root, goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Best-so-far path length for informed sampling\n        c_best = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = self.goal if active_start else self.start\n\n            # Sampling with goal bias and informed bias (if an incumbent path exists)\n            r = self._rand()\n            if c_best < float('inf') and r < self.informed_bias:\n                x_rand = self._sample_informed(c_best, obstacles, is_3d)\n            elif r < self.informed_bias + self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                continue\n\n            # Best-parent selection in a compact neighborhood\n            r_near = self._neighbor_radius(len(tree_a))\n            candidates = self._nearby_nodes(grid_a, tree_a, new_pos, r_near)\n            best_parent = None\n            best_cost = float('inf')\n            for q in candidates:\n                edge_len = self._dist(q.position, new_pos)\n                cand_cost = q.cost + edge_len\n                if cand_cost < best_cost:\n                    if not self._is_edge_in_obstacle(q.position, new_pos, obstacles, is_3d, self.edge_res):\n                        best_cost = cand_cost\n                        best_parent = q\n            if best_parent is None:\n                best_parent = nearest\n                best_cost = nearest.cost + self._dist(nearest.position, new_pos)\n\n            # Insert node (both node and parent->child edge validated)\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes_all.append(new_node)\n            self._edges_add(edges, best_parent, new_node)\n            self._grid_add(grid_a, new_node)\n\n            # Limited rewiring to improve local path quality\n            rewired = 0\n            for q in candidates:\n                if rewired >= self.rewire_budget or q is best_parent or q is new_node:\n                    continue\n                alt_cost = new_node.cost + self._dist(new_node.position, q.position)\n                if alt_cost + 1e-9 < q.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, q.position, obstacles, is_3d, self.edge_res):\n                        old_parent = q.parent\n                        if old_parent is not None:\n                            old_parent.remove_child(q)\n                            self._edges_remove(edges, old_parent, q)\n                        new_node.add_child(q)\n                        cost_delta = alt_cost - q.cost\n                        q.cost = alt_cost\n                        self._edges_add(edges, new_node, q)\n                        self._propagate_cost_from(q, cost_delta)\n                        rewired += 1\n\n            # Try commit-only direct connection to the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None and not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                path = self._extract_path(new_node, other_near)\n                c_best = self._path_length(path)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Greedy short connect from the other tree toward new_node\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if self._dist(p.position, to_pos) < self.step_size * self.min_sep_ratio:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(p.position, to_pos, obstacles, is_3d, self.edge_res):\n                    break\n                # Attach greedily to p (node and edge validated)\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                nodes_all.append(q)\n                self._edges_add(edges, p, q)\n                self._grid_add(grid_b, q)\n                p = q\n                steps += 1\n\n                # Check if we can bridge now\n                if not self._is_edge_in_obstacle(new_node.position, p.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, p)\n                    c_best = self._path_length(path)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Sampling ----------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_informed(self, c_best, obstacles, is_3d):\n        # Axis-aligned bounding box enclosing start-goal with margin proportional to current best\n        dsg = self._dist(self.start, self.goal)\n        margin = max(0.0, (c_best - dsg)) * 0.5 + self.step_size\n        low = []\n        high = []\n        for i in range(self.dim):\n            a = self.start[i]\n            b = self.goal[i]\n            lo = min(a, b) - margin\n            hi = max(a, b) + margin\n            lo = 0.0 if lo < 0.0 else lo\n            hi = self.bounds[i] if hi > self.bounds[i] else hi\n            low.append(lo)\n            high.append(hi)\n        # Rejection sample inside the AABB\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(low[0], high[0]),\n                     self._uniform(low[1], high[1]),\n                     self._uniform(low[2], high[2]))\n            else:\n                p = (self._uniform(low[0], high[0]),\n                     self._uniform(low[1], high[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ---------- Grid and neighbor queries ----------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # expand rings until at least one candidate found or capped radius\n        for r in range(0, 5):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _nearby_nodes(self, grid, tree, pos, radius):\n        key = self._grid_key(pos)\n        # Convert radius to grid cells (ceil approx)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        res = []\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                res.append(n)\n        if not res:\n            # ensure at least nearest is considered\n            res = [self._nearest_grid(grid, tree, pos)]\n        return res\n\n    def _neighbor_radius(self, n_nodes):\n        # Compact adaptive radius in [1.5, 3.0] * step_size shrinking with growth\n        base = 3.0 * self.step_size / (1.0 + 0.01 * max(1, n_nodes))\n        r = base if base > 1.5 * self.step_size else 1.5 * self.step_size\n        if r > 3.0 * self.step_size:\n            r = 3.0 * self.step_size\n        return r\n\n    # ---------- Edges and costs ----------\n    def _edges_add(self, edges, parent, child):\n        edges.append((parent, child))\n\n    def _edges_remove(self, edges, parent, child):\n        # remove first occurrence\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_cost_from(self, node, delta):\n        if delta == 0.0:\n            return\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    # ---------- Path ----------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)  # start -> ... -> meet_a (or goal side if swapped)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # path_a already ends at meet_a; append meet_b->...->root_other\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        nstall = 0\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n                nstall = 0\n            else:\n                nstall += 1\n                if nstall > 12:\n                    break\n        # Final pass: line-of-sight collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            for k in range(1, len(pts) - 1):\n                nxt = pts[k + 1]\n                if not self._is_edge_in_obstacle(last, nxt, obstacles, is_3d, self.edge_res):\n                    continue\n                else:\n                    collapsed.append(pts[k])\n                    last = pts[k]\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
                "objective": 54.38004,
                "time_improvement": -43.0,
                "length_improvement": 14.0,
                "smoothness_improvement": 3325.0,
                "node_improvement": 81.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.0447272777557373,
                        "num_nodes_avg": 62.9,
                        "path_length_avg": 172.72321740556453,
                        "smoothness_avg": 0.04175474386966843,
                        "success_improvement": 0.0,
                        "time_improvement": -75.40937468735302,
                        "node_improvement": 84.16016116847143,
                        "length_improvement": 5.32766756548325,
                        "smoothness_improvement": 553.5524134378776,
                        "objective_score": -16.65844979972657
                    },
                    {
                        "map_id": 1,
                        "success_rate": 0.9,
                        "time_avg": 0.13959274291992188,
                        "num_nodes_avg": 188.6,
                        "path_length_avg": 237.8767141690268,
                        "smoothness_avg": 0.18878187016499196,
                        "success_improvement": -9.999999999999998,
                        "time_improvement": 12.862003794222588,
                        "node_improvement": 87.32782369146005,
                        "length_improvement": 20.589905908798265,
                        "smoothness_improvement": 4757.493493430209,
                        "objective_score": -9.99998784930321
                    },
                    {
                        "map_id": 2,
                        "success_rate": 0.7,
                        "time_avg": 0.0813495397567749,
                        "num_nodes_avg": 220.3,
                        "path_length_avg": 125.59197842186634,
                        "smoothness_avg": 0.37451567120397955,
                        "success_improvement": -30.000000000000004,
                        "time_improvement": -65.84468072179355,
                        "node_improvement": 71.98982835346473,
                        "length_improvement": 16.587787979542895,
                        "smoothness_improvement": 4663.811693843319,
                        "objective_score": -136.48167295959576
                    }
                ],
                "success_rate": 0.8666666666666666
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "Adaptive Beam BiRRT-Connect (AB-Connect): a lean, time-focused bidirectional planner that alternates single-step tree growth with a tiny beam of candidate samples. It uses a fine spatial hash for fast nearest queries, corridor-guided sampling around the start\u2013goal line to reduce rejection, and on-the-fly path compression to limit node bloat. A short greedy connect attempts to bridge trees early; upon success, a bounded shortcut pass cleans the path and returns immediately. By avoiding rewiring and heavy optimization while enforcing strict node/edge collision checks, AB-Connect minimizes per-iteration cost and achieves fast solutions.",
            "planning_mechanism": "Mechanism: Initialize two trees at start/goal. Each iteration (alternating trees), generate a small beam of candidate samples (goal/corridor/uniform), steer once from the nearest node, validate node and edge, discard near-duplicates, and keep the candidate that best reduces distance to the opposite tree. Insert it, attempt on-the-fly grandparent line-of-sight compression, then try a direct or short greedy connect toward the other tree. If bridged, extract the path and run bounded shortcut smoothing; else continue until the iteration budget is reached.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=8.0,\n                 goal_bias=0.18,\n                 corridor_bias=0.5,\n                 beam_k=2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=28,\n                 connect_steps=6,\n                 min_sep_ratio=0.25,\n                 dupe_radius_ratio=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.connect_steps = connect_steps\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n\n    # ---------------- Planning ----------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Setup grid resolution and collision sampling\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.6 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.4)))\n\n        # Validate start/goal and early LOS\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        if not self._is_edge_in_obstacle(self.start, self.goal, obstacles, is_3d, self.edge_res):\n            path = [self.start, self.goal]\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, path, nodes, [])\n\n        # Initialize structures\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Corridor parameters\n        dsg = self._dist(self.start, self.goal)\n        c_best = float('inf')\n        base_corridor = max(self.step_size, 0.15 * dsg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = self.goal if active_start else self.start\n\n            # Beam of candidates; keep the one that best reduces distance to the other tree\n            best_cand = None\n            best_score = float('inf')\n            other_near_hint = None\n\n            for _ in range(self.beam_k):\n                # Sampling policy: goal-biased, corridor-guided, or uniform\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = base_corridor\n                    if c_best < float('inf'):\n                        width = max(self.step_size, 0.25 * (c_best - dsg) + base_corridor)\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                    continue\n\n                # Score: distance to nearest node in the other tree after this move\n                if other_near_hint is None:\n                    other_near_hint = self._nearest_grid(grid_b, tree_b, new_pos)\n                else:\n                    # refresh if new_pos is far from hint\n                    if self._dist(other_near_hint.position, new_pos) > 2.5 * self.step_size:\n                        other_near_hint = self._nearest_grid(grid_b, tree_b, new_pos)\n                if other_near_hint is None:\n                    score = self._dist(new_pos, root_other)\n                else:\n                    score = self._dist(new_pos, other_near_hint.position)\n                if score < best_score:\n                    best_score = score\n                    best_cand = (nearest, new_pos)\n\n            if best_cand is None:\n                continue\n\n            parent_node, new_pos = best_cand\n\n            # Insert node and edge (validated already)\n            new_cost = parent_node.cost + self._dist(parent_node.position, new_pos)\n            new_node = Node(new_pos, parent=parent_node, cost=new_cost)\n            parent_node.add_child(new_node)\n            tree_a.append(new_node)\n            self._edges_add(edges, parent_node, new_node)\n            self._grid_add(grid_a, new_node)\n\n            # On-the-fly grandparent compression\n            gp = parent_node.parent\n            if gp is not None:\n                # If LOS from grandparent to new_node, bypass parent to reduce nodes and cost\n                if not self._is_edge_in_obstacle(gp.position, new_node.position, obstacles, is_3d, self.edge_res):\n                    # Update edges/children coherently\n                    parent_node.remove_child(new_node)\n                    self._edges_remove(edges, parent_node, new_node)\n                    gp.add_child(new_node)\n                    self._edges_add(edges, gp, new_node)\n                    # Update cost\n                    new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n\n            # Try direct bridge to the nearest node in the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None and not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                path = self._extract_path(new_node, other_near)\n                c_best = self._path_length(path)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Short greedy connect toward new_node from the other tree\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if self._dist(p.position, to_pos) < self.step_size * self.min_sep_ratio:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(p.position, to_pos, obstacles, is_3d, self.edge_res):\n                    break\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                self._edges_add(edges, p, q)\n                self._grid_add(grid_b, q)\n                p = q\n                steps += 1\n\n                # Check bridge now\n                if not self._is_edge_in_obstacle(new_node.position, p.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, p)\n                    c_best = self._path_length(path)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------------- RNG ----------------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------------- Geometry ----------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------------- Collision ----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------------- Sampling ----------------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        # Sample around the start-goal line with axis-aligned jitter (cheap \"corridor\")\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        # Fallback to uniform if corridor sample is invalid\n        return self._sample_free(obstacles, is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---------------- Grid and neighbors ----------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Expand rings up to modest radius; fallback linear scan if needed\n        for r in range(0, 5):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan (rare with fine grid)\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # ---------------- Edges and costs ----------------\n    def _edges_add(self, edges, parent, child):\n        edges.append((parent, child))\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # ---------------- Paths ----------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        # Path A: root_A -> meet_a\n        path_a = self._path_to_root(meet_a)\n        # Path B: meet_b -> root_B (following parent links)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # Concatenate, implying a straight edge between meet_a and meet_b (validated before)\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        # Final LOS collapse forward\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            for k in range(1, len(pts) - 1):\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d, self.edge_res):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
            "objective": -20.0019,
            "time_improvement": 15.0,
            "length_improvement": 12.0,
            "smoothness_improvement": 1665.0,
            "node_improvement": 85.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022508907318115234,
                    "num_nodes_avg": 61.9,
                    "path_length_avg": 173.37195960178056,
                    "smoothness_avg": 0.04856882636983518,
                    "success_improvement": 0.0,
                    "time_improvement": 11.725605588421473,
                    "node_improvement": 84.41198690506171,
                    "length_improvement": 4.972081687759297,
                    "smoothness_improvement": 660.2076015824708,
                    "objective_score": 9.801968697094374
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04350669384002685,
                    "num_nodes_avg": 122.6,
                    "path_length_avg": 245.93388702328062,
                    "smoothness_avg": 0.11098748565610625,
                    "success_improvement": 0.0,
                    "time_improvement": 72.84181080292292,
                    "node_improvement": 91.76241349190352,
                    "length_improvement": 17.900189697186487,
                    "smoothness_improvement": 2755.78794698629,
                    "objective_score": 46.371596794120215
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06773929595947266,
                    "num_nodes_avg": 163.7,
                    "path_length_avg": 132.06627662911285,
                    "smoothness_avg": 0.13189994478614067,
                    "success_improvement": 0.0,
                    "time_improvement": -38.09791603378091,
                    "node_improvement": 79.18626827717736,
                    "length_improvement": 12.287867383240805,
                    "smoothness_improvement": 1577.7575618385185,
                    "objective_score": 3.832133429002802
                }
            ],
            "success_rate": 1.0
        },
        "objective": -14.200000000000003,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Expensive neighbor selection and local rewiring causing many collision-checked edges and costly edge maintenance\n   - Coarse spatial hashing with limited neighborhood search leading to frequent linear nearest-neighbor fallbacks as trees grow\n   - Overly strong directional sampling toward the target before a valid corridor exists, wasting expansions in blocked regions\n   - Fine-grained edge collision sampling inflating per-check costs across multiple candidate edges\n   - Aggressive multi-step greedy connections adding many nodes and checks per iteration\n   - Unbounded or lengthy shortcut smoothing adding significant post-processing overhead\n   - No duplicate/near-duplicate suppression, causing node bloat and redundant expansions\n   - Small motion steps increasing the number of expansions needed to traverse free space\n   - Weakly focused \u201cinformed\u201d region producing high rejection in clutter\n   - Lack of on-the-fly path compression, yielding deep chains and higher bookkeeping costs"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Replaced best-parent/rewiring with single-parent insertion to avoid heavy candidate evaluation and edge updates\n   - Introduced corridor-guided beam sampling to bias few candidates toward productive directions\n   - Increased motion step to cover more distance per expansion\n   - Added near-duplicate suppression to reduce redundant nodes\n   - Applied on-the-fly line-of-sight compression to shorten chains and cut node/edge counts\n   - Used a finer spatial hash to reduce nearest-neighbor fallbacks\n   - Shortened greedy connect attempts and capped shortcut smoothing iterations\n   - Moderated goal-directed bias to limit unproductive attempts in blocked areas\n2. Expected mechanism of impact:\n   - Fewer edge collision checks and neighbor queries per iteration\n   - Smaller and sparser trees lowering costs of search, grid lookups, and bookkeeping\n   - More directed growth reaching a bridge sooner, enabling earlier termination\n   - Reduced post-solution processing time due to bounded smoothing and prior compression\n   - Overall lower constant factors per loop, translating into improved planning time"
        }
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -24.971436625701273,
                "time_improvement": 62.0,
                "length_improvement": 9.0,
                "smoothness_improvement": 168.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.009481477737426757,
                        "num_nodes_avg": 112.0,
                        "path_length_avg": 170.25136521926942,
                        "smoothness_avg": 0.017004537999713392,
                        "success_improvement": 0.0,
                        "time_improvement": 62.815977978432855,
                        "node_improvement": 71.7955175018887,
                        "length_improvement": 6.682528917796031,
                        "smoothness_improvement": 166.15794564080122,
                        "objective_score": 23.68510047241148
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.0245816707611084,
                        "num_nodes_avg": 299.2,
                        "path_length_avg": 258.5973544494462,
                        "smoothness_avg": 0.010851066788952054,
                        "success_improvement": 0.0,
                        "time_improvement": 84.6553804394982,
                        "node_improvement": 79.89652623798965,
                        "length_improvement": 13.67275977263268,
                        "smoothness_improvement": 179.20576418723118,
                        "objective_score": 34.496298816365226
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.030178475379943847,
                        "num_nodes_avg": 287.8,
                        "path_length_avg": 139.5271231166937,
                        "smoothness_avg": 0.020290033291575655,
                        "success_improvement": 0.0,
                        "time_improvement": 38.47611641047452,
                        "node_improvement": 63.40750158931977,
                        "length_improvement": 7.332728393521491,
                        "smoothness_improvement": 158.08772581437248,
                        "objective_score": 16.732910588327112
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
                "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -17.205069232007403,
                "time_improvement": 34.0,
                "length_improvement": 10.0,
                "smoothness_improvement": 176.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.0216599702835083,
                        "num_nodes_avg": 94.5,
                        "path_length_avg": 179.3326139424124,
                        "smoothness_avg": 0.016628736549943037,
                        "success_improvement": 0.0,
                        "time_improvement": 15.05492769030675,
                        "node_improvement": 76.20246789221858,
                        "length_improvement": 1.7049525910466614,
                        "smoothness_improvement": 160.2758368859854,
                        "objective_score": 6.340829046149949
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.02987968921661377,
                        "num_nodes_avg": 216.6,
                        "path_length_avg": 257.061927055405,
                        "smoothness_avg": 0.010384869878880055,
                        "success_improvement": 0.0,
                        "time_improvement": 81.34819768474138,
                        "node_improvement": 85.44648256399921,
                        "length_improvement": 14.185329631590712,
                        "smoothness_improvement": 167.21018190301697,
                        "objective_score": 33.75170799389193
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.046378374099731445,
                        "num_nodes_avg": 257.2,
                        "path_length_avg": 128.26306667164565,
                        "smoothness_avg": 0.023576110070462338,
                        "success_improvement": 0.0,
                        "time_improvement": 5.449905826599429,
                        "node_improvement": 67.29815638906548,
                        "length_improvement": 14.813778347593729,
                        "smoothness_improvement": 199.8863798888539,
                        "objective_score": 11.522670655980336
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "Beam-guided BiRRT with ancestor line-of-sight compression and spatial hashing (BG-Connect-LOS). The planner alternates tree growth from start and goal using a small beam of guided samples, accelerates nearest lookups with a grid hash, suppresses near-duplicate nodes, and selects a parent among recent ancestors that maintains direct line-of-sight to the new point to compress chains. A short, capped greedy connect links the two trees. Upon success, a bounded shortcut pass refines the path. This reduces expansions and collision checks while improving path quality and smoothness.",
            "planning_mechanism": "At each iteration, pick the active tree and generate a small beam of guided samples biased toward the opposite root. For each sample: find a nearby node via spatial hashing, steer by a fixed step, enforce node and edge collision checks, reject near-duplicates, and pick an ancestor parent with clear line-of-sight to minimize added cost. Insert the node and attempt a capped greedy connect from the opposite tree toward it; if the two trees meet, extract and lightly shortcut the path. Alternate trees and stop early on success.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        beam_width=3,\n        goal_bias=0.15,\n        connect_steps_limit=20,\n        min_separation_factor=0.6,\n        grid_cell_factor=1.0,\n        los_lookback_depth=8,\n        shortcut_attempts=40\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.connect_steps_limit = connect_steps_limit\n        self.min_separation_factor = min_separation_factor\n        self.grid_cell_factor = grid_cell_factor\n        self.los_lookback_depth = los_lookback_depth\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dims = len(bounds)\n        is_3d = dims == 3\n\n        # Parameters derived from step_size\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root = Node(goal_position, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root, is_3d)\n        self._grid_insert(grid_b, goal_root, is_3d)\n\n        success_state = False\n        extracted_path = []\n\n        for _ in range(self.max_iter):\n            # Alternate trees by swapping references each loop\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, goal_position),\n                (tree_b, grid_b, tree_a, grid_a, start_position),\n            ]:\n                made_progress = False\n\n                for _beam in range(self.beam_width):\n                    sample = self._sample_guided(bounds, obstacles, is_3d, attractor)\n\n                    nearest = self._nearest_by_grid(active_tree, active_grid, sample, is_3d)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos, bounds):\n                        continue\n                    if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                        continue\n                    if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                        continue\n                    if self._has_near_duplicate(active_grid, new_pos, self.min_separation, is_3d):\n                        continue\n\n                    # Choose parent among LOS-capable ancestors to compress path\n                    parent = self._choose_ancestor_parent(nearest, new_pos, obstacles, is_3d)\n                    new_cost = parent.cost + self._distance(parent.position, new_pos)\n\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node, is_3d)\n                    made_progress = True\n\n                    # Try capped greedy connect from the opposite tree toward new_node\n                    connect_node = self._attempt_connect(\n                        other_tree, other_grid, new_node.position, obstacles, is_3d, nodes, edges, bounds\n                    )\n                    if connect_node is not None:\n                        # Trees meet at new_node.position; extract path\n                        path_a = self._path_from_root(new_node)\n                        path_b = self._path_from_root(connect_node)\n                        # Remove duplicate joint if equal\n                        if path_a and path_b and path_a[-1] == path_b[-1]:\n                            path_b = path_b[:-1]\n                        raw_path = path_a + path_b[::-1]\n                        # Light shortcut smoothing\n                        smoothed = self._shortcut_path(raw_path, obstacles, is_3d, attempts=self.shortcut_attempts)\n                        extracted_path = smoothed if smoothed else raw_path\n                        success_state = True\n                        return PlannerResult(True, extracted_path, nodes, edges)\n\n                # If neither beam sample made progress for this tree, continue with the other\n                if not made_progress:\n                    continue\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # --------- Core Geometry / Utilities ---------\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _within_bounds(self, pos, bounds):\n        for i in range(len(bounds)):\n            if pos[i] < 0.0 or pos[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= 1e-9:\n            return from_pos\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * r for d in range(len(from_pos)))\n\n    def _sample_guided(self, bounds, obstacles, is_3d, target):\n        # Mild guidance: with some probability sample exactly target, else blend toward target\n        while True:\n            if random.random() < self.goal_bias:\n                p = target\n            else:\n                rand = tuple(random.uniform(0.0, bounds[d]) for d in range(len(bounds)))\n                alpha = 0.2\n                p = tuple(alpha * target[d] + (1.0 - alpha) * rand[d] for d in range(len(bounds)))\n            if self._within_bounds(p, bounds) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _path_from_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\n\n    # --------- Spatial Hash (Grid) ---------\n\n    def _cell_of(self, pos):\n        # integer grid cell indices\n        if len(pos) == 3:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        else:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node, is_3d):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _has_near_duplicate(self, grid, pos, radius, is_3d):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    def _nearest_by_grid(self, tree, grid, pos, is_3d, ring_limit=3):\n        # Search neighborhood rings; fallback to linear scan if not found\n        cell = self._cell_of(pos)\n        best = None\n        best_d = float(\"inf\")\n\n        if is_3d:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best_d = d\n                                        best = n\n                                        found = True\n                if found and best is not None:\n                    return best\n        else:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                                    found = True\n                if found and best is not None:\n                    return best\n\n        # Fallback\n        if not tree:\n            return None\n        return min(tree, key=lambda n: self._distance(n.position, pos))\n\n    # --------- Parent selection via LOS to ancestors ---------\n\n    def _choose_ancestor_parent(self, nearest, new_pos, obstacles, is_3d):\n        best_parent = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        steps = 0\n        cur = nearest\n        while cur is not None and steps < self.los_lookback_depth:\n            if not self._is_edge_in_obstacle(cur.position, new_pos, obstacles, is_3d):\n                cand_cost = cur.cost + self._distance(cur.position, new_pos)\n                if cand_cost < best_cost:\n                    best_cost = cand_cost\n                    best_parent = cur\n            cur = cur.parent\n            steps += 1\n        return best_parent\n\n    # --------- Connect attempt ---------\n\n    def _attempt_connect(self, tree, grid, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest_by_grid(tree, grid, target_pos, is_3d)\n        if nearest is None:\n            return None\n\n        current = nearest\n        for _ in range(self.connect_steps_limit):\n            step_pos = self._steer(current.position, target_pos)\n            if not self._within_bounds(step_pos, bounds):\n                return None\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                return None\n\n            # If close enough to target and direct edge exists, finalize with exact target node\n            if self._distance(step_pos, target_pos) <= 1e-6 or (\n                self._distance(step_pos, target_pos) <= self.step_size and\n                not self._is_edge_in_obstacle(step_pos, target_pos, obstacles, is_3d) and\n                not self._is_in_obstacle(target_pos, obstacles, is_3d)\n            ):\n                # Add intermediate step node if it is not exactly current\n                if self._distance(current.position, step_pos) > 1e-9:\n                    if not self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                        new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n                        current.add_child(new_node)\n                        tree.append(new_node)\n                        nodes.append(new_node)\n                        edges.append((current, new_node))\n                        self._grid_insert(grid, new_node, is_3d)\n                        current = new_node\n                    else:\n                        # If duplicate exists, try using current as is\n                        pass\n                # Add final node at the exact target position to guarantee path merge\n                final_node = Node(target_pos, parent=current, cost=current.cost + self._distance(current.position, target_pos))\n                current.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((current, final_node))\n                self._grid_insert(grid, final_node, is_3d)\n                return final_node\n\n            # Regular step addition with duplicate suppression\n            if self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                # Progress is negligible; stop trying to avoid loops\n                return None\n\n            new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node, is_3d)\n            current = new_node\n\n        return None\n\n    # --------- Collision Checking ---------\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d):\n        distance = self._distance(from_pos, to_pos)\n        resolution = max(0.5, min(1.0, self.step_size * 0.5))\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    # --------- Shortcut Smoothing (bounded) ---------\n\n    def _shortcut_path(self, path, obstacles, is_3d, attempts=40):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        n = len(pts)\n        tries = 0\n        i = 0\n        # Greedy forward skipping with bounded iterations\n        while i < len(pts) - 2 and tries < attempts:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                    # Remove intermediates\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n            tries += 1\n        return pts",
            "objective": -28.86257,
            "time_improvement": 43.0,
            "length_improvement": 15.0,
            "smoothness_improvement": 1410.0,
            "node_improvement": 90.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03400664329528809,
                    "num_nodes_avg": 52.1,
                    "path_length_avg": 171.51876006638196,
                    "smoothness_avg": 0.050501544373221775,
                    "success_improvement": 0.0,
                    "time_improvement": -33.36568499023374,
                    "node_improvement": 86.87987912364643,
                    "length_improvement": 5.987849718937115,
                    "smoothness_improvement": 690.45883529979,
                    "objective_score": -2.964701489208901
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030187082290649415,
                    "num_nodes_avg": 92.2,
                    "path_length_avg": 234.31486940525366,
                    "smoothness_avg": 0.08620583217892899,
                    "success_improvement": 0.0,
                    "time_improvement": 81.1563136658539,
                    "node_improvement": 93.8050124302896,
                    "length_improvement": 21.77895221296278,
                    "smoothness_improvement": 2118.138153515002,
                    "objective_score": 48.004956195108846
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009754443168640136,
                    "num_nodes_avg": 73.2,
                    "path_length_avg": 124.45355479806292,
                    "smoothness_avg": 0.11960663519260235,
                    "success_improvement": 0.0,
                    "time_improvement": 80.11393158758125,
                    "node_improvement": 90.69294342021614,
                    "length_improvement": 17.343874744565582,
                    "smoothness_improvement": 1421.3875712064366,
                    "objective_score": 41.54744217904591
                }
            ],
            "success_rate": 1.0
        },
        "objective": 33.4,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Nearest/neighbor lookups done via full linear scans with no spatial indexing, causing increasing per-iteration cost.\n   - Neighbor-based rewiring with large/poorly scaled radii leads to many candidate evaluations and quadratic-time updates.\n   - Extensive collision sampling along edges at fixed fine resolution, plus redundant point/edge checks inflate runtime.\n   - Connection strategies either stop at a single short step or run unbounded multi-step loops, wasting iterations in clutter.\n   - No suppression of near-duplicate nodes creates dense clusters, larger trees, and more costly searches/checks.\n   - Limited guidance toward the meeting region yields excessive exploratory samples before trees converge."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Guided beam sampling toward the opposite root to focus expansions.\n   - Spatial hashing for approximate nearest lookup and local neighborhood queries.\n   - Near-duplicate suppression with a minimum separation threshold.\n   - Capped greedy connect with a strict step limit and early success return.\n   - Ancestor line-of-sight parent selection to compress chains and reduce depth.\n   - Slightly coarser, step-size-aware edge collision discretization.\n2. Expected mechanism of impact:\n   - Concentrated sampling reduces futile expansions, decreasing required iterations to meet.\n   - Spatial indexing cuts nearest-search cost from linear to near-local, lowering per-iteration overhead.\n   - Pruning near-duplicates shrinks tree size, reducing future distance computations and collision checks.\n   - Bounding the connect loop prevents runaway stepping, while early termination saves iterations once a link is found.\n   - Chain compression reduces the number of edges and future checks along the same corridor.\n   - Fewer collision samples per edge directly lowers the cost of feasibility tests without harming reliability in open space."
        }
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "Adaptive Beam BiRRT-Connect (AB-Connect): a lean, time-focused bidirectional planner that alternates single-step tree growth with a tiny beam of candidate samples. It uses a fine spatial hash for fast nearest queries, corridor-guided sampling around the start\u2013goal line to reduce rejection, and on-the-fly path compression to limit node bloat. A short greedy connect attempts to bridge trees early; upon success, a bounded shortcut pass cleans the path and returns immediately. By avoiding rewiring and heavy optimization while enforcing strict node/edge collision checks, AB-Connect minimizes per-iteration cost and achieves fast solutions.",
                "planning_mechanism": "Mechanism: Initialize two trees at start/goal. Each iteration (alternating trees), generate a small beam of candidate samples (goal/corridor/uniform), steer once from the nearest node, validate node and edge, discard near-duplicates, and keep the candidate that best reduces distance to the opposite tree. Insert it, attempt on-the-fly grandparent line-of-sight compression, then try a direct or short greedy connect toward the other tree. If bridged, extract the path and run bounded shortcut smoothing; else continue until the iteration budget is reached.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=8.0,\n                 goal_bias=0.18,\n                 corridor_bias=0.5,\n                 beam_k=2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=28,\n                 connect_steps=6,\n                 min_sep_ratio=0.25,\n                 dupe_radius_ratio=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.connect_steps = connect_steps\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n\n    # ---------------- Planning ----------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Setup grid resolution and collision sampling\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.6 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.4)))\n\n        # Validate start/goal and early LOS\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        if not self._is_edge_in_obstacle(self.start, self.goal, obstacles, is_3d, self.edge_res):\n            path = [self.start, self.goal]\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, path, nodes, [])\n\n        # Initialize structures\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Corridor parameters\n        dsg = self._dist(self.start, self.goal)\n        c_best = float('inf')\n        base_corridor = max(self.step_size, 0.15 * dsg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = self.goal if active_start else self.start\n\n            # Beam of candidates; keep the one that best reduces distance to the other tree\n            best_cand = None\n            best_score = float('inf')\n            other_near_hint = None\n\n            for _ in range(self.beam_k):\n                # Sampling policy: goal-biased, corridor-guided, or uniform\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = base_corridor\n                    if c_best < float('inf'):\n                        width = max(self.step_size, 0.25 * (c_best - dsg) + base_corridor)\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                    continue\n\n                # Score: distance to nearest node in the other tree after this move\n                if other_near_hint is None:\n                    other_near_hint = self._nearest_grid(grid_b, tree_b, new_pos)\n                else:\n                    # refresh if new_pos is far from hint\n                    if self._dist(other_near_hint.position, new_pos) > 2.5 * self.step_size:\n                        other_near_hint = self._nearest_grid(grid_b, tree_b, new_pos)\n                if other_near_hint is None:\n                    score = self._dist(new_pos, root_other)\n                else:\n                    score = self._dist(new_pos, other_near_hint.position)\n                if score < best_score:\n                    best_score = score\n                    best_cand = (nearest, new_pos)\n\n            if best_cand is None:\n                continue\n\n            parent_node, new_pos = best_cand\n\n            # Insert node and edge (validated already)\n            new_cost = parent_node.cost + self._dist(parent_node.position, new_pos)\n            new_node = Node(new_pos, parent=parent_node, cost=new_cost)\n            parent_node.add_child(new_node)\n            tree_a.append(new_node)\n            self._edges_add(edges, parent_node, new_node)\n            self._grid_add(grid_a, new_node)\n\n            # On-the-fly grandparent compression\n            gp = parent_node.parent\n            if gp is not None:\n                # If LOS from grandparent to new_node, bypass parent to reduce nodes and cost\n                if not self._is_edge_in_obstacle(gp.position, new_node.position, obstacles, is_3d, self.edge_res):\n                    # Update edges/children coherently\n                    parent_node.remove_child(new_node)\n                    self._edges_remove(edges, parent_node, new_node)\n                    gp.add_child(new_node)\n                    self._edges_add(edges, gp, new_node)\n                    # Update cost\n                    new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n\n            # Try direct bridge to the nearest node in the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None and not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                path = self._extract_path(new_node, other_near)\n                c_best = self._path_length(path)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Short greedy connect toward new_node from the other tree\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if self._dist(p.position, to_pos) < self.step_size * self.min_sep_ratio:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(p.position, to_pos, obstacles, is_3d, self.edge_res):\n                    break\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                self._edges_add(edges, p, q)\n                self._grid_add(grid_b, q)\n                p = q\n                steps += 1\n\n                # Check bridge now\n                if not self._is_edge_in_obstacle(new_node.position, p.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, p)\n                    c_best = self._path_length(path)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------------- RNG ----------------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------------- Geometry ----------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------------- Collision ----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------------- Sampling ----------------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        # Sample around the start-goal line with axis-aligned jitter (cheap \"corridor\")\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        # Fallback to uniform if corridor sample is invalid\n        return self._sample_free(obstacles, is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---------------- Grid and neighbors ----------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Expand rings up to modest radius; fallback linear scan if needed\n        for r in range(0, 5):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan (rare with fine grid)\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # ---------------- Edges and costs ----------------\n    def _edges_add(self, edges, parent, child):\n        edges.append((parent, child))\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # ---------------- Paths ----------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        # Path A: root_A -> meet_a\n        path_a = self._path_to_root(meet_a)\n        # Path B: meet_b -> root_B (following parent links)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # Concatenate, implying a straight edge between meet_a and meet_b (validated before)\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        # Final LOS collapse forward\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            for k in range(1, len(pts) - 1):\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d, self.edge_res):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
                "objective": -20.0019,
                "time_improvement": 15.0,
                "length_improvement": 12.0,
                "smoothness_improvement": 1665.0,
                "node_improvement": 85.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.022508907318115234,
                        "num_nodes_avg": 61.9,
                        "path_length_avg": 173.37195960178056,
                        "smoothness_avg": 0.04856882636983518,
                        "success_improvement": 0.0,
                        "time_improvement": 11.725605588421473,
                        "node_improvement": 84.41198690506171,
                        "length_improvement": 4.972081687759297,
                        "smoothness_improvement": 660.2076015824708,
                        "objective_score": 9.801968697094374
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.04350669384002685,
                        "num_nodes_avg": 122.6,
                        "path_length_avg": 245.93388702328062,
                        "smoothness_avg": 0.11098748565610625,
                        "success_improvement": 0.0,
                        "time_improvement": 72.84181080292292,
                        "node_improvement": 91.76241349190352,
                        "length_improvement": 17.900189697186487,
                        "smoothness_improvement": 2755.78794698629,
                        "objective_score": 46.371596794120215
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.06773929595947266,
                        "num_nodes_avg": 163.7,
                        "path_length_avg": 132.06627662911285,
                        "smoothness_avg": 0.13189994478614067,
                        "success_improvement": 0.0,
                        "time_improvement": -38.09791603378091,
                        "node_improvement": 79.18626827717736,
                        "length_improvement": 12.287867383240805,
                        "smoothness_improvement": 1577.7575618385185,
                        "objective_score": 3.832133429002802
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "FlashConnect BiRRT (FC-BiRRT): a cache-accelerated bidirectional planner with throttled growth and corridor-guided micro-batches. It couples an adaptive hashed-nearest structure with a conservative edge-collision memo (blocked-edge cache), per-cell expansion throttling, and sparse \u201cleader\u201d fallbacks to avoid O(N) scans. Direct bridges and short greedy connects are attempted with cached checks; on success, a bounded shortcut and line-of-sight collapse return a clean path fast.",
            "planning_mechanism": "Mechanism: Initialize start/goal trees with grid buckets and sparse leaders. Each iteration alternates trees, samples a tiny beam (goal/corridor/uniform), steers once from the nearest, enforces node/edge validity, prunes duplicates and saturated cells, and keeps the candidate that best reduces distance to the other tree. Insert with optional grandparent LOS compression, then attempt a direct bridge; if blocked, execute a few greedy connect steps using the blocked-edge cache. On bridge, extract and lightly smooth the path; otherwise continue until the iteration cap.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=8.0,\n                 goal_bias=0.2,\n                 corridor_bias=0.55,\n                 beam_k=2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 connect_steps=5,\n                 smoothing_iters=18,\n                 min_sep_ratio=0.25,\n                 dupe_radius_ratio=0.5,\n                 cell_expand_limit=3,\n                 leader_stride=16):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.leader_stride = max(1, int(leader_stride))\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Setup grid and edge sampling step\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.8 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.4)))\n        self.cache_bin = max(1.0, self.edge_res)  # quantization for blocked-edge cache\n\n        # Validate start/goal and early LOS\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n        if not self._is_edge_in_obstacle(self.start, self.goal, obstacles, is_3d, self.edge_res):\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, [self.start, self.goal], nodes, [])\n\n        # Initialize trees, grids, leaders, edges, caches\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start, grid_goal = {}, {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        leaders_start, leaders_goal = [start_root], [goal_root]\n        cell_expands_start, cell_expands_goal = {}, {}\n\n        blocked_edge_cache = set()\n\n        # Corridor parameters\n        dsg = self._dist(self.start, self.goal)\n        base_corridor = max(self.step_size, 0.15 * dsg)\n        best_path_len = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            leaders_a = leaders_start if active_start else leaders_goal\n            leaders_b = leaders_goal if active_start else leaders_start\n            cell_count_a = cell_expands_start if active_start else cell_expands_goal\n            root_other = self.goal if active_start else self.start\n\n            # Candidate beam; keep one that best approaches the other tree\n            best_parent = None\n            best_newpos = None\n            best_score = float('inf')\n\n            for _ in range(self.beam_k):\n                # Sampling: goal-biased, corridor-guided, or uniform\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = base_corridor\n                    if best_path_len < float('inf'):\n                        width = max(self.step_size, 0.25 * (best_path_len - dsg) + base_corridor)\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_hashed(grid_a, tree_a, leaders_a, x_rand)\n                if nearest is None:\n                    continue\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n\n                # De-duplicate and throttle saturated cells\n                if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                kcell = self._grid_key(new_pos)\n                if cell_count_a.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n\n                # Edge validity with blocked-edge cache\n                if self._is_edge_blocked_cached(nearest.position, new_pos, obstacles, is_3d, blocked_edge_cache):\n                    continue\n\n                # Score: distance to nearest in opposite tree (leaders-assisted)\n                other_near = self._nearest_hashed(grid_b, tree_b, leaders_b, new_pos)\n                if other_near is not None:\n                    score = self._dist(new_pos, other_near.position)\n                else:\n                    score = self._dist(new_pos, root_other)\n\n                if score < best_score:\n                    best_score = score\n                    best_parent = nearest\n                    best_newpos = new_pos\n\n            if best_parent is None:\n                continue\n\n            # Final validity before insertion (both checks)\n            if self._is_in_obstacle(best_newpos, obstacles, is_3d):\n                continue\n            if self._is_edge_blocked_cached(best_parent.position, best_newpos, obstacles, is_3d, blocked_edge_cache):\n                continue\n\n            # Insert node and edge\n            new_cost = best_parent.cost + self._dist(best_parent.position, best_newpos)\n            new_node = Node(best_newpos, parent=best_parent, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            self._edges_add(edges, best_parent, new_node)\n            self._grid_add(grid_a, new_node)\n            # Update per-cell throttle\n            kc = self._grid_key(new_node.position)\n            cell_count_a[kc] = cell_count_a.get(kc, 0) + 1\n            # Sparse leaders\n            if len(tree_a) % self.leader_stride == 0:\n                leaders_a.append(new_node)\n\n            # On-the-fly grandparent compression\n            gp = best_parent.parent\n            if gp is not None:\n                if not self._is_edge_blocked_cached(gp.position, new_node.position, obstacles, is_3d, blocked_edge_cache):\n                    best_parent.remove_child(new_node)\n                    self._edges_remove(edges, best_parent, new_node)\n                    gp.add_child(new_node)\n                    self._edges_add(edges, gp, new_node)\n                    new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n\n            # Attempt direct bridge to nearest in the other tree\n            other_near = self._nearest_hashed(grid_b, tree_b, leaders_b, new_node.position)\n            if other_near is not None and not self._is_edge_blocked_cached(new_node.position, other_near.position, obstacles, is_3d, blocked_edge_cache):\n                path = self._extract_path(new_node, other_near)\n                best_path_len = self._path_length(path)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Short greedy connect from the other tree toward the new node\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if self._dist(p.position, to_pos) < self.step_size * self.min_sep_ratio:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(grid_b, to_pos, self.step_size * self.dupe_radius_ratio):\n                    break\n                if self._is_edge_blocked_cached(p.position, to_pos, obstacles, is_3d, blocked_edge_cache):\n                    break\n\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                self._edges_add(edges, p, q)\n                self._grid_add(grid_b, q)\n                # leaders and per-cell throttle for tree_b\n                if len(tree_b) % self.leader_stride == 0:\n                    leaders_b.append(q)\n                kc_b = self._grid_key(q.position)\n                if active_start:\n                    cell_expands_goal[kc_b] = cell_expands_goal.get(kc_b, 0) + 1\n                else:\n                    cell_expands_start[kc_b] = cell_expands_start.get(kc_b, 0) + 1\n\n                p = q\n                steps += 1\n\n                # Check bridge now\n                if not self._is_edge_blocked_cached(new_node.position, p.position, obstacles, is_3d, blocked_edge_cache):\n                    path = self._extract_path(new_node, p)\n                    best_path_len = self._path_length(path)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # RNG\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _is_edge_blocked_cached(self, a, b, obstacles, is_3d, blocked_cache):\n        key = self._edge_key_q(a, b)\n        if key in blocked_cache:\n            return True\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n        if blocked:\n            blocked_cache.add(key)\n        return blocked\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # Grid and neighbors\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, leaders, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Limited rings, then leader fallback to avoid O(N)\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fall back to leaders (sparse)\n        for n in leaders:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # Fallback full scan (rare)\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # Edges\n    def _edges_add(self, edges, parent, child):\n        edges.append((parent, child))\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        # Forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            for k in range(1, len(pts) - 1):\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d, self.edge_res):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
            "objective": -14.73772,
            "time_improvement": 1.0,
            "length_improvement": 9.0,
            "smoothness_improvement": 1829.0,
            "node_improvement": 84.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03957667350769043,
                    "num_nodes_avg": 89.6,
                    "path_length_avg": 173.3707237388481,
                    "smoothness_avg": 0.05077321918948241,
                    "success_improvement": 0.0,
                    "time_improvement": -55.2099725384924,
                    "node_improvement": 77.43641400151094,
                    "length_improvement": 4.972759083816072,
                    "smoothness_improvement": 694.711136125575,
                    "objective_score": -10.105780630630203
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05332317352294922,
                    "num_nodes_avg": 145.0,
                    "path_length_avg": 246.8569464197752,
                    "smoothness_avg": 0.11933221064521529,
                    "success_improvement": 0.0,
                    "time_improvement": 66.7140684040557,
                    "node_improvement": 90.25734058993481,
                    "length_improvement": 17.592045901845015,
                    "smoothness_improvement": 2970.5037314185306,
                    "objective_score": 45.42196671941637
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.052624630928039554,
                    "num_nodes_avg": 134.3,
                    "path_length_avg": 145.60396458843502,
                    "smoothness_avg": 0.1510094522023601,
                    "success_improvement": 0.0,
                    "time_improvement": -7.284136338781219,
                    "node_improvement": 82.92434837889384,
                    "length_improvement": 3.2967796360860238,
                    "smoothness_improvement": 1820.829085655716,
                    "objective_score": 8.896972308295828
                }
            ],
            "success_rate": 1.0
        },
        "objective": 6.2,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Nearest-neighbor queries frequently degrade to full scans due to limited grid rings and coarse bucketization, creating repeated O(N) costs across sampling, bridge, and connect phases.\n   - Repeated edge-collision evaluations at fixed resolution without memoization, leading to redundant work around the same blocked segments.\n   - Uncontrolled growth in saturated regions (no per-cell throttling), causing clustered insertions, duplicate attempts, and wasted expansions; duplicate suppression absent during connect steps.\n   - Aggressive post-processing (high smoothing iterations) adds nontrivial tail latency.\n   - Short greedy connects often build multiple tentative nodes before discovering blockage, inflating collision checks and insert/remove overhead."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Cached blocked-edge checks with quantized keys to reuse collision results across steer/bridge/connect/compression.\n   - Hashed nearest search with limited rings plus sparse \u201cleader\u201d fallbacks to avoid frequent full-tree scans.\n   - Per-cell expansion throttling to cap insertions in saturated grid cells and reduce redundant sampling.\n   - Duplicate suppression added to the connect phase, plus slightly reduced connect steps.\n   - Lower smoothing iterations and a coarser neighbor grid tuned for faster lookups, aided by stronger corridor/goal bias.\n2. Expected mechanism of impact:\n   - Fewer O(N) nearest-neighbor fallbacks and fewer collision evaluations per iteration, cutting the dominant per-step costs.\n   - Cache hits eliminate repeated edge checks along obstacle boundaries and during repeated bridge attempts.\n   - Throttling and connect de-duplication reduce node proliferation in dense areas, lowering insertion and validation workload.\n   - Increased directional bias and leader guidance shorten the time to a viable bridge, reducing total iterations before success.\n   - Reduced post-processing work shortens end-to-end planning time."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "Adaptive Goal-Biased Grid BiRRT (AG-GBiRRT): a simplified, robust bidirectional RRT with commit-only connection, grid-accelerated nearest search, and light post-connection shortcut smoothing. It alternates growing two trees, uses uniform-with-goal-bias sampling, single-step steering with strict node/edge collision checks, and an early straight-line test. Upon any successful bridge between trees, it extracts the path and performs a few inexpensive shortcuts for smoothness, returning quickly without extra rewiring or bloat.",
                "planning_mechanism": "Mechanism: alternate start/goal tree expansion; sample (goal-biased), find nearest via grid, steer one step, validate node and edge, add node and edge, attempt a direct, collision-free bridge to the opposite tree (commit-only); on success, extract [start\u2192\u2026\u2192meetA, meetB\u2192\u2026\u2192goal] and run brief shortcut smoothing; terminate on success or iteration budget.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.0)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                continue\n\n            # Insert node (both node and edge validated)\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Try commit-only direct connection to the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None:\n                if not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, other_near)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        try:\n            return self._lcg_next()\n        except:\n            return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Sampling ----------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ---------- Grid nearest ----------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # ---------- Path ----------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # path_a ends at meet_a; we then go straight to meet_b and up to other root\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            # pick two indices i < j with at least one point between\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
                "objective": -32.96764,
                "time_improvement": 69.0,
                "length_improvement": 11.0,
                "smoothness_improvement": 1142.0,
                "node_improvement": 82.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.01299290657043457,
                        "num_nodes_avg": 78.8,
                        "path_length_avg": 167.86786188508313,
                        "smoothness_avg": 0.03825680999831742,
                        "success_improvement": 0.0,
                        "time_improvement": 49.04501835909778,
                        "node_improvement": 80.15613195668597,
                        "length_improvement": 7.988964864290817,
                        "smoothness_improvement": 498.8021524662562,
                        "objective_score": 22.000895188635106
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.02625594139099121,
                        "num_nodes_avg": 208.9,
                        "path_length_avg": 244.3021244779086,
                        "smoothness_avg": 0.07331771296729457,
                        "success_improvement": 0.0,
                        "time_improvement": 83.61025026480232,
                        "node_improvement": 85.96385137405093,
                        "length_improvement": 18.444919002512343,
                        "smoothness_improvement": 1786.5175632625994,
                        "objective_score": 45.082614297261095
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.01305999755859375,
                        "num_nodes_avg": 163.0,
                        "path_length_avg": 140.27860161008172,
                        "smoothness_avg": 0.09759083301298958,
                        "success_improvement": 0.0,
                        "time_improvement": 73.37500455677744,
                        "node_improvement": 79.27527018436109,
                        "length_improvement": 6.833632159773637,
                        "smoothness_improvement": 1141.348192519241,
                        "objective_score": 31.819421625493614
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "HASTE-BiRRT: Hashed, Anytime, Saturation\u2011Throttled, Efficient BiRRT-Connect. It accelerates bidirectional RRT with cached collision tests, hashed nearest search with leader fallbacks, per-cell growth throttling, and duplicate-suppressed commit-only connections. A light visibility prune plus brief shortcutting refines the path while keeping postprocessing costs low.",
            "planning_mechanism": "Alternate expanding start/goal trees with goal-biased sampling; find nearest via grid rings, else leader-guided buckets; steer one step and validate with cached edge checks; suppress inserts in saturated/duplicate cells; attempt a single, commit-only direct bridge to the opposite tree, skipping known-blocked cell pairs; upon success, extract start-to-goal path, visibility-prune, then run a few shortcuts; terminate on success or iteration cap.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=7.0,\n                 goal_bias=0.25,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=40,\n                 max_per_cell=6,\n                 search_r_max=2,\n                 leader_stride=25):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.max_per_cell = max_per_cell\n        self.search_r_max = search_r_max\n        self.leader_stride = leader_stride\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # Caches\n        self._edge_blocked_cache = set()   # quantized blocked segments (safe to reuse only for blocked)\n        self._edge_exact_cache = {}        # exact endpoint pairs -> bool\n        self._connect_blocked_cells = set()  # (cellA, cellB) pairs known to fail direct connect\n\n    # ------------- Public API -------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Parameters derived\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.5)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Reset caches\n        self._edge_blocked_cache = set()\n        self._edge_exact_cache = {}\n        self._connect_blocked_cells = set()\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Grids and counts\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        self._grid_add(grid_start, counts_start, start_root)\n        self._grid_add(grid_goal, counts_goal, goal_root)\n\n        # Leaders\n        leaders_start = [start_root]\n        leaders_goal = [goal_root]\n        inserted_since_leader_start = 0\n        inserted_since_leader_goal = 0\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            grid_a = grid_start if active_start else grid_goal\n            counts_a = counts_start if active_start else counts_goal\n            leaders_a = leaders_start if active_start else leaders_goal\n\n            tree_b = goal_tree if active_start else start_tree\n            grid_b = grid_goal if active_start else grid_start\n            counts_b = counts_goal if active_start else counts_start\n            leaders_b = leaders_goal if active_start else leaders_start\n\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest lookup\n            nearest = self._nearest_hashed(grid_a, leaders_a, tree_a, x_rand)\n            if nearest is None:\n                continue\n\n            # Steer\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Per-cell throttling and duplicate suppression\n            key_new = self._grid_key(new_pos)\n            if self._cell_count(counts_a, key_new) >= self.max_per_cell:\n                continue\n            if self._near_duplicate(grid_a, new_pos, dup_radius=0.7 * self.step_size):\n                continue\n\n            # Insert node and edge\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, counts_a, new_node)\n\n            # Leader sampling\n            if active_start:\n                inserted_since_leader_start += 1\n                if inserted_since_leader_start >= self.leader_stride:\n                    leaders_start.append(new_node)\n                    inserted_since_leader_start = 0\n            else:\n                inserted_since_leader_goal += 1\n                if inserted_since_leader_goal >= self.leader_stride:\n                    leaders_goal.append(new_node)\n                    inserted_since_leader_goal = 0\n\n            # Try commit-only direct connection to the other tree (with cell-pair de-dup)\n            other_near = self._nearest_hashed(grid_b, leaders_b, tree_b, new_node.position)\n            if other_near is not None:\n                pair_key = (self._grid_key(new_node.position), self._grid_key(other_near.position))\n                if pair_key not in self._connect_blocked_cells:\n                    if not self._edge_blocked(new_node.position, other_near.position, obstacles, is_3d):\n                        path = self._extract_path(new_node, other_near, a_is_start_tree=active_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n                    else:\n                        # cache blocked cell pair to avoid repeating futile checks\n                        self._connect_blocked_cells.add(pair_key)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ------------- Random -------------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry -------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ------------- Collision & caches -------------\n    def _quant(self, p, q=1.5):\n        # Quantize for blocked-segment cache; coarse to avoid false frees; safe for blocked reuse only\n        if self.dim == 3:\n            return (int(p[0] // q), int(p[1] // q), int(p[2] // q))\n        else:\n            return (int(p[0] // q), int(p[1] // q))\n\n    def _seg_key_exact(self, a, b):\n        # Canonicalize order for undirected segment\n        if a <= b:\n            return (a, b)\n        else:\n            return (b, a)\n\n    def _seg_key_quant_blocked(self, a, b):\n        qa = self._quant(a)\n        qb = self._quant(b)\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        # Exact cache check\n        k_exact = self._seg_key_exact(a, b)\n        cached = self._edge_exact_cache.get(k_exact)\n        if cached is not None:\n            return cached\n        # Blocked quantized cache\n        kq = self._seg_key_quant_blocked(a, b)\n        if kq in self._edge_blocked_cache:\n            self._edge_exact_cache[k_exact] = True\n            return True\n        # Compute\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n        # Update caches\n        self._edge_exact_cache[k_exact] = blocked\n        if blocked:\n            self._edge_blocked_cache.add(kq)\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ------------- Sampling -------------\n    def _sample_free(self, obstacles, is_3d):\n        # Rejection sampling within bounds until a free point is found\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ------------- Grid / NN -------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n\n    def _cell_count(self, counts, key):\n        return counts.get(key, 0)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, leaders, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Local rings\n        for r in range(0, self.search_r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Leader fallback\n        if leaders:\n            lead_best = None\n            lead_bestd = float('inf')\n            for n in leaders:\n                d = self._dist(n.position, pos)\n                if d < lead_bestd:\n                    lead_bestd = d\n                    lead_best = n\n            if lead_best is not None:\n                # Search around leader cell for neighbors\n                lk = self._grid_key(lead_best.position)\n                for r in range(0, min(2, self.search_r_max) + 1):\n                    cand = self._grid_ring_collect(grid, lk, r)\n                    for n in cand:\n                        d = self._dist(n.position, pos)\n                        if d < bestd:\n                            bestd = d\n                            best = n\n                if best is not None:\n                    return best\n        # Sparse random subset fallback (avoid full scan)\n        if tree:\n            trials = min(64, len(tree))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            if best is not None:\n                return best\n        return None\n\n    def _near_duplicate(self, grid, pos, dup_radius):\n        key = self._grid_key(pos)\n        r = 1\n        cand = self._grid_ring_collect(grid, key, r)\n        rr = dup_radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # ------------- Path -------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            # start-tree path to meet, then meet->goal via reversed goal-tree path\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
            "objective": -35.78786,
            "time_improvement": 66.0,
            "length_improvement": 12.0,
            "smoothness_improvement": 1772.0,
            "node_improvement": 88.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016536712646484375,
                    "num_nodes_avg": 67.3,
                    "path_length_avg": 176.25078259592178,
                    "smoothness_avg": 0.05067539409595988,
                    "success_improvement": 0.0,
                    "time_improvement": 35.1470831615236,
                    "node_improvement": 83.05212792747419,
                    "length_improvement": 3.3941531868009323,
                    "smoothness_improvement": 693.1799609813568,
                    "objective_score": 16.046516665444422
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023010659217834472,
                    "num_nodes_avg": 105.2,
                    "path_length_avg": 247.25890321415372,
                    "smoothness_avg": 0.1191098532602342,
                    "success_improvement": 0.0,
                    "time_improvement": 85.63605318102866,
                    "node_improvement": 92.93153262111133,
                    "length_improvement": 17.45786115419664,
                    "smoothness_improvement": 2964.7823157454163,
                    "objective_score": 50.989444225553655
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.011754655838012695,
                    "num_nodes_avg": 94.4,
                    "path_length_avg": 127.41557160345823,
                    "smoothness_avg": 0.13822063405561777,
                    "success_improvement": 0.0,
                    "time_improvement": 76.0361625858193,
                    "node_improvement": 87.99745708836618,
                    "length_improvement": 15.376644218505373,
                    "smoothness_improvement": 1658.156262801516,
                    "objective_score": 40.327616620856595
                }
            ],
            "success_rate": 1.0
        },
        "objective": 40.800000000000004,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Costly nearest-neighbor lookups that often fall back to full linear scans when local buckets are empty, increasing per-iteration time.\n   - Repeated edge collision evaluations without memoization, re-checking the same or similar segments many times.\n   - Uncontrolled growth in saturated regions (no per-cell throttling or duplicate suppression), inflating node count and future query costs.\n   - Repeated futile cross-tree connection attempts through the same blocked corridors, with no memory of failed cell-pairs.\n   - Heavy postprocessing (many shortcut iterations) and no early visibility pruning, leading to excessive collision checks after a solution is found.\n   - Parameter choices that increase iteration count (lower goal bias and conservative stepping) in open or mildly cluttered spaces."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Localized hashed nearest-neighbor search with frontier-leader fallback and small random subsets, avoiding most full-tree scans.\n   - Collision-check caching (exact and quantized blocked segments) plus cell-pair caching for failed direct connections.\n   - Per-cell saturation throttling and near-duplicate suppression to limit redundant node insertions.\n   - Early visibility pruning and a reduced shortcut budget aligned with cached collision checks.\n   - Slightly more goal-directed sampling and step sizing, and grid cells tuned to the step to reduce lookup overhead.\n2. Expected mechanism of impact:\n   - Lower per-iteration cost by replacing O(n) scans with bounded local searches and frequent cache hits.\n   - Fewer total expansions and collision tests by suppressing redundant nodes and skipping known-blocked connections.\n   - Reduced postprocessing time through pre-pruning and fewer shortcut iterations on a shorter waypoint list.\n   - Faster convergence to a meeting configuration via mild goal bias and larger strides, cutting total iterations needed."
        }
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "FlashConnect BiRRT (FC-BiRRT): a cache-accelerated bidirectional planner with throttled growth and corridor-guided micro-batches. It couples an adaptive hashed-nearest structure with a conservative edge-collision memo (blocked-edge cache), per-cell expansion throttling, and sparse \u201cleader\u201d fallbacks to avoid O(N) scans. Direct bridges and short greedy connects are attempted with cached checks; on success, a bounded shortcut and line-of-sight collapse return a clean path fast.",
                "planning_mechanism": "Mechanism: Initialize start/goal trees with grid buckets and sparse leaders. Each iteration alternates trees, samples a tiny beam (goal/corridor/uniform), steers once from the nearest, enforces node/edge validity, prunes duplicates and saturated cells, and keeps the candidate that best reduces distance to the other tree. Insert with optional grandparent LOS compression, then attempt a direct bridge; if blocked, execute a few greedy connect steps using the blocked-edge cache. On bridge, extract and lightly smooth the path; otherwise continue until the iteration cap.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=8.0,\n                 goal_bias=0.2,\n                 corridor_bias=0.55,\n                 beam_k=2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 connect_steps=5,\n                 smoothing_iters=18,\n                 min_sep_ratio=0.25,\n                 dupe_radius_ratio=0.5,\n                 cell_expand_limit=3,\n                 leader_stride=16):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.leader_stride = max(1, int(leader_stride))\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Setup grid and edge sampling step\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.8 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.4)))\n        self.cache_bin = max(1.0, self.edge_res)  # quantization for blocked-edge cache\n\n        # Validate start/goal and early LOS\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n        if not self._is_edge_in_obstacle(self.start, self.goal, obstacles, is_3d, self.edge_res):\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, [self.start, self.goal], nodes, [])\n\n        # Initialize trees, grids, leaders, edges, caches\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start, grid_goal = {}, {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        leaders_start, leaders_goal = [start_root], [goal_root]\n        cell_expands_start, cell_expands_goal = {}, {}\n\n        blocked_edge_cache = set()\n\n        # Corridor parameters\n        dsg = self._dist(self.start, self.goal)\n        base_corridor = max(self.step_size, 0.15 * dsg)\n        best_path_len = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            leaders_a = leaders_start if active_start else leaders_goal\n            leaders_b = leaders_goal if active_start else leaders_start\n            cell_count_a = cell_expands_start if active_start else cell_expands_goal\n            root_other = self.goal if active_start else self.start\n\n            # Candidate beam; keep one that best approaches the other tree\n            best_parent = None\n            best_newpos = None\n            best_score = float('inf')\n\n            for _ in range(self.beam_k):\n                # Sampling: goal-biased, corridor-guided, or uniform\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = base_corridor\n                    if best_path_len < float('inf'):\n                        width = max(self.step_size, 0.25 * (best_path_len - dsg) + base_corridor)\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_hashed(grid_a, tree_a, leaders_a, x_rand)\n                if nearest is None:\n                    continue\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n\n                # De-duplicate and throttle saturated cells\n                if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                kcell = self._grid_key(new_pos)\n                if cell_count_a.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n\n                # Edge validity with blocked-edge cache\n                if self._is_edge_blocked_cached(nearest.position, new_pos, obstacles, is_3d, blocked_edge_cache):\n                    continue\n\n                # Score: distance to nearest in opposite tree (leaders-assisted)\n                other_near = self._nearest_hashed(grid_b, tree_b, leaders_b, new_pos)\n                if other_near is not None:\n                    score = self._dist(new_pos, other_near.position)\n                else:\n                    score = self._dist(new_pos, root_other)\n\n                if score < best_score:\n                    best_score = score\n                    best_parent = nearest\n                    best_newpos = new_pos\n\n            if best_parent is None:\n                continue\n\n            # Final validity before insertion (both checks)\n            if self._is_in_obstacle(best_newpos, obstacles, is_3d):\n                continue\n            if self._is_edge_blocked_cached(best_parent.position, best_newpos, obstacles, is_3d, blocked_edge_cache):\n                continue\n\n            # Insert node and edge\n            new_cost = best_parent.cost + self._dist(best_parent.position, best_newpos)\n            new_node = Node(best_newpos, parent=best_parent, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            self._edges_add(edges, best_parent, new_node)\n            self._grid_add(grid_a, new_node)\n            # Update per-cell throttle\n            kc = self._grid_key(new_node.position)\n            cell_count_a[kc] = cell_count_a.get(kc, 0) + 1\n            # Sparse leaders\n            if len(tree_a) % self.leader_stride == 0:\n                leaders_a.append(new_node)\n\n            # On-the-fly grandparent compression\n            gp = best_parent.parent\n            if gp is not None:\n                if not self._is_edge_blocked_cached(gp.position, new_node.position, obstacles, is_3d, blocked_edge_cache):\n                    best_parent.remove_child(new_node)\n                    self._edges_remove(edges, best_parent, new_node)\n                    gp.add_child(new_node)\n                    self._edges_add(edges, gp, new_node)\n                    new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n\n            # Attempt direct bridge to nearest in the other tree\n            other_near = self._nearest_hashed(grid_b, tree_b, leaders_b, new_node.position)\n            if other_near is not None and not self._is_edge_blocked_cached(new_node.position, other_near.position, obstacles, is_3d, blocked_edge_cache):\n                path = self._extract_path(new_node, other_near)\n                best_path_len = self._path_length(path)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Short greedy connect from the other tree toward the new node\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if self._dist(p.position, to_pos) < self.step_size * self.min_sep_ratio:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(grid_b, to_pos, self.step_size * self.dupe_radius_ratio):\n                    break\n                if self._is_edge_blocked_cached(p.position, to_pos, obstacles, is_3d, blocked_edge_cache):\n                    break\n\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                self._edges_add(edges, p, q)\n                self._grid_add(grid_b, q)\n                # leaders and per-cell throttle for tree_b\n                if len(tree_b) % self.leader_stride == 0:\n                    leaders_b.append(q)\n                kc_b = self._grid_key(q.position)\n                if active_start:\n                    cell_expands_goal[kc_b] = cell_expands_goal.get(kc_b, 0) + 1\n                else:\n                    cell_expands_start[kc_b] = cell_expands_start.get(kc_b, 0) + 1\n\n                p = q\n                steps += 1\n\n                # Check bridge now\n                if not self._is_edge_blocked_cached(new_node.position, p.position, obstacles, is_3d, blocked_edge_cache):\n                    path = self._extract_path(new_node, p)\n                    best_path_len = self._path_length(path)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # RNG\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _is_edge_blocked_cached(self, a, b, obstacles, is_3d, blocked_cache):\n        key = self._edge_key_q(a, b)\n        if key in blocked_cache:\n            return True\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n        if blocked:\n            blocked_cache.add(key)\n        return blocked\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # Grid and neighbors\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, leaders, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Limited rings, then leader fallback to avoid O(N)\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fall back to leaders (sparse)\n        for n in leaders:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # Fallback full scan (rare)\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # Edges\n    def _edges_add(self, edges, parent, child):\n        edges.append((parent, child))\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        # Forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            for k in range(1, len(pts) - 1):\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d, self.edge_res):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
                "objective": -14.73772,
                "time_improvement": 1.0,
                "length_improvement": 9.0,
                "smoothness_improvement": 1829.0,
                "node_improvement": 84.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.03957667350769043,
                        "num_nodes_avg": 89.6,
                        "path_length_avg": 173.3707237388481,
                        "smoothness_avg": 0.05077321918948241,
                        "success_improvement": 0.0,
                        "time_improvement": -55.2099725384924,
                        "node_improvement": 77.43641400151094,
                        "length_improvement": 4.972759083816072,
                        "smoothness_improvement": 694.711136125575,
                        "objective_score": -10.105780630630203
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.05332317352294922,
                        "num_nodes_avg": 145.0,
                        "path_length_avg": 246.8569464197752,
                        "smoothness_avg": 0.11933221064521529,
                        "success_improvement": 0.0,
                        "time_improvement": 66.7140684040557,
                        "node_improvement": 90.25734058993481,
                        "length_improvement": 17.592045901845015,
                        "smoothness_improvement": 2970.5037314185306,
                        "objective_score": 45.42196671941637
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.052624630928039554,
                        "num_nodes_avg": 134.3,
                        "path_length_avg": 145.60396458843502,
                        "smoothness_avg": 0.1510094522023601,
                        "success_improvement": 0.0,
                        "time_improvement": -7.284136338781219,
                        "node_improvement": 82.92434837889384,
                        "length_improvement": 3.2967796360860238,
                        "smoothness_improvement": 1820.829085655716,
                        "objective_score": 8.896972308295828
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m1",
                "algorithm_description": "Beam-guided BiRRT with ancestor line-of-sight compression and spatial hashing (BG-Connect-LOS). The planner alternates tree growth from start and goal using a small beam of guided samples, accelerates nearest lookups with a grid hash, suppresses near-duplicate nodes, and selects a parent among recent ancestors that maintains direct line-of-sight to the new point to compress chains. A short, capped greedy connect links the two trees. Upon success, a bounded shortcut pass refines the path. This reduces expansions and collision checks while improving path quality and smoothness.",
                "planning_mechanism": "At each iteration, pick the active tree and generate a small beam of guided samples biased toward the opposite root. For each sample: find a nearby node via spatial hashing, steer by a fixed step, enforce node and edge collision checks, reject near-duplicates, and pick an ancestor parent with clear line-of-sight to minimize added cost. Insert the node and attempt a capped greedy connect from the opposite tree toward it; if the two trees meet, extract and lightly shortcut the path. Alternate trees and stop early on success.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        beam_width=3,\n        goal_bias=0.15,\n        connect_steps_limit=20,\n        min_separation_factor=0.6,\n        grid_cell_factor=1.0,\n        los_lookback_depth=8,\n        shortcut_attempts=40\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.connect_steps_limit = connect_steps_limit\n        self.min_separation_factor = min_separation_factor\n        self.grid_cell_factor = grid_cell_factor\n        self.los_lookback_depth = los_lookback_depth\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dims = len(bounds)\n        is_3d = dims == 3\n\n        # Parameters derived from step_size\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root = Node(goal_position, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root, is_3d)\n        self._grid_insert(grid_b, goal_root, is_3d)\n\n        success_state = False\n        extracted_path = []\n\n        for _ in range(self.max_iter):\n            # Alternate trees by swapping references each loop\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, goal_position),\n                (tree_b, grid_b, tree_a, grid_a, start_position),\n            ]:\n                made_progress = False\n\n                for _beam in range(self.beam_width):\n                    sample = self._sample_guided(bounds, obstacles, is_3d, attractor)\n\n                    nearest = self._nearest_by_grid(active_tree, active_grid, sample, is_3d)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos, bounds):\n                        continue\n                    if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                        continue\n                    if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                        continue\n                    if self._has_near_duplicate(active_grid, new_pos, self.min_separation, is_3d):\n                        continue\n\n                    # Choose parent among LOS-capable ancestors to compress path\n                    parent = self._choose_ancestor_parent(nearest, new_pos, obstacles, is_3d)\n                    new_cost = parent.cost + self._distance(parent.position, new_pos)\n\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node, is_3d)\n                    made_progress = True\n\n                    # Try capped greedy connect from the opposite tree toward new_node\n                    connect_node = self._attempt_connect(\n                        other_tree, other_grid, new_node.position, obstacles, is_3d, nodes, edges, bounds\n                    )\n                    if connect_node is not None:\n                        # Trees meet at new_node.position; extract path\n                        path_a = self._path_from_root(new_node)\n                        path_b = self._path_from_root(connect_node)\n                        # Remove duplicate joint if equal\n                        if path_a and path_b and path_a[-1] == path_b[-1]:\n                            path_b = path_b[:-1]\n                        raw_path = path_a + path_b[::-1]\n                        # Light shortcut smoothing\n                        smoothed = self._shortcut_path(raw_path, obstacles, is_3d, attempts=self.shortcut_attempts)\n                        extracted_path = smoothed if smoothed else raw_path\n                        success_state = True\n                        return PlannerResult(True, extracted_path, nodes, edges)\n\n                # If neither beam sample made progress for this tree, continue with the other\n                if not made_progress:\n                    continue\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # --------- Core Geometry / Utilities ---------\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _within_bounds(self, pos, bounds):\n        for i in range(len(bounds)):\n            if pos[i] < 0.0 or pos[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= 1e-9:\n            return from_pos\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * r for d in range(len(from_pos)))\n\n    def _sample_guided(self, bounds, obstacles, is_3d, target):\n        # Mild guidance: with some probability sample exactly target, else blend toward target\n        while True:\n            if random.random() < self.goal_bias:\n                p = target\n            else:\n                rand = tuple(random.uniform(0.0, bounds[d]) for d in range(len(bounds)))\n                alpha = 0.2\n                p = tuple(alpha * target[d] + (1.0 - alpha) * rand[d] for d in range(len(bounds)))\n            if self._within_bounds(p, bounds) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _path_from_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\n\n    # --------- Spatial Hash (Grid) ---------\n\n    def _cell_of(self, pos):\n        # integer grid cell indices\n        if len(pos) == 3:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        else:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node, is_3d):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _has_near_duplicate(self, grid, pos, radius, is_3d):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    def _nearest_by_grid(self, tree, grid, pos, is_3d, ring_limit=3):\n        # Search neighborhood rings; fallback to linear scan if not found\n        cell = self._cell_of(pos)\n        best = None\n        best_d = float(\"inf\")\n\n        if is_3d:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best_d = d\n                                        best = n\n                                        found = True\n                if found and best is not None:\n                    return best\n        else:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                                    found = True\n                if found and best is not None:\n                    return best\n\n        # Fallback\n        if not tree:\n            return None\n        return min(tree, key=lambda n: self._distance(n.position, pos))\n\n    # --------- Parent selection via LOS to ancestors ---------\n\n    def _choose_ancestor_parent(self, nearest, new_pos, obstacles, is_3d):\n        best_parent = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        steps = 0\n        cur = nearest\n        while cur is not None and steps < self.los_lookback_depth:\n            if not self._is_edge_in_obstacle(cur.position, new_pos, obstacles, is_3d):\n                cand_cost = cur.cost + self._distance(cur.position, new_pos)\n                if cand_cost < best_cost:\n                    best_cost = cand_cost\n                    best_parent = cur\n            cur = cur.parent\n            steps += 1\n        return best_parent\n\n    # --------- Connect attempt ---------\n\n    def _attempt_connect(self, tree, grid, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest_by_grid(tree, grid, target_pos, is_3d)\n        if nearest is None:\n            return None\n\n        current = nearest\n        for _ in range(self.connect_steps_limit):\n            step_pos = self._steer(current.position, target_pos)\n            if not self._within_bounds(step_pos, bounds):\n                return None\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                return None\n\n            # If close enough to target and direct edge exists, finalize with exact target node\n            if self._distance(step_pos, target_pos) <= 1e-6 or (\n                self._distance(step_pos, target_pos) <= self.step_size and\n                not self._is_edge_in_obstacle(step_pos, target_pos, obstacles, is_3d) and\n                not self._is_in_obstacle(target_pos, obstacles, is_3d)\n            ):\n                # Add intermediate step node if it is not exactly current\n                if self._distance(current.position, step_pos) > 1e-9:\n                    if not self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                        new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n                        current.add_child(new_node)\n                        tree.append(new_node)\n                        nodes.append(new_node)\n                        edges.append((current, new_node))\n                        self._grid_insert(grid, new_node, is_3d)\n                        current = new_node\n                    else:\n                        # If duplicate exists, try using current as is\n                        pass\n                # Add final node at the exact target position to guarantee path merge\n                final_node = Node(target_pos, parent=current, cost=current.cost + self._distance(current.position, target_pos))\n                current.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((current, final_node))\n                self._grid_insert(grid, final_node, is_3d)\n                return final_node\n\n            # Regular step addition with duplicate suppression\n            if self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                # Progress is negligible; stop trying to avoid loops\n                return None\n\n            new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node, is_3d)\n            current = new_node\n\n        return None\n\n    # --------- Collision Checking ---------\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d):\n        distance = self._distance(from_pos, to_pos)\n        resolution = max(0.5, min(1.0, self.step_size * 0.5))\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    # --------- Shortcut Smoothing (bounded) ---------\n\n    def _shortcut_path(self, path, obstacles, is_3d, attempts=40):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        n = len(pts)\n        tries = 0\n        i = 0\n        # Greedy forward skipping with bounded iterations\n        while i < len(pts) - 2 and tries < attempts:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                    # Remove intermediates\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n            tries += 1\n        return pts",
                "objective": -28.86257,
                "time_improvement": 43.0,
                "length_improvement": 15.0,
                "smoothness_improvement": 1410.0,
                "node_improvement": 90.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.03400664329528809,
                        "num_nodes_avg": 52.1,
                        "path_length_avg": 171.51876006638196,
                        "smoothness_avg": 0.050501544373221775,
                        "success_improvement": 0.0,
                        "time_improvement": -33.36568499023374,
                        "node_improvement": 86.87987912364643,
                        "length_improvement": 5.987849718937115,
                        "smoothness_improvement": 690.45883529979,
                        "objective_score": -2.964701489208901
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.030187082290649415,
                        "num_nodes_avg": 92.2,
                        "path_length_avg": 234.31486940525366,
                        "smoothness_avg": 0.08620583217892899,
                        "success_improvement": 0.0,
                        "time_improvement": 81.1563136658539,
                        "node_improvement": 93.8050124302896,
                        "length_improvement": 21.77895221296278,
                        "smoothness_improvement": 2118.138153515002,
                        "objective_score": 48.004956195108846
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.009754443168640136,
                        "num_nodes_avg": 73.2,
                        "path_length_avg": 124.45355479806292,
                        "smoothness_avg": 0.11960663519260235,
                        "success_improvement": 0.0,
                        "time_improvement": 80.11393158758125,
                        "node_improvement": 90.69294342021614,
                        "length_improvement": 17.343874744565582,
                        "smoothness_improvement": 1421.3875712064366,
                        "objective_score": 41.54744217904591
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "cross_over",
            "algorithm_description": "IBEX-BiRRT (Informed Beam EXploration BiRRT): a bidirectional planner that couples ellipse-informed beam sampling with dual-state edge memoization, anchor-guided hashed nearest search, and local LOS-based parent selection. It throttles per-cell growth, rejects near-duplicates, and performs micro-connect probes with cached collision results. A provisional path immediately activates an informed ellipse to focus sampling; final paths are lightly shortcut and LOS-collapsed for length and smoothness.",
            "planning_mechanism": "Alternate growing start/goal trees. For each side, generate a small beam of samples from goal/corridor/uniform, switching to ellipse-informed sampling once a path exists. For each sample: find a near node via grid+anchors, steer, ensure node and edge collision-free, then choose a best-cost parent among a few nearby LOS-feasible nodes. Insert the node, attempt a direct bridge, else try a few micro connect steps from the opposite tree. Both node and edge checks are enforced before any insertion. On success, extract and shortcut the path; otherwise iterate up to a cap.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=10.0,\n        collision_step=1.0,\n        beam_k=3,\n        goal_bias=0.2,\n        corridor_bias=0.5,\n        informed_bias=0.6,\n        grid_cell_factor=0.9,\n        min_sep_ratio=0.4,\n        dupe_radius_ratio=0.6,\n        cell_expand_limit=3,\n        max_rings=3,\n        parent_search_rings=2,\n        connect_micro_steps=4,\n        smoothing_attempts=40,\n        anchors_stride=24,\n        edge_cache_max=12000,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_step = collision_step\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.max_rings = max_rings\n        self.parent_search_rings = parent_search_rings\n        self.connect_micro_steps = connect_micro_steps\n        self.smoothing_attempts = smoothing_attempts\n        self.anchors_stride = max(1, int(anchors_stride))\n        self.edge_cache_max = edge_cache_max\n\n        # Runtime fields\n        self.bounds = None\n        self.dim = 2\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self.edge_cache = None  # dict[(qa,qb)] = 1(blocked) or 2(free)\n        self.cell_size = 1.0\n        self.min_sep = 1.0\n        self.dupe_radius = 1.0\n        self.start = None\n        self.goal = None\n\n    # ------------- Public entry ----------------\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Parameterize discretizations\n        self.edge_res = max(0.75, min(self.collision_step, self.step_size * 0.5))\n        self.cache_bin = max(1.0, self.edge_res)\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_ratio)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.edge_cache = {}\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start)\n            n1 = Node(self.goal, parent=n0, cost=self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Init trees, grids, anchors, throttles\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        anchors_a, anchors_b = [start_root], [goal_root]\n        cell_expands_a, cell_expands_b = {}, {}\n\n        best_path_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        base_corridor_w = max(self.step_size, 0.2 * d_sg)\n\n        # Main loop\n        for it in range(self.max_iter):\n            # alternate sides\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            anchors1 = anchors_a if active_start else anchors_b\n            anchors2 = anchors_b if active_start else anchors_a\n            throttles1 = cell_expands_a if active_start else cell_expands_b\n            other_root = self.goal if active_start else self.start\n\n            best_candidate = None  # (parent_node, new_pos, score)\n\n            for _ in range(self.beam_k):\n                # Guided sampling with informed ellipse if available\n                x_rand = None\n                r = self._rand()\n                if best_path_len < float('inf') and r < self.informed_bias:\n                    x_rand = self._sample_informed(best_path_len, obstacles, is_3d)\n                else:\n                    r2 = self._rand()\n                    if r2 < self.goal_bias:\n                        x_rand = other_root\n                    elif r2 < self.goal_bias + self.corridor_bias:\n                        width = base_corridor_w\n                        if best_path_len < float('inf'):\n                            slack = max(0.0, best_path_len - d_sg)\n                            width = max(self.step_size, 0.15 * slack + base_corridor_w)\n                        x_rand = self._sample_corridor(width, obstacles, is_3d)\n                    else:\n                        x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_hashed(grid1, tree1, anchors1, x_rand)\n                if nearest is None:\n                    continue\n\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._exists_close(grid1, new_pos, self.dupe_radius):\n                    continue\n\n                # Throttle expansions per cell\n                kcell = self._grid_key(new_pos)\n                if throttles1.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n\n                # Candidate parent selection: consider a few nearby nodes with LOS and lower cost\n                parent = self._choose_parent(nearest, grid1, new_pos, obstacles, is_3d)\n                if parent is None:\n                    continue\n                # Edge check (both checks enforced before insertion)\n                if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Score: distance to nearest on opposite tree (encourage bridging)\n                near2 = self._nearest_hashed(grid2, tree2, anchors2, new_pos)\n                score = self._dist(new_pos, near2.position) if near2 is not None else self._dist(new_pos, other_root)\n\n                if best_candidate is None or score < best_candidate[2]:\n                    best_candidate = (parent, new_pos, score)\n\n            if best_candidate is None:\n                continue\n\n            parent, new_pos, _score = best_candidate\n\n            # Final checks before adding\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_cost = parent.cost + self._dist(parent.position, new_pos)\n            new_node = Node(new_pos, parent=parent, cost=new_cost)\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid1, new_node)\n            kc = self._grid_key(new_pos)\n            throttles1[kc] = throttles1.get(kc, 0) + 1\n            if len(tree1) % self.anchors_stride == 0:\n                anchors1.append(new_node)\n\n            # Grandparent LOS compression (cheap)\n            gp = parent.parent\n            if gp is not None and not self._edge_blocked_memo(gp.position, new_node.position, obstacles, is_3d):\n                parent.children = [c for c in parent.children if c is not new_node]\n                new_node.parent = gp\n                gp.add_child(new_node)\n                new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n                # edges bookkeeping: replace edge (parent,new_node) by (gp,new_node)\n                try:\n                    idx = -1\n                    for i in range(len(edges)):\n                        if edges[i][0] is parent and edges[i][1] is new_node:\n                            idx = i\n                            break\n                    if idx >= 0:\n                        edges.pop(idx)\n                except:\n                    pass\n                edges.append((gp, new_node))\n\n            # Try direct bridge\n            other_near = self._nearest_hashed(grid2, tree2, anchors2, new_node.position)\n            if other_near is not None and not self._edge_blocked_memo(new_node.position, other_near.position, obstacles, is_3d):\n                path = self._extract_path(new_node, other_near)\n                best_path_len = self._path_length(path)\n                path = self._smooth_path(path, obstacles, is_3d, self.smoothing_attempts)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Micro-connect from the other side\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_micro_steps:\n                step_pos = self._steer(p.position, new_node.position, self.step_size)\n                if not self._in_bounds(step_pos):\n                    break\n                if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(grid2, step_pos, self.dupe_radius):\n                    break\n                if self._edge_blocked_memo(p.position, step_pos, obstacles, is_3d):\n                    break\n\n                # Add micro step node (both checks passed)\n                q = Node(step_pos, parent=p, cost=p.cost + self._dist(p.position, step_pos))\n                p.add_child(q)\n                tree2.append(q)\n                nodes.append(q)\n                edges.append((p, q))\n                self._grid_add(grid2, q)\n                if len(tree2) % self.anchors_stride == 0:\n                    anchors2.append(q)\n                k2 = self._grid_key(step_pos)\n                if active_start:\n                    cell_expands_b[k2] = cell_expands_b.get(k2, 0) + 1\n                else:\n                    cell_expands_a[k2] = cell_expands_a.get(k2, 0) + 1\n\n                p = q\n                steps += 1\n\n                # Check bridge after each micro step\n                if not self._edge_blocked_memo(new_node.position, p.position, obstacles, is_3d):\n                    path = self._extract_path(new_node, p)\n                    best_path_len = self._path_length(path)\n                    path = self._smooth_path(path, obstacles, is_3d, self.smoothing_attempts)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # ------------- RNG -------------\n    def _rand(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry -------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp_tuple(to_pos)\n        if d <= 1e-12:\n            return self._clamp_tuple(from_pos)\n        r = step / d\n        return self._clamp_tuple(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ------------- Collision -------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        state = self.edge_cache.get(key)\n        if state is not None:\n            return state == 1\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d)\n        self.edge_cache[key] = 1 if blocked else 2\n        if len(self.edge_cache) > self.edge_cache_max:\n            # Simple aging: clear cache to bound memory\n            self.edge_cache.clear()\n        return blocked\n\n    # ------------- Sampling -------------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        base_t = self._rand()\n        base = tuple(self.start[i] + base_t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            # Random offset in sphere\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        else:\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        # Rejection sampling in prolate ellipse (sum of distances to foci <= best_len)\n        for _ in range(40):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= best_len and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Fallback if rejection too strict\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)\n\n    # ------------- Grid Hashing -------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, tree, anchors, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.max_rings + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback to anchors (sparse subset)\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # Rare: full scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.cell_size) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    def _nearby_candidates(self, grid, pos, rings):\n        key = self._grid_key(pos)\n        cand = []\n        for r in range(0, rings + 1):\n            cand.extend(self._grid_ring_collect(grid, key, r))\n        return cand\n\n    # ------------- Parent selection -------------\n    def _choose_parent(self, nearest, grid, new_pos, obstacles, is_3d):\n        best_parent = nearest\n        best_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        # include a few nearby candidates\n        candidates = self._nearby_candidates(grid, new_pos, self.parent_search_rings)\n        if not candidates:\n            candidates = [nearest]\n        for cand in candidates:\n            # Avoid trivial duplicate\n            if cand is None:\n                continue\n            # LOS check to new_pos\n            if not self._edge_blocked_memo(cand.position, new_pos, obstacles, is_3d):\n                c = cand.cost + self._dist(cand.position, new_pos)\n                if c < best_cost:\n                    best_cost = c\n                    best_parent = cand\n        return best_parent\n\n    # ------------- Paths -------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node):\n        path_a = self._path_to_root(a_node)\n        path_b = []\n        cur = b_node\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _smooth_path(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and len(pts) >= 3:\n            i = int(self._uniform(0, len(pts) - 2))\n            j = int(self._uniform(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked_memo(a, b, obstacles, is_3d):\n                # remove intermediates\n                pts = pts[:i + 1] + pts[j:]\n            tries += 1\n        # Forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            k = 1\n            while k < len(pts) - 1:\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n                k += 1\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
            "objective": -19.56842,
            "time_improvement": 16.0,
            "length_improvement": 10.0,
            "smoothness_improvement": 1708.0,
            "node_improvement": 91.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.034371376037597656,
                    "num_nodes_avg": 54.5,
                    "path_length_avg": 176.5532757902085,
                    "smoothness_avg": 0.04933649347201097,
                    "success_improvement": 0.0,
                    "time_improvement": -34.79607703434419,
                    "node_improvement": 86.27549735582977,
                    "length_improvement": 3.2283518737009844,
                    "smoothness_improvement": 672.2232587473158,
                    "objective_score": -5.140695692346085
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.049022126197814944,
                    "num_nodes_avg": 74.3,
                    "path_length_avg": 244.4349083904013,
                    "smoothness_avg": 0.12138388867178254,
                    "success_improvement": 0.0,
                    "time_improvement": 69.39891173945327,
                    "node_improvement": 95.00772693677351,
                    "length_improvement": 18.400591910549277,
                    "smoothness_improvement": 3023.294884806057,
                    "objective_score": 46.976503092195834
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04275155067443848,
                    "num_nodes_avg": 61.0,
                    "path_length_avg": 135.83592104549325,
                    "smoothness_avg": 0.12021718235188508,
                    "success_improvement": 0.0,
                    "time_improvement": 12.8437936691172,
                    "node_improvement": 92.2441195168468,
                    "length_improvement": 9.784249053058426,
                    "smoothness_improvement": 1429.1536860066096,
                    "objective_score": 16.869455962603265
                }
            ],
            "success_rate": 1.0
        },
        "objective": 20.4,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Nearest-neighbor lookups frequently degrade to linear scans due to small neighborhood rings and coarse spatial hashing, inflating per-iteration cost.\n   - Collision checking is repeatedly recomputed for the same edges; when caching exists it stores only blocked results, causing free edges to be rechecked during extend/connect/smoothing.\n   - Guided sampling can be rejection-prone in clutter or near blocked attractors; large separation/duplicate thresholds and per-cell saturation cause many samples to be discarded after expensive checks.\n   - Greedy connect procedures attempt long chains, triggering many collision checks and often aborting late due to duplicates or obstacles, wasting iterations.\n   - Limited local parent selection and delayed compression keep more nodes/edges alive, increasing the cost of future NN queries and checks."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Dual-state edge memoization (caching both blocked and free edges) with bounded size, reused across extend/connect/smoothing.\n   - Informed sampling activated after the first provisional path (ellipse/corridor focused), with adaptive corridor width.\n   - Anchored, ring-bounded hashed nearest search (grid + sparse anchors) to avoid frequent full scans.\n   - Short, capped micro-connect steps with bridge checks after each step to bound per-attempt work.\n   - Early grandparent line-of-sight compression, per-cell expansion throttling, and duplicate suppression to keep trees sparse.\n   - Slightly larger step size to reduce node count per successful extension.\n2. Expected mechanism of impact:\n   - Eliminates redundant collision evaluations and accelerates smoothing/connection via cache hits.\n   - Focuses exploration to promising regions once any path exists, reducing wasted iterations.\n   - Cuts nearest-neighbor overhead by preventing O(N) fallbacks and limiting candidate sets.\n   - Bounds the work of connection attempts and yields earlier tree merges, lowering total expansions.\n   - Keeps the search structure smaller, making all subsequent NN and collision operations cheaper per iteration.\n   - Fewer nodes needed to span distances, lowering total checks and iterations for similar coverage."
        }
    },
    {
        "parents": [
            {
                "operator": "cross_over",
                "algorithm_description": "IBEX-BiRRT (Informed Beam EXploration BiRRT): a bidirectional planner that couples ellipse-informed beam sampling with dual-state edge memoization, anchor-guided hashed nearest search, and local LOS-based parent selection. It throttles per-cell growth, rejects near-duplicates, and performs micro-connect probes with cached collision results. A provisional path immediately activates an informed ellipse to focus sampling; final paths are lightly shortcut and LOS-collapsed for length and smoothness.",
                "planning_mechanism": "Alternate growing start/goal trees. For each side, generate a small beam of samples from goal/corridor/uniform, switching to ellipse-informed sampling once a path exists. For each sample: find a near node via grid+anchors, steer, ensure node and edge collision-free, then choose a best-cost parent among a few nearby LOS-feasible nodes. Insert the node, attempt a direct bridge, else try a few micro connect steps from the opposite tree. Both node and edge checks are enforced before any insertion. On success, extract and shortcut the path; otherwise iterate up to a cap.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=10.0,\n        collision_step=1.0,\n        beam_k=3,\n        goal_bias=0.2,\n        corridor_bias=0.5,\n        informed_bias=0.6,\n        grid_cell_factor=0.9,\n        min_sep_ratio=0.4,\n        dupe_radius_ratio=0.6,\n        cell_expand_limit=3,\n        max_rings=3,\n        parent_search_rings=2,\n        connect_micro_steps=4,\n        smoothing_attempts=40,\n        anchors_stride=24,\n        edge_cache_max=12000,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_step = collision_step\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.max_rings = max_rings\n        self.parent_search_rings = parent_search_rings\n        self.connect_micro_steps = connect_micro_steps\n        self.smoothing_attempts = smoothing_attempts\n        self.anchors_stride = max(1, int(anchors_stride))\n        self.edge_cache_max = edge_cache_max\n\n        # Runtime fields\n        self.bounds = None\n        self.dim = 2\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self.edge_cache = None  # dict[(qa,qb)] = 1(blocked) or 2(free)\n        self.cell_size = 1.0\n        self.min_sep = 1.0\n        self.dupe_radius = 1.0\n        self.start = None\n        self.goal = None\n\n    # ------------- Public entry ----------------\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Parameterize discretizations\n        self.edge_res = max(0.75, min(self.collision_step, self.step_size * 0.5))\n        self.cache_bin = max(1.0, self.edge_res)\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_ratio)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.edge_cache = {}\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start)\n            n1 = Node(self.goal, parent=n0, cost=self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Init trees, grids, anchors, throttles\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        anchors_a, anchors_b = [start_root], [goal_root]\n        cell_expands_a, cell_expands_b = {}, {}\n\n        best_path_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        base_corridor_w = max(self.step_size, 0.2 * d_sg)\n\n        # Main loop\n        for it in range(self.max_iter):\n            # alternate sides\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            anchors1 = anchors_a if active_start else anchors_b\n            anchors2 = anchors_b if active_start else anchors_a\n            throttles1 = cell_expands_a if active_start else cell_expands_b\n            other_root = self.goal if active_start else self.start\n\n            best_candidate = None  # (parent_node, new_pos, score)\n\n            for _ in range(self.beam_k):\n                # Guided sampling with informed ellipse if available\n                x_rand = None\n                r = self._rand()\n                if best_path_len < float('inf') and r < self.informed_bias:\n                    x_rand = self._sample_informed(best_path_len, obstacles, is_3d)\n                else:\n                    r2 = self._rand()\n                    if r2 < self.goal_bias:\n                        x_rand = other_root\n                    elif r2 < self.goal_bias + self.corridor_bias:\n                        width = base_corridor_w\n                        if best_path_len < float('inf'):\n                            slack = max(0.0, best_path_len - d_sg)\n                            width = max(self.step_size, 0.15 * slack + base_corridor_w)\n                        x_rand = self._sample_corridor(width, obstacles, is_3d)\n                    else:\n                        x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_hashed(grid1, tree1, anchors1, x_rand)\n                if nearest is None:\n                    continue\n\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._exists_close(grid1, new_pos, self.dupe_radius):\n                    continue\n\n                # Throttle expansions per cell\n                kcell = self._grid_key(new_pos)\n                if throttles1.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n\n                # Candidate parent selection: consider a few nearby nodes with LOS and lower cost\n                parent = self._choose_parent(nearest, grid1, new_pos, obstacles, is_3d)\n                if parent is None:\n                    continue\n                # Edge check (both checks enforced before insertion)\n                if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Score: distance to nearest on opposite tree (encourage bridging)\n                near2 = self._nearest_hashed(grid2, tree2, anchors2, new_pos)\n                score = self._dist(new_pos, near2.position) if near2 is not None else self._dist(new_pos, other_root)\n\n                if best_candidate is None or score < best_candidate[2]:\n                    best_candidate = (parent, new_pos, score)\n\n            if best_candidate is None:\n                continue\n\n            parent, new_pos, _score = best_candidate\n\n            # Final checks before adding\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_cost = parent.cost + self._dist(parent.position, new_pos)\n            new_node = Node(new_pos, parent=parent, cost=new_cost)\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid1, new_node)\n            kc = self._grid_key(new_pos)\n            throttles1[kc] = throttles1.get(kc, 0) + 1\n            if len(tree1) % self.anchors_stride == 0:\n                anchors1.append(new_node)\n\n            # Grandparent LOS compression (cheap)\n            gp = parent.parent\n            if gp is not None and not self._edge_blocked_memo(gp.position, new_node.position, obstacles, is_3d):\n                parent.children = [c for c in parent.children if c is not new_node]\n                new_node.parent = gp\n                gp.add_child(new_node)\n                new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n                # edges bookkeeping: replace edge (parent,new_node) by (gp,new_node)\n                try:\n                    idx = -1\n                    for i in range(len(edges)):\n                        if edges[i][0] is parent and edges[i][1] is new_node:\n                            idx = i\n                            break\n                    if idx >= 0:\n                        edges.pop(idx)\n                except:\n                    pass\n                edges.append((gp, new_node))\n\n            # Try direct bridge\n            other_near = self._nearest_hashed(grid2, tree2, anchors2, new_node.position)\n            if other_near is not None and not self._edge_blocked_memo(new_node.position, other_near.position, obstacles, is_3d):\n                path = self._extract_path(new_node, other_near)\n                best_path_len = self._path_length(path)\n                path = self._smooth_path(path, obstacles, is_3d, self.smoothing_attempts)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Micro-connect from the other side\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_micro_steps:\n                step_pos = self._steer(p.position, new_node.position, self.step_size)\n                if not self._in_bounds(step_pos):\n                    break\n                if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(grid2, step_pos, self.dupe_radius):\n                    break\n                if self._edge_blocked_memo(p.position, step_pos, obstacles, is_3d):\n                    break\n\n                # Add micro step node (both checks passed)\n                q = Node(step_pos, parent=p, cost=p.cost + self._dist(p.position, step_pos))\n                p.add_child(q)\n                tree2.append(q)\n                nodes.append(q)\n                edges.append((p, q))\n                self._grid_add(grid2, q)\n                if len(tree2) % self.anchors_stride == 0:\n                    anchors2.append(q)\n                k2 = self._grid_key(step_pos)\n                if active_start:\n                    cell_expands_b[k2] = cell_expands_b.get(k2, 0) + 1\n                else:\n                    cell_expands_a[k2] = cell_expands_a.get(k2, 0) + 1\n\n                p = q\n                steps += 1\n\n                # Check bridge after each micro step\n                if not self._edge_blocked_memo(new_node.position, p.position, obstacles, is_3d):\n                    path = self._extract_path(new_node, p)\n                    best_path_len = self._path_length(path)\n                    path = self._smooth_path(path, obstacles, is_3d, self.smoothing_attempts)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # ------------- RNG -------------\n    def _rand(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry -------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp_tuple(to_pos)\n        if d <= 1e-12:\n            return self._clamp_tuple(from_pos)\n        r = step / d\n        return self._clamp_tuple(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ------------- Collision -------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        state = self.edge_cache.get(key)\n        if state is not None:\n            return state == 1\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d)\n        self.edge_cache[key] = 1 if blocked else 2\n        if len(self.edge_cache) > self.edge_cache_max:\n            # Simple aging: clear cache to bound memory\n            self.edge_cache.clear()\n        return blocked\n\n    # ------------- Sampling -------------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        base_t = self._rand()\n        base = tuple(self.start[i] + base_t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            # Random offset in sphere\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        else:\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        # Rejection sampling in prolate ellipse (sum of distances to foci <= best_len)\n        for _ in range(40):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= best_len and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Fallback if rejection too strict\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)\n\n    # ------------- Grid Hashing -------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, tree, anchors, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.max_rings + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback to anchors (sparse subset)\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # Rare: full scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.cell_size) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    def _nearby_candidates(self, grid, pos, rings):\n        key = self._grid_key(pos)\n        cand = []\n        for r in range(0, rings + 1):\n            cand.extend(self._grid_ring_collect(grid, key, r))\n        return cand\n\n    # ------------- Parent selection -------------\n    def _choose_parent(self, nearest, grid, new_pos, obstacles, is_3d):\n        best_parent = nearest\n        best_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        # include a few nearby candidates\n        candidates = self._nearby_candidates(grid, new_pos, self.parent_search_rings)\n        if not candidates:\n            candidates = [nearest]\n        for cand in candidates:\n            # Avoid trivial duplicate\n            if cand is None:\n                continue\n            # LOS check to new_pos\n            if not self._edge_blocked_memo(cand.position, new_pos, obstacles, is_3d):\n                c = cand.cost + self._dist(cand.position, new_pos)\n                if c < best_cost:\n                    best_cost = c\n                    best_parent = cand\n        return best_parent\n\n    # ------------- Paths -------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node):\n        path_a = self._path_to_root(a_node)\n        path_b = []\n        cur = b_node\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _smooth_path(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and len(pts) >= 3:\n            i = int(self._uniform(0, len(pts) - 2))\n            j = int(self._uniform(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked_memo(a, b, obstacles, is_3d):\n                # remove intermediates\n                pts = pts[:i + 1] + pts[j:]\n            tries += 1\n        # Forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            k = 1\n            while k < len(pts) - 1:\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n                k += 1\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
                "objective": -19.56842,
                "time_improvement": 16.0,
                "length_improvement": 10.0,
                "smoothness_improvement": 1708.0,
                "node_improvement": 91.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.034371376037597656,
                        "num_nodes_avg": 54.5,
                        "path_length_avg": 176.5532757902085,
                        "smoothness_avg": 0.04933649347201097,
                        "success_improvement": 0.0,
                        "time_improvement": -34.79607703434419,
                        "node_improvement": 86.27549735582977,
                        "length_improvement": 3.2283518737009844,
                        "smoothness_improvement": 672.2232587473158,
                        "objective_score": -5.140695692346085
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.049022126197814944,
                        "num_nodes_avg": 74.3,
                        "path_length_avg": 244.4349083904013,
                        "smoothness_avg": 0.12138388867178254,
                        "success_improvement": 0.0,
                        "time_improvement": 69.39891173945327,
                        "node_improvement": 95.00772693677351,
                        "length_improvement": 18.400591910549277,
                        "smoothness_improvement": 3023.294884806057,
                        "objective_score": 46.976503092195834
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.04275155067443848,
                        "num_nodes_avg": 61.0,
                        "path_length_avg": 135.83592104549325,
                        "smoothness_avg": 0.12021718235188508,
                        "success_improvement": 0.0,
                        "time_improvement": 12.8437936691172,
                        "node_improvement": 92.2441195168468,
                        "length_improvement": 9.784249053058426,
                        "smoothness_improvement": 1429.1536860066096,
                        "objective_score": 16.869455962603265
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "time_expert",
                "algorithm_description": "FlashConnect BiRRT (FC-BiRRT): a cache-accelerated bidirectional planner with throttled growth and corridor-guided micro-batches. It couples an adaptive hashed-nearest structure with a conservative edge-collision memo (blocked-edge cache), per-cell expansion throttling, and sparse \u201cleader\u201d fallbacks to avoid O(N) scans. Direct bridges and short greedy connects are attempted with cached checks; on success, a bounded shortcut and line-of-sight collapse return a clean path fast.",
                "planning_mechanism": "Mechanism: Initialize start/goal trees with grid buckets and sparse leaders. Each iteration alternates trees, samples a tiny beam (goal/corridor/uniform), steers once from the nearest, enforces node/edge validity, prunes duplicates and saturated cells, and keeps the candidate that best reduces distance to the other tree. Insert with optional grandparent LOS compression, then attempt a direct bridge; if blocked, execute a few greedy connect steps using the blocked-edge cache. On bridge, extract and lightly smooth the path; otherwise continue until the iteration cap.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=8.0,\n                 goal_bias=0.2,\n                 corridor_bias=0.55,\n                 beam_k=2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 connect_steps=5,\n                 smoothing_iters=18,\n                 min_sep_ratio=0.25,\n                 dupe_radius_ratio=0.5,\n                 cell_expand_limit=3,\n                 leader_stride=16):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.leader_stride = max(1, int(leader_stride))\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Setup grid and edge sampling step\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.8 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.4)))\n        self.cache_bin = max(1.0, self.edge_res)  # quantization for blocked-edge cache\n\n        # Validate start/goal and early LOS\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n        if not self._is_edge_in_obstacle(self.start, self.goal, obstacles, is_3d, self.edge_res):\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, [self.start, self.goal], nodes, [])\n\n        # Initialize trees, grids, leaders, edges, caches\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start, grid_goal = {}, {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        leaders_start, leaders_goal = [start_root], [goal_root]\n        cell_expands_start, cell_expands_goal = {}, {}\n\n        blocked_edge_cache = set()\n\n        # Corridor parameters\n        dsg = self._dist(self.start, self.goal)\n        base_corridor = max(self.step_size, 0.15 * dsg)\n        best_path_len = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            leaders_a = leaders_start if active_start else leaders_goal\n            leaders_b = leaders_goal if active_start else leaders_start\n            cell_count_a = cell_expands_start if active_start else cell_expands_goal\n            root_other = self.goal if active_start else self.start\n\n            # Candidate beam; keep one that best approaches the other tree\n            best_parent = None\n            best_newpos = None\n            best_score = float('inf')\n\n            for _ in range(self.beam_k):\n                # Sampling: goal-biased, corridor-guided, or uniform\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = base_corridor\n                    if best_path_len < float('inf'):\n                        width = max(self.step_size, 0.25 * (best_path_len - dsg) + base_corridor)\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_hashed(grid_a, tree_a, leaders_a, x_rand)\n                if nearest is None:\n                    continue\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n\n                # De-duplicate and throttle saturated cells\n                if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                kcell = self._grid_key(new_pos)\n                if cell_count_a.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n\n                # Edge validity with blocked-edge cache\n                if self._is_edge_blocked_cached(nearest.position, new_pos, obstacles, is_3d, blocked_edge_cache):\n                    continue\n\n                # Score: distance to nearest in opposite tree (leaders-assisted)\n                other_near = self._nearest_hashed(grid_b, tree_b, leaders_b, new_pos)\n                if other_near is not None:\n                    score = self._dist(new_pos, other_near.position)\n                else:\n                    score = self._dist(new_pos, root_other)\n\n                if score < best_score:\n                    best_score = score\n                    best_parent = nearest\n                    best_newpos = new_pos\n\n            if best_parent is None:\n                continue\n\n            # Final validity before insertion (both checks)\n            if self._is_in_obstacle(best_newpos, obstacles, is_3d):\n                continue\n            if self._is_edge_blocked_cached(best_parent.position, best_newpos, obstacles, is_3d, blocked_edge_cache):\n                continue\n\n            # Insert node and edge\n            new_cost = best_parent.cost + self._dist(best_parent.position, best_newpos)\n            new_node = Node(best_newpos, parent=best_parent, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            self._edges_add(edges, best_parent, new_node)\n            self._grid_add(grid_a, new_node)\n            # Update per-cell throttle\n            kc = self._grid_key(new_node.position)\n            cell_count_a[kc] = cell_count_a.get(kc, 0) + 1\n            # Sparse leaders\n            if len(tree_a) % self.leader_stride == 0:\n                leaders_a.append(new_node)\n\n            # On-the-fly grandparent compression\n            gp = best_parent.parent\n            if gp is not None:\n                if not self._is_edge_blocked_cached(gp.position, new_node.position, obstacles, is_3d, blocked_edge_cache):\n                    best_parent.remove_child(new_node)\n                    self._edges_remove(edges, best_parent, new_node)\n                    gp.add_child(new_node)\n                    self._edges_add(edges, gp, new_node)\n                    new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n\n            # Attempt direct bridge to nearest in the other tree\n            other_near = self._nearest_hashed(grid_b, tree_b, leaders_b, new_node.position)\n            if other_near is not None and not self._is_edge_blocked_cached(new_node.position, other_near.position, obstacles, is_3d, blocked_edge_cache):\n                path = self._extract_path(new_node, other_near)\n                best_path_len = self._path_length(path)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Short greedy connect from the other tree toward the new node\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if self._dist(p.position, to_pos) < self.step_size * self.min_sep_ratio:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(grid_b, to_pos, self.step_size * self.dupe_radius_ratio):\n                    break\n                if self._is_edge_blocked_cached(p.position, to_pos, obstacles, is_3d, blocked_edge_cache):\n                    break\n\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                self._edges_add(edges, p, q)\n                self._grid_add(grid_b, q)\n                # leaders and per-cell throttle for tree_b\n                if len(tree_b) % self.leader_stride == 0:\n                    leaders_b.append(q)\n                kc_b = self._grid_key(q.position)\n                if active_start:\n                    cell_expands_goal[kc_b] = cell_expands_goal.get(kc_b, 0) + 1\n                else:\n                    cell_expands_start[kc_b] = cell_expands_start.get(kc_b, 0) + 1\n\n                p = q\n                steps += 1\n\n                # Check bridge now\n                if not self._is_edge_blocked_cached(new_node.position, p.position, obstacles, is_3d, blocked_edge_cache):\n                    path = self._extract_path(new_node, p)\n                    best_path_len = self._path_length(path)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # RNG\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _is_edge_blocked_cached(self, a, b, obstacles, is_3d, blocked_cache):\n        key = self._edge_key_q(a, b)\n        if key in blocked_cache:\n            return True\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n        if blocked:\n            blocked_cache.add(key)\n        return blocked\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # Grid and neighbors\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, leaders, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Limited rings, then leader fallback to avoid O(N)\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fall back to leaders (sparse)\n        for n in leaders:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # Fallback full scan (rare)\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # Edges\n    def _edges_add(self, edges, parent, child):\n        edges.append((parent, child))\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        # Forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            for k in range(1, len(pts) - 1):\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d, self.edge_res):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
                "objective": -14.73772,
                "time_improvement": 1.0,
                "length_improvement": 9.0,
                "smoothness_improvement": 1829.0,
                "node_improvement": 84.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.03957667350769043,
                        "num_nodes_avg": 89.6,
                        "path_length_avg": 173.3707237388481,
                        "smoothness_avg": 0.05077321918948241,
                        "success_improvement": 0.0,
                        "time_improvement": -55.2099725384924,
                        "node_improvement": 77.43641400151094,
                        "length_improvement": 4.972759083816072,
                        "smoothness_improvement": 694.711136125575,
                        "objective_score": -10.105780630630203
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.05332317352294922,
                        "num_nodes_avg": 145.0,
                        "path_length_avg": 246.8569464197752,
                        "smoothness_avg": 0.11933221064521529,
                        "success_improvement": 0.0,
                        "time_improvement": 66.7140684040557,
                        "node_improvement": 90.25734058993481,
                        "length_improvement": 17.592045901845015,
                        "smoothness_improvement": 2970.5037314185306,
                        "objective_score": 45.42196671941637
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.052624630928039554,
                        "num_nodes_avg": 134.3,
                        "path_length_avg": 145.60396458843502,
                        "smoothness_avg": 0.1510094522023601,
                        "success_improvement": 0.0,
                        "time_improvement": -7.284136338781219,
                        "node_improvement": 82.92434837889384,
                        "length_improvement": 3.2967796360860238,
                        "smoothness_improvement": 1820.829085655716,
                        "objective_score": 8.896972308295828
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "HASTE-BiRRT (Heuristically Accelerated Sparse Tree Expansion BiRRT): a bidirectional planner that couples tiny-beam, corridor/informed sampling with dual-anchored hashed nearest search, bounded per-cell growth, and a two-sided edge memo caching both blocked and free checks. It inserts single-parent nodes with multi-ancestor LOS compression to keep trees shallow, uses a short single-step greedy connect to limit overhead, and maintains an early-updating best path to focus informed sampling. A bounded shortcut with forward LOS collapse returns smooth, short paths quickly.",
            "planning_mechanism": "Alternate growth of start/goal trees. Each side samples a small beam (goal/corridor/uniform, switching to informed ellipse after a provisional path). For each sample, find a near node via grid+anchors, steer once, enforce node and edge validity (with memoized edge checks), suppress near-duplicates and throttle per-cell growth; keep the candidate that minimizes a heuristic combining distance to the opposite tree and cost-to-come. Insert the node, apply multi-ancestor LOS compression, then attempt a direct bridge or a single-step greedy connect from the opposite tree. On success, extract and bounded-shortcut the path with LOS collapse; otherwise iterate to a cap.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=10.0,\n                 collision_step=1.0,\n                 beam_k=2,\n                 goal_bias=0.15,\n                 corridor_bias=0.55,\n                 informed_bias=0.65,\n                 grid_cell=None,\n                 max_rings=3,\n                 dupe_radius_ratio=0.45,\n                 min_sep_ratio=0.30,\n                 cell_expand_limit=2,\n                 anchor_stride=20,\n                 connect_attempts=1,\n                 compress_depth=3,\n                 smoothing_iters=24,\n                 edge_cache_max=20000):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_step = collision_step\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.grid_cell = grid_cell\n        self.max_rings = max_rings\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.min_sep_ratio = min_sep_ratio\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.anchor_stride = max(1, int(anchor_stride))\n        self.connect_attempts = max(1, int(connect_attempts))\n        self.compress_depth = max(1, int(compress_depth))\n        self.smoothing_iters = smoothing_iters\n        self.edge_cache_max = max(1000, int(edge_cache_max))\n\n        # runtime\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self.edge_cache = None  # key -> 1(blocked) or 2(free)\n\n        self.start = None\n        self.goal = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # setup discretizations\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.5)))\n        self.cache_bin = max(1.0, self.edge_res)\n        self.edge_cache = {}\n\n        # validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # early straight connection\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # initialize trees and structures\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        edges = []\n        nodes = [start_root, goal_root]\n\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        anchors_a, anchors_b = [start_root], [goal_root]\n        cell_expands_a, cell_expands_b = {}, {}\n\n        best_path_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        base_corridor_w = max(self.step_size, 0.2 * d_sg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            anchors1 = anchors_a if active_start else anchors_b\n            anchors2 = anchors_b if active_start else anchors_a\n            throttles1 = cell_expands_a if active_start else cell_expands_b\n            throttles2 = cell_expands_b if active_start else cell_expands_a\n            other_root = self.goal if active_start else self.start\n\n            best_parent = None\n            best_new = None\n            best_score = float('inf')\n\n            for _ in range(self.beam_k):\n                # sampling strategy\n                r = self._rand()\n                if best_path_len < float('inf') and r < self.informed_bias:\n                    x_rand = self._sample_informed(best_path_len, obstacles, is_3d)\n                else:\n                    r2 = self._rand()\n                    if r2 < self.goal_bias:\n                        x_rand = other_root\n                    elif r2 < self.goal_bias + self.corridor_bias:\n                        width = base_corridor_w\n                        if best_path_len < float('inf'):\n                            slack = max(0.0, best_path_len - d_sg)\n                            width = max(self.step_size, 0.2 * slack + base_corridor_w)\n                        x_rand = self._sample_corridor(width, obstacles, is_3d)\n                    else:\n                        x_rand = self._sample_free(obstacles, is_3d)\n\n                near = self._nearest_hashed(grid1, tree1, anchors1, x_rand)\n                if near is None:\n                    continue\n\n                new_pos = self._steer(near.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                # Node collision check before any insertion\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n\n                # duplicate suppression and throttle\n                if self._dist(near.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid1, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                kcell = self._grid_key(new_pos)\n                if throttles1.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n\n                # Edge collision check before considering\n                if self._edge_blocked_memo(near.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Heuristic score: distance to opposite-tree nearest + mild cost term\n                other_near = self._nearest_hashed(grid2, tree2, anchors2, new_pos)\n                to_other = self._dist(new_pos, other_near.position) if other_near is not None else self._dist(new_pos, other_root)\n                cost_term = (near.cost + self._dist(near.position, new_pos)) * 0.05\n                score = to_other + cost_term\n\n                if score < best_score:\n                    best_score = score\n                    best_parent = near\n                    best_new = new_pos\n\n            if best_parent is None:\n                continue\n\n            # Final validity before insertion (both checks)\n            if self._is_in_obstacle(best_new, obstacles, is_3d):\n                continue\n            if self._edge_blocked_memo(best_parent.position, best_new, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_cost = best_parent.cost + self._dist(best_parent.position, best_new)\n            new_node = Node(best_new, best_parent, new_cost)\n            best_parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            self._grid_add(grid1, new_node)\n            kc = self._grid_key(best_new)\n            throttles1[kc] = throttles1.get(kc, 0) + 1\n            if len(tree1) % self.anchor_stride == 0:\n                anchors1.append(new_node)\n\n            # Multi-ancestor LOS compression (up to compress_depth)\n            self._compress_to_ancestors(new_node, obstacles, is_3d, edges, self.compress_depth)\n\n            # Try direct bridge\n            other_near = self._nearest_hashed(grid2, tree2, anchors2, new_node.position)\n            if other_near is not None and not self._edge_blocked_memo(new_node.position, other_near.position, obstacles, is_3d):\n                path = self._extract_path(new_node, other_near)\n                best_path_len = self._path_length(path)\n                path = self._smooth_path(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Short greedy connect from the other side (single-step attempts)\n            p = other_near\n            attempts = 0\n            while p is not None and attempts < self.connect_attempts:\n                step_pos = self._steer(p.position, new_node.position, self.step_size)\n                if not self._in_bounds(step_pos):\n                    break\n                if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(grid2, step_pos, self.step_size * self.dupe_radius_ratio):\n                    break\n                if self._edge_blocked_memo(p.position, step_pos, obstacles, is_3d):\n                    break\n\n                # Insert micro-step node (both checks passed)\n                q = Node(step_pos, p, p.cost + self._dist(p.position, step_pos))\n                p.add_child(q)\n                tree2.append(q)\n                nodes.append(q)\n                edges.append((p, q))\n                self._grid_add(grid2, q)\n                if len(tree2) % self.anchor_stride == 0:\n                    anchors2.append(q)\n                throttles2[self._grid_key(step_pos)] = throttles2.get(self._grid_key(step_pos), 0) + 1\n\n                # optional small compression on the micro-step\n                self._compress_to_ancestors(q, obstacles, is_3d, edges, 2)\n\n                # Check bridge to new_node\n                if not self._edge_blocked_memo(new_node.position, q.position, obstacles, is_3d):\n                    path = self._extract_path(new_node, q)\n                    best_path_len = self._path_length(path)\n                    path = self._smooth_path(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, nodes, edges)\n\n                p = q\n                attempts += 1\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp_tuple(to_pos)\n        if d <= 1e-12:\n            return self._clamp_tuple(from_pos)\n        r = step / d\n        return self._clamp_tuple(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Edge memo (blocked and free)\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        state = self.edge_cache.get(key)\n        if state is not None:\n            return state == 1\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d)\n        self.edge_cache[key] = 1 if blocked else 2\n        # bounded cache pruning to limit rechecks without frequent full clears\n        if len(self.edge_cache) > self.edge_cache_max:\n            self._prune_edge_cache()\n        return blocked\n\n    def _prune_edge_cache(self):\n        # remove roughly half of items deterministically\n        to_remove = []\n        count = 0\n        for k in self.edge_cache:\n            if (count % 2) == 0:\n                to_remove.append(k)\n            count += 1\n            if len(to_remove) >= self.edge_cache_max // 2:\n                break\n        for k in to_remove:\n            try:\n                del self.edge_cache[k]\n            except:\n                pass\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            # rejection within sphere\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        else:\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        # prolate ellipse: sum of distances to foci <= best_len\n        for _ in range(48):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= best_len and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # fallback\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)\n\n    # Grid hashing\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, tree, anchors, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # anchor fallback\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # rare: full scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(max(1, radius / self.grid_cell)) + 1\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Compression\n    def _compress_to_ancestors(self, node, obstacles, is_3d, edges, depth_limit):\n        cur_parent = node.parent\n        depth = 0\n        while cur_parent is not None and depth < depth_limit:\n            gp = cur_parent.parent\n            if gp is None:\n                break\n            if not self._edge_blocked_memo(gp.position, node.position, obstacles, is_3d):\n                # update parent-child relations\n                cur_parent.remove_child(node)\n                self._edges_remove(edges, cur_parent, node)\n                gp.add_child(node)\n                edges.append((gp, node))\n                node.cost = gp.cost + self._dist(gp.position, node.position)\n                cur_parent = gp\n                depth += 1\n            else:\n                break\n\n    # Edges helpers\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node):\n        path_a = self._path_to_root(a_node)\n        path_b = []\n        cur = b_node\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _smooth_path(self, path, obstacles, is_3d, iters):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        no_improve = 0\n        last_len = self._path_length(pts)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d):\n                new_pts = pts[:i + 1] + pts[j:]\n                new_len = self._path_length(new_pts)\n                if new_len <= last_len:\n                    pts = new_pts\n                    last_len = new_len\n                    no_improve = 0\n                else:\n                    no_improve += 1\n            else:\n                no_improve += 1\n            if no_improve >= 8:\n                break\n        # Forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            k = 1\n            while k < len(pts) - 1:\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n                k += 1\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
            "objective": -26.1688,
            "time_improvement": 35.0,
            "length_improvement": 11.0,
            "smoothness_improvement": 1792.0,
            "node_improvement": 88.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027369928359985352,
                    "num_nodes_avg": 65.0,
                    "path_length_avg": 171.28307479198807,
                    "smoothness_avg": 0.05148806664012615,
                    "success_improvement": 0.0,
                    "time_improvement": -7.338122500577379,
                    "node_improvement": 83.63132712163183,
                    "length_improvement": 6.11703255250457,
                    "smoothness_improvement": 705.9000510442344,
                    "objective_score": 4.9982830365507
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04116971492767334,
                    "num_nodes_avg": 116.3,
                    "path_length_avg": 248.99030586642007,
                    "smoothness_avg": 0.12529040112374196,
                    "success_improvement": 0.0,
                    "time_improvement": 74.30062345562982,
                    "node_improvement": 92.18571524558222,
                    "length_improvement": 16.879869113207995,
                    "smoothness_improvement": 3123.8122639421595,
                    "objective_score": 48.037169824324536
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.030934453010559082,
                    "num_nodes_avg": 94.2,
                    "path_length_avg": 133.85366176833466,
                    "smoothness_avg": 0.12940331913875977,
                    "success_improvement": 0.0,
                    "time_improvement": 36.934929218056986,
                    "node_improvement": 88.02288620470438,
                    "length_improvement": 11.10077127990379,
                    "smoothness_improvement": 1546.0006678855698,
                    "objective_score": 25.470944872787218
                }
            ],
            "success_rate": 1.0
        },
        "objective": 13.399999999999999,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient neighbor retrieval and fallback strategies that often degrade to broad scans, inflating per-iteration cost\n   - Redundant obstacle and edge checks on the same candidate (inside beam selection and again before insertion), multiplying collision-testing overhead\n   - Weak or lossy edge memoization (only caching blocked edges or frequent whole-cache clears), causing repeated evaluation of identical free edges\n   - Bridge-chasing beam scoring that ignores cost-to-come, producing detours and unnecessary branch growth before a valid connection\n   - Long greedy connect sequences from the opposite tree, adding many micro-steps and checks per iteration with modest payoff\n   - Limited one-hop compression toward ancestors, leaving deep chains that are harder to bridge and more expensive to process\n   - Overly aggressive or poorly tuned de-duplication/throttling that wastes samples and inhibits focused growth in optimal corridors\n   - Smoothing without early-stopping criteria and with repeated fine-resolution checks, adding avoidable latency"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Robust bidirectional edge memo caching for both blocked and free results with bounded pruning, minimizing repeated collision checks\n   - Informed/corridor-biased sampling activated after a provisional path, plus a beam score that adds a mild cost-to-come term to avoid detours\n   - Multi-ancestor line-of-sight compression to a fixed depth, quickly shortening chains and reducing tree complexity\n   - Short, capped connect attempts with light compression on micro-steps, cutting per-iteration expansion and validation work\n   - Stable grid-hash nearest search with anchor fallbacks and tighter per-cell growth limits, reducing redundant local expansions\n   - Smoothing with an early no-improvement stop and forward LOS collapse to limit postprocessing time\n2. Expected mechanism of impact:\n   - Fewer edge discretizations thanks to higher cache hit rates and preserved free-edge entries \u2192 lower collision-check cost\n   - More samples concentrated in the feasible corridor/ellipse and better candidate scoring \u2192 faster bridging with fewer nodes\n   - Shallower trees from multi-ancestor compression \u2192 cheaper nearest/bridge checks and higher likelihood of straight connections\n   - Reduced micro-step insertion during connect phases \u2192 fewer node/edge updates and grid operations per iteration\n   - Early-terminating smoothing \u2192 cuts tail latency while maintaining path quality"
        }
    },
    {
        "parents": [
            {
                "operator": "m1",
                "algorithm_description": "Beam-guided BiRRT with ancestor line-of-sight compression and spatial hashing (BG-Connect-LOS). The planner alternates tree growth from start and goal using a small beam of guided samples, accelerates nearest lookups with a grid hash, suppresses near-duplicate nodes, and selects a parent among recent ancestors that maintains direct line-of-sight to the new point to compress chains. A short, capped greedy connect links the two trees. Upon success, a bounded shortcut pass refines the path. This reduces expansions and collision checks while improving path quality and smoothness.",
                "planning_mechanism": "At each iteration, pick the active tree and generate a small beam of guided samples biased toward the opposite root. For each sample: find a nearby node via spatial hashing, steer by a fixed step, enforce node and edge collision checks, reject near-duplicates, and pick an ancestor parent with clear line-of-sight to minimize added cost. Insert the node and attempt a capped greedy connect from the opposite tree toward it; if the two trees meet, extract and lightly shortcut the path. Alternate trees and stop early on success.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        beam_width=3,\n        goal_bias=0.15,\n        connect_steps_limit=20,\n        min_separation_factor=0.6,\n        grid_cell_factor=1.0,\n        los_lookback_depth=8,\n        shortcut_attempts=40\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.connect_steps_limit = connect_steps_limit\n        self.min_separation_factor = min_separation_factor\n        self.grid_cell_factor = grid_cell_factor\n        self.los_lookback_depth = los_lookback_depth\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dims = len(bounds)\n        is_3d = dims == 3\n\n        # Parameters derived from step_size\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root = Node(goal_position, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root, is_3d)\n        self._grid_insert(grid_b, goal_root, is_3d)\n\n        success_state = False\n        extracted_path = []\n\n        for _ in range(self.max_iter):\n            # Alternate trees by swapping references each loop\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, goal_position),\n                (tree_b, grid_b, tree_a, grid_a, start_position),\n            ]:\n                made_progress = False\n\n                for _beam in range(self.beam_width):\n                    sample = self._sample_guided(bounds, obstacles, is_3d, attractor)\n\n                    nearest = self._nearest_by_grid(active_tree, active_grid, sample, is_3d)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos, bounds):\n                        continue\n                    if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                        continue\n                    if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                        continue\n                    if self._has_near_duplicate(active_grid, new_pos, self.min_separation, is_3d):\n                        continue\n\n                    # Choose parent among LOS-capable ancestors to compress path\n                    parent = self._choose_ancestor_parent(nearest, new_pos, obstacles, is_3d)\n                    new_cost = parent.cost + self._distance(parent.position, new_pos)\n\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node, is_3d)\n                    made_progress = True\n\n                    # Try capped greedy connect from the opposite tree toward new_node\n                    connect_node = self._attempt_connect(\n                        other_tree, other_grid, new_node.position, obstacles, is_3d, nodes, edges, bounds\n                    )\n                    if connect_node is not None:\n                        # Trees meet at new_node.position; extract path\n                        path_a = self._path_from_root(new_node)\n                        path_b = self._path_from_root(connect_node)\n                        # Remove duplicate joint if equal\n                        if path_a and path_b and path_a[-1] == path_b[-1]:\n                            path_b = path_b[:-1]\n                        raw_path = path_a + path_b[::-1]\n                        # Light shortcut smoothing\n                        smoothed = self._shortcut_path(raw_path, obstacles, is_3d, attempts=self.shortcut_attempts)\n                        extracted_path = smoothed if smoothed else raw_path\n                        success_state = True\n                        return PlannerResult(True, extracted_path, nodes, edges)\n\n                # If neither beam sample made progress for this tree, continue with the other\n                if not made_progress:\n                    continue\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # --------- Core Geometry / Utilities ---------\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _within_bounds(self, pos, bounds):\n        for i in range(len(bounds)):\n            if pos[i] < 0.0 or pos[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= 1e-9:\n            return from_pos\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * r for d in range(len(from_pos)))\n\n    def _sample_guided(self, bounds, obstacles, is_3d, target):\n        # Mild guidance: with some probability sample exactly target, else blend toward target\n        while True:\n            if random.random() < self.goal_bias:\n                p = target\n            else:\n                rand = tuple(random.uniform(0.0, bounds[d]) for d in range(len(bounds)))\n                alpha = 0.2\n                p = tuple(alpha * target[d] + (1.0 - alpha) * rand[d] for d in range(len(bounds)))\n            if self._within_bounds(p, bounds) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _path_from_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\n\n    # --------- Spatial Hash (Grid) ---------\n\n    def _cell_of(self, pos):\n        # integer grid cell indices\n        if len(pos) == 3:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        else:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node, is_3d):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _has_near_duplicate(self, grid, pos, radius, is_3d):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    def _nearest_by_grid(self, tree, grid, pos, is_3d, ring_limit=3):\n        # Search neighborhood rings; fallback to linear scan if not found\n        cell = self._cell_of(pos)\n        best = None\n        best_d = float(\"inf\")\n\n        if is_3d:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best_d = d\n                                        best = n\n                                        found = True\n                if found and best is not None:\n                    return best\n        else:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                                    found = True\n                if found and best is not None:\n                    return best\n\n        # Fallback\n        if not tree:\n            return None\n        return min(tree, key=lambda n: self._distance(n.position, pos))\n\n    # --------- Parent selection via LOS to ancestors ---------\n\n    def _choose_ancestor_parent(self, nearest, new_pos, obstacles, is_3d):\n        best_parent = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        steps = 0\n        cur = nearest\n        while cur is not None and steps < self.los_lookback_depth:\n            if not self._is_edge_in_obstacle(cur.position, new_pos, obstacles, is_3d):\n                cand_cost = cur.cost + self._distance(cur.position, new_pos)\n                if cand_cost < best_cost:\n                    best_cost = cand_cost\n                    best_parent = cur\n            cur = cur.parent\n            steps += 1\n        return best_parent\n\n    # --------- Connect attempt ---------\n\n    def _attempt_connect(self, tree, grid, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest_by_grid(tree, grid, target_pos, is_3d)\n        if nearest is None:\n            return None\n\n        current = nearest\n        for _ in range(self.connect_steps_limit):\n            step_pos = self._steer(current.position, target_pos)\n            if not self._within_bounds(step_pos, bounds):\n                return None\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                return None\n\n            # If close enough to target and direct edge exists, finalize with exact target node\n            if self._distance(step_pos, target_pos) <= 1e-6 or (\n                self._distance(step_pos, target_pos) <= self.step_size and\n                not self._is_edge_in_obstacle(step_pos, target_pos, obstacles, is_3d) and\n                not self._is_in_obstacle(target_pos, obstacles, is_3d)\n            ):\n                # Add intermediate step node if it is not exactly current\n                if self._distance(current.position, step_pos) > 1e-9:\n                    if not self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                        new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n                        current.add_child(new_node)\n                        tree.append(new_node)\n                        nodes.append(new_node)\n                        edges.append((current, new_node))\n                        self._grid_insert(grid, new_node, is_3d)\n                        current = new_node\n                    else:\n                        # If duplicate exists, try using current as is\n                        pass\n                # Add final node at the exact target position to guarantee path merge\n                final_node = Node(target_pos, parent=current, cost=current.cost + self._distance(current.position, target_pos))\n                current.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((current, final_node))\n                self._grid_insert(grid, final_node, is_3d)\n                return final_node\n\n            # Regular step addition with duplicate suppression\n            if self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                # Progress is negligible; stop trying to avoid loops\n                return None\n\n            new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node, is_3d)\n            current = new_node\n\n        return None\n\n    # --------- Collision Checking ---------\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d):\n        distance = self._distance(from_pos, to_pos)\n        resolution = max(0.5, min(1.0, self.step_size * 0.5))\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    # --------- Shortcut Smoothing (bounded) ---------\n\n    def _shortcut_path(self, path, obstacles, is_3d, attempts=40):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        n = len(pts)\n        tries = 0\n        i = 0\n        # Greedy forward skipping with bounded iterations\n        while i < len(pts) - 2 and tries < attempts:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                    # Remove intermediates\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n            tries += 1\n        return pts",
                "objective": -28.86257,
                "time_improvement": 43.0,
                "length_improvement": 15.0,
                "smoothness_improvement": 1410.0,
                "node_improvement": 90.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.03400664329528809,
                        "num_nodes_avg": 52.1,
                        "path_length_avg": 171.51876006638196,
                        "smoothness_avg": 0.050501544373221775,
                        "success_improvement": 0.0,
                        "time_improvement": -33.36568499023374,
                        "node_improvement": 86.87987912364643,
                        "length_improvement": 5.987849718937115,
                        "smoothness_improvement": 690.45883529979,
                        "objective_score": -2.964701489208901
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.030187082290649415,
                        "num_nodes_avg": 92.2,
                        "path_length_avg": 234.31486940525366,
                        "smoothness_avg": 0.08620583217892899,
                        "success_improvement": 0.0,
                        "time_improvement": 81.1563136658539,
                        "node_improvement": 93.8050124302896,
                        "length_improvement": 21.77895221296278,
                        "smoothness_improvement": 2118.138153515002,
                        "objective_score": 48.004956195108846
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.009754443168640136,
                        "num_nodes_avg": 73.2,
                        "path_length_avg": 124.45355479806292,
                        "smoothness_avg": 0.11960663519260235,
                        "success_improvement": 0.0,
                        "time_improvement": 80.11393158758125,
                        "node_improvement": 90.69294342021614,
                        "length_improvement": 17.343874744565582,
                        "smoothness_improvement": 1421.3875712064366,
                        "objective_score": 41.54744217904591
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "EC-Guide BiRRT with Edge-Cached LOS Compression and Elliptic Focus (EC-GBiRRT). This planner grows two trees from start and goal using a small beam of guided samples, compresses each new extension via multi-ancestor line-of-sight (LOS) with a shared edge-collision memo cache, and attempts a zero-step direct connect to the other tree. After a first path, sampling narrows to a prolate ellipse corridor to accelerate convergence. Early-terminating forward LOS shortcutting finalizes the path. These choices cut repeated collision checks, reduce tree depth, and avoid micro-step connects, improving planning time and path quality.",
            "planning_mechanism": "Each iteration alternates trees: generate a few biased samples, pick a nearby node via a grid hash, steer one step, and validate node/edge. Select the cheapest LOS-ancestor parent using cached edge checks, insert the node, then try a direct LOS link to the other tree\u2019s nearest node; if it succeeds, extract and lightly shortcut the path. A shared bounded edge-cache stores free/blocked results, multi-ancestor compression shortens chains, a per-cell cap limits redundant local growth, and corridor-biased sampling activates once a provisional path exists.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        beam_width=2,\n        goal_bias=0.2,\n        los_lookback_depth=10,\n        min_separation_factor=0.6,\n        grid_cell_factor=1.2,\n        per_cell_cap=12,\n        edge_cache_capacity=20000,\n        shortcut_attempts=60,\n        no_improve_stop=12\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.los_lookback_depth = los_lookback_depth\n        self.min_separation_factor = min_separation_factor\n        self.grid_cell_factor = grid_cell_factor\n        self.per_cell_cap = per_cell_cap\n        self.edge_cache_capacity = edge_cache_capacity\n        self.shortcut_attempts = shortcut_attempts\n        self.no_improve_stop = no_improve_stop\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dims = len(self.bounds)\n        self.is_3d = self.dims == 3\n        self.obstacles = map.obstacles\n        self.start = map.start\n        self.goal = map.goal\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n        self.ecache = {}\n        self._tick = 0\n        self._last_prune = 0\n        self.ecache_quant = max(0.5, self.step_size * 0.5)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(self.start, parent=None, cost=0.0)\n        goal_root = Node(self.goal, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        incumbent_len = None\n        best_path = None\n\n        for _ in range(self.max_iter):\n            # Alternate trees each loop\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, self.goal),\n                (tree_b, grid_b, tree_a, grid_a, self.start),\n            ]:\n                progress = False\n                for _b in range(self.beam_width):\n                    sample = self._guided_sample(attractor, incumbent_len)\n                    if sample is None:\n                        continue\n\n                    nearest = self._nearest_in_grid(active_grid, sample)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos):\n                        continue\n                    if self._in_obstacle(new_pos):\n                        continue\n                    # Check edge to nearest; required before any parent selection\n                    if not self._edge_free(nearest.position, new_pos):\n                        continue\n                    # Duplicate suppression\n                    if self._has_nearby(active_grid, new_pos, self.min_separation):\n                        continue\n\n                    # Parent selection via LOS ancestors using cached edge checks\n                    parent = self._select_parent(nearest, new_pos)\n                    if parent is None:\n                        # Safety: though nearest->new_pos was free, parent selection failed; fallback\n                        parent = nearest\n\n                    # Per-cell growth limit; allow insert if bucket light or cost improves the bucket\n                    cell_key = self._cell_of(new_pos)\n                    bucket = active_grid.get(cell_key)\n                    if bucket and len(bucket) >= self.per_cell_cap:\n                        # Allow only if this is significantly cheaper than the best in bucket\n                        best_bucket_cost = min(n.cost for n in bucket)\n                        cand_cost = parent.cost + self._distance(parent.position, new_pos)\n                        if cand_cost >= best_bucket_cost - 1e-6:\n                            continue\n\n                    new_cost = parent.cost + self._distance(parent.position, new_pos)\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node)\n                    progress = True\n\n                    # Attempt direct LOS connect (no micro-steps)\n                    other_near = self._nearest_in_grid(other_grid, new_node.position)\n                    if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                        path_a = self._path_from_root(new_node)\n                        path_b = self._path_from_root(other_near)\n                        # Merge with direct bridge segment ensured free\n                        raw_path = path_a + path_b[::-1]\n                        # Path might duplicate joint if new_node coincides with other_near; dedup\n                        if len(raw_path) >= 2 and self._distance(raw_path[-1], raw_path[-2]) <= 1e-9:\n                            raw_path.pop()  # remove duplicate\n                        smoothed = self._shortcut(raw_path)\n                        final_path = smoothed if smoothed else raw_path\n                        best_path = final_path\n                        incumbent_len = self._path_length(final_path)\n                        return PlannerResult(True, final_path, nodes, edges)\n\n                # If we found no progress from this side in this alternation, continue to the other\n                if not progress:\n                    continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # ---------- Geometry and metrics ----------\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._distance(a, b)\n        if d <= 1e-12:\n            return a\n        if d <= self.step_size:\n            return b\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n\n    def _path_from_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        length = 0.0\n        for i in range(1, len(path)):\n            length += self._distance(path[i - 1], path[i])\n        return length\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, attractor, incumbent_len):\n        # Corridor-biased sampling if incumbent exists; else mild goal bias\n        # Try limited attempts to avoid heavy rejection\n        for _ in range(20):\n            if incumbent_len is not None and self._distance(self.start, self.goal) > 1e-9:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.05)\n                if p is None:\n                    continue\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if self._within_bounds(p) and not self._in_obstacle(p):\n                return p\n        # Fallback hard-attractor\n        return attractor if self._within_bounds(attractor) and not self._in_obstacle(attractor) else None\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        # Rejection sample in the bounding box of the ellipse/spheroid\n        # Limited attempts for speed; returns None on failure\n        cx = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        # Direction vector and its norm\n        v = tuple(f2[i] - f1[i] for i in range(self.dims))\n        vd = self._distance(f1, f2)\n        # Bounding box extents\n        ext = [half, half, half] if self.is_3d else [half, half]\n        # Try a few samples\n        for _ in range(12):\n            p = tuple(cx[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            # ellipse condition: dist(p,f1)+dist(p,f2) <= max_sum_dist\n            if self._distance(p, f1) + self._distance(p, f2) <= max_sum_dist and not self._in_obstacle(p):\n                return p\n        return None\n\n    # ---------- Grid spatial hash ----------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    def _nearest_in_grid(self, grid, pos, max_ring=5):\n        cell = self._cell_of(pos)\n        best = None\n        best_d = 1e100\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best = n\n                                        best_d = d\n                                        found = True\n                if found:\n                    return best\n        else:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best = n\n                                    best_d = d\n                                    found = True\n                if found:\n                    return best\n        # Rare fallback: scan all buckets\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._distance(n.position, pos)\n                if d < best_d:\n                    best = n\n                    best_d = d\n        return best\n\n    # ---------- Obstacles ----------\n    def _in_obstacle(self, pos):\n        if self.is_3d:\n            px, py, pz = pos\n            for obs in self.obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in self.obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.ecache_quant) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.ecache_quant) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]  # True if free, False if blocked\n        # Compute and cache\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        # Bounded pruning\n        if len(self.ecache) - self._last_prune > self.edge_cache_capacity:\n            self._prune_cache()\n        return free\n\n    def _prune_cache(self):\n        # Drop roughly oldest 40%\n        if not self.ecache:\n            return\n        cutoff = self._tick - 2000\n        to_remove = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_remove.append(k)\n        if not to_remove:\n            # If nothing older than cutoff, remove every 3rd entry to bound size\n            i = 0\n            for k in list(self.ecache.keys()):\n                if i % 3 == 0:\n                    to_remove.append(k)\n                i += 1\n        for k in to_remove:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune = len(self.ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        dist = self._distance(a, b)\n        # Resolution tuned for speed while preserving safety\n        resolution = max(0.5, min(1.0, self.step_size * 0.5))\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(self.dims))\n            if self._in_obstacle(p):\n                return True\n        return False\n\n    # ---------- Parent selection ----------\n    def _select_parent(self, nearest, new_pos):\n        best = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        cur = nearest\n        depth = 0\n        while cur is not None and depth < self.los_lookback_depth:\n            if self._edge_free(cur.position, new_pos):\n                cand = cur.cost + self._distance(cur.position, new_pos)\n                if cand + 1e-9 < best_cost:\n                    best_cost = cand\n                    best = cur\n            cur = cur.parent\n            depth += 1\n        return best\n\n    # ---------- Shortcut smoothing ----------\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_improve = 0\n        i = 0\n        while attempts < self.shortcut_attempts and i < len(pts) - 2:\n            improved = False\n            # Try to jump from i to a farther j\n            j = len(pts) - 1\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    # Remove intermediates\n                    del pts[i + 1:j]\n                    improved = True\n                    no_improve = 0\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n                no_improve += 1\n            attempts += 1\n            if no_improve >= self.no_improve_stop:\n                break\n        return pts\n\n    # ---------- Random helpers ----------\n    def _rand(self):\n        # expects 'random' module available\n        return random.random()\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()",
            "objective": -29.11471,
            "time_improvement": 51.0,
            "length_improvement": 10.0,
            "smoothness_improvement": 1571.0,
            "node_improvement": 89.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02822730541229248,
                    "num_nodes_avg": 65.6,
                    "path_length_avg": 182.96020324956595,
                    "smoothness_avg": 0.05732726413788967,
                    "success_improvement": 0.0,
                    "time_improvement": -10.700544274551492,
                    "node_improvement": 83.48023167967766,
                    "length_improvement": -0.28338659103527,
                    "smoothness_improvement": 797.2961719045505,
                    "objective_score": 0.6062856225361433
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01984243392944336,
                    "num_nodes_avg": 86.6,
                    "path_length_avg": 243.5413235727727,
                    "smoothness_avg": 0.09042567896577892,
                    "success_improvement": 0.0,
                    "time_improvement": 87.61375486797985,
                    "node_improvement": 94.18128065578178,
                    "length_improvement": 18.698896243086562,
                    "smoothness_improvement": 2226.7178507734366,
                    "objective_score": 48.63705346011307
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01169896125793457,
                    "num_nodes_avg": 78.1,
                    "path_length_avg": 133.4682422714018,
                    "smoothness_avg": 0.1405957321950529,
                    "success_improvement": 0.0,
                    "time_improvement": 76.14970532839176,
                    "node_improvement": 90.06993006993007,
                    "length_improvement": 11.356748558062376,
                    "smoothness_improvement": 1688.3673358236224,
                    "objective_score": 38.100797412473064
                }
            ],
            "success_rate": 1.0
        },
        "objective": 27.4,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Repeated, uncached edge-collision checks during ancestor LOS selection, connection attempts, and smoothing, causing high per-extension overhead.\n   - Inefficient tree-connection via incremental micro-steps that add many nodes, trigger dense collision sampling, and often abort on near-duplicates.\n   - Spatial hashing with narrow neighborhood search leading to frequent global fallbacks and costly nearest-neighbor lookups.\n   - No control on local node proliferation; densely populated cells accumulate redundant nodes and checks.\n   - Sampling lacks focused guidance once a provisional route is available, leading to wasted expansions in irrelevant regions.\n   - Post-processing shortcutting performs many fresh collision queries without reuse, adding extra solve-time costs."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Edge-collision memoization with bounded pruning used across parent selection, connection checks, and smoothing.\n   - Direct line-of-sight bridging between the two trees (no incremental connect steps or forced final-node insertion).\n   - Per-cell growth cap with cost-based admission to curb redundant local expansions.\n   - Tuned spatial hash (larger cells, wider ring search) to reduce nearest-neighbor fallbacks and improve locality.\n   - Leaner expansion per iteration (narrower beam, slightly higher goal bias) to cut low-yield samples.\n   - Early-terminating shortcutting that reuses cached edge results.\n   - Optional corridor-biased sampling (ellipse) once an incumbent path exists.\n2. Expected mechanism of impact:\n   - Caching eliminates many repeated edge checks, slashing CPU time in ancestor selection and smoothing.\n   - Direct LOS bridging reduces iterations and node/bookkeeping overhead by avoiding micro-step connects.\n   - Local growth limits lower branching and collision-test volume in crowded cells.\n   - Improved NN queries reduce O(N) fallbacks and accelerate extension decisions.\n   - Fewer, better-guided samples decrease unproductive expansions, improving wall-clock time.\n   - Shortcutting with cache avoids redundant computations, shortening post-solve processing.\n   - Focused corridor sampling concentrates effort where connection is likely, accelerating convergence once a route is found."
        }
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm with post-optimization: a bidirectional RRT*-Connect that, after finding a first feasible \u201cbest shot\u201d path, keeps optimizing for only a user-defined number of extra iterations (or until no further improvements occur), then terminates\u2014while maintaining strict collision checks and a 30 s time cap.",
                "planning_mechanism": "Mechanism: Alternate tree growth with RRT* best-parent selection and local rewiring; greedily connect the opposite tree; upon the first connection, record the best path and continue only N additional iterations (or until M consecutive non-improving attempts), always staying within bounds and validating node and edge collisions; stop early on time limit and return the best path so far.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from its tree root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        post_opt_iters: int = 400,   # extra iterations after first solution\n        max_no_improve: int = 150,   # early stop if no improvement for this many iterations\n        improve_tol: float = 1e-6,   # minimal cost drop to count as improvement\n        goal_sample_rate: float = 0.05,   # mild goal bias\n        bridge_bias_rate: float = 0.15,   # bias toward the opposite tree root\n        neighbor_gamma: float = 60.0,     # RRT* radius coefficient\n        time_limit_sec: float = 30.0      # hard wall time limit\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.goal_sample_rate = goal_sample_rate\n        self.bridge_bias_rate = bridge_bias_rate\n        self.neighbor_gamma = neighbor_gamma\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map: Map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Core data\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        # Initialize bidirectional trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root  = Node(goal_position,  cost=0.0)\n        tree_start: List[Node] = [start_root]\n        tree_goal:  List[Node] = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Practical RRT* neighborhood clamps\n        max_radius = max(bounds) * 0.30\n        min_radius = max(10.0, self.step_size * 2.0)\n\n        # Best solution tracking + post-optimization control\n        best_cost = float(\"inf\")\n        best_path: List[Tuple[float, ...]] = []\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        # Hard time limit\n        start_time = time.time()\n\n        # ----------------- Helper functions -----------------\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def clamp_bounds(p):\n            return tuple(min(max(p[d], 0.0), bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            d = math.dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return clamp_bounds(to_pos)\n            r = self.step_size / d\n            return clamp_bounds(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(dim)))\n\n        def nearest(tree, pt):\n            return min(tree, key=lambda n: math.dist(n.position, pt))\n\n        def neighbor_radius(n_nodes: int) -> float:\n            if n_nodes < 2:\n                return min_radius\n            r_theory = self.neighbor_gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n            return max(min_radius, min(max_radius, r_theory))\n\n        def near_nodes(tree, pos, radius):\n            return [nd for nd in tree if math.dist(nd.position, pos) <= radius]\n\n        def uniform_sample():\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_free(active_tree, other_tree):\n            # Goal bias toward the global goal or start depending on active tree\n            if random.random() < self.goal_sample_rate:\n                return goal_position if active_tree is tree_start else start_position\n            # Bridge bias: sample around the opposite root to encourage meeting\n            if random.random() < self.bridge_bias_rate:\n                anchor = other_tree[0].position\n                jitter = tuple(random.uniform(-2.0*self.step_size, 2.0*self.step_size) for _ in range(dim))\n                s = clamp_bounds(tuple(anchor[i] + jitter[i] for i in range(dim)))\n                return s if not self._is_in_obstacle(s, obstacles, is_3d) else uniform_sample()\n            # Uniform fallback\n            return uniform_sample()\n\n        def add_with_best_parent(tree, new_pos):\n            \"\"\"Insert new_pos with RRT* best-parent selection; returns (new_node, neighbors) or (None, []).\"\"\"\n            r = neighbor_radius(len(tree))\n            neigh = near_nodes(tree, new_pos, r)\n            if not neigh:\n                parent = nearest(tree, new_pos)\n                if self._is_edge_in_obstacle(parent.position, new_pos, obstacles, is_3d):\n                    return None, []\n            else:\n                candidates = [nb for nb in neigh if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d)]\n                if not candidates:\n                    return None, []\n                parent = min(candidates, key=lambda nb: nb.cost + math.dist(nb.position, new_pos))\n\n            new_node = Node(new_pos, parent=None, cost=parent.cost + math.dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            return new_node, neigh\n\n        def rewire_from(pivot: Node, neigh: List[Node]):\n            \"\"\"Local RRT* rewiring around pivot (edge and cost validated).\"\"\"\n            for nb in neigh:\n                if nb is pivot:\n                    continue\n                if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                    continue\n                new_c = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_c + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_c\n                    edges.append((pivot, nb))\n\n        def stitch_paths(a_node: Node, b_node: Node, a_is_start_side: bool) -> List[Tuple[float, ...]]:\n            \"\"\"Combine root\u2192a_node and root\u2192b_node into a single start\u2192goal path.\"\"\"\n            pa = a_node.path_from_root()\n            pb = b_node.path_from_root()\n            if pa and pb and pa[-1] == pb[-1]:\n                merged = pa + pb[-2::-1]\n            else:\n                merged = pa + pb[::-1]\n            return merged if a_is_start_side else merged[::-1]\n\n        def path_cost(path: List[Tuple[float, ...]]) -> float:\n            return sum(math.dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        # ----------------- Main loop -----------------\n        for it in range(self.max_iter):\n            # Enforce 30s time limit (return best so far)\n            if time.time() - start_time > self.time_limit_sec:\n                return PlannerResult(\n                    success=(len(best_path) > 0),\n                    path=best_path if best_path else [],\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            # Alternate trees\n            if it % 2 == 0:\n                grow_tree, other_tree = tree_start, tree_goal\n                a_is_start_side = True\n            else:\n                grow_tree, other_tree = tree_goal, tree_start\n                a_is_start_side = False\n\n            # Sampling\n            s = sample_free(grow_tree, other_tree)\n\n            # Extend grow_tree toward sample\n            a_near = nearest(grow_tree, s)\n            a_new_pos = steer(a_near.position, s)\n\n            # Node & edge validity\n            if not within_bounds(a_new_pos) or self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            if self._is_edge_in_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            a_new, a_neigh = add_with_best_parent(grow_tree, a_new_pos)\n            if a_new is None:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n            rewire_from(a_new, a_neigh)\n\n            # Greedy connect the other tree toward a_new with stepwise rewiring\n            b_near = nearest(other_tree, a_new.position)\n            current = b_near\n            connected_b = None\n\n            while True:\n                step_pos = steer(current.position, a_new.position)\n                if not within_bounds(step_pos) or self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                    break\n\n                b_new, b_neigh = add_with_best_parent(other_tree, step_pos)\n                if b_new is None:\n                    break\n                rewire_from(b_new, b_neigh)\n                current = b_new\n\n                # Try to close the final short bridge exactly to a_new\n                if math.dist(current.position, a_new.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(current.position, a_new.position, obstacles, is_3d) and a_new.valid:\n                        final_b = Node(\n                            a_new.position,\n                            parent=None,\n                            cost=current.cost + math.dist(current.position, a_new.position)\n                        )\n                        current.add_child(final_b)\n                        other_tree.append(final_b)\n                        nodes.append(final_b)\n                        edges.append((current, final_b))\n                        connected_b = final_b\n                    break\n\n            # If a connection was made, evaluate candidate and manage post-optimization counters\n            if connected_b is not None:\n                candidate = stitch_paths(a_new, connected_b, a_is_start_side)\n                cand_cost = path_cost(candidate)\n\n                if cand_cost + self.improve_tol < best_cost:\n                    best_cost = cand_cost\n                    best_path = candidate\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0\n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                # No successful connection this iteration\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ----------------- Collision utilities -----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps)\n                for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": 61.276875445186825,
                "time_improvement": -249.0,
                "length_improvement": 19.0,
                "smoothness_improvement": 396.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.1527228832244873,
                        "num_nodes_avg": 353.2,
                        "path_length_avg": 154.84589437556275,
                        "smoothness_avg": 0.036504670776118395,
                        "success_improvement": 0.0,
                        "time_improvement": -498.94155850834557,
                        "node_improvement": 11.055149836313278,
                        "length_improvement": 15.12651160253883,
                        "smoothness_improvement": 471.37736880762213,
                        "objective_score": -138.24967374694225
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.14496326446533203,
                        "num_nodes_avg": 649.1,
                        "path_length_avg": 236.19902822185213,
                        "smoothness_avg": 0.016202565568581816,
                        "success_improvement": 0.0,
                        "time_improvement": 9.509562426153382,
                        "node_improvement": 56.3864812201841,
                        "length_improvement": 21.14996576747767,
                        "smoothness_improvement": 316.90368231587473,
                        "objective_score": 17.12736659991199
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.17532651424407958,
                        "num_nodes_avg": 731.9,
                        "path_length_avg": 119.13487163387659,
                        "smoothness_avg": 0.03924013026708708,
                        "success_improvement": 0.0,
                        "time_improvement": -257.4325050124552,
                        "node_improvement": 6.942148760330581,
                        "length_improvement": 20.87629085374207,
                        "smoothness_improvement": 399.1315605922187,
                        "objective_score": -62.708319188530226
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -24.971436625701273,
                "time_improvement": 62.0,
                "length_improvement": 9.0,
                "smoothness_improvement": 168.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.009481477737426757,
                        "num_nodes_avg": 112.0,
                        "path_length_avg": 170.25136521926942,
                        "smoothness_avg": 0.017004537999713392,
                        "success_improvement": 0.0,
                        "time_improvement": 62.815977978432855,
                        "node_improvement": 71.7955175018887,
                        "length_improvement": 6.682528917796031,
                        "smoothness_improvement": 166.15794564080122,
                        "objective_score": 23.68510047241148
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.0245816707611084,
                        "num_nodes_avg": 299.2,
                        "path_length_avg": 258.5973544494462,
                        "smoothness_avg": 0.010851066788952054,
                        "success_improvement": 0.0,
                        "time_improvement": 84.6553804394982,
                        "node_improvement": 79.89652623798965,
                        "length_improvement": 13.67275977263268,
                        "smoothness_improvement": 179.20576418723118,
                        "objective_score": 34.496298816365226
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.030178475379943847,
                        "num_nodes_avg": 287.8,
                        "path_length_avg": 139.5271231166937,
                        "smoothness_avg": 0.020290033291575655,
                        "success_improvement": 0.0,
                        "time_improvement": 38.47611641047452,
                        "node_improvement": 63.40750158931977,
                        "length_improvement": 7.332728393521491,
                        "smoothness_improvement": 158.08772581437248,
                        "objective_score": 16.732910588327112
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "Bounded BiRRT-Connect with Grid-Accelerated Nearest and Lightweight Shortcutting: a time-capped, bidirectional RRT-Connect that uses a coarse spatial grid for fast nearest-neighbor queries, commits only validated steps, attempts a single greedy bridge per iteration, and applies a brief shortcut smoother to the first found path for quality without heavy rewiring or anytime overhead.",
            "planning_mechanism": "Mechanism: Alternate growing start/goal trees with one extend loop toward a biased sample; each successful extension triggers a greedy extend from the opposite tree toward the new node. Both node and edge collisions are strictly checked before every insertion and the final bridge. Nearest queries use a bucket grid with limited ring expansion and linear fallback. On success, a bounded-time shortcut pass improves path length/smoothness; the planner enforces a hard time limit and returns the best (first) feasible path promptly.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=6.0,\n        goal_sample_rate=0.15,\n        bridge_bias_rate=0.30,\n        cell_size_factor=2.0,\n        time_limit_sec=12.0,\n        edge_resolution=1.0,\n        smooth_attempts=80,\n        smooth_time_frac=0.2\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.bridge_bias_rate = bridge_bias_rate\n        self.cell_size_factor = cell_size_factor\n        self.time_limit_sec = time_limit_sec\n        self.edge_resolution = edge_resolution\n        self.smooth_attempts = smooth_attempts\n        self.smooth_time_frac = smooth_time_frac\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Validate start/goal feasibility\n        if self._is_in_obstacle(start_position, obstacles, is_3d) or self._is_in_obstacle(goal_position, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Initialize trees and spatial grids\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root = Node(goal_position, parent=None, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        grid_start = {}\n        grid_goal = {}\n        self._grid_insert(grid_start, start_root.position, start_root, cell_size, dim)\n        self._grid_insert(grid_goal, goal_root.position, goal_root, cell_size, dim)\n\n        start_time = time.time()\n\n        # Early straight-line check\n        if not self._is_edge_in_obstacle(start_position, goal_position, obstacles, is_3d, self.edge_resolution):\n            edges.append((start_root, goal_root))\n            direct_path = [start_position, goal_position]\n            return PlannerResult(True, direct_path, start_tree + goal_tree, edges)\n\n        # Main loop\n        for it in range(self.max_iter):\n            if time.time() - start_time >= self.time_limit_sec:\n                return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n            # Alternate tree growth\n            if it % 2 == 0:\n                grow_tree, grow_grid = start_tree, grid_start\n                other_tree, other_grid = goal_tree, grid_goal\n                a_is_start_side = True\n                other_root_pos = goal_root.position\n            else:\n                grow_tree, grow_grid = goal_tree, grid_goal\n                other_tree, other_grid = start_tree, grid_start\n                a_is_start_side = False\n                other_root_pos = start_root.position\n\n            sample = self._sample(bounds, obstacles, is_3d, other_root_pos)\n\n            # Extend grow_tree toward sample\n            a_near = self._nearest_from_grid(grow_tree, grow_grid, sample, cell_size, dim)\n            a_last = self._extend(grow_tree, grow_grid, a_near, sample, nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if a_last is None:\n                continue\n\n            # Greedy connect: extend other_tree toward the new node\n            b_near = self._nearest_from_grid(other_tree, other_grid, a_last.position, cell_size, dim)\n            b_last = self._extend(other_tree, other_grid, b_near, a_last.position, nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if b_last is None:\n                continue\n\n            # Attempt final short bridge\n            if self._distance(b_last.position, a_last.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(b_last.position, a_last.position, obstacles, is_3d, self.edge_resolution):\n                    edges.append((b_last, a_last))\n                    # Extract and smooth path\n                    final_path = self._assemble_path(a_last, b_last, a_is_start_side)\n                    remaining = max(0.0, self.time_limit_sec - (time.time() - start_time))\n                    budget = min(remaining, self.time_limit_sec * self.smooth_time_frac)\n                    final_path = self._shortcut_path(final_path, obstacles, is_3d, bounds, budget, self.smooth_attempts)\n                    return PlannerResult(True, final_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---- Utilities ----\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _within_bounds(self, p, bounds):\n        for i in range(len(bounds)):\n            if p[i] < 0.0 or p[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step_size):\n        d = self._distance(from_pos, to_pos)\n        if d <= step_size:\n            return to_pos\n        r = step_size / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _sample(self, bounds, obstacles, is_3d, other_root_pos):\n        # Bias toward the opposite root\n        if random.random() < self.bridge_bias_rate:\n            return other_root_pos\n        # Mild goal bias to encourage meeting/goal attraction\n        if random.random() < self.goal_sample_rate:\n            return other_root_pos\n        # Uniform rejection sampling in free space\n        dim = len(bounds)\n        for _ in range(30):\n            pt = tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n        # Fallback: last sample even if occupied (extend will reject)\n        return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n\n    def _extend(self, tree, grid, nearest_node, target_pos, nodes, edges, obstacles, is_3d, bounds, cell_size, dim):\n        current = nearest_node\n        last_new = None\n        while True:\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if not self._within_bounds(step_pos, bounds):\n                break\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                break\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d, self.edge_resolution):\n                break\n            # Both node and edge are valid \u2192 commit\n            new_node = Node(step_pos)\n            new_node.cost = current.cost + self._distance(current.position, step_pos)\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node.position, new_node, cell_size, dim)\n            last_new = new_node\n            current = new_node\n            # Stop if reached target (within one step)\n            if self._distance(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    def _assemble_path(self, a_node, b_node, a_is_start_side):\n        if a_is_start_side:\n            pa = a_node.path_from_root()   # start -> ... -> a\n            pb = b_node.path_from_root()   # goal  -> ... -> b\n            return pa + pb[::-1]           # start ... a, b ... goal\n        else:\n            pa = a_node.path_from_root()   # goal  -> ... -> a\n            pb = b_node.path_from_root()   # start -> ... -> b\n            return pb + pa[::-1]           # start ... b, a ... goal\n\n    # ---- Spatial grid for approximate nearest ----\n    def _cell_index(self, pos, cell_size, dim):\n        if dim == 2:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size))\n        else:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size), int(pos[2] // cell_size))\n\n    def _grid_insert(self, grid, pos, node, cell_size, dim):\n        idx = self._cell_index(pos, cell_size, dim)\n        if idx in grid:\n            grid[idx].append(node)\n        else:\n            grid[idx] = [node]\n\n    def _nearest_from_grid(self, tree, grid, point, cell_size, dim, max_rings=3):\n        # For small trees, just do linear scan\n        if len(tree) < 32:\n            return min(tree, key=lambda n: self._distance(n.position, point))\n\n        center = self._cell_index(point, cell_size, dim)\n        best = None\n        # Expand rings until some candidates found, then pick nearest among them\n        for r in range(0, max_rings + 1):\n            candidates = []\n            if dim == 2:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        idx = (center[0] + dx, center[1] + dy)\n                        if idx in grid:\n                            candidates.extend(grid[idx])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if idx in grid:\n                                candidates.extend(grid[idx])\n            if candidates:\n                best = min(candidates, key=lambda n: self._distance(n.position, point))\n                break\n\n        if best is None:\n            # Fallback to linear scan if grid empty nearby\n            best = min(tree, key=lambda n: self._distance(n.position, point))\n        return best\n\n    # ---- Collision utilities ----\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist / max(1e-6, resolution)))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    # ---- Path shortcutting ----\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, time_budget, attempts):\n        if len(path) < 3:\n            return path\n        start_t = time.time()\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and (time.time() - start_t) <= time_budget:\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            # Keep within bounds and collision-free\n            if not self._segment_within_bounds(a, b, bounds):\n                tries += 1\n                continue\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_resolution):\n                # Apply shortcut\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n            tries += 1\n        return pts\n\n    def _segment_within_bounds(self, a, b, bounds):\n        # The interpolated segment is within bounds if endpoints are; checks along the way via edge collision\n        for d in range(len(bounds)):\n            if a[d] < 0.0 or a[d] > bounds[d]:\n                return False\n            if b[d] < 0.0 or b[d] > bounds[d]:\n                return False\n        return True",
            "objective": -35.38986,
            "time_improvement": 79.0,
            "length_improvement": 6.0,
            "smoothness_improvement": 1571.0,
            "node_improvement": 81.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009288859367370606,
                    "num_nodes_avg": 87.5,
                    "path_length_avg": 179.7819366813108,
                    "smoothness_avg": 0.041891929272141075,
                    "success_improvement": 0.0,
                    "time_improvement": 63.57137981686718,
                    "node_improvement": 77.96524804835055,
                    "length_improvement": 1.4586716778820132,
                    "smoothness_improvement": 555.6996628894441,
                    "objective_score": 22.725115266236582
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009074711799621582,
                    "num_nodes_avg": 124.9,
                    "path_length_avg": 251.58839597257443,
                    "smoothness_avg": 0.10077141463831178,
                    "success_improvement": 0.0,
                    "time_improvement": 94.3352914641303,
                    "node_improvement": 91.6078747564335,
                    "length_improvement": 16.01255185389636,
                    "smoothness_improvement": 2492.9210813599107,
                    "objective_score": 50.372723958376454
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01003124713897705,
                    "num_nodes_avg": 215.4,
                    "path_length_avg": 148.33090891427284,
                    "smoothness_avg": 0.13860849885025553,
                    "success_improvement": 0.0,
                    "time_improvement": 79.54962026854608,
                    "node_improvement": 72.6128417037508,
                    "length_improvement": 1.4856730579993105,
                    "smoothness_improvement": 1663.0898743601072,
                    "objective_score": 33.07173928716395
                }
            ],
            "success_rate": 1.0
        },
        "objective": 40.599999999999994,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Nearest/near queries rely on full linear scans, leading to high per-iteration cost as trees grow.\n   - Large or fixed neighbor sets trigger many parent evaluations, rewires, and collision checks.\n   - Dense edge-collision sampling is applied repeatedly for candidates and rewiring, compounding cost.\n   - Connections are limited to single-step attempts, causing frequent failed bridges through clutter.\n   - Greedy bidirectional connects insert multiple nodes and rewires within an iteration, inflating checks.\n   - Prolonged or unbounded post-solution optimization phases lack strict time budgeting.\n   - Weak/inefficient sampling biases cause exploration drift and slow tree meeting.\n   - No lightweight shortcutting; quality improvements depend on heavy rewiring, increasing runtime."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Approximate nearest-neighbor via a coarse spatial grid, with limited ring expansion and linear fallback.\n   - Multi-step extend-then-connect growth that commits only validated segments per attempt.\n   - Stronger goal/bridge-directed sampling to quickly bring trees together.\n   - Early straight-line feasibility check to exit immediately on easy instances.\n   - Strict wall-clock cap and return-on-first-feasible-path, avoiding lengthy post-optimization.\n   - Lightweight, time-bounded shortcut smoothing instead of structural rewiring.\n\n2. Expected mechanism of impact:\n   - Reduces per-iteration complexity from global O(n) scans/rewires to local, near-constant lookups without rewiring.\n   - Cuts collision-check volume by validating only along committed extensions and avoiding neighbor-wide rewires.\n   - Decreases failed connection attempts and total iterations via guided sampling and extended steps.\n   - Enables immediate termination on trivial cases and enforces predictable, lower planning time via hard limits.\n   - Decouples path quality from planning effort through brief shortcutting, preserving time gains while modestly improving paths."
        }
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "EC-Guide BiRRT with Edge-Cached LOS Compression and Elliptic Focus (EC-GBiRRT). This planner grows two trees from start and goal using a small beam of guided samples, compresses each new extension via multi-ancestor line-of-sight (LOS) with a shared edge-collision memo cache, and attempts a zero-step direct connect to the other tree. After a first path, sampling narrows to a prolate ellipse corridor to accelerate convergence. Early-terminating forward LOS shortcutting finalizes the path. These choices cut repeated collision checks, reduce tree depth, and avoid micro-step connects, improving planning time and path quality.",
                "planning_mechanism": "Each iteration alternates trees: generate a few biased samples, pick a nearby node via a grid hash, steer one step, and validate node/edge. Select the cheapest LOS-ancestor parent using cached edge checks, insert the node, then try a direct LOS link to the other tree\u2019s nearest node; if it succeeds, extract and lightly shortcut the path. A shared bounded edge-cache stores free/blocked results, multi-ancestor compression shortens chains, a per-cell cap limits redundant local growth, and corridor-biased sampling activates once a provisional path exists.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        beam_width=2,\n        goal_bias=0.2,\n        los_lookback_depth=10,\n        min_separation_factor=0.6,\n        grid_cell_factor=1.2,\n        per_cell_cap=12,\n        edge_cache_capacity=20000,\n        shortcut_attempts=60,\n        no_improve_stop=12\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.los_lookback_depth = los_lookback_depth\n        self.min_separation_factor = min_separation_factor\n        self.grid_cell_factor = grid_cell_factor\n        self.per_cell_cap = per_cell_cap\n        self.edge_cache_capacity = edge_cache_capacity\n        self.shortcut_attempts = shortcut_attempts\n        self.no_improve_stop = no_improve_stop\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dims = len(self.bounds)\n        self.is_3d = self.dims == 3\n        self.obstacles = map.obstacles\n        self.start = map.start\n        self.goal = map.goal\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n        self.ecache = {}\n        self._tick = 0\n        self._last_prune = 0\n        self.ecache_quant = max(0.5, self.step_size * 0.5)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(self.start, parent=None, cost=0.0)\n        goal_root = Node(self.goal, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        incumbent_len = None\n        best_path = None\n\n        for _ in range(self.max_iter):\n            # Alternate trees each loop\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, self.goal),\n                (tree_b, grid_b, tree_a, grid_a, self.start),\n            ]:\n                progress = False\n                for _b in range(self.beam_width):\n                    sample = self._guided_sample(attractor, incumbent_len)\n                    if sample is None:\n                        continue\n\n                    nearest = self._nearest_in_grid(active_grid, sample)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos):\n                        continue\n                    if self._in_obstacle(new_pos):\n                        continue\n                    # Check edge to nearest; required before any parent selection\n                    if not self._edge_free(nearest.position, new_pos):\n                        continue\n                    # Duplicate suppression\n                    if self._has_nearby(active_grid, new_pos, self.min_separation):\n                        continue\n\n                    # Parent selection via LOS ancestors using cached edge checks\n                    parent = self._select_parent(nearest, new_pos)\n                    if parent is None:\n                        # Safety: though nearest->new_pos was free, parent selection failed; fallback\n                        parent = nearest\n\n                    # Per-cell growth limit; allow insert if bucket light or cost improves the bucket\n                    cell_key = self._cell_of(new_pos)\n                    bucket = active_grid.get(cell_key)\n                    if bucket and len(bucket) >= self.per_cell_cap:\n                        # Allow only if this is significantly cheaper than the best in bucket\n                        best_bucket_cost = min(n.cost for n in bucket)\n                        cand_cost = parent.cost + self._distance(parent.position, new_pos)\n                        if cand_cost >= best_bucket_cost - 1e-6:\n                            continue\n\n                    new_cost = parent.cost + self._distance(parent.position, new_pos)\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node)\n                    progress = True\n\n                    # Attempt direct LOS connect (no micro-steps)\n                    other_near = self._nearest_in_grid(other_grid, new_node.position)\n                    if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                        path_a = self._path_from_root(new_node)\n                        path_b = self._path_from_root(other_near)\n                        # Merge with direct bridge segment ensured free\n                        raw_path = path_a + path_b[::-1]\n                        # Path might duplicate joint if new_node coincides with other_near; dedup\n                        if len(raw_path) >= 2 and self._distance(raw_path[-1], raw_path[-2]) <= 1e-9:\n                            raw_path.pop()  # remove duplicate\n                        smoothed = self._shortcut(raw_path)\n                        final_path = smoothed if smoothed else raw_path\n                        best_path = final_path\n                        incumbent_len = self._path_length(final_path)\n                        return PlannerResult(True, final_path, nodes, edges)\n\n                # If we found no progress from this side in this alternation, continue to the other\n                if not progress:\n                    continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # ---------- Geometry and metrics ----------\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._distance(a, b)\n        if d <= 1e-12:\n            return a\n        if d <= self.step_size:\n            return b\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n\n    def _path_from_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        length = 0.0\n        for i in range(1, len(path)):\n            length += self._distance(path[i - 1], path[i])\n        return length\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, attractor, incumbent_len):\n        # Corridor-biased sampling if incumbent exists; else mild goal bias\n        # Try limited attempts to avoid heavy rejection\n        for _ in range(20):\n            if incumbent_len is not None and self._distance(self.start, self.goal) > 1e-9:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.05)\n                if p is None:\n                    continue\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if self._within_bounds(p) and not self._in_obstacle(p):\n                return p\n        # Fallback hard-attractor\n        return attractor if self._within_bounds(attractor) and not self._in_obstacle(attractor) else None\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        # Rejection sample in the bounding box of the ellipse/spheroid\n        # Limited attempts for speed; returns None on failure\n        cx = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        # Direction vector and its norm\n        v = tuple(f2[i] - f1[i] for i in range(self.dims))\n        vd = self._distance(f1, f2)\n        # Bounding box extents\n        ext = [half, half, half] if self.is_3d else [half, half]\n        # Try a few samples\n        for _ in range(12):\n            p = tuple(cx[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            # ellipse condition: dist(p,f1)+dist(p,f2) <= max_sum_dist\n            if self._distance(p, f1) + self._distance(p, f2) <= max_sum_dist and not self._in_obstacle(p):\n                return p\n        return None\n\n    # ---------- Grid spatial hash ----------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    def _nearest_in_grid(self, grid, pos, max_ring=5):\n        cell = self._cell_of(pos)\n        best = None\n        best_d = 1e100\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best = n\n                                        best_d = d\n                                        found = True\n                if found:\n                    return best\n        else:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best = n\n                                    best_d = d\n                                    found = True\n                if found:\n                    return best\n        # Rare fallback: scan all buckets\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._distance(n.position, pos)\n                if d < best_d:\n                    best = n\n                    best_d = d\n        return best\n\n    # ---------- Obstacles ----------\n    def _in_obstacle(self, pos):\n        if self.is_3d:\n            px, py, pz = pos\n            for obs in self.obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in self.obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.ecache_quant) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.ecache_quant) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]  # True if free, False if blocked\n        # Compute and cache\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        # Bounded pruning\n        if len(self.ecache) - self._last_prune > self.edge_cache_capacity:\n            self._prune_cache()\n        return free\n\n    def _prune_cache(self):\n        # Drop roughly oldest 40%\n        if not self.ecache:\n            return\n        cutoff = self._tick - 2000\n        to_remove = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_remove.append(k)\n        if not to_remove:\n            # If nothing older than cutoff, remove every 3rd entry to bound size\n            i = 0\n            for k in list(self.ecache.keys()):\n                if i % 3 == 0:\n                    to_remove.append(k)\n                i += 1\n        for k in to_remove:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune = len(self.ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        dist = self._distance(a, b)\n        # Resolution tuned for speed while preserving safety\n        resolution = max(0.5, min(1.0, self.step_size * 0.5))\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(self.dims))\n            if self._in_obstacle(p):\n                return True\n        return False\n\n    # ---------- Parent selection ----------\n    def _select_parent(self, nearest, new_pos):\n        best = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        cur = nearest\n        depth = 0\n        while cur is not None and depth < self.los_lookback_depth:\n            if self._edge_free(cur.position, new_pos):\n                cand = cur.cost + self._distance(cur.position, new_pos)\n                if cand + 1e-9 < best_cost:\n                    best_cost = cand\n                    best = cur\n            cur = cur.parent\n            depth += 1\n        return best\n\n    # ---------- Shortcut smoothing ----------\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_improve = 0\n        i = 0\n        while attempts < self.shortcut_attempts and i < len(pts) - 2:\n            improved = False\n            # Try to jump from i to a farther j\n            j = len(pts) - 1\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    # Remove intermediates\n                    del pts[i + 1:j]\n                    improved = True\n                    no_improve = 0\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n                no_improve += 1\n            attempts += 1\n            if no_improve >= self.no_improve_stop:\n                break\n        return pts\n\n    # ---------- Random helpers ----------\n    def _rand(self):\n        # expects 'random' module available\n        return random.random()\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()",
                "objective": -29.11471,
                "time_improvement": 51.0,
                "length_improvement": 10.0,
                "smoothness_improvement": 1571.0,
                "node_improvement": 89.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.02822730541229248,
                        "num_nodes_avg": 65.6,
                        "path_length_avg": 182.96020324956595,
                        "smoothness_avg": 0.05732726413788967,
                        "success_improvement": 0.0,
                        "time_improvement": -10.700544274551492,
                        "node_improvement": 83.48023167967766,
                        "length_improvement": -0.28338659103527,
                        "smoothness_improvement": 797.2961719045505,
                        "objective_score": 0.6062856225361433
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.01984243392944336,
                        "num_nodes_avg": 86.6,
                        "path_length_avg": 243.5413235727727,
                        "smoothness_avg": 0.09042567896577892,
                        "success_improvement": 0.0,
                        "time_improvement": 87.61375486797985,
                        "node_improvement": 94.18128065578178,
                        "length_improvement": 18.698896243086562,
                        "smoothness_improvement": 2226.7178507734366,
                        "objective_score": 48.63705346011307
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.01169896125793457,
                        "num_nodes_avg": 78.1,
                        "path_length_avg": 133.4682422714018,
                        "smoothness_avg": 0.1405957321950529,
                        "success_improvement": 0.0,
                        "time_improvement": 76.14970532839176,
                        "node_improvement": 90.06993006993007,
                        "length_improvement": 11.356748558062376,
                        "smoothness_improvement": 1688.3673358236224,
                        "objective_score": 38.100797412473064
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "HB-EdgeSieve BiRRT (HB-ESBiRRT): A heuristic-biased, bidirectional RRT that uses an obstacle grid with slab-based segment checks, quantized edge-collision caching, and cost-gated sparse hashing to minimize planning time while preserving robustness and path quality. It grows two trees toward each other with a single, high-yield sample per side, selects a cheap line-of-sight ancestor over a short lookback, and attempts direct bridging to the other tree. After the first solution, informed ellipse sampling narrows exploration and a cache-reusing greedy shortcutting finalizes the path.",
            "planning_mechanism": "Mechanism: Each iteration alternates trees. A guided sample (goal-biased or ellipse-informed) is steered from the nearest grid-bucket node. Before inserting, both node and edge are collision-checked. Edge checks use a memoized cache and fast slab intersections against only nearby obstacles fetched from an obstacle spatial grid. Parent compression considers a few visible ancestors to cut depth and cost. On each insertion, the planner tries a zero-step line-of-sight connect to the other tree's nearest node. A per-cell cap with cost admission curbs local redundancy. If a path appears, shortcutting reuses the same cached edge tests to converge quickly.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        goal_bias=0.35,\n        beam_width=1,\n        lookback_depth=4,\n        grid_cell_factor=1.5,\n        per_cell_cap=10,\n        min_separation_factor=0.6,\n        edge_cache_capacity=30000,\n        edge_cache_quant_factor=0.6,\n        shortcut_attempts=60,\n        no_improve_stop=10\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.beam_width = beam_width\n        self.lookback_depth = lookback_depth\n        self.grid_cell_factor = grid_cell_factor\n        self.per_cell_cap = per_cell_cap\n        self.min_separation_factor = min_separation_factor\n        self.edge_cache_capacity = edge_cache_capacity\n        self.edge_cache_quant_factor = edge_cache_quant_factor\n        self.shortcut_attempts = shortcut_attempts\n        self.no_improve_stop = no_improve_stop\n\n        # PRNG state\n        self._rnd_state = 1234567\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # Early exit if trivial\n        if self._dist(self.start, self.goal) <= 1e-9:\n            path = [self.start, self.goal]\n            return PlannerResult(True, path, [], [])\n\n        # Initialize parameters\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n\n        # Initialize PRNG with scene-dependent seed\n        self._seed_from_scene()\n\n        # Edge collision cache (LRU-ish via ticks)\n        self._tick = 0\n        self._last_prune_size = 0\n        self.ecache = {}\n        self.ecache_quant = max(0.25, self.step_size * self.edge_cache_quant_factor)\n\n        # Build obstacle spatial grid for fast queries\n        self._build_obstacle_grid()\n\n        nodes = []\n        edges = []\n\n        # Validate start/goal points\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        start_root = Node(self.start, parent=None, cost=0.0)\n        goal_root = Node(self.goal, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_path = None\n        incumbent_len = None\n\n        for _ in range(self.max_iter):\n            # Alternate growth between the two trees\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, self.goal),\n                (tree_b, grid_b, tree_a, grid_a, self.start)\n            ]:\n                progressed = False\n                for _b in range(self.beam_width):\n                    sample = self._sample(attractor, incumbent_len)\n                    if sample is None:\n                        continue\n\n                    nearest = self._nearest_in_grid(active_grid, sample)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos):\n                        continue\n                    # Node collision check\n                    if self._point_in_obstacles(new_pos):\n                        continue\n                    # Edge collision check to nearest\n                    if not self._edge_free(nearest.position, new_pos):\n                        continue\n                    # Suppress near-duplicates\n                    if self._has_nearby(active_grid, new_pos, self.min_separation):\n                        continue\n\n                    # Limited lookback LOS parent selection\n                    parent = self._best_parent_los(nearest, new_pos)\n                    new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n                    # Per-cell cap with cost admission\n                    cell_key = self._cell_of(new_pos)\n                    bucket = active_grid.get(cell_key)\n                    if bucket and len(bucket) >= self.per_cell_cap:\n                        best_bucket_cost = min(n.cost for n in bucket)\n                        if new_cost >= best_bucket_cost - 1e-9:\n                            continue\n\n                    # Insert node\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node)\n                    progressed = True\n\n                    # Try direct bridge to the other tree\n                    other_near = self._nearest_in_grid(other_grid, new_node.position)\n                    if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                        # Build raw path\n                        path_a = self._path_to_root(new_node)\n                        path_b = self._path_to_root(other_near)\n                        raw_path = path_a + path_b[::-1]\n                        # Deduplicate meeting point if coincident\n                        if len(raw_path) >= 2 and self._dist(raw_path[-1], raw_path[-2]) <= 1e-12:\n                            raw_path.pop()\n                        # Shortcut with cached collision checks\n                        final_path = self._shortcut(raw_path)\n                        best_path = final_path\n                        incumbent_len = self._path_len(final_path)\n                        return PlannerResult(True, final_path, nodes, edges)\n\n                if not progressed:\n                    continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # ---------- PRNG ----------\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 1000 + 0.5)) & 0x7fffffff\n        s ^= len(self.obstacles) * 2654435761\n        self._rnd_state = (s ^ 0xA5A5A5) & 0x7fffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 1234567\n\n    def _rand(self):\n        # LCG: x_{n+1} = (a x_n + c) mod m\n        self._rnd_state = (1103515245 * self._rnd_state + 12345) & 0x7fffffff\n        return (self._rnd_state / 2147483647.0)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return a\n        if d <= self.step_size:\n            return b\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # ---------- Sampling ----------\n    def _sample(self, attractor, incumbent_len):\n        # Guided: ellipse if incumbent known, else uniform with goal bias\n        for _ in range(20):\n            if incumbent_len is not None and self._dist(self.start, self.goal) > 1e-9:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.03)\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if p is None:\n                continue\n            if self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        # Fallback\n        return attractor if self._within_bounds(attractor) and not self._point_in_obstacles(attractor) else None\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        # Rejection sample around the segment f1-f2\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        ext = [half] * self.dims\n        for _ in range(16):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum_dist and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # ---------- Grid spatial hash for nodes ----------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_in_grid(self, grid, pos, max_ring=5):\n        cell = self._cell_of(pos)\n        best = None\n        best_d = 1e100\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if not bucket:\n                                continue\n                            for n in bucket:\n                                d = self._dist(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                                    found = True\n                if found:\n                    return best\n        else:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            d = self._dist(n.position, pos)\n                            if d < best_d:\n                                best_d = d\n                                best = n\n                                found = True\n                if found:\n                    return best\n        # Fallback: scan all\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < best_d:\n                    best_d = d\n                    best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if not bucket:\n                        continue\n                    for n in bucket:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # ---------- Obstacle spatial grid ----------\n    def _build_obstacle_grid(self):\n        # Choose obstacle cell size proportional to step for balanced performance\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}  # cell -> list of obstacle indices\n        self._obs_is_3d = self.is_3d\n        for idx, obs in enumerate(self.obstacles):\n            if self._obs_is_3d:\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            key = (cx, cy, cz)\n                            bucket = self.obs_grid.get(key)\n                            if bucket is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                bucket.append(idx)\n            else:\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        key = (cx, cy)\n                        bucket = self.obs_grid.get(key)\n                        if bucket is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self._obs_is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    # ---------- Edge checks with cache ----------\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.ecache_quant) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.ecache_quant) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        if len(self.ecache) - self._last_prune_size > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self.ecache:\n            return\n        # Drop the oldest ~40%\n        cutoff = self._tick - 2000\n        to_del = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            # Fallback: remove every 3rd entry to bound size\n            i = 0\n            for k in list(self.ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune_size = len(self.ecache)\n\n    # ---------- Segment vs obstacle (slab) accelerated by obstacle grid ----------\n    def _segment_hits_obstacle(self, a, b):\n        # Gather obstacles intersecting the bounding box of segment\n        if self._obs_is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bucket = self.obs_grid.get((cx, cy, cz))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bucket = self.obs_grid.get((cx, cy))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # ---------- Parent selection (short LOS lookback) ----------\n    def _best_parent_los(self, nearest, new_pos):\n        best = nearest\n        best_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        cur = nearest\n        depth = 0\n        while cur is not None and depth < self.lookback_depth:\n            if self._edge_free(cur.position, new_pos):\n                c = cur.cost + self._dist(cur.position, new_pos)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best = cur\n            cur = cur.parent\n            depth += 1\n        return best\n\n    # ---------- Shortcut smoothing ----------\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_improve = 0\n        i = 0\n        while attempts < self.shortcut_attempts and i < len(pts) - 2:\n            improved = False\n            j = len(pts) - 1\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    improved = True\n                    no_improve = 0\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n                no_improve += 1\n            attempts += 1\n            if no_improve >= self.no_improve_stop:\n                break\n        return pts",
            "objective": -26.29094,
            "time_improvement": 61.0,
            "length_improvement": -0.0,
            "smoothness_improvement": 1630.0,
            "node_improvement": 90.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024515295028686525,
                    "num_nodes_avg": 73.0,
                    "path_length_avg": 235.8280485058371,
                    "smoothness_avg": 0.03800756828685148,
                    "success_improvement": 0.0,
                    "time_improvement": 3.857046817335618,
                    "node_improvement": 81.6167212289096,
                    "length_improvement": -29.261090320615313,
                    "smoothness_improvement": 494.90097844477503,
                    "objective_score": -13.925035254944627
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023125672340393068,
                    "num_nodes_avg": 110.0,
                    "path_length_avg": 245.0393031205978,
                    "smoothness_avg": 0.12370286737465501,
                    "success_improvement": 0.0,
                    "time_improvement": 85.56425852446206,
                    "node_improvement": 92.6090169992609,
                    "length_improvement": 18.19882755307195,
                    "smoothness_improvement": 3082.9638771238115,
                    "objective_score": 52.003393474800845
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0030002355575561523,
                    "num_nodes_avg": 35.0,
                    "path_length_avg": 135.33178973135438,
                    "smoothness_avg": 0.1109750714335361,
                    "success_improvement": 0.0,
                    "time_improvement": 93.88351661704843,
                    "node_improvement": 95.54990464081374,
                    "length_improvement": 10.119069067755975,
                    "smoothness_improvement": 1311.5947173068773,
                    "objective_score": 40.7944700123025
                }
            ],
            "success_rate": 1.0
        },
        "objective": 32.6,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Expensive collision checking from step-by-step segment sampling and full obstacle scans, dominating runtime in cluttered maps\n   - Excessive line-of-sight ancestor lookback causing many redundant edge evaluations per insertion\n   - Broad parallel expansion (wider beam) and weaker goal guidance producing low-yield samples and wasted checks\n   - Node spatial hashing tuned too fine, leading to frequent nearest-neighbor fallback scans across many buckets\n   - Small, finely quantized edge-check cache with aggressive pruning causing low reuse and repeated computations\n   - Late rejections from strict per-cell admission filtering, incurring compute cost before discard"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Obstacle spatial grid plus slab-based segment-vs-AABB tests for both node and edge checks\n   - More permissive and larger edge-collision cache with coarser quantization and gentler pruning\n   - Shallower LOS lookback for parent selection\n   - Narrowed exploration (higher goal bias, tighter informed sampling) with reduced beam width\n   - Coarser node-grid cell size for faster nearest-neighbor queries and duplicate suppression\n   - Early scene-dependent seeding and validity checks to avoid fruitless searches\n2. Expected mechanism of impact:\n   - Cuts per-check cost by querying only nearby obstacles and using constant-time slab intersections instead of dense sampling\n   - Increases cache hit rate and lowers churn, avoiding repeated collision computations across iterations and during shortcutting\n   - Reduces the number of edge evaluations per extension, shrinking CPU time without materially harming path feasibility\n   - Focuses growth toward the attractor and along the current corridor, lowering the number of iterations and rejected samples\n   - Decreases ring expansions and global fallbacks in nearest-neighbor search, reducing lookup overhead\n   - Prevents wasted planning on invalid or trivially solvable scenes, improving average planning time"
        }
    },
    {
        "parents": [
            {
                "operator": "m2",
                "algorithm_description": "HASTE-BiRRT (Heuristically Accelerated Sparse Tree Expansion BiRRT): a bidirectional planner that couples tiny-beam, corridor/informed sampling with dual-anchored hashed nearest search, bounded per-cell growth, and a two-sided edge memo caching both blocked and free checks. It inserts single-parent nodes with multi-ancestor LOS compression to keep trees shallow, uses a short single-step greedy connect to limit overhead, and maintains an early-updating best path to focus informed sampling. A bounded shortcut with forward LOS collapse returns smooth, short paths quickly.",
                "planning_mechanism": "Alternate growth of start/goal trees. Each side samples a small beam (goal/corridor/uniform, switching to informed ellipse after a provisional path). For each sample, find a near node via grid+anchors, steer once, enforce node and edge validity (with memoized edge checks), suppress near-duplicates and throttle per-cell growth; keep the candidate that minimizes a heuristic combining distance to the opposite tree and cost-to-come. Insert the node, apply multi-ancestor LOS compression, then attempt a direct bridge or a single-step greedy connect from the opposite tree. On success, extract and bounded-shortcut the path with LOS collapse; otherwise iterate to a cap.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=10.0,\n                 collision_step=1.0,\n                 beam_k=2,\n                 goal_bias=0.15,\n                 corridor_bias=0.55,\n                 informed_bias=0.65,\n                 grid_cell=None,\n                 max_rings=3,\n                 dupe_radius_ratio=0.45,\n                 min_sep_ratio=0.30,\n                 cell_expand_limit=2,\n                 anchor_stride=20,\n                 connect_attempts=1,\n                 compress_depth=3,\n                 smoothing_iters=24,\n                 edge_cache_max=20000):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_step = collision_step\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.grid_cell = grid_cell\n        self.max_rings = max_rings\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.min_sep_ratio = min_sep_ratio\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.anchor_stride = max(1, int(anchor_stride))\n        self.connect_attempts = max(1, int(connect_attempts))\n        self.compress_depth = max(1, int(compress_depth))\n        self.smoothing_iters = smoothing_iters\n        self.edge_cache_max = max(1000, int(edge_cache_max))\n\n        # runtime\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self.edge_cache = None  # key -> 1(blocked) or 2(free)\n\n        self.start = None\n        self.goal = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # setup discretizations\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.5)))\n        self.cache_bin = max(1.0, self.edge_res)\n        self.edge_cache = {}\n\n        # validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # early straight connection\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # initialize trees and structures\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        edges = []\n        nodes = [start_root, goal_root]\n\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        anchors_a, anchors_b = [start_root], [goal_root]\n        cell_expands_a, cell_expands_b = {}, {}\n\n        best_path_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        base_corridor_w = max(self.step_size, 0.2 * d_sg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            anchors1 = anchors_a if active_start else anchors_b\n            anchors2 = anchors_b if active_start else anchors_a\n            throttles1 = cell_expands_a if active_start else cell_expands_b\n            throttles2 = cell_expands_b if active_start else cell_expands_a\n            other_root = self.goal if active_start else self.start\n\n            best_parent = None\n            best_new = None\n            best_score = float('inf')\n\n            for _ in range(self.beam_k):\n                # sampling strategy\n                r = self._rand()\n                if best_path_len < float('inf') and r < self.informed_bias:\n                    x_rand = self._sample_informed(best_path_len, obstacles, is_3d)\n                else:\n                    r2 = self._rand()\n                    if r2 < self.goal_bias:\n                        x_rand = other_root\n                    elif r2 < self.goal_bias + self.corridor_bias:\n                        width = base_corridor_w\n                        if best_path_len < float('inf'):\n                            slack = max(0.0, best_path_len - d_sg)\n                            width = max(self.step_size, 0.2 * slack + base_corridor_w)\n                        x_rand = self._sample_corridor(width, obstacles, is_3d)\n                    else:\n                        x_rand = self._sample_free(obstacles, is_3d)\n\n                near = self._nearest_hashed(grid1, tree1, anchors1, x_rand)\n                if near is None:\n                    continue\n\n                new_pos = self._steer(near.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                # Node collision check before any insertion\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n\n                # duplicate suppression and throttle\n                if self._dist(near.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid1, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                kcell = self._grid_key(new_pos)\n                if throttles1.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n\n                # Edge collision check before considering\n                if self._edge_blocked_memo(near.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Heuristic score: distance to opposite-tree nearest + mild cost term\n                other_near = self._nearest_hashed(grid2, tree2, anchors2, new_pos)\n                to_other = self._dist(new_pos, other_near.position) if other_near is not None else self._dist(new_pos, other_root)\n                cost_term = (near.cost + self._dist(near.position, new_pos)) * 0.05\n                score = to_other + cost_term\n\n                if score < best_score:\n                    best_score = score\n                    best_parent = near\n                    best_new = new_pos\n\n            if best_parent is None:\n                continue\n\n            # Final validity before insertion (both checks)\n            if self._is_in_obstacle(best_new, obstacles, is_3d):\n                continue\n            if self._edge_blocked_memo(best_parent.position, best_new, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_cost = best_parent.cost + self._dist(best_parent.position, best_new)\n            new_node = Node(best_new, best_parent, new_cost)\n            best_parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            self._grid_add(grid1, new_node)\n            kc = self._grid_key(best_new)\n            throttles1[kc] = throttles1.get(kc, 0) + 1\n            if len(tree1) % self.anchor_stride == 0:\n                anchors1.append(new_node)\n\n            # Multi-ancestor LOS compression (up to compress_depth)\n            self._compress_to_ancestors(new_node, obstacles, is_3d, edges, self.compress_depth)\n\n            # Try direct bridge\n            other_near = self._nearest_hashed(grid2, tree2, anchors2, new_node.position)\n            if other_near is not None and not self._edge_blocked_memo(new_node.position, other_near.position, obstacles, is_3d):\n                path = self._extract_path(new_node, other_near)\n                best_path_len = self._path_length(path)\n                path = self._smooth_path(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Short greedy connect from the other side (single-step attempts)\n            p = other_near\n            attempts = 0\n            while p is not None and attempts < self.connect_attempts:\n                step_pos = self._steer(p.position, new_node.position, self.step_size)\n                if not self._in_bounds(step_pos):\n                    break\n                if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(grid2, step_pos, self.step_size * self.dupe_radius_ratio):\n                    break\n                if self._edge_blocked_memo(p.position, step_pos, obstacles, is_3d):\n                    break\n\n                # Insert micro-step node (both checks passed)\n                q = Node(step_pos, p, p.cost + self._dist(p.position, step_pos))\n                p.add_child(q)\n                tree2.append(q)\n                nodes.append(q)\n                edges.append((p, q))\n                self._grid_add(grid2, q)\n                if len(tree2) % self.anchor_stride == 0:\n                    anchors2.append(q)\n                throttles2[self._grid_key(step_pos)] = throttles2.get(self._grid_key(step_pos), 0) + 1\n\n                # optional small compression on the micro-step\n                self._compress_to_ancestors(q, obstacles, is_3d, edges, 2)\n\n                # Check bridge to new_node\n                if not self._edge_blocked_memo(new_node.position, q.position, obstacles, is_3d):\n                    path = self._extract_path(new_node, q)\n                    best_path_len = self._path_length(path)\n                    path = self._smooth_path(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, nodes, edges)\n\n                p = q\n                attempts += 1\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp_tuple(to_pos)\n        if d <= 1e-12:\n            return self._clamp_tuple(from_pos)\n        r = step / d\n        return self._clamp_tuple(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Edge memo (blocked and free)\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        state = self.edge_cache.get(key)\n        if state is not None:\n            return state == 1\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d)\n        self.edge_cache[key] = 1 if blocked else 2\n        # bounded cache pruning to limit rechecks without frequent full clears\n        if len(self.edge_cache) > self.edge_cache_max:\n            self._prune_edge_cache()\n        return blocked\n\n    def _prune_edge_cache(self):\n        # remove roughly half of items deterministically\n        to_remove = []\n        count = 0\n        for k in self.edge_cache:\n            if (count % 2) == 0:\n                to_remove.append(k)\n            count += 1\n            if len(to_remove) >= self.edge_cache_max // 2:\n                break\n        for k in to_remove:\n            try:\n                del self.edge_cache[k]\n            except:\n                pass\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            # rejection within sphere\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        else:\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        # prolate ellipse: sum of distances to foci <= best_len\n        for _ in range(48):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= best_len and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # fallback\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)\n\n    # Grid hashing\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, tree, anchors, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # anchor fallback\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # rare: full scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(max(1, radius / self.grid_cell)) + 1\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Compression\n    def _compress_to_ancestors(self, node, obstacles, is_3d, edges, depth_limit):\n        cur_parent = node.parent\n        depth = 0\n        while cur_parent is not None and depth < depth_limit:\n            gp = cur_parent.parent\n            if gp is None:\n                break\n            if not self._edge_blocked_memo(gp.position, node.position, obstacles, is_3d):\n                # update parent-child relations\n                cur_parent.remove_child(node)\n                self._edges_remove(edges, cur_parent, node)\n                gp.add_child(node)\n                edges.append((gp, node))\n                node.cost = gp.cost + self._dist(gp.position, node.position)\n                cur_parent = gp\n                depth += 1\n            else:\n                break\n\n    # Edges helpers\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node):\n        path_a = self._path_to_root(a_node)\n        path_b = []\n        cur = b_node\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _smooth_path(self, path, obstacles, is_3d, iters):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        no_improve = 0\n        last_len = self._path_length(pts)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d):\n                new_pts = pts[:i + 1] + pts[j:]\n                new_len = self._path_length(new_pts)\n                if new_len <= last_len:\n                    pts = new_pts\n                    last_len = new_len\n                    no_improve = 0\n                else:\n                    no_improve += 1\n            else:\n                no_improve += 1\n            if no_improve >= 8:\n                break\n        # Forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            k = 1\n            while k < len(pts) - 1:\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n                k += 1\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
                "objective": -26.1688,
                "time_improvement": 35.0,
                "length_improvement": 11.0,
                "smoothness_improvement": 1792.0,
                "node_improvement": 88.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.027369928359985352,
                        "num_nodes_avg": 65.0,
                        "path_length_avg": 171.28307479198807,
                        "smoothness_avg": 0.05148806664012615,
                        "success_improvement": 0.0,
                        "time_improvement": -7.338122500577379,
                        "node_improvement": 83.63132712163183,
                        "length_improvement": 6.11703255250457,
                        "smoothness_improvement": 705.9000510442344,
                        "objective_score": 4.9982830365507
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.04116971492767334,
                        "num_nodes_avg": 116.3,
                        "path_length_avg": 248.99030586642007,
                        "smoothness_avg": 0.12529040112374196,
                        "success_improvement": 0.0,
                        "time_improvement": 74.30062345562982,
                        "node_improvement": 92.18571524558222,
                        "length_improvement": 16.879869113207995,
                        "smoothness_improvement": 3123.8122639421595,
                        "objective_score": 48.037169824324536
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.030934453010559082,
                        "num_nodes_avg": 94.2,
                        "path_length_avg": 133.85366176833466,
                        "smoothness_avg": 0.12940331913875977,
                        "success_improvement": 0.0,
                        "time_improvement": 36.934929218056986,
                        "node_improvement": 88.02288620470438,
                        "length_improvement": 11.10077127990379,
                        "smoothness_improvement": 1546.0006678855698,
                        "objective_score": 25.470944872787218
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "time_expert",
                "algorithm_description": "HB-EdgeSieve BiRRT (HB-ESBiRRT): A heuristic-biased, bidirectional RRT that uses an obstacle grid with slab-based segment checks, quantized edge-collision caching, and cost-gated sparse hashing to minimize planning time while preserving robustness and path quality. It grows two trees toward each other with a single, high-yield sample per side, selects a cheap line-of-sight ancestor over a short lookback, and attempts direct bridging to the other tree. After the first solution, informed ellipse sampling narrows exploration and a cache-reusing greedy shortcutting finalizes the path.",
                "planning_mechanism": "Mechanism: Each iteration alternates trees. A guided sample (goal-biased or ellipse-informed) is steered from the nearest grid-bucket node. Before inserting, both node and edge are collision-checked. Edge checks use a memoized cache and fast slab intersections against only nearby obstacles fetched from an obstacle spatial grid. Parent compression considers a few visible ancestors to cut depth and cost. On each insertion, the planner tries a zero-step line-of-sight connect to the other tree's nearest node. A per-cell cap with cost admission curbs local redundancy. If a path appears, shortcutting reuses the same cached edge tests to converge quickly.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        goal_bias=0.35,\n        beam_width=1,\n        lookback_depth=4,\n        grid_cell_factor=1.5,\n        per_cell_cap=10,\n        min_separation_factor=0.6,\n        edge_cache_capacity=30000,\n        edge_cache_quant_factor=0.6,\n        shortcut_attempts=60,\n        no_improve_stop=10\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.beam_width = beam_width\n        self.lookback_depth = lookback_depth\n        self.grid_cell_factor = grid_cell_factor\n        self.per_cell_cap = per_cell_cap\n        self.min_separation_factor = min_separation_factor\n        self.edge_cache_capacity = edge_cache_capacity\n        self.edge_cache_quant_factor = edge_cache_quant_factor\n        self.shortcut_attempts = shortcut_attempts\n        self.no_improve_stop = no_improve_stop\n\n        # PRNG state\n        self._rnd_state = 1234567\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # Early exit if trivial\n        if self._dist(self.start, self.goal) <= 1e-9:\n            path = [self.start, self.goal]\n            return PlannerResult(True, path, [], [])\n\n        # Initialize parameters\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n\n        # Initialize PRNG with scene-dependent seed\n        self._seed_from_scene()\n\n        # Edge collision cache (LRU-ish via ticks)\n        self._tick = 0\n        self._last_prune_size = 0\n        self.ecache = {}\n        self.ecache_quant = max(0.25, self.step_size * self.edge_cache_quant_factor)\n\n        # Build obstacle spatial grid for fast queries\n        self._build_obstacle_grid()\n\n        nodes = []\n        edges = []\n\n        # Validate start/goal points\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        start_root = Node(self.start, parent=None, cost=0.0)\n        goal_root = Node(self.goal, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_path = None\n        incumbent_len = None\n\n        for _ in range(self.max_iter):\n            # Alternate growth between the two trees\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, self.goal),\n                (tree_b, grid_b, tree_a, grid_a, self.start)\n            ]:\n                progressed = False\n                for _b in range(self.beam_width):\n                    sample = self._sample(attractor, incumbent_len)\n                    if sample is None:\n                        continue\n\n                    nearest = self._nearest_in_grid(active_grid, sample)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos):\n                        continue\n                    # Node collision check\n                    if self._point_in_obstacles(new_pos):\n                        continue\n                    # Edge collision check to nearest\n                    if not self._edge_free(nearest.position, new_pos):\n                        continue\n                    # Suppress near-duplicates\n                    if self._has_nearby(active_grid, new_pos, self.min_separation):\n                        continue\n\n                    # Limited lookback LOS parent selection\n                    parent = self._best_parent_los(nearest, new_pos)\n                    new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n                    # Per-cell cap with cost admission\n                    cell_key = self._cell_of(new_pos)\n                    bucket = active_grid.get(cell_key)\n                    if bucket and len(bucket) >= self.per_cell_cap:\n                        best_bucket_cost = min(n.cost for n in bucket)\n                        if new_cost >= best_bucket_cost - 1e-9:\n                            continue\n\n                    # Insert node\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node)\n                    progressed = True\n\n                    # Try direct bridge to the other tree\n                    other_near = self._nearest_in_grid(other_grid, new_node.position)\n                    if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                        # Build raw path\n                        path_a = self._path_to_root(new_node)\n                        path_b = self._path_to_root(other_near)\n                        raw_path = path_a + path_b[::-1]\n                        # Deduplicate meeting point if coincident\n                        if len(raw_path) >= 2 and self._dist(raw_path[-1], raw_path[-2]) <= 1e-12:\n                            raw_path.pop()\n                        # Shortcut with cached collision checks\n                        final_path = self._shortcut(raw_path)\n                        best_path = final_path\n                        incumbent_len = self._path_len(final_path)\n                        return PlannerResult(True, final_path, nodes, edges)\n\n                if not progressed:\n                    continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # ---------- PRNG ----------\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 1000 + 0.5)) & 0x7fffffff\n        s ^= len(self.obstacles) * 2654435761\n        self._rnd_state = (s ^ 0xA5A5A5) & 0x7fffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 1234567\n\n    def _rand(self):\n        # LCG: x_{n+1} = (a x_n + c) mod m\n        self._rnd_state = (1103515245 * self._rnd_state + 12345) & 0x7fffffff\n        return (self._rnd_state / 2147483647.0)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return a\n        if d <= self.step_size:\n            return b\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # ---------- Sampling ----------\n    def _sample(self, attractor, incumbent_len):\n        # Guided: ellipse if incumbent known, else uniform with goal bias\n        for _ in range(20):\n            if incumbent_len is not None and self._dist(self.start, self.goal) > 1e-9:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.03)\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if p is None:\n                continue\n            if self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        # Fallback\n        return attractor if self._within_bounds(attractor) and not self._point_in_obstacles(attractor) else None\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        # Rejection sample around the segment f1-f2\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        ext = [half] * self.dims\n        for _ in range(16):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum_dist and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # ---------- Grid spatial hash for nodes ----------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_in_grid(self, grid, pos, max_ring=5):\n        cell = self._cell_of(pos)\n        best = None\n        best_d = 1e100\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if not bucket:\n                                continue\n                            for n in bucket:\n                                d = self._dist(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                                    found = True\n                if found:\n                    return best\n        else:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            d = self._dist(n.position, pos)\n                            if d < best_d:\n                                best_d = d\n                                best = n\n                                found = True\n                if found:\n                    return best\n        # Fallback: scan all\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < best_d:\n                    best_d = d\n                    best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if not bucket:\n                        continue\n                    for n in bucket:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # ---------- Obstacle spatial grid ----------\n    def _build_obstacle_grid(self):\n        # Choose obstacle cell size proportional to step for balanced performance\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}  # cell -> list of obstacle indices\n        self._obs_is_3d = self.is_3d\n        for idx, obs in enumerate(self.obstacles):\n            if self._obs_is_3d:\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            key = (cx, cy, cz)\n                            bucket = self.obs_grid.get(key)\n                            if bucket is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                bucket.append(idx)\n            else:\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        key = (cx, cy)\n                        bucket = self.obs_grid.get(key)\n                        if bucket is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self._obs_is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    # ---------- Edge checks with cache ----------\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.ecache_quant) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.ecache_quant) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        if len(self.ecache) - self._last_prune_size > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self.ecache:\n            return\n        # Drop the oldest ~40%\n        cutoff = self._tick - 2000\n        to_del = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            # Fallback: remove every 3rd entry to bound size\n            i = 0\n            for k in list(self.ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune_size = len(self.ecache)\n\n    # ---------- Segment vs obstacle (slab) accelerated by obstacle grid ----------\n    def _segment_hits_obstacle(self, a, b):\n        # Gather obstacles intersecting the bounding box of segment\n        if self._obs_is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bucket = self.obs_grid.get((cx, cy, cz))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bucket = self.obs_grid.get((cx, cy))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # ---------- Parent selection (short LOS lookback) ----------\n    def _best_parent_los(self, nearest, new_pos):\n        best = nearest\n        best_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        cur = nearest\n        depth = 0\n        while cur is not None and depth < self.lookback_depth:\n            if self._edge_free(cur.position, new_pos):\n                c = cur.cost + self._dist(cur.position, new_pos)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best = cur\n            cur = cur.parent\n            depth += 1\n        return best\n\n    # ---------- Shortcut smoothing ----------\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_improve = 0\n        i = 0\n        while attempts < self.shortcut_attempts and i < len(pts) - 2:\n            improved = False\n            j = len(pts) - 1\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    improved = True\n                    no_improve = 0\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n                no_improve += 1\n            attempts += 1\n            if no_improve >= self.no_improve_stop:\n                break\n        return pts",
                "objective": -26.29094,
                "time_improvement": 61.0,
                "length_improvement": -0.0,
                "smoothness_improvement": 1630.0,
                "node_improvement": 90.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.024515295028686525,
                        "num_nodes_avg": 73.0,
                        "path_length_avg": 235.8280485058371,
                        "smoothness_avg": 0.03800756828685148,
                        "success_improvement": 0.0,
                        "time_improvement": 3.857046817335618,
                        "node_improvement": 81.6167212289096,
                        "length_improvement": -29.261090320615313,
                        "smoothness_improvement": 494.90097844477503,
                        "objective_score": -13.925035254944627
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.023125672340393068,
                        "num_nodes_avg": 110.0,
                        "path_length_avg": 245.0393031205978,
                        "smoothness_avg": 0.12370286737465501,
                        "success_improvement": 0.0,
                        "time_improvement": 85.56425852446206,
                        "node_improvement": 92.6090169992609,
                        "length_improvement": 18.19882755307195,
                        "smoothness_improvement": 3082.9638771238115,
                        "objective_score": 52.003393474800845
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.0030002355575561523,
                        "num_nodes_avg": 35.0,
                        "path_length_avg": 135.33178973135438,
                        "smoothness_avg": 0.1109750714335361,
                        "success_improvement": 0.0,
                        "time_improvement": 93.88351661704843,
                        "node_improvement": 95.54990464081374,
                        "length_improvement": 10.119069067755975,
                        "smoothness_improvement": 1311.5947173068773,
                        "objective_score": 40.7944700123025
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "AURORA-BiRRT*: A*-guided, Unrolled-Rewire, Obstacle-Grid accelerated BiRRT with memoized edges and cell-pair sieve. It couples hashed nearest search, per-cell throttling, duplicate suppression, heuristic parent selection (g+h), bounded rewiring with full cost propagation, multi-step Connect, and quantized edge-collision caching; online LOS compression and cache-aware shortcutting yield smooth, short paths quickly.",
            "planning_mechanism": "Alternate tree growth with k-beam samples. Each beam selects a parent among local candidates minimizing g(parent)+d(parent,qn)+\u03bb\u00b7h(qn,other-tree), enforcing both node and edge validity before insertion. After insertion, LOS-compress to an ancestor, rewire neighbors if cheaper and propagate costs. A limited Connect grows the opposite tree unless a cached blocked cell-pair forbids it; direct edges terminate early. Once an incumbent exists, informed ellipse sampling narrows exploration; final shortcutting and LOS collapse return a concise path.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=9.0,\n        collision_res=1.0,\n        beam_k=2,\n        goal_bias=0.2,\n        informed_bias=0.6,\n        grid_cell_factor=1.2,\n        per_cell_cap=6,\n        dupe_radius_ratio=0.45,\n        rewire_radius_factor=2.5,\n        neighbor_cap=24,\n        compress_depth=2,\n        connect_steps=3,\n        edge_cache_capacity=40000,\n        edge_cache_quant=0.8,\n        smoothing_iters=50,\n        no_improve_stop=12\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_res = collision_res\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.per_cell_cap = per_cell_cap\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.rewire_radius_factor = rewire_radius_factor\n        self.neighbor_cap = neighbor_cap\n        self.compress_depth = compress_depth\n        self.connect_steps = connect_steps\n        self.edge_cache_capacity = edge_cache_capacity\n        self.edge_cache_quant = edge_cache_quant\n        self.smoothing_iters = smoothing_iters\n        self.no_improve_stop = no_improve_stop\n\n        self._rnd_state = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n\n        # Edge cache\n        self._tick = 0\n        self.ecache = {}\n        self._last_prune_size = 0\n        self.eq = max(0.25, self.edge_cache_quant)\n        # Collision stepping resolution for fallback sampling checks\n        self.edge_res = max(0.5, self.collision_res)\n\n        # Build obstacle grid\n        self._build_obstacle_grid()\n\n        # Validate endpoints\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        nodes = []\n        edges = []\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        throttles_a, throttles_b = {}, {}\n        anchors_a, anchors_b = [start_root], [goal_root]\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_path = None\n        best_len = float('inf')\n        sg = self._dist(self.start, self.goal)\n\n        blocked_pairs = set()\n        anchor_stride = 20\n        max_rings = 4\n\n        for it in range(self.max_iter):\n            side_start = (it % 2 == 0)\n            tree1 = tree_a if side_start else tree_b\n            grid1 = grid_a if side_start else grid_b\n            throttles1 = throttles_a if side_start else throttles_b\n            anchors1 = anchors_a if side_start else anchors_b\n\n            tree2 = tree_b if side_start else tree_a\n            grid2 = grid_b if side_start else grid_a\n            throttles2 = throttles_b if side_start else throttles_a\n            anchors2 = anchors_b if side_start else anchors_a\n\n            attractor = self.goal if side_start else self.start\n\n            progressed = False\n            for _ in range(self.beam_k):\n                sample = self._sample(attractor, best_len, sg)\n                if sample is None:\n                    continue\n                near = self._nearest_hashed(grid1, anchors1, sample, max_rings)\n                if near is None:\n                    continue\n                new_pos = self._steer(near.position, sample)\n                if not self._within_bounds(new_pos):\n                    continue\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if self._has_nearby(grid1, new_pos, self.dupe_radius):\n                    continue\n\n                # Parent selection (A*-guided among local candidates)\n                rewire_r = self._rewire_radius(len(nodes))\n                parents = self._candidate_parents(grid1, anchors1, tree1, new_pos, rewire_r, self.neighbor_cap)\n                best_parent, best_new_cost = None, float('inf')\n                best_score = float('inf')\n                other_near = self._nearest_hashed(grid2, anchors2, new_pos, max_rings)\n                h_term = self._dist(new_pos, other_near.position if other_near else attractor)\n                lam = 0.1\n                for p in parents:\n                    if not self._edge_free(p.position, new_pos):\n                        continue\n                    gc = p.cost + self._dist(p.position, new_pos)\n                    f = gc + lam * h_term\n                    if f + 1e-9 < best_score:\n                        best_score = f\n                        best_parent = p\n                        best_new_cost = gc\n                if best_parent is None:\n                    continue\n\n                # Per-cell cap with cost admission\n                ckey = self._cell_of(new_pos)\n                bucket = grid1.get(ckey)\n                if bucket and len(bucket) >= self.per_cell_cap:\n                    best_bucket_cost = min(n.cost for n in bucket)\n                    if best_new_cost >= best_bucket_cost - 1e-9:\n                        continue\n\n                # Final validity before insertion\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if not self._edge_free(best_parent.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos, best_parent, best_new_cost)\n                best_parent.add_child(new_node)\n                tree1.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                self._grid_insert(grid1, new_node)\n                throttles1[ckey] = throttles1.get(ckey, 0) + 1\n                if (len(tree1) % anchor_stride) == 0:\n                    anchors1.append(new_node)\n                progressed = True\n\n                # LOS compression to ancestors\n                self._compress_to_ancestors(new_node, edges, self.compress_depth)\n\n                # Rewiring around new_node\n                self._rewire_neighbors(grid1, new_node, rewire_r, edges)\n\n                # Try connect to the other tree\n                pair_key = self._pair_key(self._cell_of(new_node.position),\n                                          self._cell_of((other_near.position if other_near else attractor)))\n                if pair_key not in blocked_pairs:\n                    connected, path = self._attempt_connect(new_node, tree2, grid2, throttles2, anchors2, nodes, edges)\n                    if connected:\n                        path = self._shortcut(path)\n                        path = self._los_collapse(path)\n                        best_path = path\n                        best_len = self._path_len(path)\n                        return PlannerResult(True, path, nodes, edges)\n                    else:\n                        blocked_pairs.add(pair_key)\n\n            if not progressed:\n                continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= len(self.obstacles) * 2654435761\n        self._rnd_state = (s ^ 0xA5A5A5) & 0xffffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 2463534242\n\n    def _rand(self):\n        self._rnd_state = (1664525 * self._rnd_state + 1013904223) & 0xffffffff\n        return self._rnd_state / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Sampling\n    def _sample(self, attractor, best_len, sg):\n        for _ in range(24):\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p and self._within_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._within_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Node grid (for NN, dupes, neighbors)\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, anchors, pos, max_rings=4):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # fallback scan\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((key[0] + dx, key[1] + dy))\n                    if not bucket:\n                        continue\n                    for n in bucket:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    def _candidate_parents(self, grid, anchors, tree, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        if not cand:\n            cand = anchors[:]\n        if len(cand) > cap:\n            # Reservoir-like random subset\n            out = []\n            take = 0\n            for n in cand:\n                take += 1\n                if len(out) < cap:\n                    out.append(n)\n                else:\n                    j = int(self._rand_range(0, take))\n                    if j < len(out):\n                        out[j] = n\n            cand = out\n        return cand\n\n    # Obstacle spatial grid\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    # Edge checks with cache\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.eq) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.eq) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        if len(self.ecache) - self._last_prune_size > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self.ecache:\n            return\n        cutoff = self._tick - 3000\n        to_del = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            i = 0\n            for k in list(self.ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune_size = len(self.ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Compression and rewiring\n    def _compress_to_ancestors(self, node, edges, depth_limit):\n        depth = 0\n        curp = node.parent\n        while curp is not None and curp.parent is not None and depth < depth_limit:\n            gp = curp.parent\n            if self._edge_free(gp.position, node.position):\n                self._reparent(node, gp, edges)\n                curp = node.parent\n                depth += 1\n            else:\n                break\n\n    def _rewire_radius(self, n_nodes):\n        # simple schedule\n        return max(self.step_size * 1.5, self.rewire_radius_factor * self.step_size)\n\n    def _rewire_neighbors(self, grid, node, radius, edges):\n        key = self._cell_of(node.position)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        neigh = self._grid_ring_nodes(grid, key, r_cells)\n        count = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if d > radius:\n                continue\n            new_cost = node.cost + d\n            if new_cost + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n                count += 1\n                if count >= self.neighbor_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        old_parent = child.parent\n        if old_parent is new_parent:\n            return\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    stack.append(ch)\n\n    # Connect attempt\n    def _attempt_connect(self, new_node, other_tree, other_grid, throttles, anchors, nodes, edges):\n        other_near = self._nearest_hashed(other_grid, anchors, new_node.position, 4)\n        if other_near is None:\n            return False, []\n        # Try direct bridge first\n        if self._edge_free(new_node.position, other_near.position):\n            path = self._extract_path(new_node, other_near)\n            return True, self._ensure_bounds_and_valid(path)\n\n        p = other_near\n        steps = 0\n        last_q = None\n        while steps < self.connect_steps:\n            step_pos = self._steer(p.position, new_node.position)\n            if not self._within_bounds(step_pos):\n                break\n            if self._point_in_obstacles(step_pos):\n                break\n            if self._has_nearby(other_grid, step_pos, self.dupe_radius):\n                break\n            if not self._edge_free(p.position, step_pos):\n                break\n            cell = self._cell_of(step_pos)\n            bucket = other_grid.get(cell)\n            if bucket and len(bucket) >= self.per_cell_cap:\n                best_bucket_cost = min(n.cost for n in bucket)\n                new_c = p.cost + self._dist(p.position, step_pos)\n                if new_c >= best_bucket_cost - 1e-9:\n                    break\n\n            q = Node(step_pos, p, p.cost + self._dist(p.position, step_pos))\n            p.add_child(q)\n            other_tree.append(q)\n            nodes.append(q)\n            edges.append((p, q))\n            self._grid_insert(other_grid, q)\n            throttles[cell] = throttles.get(cell, 0) + 1\n            if (len(other_tree) % 20) == 0:\n                anchors.append(q)\n\n            self._compress_to_ancestors(q, edges, 1)\n            # local light rewiring\n            self._rewire_neighbors(other_grid, q, self._rewire_radius(len(nodes)), edges)\n\n            if self._edge_free(new_node.position, q.position):\n                path = self._extract_path(new_node, q)\n                return True, self._ensure_bounds_and_valid(path)\n\n            p = q\n            last_q = q\n            steps += 1\n        return False, []\n\n    def _pair_key(self, c1, c2):\n        return (c1, c2) if c1 <= c2 else (c2, c1)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return pa + pb[::-1]\n\n    def _ensure_bounds_and_valid(self, path):\n        return [self._clamp(p) for p in path]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # Post smoothing\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_improve = 0\n        best_len = self._path_len(pts)\n        while attempts < self.smoothing_iters:\n            i = int(self._rand_range(0, max(1, len(pts) - 2)))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                attempts += 1\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best_len + 1e-12:\n                    pts = new_pts\n                    best_len = L\n                    no_improve = 0\n                else:\n                    no_improve += 1\n            else:\n                no_improve += 1\n            attempts += 1\n            if no_improve >= self.no_improve_stop:\n                break\n        return pts\n\n    def _los_collapse(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = [path[0]]\n        last = path[0]\n        k = 1\n        while k < len(path) - 1:\n            nxt = path[k + 1]\n            if self._edge_free(last, nxt):\n                k += 1\n                continue\n            pts.append(path[k])\n            last = path[k]\n            k += 1\n        pts.append(path[-1])\n        return pts",
            "objective": -29.84258,
            "time_improvement": 46.0,
            "length_improvement": 12.0,
            "smoothness_improvement": 1759.0,
            "node_improvement": 89.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013257336616516114,
                    "num_nodes_avg": 49.0,
                    "path_length_avg": 163.59788282479164,
                    "smoothness_avg": 0.10284552152668414,
                    "success_improvement": 0.0,
                    "time_improvement": 48.00798880221262,
                    "node_improvement": 87.6605389070763,
                    "length_improvement": 10.329408049384693,
                    "smoothness_improvement": 1509.7557445171647,
                    "objective_score": 28.148820192880425
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01610586643218994,
                    "num_nodes_avg": 62.0,
                    "path_length_avg": 241.62656852319907,
                    "smoothness_avg": 0.0921645090196098,
                    "success_improvement": 0.0,
                    "time_improvement": 89.9462328864473,
                    "node_improvement": 95.83417321776524,
                    "length_improvement": 19.338096591802515,
                    "smoothness_improvement": 2271.4592004871693,
                    "objective_score": 49.944023823451545
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.048529839515686034,
                    "num_nodes_avg": 126.0,
                    "path_length_avg": 141.44566627862946,
                    "smoothness_avg": 0.12548275222835503,
                    "success_improvement": 0.0,
                    "time_improvement": 1.0637827328513305,
                    "node_improvement": 83.97965670692943,
                    "length_improvement": 6.058523376571766,
                    "smoothness_improvement": 1496.1313461713685,
                    "objective_score": 11.4349055766553
                }
            ],
            "success_rate": 1.0
        },
        "objective": 33.599999999999994,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient connection strategy with single-shot bridges and short, greedy steps, leading to low connection rates and extra iterations\n   - Suboptimal parent selection restricted to nearest or shallow lookback without robust heuristic guidance, inflating cost-to-come and wandering\n   - Missing or limited rewiring and lack of descendant cost propagation after reparenting, leaving trees cost-stale and biasing future growth\n   - High collision-check overhead due to weak memoization and repeated testing of similar segments; no memory of consistently blocked region pairs\n   - Approximate nearest search that frequently falls back to broad scans; aggressive duplicate/per-cell caps causing many rejections and retries\n   - Early acceptance of first path with limited anytime improvement and modest smoothing, keeping the informed region wide for longer"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Heuristic-guided parent selection over local candidates (g+h) within a neighborhood radius\n   - Local rewiring with full downstream cost propagation to maintain consistent, low-cost trees\n   - Multi-step bidirectional connect with light rewiring and blocked-pair sieving to avoid repeated futile bridges\n   - Quantized, pruned edge-collision cache combined with an obstacle spatial grid\n   - Online line-of-sight compression plus cost-aware per-cell admission to curb node proliferation\n   - Informed sampling that activates early once an incumbent path is found, paired with modest beam exploration\n2. Expected mechanism of impact:\n   - Faster convergence to an incumbent path tightens the informed sampling region, reducing exploration volume and iterations\n   - Better parent choices and rewiring lower g-costs, decreasing future steering distances and failure rates\n   - Higher connection success per attempt cuts oscillations between trees and shortens search time\n   - Collision checking becomes cheaper through reuse and spatial culling, shrinking per-iteration cost\n   - Fewer redundant/near-duplicate nodes reduce nearest-neighbor queries and edge checks, accelerating the loop\n   - Smoother intermediate paths stabilize guidance, further focusing sampling and trimming planning time"
        }
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "HASTE-BiRRT: Hashed, Anytime, Saturation\u2011Throttled, Efficient BiRRT-Connect. It accelerates bidirectional RRT with cached collision tests, hashed nearest search with leader fallbacks, per-cell growth throttling, and duplicate-suppressed commit-only connections. A light visibility prune plus brief shortcutting refines the path while keeping postprocessing costs low.",
                "planning_mechanism": "Alternate expanding start/goal trees with goal-biased sampling; find nearest via grid rings, else leader-guided buckets; steer one step and validate with cached edge checks; suppress inserts in saturated/duplicate cells; attempt a single, commit-only direct bridge to the opposite tree, skipping known-blocked cell pairs; upon success, extract start-to-goal path, visibility-prune, then run a few shortcuts; terminate on success or iteration cap.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=7.0,\n                 goal_bias=0.25,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=40,\n                 max_per_cell=6,\n                 search_r_max=2,\n                 leader_stride=25):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.max_per_cell = max_per_cell\n        self.search_r_max = search_r_max\n        self.leader_stride = leader_stride\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # Caches\n        self._edge_blocked_cache = set()   # quantized blocked segments (safe to reuse only for blocked)\n        self._edge_exact_cache = {}        # exact endpoint pairs -> bool\n        self._connect_blocked_cells = set()  # (cellA, cellB) pairs known to fail direct connect\n\n    # ------------- Public API -------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Parameters derived\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.5)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Reset caches\n        self._edge_blocked_cache = set()\n        self._edge_exact_cache = {}\n        self._connect_blocked_cells = set()\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Grids and counts\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        self._grid_add(grid_start, counts_start, start_root)\n        self._grid_add(grid_goal, counts_goal, goal_root)\n\n        # Leaders\n        leaders_start = [start_root]\n        leaders_goal = [goal_root]\n        inserted_since_leader_start = 0\n        inserted_since_leader_goal = 0\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            grid_a = grid_start if active_start else grid_goal\n            counts_a = counts_start if active_start else counts_goal\n            leaders_a = leaders_start if active_start else leaders_goal\n\n            tree_b = goal_tree if active_start else start_tree\n            grid_b = grid_goal if active_start else grid_start\n            counts_b = counts_goal if active_start else counts_start\n            leaders_b = leaders_goal if active_start else leaders_start\n\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest lookup\n            nearest = self._nearest_hashed(grid_a, leaders_a, tree_a, x_rand)\n            if nearest is None:\n                continue\n\n            # Steer\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Per-cell throttling and duplicate suppression\n            key_new = self._grid_key(new_pos)\n            if self._cell_count(counts_a, key_new) >= self.max_per_cell:\n                continue\n            if self._near_duplicate(grid_a, new_pos, dup_radius=0.7 * self.step_size):\n                continue\n\n            # Insert node and edge\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, counts_a, new_node)\n\n            # Leader sampling\n            if active_start:\n                inserted_since_leader_start += 1\n                if inserted_since_leader_start >= self.leader_stride:\n                    leaders_start.append(new_node)\n                    inserted_since_leader_start = 0\n            else:\n                inserted_since_leader_goal += 1\n                if inserted_since_leader_goal >= self.leader_stride:\n                    leaders_goal.append(new_node)\n                    inserted_since_leader_goal = 0\n\n            # Try commit-only direct connection to the other tree (with cell-pair de-dup)\n            other_near = self._nearest_hashed(grid_b, leaders_b, tree_b, new_node.position)\n            if other_near is not None:\n                pair_key = (self._grid_key(new_node.position), self._grid_key(other_near.position))\n                if pair_key not in self._connect_blocked_cells:\n                    if not self._edge_blocked(new_node.position, other_near.position, obstacles, is_3d):\n                        path = self._extract_path(new_node, other_near, a_is_start_tree=active_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n                    else:\n                        # cache blocked cell pair to avoid repeating futile checks\n                        self._connect_blocked_cells.add(pair_key)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ------------- Random -------------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry -------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ------------- Collision & caches -------------\n    def _quant(self, p, q=1.5):\n        # Quantize for blocked-segment cache; coarse to avoid false frees; safe for blocked reuse only\n        if self.dim == 3:\n            return (int(p[0] // q), int(p[1] // q), int(p[2] // q))\n        else:\n            return (int(p[0] // q), int(p[1] // q))\n\n    def _seg_key_exact(self, a, b):\n        # Canonicalize order for undirected segment\n        if a <= b:\n            return (a, b)\n        else:\n            return (b, a)\n\n    def _seg_key_quant_blocked(self, a, b):\n        qa = self._quant(a)\n        qb = self._quant(b)\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        # Exact cache check\n        k_exact = self._seg_key_exact(a, b)\n        cached = self._edge_exact_cache.get(k_exact)\n        if cached is not None:\n            return cached\n        # Blocked quantized cache\n        kq = self._seg_key_quant_blocked(a, b)\n        if kq in self._edge_blocked_cache:\n            self._edge_exact_cache[k_exact] = True\n            return True\n        # Compute\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n        # Update caches\n        self._edge_exact_cache[k_exact] = blocked\n        if blocked:\n            self._edge_blocked_cache.add(kq)\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ------------- Sampling -------------\n    def _sample_free(self, obstacles, is_3d):\n        # Rejection sampling within bounds until a free point is found\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ------------- Grid / NN -------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n\n    def _cell_count(self, counts, key):\n        return counts.get(key, 0)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, leaders, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Local rings\n        for r in range(0, self.search_r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Leader fallback\n        if leaders:\n            lead_best = None\n            lead_bestd = float('inf')\n            for n in leaders:\n                d = self._dist(n.position, pos)\n                if d < lead_bestd:\n                    lead_bestd = d\n                    lead_best = n\n            if lead_best is not None:\n                # Search around leader cell for neighbors\n                lk = self._grid_key(lead_best.position)\n                for r in range(0, min(2, self.search_r_max) + 1):\n                    cand = self._grid_ring_collect(grid, lk, r)\n                    for n in cand:\n                        d = self._dist(n.position, pos)\n                        if d < bestd:\n                            bestd = d\n                            best = n\n                if best is not None:\n                    return best\n        # Sparse random subset fallback (avoid full scan)\n        if tree:\n            trials = min(64, len(tree))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            if best is not None:\n                return best\n        return None\n\n    def _near_duplicate(self, grid, pos, dup_radius):\n        key = self._grid_key(pos)\n        r = 1\n        cand = self._grid_ring_collect(grid, key, r)\n        rr = dup_radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # ------------- Path -------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            # start-tree path to meet, then meet->goal via reversed goal-tree path\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
                "objective": -35.78786,
                "time_improvement": 66.0,
                "length_improvement": 12.0,
                "smoothness_improvement": 1772.0,
                "node_improvement": 88.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.016536712646484375,
                        "num_nodes_avg": 67.3,
                        "path_length_avg": 176.25078259592178,
                        "smoothness_avg": 0.05067539409595988,
                        "success_improvement": 0.0,
                        "time_improvement": 35.1470831615236,
                        "node_improvement": 83.05212792747419,
                        "length_improvement": 3.3941531868009323,
                        "smoothness_improvement": 693.1799609813568,
                        "objective_score": 16.046516665444422
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.023010659217834472,
                        "num_nodes_avg": 105.2,
                        "path_length_avg": 247.25890321415372,
                        "smoothness_avg": 0.1191098532602342,
                        "success_improvement": 0.0,
                        "time_improvement": 85.63605318102866,
                        "node_improvement": 92.93153262111133,
                        "length_improvement": 17.45786115419664,
                        "smoothness_improvement": 2964.7823157454163,
                        "objective_score": 50.989444225553655
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.011754655838012695,
                        "num_nodes_avg": 94.4,
                        "path_length_avg": 127.41557160345823,
                        "smoothness_avg": 0.13822063405561777,
                        "success_improvement": 0.0,
                        "time_improvement": 76.0361625858193,
                        "node_improvement": 87.99745708836618,
                        "length_improvement": 15.376644218505373,
                        "smoothness_improvement": 1658.156262801516,
                        "objective_score": 40.327616620856595
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m1",
                "algorithm_description": "Beam-guided BiRRT with ancestor line-of-sight compression and spatial hashing (BG-Connect-LOS). The planner alternates tree growth from start and goal using a small beam of guided samples, accelerates nearest lookups with a grid hash, suppresses near-duplicate nodes, and selects a parent among recent ancestors that maintains direct line-of-sight to the new point to compress chains. A short, capped greedy connect links the two trees. Upon success, a bounded shortcut pass refines the path. This reduces expansions and collision checks while improving path quality and smoothness.",
                "planning_mechanism": "At each iteration, pick the active tree and generate a small beam of guided samples biased toward the opposite root. For each sample: find a nearby node via spatial hashing, steer by a fixed step, enforce node and edge collision checks, reject near-duplicates, and pick an ancestor parent with clear line-of-sight to minimize added cost. Insert the node and attempt a capped greedy connect from the opposite tree toward it; if the two trees meet, extract and lightly shortcut the path. Alternate trees and stop early on success.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        beam_width=3,\n        goal_bias=0.15,\n        connect_steps_limit=20,\n        min_separation_factor=0.6,\n        grid_cell_factor=1.0,\n        los_lookback_depth=8,\n        shortcut_attempts=40\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.connect_steps_limit = connect_steps_limit\n        self.min_separation_factor = min_separation_factor\n        self.grid_cell_factor = grid_cell_factor\n        self.los_lookback_depth = los_lookback_depth\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dims = len(bounds)\n        is_3d = dims == 3\n\n        # Parameters derived from step_size\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root = Node(goal_position, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root, is_3d)\n        self._grid_insert(grid_b, goal_root, is_3d)\n\n        success_state = False\n        extracted_path = []\n\n        for _ in range(self.max_iter):\n            # Alternate trees by swapping references each loop\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, goal_position),\n                (tree_b, grid_b, tree_a, grid_a, start_position),\n            ]:\n                made_progress = False\n\n                for _beam in range(self.beam_width):\n                    sample = self._sample_guided(bounds, obstacles, is_3d, attractor)\n\n                    nearest = self._nearest_by_grid(active_tree, active_grid, sample, is_3d)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos, bounds):\n                        continue\n                    if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                        continue\n                    if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                        continue\n                    if self._has_near_duplicate(active_grid, new_pos, self.min_separation, is_3d):\n                        continue\n\n                    # Choose parent among LOS-capable ancestors to compress path\n                    parent = self._choose_ancestor_parent(nearest, new_pos, obstacles, is_3d)\n                    new_cost = parent.cost + self._distance(parent.position, new_pos)\n\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node, is_3d)\n                    made_progress = True\n\n                    # Try capped greedy connect from the opposite tree toward new_node\n                    connect_node = self._attempt_connect(\n                        other_tree, other_grid, new_node.position, obstacles, is_3d, nodes, edges, bounds\n                    )\n                    if connect_node is not None:\n                        # Trees meet at new_node.position; extract path\n                        path_a = self._path_from_root(new_node)\n                        path_b = self._path_from_root(connect_node)\n                        # Remove duplicate joint if equal\n                        if path_a and path_b and path_a[-1] == path_b[-1]:\n                            path_b = path_b[:-1]\n                        raw_path = path_a + path_b[::-1]\n                        # Light shortcut smoothing\n                        smoothed = self._shortcut_path(raw_path, obstacles, is_3d, attempts=self.shortcut_attempts)\n                        extracted_path = smoothed if smoothed else raw_path\n                        success_state = True\n                        return PlannerResult(True, extracted_path, nodes, edges)\n\n                # If neither beam sample made progress for this tree, continue with the other\n                if not made_progress:\n                    continue\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # --------- Core Geometry / Utilities ---------\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _within_bounds(self, pos, bounds):\n        for i in range(len(bounds)):\n            if pos[i] < 0.0 or pos[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= 1e-9:\n            return from_pos\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * r for d in range(len(from_pos)))\n\n    def _sample_guided(self, bounds, obstacles, is_3d, target):\n        # Mild guidance: with some probability sample exactly target, else blend toward target\n        while True:\n            if random.random() < self.goal_bias:\n                p = target\n            else:\n                rand = tuple(random.uniform(0.0, bounds[d]) for d in range(len(bounds)))\n                alpha = 0.2\n                p = tuple(alpha * target[d] + (1.0 - alpha) * rand[d] for d in range(len(bounds)))\n            if self._within_bounds(p, bounds) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _path_from_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\n\n    # --------- Spatial Hash (Grid) ---------\n\n    def _cell_of(self, pos):\n        # integer grid cell indices\n        if len(pos) == 3:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        else:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node, is_3d):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _has_near_duplicate(self, grid, pos, radius, is_3d):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    def _nearest_by_grid(self, tree, grid, pos, is_3d, ring_limit=3):\n        # Search neighborhood rings; fallback to linear scan if not found\n        cell = self._cell_of(pos)\n        best = None\n        best_d = float(\"inf\")\n\n        if is_3d:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best_d = d\n                                        best = n\n                                        found = True\n                if found and best is not None:\n                    return best\n        else:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                                    found = True\n                if found and best is not None:\n                    return best\n\n        # Fallback\n        if not tree:\n            return None\n        return min(tree, key=lambda n: self._distance(n.position, pos))\n\n    # --------- Parent selection via LOS to ancestors ---------\n\n    def _choose_ancestor_parent(self, nearest, new_pos, obstacles, is_3d):\n        best_parent = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        steps = 0\n        cur = nearest\n        while cur is not None and steps < self.los_lookback_depth:\n            if not self._is_edge_in_obstacle(cur.position, new_pos, obstacles, is_3d):\n                cand_cost = cur.cost + self._distance(cur.position, new_pos)\n                if cand_cost < best_cost:\n                    best_cost = cand_cost\n                    best_parent = cur\n            cur = cur.parent\n            steps += 1\n        return best_parent\n\n    # --------- Connect attempt ---------\n\n    def _attempt_connect(self, tree, grid, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest_by_grid(tree, grid, target_pos, is_3d)\n        if nearest is None:\n            return None\n\n        current = nearest\n        for _ in range(self.connect_steps_limit):\n            step_pos = self._steer(current.position, target_pos)\n            if not self._within_bounds(step_pos, bounds):\n                return None\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                return None\n\n            # If close enough to target and direct edge exists, finalize with exact target node\n            if self._distance(step_pos, target_pos) <= 1e-6 or (\n                self._distance(step_pos, target_pos) <= self.step_size and\n                not self._is_edge_in_obstacle(step_pos, target_pos, obstacles, is_3d) and\n                not self._is_in_obstacle(target_pos, obstacles, is_3d)\n            ):\n                # Add intermediate step node if it is not exactly current\n                if self._distance(current.position, step_pos) > 1e-9:\n                    if not self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                        new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n                        current.add_child(new_node)\n                        tree.append(new_node)\n                        nodes.append(new_node)\n                        edges.append((current, new_node))\n                        self._grid_insert(grid, new_node, is_3d)\n                        current = new_node\n                    else:\n                        # If duplicate exists, try using current as is\n                        pass\n                # Add final node at the exact target position to guarantee path merge\n                final_node = Node(target_pos, parent=current, cost=current.cost + self._distance(current.position, target_pos))\n                current.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((current, final_node))\n                self._grid_insert(grid, final_node, is_3d)\n                return final_node\n\n            # Regular step addition with duplicate suppression\n            if self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                # Progress is negligible; stop trying to avoid loops\n                return None\n\n            new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node, is_3d)\n            current = new_node\n\n        return None\n\n    # --------- Collision Checking ---------\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d):\n        distance = self._distance(from_pos, to_pos)\n        resolution = max(0.5, min(1.0, self.step_size * 0.5))\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    # --------- Shortcut Smoothing (bounded) ---------\n\n    def _shortcut_path(self, path, obstacles, is_3d, attempts=40):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        n = len(pts)\n        tries = 0\n        i = 0\n        # Greedy forward skipping with bounded iterations\n        while i < len(pts) - 2 and tries < attempts:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                    # Remove intermediates\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n            tries += 1\n        return pts",
                "objective": -28.86257,
                "time_improvement": 43.0,
                "length_improvement": 15.0,
                "smoothness_improvement": 1410.0,
                "node_improvement": 90.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.03400664329528809,
                        "num_nodes_avg": 52.1,
                        "path_length_avg": 171.51876006638196,
                        "smoothness_avg": 0.050501544373221775,
                        "success_improvement": 0.0,
                        "time_improvement": -33.36568499023374,
                        "node_improvement": 86.87987912364643,
                        "length_improvement": 5.987849718937115,
                        "smoothness_improvement": 690.45883529979,
                        "objective_score": -2.964701489208901
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.030187082290649415,
                        "num_nodes_avg": 92.2,
                        "path_length_avg": 234.31486940525366,
                        "smoothness_avg": 0.08620583217892899,
                        "success_improvement": 0.0,
                        "time_improvement": 81.1563136658539,
                        "node_improvement": 93.8050124302896,
                        "length_improvement": 21.77895221296278,
                        "smoothness_improvement": 2118.138153515002,
                        "objective_score": 48.004956195108846
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.009754443168640136,
                        "num_nodes_avg": 73.2,
                        "path_length_avg": 124.45355479806292,
                        "smoothness_avg": 0.11960663519260235,
                        "success_improvement": 0.0,
                        "time_improvement": 80.11393158758125,
                        "node_improvement": 90.69294342021614,
                        "length_improvement": 17.343874744565582,
                        "smoothness_improvement": 1421.3875712064366,
                        "objective_score": 41.54744217904591
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "cross_over",
            "algorithm_description": "ARC-BiRRT: Adaptive Reuse-Cached, Ring-Hashed, Cost-Gated BiRRT-Connect. It accelerates bidirectional planning with exact edge-collision memoization, ring-hash nearest search, local LOS parent selection, per-cell cost-gated admission, and single-shot tree bridging; upon success it applies cache-reused visibility pruning and bounded shortcut smoothing for shorter, smoother paths.",
            "planning_mechanism": "Alternate expanding start/goal trees with small-beam guided sampling (goal/corridor bias); find a near node via ring-hash, steer one step, enforce node+edge checks and near-duplicate rejection; pick a best-cost parent among nearby ring neighbors that see the new point; admit only if per-cell capacity or cost improves; after insertion, attempt a direct LOS bridge to the opposite tree; on success, extract and cache-prune/shortcut the path and stop early.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.5,\n        beam_width=2,\n        goal_bias=0.3,\n        grid_cell_factor=1.6,\n        ring_max=3,\n        max_per_cell=6,\n        min_sep_factor=0.5,\n        los_neighbor_rings=1,\n        smoothing_iters=50,\n        corridor_bias=0.5\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.ring_max = ring_max\n        self.max_per_cell = max_per_cell\n        self.min_sep_factor = min_sep_factor\n        self.los_neighbor_rings = los_neighbor_rings\n        self.smoothing_iters = smoothing_iters\n        self.corridor_bias = corridor_bias\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # RNG state\n        self._lcg_state = 2463534242\n\n        # Caches\n        self._edge_cache = {}  # exact endpoints (ordered) -> bool blocked\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Derived params\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.3, self.step_size * self.min_sep_factor)\n        self.edge_res = max(0.5, min(1.0, self.step_size * 0.5))\n\n        # Reset caches\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            path = self._visibility_prune(path, obstacles, is_3d)\n            path = self._shortcut_smooth(path, obstacles, is_3d, iters=min(10, self.smoothing_iters))\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        bestcost_start = {}\n        bestcost_goal = {}\n\n        self._grid_add(grid_start, counts_start, bestcost_start, start_root)\n        self._grid_add(grid_goal, counts_goal, bestcost_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n\n            tree_a = start_tree if active_start else goal_tree\n            grid_a = grid_start if active_start else grid_goal\n            counts_a = counts_start if active_start else counts_goal\n            bestcost_a = bestcost_start if active_start else bestcost_goal\n\n            tree_b = goal_tree if active_start else start_tree\n            grid_b = grid_goal if active_start else grid_start\n            counts_b = counts_goal if active_start else counts_start\n            bestcost_b = bestcost_goal if active_start else bestcost_start\n\n            attractor = goal if active_start else start\n\n            for _ in range(self.beam_width):\n                x_rand = self._guided_sample(obstacles, is_3d, attractor)\n\n                nearest = self._nearest_hashed(grid_a, tree_a, x_rand)\n                if nearest is None:\n                    continue\n\n                new_pos = self._steer(nearest.position, x_rand)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                if self._near_duplicate(grid_a, new_pos, self.min_sep):\n                    continue\n\n                # Choose a parent among local neighbors with LOS (limited rings) for better path cost\n                parent = self._choose_parent_local(grid_a, new_pos, nearest, obstacles, is_3d)\n                if self._edge_blocked(parent.position, new_pos, obstacles, is_3d):\n                    continue  # safety\n\n                new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n                # Per-cell cost-gated admission\n                key_new = self._grid_key(new_pos)\n                ccount = counts_a.get(key_new, 0)\n                bestc = bestcost_a.get(key_new, float('inf'))\n                if ccount >= self.max_per_cell and not (new_cost + 1e-9 < bestc):\n                    continue\n\n                # Insert node\n                new_node = Node(new_pos, parent=parent, cost=new_cost)\n                parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((parent, new_node))\n                self._grid_add(grid_a, counts_a, bestcost_a, new_node)\n\n                # Try single-shot direct bridge to the other tree\n                other_near = self._nearest_hashed(grid_b, tree_b, new_node.position)\n                if other_near is not None:\n                    if not self._edge_blocked(new_node.position, other_near.position, obstacles, is_3d):\n                        path = self._extract_path(new_node, other_near, a_is_start_tree=active_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-9:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision and caching\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        if k in self._edge_cache:\n            return self._edge_cache[k]\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _guided_sample(self, obstacles, is_3d, attractor):\n        # Goal-biased with optional corridor pull (activated only after success; here kept generic)\n        if self._rand() < self.goal_bias:\n            p = attractor\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Mild blend toward attractor\n        alpha = 0.2\n        if self.dim == 3:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]),\n                   self._uniform(0.0, self.bounds[2]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(3))\n        else:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(2))\n        if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    # Grid / NN\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n        bc = bestcost.get(k)\n        if bc is None or node.cost < bc:\n            bestcost[k] = node.cost\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.ring_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback to limited random subset to avoid O(N)\n        if not tree:\n            return None\n        trials = min(64, len(tree))\n        for _ in range(trials):\n            idx = int(self._uniform(0, len(tree)))\n            n = tree[idx]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r = 1\n        cand = self._grid_ring_collect(grid, key, r)\n        rr = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # Parent selection among local neighbors with LOS\n    def _choose_parent_local(self, grid, new_pos, fallback_nearest, obstacles, is_3d):\n        key = self._grid_key(new_pos)\n        best_parent = fallback_nearest\n        best_cost = fallback_nearest.cost + self._dist(fallback_nearest.position, new_pos)\n        max_r = max(1, self.los_neighbor_rings)\n        for r in range(0, max_r + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            for n in cand:\n                if n is fallback_nearest or n is best_parent:\n                    pass\n                # Check LOS\n                if not self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                    c = n.cost + self._dist(n.position, new_pos)\n                    if c + 1e-9 < best_cost:\n                        best_cost = c\n                        best_parent = n\n        return best_parent\n\n    # Path\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
            "objective": -33.74569,
            "time_improvement": 58.0,
            "length_improvement": 18.0,
            "smoothness_improvement": 1051.0,
            "node_improvement": 90.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010497808456420898,
                    "num_nodes_avg": 34.0,
                    "path_length_avg": 154.57051194099205,
                    "smoothness_avg": 0.03958955729868922,
                    "success_improvement": 0.0,
                    "time_improvement": 58.830179046785545,
                    "node_improvement": 91.4379249559305,
                    "length_improvement": 15.277453078640955,
                    "smoothness_improvement": 519.6625418241595,
                    "objective_score": 29.41383827034103
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.049208974838256835,
                    "num_nodes_avg": 116.0,
                    "path_length_avg": 236.11546529476226,
                    "smoothness_avg": 0.06943512420354042,
                    "success_improvement": 0.0,
                    "time_improvement": 69.28227518814471,
                    "node_improvement": 92.20587247194786,
                    "length_improvement": 21.177861477765767,
                    "smoothness_improvement": 1686.6157578555544,
                    "objective_score": 41.92447823238064
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026494455337524415,
                    "num_nodes_avg": 117.0,
                    "path_length_avg": 122.03531483713664,
                    "smoothness_avg": 0.08227711903121854,
                    "success_improvement": 0.0,
                    "time_improvement": 45.98660915000911,
                    "node_improvement": 85.12396694214877,
                    "length_improvement": 18.94995458240024,
                    "smoothness_improvement": 946.5588810119002,
                    "objective_score": 29.898749899502377
                }
            ],
            "success_rate": 1.0
        },
        "objective": 38.0,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Excessive collision checking from deep line-of-sight ancestor scans and repeated edge tests per extension\n   - Over-coarse or pessimistic blocked-edge caching leading to false \u201cblocked\u201d results and aborted expansions\n   - Aggressive connect/blacklist logic and stepwise connect bookkeeping that suppress valid bridges and waste iterations\n   - Nearest-neighbor lookups that often fall back to linear scans due to coarse grids or weak locality\n   - Rigid per-cell throttling and large duplicate radii causing high rejection rates and poor local refinement\n   - Tree bloat from unconditional final-node insertions and multi-step connects increasing query/maintenance cost\n   - Single-step extend with no cost-aware parent refinement yielding zig-zag growth and longer searches"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Local neighbor-based LOS parent selection with bounded neighborhood rings (avoids deep ancestor scans)\n   - Exact edge-collision memoization (symmetric endpoint cache) replacing coarse blocked-only caching\n   - Per-cell cost-gated admission using best-cost tracking to prevent low-value inserts in saturated cells\n   - Ring-hashed nearest search with fixed local rings and bounded random-subset fallback (no O(N) fallback)\n   - Tuned spatial parameters (finer grid cells, smaller near-duplicate threshold) to lower rejections\n   - Leaner expansion loop: reduced beam width and single-shot bridging without blacklist overhead\n   - Early straight-line check and bounded post-processing\n\n2. Expected mechanism of impact:\n   - Fewer and cheaper collision checks per extension; less LOS probing reduces constant factors\n   - Eliminates false negatives from coarse caches, enabling valid edges and earlier tree joining\n   - Limits tree growth in crowded cells, reducing NN/query time and bookkeeping per iteration\n   - Better local NN recall shortens expansion steps and avoids costly global scans\n   - Lower rejection rate increases effective progress per iteration and reduces wasted samples\n   - Earlier successful bridges terminate search sooner, cutting total iterations\n   - Smaller, cleaner trees decrease per-iteration overhead, improving wall-clock time"
        }
    },
    {
        "parents": [
            {
                "operator": "e1",
                "algorithm_description": "STRIDE-BF-BiRRT: Score-Tempered, Proxy-Guided, Edge-Cached Best-First Bidirectional RRT. It grows two trees with small best-first beams scored f = g + w*h, where h is distance to a rotating proxy set from the opposite tree. It uses a hashed grid for approximate nearest search, progressive step shrinking for viable extensions, duplicate suppression, and bounded edge-collision memoization. After each insertion it tries a direct bridge and a short greedy connect; on success it returns a lightly shortcutted path for speed and smoothness.",
                "planning_mechanism": "Initialize start/goal roots, two hash-grids, and bounded free/blocked edge caches. Each iteration alternates trees, refreshes a small proxy set from the opposite tree, samples a few targets (goal/corridor/uniform), chooses the candidate with minimum f = (parent.g + \u0394g) + w*min_dist_to_proxies, and extends via progressive step shrinking. Only free nodes/edges are added. It then attempts a direct bridge and a brief guided connect. On first feasible connection it assembles and shortcuttens the path and returns.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=8.0,\n                 min_step=2.0,\n                 beam_k=3,\n                 goal_bias=0.3,\n                 corridor_bias=0.5,\n                 connect_steps=8,\n                 collision_res=1.0,\n                 grid_cell=None,\n                 dupe_radius_ratio=0.45,\n                 r_max=3,\n                 random_nn_samples=16,\n                 cache_capacity=80000,\n                 shortcut_iters=28,\n                 proxy_k=8,\n                 proxy_refresh=12,\n                 score_weight=1.0):\n        self.max_iter = max(1, int(max_iter))\n        self.step_size = float(step_size)\n        self.min_step = max(0.5, float(min_step))\n        self.beam_k = max(1, int(beam_k))\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.connect_steps = max(0, int(connect_steps))\n        self.collision_res = max(0.25, float(collision_res))\n        self.grid_cell = grid_cell\n        self.dupe_radius_ratio = max(0.1, float(dupe_radius_ratio))\n        self.r_max = max(1, int(r_max))\n        self.random_nn_samples = max(4, int(random_nn_samples))\n        self.cache_capacity = max(1000, int(cache_capacity))\n        self.shortcut_iters = max(0, int(shortcut_iters))\n        self.proxy_k = max(1, int(proxy_k))\n        self.proxy_refresh = max(1, int(proxy_refresh))\n        self.score_weight = max(0.5, float(score_weight))\n\n        self.dim = 2\n        self.bounds = None\n\n        self._lcg_state = 88172645463393265\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        start = self._as_tuple(map.start)\n        goal = self._as_tuple(map.goal)\n        obstacles = list(map.obstacles)\n        is_3d = (self.dim == 3)\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.cache_bin = max(0.5, min(self.collision_res, self.step_size * 0.5))\n\n        self._free_edges = {}\n        self._blocked_edges = {}\n        self._cache_keys = []\n\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        if self._is_edge_free_cached(start, goal, obstacles, is_3d):\n            n0 = Node(start, None, 0.0)\n            n1 = Node(goal, n0, self._dist(start, goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [start, goal], [n0, n1], [(n0, n1)])\n\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start, grid_goal = {}, {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        dsg = self._dist(start, goal)\n        corridor_w = max(self.step_size, 0.12 * dsg)\n        best_iter = -1\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            if it % self.proxy_refresh == 0 or len(tree_b) <= self.proxy_k:\n                proxies = self._select_proxies(tree_b, self.proxy_k)\n            else:\n                proxies = self._select_proxies(tree_b, self.proxy_k)\n\n            winner = None\n            winner_parent = None\n            best_f = float('inf')\n\n            for _ in range(self.beam_k):\n                target = self._sample_biased(start, goal, corridor_w, obstacles, is_3d, root_other)\n                parent = self._nearest_hashed(grid_a, tree_a, target)\n                if parent is None:\n                    continue\n                new_pos = self._progressive_steer(parent.position, target, obstacles, is_3d)\n                if new_pos is None:\n                    continue\n                if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                g_new = parent.cost + self._dist(parent.position, new_pos)\n                h = self._min_dist_to_set(new_pos, proxies) if proxies else self._dist(new_pos, root_other)\n                f = g_new + self.score_weight * h\n                if f < best_f:\n                    best_f = f\n                    winner = new_pos\n                    winner_parent = parent\n\n            if winner is None:\n                continue\n\n            new_node = Node(winner, winner_parent, winner_parent.cost + self._dist(winner_parent.position, winner))\n            winner_parent.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((winner_parent, new_node))\n            self._grid_add(grid_a, new_node)\n\n            other_near = self._nearest_hashed(grid_b, tree_b, new_node.position)\n            if other_near is not None and self._is_edge_free_cached(new_node.position, other_near.position, obstacles, is_3d):\n                path = self._extract_path(new_node, other_near)\n                smooth = self._shortcut(path, obstacles, is_3d, self.shortcut_iters)\n                return PlannerResult(True, smooth, start_tree + goal_tree, edges)\n\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._progressive_steer(p.position, new_node.position, obstacles, is_3d)\n                if to_pos is None:\n                    break\n                if self._exists_close(grid_b, to_pos, self.step_size * self.dupe_radius_ratio):\n                    break\n                q = Node(to_pos, p, p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                edges.append((p, q))\n                self._grid_add(grid_b, q)\n\n                if self._is_edge_free_cached(q.position, new_node.position, obstacles, is_3d):\n                    path = self._extract_path(new_node, q)\n                    smooth = self._shortcut(path, obstacles, is_3d, self.shortcut_iters)\n                    return PlannerResult(True, smooth, start_tree + goal_tree, edges)\n\n                p = q\n                steps += 1\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _rand(self):\n        self._lcg_state = (6364136223846793005 * self._lcg_state + 1442695040888963407) % (1 << 61)\n        return (self._lcg_state & ((1 << 61) - 1)) / float(1 << 61)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _rand_int(self, a, b):\n        if b <= a:\n            return a\n        r = int(self._uniform(0.0, (b - a + 1)))\n        v = a + r\n        if v > b:\n            v = b\n        return v\n\n    def _as_tuple(self, p):\n        if isinstance(p, tuple):\n            return p\n        return tuple(p[i] for i in range(len(p)))\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    def _clamp(self, p):\n        return tuple(self._clamp_val(p[i], 0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / max(1e-9, d)\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _seg_aabb_overlap(self, a, b, obs, is_3d):\n        if is_3d:\n            x, y, z, w, h, d = obs\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            if maxx < x or minx > x + w or maxy < y or miny > y + h or maxz < z or minz > z + d:\n                return False\n            return True\n        else:\n            x, y, w, h = obs\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            if maxx < x or minx > x + w or maxy < y or miny > y + h:\n                return False\n            return True\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(max(1, d / max(1e-9, resolution)))\n        for obs in obstacles:\n            if not self._seg_aabb_overlap(a, b, obs, is_3d):\n                continue\n            for i in range(steps + 1):\n                t = i / float(steps)\n                p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n                if self._is_in_obstacle(p, obstacles, is_3d):\n                    return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _cache_put(self, key, free):\n        self._cache_keys.append(key)\n        if free:\n            self._free_edges[key] = True\n        else:\n            self._blocked_edges[key] = True\n        if len(self._cache_keys) > self.cache_capacity:\n            drop = int(max(1, self.cache_capacity * 0.1))\n            for _ in range(drop):\n                if not self._cache_keys:\n                    break\n                k = self._cache_keys.pop(0)\n                self._free_edges.pop(k, None)\n                self._blocked_edges.pop(k, None)\n\n    def _is_edge_free_cached(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        if key in self._blocked_edges:\n            return False\n        if key in self._free_edges:\n            return True\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_res)\n        if blocked:\n            self._cache_put(key, False)\n            return False\n        else:\n            self._cache_put(key, True)\n            return True\n\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, self.r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n                    found = True\n            if found:\n                return best\n        if len(tree) > 0:\n            trials = min(self.random_nn_samples, len(tree))\n            for _ in range(trials):\n                idx = self._rand_int(0, len(tree) - 1)\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                di = n.position[i] - pos[i]\n                s += di * di\n            if s <= r2:\n                return True\n        return False\n\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, start, goal, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_biased(self, start, goal, corridor_w, obstacles, is_3d, root_other):\n        r = self._rand()\n        if r < self.goal_bias:\n            return root_other\n        elif r < self.goal_bias + self.corridor_bias:\n            return self._sample_corridor(start, goal, corridor_w, obstacles, is_3d)\n        else:\n            return self._sample_free(obstacles, is_3d)\n\n    def _progressive_steer(self, from_pos, to_pos, obstacles, is_3d):\n        step = self.step_size\n        while step >= self.min_step:\n            cand = self._steer(from_pos, to_pos, step)\n            if not self._in_bounds(cand):\n                step *= 0.5\n                continue\n            if self._is_in_obstacle(cand, obstacles, is_3d):\n                step *= 0.5\n                continue\n            if not self._is_edge_free_cached(from_pos, cand, obstacles, is_3d):\n                step *= 0.5\n                continue\n            return cand\n        return None\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _shortcut(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = self._rand_int(0, n - 3)\n            j = self._rand_int(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            if self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_res):\n                continue\n            pts = pts[:i + 1] + pts[j:]\n        out = [pts[0]]\n        last = pts[0]\n        i = 1\n        while i < len(pts):\n            far = i\n            j = i\n            while j < len(pts) and not self._is_edge_in_obstacle(last, pts[j], obstacles, is_3d, self.collision_res):\n                far = j\n                j += 1\n            last = pts[far]\n            out.append(last)\n            i = far + 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _min_dist_to_set(self, p, pts):\n        best = float('inf')\n        for q in pts:\n            d = self._dist(p, q)\n            if d < best:\n                best = d\n        return best\n\n    def _select_proxies(self, tree, k):\n        if not tree:\n            return []\n        out = []\n        n = len(tree)\n        if n <= k:\n            for node in tree:\n                out.append(node.position)\n            return out\n        stride = max(1, n // k)\n        idx = n - 1\n        cnt = 0\n        while idx >= 0 and cnt < k:\n            out.append(tree[idx].position)\n            idx -= stride\n            cnt += 1\n        return out",
                "objective": -22.67068,
                "time_improvement": 28.0,
                "length_improvement": 11.0,
                "smoothness_improvement": 1478.0,
                "node_improvement": 85.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.01907973289489746,
                        "num_nodes_avg": 58.6,
                        "path_length_avg": 164.53758766363492,
                        "smoothness_avg": 0.04579305398539159,
                        "success_improvement": 0.0,
                        "time_improvement": 25.17398365773817,
                        "node_improvement": 85.24301183580961,
                        "length_improvement": 9.814340936638626,
                        "smoothness_improvement": 616.7607360797193,
                        "objective_score": 16.524603339703223
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.06179916858673096,
                        "num_nodes_avg": 163.2,
                        "path_length_avg": 247.82573249877174,
                        "smoothness_avg": 0.09381710615283037,
                        "success_improvement": 0.0,
                        "time_improvement": 61.42309689465787,
                        "node_improvement": 89.03446885708526,
                        "length_improvement": 17.26863722371481,
                        "smoothness_improvement": 2313.9817150425365,
                        "objective_score": 40.35801997783892
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.05005335807800293,
                        "num_nodes_avg": 150.1,
                        "path_length_avg": 139.95745090666273,
                        "smoothness_avg": 0.12600553281359275,
                        "success_improvement": 0.0,
                        "time_improvement": -2.042165380642809,
                        "node_improvement": 80.91544818817546,
                        "length_improvement": 7.046925165431393,
                        "smoothness_improvement": 1502.7810766279433,
                        "objective_score": 11.12941086820571
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m3",
                "algorithm_description": "Bounded BiRRT-Connect with Grid-Accelerated Nearest and Lightweight Shortcutting: a time-capped, bidirectional RRT-Connect that uses a coarse spatial grid for fast nearest-neighbor queries, commits only validated steps, attempts a single greedy bridge per iteration, and applies a brief shortcut smoother to the first found path for quality without heavy rewiring or anytime overhead.",
                "planning_mechanism": "Mechanism: Alternate growing start/goal trees with one extend loop toward a biased sample; each successful extension triggers a greedy extend from the opposite tree toward the new node. Both node and edge collisions are strictly checked before every insertion and the final bridge. Nearest queries use a bucket grid with limited ring expansion and linear fallback. On success, a bounded-time shortcut pass improves path length/smoothness; the planner enforces a hard time limit and returns the best (first) feasible path promptly.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=6.0,\n        goal_sample_rate=0.15,\n        bridge_bias_rate=0.30,\n        cell_size_factor=2.0,\n        time_limit_sec=12.0,\n        edge_resolution=1.0,\n        smooth_attempts=80,\n        smooth_time_frac=0.2\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.bridge_bias_rate = bridge_bias_rate\n        self.cell_size_factor = cell_size_factor\n        self.time_limit_sec = time_limit_sec\n        self.edge_resolution = edge_resolution\n        self.smooth_attempts = smooth_attempts\n        self.smooth_time_frac = smooth_time_frac\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Validate start/goal feasibility\n        if self._is_in_obstacle(start_position, obstacles, is_3d) or self._is_in_obstacle(goal_position, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Initialize trees and spatial grids\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root = Node(goal_position, parent=None, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        grid_start = {}\n        grid_goal = {}\n        self._grid_insert(grid_start, start_root.position, start_root, cell_size, dim)\n        self._grid_insert(grid_goal, goal_root.position, goal_root, cell_size, dim)\n\n        start_time = time.time()\n\n        # Early straight-line check\n        if not self._is_edge_in_obstacle(start_position, goal_position, obstacles, is_3d, self.edge_resolution):\n            edges.append((start_root, goal_root))\n            direct_path = [start_position, goal_position]\n            return PlannerResult(True, direct_path, start_tree + goal_tree, edges)\n\n        # Main loop\n        for it in range(self.max_iter):\n            if time.time() - start_time >= self.time_limit_sec:\n                return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n            # Alternate tree growth\n            if it % 2 == 0:\n                grow_tree, grow_grid = start_tree, grid_start\n                other_tree, other_grid = goal_tree, grid_goal\n                a_is_start_side = True\n                other_root_pos = goal_root.position\n            else:\n                grow_tree, grow_grid = goal_tree, grid_goal\n                other_tree, other_grid = start_tree, grid_start\n                a_is_start_side = False\n                other_root_pos = start_root.position\n\n            sample = self._sample(bounds, obstacles, is_3d, other_root_pos)\n\n            # Extend grow_tree toward sample\n            a_near = self._nearest_from_grid(grow_tree, grow_grid, sample, cell_size, dim)\n            a_last = self._extend(grow_tree, grow_grid, a_near, sample, nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if a_last is None:\n                continue\n\n            # Greedy connect: extend other_tree toward the new node\n            b_near = self._nearest_from_grid(other_tree, other_grid, a_last.position, cell_size, dim)\n            b_last = self._extend(other_tree, other_grid, b_near, a_last.position, nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if b_last is None:\n                continue\n\n            # Attempt final short bridge\n            if self._distance(b_last.position, a_last.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(b_last.position, a_last.position, obstacles, is_3d, self.edge_resolution):\n                    edges.append((b_last, a_last))\n                    # Extract and smooth path\n                    final_path = self._assemble_path(a_last, b_last, a_is_start_side)\n                    remaining = max(0.0, self.time_limit_sec - (time.time() - start_time))\n                    budget = min(remaining, self.time_limit_sec * self.smooth_time_frac)\n                    final_path = self._shortcut_path(final_path, obstacles, is_3d, bounds, budget, self.smooth_attempts)\n                    return PlannerResult(True, final_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---- Utilities ----\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _within_bounds(self, p, bounds):\n        for i in range(len(bounds)):\n            if p[i] < 0.0 or p[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step_size):\n        d = self._distance(from_pos, to_pos)\n        if d <= step_size:\n            return to_pos\n        r = step_size / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _sample(self, bounds, obstacles, is_3d, other_root_pos):\n        # Bias toward the opposite root\n        if random.random() < self.bridge_bias_rate:\n            return other_root_pos\n        # Mild goal bias to encourage meeting/goal attraction\n        if random.random() < self.goal_sample_rate:\n            return other_root_pos\n        # Uniform rejection sampling in free space\n        dim = len(bounds)\n        for _ in range(30):\n            pt = tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n        # Fallback: last sample even if occupied (extend will reject)\n        return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n\n    def _extend(self, tree, grid, nearest_node, target_pos, nodes, edges, obstacles, is_3d, bounds, cell_size, dim):\n        current = nearest_node\n        last_new = None\n        while True:\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if not self._within_bounds(step_pos, bounds):\n                break\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                break\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d, self.edge_resolution):\n                break\n            # Both node and edge are valid \u2192 commit\n            new_node = Node(step_pos)\n            new_node.cost = current.cost + self._distance(current.position, step_pos)\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node.position, new_node, cell_size, dim)\n            last_new = new_node\n            current = new_node\n            # Stop if reached target (within one step)\n            if self._distance(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    def _assemble_path(self, a_node, b_node, a_is_start_side):\n        if a_is_start_side:\n            pa = a_node.path_from_root()   # start -> ... -> a\n            pb = b_node.path_from_root()   # goal  -> ... -> b\n            return pa + pb[::-1]           # start ... a, b ... goal\n        else:\n            pa = a_node.path_from_root()   # goal  -> ... -> a\n            pb = b_node.path_from_root()   # start -> ... -> b\n            return pb + pa[::-1]           # start ... b, a ... goal\n\n    # ---- Spatial grid for approximate nearest ----\n    def _cell_index(self, pos, cell_size, dim):\n        if dim == 2:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size))\n        else:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size), int(pos[2] // cell_size))\n\n    def _grid_insert(self, grid, pos, node, cell_size, dim):\n        idx = self._cell_index(pos, cell_size, dim)\n        if idx in grid:\n            grid[idx].append(node)\n        else:\n            grid[idx] = [node]\n\n    def _nearest_from_grid(self, tree, grid, point, cell_size, dim, max_rings=3):\n        # For small trees, just do linear scan\n        if len(tree) < 32:\n            return min(tree, key=lambda n: self._distance(n.position, point))\n\n        center = self._cell_index(point, cell_size, dim)\n        best = None\n        # Expand rings until some candidates found, then pick nearest among them\n        for r in range(0, max_rings + 1):\n            candidates = []\n            if dim == 2:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        idx = (center[0] + dx, center[1] + dy)\n                        if idx in grid:\n                            candidates.extend(grid[idx])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if idx in grid:\n                                candidates.extend(grid[idx])\n            if candidates:\n                best = min(candidates, key=lambda n: self._distance(n.position, point))\n                break\n\n        if best is None:\n            # Fallback to linear scan if grid empty nearby\n            best = min(tree, key=lambda n: self._distance(n.position, point))\n        return best\n\n    # ---- Collision utilities ----\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist / max(1e-6, resolution)))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    # ---- Path shortcutting ----\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, time_budget, attempts):\n        if len(path) < 3:\n            return path\n        start_t = time.time()\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and (time.time() - start_t) <= time_budget:\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            # Keep within bounds and collision-free\n            if not self._segment_within_bounds(a, b, bounds):\n                tries += 1\n                continue\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_resolution):\n                # Apply shortcut\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n            tries += 1\n        return pts\n\n    def _segment_within_bounds(self, a, b, bounds):\n        # The interpolated segment is within bounds if endpoints are; checks along the way via edge collision\n        for d in range(len(bounds)):\n            if a[d] < 0.0 or a[d] > bounds[d]:\n                return False\n            if b[d] < 0.0 or b[d] > bounds[d]:\n                return False\n        return True",
                "objective": -35.38986,
                "time_improvement": 79.0,
                "length_improvement": 6.0,
                "smoothness_improvement": 1571.0,
                "node_improvement": 81.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.009288859367370606,
                        "num_nodes_avg": 87.5,
                        "path_length_avg": 179.7819366813108,
                        "smoothness_avg": 0.041891929272141075,
                        "success_improvement": 0.0,
                        "time_improvement": 63.57137981686718,
                        "node_improvement": 77.96524804835055,
                        "length_improvement": 1.4586716778820132,
                        "smoothness_improvement": 555.6996628894441,
                        "objective_score": 22.725115266236582
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.009074711799621582,
                        "num_nodes_avg": 124.9,
                        "path_length_avg": 251.58839597257443,
                        "smoothness_avg": 0.10077141463831178,
                        "success_improvement": 0.0,
                        "time_improvement": 94.3352914641303,
                        "node_improvement": 91.6078747564335,
                        "length_improvement": 16.01255185389636,
                        "smoothness_improvement": 2492.9210813599107,
                        "objective_score": 50.372723958376454
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.01003124713897705,
                        "num_nodes_avg": 215.4,
                        "path_length_avg": 148.33090891427284,
                        "smoothness_avg": 0.13860849885025553,
                        "success_improvement": 0.0,
                        "time_improvement": 79.54962026854608,
                        "node_improvement": 72.6128417037508,
                        "length_improvement": 1.4856730579993105,
                        "smoothness_improvement": 1663.0898743601072,
                        "objective_score": 33.07173928716395
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "ABLE-RRT: Adaptive Best-Parent Light Elastic Bidirectional RRT-Connect. Two grids grow start/goal trees with mixture-biased sampling. Each extension selects a locally optimal parent within one-step radius to reduce path cost, enforces strict node/edge collision checks, and performs greedy connect to the opposite tree. AABB-pruned edge checks accelerate collision tests. Upon connection, a light two-stage smoother (visibility compression + shortcutting + optional rubber-band) improves length and smoothness while keeping runtime low.",
            "planning_mechanism": "Initialize bidirectional trees and coarse grids. Each iteration: sample (goal/corridor/uniform), find a near node via grid, propose a one-step point, choose the best parent among nearby nodes that can reach it collision-free, then insert. Greedily connect the other tree toward the new node; if a short, collision-free bridge closes the gap, assemble the path and apply lightweight smoothing.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=7.0,\n        goal_bias=0.20,\n        corridor_bias=0.40,\n        cell_size_factor=2.0,\n        edge_resolution=1.0,\n        dupe_radius_ratio=0.40,\n        neighbor_radius_ratio=1.25,\n        smooth_shortcuts=80,\n        rubber_iters=6\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.cell_size_factor = float(cell_size_factor)\n        self.edge_resolution = float(edge_resolution)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.neighbor_radius_ratio = float(neighbor_radius_ratio)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.rubber_iters = int(max(0, rubber_iters))\n\n    def plan(self, map):\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        obstacles = list(map.obstacles)\n\n        # Validate start/goal\n        if not self._within_bounds(start, bounds) or not self._within_bounds(goal, bounds):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight line\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_resolution):\n            n0 = Node(start, None, 0.0)\n            n1 = Node(goal, n0, self._distance(start, goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [start, goal], [n0, n1], [(n0, n1)])\n\n        # Init trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n        cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        grid_start, grid_goal = {}, {}\n        self._grid_insert(grid_start, start_root.position, start_root, cell_size, dim)\n        self._grid_insert(grid_goal, goal_root.position, goal_root, cell_size, dim)\n\n        dsg = self._distance(start, goal)\n        corridor_w = max(self.step_size, 0.18 * dsg)\n        dupe_radius = max(0.5, self.dupe_radius_ratio * self.step_size)\n        neighbor_radius = max(self.step_size, self.neighbor_radius_ratio * self.step_size)\n\n        for it in range(self.max_iter):\n            # Alternate growth\n            if it % 2 == 0:\n                grow_tree, grow_grid, grow_root = start_tree, grid_start, start_root\n                other_tree, other_grid, other_root = goal_tree, grid_goal, goal_root\n                other_root_pos = goal\n                a_is_start_side = True\n            else:\n                grow_tree, grow_grid, grow_root = goal_tree, grid_goal, goal_root\n                other_tree, other_grid, other_root = start_tree, grid_start, start_root\n                other_root_pos = start\n                a_is_start_side = False\n\n            target = self._sample_target(bounds, obstacles, is_3d, start, goal, corridor_w, other_root_pos)\n            a_near = self._nearest_from_grid(grow_tree, grow_grid, target, cell_size, dim)\n\n            # Propose a one-step point\n            proposed = self._steer(a_near.position, target, self.step_size)\n            if not self._within_bounds(proposed, bounds):\n                continue\n            if self._is_in_obstacle(proposed, obstacles, is_3d):\n                continue\n            if self._exists_close(grow_grid, proposed, dupe_radius, cell_size, dim):\n                continue\n\n            # Choose best parent among neighbors that can reach proposed within one step\n            candidates = self._neighbors_within_radius(grow_grid, proposed, neighbor_radius, cell_size, dim)\n            if a_near not in candidates:\n                candidates.append(a_near)\n            best_parent = None\n            best_cost = float('inf')\n            for cand in candidates:\n                dcp = self._distance(cand.position, proposed)\n                if dcp > self.step_size + 1e-9:\n                    continue\n                if self._is_edge_in_obstacle(cand.position, proposed, obstacles, is_3d, self.edge_resolution):\n                    continue\n                cost = cand.cost + dcp\n                if cost < best_cost:\n                    best_cost = cost\n                    best_parent = cand\n            if best_parent is None:\n                continue\n\n            # Commit new node (both node and edge already validated)\n            new_node = Node(proposed, best_parent, best_cost)\n            best_parent.add_child(new_node)\n            grow_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            self._grid_insert(grow_grid, new_node.position, new_node, cell_size, dim)\n\n            # Greedy connect from the other tree toward new_node\n            b_near = self._nearest_from_grid(other_tree, other_grid, new_node.position, cell_size, dim)\n            b_last = self._greedy_extend(other_tree, other_grid, b_near, new_node.position,\n                                         nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if b_last is None:\n                continue\n\n            # Try final short bridge\n            if self._distance(b_last.position, new_node.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(b_last.position, new_node.position, obstacles, is_3d, self.edge_resolution):\n                    edges.append((b_last, new_node))\n                    # Assemble path\n                    if a_is_start_side:\n                        pa = new_node.path_from_root()\n                        pb = b_last.path_from_root()\n                        raw_path = pa + pb[::-1]\n                    else:\n                        pa = new_node.path_from_root()\n                        pb = b_last.path_from_root()\n                        raw_path = pb + pa[::-1]\n                    # Smooth\n                    path = self._compress_visibility(raw_path, obstacles, is_3d)\n                    path = self._shortcut_path(path, obstacles, is_3d, bounds, self.smooth_shortcuts)\n                    path = self._rubber_band(path, obstacles, is_3d, self.rubber_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---- Geometry utilities ----\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(len(a)):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p, bounds):\n        for i in range(len(bounds)):\n            if p[i] < 0.0 or p[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._distance(from_pos, to_pos)\n        if d <= step:\n            return tuple(to_pos[i] for i in range(len(to_pos)))\n        r = step / (d + 1e-12)\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    # ---- Sampling ----\n    def _sample_target(self, bounds, obstacles, is_3d, start, goal, corridor_w, other_root_pos):\n        import random  # Local import to avoid global requirement; acceptable inline\n        r = random.random()\n        if r < self.goal_bias:\n            return other_root_pos\n        elif r < self.goal_bias + self.corridor_bias:\n            t = random.random()\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(len(bounds)))\n            if len(bounds) == 3:\n                return (\n                    self._clamp(base[0] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[0]),\n                    self._clamp(base[1] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[1]),\n                    self._clamp(base[2] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[2]),\n                )\n            else:\n                return (\n                    self._clamp(base[0] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[0]),\n                    self._clamp(base[1] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[1]),\n                )\n        else:\n            # rejection sample in free space\n            for _ in range(32):\n                if len(bounds) == 3:\n                    p = (random.uniform(0.0, bounds[0]),\n                         random.uniform(0.0, bounds[1]),\n                         random.uniform(0.0, bounds[2]))\n                else:\n                    p = (random.uniform(0.0, bounds[0]),\n                         random.uniform(0.0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback (may be occupied; extension will reject)\n            if len(bounds) == 3:\n                return (random.uniform(0.0, bounds[0]),\n                        random.uniform(0.0, bounds[1]),\n                        random.uniform(0.0, bounds[2]))\n            else:\n                return (random.uniform(0.0, bounds[0]),\n                        random.uniform(0.0, bounds[1]))\n\n    def _clamp(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---- Collision utilities ----\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for x, y, z, w, h, d in obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for x, y, w, h in obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _seg_aabb_overlap(self, a, b, obs, is_3d):\n        if is_3d:\n            x, y, z, w, h, d = obs\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            if maxx < x or minx > x + w or maxy < y or miny > y + h or maxz < z or minz > z + d:\n                return False\n            return True\n        else:\n            x, y, w, h = obs\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            if maxx < x or minx > x + w or maxy < y or miny > y + h:\n                return False\n            return True\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._distance(a, b)\n        steps = int(max(1, d / max(1e-9, resolution)))\n        # Pre-filter obstacles by segment AABB overlap\n        relevant = []\n        for obs in obstacles:\n            if self._seg_aabb_overlap(a, b, obs, is_3d):\n                relevant.append(obs)\n        if not relevant:\n            return False\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(len(a)))\n            if self._is_in_obstacle(p, relevant, is_3d):\n                return True\n        return False\n\n    # ---- Grid NN and neighborhood ----\n    def _cell_index(self, pos, cell_size, dim):\n        if dim == 2:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size))\n        else:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size), int(pos[2] // cell_size))\n\n    def _grid_insert(self, grid, pos, node, cell_size, dim):\n        idx = self._cell_index(pos, cell_size, dim)\n        bucket = grid.get(idx)\n        if bucket is None:\n            grid[idx] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_from_grid(self, tree, grid, point, cell_size, dim, max_rings=3):\n        if len(tree) < 32:\n            best = None\n            bestd = float('inf')\n            for n in tree:\n                d = self._distance(n.position, point)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            return best\n        center = self._cell_index(point, cell_size, dim)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, max_rings + 1):\n            cand = []\n            if dim == 2:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        idx = (center[0] + dx, center[1] + dy)\n                        if idx in grid:\n                            cand.extend(grid[idx])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if idx in grid:\n                                cand.extend(grid[idx])\n            if cand:\n                for n in cand:\n                    d = self._distance(n.position, point)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                        found = True\n            if found:\n                break\n        if best is None:\n            # fallback linear\n            best = tree[0]\n            bestd = self._distance(best.position, point)\n            for n in tree:\n                d = self._distance(n.position, point)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_within_radius(self, grid, point, radius, cell_size, dim):\n        cells = int(radius / max(1e-9, cell_size)) + 1\n        center = self._cell_index(point, cell_size, dim)\n        out = []\n        if dim == 2:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    idx = (center[0] + dx, center[1] + dy)\n                    if idx in grid:\n                        out.extend(grid[idx])\n        else:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    for dz in range(-cells, cells + 1):\n                        idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                        if idx in grid:\n                            out.extend(grid[idx])\n        # filter by true distance\n        rr = radius * radius\n        fil = []\n        for n in out:\n            s = 0.0\n            p = n.position\n            for i in range(dim):\n                d = p[i] - point[i]\n                s += d * d\n            if s <= rr:\n                fil.append(n)\n        return fil\n\n    def _exists_close(self, grid, pos, radius, cell_size, dim):\n        neigh = self._neighbors_within_radius(grid, pos, radius, cell_size, dim)\n        return len(neigh) > 0\n\n    # ---- Extend/connect ----\n    def _greedy_extend(self, tree, grid, from_node, target_pos, nodes, edges, obstacles, is_3d, bounds, cell_size, dim):\n        current = from_node\n        last_new = None\n        while True:\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if not self._within_bounds(step_pos, bounds):\n                break\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                break\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d, self.edge_resolution):\n                break\n            new_node = Node(step_pos, current, current.cost + self._distance(current.position, step_pos))\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node.position, new_node, cell_size, dim)\n            last_new = new_node\n            current = new_node\n            if self._distance(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    # ---- Smoothing ----\n    def _compress_visibility(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        last = path[0]\n        i = 1\n        while i < len(path):\n            far = i\n            j = i\n            while j < len(path):\n                if self._is_edge_in_obstacle(last, path[j], obstacles, is_3d, self.edge_resolution):\n                    break\n                far = j\n                j += 1\n            out.append(path[far])\n            last = path[far]\n            i = far + 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, attempts):\n        if len(path) < 3:\n            return list(path)\n        import random\n        pts = list(path)\n        n = len(pts)\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_resolution):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts\n\n    def _rubber_band(self, path, obstacles, is_3d, iters):\n        if len(path) < 3 or iters <= 0:\n            return list(path)\n        pts = list(path)\n        for _ in range(iters):\n            changed = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(len(a)))\n                if self._is_in_obstacle(mid, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(a, mid, obstacles, is_3d, self.edge_resolution):\n                    continue\n                if self._is_edge_in_obstacle(mid, c, obstacles, is_3d, self.edge_resolution):\n                    continue\n                if mid != pts[i]:\n                    pts[i] = mid\n                    changed = True\n            if not changed:\n                break\n        return pts",
            "objective": -37.59775,
            "time_improvement": 66.0,
            "length_improvement": 14.0,
            "smoothness_improvement": 1905.0,
            "node_improvement": 85.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009185576438903808,
                    "num_nodes_avg": 64.4,
                    "path_length_avg": 170.56202690395023,
                    "smoothness_avg": 0.04785735504538155,
                    "success_improvement": 0.0,
                    "time_improvement": 62.768158532802346,
                    "node_improvement": 83.782422563586,
                    "length_improvement": 6.512250325673065,
                    "smoothness_improvement": 649.0715303700621,
                    "objective_score": 25.983155407094852
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027295637130737304,
                    "num_nodes_avg": 154.6,
                    "path_length_avg": 240.5028644826979,
                    "smoothness_avg": 0.12901280114279629,
                    "success_improvement": 0.0,
                    "time_improvement": 83.67989348599582,
                    "node_improvement": 89.61230934623397,
                    "length_improvement": 19.713221344549247,
                    "smoothness_improvement": 3219.5922975687886,
                    "objective_score": 53.02986234037223
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02437562942504883,
                    "num_nodes_avg": 141.5,
                    "path_length_avg": 127.88160399822759,
                    "smoothness_avg": 0.15294445433893913,
                    "success_improvement": 0.0,
                    "time_improvement": 51.70916332215004,
                    "node_improvement": 82.00890019071836,
                    "length_improvement": 15.067127691977475,
                    "smoothness_improvement": 1845.4421700060007,
                    "objective_score": 33.7802364618615
                }
            ],
            "success_rate": 1.0
        },
        "objective": 44.800000000000004,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Heavy edge-collision routines (sampling along segments against many obstacles, sometimes with nested occupancy checks) inflate per-iteration cost.\n   - Progressive step halving and multi-candidate scoring per iteration trigger repeated collision tests and distance/heuristic evaluations.\n   - Strong, repeated bias toward fixed meeting points wastes samples when those directions are blocked.\n   - Coarse or ring-limited grid nearest-neighbor lookups often pick suboptimal anchors, requiring more nodes and checks to make progress.\n   - Greedy connect implemented via many micro-steps adds redundant validations and bookkeeping.\n   - Post-planning smoothing lacks early visibility compression and can consume unnecessary time even on already simple paths."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Obstacle prefiltering for edge checks (segment\u2013AABB gating) with filtered occupancy testing, avoiding nested scans.\n   - Single-step proposal with immediate validation (no progressive halving), plus rejection of near-duplicate nodes via grid-radius throttling.\n   - Balanced sampling (goal/corridor/uniform) that targets a start\u2013goal corridor with moderate goal pull, reducing wasted biased samples.\n   - Local best-parent selection within a bounded neighborhood to commit lower-cost, more direct edges.\n   - Lightweight greedy connect with per-step validation and early short-bridge closure.\n   - Two-stage smoothing (visibility compression \u2192 bounded shortcutting, with a light rubber-band pass) executed only after connection.\n2. Expected mechanism of impact:\n   - Cuts collision-check complexity by limiting tests to obstacles overlapping the segment, shrinking work from broad scans to a small relevant set.\n   - Reduces the number of collision evaluations and distance/score computations per iteration by avoiding beam expansions and progressive halving.\n   - Guides samples into productive regions (corridor) to meet earlier, lowering the total iterations and edges created.\n   - Fewer, more effective nodes (via best-parent choice and duplicate suppression) reduce grid operations and edge validations.\n   - Visibility compression lowers waypoint count before shortcutting, decreasing smoothing checks and overall CPU time.\n   - Combined effect: lower per-iteration cost and fewer iterations to a valid, simplified path, yielding faster planning."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "SAGE-BRRT: Simple Adaptive Grid-Enhanced BiRRT with Local Rewire and On-the-fly Visibility. Two trees grow toward each other using grid-accelerated nearest search and informed/corridor-biased sampling. Each insertion selects the least-cost feasible parent among nearby nodes, performs ancestor visibility compression, and locally rewires neighbors. A probe-then-commit connect adds at most one node on the opposite tree per iteration and bridges if a short direct link is free. Obstacle checks use a spatial hash for fast node and edge validation. On success, a lightweight visibility pass, shortcutting, and elastic smoothing return a short, smooth path quickly.",
                "planning_mechanism": "Initialize bidirectional trees, node-grid, and obstacle-grid. Iterate: sample a target (goal/corridor/informed/uniform), find a near node via grid rings, steer by a fixed step, and validate node (inside-bounds, not in obstacles) and edge (segment-obstacle free). Choose the best feasible parent within a local radius; insert the node, then optionally compress to a visible ancestor and rewire nearby nodes if cheaper. Probe the other tree: try a direct bridge; else simulate one feasible step toward the new node and commit at most one opposite-node; if the short bridge becomes free, assemble the path. Maintain an incumbent path for informed sampling. After connection, run visibility compression, shortcutting, and elastic smoothing, then return the result.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.0,\n        goal_bias=0.18,\n        corridor_bias=0.35,\n        informed_bias=0.55,\n        cell_size_factor=1.6,\n        dupe_radius_ratio=0.45,\n        rewire_radius_factor=2.0,\n        neighbor_cap=24,\n        connect_steps=1,\n        smooth_shortcuts=80,\n        rubber_iters=8\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.cell_size_factor = float(cell_size_factor)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.rewire_radius_factor = float(rewire_radius_factor)\n        self.neighbor_cap = int(neighbor_cap)\n        self.connect_steps = int(connect_steps)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.rubber_iters = int(max(0, rubber_iters))\n\n        self._rnd = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n\n        # Build obstacle spatial hash\n        self._build_obstacle_grid()\n\n        # Validate endpoints\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Setup structures\n        self.cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.rewire_radius = max(self.step_size * 1.25, self.rewire_radius_factor * self.step_size)\n\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        tree_a, tree_b = [a_root], [b_root]\n        grid_a, grid_b = {}, {}\n        anchors_a, anchors_b = [a_root], [b_root]\n        self._grid_insert(grid_a, a_root)\n        self._grid_insert(grid_b, b_root)\n\n        best_path = None\n        best_len = float('inf')\n\n        # Corridor width for biased sampling\n        sg = self._dist(self.start, self.goal)\n        corridor_w = max(self.step_size, 0.2 * sg)\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            tree1 = tree_a if side_a else tree_b\n            grid1 = grid_a if side_a else grid_b\n            anchors1 = anchors_a if side_a else anchors_b\n\n            tree2 = tree_b if side_a else tree_a\n            grid2 = grid_b if side_a else grid_a\n            anchors2 = anchors_b if side_a else anchors_a\n\n            attractor = self.goal if side_a else self.start\n\n            # Sample a target\n            target = self._sample_target(attractor, best_len, corridor_w)\n            if target is None:\n                continue\n\n            # Find near node and steer\n            near = self._nearest_hashed(grid1, anchors1, target, 3)\n            if near is None:\n                continue\n            new_pos = self._steer(near.position, target)\n\n            # Validity checks for node and edge\n            if not self._within_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._has_nearby(grid1, new_pos, self.dupe_radius):\n                continue\n\n            # Select best parent among local candidates\n            parent, new_cost = self._choose_parent(grid1, anchors1, tree1, new_pos)\n            if parent is None:\n                continue\n\n            # Node collision already checked; ensure edge is free\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(grid1, new_node)\n            if (len(tree1) % 24) == 0:\n                anchors1.append(new_node)\n\n            # Optional: compress to visible ancestor (one hop)\n            gp = parent.parent\n            if gp is not None:\n                if self._edge_free(gp.position, new_node.position):\n                    self._reparent(new_node, gp, edges)\n\n            # Local rewiring\n            self._rewire_neighbors(grid1, new_node, self.rewire_radius, edges)\n\n            # Try to connect the other tree\n            other_near = self._nearest_hashed(grid2, anchors2, new_node.position, 3)\n            if other_near is not None:\n                # Direct bridge\n                if self._edge_free(new_node.position, other_near.position):\n                    path = self._assemble_path(new_node, other_near, side_a)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # Probe-then-commit: at most one step on the other tree\n                committed = None\n                steps = 0\n                probe_from = other_near\n                while steps < self.connect_steps:\n                    step_p = self._steer(probe_from.position, new_node.position)\n                    if not self._within_bounds(step_p):\n                        break\n                    if self._point_in_obstacles(step_p):\n                        break\n                    if self._has_nearby(grid2, step_p, self.dupe_radius):\n                        break\n                    if not self._edge_free(probe_from.position, step_p):\n                        break\n                    # Commit this single step\n                    q = Node(step_p, probe_from, probe_from.cost + self._dist(probe_from.position, step_p))\n                    probe_from.add_child(q)\n                    tree2.append(q)\n                    nodes.append(q)\n                    edges.append((probe_from, q))\n                    self._grid_insert(grid2, q)\n                    if (len(tree2) % 24) == 0:\n                        anchors2.append(q)\n                    # Light local optimize\n                    self._compress_one(q, edges)\n                    self._rewire_neighbors(grid2, q, self.rewire_radius, edges)\n                    committed = q\n                    break\n                # If committed, try short bridge\n                if committed is not None:\n                    if self._edge_free(new_node.position, committed.position):\n                        path = self._assemble_path(new_node, committed, side_a)\n                        path = self._postprocess(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n            # Maintain best incumbent (for informed sampling)\n            if best_path is None:\n                # Try a temporary connection via NN if possible (no commit)\n                if other_near is not None:\n                    if self._edge_free(new_node.position, other_near.position):\n                        tmp = self._assemble_path(new_node, other_near, side_a)\n                        L = self._path_len(tmp)\n                        if L < best_len:\n                            best_len = L\n                            best_path = tmp\n\n        if best_path is not None:\n            best_path = self._postprocess(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG utilities\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761\n        self._rnd = (s ^ 0x9E3779B9) & 0xffffffff\n        if self._rnd == 0:\n            self._rnd = 2463534242\n\n    def _rand(self):\n        self._rnd = (1664525 * self._rnd + 1013904223) & 0xffffffff\n        return self._rnd / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Sampling\n    def _sample_target(self, attractor, best_len, corridor_w):\n        for _ in range(24):\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p is not None and not self._point_in_obstacles(p):\n                    return p\n            else:\n                r = self._rand()\n                if r < self.goal_bias:\n                    p = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    t = self._rand()\n                    base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n                    if self.is_3d:\n                        p = (\n                            self._clamp((base[0] + self._rand_range(-corridor_w, corridor_w),\n                                         base[1] + self._rand_range(-corridor_w, corridor_w),\n                                         base[2] + self._rand_range(-corridor_w, corridor_w)))[0],\n                            self._clamp((base[0] + self._rand_range(-corridor_w, corridor_w),\n                                         base[1] + self._rand_range(-corridor_w, corridor_w),\n                                         base[2] + self._rand_range(-corridor_w, corridor_w)))[1],\n                            self._clamp((base[0] + self._rand_range(-corridor_w, corridor_w),\n                                         base[1] + self._rand_range(-corridor_w, corridor_w),\n                                         base[2] + self._rand_range(-corridor_w, corridor_w)))[2]\n                        )\n                        p = (min(max(base[0] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[0]),\n                             min(max(base[1] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[1]),\n                             min(max(base[2] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[2]))\n                    else:\n                        p = (min(max(base[0] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[0]),\n                             min(max(base[1] + self._rand_range(-corridor_w, corridor_w), 0.0), self.bounds[1]))\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._within_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._within_bounds(p):\n                return p\n        return None\n\n    # Node grid\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, anchors, pos, max_rings=3):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # Fallback: scan grid buckets\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_within_radius(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        # Filter and cap\n        out = []\n        rr = radius * radius\n        for n in cand:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_nearby(self, grid, pos, radius):\n        neigh = self._neighbors_within_radius(grid, pos, radius, self.neighbor_cap)\n        return len(neigh) > 0\n\n    # Parent selection\n    def _choose_parent(self, grid, anchors, tree, new_pos):\n        neigh = self._neighbors_within_radius(grid, new_pos, self.rewire_radius, self.neighbor_cap)\n        if not neigh:\n            # include a nearest fallback\n            near = None\n            bestd = 1e100\n            for n in tree:\n                d = self._dist(n.position, new_pos)\n                if d < bestd:\n                    bestd = d\n                    near = n\n            if near is None:\n                return None, None\n            neigh = [near]\n        best_parent = None\n        best_cost = 1e100\n        for p in neigh:\n            d = self._dist(p.position, new_pos)\n            if d > self.step_size + 1e-9:\n                continue\n            if not self._edge_free(p.position, new_pos):\n                continue\n            gc = p.cost + d\n            if gc < best_cost:\n                best_cost = gc\n                best_parent = p\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    # Obstacle spatial hash\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Local optimization helpers\n    def _compress_one(self, node, edges):\n        p = node.parent\n        if p is None or p.parent is None:\n            return\n        gp = p.parent\n        if self._edge_free(gp.position, node.position):\n            self._reparent(node, gp, edges)\n\n    def _rewire_neighbors(self, grid, node, radius, edges):\n        neigh = self._neighbors_within_radius(grid, node.position, radius, self.neighbor_cap)\n        count = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            new_cost = node.cost + d\n            if new_cost + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n                count += 1\n                if count >= self.neighbor_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        old_parent = child.parent\n        if old_parent is new_parent:\n            return\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    stack.append(ch)\n\n    # Path assembly and post-processing\n    def _assemble_path(self, new_node, other_node, side_a):\n        if side_a:\n            pa = new_node.path_from_root()\n            pb = other_node.path_from_root()\n            if pa and pb and pa[0] == pb[-1]:\n                pb = pb[:-1]\n            return pa + pb[::-1]\n        else:\n            pa = new_node.path_from_root()\n            pb = other_node.path_from_root()\n            if pa and pb and pb[0] == pa[-1]:\n                pa = pa[:-1]\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _postprocess(self, path):\n        if len(path) < 3:\n            return path[:]\n        p = self._visibility_compress(path)\n        p = self._shortcut(p, self.smooth_shortcuts)\n        p = self._rubber_band(p, self.rubber_iters)\n        return p\n\n    def _visibility_compress(self, path):\n        out = [path[0]]\n        last = path[0]\n        i = 1\n        while i < len(path):\n            far = i\n            j = i\n            while j < len(path):\n                if self._edge_free(last, path[j]):\n                    far = j\n                    j += 1\n                else:\n                    break\n            out.append(path[far])\n            last = path[far]\n            i = far + 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        best_len = self._path_len(pts)\n        n = len(pts)\n        tries = 0\n        noimp = 0\n        stop = 12\n        while tries < attempts and n >= 3:\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n:\n                tries += 1\n                continue\n            a, b = pts[i], pts[j - 1]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j - 1:]\n                L = self._path_len(new_pts)\n                if L <= best_len + 1e-12:\n                    pts = new_pts\n                    best_len = L\n                    n = len(pts)\n                    noimp = 0\n                else:\n                    noimp += 1\n            else:\n                noimp += 1\n            tries += 1\n            if noimp >= stop:\n                break\n        return pts\n\n    def _rubber_band(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dims))\n                if self._point_in_obstacles(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if mid != pts[i]:\n                        pts[i] = mid\n                        moved = True\n            if not moved:\n                break\n        return pts",
                "objective": -36.91755,
                "time_improvement": 60.0,
                "length_improvement": 12.0,
                "smoothness_improvement": 2316.0,
                "node_improvement": 87.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.016495347023010254,
                        "num_nodes_avg": 71.0,
                        "path_length_avg": 170.6218692301367,
                        "smoothness_avg": 0.05965294648609013,
                        "success_improvement": 0.0,
                        "time_improvement": 33.13950960050793,
                        "node_improvement": 82.12037270209015,
                        "length_improvement": 6.479449798427921,
                        "smoothness_improvement": 833.6981509539397,
                        "objective_score": 17.99801351397883
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03120548725128174,
                        "num_nodes_avg": 138.0,
                        "path_length_avg": 245.4887822432574,
                        "smoothness_avg": 0.18956585497977163,
                        "success_improvement": 0.0,
                        "time_improvement": 81.34218764255085,
                        "node_improvement": 90.72767587180005,
                        "length_improvement": 18.048778484388976,
                        "smoothness_improvement": 4777.665987395928,
                        "objective_score": 59.12025332037828
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.01702072620391846,
                        "num_nodes_avg": 92.0,
                        "path_length_avg": 132.8506469498789,
                        "smoothness_avg": 0.1130542551758292,
                        "success_improvement": 0.0,
                        "time_improvement": 66.28004574080119,
                        "node_improvement": 88.30260648442466,
                        "length_improvement": 11.766925963888978,
                        "smoothness_improvement": 1338.0417810394658,
                        "objective_score": 33.63437820577107
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "BASIL-RRT: Bi-directional Adaptive Simplified Informed Lite with Rewire and Visibility. Two trees grow toward each other with simple grid-accelerated nearest search, duplicate suppression, best-parent selection, visibility jumps to higher ancestors, and light local rewiring. Guided sampling uses corridor and informed-ellipse biases to shorten routes. On connection, deterministic visibility compression, shortcutting, and elastic smoothing yield short, smooth paths efficiently.",
            "planning_mechanism": "Initialize bidirectional trees and spatial hashes. Repeat: sample a biased target (goal/corridor/informed/uniform), pick the nearest via grid, steer by a fixed step, and validate both node and edge. Choose the least-cost feasible parent from nearby nodes, insert, then visibility-jump to a visible ancestor and locally rewire cheaper neighbors. Probe the opposite tree for a direct or short bridge; if connected, assemble the path and postprocess with visibility compression, randomized shortcuts, and elastic smoothing. Maintain an incumbent best path for informed sampling.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.0,\n        goal_bias=0.15,\n        corridor_bias=0.45,\n        informed_bias=0.5,\n        cell_size_factor=1.2,\n        dupe_ratio=0.3,\n        connect_dist_factor=2.5,\n        rewire_mult=2.5,\n        neighbor_cap=32,\n        shortcuts=120,\n        elastic_iters=10\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.cell_size_factor = float(cell_size_factor)\n        self.dupe_ratio = float(dupe_ratio)\n        self.connect_dist_factor = float(connect_dist_factor)\n        self.rewire_mult = float(rewire_mult)\n        self.neighbor_cap = int(neighbor_cap)\n        self.shortcuts = int(max(0, shortcuts))\n        self.elastic_iters = int(max(0, elastic_iters))\n        self._rnd = 2463534242\n\n    # Public entry\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._seed_from_scene()\n        self._build_obstacle_grid()\n\n        # Endpoint validity\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Parameters\n        self.cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_ratio)\n        self.connect_dist = max(self.step_size, self.connect_dist_factor * self.step_size)\n        corridor_w = max(self.step_size, 0.2 * self._dist(self.start, self.goal))\n\n        # Trees and grids\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_insert(Ga, a_root)\n        self._grid_insert(Gb, b_root)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            T = Ta if side_a else Tb\n            G = Ga if side_a else Gb\n            T_opp = Tb if side_a else Ta\n            G_opp = Gb if side_a else Ga\n            attractor = self.goal if side_a else self.start\n\n            # Target sampling\n            target = self._sample_target(attractor, best_len, corridor_w)\n            if target is None:\n                continue\n\n            # Nearest and steer\n            near = self._nearest_grid(G, target)\n            if near is None:\n                continue\n            new_pos = self._steer(near.position, target)\n            if not self._within_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._has_nearby(G, new_pos, self.dupe_radius):\n                continue\n\n            # Best-parent selection with local neighbors\n            parent, new_cost = self._choose_parent(T, G, new_pos)\n            if parent is None:\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            T.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(G, new_node)\n\n            # Visibility jump to a cheaper visible ancestor\n            self._visibility_jump(new_node, edges)\n\n            # Local rewiring (length/cost reduction)\n            self._rewire_neighbors(G, new_node, edges)\n\n            # Try connect to opposite tree\n            other_near = self._nearest_grid(G_opp, new_node.position)\n            if other_near is not None:\n                dno = self._dist(new_node.position, other_near.position)\n                if dno <= self.connect_dist and self._edge_free(new_node.position, other_near.position):\n                    path = self._assemble_path(new_node, other_near, side_a)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # One-step probe from opposite tree\n                step_p = self._steer(other_near.position, new_node.position)\n                if self._within_bounds(step_p) and not self._point_in_obstacles(step_p):\n                    if not self._has_nearby(G_opp, step_p, self.dupe_radius):\n                        if self._edge_free(other_near.position, step_p):\n                            q = Node(step_p, other_near, other_near.cost + self._dist(other_near.position, step_p))\n                            other_near.add_child(q)\n                            T_opp.append(q)\n                            nodes.append(q)\n                            edges.append((other_near, q))\n                            self._grid_insert(G_opp, q)\n                            self._visibility_jump(q, edges)\n                            self._rewire_neighbors(G_opp, q, edges)\n                            if self._edge_free(new_node.position, q.position):\n                                path = self._assemble_path(new_node, q, side_a)\n                                path = self._postprocess(path)\n                                return PlannerResult(True, path, nodes, edges)\n\n            # Maintain incumbent best for informed sampling\n            if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                tmp = self._assemble_path(new_node, other_near, side_a)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._postprocess(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761\n        self._rnd = (s ^ 0x9E3779B9) & 0xffffffff\n        if self._rnd == 0:\n            self._rnd = 2463534242\n\n    def _rand(self):\n        self._rnd = (1664525 * self._rnd + 1013904223) & 0xffffffff\n        return self._rnd / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Sampling\n    def _sample_target(self, attractor, best_len, corridor_w):\n        for _ in range(16):\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p is not None and not self._point_in_obstacles(p):\n                    return p\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            elif r < self.goal_bias + self.corridor_bias:\n                t = self._rand()\n                base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n                if self.dims == 3:\n                    p = (self._rand_range(base[0] - corridor_w, base[0] + corridor_w),\n                         self._rand_range(base[1] - corridor_w, base[1] + corridor_w),\n                         self._rand_range(base[2] - corridor_w, base[2] + corridor_w))\n                else:\n                    p = (self._rand_range(base[0] - corridor_w, base[0] + corridor_w),\n                         self._rand_range(base[1] - corridor_w, base[1] + corridor_w))\n            else:\n                p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            p = self._clamp(p)\n            if not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if self._within_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Node spatial grid\n    def _cell_of(self, pos, cell=None):\n        cs = self.cell_size if cell is None else cell\n        if self.dims == 3:\n            return (int(pos[0] // cs), int(pos[1] // cs), int(pos[2] // cs))\n        return (int(pos[0] // cs), int(pos[1] // cs))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_grid(self, grid, pos):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        # Expand rings up to 3\n        for r in range(0, 4):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback: scan all buckets\n        for b in grid.values():\n            for n in b:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.dims == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _neighbors_within_radius(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        out = []\n        rr = radius * radius\n        for n in cand:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_nearby(self, grid, pos, radius):\n        neigh = self._neighbors_within_radius(grid, pos, radius, self.neighbor_cap)\n        return len(neigh) > 0\n\n    # Parent selection and optimization\n    def _choose_parent(self, tree, grid, new_pos):\n        n = len(tree)\n        # Dynamic radius ~ n^{-1/d}\n        dyn_r = max(self.step_size, self.rewire_mult * self.step_size * (1.0 / (1.0 + n)) ** (1.0 / max(1, self.dims)))\n        neigh = self._neighbors_within_radius(grid, new_pos, dyn_r, self.neighbor_cap)\n        if not neigh:\n            near = None\n            bestd = 1e100\n            for m in tree:\n                d = self._dist(m.position, new_pos)\n                if d < bestd:\n                    bestd = d\n                    near = m\n            neigh = [near] if near is not None else []\n        best_parent = None\n        best_cost = 1e100\n        for p in neigh:\n            d = self._dist(p.position, new_pos)\n            if d > dyn_r + 1e-9:\n                continue\n            if not self._edge_free(p.position, new_pos):\n                continue\n            gc = p.cost + d\n            if gc < best_cost:\n                best_cost = gc\n                best_parent = p\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    def _visibility_jump(self, node, edges):\n        cur_parent = node.parent\n        if cur_parent is None:\n            return\n        best_parent = cur_parent\n        best_cost = node.cost\n        anc = cur_parent.parent\n        while anc is not None:\n            if self._edge_free(anc.position, node.position):\n                c = anc.cost + self._dist(anc.position, node.position)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best_parent = anc\n            anc = anc.parent\n        if best_parent is not cur_parent:\n            self._reparent(node, best_parent, edges)\n\n    def _rewire_neighbors(self, grid, node, edges):\n        # Use same dynamic radius as parent selection from this node's tree size (approx via node.cost order not needed)\n        radius = max(self.step_size, self.rewire_mult * self.step_size * 0.9)\n        neigh = self._neighbors_within_radius(grid, node.position, radius, self.neighbor_cap)\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if node.cost + d + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        if child.parent is new_parent:\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old_parent = child.parent\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is parent and e[1] is child:\n                edges.pop(i)\n                break\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if abs(newc - ch.cost) > 1e-12:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    # Obstacles\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.dims == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.dims == 3:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Path assembly and post-process\n    def _assemble_path(self, u, v, side_a):\n        # u in current tree, v in opposite\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if side_a:\n            # start -> u then v -> goal\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _postprocess(self, path):\n        if len(path) < 2:\n            return path[:]\n        p = self._visibility_compress(path)\n        p = self._shortcut(p, self.shortcuts)\n        p = self._elastic(p, self.elastic_iters)\n        return p\n\n    def _visibility_compress(self, path):\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        while i < len(path):\n            far = i\n            j = i\n            while j < len(path):\n                if self._edge_free(anchor, path[j]):\n                    far = j\n                    j += 1\n                else:\n                    break\n            out.append(path[far])\n            anchor = path[far]\n            i = far + 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        best = self._path_len(pts)\n        n = len(pts)\n        noimp = 0\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n:\n                noimp += 1\n                if noimp > 16:\n                    break\n                continue\n            a, b = pts[i], pts[j - 1]\n            if self._edge_free(a, b):\n                candidate = pts[:i + 1] + pts[j - 1:]\n                L = self._path_len(candidate)\n                if L <= best + 1e-12:\n                    pts = candidate\n                    best = L\n                    n = len(pts)\n                    noimp = 0\n                else:\n                    noimp += 1\n            else:\n                noimp += 1\n            if noimp > 24:\n                break\n        return pts\n\n    def _elastic(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dims))\n                if self._point_in_obstacles(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if mid != pts[i]:\n                        pts[i] = mid\n                        moved = True\n            if not moved:\n                break\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts",
            "objective": -37.60553,
            "time_improvement": 63.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 1737.0,
            "node_improvement": 84.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01027677059173584,
                    "num_nodes_avg": 56.0,
                    "path_length_avg": 152.97087548687767,
                    "smoothness_avg": 0.05880624031240139,
                    "success_improvement": 0.0,
                    "time_improvement": 58.34522786771023,
                    "node_improvement": 85.89775875094435,
                    "length_improvement": 16.154239167002743,
                    "smoothness_improvement": 820.4453606838263,
                    "objective_score": 31.298338663933844
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.048004674911499026,
                    "num_nodes_avg": 233.0,
                    "path_length_avg": 260.1076340388263,
                    "smoothness_avg": 0.1240816945243068,
                    "success_improvement": 0.0,
                    "time_improvement": 71.29792559985403,
                    "node_improvement": 84.34455418934354,
                    "length_improvement": 13.168584974709937,
                    "smoothness_improvement": 3092.7113725425193,
                    "objective_score": 44.754085527494766
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.021122431755065917,
                    "num_nodes_avg": 136.0,
                    "path_length_avg": 118.36585536678952,
                    "smoothness_avg": 0.1098386556019516,
                    "success_improvement": 0.0,
                    "time_improvement": 58.154110224750575,
                    "node_improvement": 82.70820089001907,
                    "length_improvement": 21.38703484172179,
                    "smoothness_improvement": 1297.1395918106139,
                    "objective_score": 36.764151931511314
                }
            ],
            "success_rate": 1.0
        },
        "objective": 36.599999999999994,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Coarse spatial hashing and anchor-based nearest lookups causing frequent linear scans and redundant distance computations.\n   - Unrestricted long-distance bridge attempts triggering expensive collision checks over long segments.\n   - Overly aggressive duplicate suppression leading to many rejected samples and repeated retries.\n   - Limited ancestor compression (single-hop) leaving deep, zig-zag trees that inflate later nearest/rewire/collision workloads.\n   - Fixed local-parent radius tied to step size, reducing chances to pick cheaper nearby parents while still checking many edges.\n   - Heavy per-iteration sampling overhead with many retries and complicated corridor sampling logic.\n   - Broad, fixed rewiring neighborhoods prompting repeated edge evaluations without sufficient payoff."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Finer node-grid (smaller cell size) with simplified nearest search (ring expansion only, no anchor scans).\n   - Distance-gated connection policy (short-range bridge threshold) to avoid long, costly collision checks.\n   - Dynamic, shrinking best-parent radius that limits candidate evaluations as the tree grows.\n   - Multi-ancestor visibility jump that collapses chains early and reduces future NN/rewire/collision work.\n   - Higher corridor-biased sampling and fewer sampling retries per iteration.\n   - Less strict duplicate radius reducing rejection-induced stalls.\n2. Expected mechanism of impact:\n   - Reduced nearest-neighbor overhead via smaller buckets and fewer global fallbacks.\n   - Fewer and shorter edge validation calls by avoiding long bridges and pruning parent candidates adaptively.\n   - Smaller, shallower trees after visibility jumps, lowering the cost of subsequent expansions and rewiring.\n   - More targeted sampling along the start\u2013goal corridor increases useful expansions and lowers the number of iterations to connect.\n   - Lower sample rejection rates translate into more productive iterations and faster convergence."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "IBEX-Lite: Informed Beam-Expand Bi-Tree with on-the-fly visibility compression and lazy bounded connect. It grows two sparse trees from start and goal using a small beam of candidate samples per iteration, selects the best steer via a simple cost+heuristic score, enforces strict node/edge collision checks, suppresses near-duplicates with a spatial hash, and line-of-sight compresses to ancestors to keep chains short. Upon a short-range or lazily-bridged connection, it visibility-prunes and performs bounded shortcut smoothing, enabling early termination with a short, smooth path.",
                "planning_mechanism": "Alternate expansion between start and goal trees. Each iteration: beam-sample around an attractor (goal/start) with goal/informed bias; pick a nearest-based parent and steer once; validate node and edge, insert, and compress to a visible ancestor. Try a direct or short-step lazy connect to the opposite tree. On success, extract, visibility-prune, shortcut, and return. Spatial hashing accelerates nearest checks and duplicate suppression; no rewiring keeps computations light.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=8.0,\n        goal_bias=0.2,\n        informed_bias=0.5,\n        beam_width=4,\n        dupe_radius_ratio=0.5,\n        connect_radius_factor=4.0,\n        connect_steps=4,\n        smoothing_iters=60,\n        no_improve_stop=15,\n        cell_factor=1.0\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.beam_width = int(beam_width)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.connect_radius_factor = float(connect_radius_factor)\n        self.connect_steps = int(connect_steps)\n        self.smoothing_iters = int(smoothing_iters)\n        self.no_improve_stop = int(no_improve_stop)\n        self.cell_factor = float(cell_factor)\n        self._rng = 1234567\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Parameters\n        self.cell_size = max(1.0, self.step_size * self.cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n\n        # Trees and grids\n        nodes = []\n        edges = []\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        nodes.extend([root_a, root_b])\n        tree_a, tree_b = [root_a], [root_b]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, root_a)\n        self._grid_insert(grid_b, root_b)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            tree = tree_a if side_a else tree_b\n            other_tree = tree_b if side_a else tree_a\n            grid = grid_a if side_a else grid_b\n            other_grid = grid_b if side_a else grid_a\n            attractor = self.goal if side_a else self.start\n\n            # Beam sampling and candidate selection\n            best_cand = None\n            best_score = 1e100\n            samples = self._beam_samples(attractor, best_len)\n            for s in samples:\n                near = self._nearest_hashed(grid, tree, s, 4)\n                if near is None:\n                    continue\n                new_pos = self._steer(near.position, s)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if self._has_nearby(grid, new_pos, self.dupe_radius):\n                    continue\n                if not self._edge_free(near.position, new_pos):\n                    continue\n                g = near.cost + self._dist(near.position, new_pos)\n                h = self._dist(new_pos, attractor)\n                score = g + h\n                if score < best_score:\n                    best_score = score\n                    best_cand = (near, new_pos)\n\n            if best_cand is None:\n                continue\n\n            parent, new_pos = best_cand\n            # Validate node and edge before adding\n            if self._point_in_obstacles(new_pos):\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent, parent.cost + self._dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(grid, new_node)\n\n            # On-the-fly visibility compression to up to 3 visible ancestors\n            self._compress_to_ancestors(new_node, edges, 3)\n\n            # Try to connect to the other tree\n            other_near = self._nearest_hashed(other_grid, other_tree, new_node.position, 4)\n            if other_near is not None:\n                if self._dist(other_near.position, new_node.position) <= self.connect_radius and self._edge_free(other_near.position, new_node.position):\n                    path = self._extract_path(new_node, other_near, side_a)\n                    final = self._finalize_path(path)\n                    return PlannerResult(True, final, nodes, edges)\n                ok, joined = self._lazy_connect(new_node, other_tree, other_grid, nodes, edges)\n                if ok:\n                    path = self._extract_path(new_node, joined, side_a)\n                    final = self._finalize_path(path)\n                    return PlannerResult(True, final, nodes, edges)\n\n        if best_path:\n            final = self._finalize_path(best_path)\n            return PlannerResult(True, final, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG utilities\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1103515245 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761\n        if s == 0:\n            s = 1234567\n        self._rng = s & 0x7fffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0x7fffffff\n        return self._rng / float(1 << 31)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and bounds\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= self.step_size:\n            return tuple(b)\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n\n    # Obstacles and collisions\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            px, py, pz = p\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for o in self.obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            for o in self.obstacles:\n                x, y, w, h = o\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Spatial hashing\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, tree, pos, max_rings):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        found = False\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # Sampling\n    def _beam_samples(self, attractor, best_len):\n        out = []\n        for _ in range(self.beam_width * 2):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p and self._in_bounds(p) and not self._point_in_obstacles(p):\n                    out.append(p)\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p) and not self._point_in_obstacles(p):\n                    out.append(p)\n            if len(out) >= self.beam_width:\n                break\n        if not out:\n            # fallback uniform\n            p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n            if self._in_bounds(p) and not self._point_in_obstacles(p):\n                out.append(p)\n        return out\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [half] * self.dim\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dim))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Compression\n    def _compress_to_ancestors(self, node, edges, depth_limit):\n        depth = 0\n        cur = node\n        while depth < depth_limit and cur.parent is not None and cur.parent.parent is not None:\n            gp = cur.parent.parent\n            if self._edge_free(gp.position, cur.position):\n                self._reparent(cur, gp, edges)\n            else:\n                break\n            depth += 1\n\n    def _reparent(self, child, new_parent, edges):\n        old_parent = child.parent\n        if old_parent is new_parent:\n            return\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        edges.append((new_parent, child))\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    stack.append(ch)\n\n    # Lazy connect\n    def _lazy_connect(self, new_node, other_tree, other_grid, nodes, edges):\n        near = self._nearest_hashed(other_grid, other_tree, new_node.position, 4)\n        if near is None:\n            return False, None\n        if self._edge_free(near.position, new_node.position):\n            return True, near\n        p = near\n        steps = 0\n        while steps < self.connect_steps:\n            step_pos = self._steer(p.position, new_node.position)\n            if not self._in_bounds(step_pos):\n                break\n            if self._point_in_obstacles(step_pos):\n                break\n            if not self._edge_free(p.position, step_pos):\n                break\n            if self._has_nearby(other_grid, step_pos, self.dupe_radius):\n                break\n            q = Node(step_pos, p, p.cost + self._dist(p.position, step_pos))\n            p.add_child(q)\n            other_tree.append(q)\n            nodes.append(q)\n            edges.append((p, q))\n            self._grid_insert(other_grid, q)\n            if self._edge_free(q.position, new_node.position):\n                return True, q\n            p = q\n            steps += 1\n        return False, None\n\n    # Paths\n    def _path_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _extract_path(self, a_node, b_node, a_forward=True):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return (pa + pb[::-1]) if a_forward else (pb + pa[::-1])\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # Finalization: prune + shortcut\n    def _finalize_path(self, path):\n        if not path:\n            return []\n        pruned = self._visibility_prune(path)\n        sm = self._shortcut(pruned)\n        return sm\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pts = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pts[-1], path[j]):\n                    pts.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pts.append(path[i + 1])\n                i += 1\n        return pts\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_len = self._path_len(pts)\n        attempts = 0\n        no_imp = 0\n        while attempts < self.smoothing_iters:\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                attempts += 1\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best_len + 1e-12:\n                    pts = new_pts\n                    best_len = L\n                    no_imp = 0\n                else:\n                    no_imp += 1\n            else:\n                no_imp += 1\n            attempts += 1\n            if no_imp >= self.no_improve_stop:\n                break\n        return pts",
                "objective": -33.37732,
                "time_improvement": 62.0,
                "length_improvement": 13.0,
                "smoothness_improvement": 1447.0,
                "node_improvement": 90.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.020781850814819335,
                        "num_nodes_avg": 68.0,
                        "path_length_avg": 170.9976979112377,
                        "smoothness_avg": 0.05181632978932453,
                        "success_improvement": 0.0,
                        "time_improvement": 15.765049686457818,
                        "node_improvement": 82.87584991186098,
                        "length_improvement": 6.2734521429299,
                        "smoothness_improvement": 711.0380821640268,
                        "objective_score": 12.04877660251542
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.02635343074798584,
                        "num_nodes_avg": 100.0,
                        "path_length_avg": 249.8743230654094,
                        "smoothness_avg": 0.09393033531173191,
                        "success_improvement": 0.0,
                        "time_improvement": 84.24324023811695,
                        "node_improvement": 93.28092454478264,
                        "length_improvement": 16.58475872716112,
                        "smoothness_improvement": 2316.8951828567397,
                        "objective_score": 46.808303222015454
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.007054257392883301,
                        "num_nodes_avg": 52.0,
                        "path_length_avg": 128.22672229799147,
                        "smoothness_avg": 0.11108113551878454,
                        "success_improvement": 0.0,
                        "time_improvement": 86.02473045093231,
                        "node_improvement": 93.38842975206612,
                        "length_improvement": 14.837916550041735,
                        "smoothness_improvement": 1312.943844642401,
                        "objective_score": 41.274888288516735
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "SIMPLE-BiRRT-i: a simplified informed bi-directional RRT with spatial hashing and ghost-connect. It grows two trees from start and goal with small-step steering, hashed nearest search, light duplicate suppression, and early termination upon a valid bridge. It maintains coherence (node/edge checks before add), avoids heavy rewiring/compression, and performs greedy visibility pruning followed by bounded shortcut smoothing for shorter, smoother paths.",
            "planning_mechanism": "Alternate expanding start and goal trees. Each iteration: sample uniformly with goal-bias and optionally inside the informed ellipse if a path bound exists; choose a hashed-nearest parent; steer one step; validate node and edge; insert into the active tree. Try to connect to the opposite tree by direct line or a ghost (non-committal) short-step chain; if feasible, commit the chain, extract the bi-tree path, prune by visibility, shortcut, and return.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        goal_bias=0.15,\n        informed_bias=0.5,\n        dupe_radius_ratio=0.35,\n        connect_radius_factor=3.0,\n        connect_steps=6,\n        smoothing_iters=60,\n        cell_factor=1.0\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.connect_radius_factor = float(connect_radius_factor)\n        self.connect_steps = int(connect_steps)\n        self.smoothing_iters = int(smoothing_iters)\n        self.cell_factor = float(cell_factor)\n        self._rng = 1234567\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Direct path early exit\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        self.cell_size = max(1.0, self.step_size * self.cell_factor)\n        self.dupe_radius = max(0.25, self.step_size * self.dupe_radius_ratio)\n        self.connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n\n        # Trees\n        nodes = []\n        edges = []\n\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        nodes.extend([root_a, root_b])\n        edges.extend([])\n\n        tree_a, tree_b = [root_a], [root_b]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, root_a)\n        self._grid_insert(grid_b, root_b)\n\n        best_len = float('inf')  # enables informed sampling when a bound appears\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            tree = tree_a if side_a else tree_b\n            other_tree = tree_b if side_a else tree_a\n            grid = grid_a if side_a else grid_b\n            other_grid = grid_b if side_a else grid_a\n            attractor = self.goal if side_a else self.start\n\n            s = self._sample(attractor, best_len)\n            if s is None:\n                continue\n\n            parent = self._nearest_hashed(grid, tree, s, 2)\n            if parent is None:\n                continue\n\n            new_pos = self._steer(parent.position, s)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n            if self._has_nearby(grid, new_pos, self.dupe_radius):\n                continue\n\n            new_node = Node(new_pos, parent, parent.cost + self._dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(grid, new_node)\n\n            # Try to connect directly to nearest in the opposite tree\n            near_other = self._nearest_hashed(other_grid, other_tree, new_node.position, 2)\n            if near_other is not None:\n                if self._dist(near_other.position, new_node.position) <= self.connect_radius and self._edge_free(near_other.position, new_node.position):\n                    path = self._extract_path(new_node, near_other, side_a)\n                    path = self._finalize_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n                # Ghost-connect: plan a short chain without committing, commit only if bridging succeeds\n                ok, chain_positions, last_pos = self._ghost_connect_positions(near_other.position, new_node.position, other_grid)\n                if ok and self._edge_free(last_pos, new_node.position):\n                    # Commit chain into the opposite tree\n                    prev = near_other\n                    for p in chain_positions:\n                        if self._has_nearby(other_grid, p, self.dupe_radius):\n                            prev = self._nearest_hashed(other_grid, other_tree, p, 1)\n                            if prev is None:\n                                prev = near_other\n                            continue\n                        if self._point_in_obstacles(p):\n                            ok = False\n                            break\n                        if not self._edge_free(prev.position, p):\n                            ok = False\n                            break\n                        q = Node(p, prev, prev.cost + self._dist(prev.position, p))\n                        prev.add_child(q)\n                        other_tree.append(q)\n                        nodes.append(q)\n                        edges.append((prev, q))\n                        self._grid_insert(other_grid, q)\n                        prev = q\n                    if ok and self._edge_free(prev.position, new_node.position):\n                        # We do not add a cross-tree edge; extract bi-tree path\n                        path = self._extract_path(new_node, prev, side_a)\n                        L = self._path_len(path)\n                        if L < best_len:\n                            best_len = L\n                        path = self._finalize_path(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1103515245 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761\n        if s == 0:\n            s = 1234567\n        self._rng = s & 0x7fffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0x7fffffff\n        return self._rng / float(1 << 31)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= self.step_size:\n            return tuple(b)\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n\n    # Obstacles\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            px, py, pz = p\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for o in self.obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            for o in self.obstacles:\n                x, y, z, w, h, d = o\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            for o in self.obstacles:\n                x, y, w, h = o\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Spatial hashing\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, tree, pos, max_rings):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        any_found = False\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n                    any_found = True\n        if any_found:\n            return best\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n            if p and self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        if r < self.goal_bias:\n            p = attractor\n        else:\n            p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n        if self._in_bounds(p) and not self._point_in_obstacles(p):\n            return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [half] * self.dim\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dim))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Ghost connect (non-committal)\n    def _ghost_connect_positions(self, from_pos, to_pos, other_grid):\n        chain = []\n        cur = from_pos\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(cur, to_pos)\n            if not self._in_bounds(nxt):\n                return False, None, None\n            if self._point_in_obstacles(nxt):\n                return False, None, None\n            if not self._edge_free(cur, nxt):\n                return False, None, None\n            if self._has_nearby(other_grid, nxt, self.dupe_radius):\n                return False, None, None\n            chain.append(nxt)\n            cur = nxt\n            if self._dist(cur, to_pos) <= self.step_size or self._edge_free(cur, to_pos):\n                return True, chain, cur\n            steps += 1\n        return False, None, None\n\n    # Paths and smoothing\n    def _path_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _extract_path(self, a_node, b_node, a_forward=True):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return (pa + pb[::-1]) if a_forward else (pb + pa[::-1])\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pruned[-1], path[j]):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_L = self._path_len(pts)\n        for _ in range(self.smoothing_iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best_L + 1e-12:\n                    pts = new_pts\n                    best_L = L\n        return pts\n\n    def _finalize_path(self, path):\n        if not path:\n            return []\n        p = self._visibility_prune(path)\n        p = self._shortcut(p)\n        return p",
            "objective": -40.79252,
            "time_improvement": 68.0,
            "length_improvement": 13.0,
            "smoothness_improvement": 2580.0,
            "node_improvement": 82.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007870960235595702,
                    "num_nodes_avg": 48.0,
                    "path_length_avg": 179.5861954290845,
                    "smoothness_avg": 0.06548709066523807,
                    "success_improvement": 0.0,
                    "time_improvement": 68.09668444484818,
                    "node_improvement": 87.91236464366659,
                    "length_improvement": 1.565960559945877,
                    "smoothness_improvement": 925.0151764044653,
                    "objective_score": 25.993657551444304
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0211273193359375,
                    "num_nodes_avg": 158.0,
                    "path_length_avg": 237.3530114017347,
                    "smoothness_avg": 0.18862965381071545,
                    "success_improvement": 0.0,
                    "time_improvement": 87.36794088130645,
                    "node_improvement": 89.38386078075656,
                    "length_improvement": 20.764732966468724,
                    "smoothness_improvement": 4753.576856997666,
                    "objective_score": 62.437106329261496
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026227736473083497,
                    "num_nodes_avg": 250.0,
                    "path_length_avg": 127.39626037258856,
                    "smoothness_avg": 0.16982997215257256,
                    "success_improvement": 0.0,
                    "time_improvement": 48.039932985286335,
                    "node_improvement": 68.21360457724094,
                    "length_improvement": 15.389469818547017,
                    "smoothness_improvement": 2060.2247102361403,
                    "objective_score": 33.94678533789481
                }
            ],
            "success_rate": 1.0
        },
        "objective": 38.4,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Excessive per-iteration work from evaluating multiple candidate samples with repeated nearest-neighbor, collision, and scoring checks\n   - Expensive in-iteration topology changes (ancestor compression/rewiring) that trigger edge removal and cost propagation\n   - Bridge attempts that eagerly commit nodes to the opposite tree even when the final connection fails, inflating the tree and future queries\n   - Broad neighbor searches and large duplicate-suppression radii leading to frequent rejections and extra grid scans\n   - Inconsistent activation of informed sampling, keeping exploration uninformed for longer in many cases"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Single-sample expansion per iteration with shallower hashed-nearest lookup to cut nearest and collision checks\n   - Removal of on-the-fly reparenting/compression to avoid edge churn and cost propagation\n   - Non-committal (ghost) connect that only inserts the bridge after a successful validation, preventing tree bloat\n   - Tighter duplicate-suppression radius and longer bounded connect steps to increase successful join rates\n2. Expected mechanism of impact:\n   - Fewer distance and collision evaluations per iteration reduce constant factors\n   - Smaller, cleaner trees accelerate subsequent nearest lookups and reduce grid traversals\n   - Higher probability of bridging per attempt lowers total iterations to a solution\n   - Early termination upon a validated bridge yields faster overall planning time"
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "Adaptive Goal-Biased Grid BiRRT (AG-GBiRRT): a simplified, robust bidirectional RRT with commit-only connection, grid-accelerated nearest search, and light post-connection shortcut smoothing. It alternates growing two trees, uses uniform-with-goal-bias sampling, single-step steering with strict node/edge collision checks, and an early straight-line test. Upon any successful bridge between trees, it extracts the path and performs a few inexpensive shortcuts for smoothness, returning quickly without extra rewiring or bloat.",
                "planning_mechanism": "Mechanism: alternate start/goal tree expansion; sample (goal-biased), find nearest via grid, steer one step, validate node and edge, add node and edge, attempt a direct, collision-free bridge to the opposite tree (commit-only); on success, extract [start\u2192\u2026\u2192meetA, meetB\u2192\u2026\u2192goal] and run brief shortcut smoothing; terminate on success or iteration budget.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.0)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                continue\n\n            # Insert node (both node and edge validated)\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Try commit-only direct connection to the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None:\n                if not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, other_near)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        try:\n            return self._lcg_next()\n        except:\n            return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Sampling ----------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ---------- Grid nearest ----------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # ---------- Path ----------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # path_a ends at meet_a; we then go straight to meet_b and up to other root\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            # pick two indices i < j with at least one point between\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
                "objective": -32.96764,
                "time_improvement": 69.0,
                "length_improvement": 11.0,
                "smoothness_improvement": 1142.0,
                "node_improvement": 82.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.01299290657043457,
                        "num_nodes_avg": 78.8,
                        "path_length_avg": 167.86786188508313,
                        "smoothness_avg": 0.03825680999831742,
                        "success_improvement": 0.0,
                        "time_improvement": 49.04501835909778,
                        "node_improvement": 80.15613195668597,
                        "length_improvement": 7.988964864290817,
                        "smoothness_improvement": 498.8021524662562,
                        "objective_score": 22.000895188635106
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.02625594139099121,
                        "num_nodes_avg": 208.9,
                        "path_length_avg": 244.3021244779086,
                        "smoothness_avg": 0.07331771296729457,
                        "success_improvement": 0.0,
                        "time_improvement": 83.61025026480232,
                        "node_improvement": 85.96385137405093,
                        "length_improvement": 18.444919002512343,
                        "smoothness_improvement": 1786.5175632625994,
                        "objective_score": 45.082614297261095
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.01305999755859375,
                        "num_nodes_avg": 163.0,
                        "path_length_avg": 140.27860161008172,
                        "smoothness_avg": 0.09759083301298958,
                        "success_improvement": 0.0,
                        "time_improvement": 73.37500455677744,
                        "node_improvement": 79.27527018436109,
                        "length_improvement": 6.833632159773637,
                        "smoothness_improvement": 1141.348192519241,
                        "objective_score": 31.819421625493614
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m3",
                "algorithm_description": "FLASH-IRRT: Fast Lightweight Adaptive Short-horizon Informed RRT. It focuses growth toward the goal with simple guided sampling and a coarse spatial hash for quick nearest/neighbor queries, uses slab-based obstacle checks with a prebuilt obstacle grid, performs minimal-cost parent selection and tiny local rewiring, and terminates on the first valid goal bridge. A two-stage path simplifier (visibility collapse + bounded shortcutting) refines the result with negligible overhead.",
                "planning_mechanism": "Mechanism: Initialize with start/root, obstacle grid, and coarse node bins. Each iteration: draw a guided sample (goal/corridor/uniform; switch to ellipse after any incumbent), pick a nearby anchor via hashed bins, steer one step, and admit the node only if node- and edge-collision-free and not too close to existing nodes. Choose the cheapest parent among a few nearby anchors; insert and perform capped local rewires. After insertion, attempt a direct bridge to the goal; on success, extract and smooth the path and return.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        goal_bias=0.35,\n        corridor_bias=0.45,\n        ellipse_bias=0.65,\n        cell_factor=1.6,\n        neighbor_radius_factor=2.2,\n        min_sep_ratio=0.45,\n        k_parent=6,\n        k_rewire=5,\n        shortcut_attempts=60\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.ellipse_bias = float(ellipse_bias)\n        self.cell_factor = float(cell_factor)\n        self.neigh_factor = float(neighbor_radius_factor)\n        self.min_sep_ratio = float(min_sep_ratio)\n        self.k_parent = int(max(1, k_parent))\n        self.k_rewire = int(max(0, k_rewire))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self._rng = 246813579\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self._is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed()\n        # Spatial params\n        self.cell = max(1.0, self.step * self.cell_factor)\n        self.min_sep = max(0.5, self.step * self.min_sep_ratio)\n        self.neigh_radius = max(self.step * 1.2, self.step * self.neigh_factor)\n\n        # Build obstacle bin grid\n        self._build_obs_bins()\n\n        # Validate start/goal\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Trivial straight solution\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._smooth(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize tree\n        root = Node(self.start, None, 0.0)\n        nodes.append(root)\n        grid = {}\n        self._grid_add(grid, root)\n\n        best_len = None\n\n        for _ in range(self.max_iter):\n            sp = self._sample(best_len)\n            if sp is None:\n                continue\n\n            near = self._grid_near_anchor(grid, sp)\n            if near is None:\n                near = nodes[-1] if nodes else root\n\n            newp = self._steer(near.position, sp)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(grid, newp, self.min_sep):\n                continue\n            if not self._edge_free(near.position, newp):\n                continue\n\n            # Choose parent among a few close anchors\n            cands = self._neighbors(grid, newp, self.neigh_radius)\n            if not cands:\n                cands = [near]\n            cands = sorted(cands, key=lambda n: self._dist2(n.position, newp))[:self.k_parent]\n            parent = near\n            bestc = near.cost + self._dist(near.position, newp)\n            for nb in cands:\n                gc = nb.cost + self._dist(nb.position, newp)\n                if gc + 1e-12 < bestc and self._edge_free(nb.position, newp):\n                    parent = nb\n                    bestc = gc\n\n            # Final checks before adding node/edge\n            if self._point_in_obstacles(newp) or not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, bestc)\n            parent.add_child(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid, nn)\n\n            if self.k_rewire > 0:\n                self._rewire_lite(nn, grid, edges)\n\n            # Try direct bridge to goal\n            if self._edge_free(nn.position, self.goal):\n                goal_node = Node(self.goal, nn, nn.cost + self._dist(nn.position, self.goal))\n                if not self._point_in_obstacles(goal_node.position) and self._edge_free(nn.position, goal_node.position):\n                    nn.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((nn, goal_node))\n                    path = self._trace(goal_node)\n                    path = self._smooth(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n        # No solution found\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed(self):\n        s = 0xA5A5A5A5\n        for v in self.start + self.goal:\n            s ^= ((int(v * 1315423911) ^ 0x9E3779B1) & 0xffffffff)\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        self._rng = s if s != 0 else 246813579\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= self.step * self.step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = self.step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash for nodes\n    def _cell_key(self, p):\n        if self._is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_near_anchor(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        # Probe small ring only for speed\n        rng = 1\n        if self._is3:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            d2 = self._dist2(n.position, pos)\n                            if d2 < bestd:\n                                bestd = d2\n                                best = n\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        d2 = self._dist2(n.position, pos)\n                        if d2 < bestd:\n                            bestd = d2\n                            best = n\n        if best is not None:\n            return best\n        # Fallback: no local bins populated yet\n        for lst in grid.values():\n            if lst:\n                return lst[0]\n        return None\n\n    def _neighbors(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self._is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        arr = self._neighbors(grid, pos, radius)\n        return len(arr) > 0\n\n    # Obstacles: binning and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self._is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obin.get(key)\n                            if b is None:\n                                self.obin[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obin.get(key)\n                        if b is None:\n                            self.obin[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self._is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        # Collect candidate obstacle bins overlapping the segment AABB\n        if self._is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        # Slab intersection (Liang-Barsky style) for 2D/3D\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Rewiring (bounded)\n    def _rewire_lite(self, new_node, grid, edges):\n        neigh = self._neighbors(grid, new_node.position, self.neigh_radius)\n        if not neigh:\n            return\n        neigh = sorted(neigh, key=lambda n: self._dist2(n.position, new_node.position))[:self.k_rewire]\n        for nb in neigh:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            if self._is_ancestor(nb, new_node):\n                continue\n            if self._point_in_obstacles(nb.position):\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand_cost + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._erase_edge(edges, oldp, nb)\n                new_node.add_child(nb)\n                edges.append((new_node, nb))\n                delta = cand_cost - nb.cost\n                nb.cost = cand_cost\n                self._propagate_cost(nb, delta)\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _erase_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                del edges[i]\n                break\n\n    def _propagate_cost(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    # Sampling\n    def _sample(self, incumbent_len):\n        tries = 18\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            if incumbent_len is not None and r < self.ellipse_bias:\n                p = self._sample_in_ellipse(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    p = self.goal\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_point()\n                else:\n                    if self._is3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.07 * sg)\n        if self._is3:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            oz = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n        else:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(14):\n            if self._is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Paths\n    def _trace(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _vis_collapse(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = pts[:]\n        i = 0\n        while i < len(out) - 2:\n            j = len(out) - 1\n            collapsed = False\n            while j > i + 1:\n                if self._edge_free(out[i], out[j]):\n                    del out[i + 1:j]\n                    collapsed = True\n                    break\n                j -= 1\n            if not collapsed:\n                i += 1\n        return out\n\n    def _shortcut(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        attempts = 0\n        stall = 0\n        while attempts < self.shortcut_attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 1, len(cur) - 1))\n            if j <= i + 1:\n                attempts += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-9 <= bestL:\n                    cur = cand\n                    bestL = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            attempts += 1\n            if stall > 22:\n                break\n        return cur\n\n    def _smooth(self, path):\n        p1 = self._vis_collapse(path)\n        p2 = self._shortcut(p1)\n        return p2",
                "objective": -23.31374,
                "time_improvement": 10.0,
                "length_improvement": 14.0,
                "smoothness_improvement": 2366.0,
                "node_improvement": 82.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.024941086769104004,
                        "num_nodes_avg": 71.0,
                        "path_length_avg": 178.52352920803884,
                        "smoothness_avg": 0.06965954833489985,
                        "success_improvement": 0.0,
                        "time_improvement": -1.093556270891946,
                        "node_improvement": 82.12037270209015,
                        "length_improvement": 2.1484247547248625,
                        "smoothness_improvement": 990.3231995715222,
                        "objective_score": 5.912603969424945
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.10027201175689697,
                        "num_nodes_avg": 183.0,
                        "path_length_avg": 236.67314760851235,
                        "smoothness_avg": 0.19080990248372065,
                        "success_improvement": 0.0,
                        "time_improvement": 40.04719859045708,
                        "node_improvement": 87.70409191695224,
                        "length_improvement": 20.991691069440613,
                        "smoothness_improvement": 4809.676225723734,
                        "objective_score": 48.657555347420164
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.05442237854003906,
                        "num_nodes_avg": 181.0,
                        "path_length_avg": 122.3803596006084,
                        "smoothness_avg": 0.10980596730833918,
                        "success_improvement": 0.0,
                        "time_improvement": -7.816793071052689,
                        "node_improvement": 76.98664971392245,
                        "length_improvement": 18.720792279768308,
                        "smoothness_improvement": 1296.7237991286624,
                        "objective_score": 15.37105644218849
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "AERO-Connect-R*: Adaptive Elliptic Rewired Connect BiRRT with Hash-Grids. It couples bidirectional RRT-Connect growth (greedy multi-step connect) with lightweight RRT* local optimization (best-parent selection and bounded rewiring), uses adaptive informed sampling (goal/corridor \u2192 ellipse after first incumbent), and fast slab-based collision via obstacle bins. A two-stage path refiner (visibility + shortcut + corner-round) improves length and smoothness at negligible cost.",
            "planning_mechanism": "Mechanism: Alternate expanding start/goal trees. Each iteration: draw a guided sample (goal/corridor/uniform; switch to ellipse once a path is known), pick an anchor via multi-ring hash-grid nearest, steer one step, validate node/edge, choose cheapest parent among nearby anchors, insert and locally rewire. Then greedily connect the opposite tree toward the new node with multiple validated steps; on meeting, extract the path and run refinements, then return.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.25,\n                 corridor_bias=0.35,\n                 ellipse_bias=0.55,\n                 grid_cell_factor=1.7,\n                 neighbor_radius_factor=2.4,\n                 min_sep_ratio=0.4,\n                 k_parent=6,\n                 k_rewire=6,\n                 connect_mult=1.8,\n                 smoothing_attempts=120):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.ellipse_bias = float(ellipse_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neigh_factor = float(neighbor_radius_factor)\n        self.min_sep_ratio = float(min_sep_ratio)\n        self.k_parent = int(max(1, k_parent))\n        self.k_rewire = int(max(0, k_rewire))\n        self.connect_mult = float(connect_mult)\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self._is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Spatial parameters\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.neigh_radius = max(self.step * 1.2, self.step * self.neigh_factor)\n        self.min_sep = max(0.5, self.step * self.min_sep_ratio)\n        self.connect_step = max(self.step, self.step * self.connect_mult)\n\n        # Initialize RNG seed\n        self._seed()\n\n        # Build obstacle bins before any collision checks\n        self._build_obs_bins()\n\n        # Validate start/goal\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Trivial straight-line solution\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._smooth_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize two trees and their grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = self.goal if active_start else self.start\n\n            # Guided sampling with informed ellipse once best path exists\n            sp = self._guided_sample(root_other, best_len)\n            if sp is None:\n                continue\n\n            # Nearest anchor in active tree\n            anchor = self._nearest_grid(grid_a, sp)\n            if anchor is None:\n                anchor = tree_a[-1]\n\n            # Steer one step toward sample\n            newp = self._steer(anchor.position, sp, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(grid_a, newp, self.min_sep):\n                continue\n            if not self._edge_free(anchor.position, newp):\n                continue\n\n            # Best-parent selection (local RRT*)\n            neigh = self._neighbors(grid_a, newp, self.neigh_radius)\n            if not neigh:\n                neigh = [anchor]\n            # Sort few closest anchors\n            neigh = sorted(neigh, key=lambda n: self._dist2(n.position, newp))[:self.k_parent]\n            parent = anchor\n            bestc = anchor.cost + self._dist(anchor.position, newp)\n            for nb in neigh:\n                gc = nb.cost + self._dist(nb.position, newp)\n                if gc + 1e-12 < bestc and self._edge_free(nb.position, newp):\n                    parent = nb\n                    bestc = gc\n\n            # Final checks before adding node/edge\n            if self._point_in_obstacles(newp) or (not self._edge_free(parent.position, newp)):\n                continue\n\n            nn = Node(newp, parent, bestc)\n            parent.add_child(nn)\n            tree_a.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid_a, nn)\n\n            # Bounded local rewiring\n            if self.k_rewire > 0:\n                self._rewire_lite(nn, grid_a, edges)\n\n            # Greedy multi-step connect from the opposite tree toward nn\n            other_near = self._nearest_grid(grid_b, nn.position)\n            meet_b = other_near\n            connected = False\n            cur = other_near\n            if cur is not None:\n                while True:\n                    # If we are close and direct edge is free, consider connected\n                    if self._dist(cur.position, nn.position) <= self.connect_step and self._edge_free(cur.position, nn.position):\n                        connected = True\n                        meet_b = cur\n                        break\n                    # Otherwise extend the other tree by a connect step\n                    nxtp = self._steer(cur.position, nn.position, self.connect_step)\n                    if (not self._in_bounds(nxtp)) or self._point_in_obstacles(nxtp):\n                        break\n                    if not self._edge_free(cur.position, nxtp):\n                        break\n                    # Add the node to the opposite tree (both checks already passed)\n                    cn = Node(nxtp, cur, cur.cost + self._dist(cur.position, nxtp))\n                    cur.add_child(cn)\n                    tree_b.append(cn)\n                    nodes.append(cn)\n                    edges.append((cur, cn))\n                    self._grid_add(grid_b, cn)\n                    cur = cn\n                    meet_b = cur\n                    # Loop continues until blocked or within direct reach\n\n            if connected:\n                # Extract full path (do not insert a cross-edge to preserve tree structures)\n                path = self._extract_path(nn, meet_b)\n                L = self._path_len(path)\n                if best_len is None or L + 1e-9 < best_len:\n                    best_len = L\n                path = self._smooth_path(path)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- RNG ----------\n    def _seed(self):\n        s = 0x9E3779B97F4A7C15 & 0xffffffff\n        for v in self.start + self.goal:\n            zv = int(v * 1315423911) & 0xffffffff\n            s ^= ((zv ^ (zv << 13) ^ (zv >> 17)) & 0xffffffff)\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # ---------- Spatial hash for nodes ----------\n    def _cell_key(self, p):\n        if self._is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self._is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            cand.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        cand.extend(lst)\n        return cand\n\n    def _nearest_grid(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self._is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors(grid, pos, radius)) > 0\n\n    # ---------- Obstacles: binning and collision ----------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self._is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obin.get(key)\n                            if b is None:\n                                self.obin[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obin.get(key)\n                        if b is None:\n                            self.obin[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self._is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self._is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # ---------- Rewiring ----------\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _erase_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                del edges[i]\n                break\n\n    def _propagate_cost(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire_lite(self, new_node, grid, edges):\n        neigh = self._neighbors(grid, new_node.position, self.neigh_radius)\n        if not neigh:\n            return\n        neigh = sorted(neigh, key=lambda n: self._dist2(n.position, new_node.position))[:self.k_rewire]\n        for nb in neigh:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            if self._is_ancestor(nb, new_node):\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._erase_edge(edges, oldp, nb)\n                new_node.add_child(nb)\n                edges.append((new_node, nb))\n                delta = cand - nb.cost\n                nb.cost = cand\n                self._propagate_cost(nb, delta)\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, target_root, incumbent_len):\n        tries = 20\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            if incumbent_len is not None and r < self.ellipse_bias:\n                p = self._sample_in_ellipse(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    p = target_root\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_point()\n                else:\n                    if self._is3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.07 * sg)\n        if self._is3:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            oz = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n        else:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(16):\n            if self._is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # ---------- Paths and smoothing ----------\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, meet_a, meet_b):\n        # meet_a is in active tree; meet_b is in the opposite tree\n        path_a = self._trace_to_root(meet_a)\n        # path_b: from meet_b up to its root\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # Concatenate without adding a cross edge to preserve structures\n        return path_a + path_b\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _prune_collinear(self, pts, cos_eps=0.999):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts) - 1):\n            a = out[-1]\n            b = pts[i]\n            c = pts[i + 1]\n            v1 = tuple(b[j] - a[j] for j in range(self.dim))\n            v2 = tuple(c[j] - b[j] for j in range(self.dim))\n            n1 = sum(v1[j] * v1[j] for j in range(self.dim)) ** 0.5\n            n2 = sum(v2[j] * v2[j] for j in range(self.dim)) ** 0.5\n            if n1 < 1e-9 or n2 < 1e-9:\n                continue\n            cosang = sum(v1[j] * v2[j] for j in range(self.dim)) / (n1 * n2)\n            if cosang < cos_eps:\n                out.append(b)\n        out.append(pts[-1])\n        return out\n\n    def _vis_collapse(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = pts[:]\n        i = 0\n        while i < len(out) - 2:\n            j = len(out) - 1\n            collapsed = False\n            while j > i + 1:\n                if self._edge_free(out[i], out[j]):\n                    del out[i + 1:j]\n                    collapsed = True\n                    break\n                j -= 1\n            if not collapsed:\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        stall = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 1, len(cur) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-9 <= bestL:\n                    cur = cand\n                    bestL = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            tries += 1\n            if stall > 24:\n                break\n        return cur\n\n    def _round_corners(self, pts, passes=2):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            i = 1\n            while i < len(cur) - 1:\n                a = cur[i - 1]\n                c = cur[i + 1]\n                # propose midpoint between a and c\n                mid = tuple(0.5 * (a[j] + c[j]) for j in range(self.dim))\n                if self._in_bounds(mid) and (not self._point_in_obstacles(mid)):\n                    if self._edge_free(a, mid) and self._edge_free(mid, c):\n                        cur[i] = mid\n                i += 1\n        return cur\n\n    def _smooth_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._prune_collinear(path)\n        p1 = self._vis_collapse(p0)\n        p2 = self._shortcut(p1, self.smoothing_attempts)\n        p3 = self._round_corners(p2, passes=2)\n        return p3",
            "objective": -37.18079,
            "time_improvement": 73.0,
            "length_improvement": 14.0,
            "smoothness_improvement": 1385.0,
            "node_improvement": 90.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009148359298706055,
                    "num_nodes_avg": 41.0,
                    "path_length_avg": 160.05130696013703,
                    "smoothness_avg": 0.047923416631070685,
                    "success_improvement": 0.0,
                    "time_improvement": 62.919010542245815,
                    "node_improvement": 89.67514479979855,
                    "length_improvement": 12.273342479892806,
                    "smoothness_improvement": 650.1055376411265,
                    "objective_score": 29.490236338815063
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.039803075790405276,
                    "num_nodes_avg": 172.0,
                    "path_length_avg": 240.87765654308606,
                    "smoothness_avg": 0.0896202009366,
                    "success_improvement": 0.0,
                    "time_improvement": 76.20167525773196,
                    "node_improvement": 88.44319021702614,
                    "length_improvement": 19.588104967000366,
                    "smoothness_improvement": 2205.992320920289,
                    "objective_score": 45.64332716212125
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.00955343246459961,
                    "num_nodes_avg": 74.0,
                    "path_length_avg": 136.5410158564313,
                    "smoothness_avg": 0.11001885368701667,
                    "success_improvement": 0.0,
                    "time_improvement": 81.07358629325219,
                    "node_improvement": 90.59122695486332,
                    "length_improvement": 9.315958652640234,
                    "smoothness_improvement": 1299.4316981518023,
                    "objective_score": 36.40880957031881
                }
            ],
            "success_rate": 1.0
        },
        "objective": 42.199999999999996,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Single-step growth with one-shot bridge attempts caused frequent failed connections and extra collision checks\n   - Inefficient exploration in cluttered regions due to heavy or static sampling biases and lack of informed sampling once a path existed\n   - Shallow/coarse spatial hashing for nearest-anchor search led to poor anchors and frequent fallback scans\n   - Costly edge validation from dense point-by-point collision checks and redundant obstacle re-checks\n   - Limited or absent local rewiring/parent optimization produced detours that delayed feasible tree meeting\n   - Use of a single tree or weak bidirectional cooperation slowed convergence to a meeting configuration"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Bidirectional expansion with greedy multi-step connect toward the opposite tree\n   - Fast, bin-based collision queries with slab intersection instead of dense edge discretization\n   - Balanced guided sampling (goal/corridor) with informed-ellipse activation once an incumbent is known\n   - Multi-ring spatial hash nearest search plus minimum-separation pruning to avoid redundant nodes\n   - Lightweight local optimization (best-parent selection and bounded rewiring)\n   - Larger connect stride than local growth step to traverse open space quickly\n2. Expected mechanism of impact:\n   - Fewer failed bridge attempts and fewer iterations to reach a meeting point\n   - Lower per-iteration collision-check cost and reduced redundant validations\n   - Higher proportion of productive samples focused along the start\u2013goal corridor and, when available, inside the informed region\n   - Reduced node crowding and cheaper neighbor lookups, improving anchor quality and extension success\n   - Straighter, lower-cost branches more likely to admit direct line-of-sight connections, accelerating solution discovery"
        }
    },
    {
        "parents": [
            {
                "operator": "m1",
                "algorithm_description": "AURORA-BiRRT*: A*-guided, Unrolled-Rewire, Obstacle-Grid accelerated BiRRT with memoized edges and cell-pair sieve. It couples hashed nearest search, per-cell throttling, duplicate suppression, heuristic parent selection (g+h), bounded rewiring with full cost propagation, multi-step Connect, and quantized edge-collision caching; online LOS compression and cache-aware shortcutting yield smooth, short paths quickly.",
                "planning_mechanism": "Alternate tree growth with k-beam samples. Each beam selects a parent among local candidates minimizing g(parent)+d(parent,qn)+\u03bb\u00b7h(qn,other-tree), enforcing both node and edge validity before insertion. After insertion, LOS-compress to an ancestor, rewire neighbors if cheaper and propagate costs. A limited Connect grows the opposite tree unless a cached blocked cell-pair forbids it; direct edges terminate early. Once an incumbent exists, informed ellipse sampling narrows exploration; final shortcutting and LOS collapse return a concise path.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=9.0,\n        collision_res=1.0,\n        beam_k=2,\n        goal_bias=0.2,\n        informed_bias=0.6,\n        grid_cell_factor=1.2,\n        per_cell_cap=6,\n        dupe_radius_ratio=0.45,\n        rewire_radius_factor=2.5,\n        neighbor_cap=24,\n        compress_depth=2,\n        connect_steps=3,\n        edge_cache_capacity=40000,\n        edge_cache_quant=0.8,\n        smoothing_iters=50,\n        no_improve_stop=12\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_res = collision_res\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.per_cell_cap = per_cell_cap\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.rewire_radius_factor = rewire_radius_factor\n        self.neighbor_cap = neighbor_cap\n        self.compress_depth = compress_depth\n        self.connect_steps = connect_steps\n        self.edge_cache_capacity = edge_cache_capacity\n        self.edge_cache_quant = edge_cache_quant\n        self.smoothing_iters = smoothing_iters\n        self.no_improve_stop = no_improve_stop\n\n        self._rnd_state = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n\n        # Edge cache\n        self._tick = 0\n        self.ecache = {}\n        self._last_prune_size = 0\n        self.eq = max(0.25, self.edge_cache_quant)\n        # Collision stepping resolution for fallback sampling checks\n        self.edge_res = max(0.5, self.collision_res)\n\n        # Build obstacle grid\n        self._build_obstacle_grid()\n\n        # Validate endpoints\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        nodes = []\n        edges = []\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        throttles_a, throttles_b = {}, {}\n        anchors_a, anchors_b = [start_root], [goal_root]\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_path = None\n        best_len = float('inf')\n        sg = self._dist(self.start, self.goal)\n\n        blocked_pairs = set()\n        anchor_stride = 20\n        max_rings = 4\n\n        for it in range(self.max_iter):\n            side_start = (it % 2 == 0)\n            tree1 = tree_a if side_start else tree_b\n            grid1 = grid_a if side_start else grid_b\n            throttles1 = throttles_a if side_start else throttles_b\n            anchors1 = anchors_a if side_start else anchors_b\n\n            tree2 = tree_b if side_start else tree_a\n            grid2 = grid_b if side_start else grid_a\n            throttles2 = throttles_b if side_start else throttles_a\n            anchors2 = anchors_b if side_start else anchors_a\n\n            attractor = self.goal if side_start else self.start\n\n            progressed = False\n            for _ in range(self.beam_k):\n                sample = self._sample(attractor, best_len, sg)\n                if sample is None:\n                    continue\n                near = self._nearest_hashed(grid1, anchors1, sample, max_rings)\n                if near is None:\n                    continue\n                new_pos = self._steer(near.position, sample)\n                if not self._within_bounds(new_pos):\n                    continue\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if self._has_nearby(grid1, new_pos, self.dupe_radius):\n                    continue\n\n                # Parent selection (A*-guided among local candidates)\n                rewire_r = self._rewire_radius(len(nodes))\n                parents = self._candidate_parents(grid1, anchors1, tree1, new_pos, rewire_r, self.neighbor_cap)\n                best_parent, best_new_cost = None, float('inf')\n                best_score = float('inf')\n                other_near = self._nearest_hashed(grid2, anchors2, new_pos, max_rings)\n                h_term = self._dist(new_pos, other_near.position if other_near else attractor)\n                lam = 0.1\n                for p in parents:\n                    if not self._edge_free(p.position, new_pos):\n                        continue\n                    gc = p.cost + self._dist(p.position, new_pos)\n                    f = gc + lam * h_term\n                    if f + 1e-9 < best_score:\n                        best_score = f\n                        best_parent = p\n                        best_new_cost = gc\n                if best_parent is None:\n                    continue\n\n                # Per-cell cap with cost admission\n                ckey = self._cell_of(new_pos)\n                bucket = grid1.get(ckey)\n                if bucket and len(bucket) >= self.per_cell_cap:\n                    best_bucket_cost = min(n.cost for n in bucket)\n                    if best_new_cost >= best_bucket_cost - 1e-9:\n                        continue\n\n                # Final validity before insertion\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if not self._edge_free(best_parent.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos, best_parent, best_new_cost)\n                best_parent.add_child(new_node)\n                tree1.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                self._grid_insert(grid1, new_node)\n                throttles1[ckey] = throttles1.get(ckey, 0) + 1\n                if (len(tree1) % anchor_stride) == 0:\n                    anchors1.append(new_node)\n                progressed = True\n\n                # LOS compression to ancestors\n                self._compress_to_ancestors(new_node, edges, self.compress_depth)\n\n                # Rewiring around new_node\n                self._rewire_neighbors(grid1, new_node, rewire_r, edges)\n\n                # Try connect to the other tree\n                pair_key = self._pair_key(self._cell_of(new_node.position),\n                                          self._cell_of((other_near.position if other_near else attractor)))\n                if pair_key not in blocked_pairs:\n                    connected, path = self._attempt_connect(new_node, tree2, grid2, throttles2, anchors2, nodes, edges)\n                    if connected:\n                        path = self._shortcut(path)\n                        path = self._los_collapse(path)\n                        best_path = path\n                        best_len = self._path_len(path)\n                        return PlannerResult(True, path, nodes, edges)\n                    else:\n                        blocked_pairs.add(pair_key)\n\n            if not progressed:\n                continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= len(self.obstacles) * 2654435761\n        self._rnd_state = (s ^ 0xA5A5A5) & 0xffffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 2463534242\n\n    def _rand(self):\n        self._rnd_state = (1664525 * self._rnd_state + 1013904223) & 0xffffffff\n        return self._rnd_state / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Sampling\n    def _sample(self, attractor, best_len, sg):\n        for _ in range(24):\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p and self._within_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._within_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Node grid (for NN, dupes, neighbors)\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, anchors, pos, max_rings=4):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # fallback scan\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((key[0] + dx, key[1] + dy))\n                    if not bucket:\n                        continue\n                    for n in bucket:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    def _candidate_parents(self, grid, anchors, tree, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        if not cand:\n            cand = anchors[:]\n        if len(cand) > cap:\n            # Reservoir-like random subset\n            out = []\n            take = 0\n            for n in cand:\n                take += 1\n                if len(out) < cap:\n                    out.append(n)\n                else:\n                    j = int(self._rand_range(0, take))\n                    if j < len(out):\n                        out[j] = n\n            cand = out\n        return cand\n\n    # Obstacle spatial grid\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    # Edge checks with cache\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.eq) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.eq) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        if len(self.ecache) - self._last_prune_size > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self.ecache:\n            return\n        cutoff = self._tick - 3000\n        to_del = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            i = 0\n            for k in list(self.ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune_size = len(self.ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Compression and rewiring\n    def _compress_to_ancestors(self, node, edges, depth_limit):\n        depth = 0\n        curp = node.parent\n        while curp is not None and curp.parent is not None and depth < depth_limit:\n            gp = curp.parent\n            if self._edge_free(gp.position, node.position):\n                self._reparent(node, gp, edges)\n                curp = node.parent\n                depth += 1\n            else:\n                break\n\n    def _rewire_radius(self, n_nodes):\n        # simple schedule\n        return max(self.step_size * 1.5, self.rewire_radius_factor * self.step_size)\n\n    def _rewire_neighbors(self, grid, node, radius, edges):\n        key = self._cell_of(node.position)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        neigh = self._grid_ring_nodes(grid, key, r_cells)\n        count = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if d > radius:\n                continue\n            new_cost = node.cost + d\n            if new_cost + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n                count += 1\n                if count >= self.neighbor_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        old_parent = child.parent\n        if old_parent is new_parent:\n            return\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    stack.append(ch)\n\n    # Connect attempt\n    def _attempt_connect(self, new_node, other_tree, other_grid, throttles, anchors, nodes, edges):\n        other_near = self._nearest_hashed(other_grid, anchors, new_node.position, 4)\n        if other_near is None:\n            return False, []\n        # Try direct bridge first\n        if self._edge_free(new_node.position, other_near.position):\n            path = self._extract_path(new_node, other_near)\n            return True, self._ensure_bounds_and_valid(path)\n\n        p = other_near\n        steps = 0\n        last_q = None\n        while steps < self.connect_steps:\n            step_pos = self._steer(p.position, new_node.position)\n            if not self._within_bounds(step_pos):\n                break\n            if self._point_in_obstacles(step_pos):\n                break\n            if self._has_nearby(other_grid, step_pos, self.dupe_radius):\n                break\n            if not self._edge_free(p.position, step_pos):\n                break\n            cell = self._cell_of(step_pos)\n            bucket = other_grid.get(cell)\n            if bucket and len(bucket) >= self.per_cell_cap:\n                best_bucket_cost = min(n.cost for n in bucket)\n                new_c = p.cost + self._dist(p.position, step_pos)\n                if new_c >= best_bucket_cost - 1e-9:\n                    break\n\n            q = Node(step_pos, p, p.cost + self._dist(p.position, step_pos))\n            p.add_child(q)\n            other_tree.append(q)\n            nodes.append(q)\n            edges.append((p, q))\n            self._grid_insert(other_grid, q)\n            throttles[cell] = throttles.get(cell, 0) + 1\n            if (len(other_tree) % 20) == 0:\n                anchors.append(q)\n\n            self._compress_to_ancestors(q, edges, 1)\n            # local light rewiring\n            self._rewire_neighbors(other_grid, q, self._rewire_radius(len(nodes)), edges)\n\n            if self._edge_free(new_node.position, q.position):\n                path = self._extract_path(new_node, q)\n                return True, self._ensure_bounds_and_valid(path)\n\n            p = q\n            last_q = q\n            steps += 1\n        return False, []\n\n    def _pair_key(self, c1, c2):\n        return (c1, c2) if c1 <= c2 else (c2, c1)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return pa + pb[::-1]\n\n    def _ensure_bounds_and_valid(self, path):\n        return [self._clamp(p) for p in path]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # Post smoothing\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_improve = 0\n        best_len = self._path_len(pts)\n        while attempts < self.smoothing_iters:\n            i = int(self._rand_range(0, max(1, len(pts) - 2)))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                attempts += 1\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best_len + 1e-12:\n                    pts = new_pts\n                    best_len = L\n                    no_improve = 0\n                else:\n                    no_improve += 1\n            else:\n                no_improve += 1\n            attempts += 1\n            if no_improve >= self.no_improve_stop:\n                break\n        return pts\n\n    def _los_collapse(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = [path[0]]\n        last = path[0]\n        k = 1\n        while k < len(path) - 1:\n            nxt = path[k + 1]\n            if self._edge_free(last, nxt):\n                k += 1\n                continue\n            pts.append(path[k])\n            last = path[k]\n            k += 1\n        pts.append(path[-1])\n        return pts",
                "objective": -29.84258,
                "time_improvement": 46.0,
                "length_improvement": 12.0,
                "smoothness_improvement": 1759.0,
                "node_improvement": 89.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.013257336616516114,
                        "num_nodes_avg": 49.0,
                        "path_length_avg": 163.59788282479164,
                        "smoothness_avg": 0.10284552152668414,
                        "success_improvement": 0.0,
                        "time_improvement": 48.00798880221262,
                        "node_improvement": 87.6605389070763,
                        "length_improvement": 10.329408049384693,
                        "smoothness_improvement": 1509.7557445171647,
                        "objective_score": 28.148820192880425
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.01610586643218994,
                        "num_nodes_avg": 62.0,
                        "path_length_avg": 241.62656852319907,
                        "smoothness_avg": 0.0921645090196098,
                        "success_improvement": 0.0,
                        "time_improvement": 89.9462328864473,
                        "node_improvement": 95.83417321776524,
                        "length_improvement": 19.338096591802515,
                        "smoothness_improvement": 2271.4592004871693,
                        "objective_score": 49.944023823451545
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.048529839515686034,
                        "num_nodes_avg": 126.0,
                        "path_length_avg": 141.44566627862946,
                        "smoothness_avg": 0.12548275222835503,
                        "success_improvement": 0.0,
                        "time_improvement": 1.0637827328513305,
                        "node_improvement": 83.97965670692943,
                        "length_improvement": 6.058523376571766,
                        "smoothness_improvement": 1496.1313461713685,
                        "objective_score": 11.4349055766553
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "FLASH-Connect: a fast, low-dispersion, edge-cached BiRRT-Connect with hash-grid nearest search, per-cell caps, and one-shot limited connection. It minimizes planning time by deterministic Halton sampling, bounded tree growth without rewiring, immediate bridge attempts, and lightweight post-shortcutting.",
            "planning_mechanism": "Alternate expansion from start and goal trees toward a Halton-guided target. Each step inserts only if both the node and edge are collision-free and not too close to existing nodes. After insertion, attempt a direct bridge to the opposite tree; if blocked, perform at most a couple of connect steps on the other tree, again validating both node and edge per step. An LRU-like edge-collision cache accelerates repeated checks. On success, return immediately after quick line-of-sight collapse and a few shortcut passes.",
            "code": "class Node:\n    def __init__(self, position, parent=None):\n        self.position = tuple(position)\n        self.parent = parent\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=9.0,\n        goal_bias=0.2,\n        grid_cell_factor=1.25,\n        per_cell_cap=8,\n        dupe_radius_ratio=0.5,\n        connect_steps=2,\n        edge_cache_capacity=30000,\n        edge_cache_quant=1.0,\n        smoothing_iters=20\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.per_cell_cap = int(per_cell_cap)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.connect_steps = int(connect_steps)\n        self.edge_cache_capacity = int(edge_cache_capacity)\n        self.edge_cache_quant = float(edge_cache_quant)\n        self.smoothing_iters = int(smoothing_iters)\n        # internal states\n        self._rnd_state = 2463534242\n        self._hidx = 1\n\n    def plan(self, map):\n        # Scene setup\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # seed RNG deterministically from scene\n        self._seed_from_scene()\n\n        # build spatial indices\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self._build_obstacle_grid()\n\n        # quick endpoint checks\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # edge cache\n        self._tick = 0\n        self._ecache = {}\n        self._ecache_last_prune = 0\n\n        # early straight line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None)\n            n1 = Node(self.goal, n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # trees and grids\n        nodes = []\n        edges = []\n\n        root_a = Node(self.start, None)\n        root_b = Node(self.goal, None)\n        nodes.extend([root_a, root_b])\n\n        tree_a = [root_a]\n        tree_b = [root_b]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, root_a)\n        self._grid_insert(grid_b, root_b)\n\n        # main loop\n        for it in range(self.max_iter):\n            grow_from_a = (it % 2 == 0)\n            source_tree = tree_a if grow_from_a else tree_b\n            source_grid = grid_a if grow_from_a else grid_b\n            target_tree = tree_b if grow_from_a else tree_a\n            target_grid = grid_b if grow_from_a else grid_a\n            attractor = self.goal if grow_from_a else self.start\n\n            q_rand = self._sample(attractor)\n            if q_rand is None:\n                continue\n\n            near = self._nearest(source_grid, q_rand)\n            if near is None:\n                continue\n\n            q_new = self._steer_valid(near.position, q_rand)\n            if q_new is None:\n                continue\n            if self._has_nearby(source_grid, q_new, self.dupe_radius):\n                continue\n\n            # per-cell cap\n            ckey = self._cell_of(q_new)\n            bucket = source_grid.get(ckey)\n            if bucket and len(bucket) >= self.per_cell_cap:\n                continue\n\n            # Insertion (both node and edge already validated in _steer_valid)\n            new_node = Node(q_new, near)\n            source_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((near, new_node))\n            self._grid_insert(source_grid, new_node)\n\n            # Try to connect to opposite tree\n            other_near = self._nearest(target_grid, new_node.position)\n            if other_near is not None:\n                # direct bridge\n                if self._edge_free(new_node.position, other_near.position):\n                    path = self._assemble_path(new_node, other_near)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # limited connect steps\n                p = other_near\n                steps = 0\n                while steps < self.connect_steps:\n                    step_pos = self._steer_once(p.position, new_node.position)\n                    if step_pos is None:\n                        break\n                    if self._has_nearby(target_grid, step_pos, self.dupe_radius):\n                        break\n                    cell2 = self._cell_of(step_pos)\n                    buck2 = target_grid.get(cell2)\n                    if buck2 and len(buck2) >= self.per_cell_cap:\n                        break\n                    q2 = Node(step_pos, p)\n                    target_tree.append(q2)\n                    nodes.append(q2)\n                    edges.append((p, q2))\n                    self._grid_insert(target_grid, q2)\n                    if self._edge_free(new_node.position, q2.position):\n                        path = self._assemble_path(new_node, q2)\n                        path = self._postprocess(path)\n                        return PlannerResult(True, path, nodes, edges)\n                    p = q2\n                    steps += 1\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and Halton\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= len(self.obstacles) * 2654435761\n        s ^= int(self.step_size * 1000) & 0xffffffff\n        self._rnd_state = (s ^ 0x9E3779B9) & 0xffffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 2463534242\n        self._hidx = 1\n\n    def _rand(self):\n        self._rnd_state = (1664525 * self._rnd_state + 1013904223) & 0xffffffff\n        return self._rnd_state / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _vdc(self, n, base):\n        v = 0.0\n        denom = 1.0\n        while n > 0:\n            n, r = divmod(n, base)\n            denom *= base\n            v += r / denom\n        return v\n\n    def _halton_point(self, idx):\n        bases = (2, 3, 5)\n        if self.dims == 2:\n            x = self._vdc(idx, bases[0]) * self.bounds[0]\n            y = self._vdc(idx, bases[1]) * self.bounds[1]\n            return (x, y)\n        else:\n            x = self._vdc(idx, bases[0]) * self.bounds[0]\n            y = self._vdc(idx, bases[1]) * self.bounds[1]\n            z = self._vdc(idx, bases[2]) * self.bounds[2]\n            return (x, y, z)\n\n    # Sampling with goal bias and Halton fallback\n    def _sample(self, attractor):\n        for _ in range(24):\n            if self._rand() < self.goal_bias:\n                p = attractor\n            else:\n                # Halton with tiny jitter to avoid grid alignment with obstacles\n                p = self._halton_point(self._hidx)\n                self._hidx += 1\n                jitter = 0.001 * self.cell_size\n                if self.dims == 2:\n                    p = (min(max(p[0] + self._rand_range(-jitter, jitter), 0.0), self.bounds[0]),\n                         min(max(p[1] + self._rand_range(-jitter, jitter), 0.0), self.bounds[1]))\n                else:\n                    p = (min(max(p[0] + self._rand_range(-jitter, jitter), 0.0), self.bounds[0]),\n                         min(max(p[1] + self._rand_range(-jitter, jitter), 0.0), self.bounds[1]),\n                         min(max(p[2] + self._rand_range(-jitter, jitter), 0.0), self.bounds[2]))\n            if self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer_once(self, a, b):\n        # Try to step toward b by at most step_size\n        d = self._dist(a, b)\n        if d < 1e-12:\n            return None\n        r = min(1.0, self.step_size / d)\n        q = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n        if not self._within_bounds(q):\n            return None\n        if self._point_in_obstacles(q):\n            return None\n        if not self._edge_free(a, q):\n            return None\n        return q\n\n    def _steer_valid(self, a, b):\n        # Fast attempt: if target within 1.5*step and edge is free, go there; else single step\n        d = self._dist(a, b)\n        max_jump = 1.5 * self.step_size\n        if d <= max_jump:\n            q = b\n            # clamp to bounds\n            q = tuple(min(max(q[i], 0.0), self.bounds[i]) for i in range(self.dims))\n            if not self._point_in_obstacles(q) and self._edge_free(a, q):\n                return q\n        # try normal step\n        q = self._steer_once(a, b)\n        if q is not None:\n            return q\n        # last attempt: slightly shorter step to sneak around grazing edges\n        if d > 1e-9:\n            r = min(1.0, (0.6 * self.step_size) / d)\n            q2 = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n            if self._within_bounds(q2) and (not self._point_in_obstacles(q2)) and self._edge_free(a, q2):\n                return q2\n        return None\n\n    # Node grid utilities\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_of(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 4):\n            cand = self._grid_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback: scan grid buckets\n        for b in grid.values():\n            for n in b:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # Obstacle grid\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 2.0)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x0, y0, z0 = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= x0 <= x + w and y <= y0 <= y + h and z <= z0 <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            x0, y0 = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= x0 <= x + w and y <= y0 <= y + h:\n                    return True\n            return False\n\n    # Edge collision with cache\n    def _edge_key(self, a, b):\n        q = max(0.25, self.edge_cache_quant)\n        qa = tuple(int(a[i] / q) for i in range(self.dims))\n        qb = tuple(int(b[i] / q) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self._ecache.get(key)\n        if hit is not None:\n            # refresh LRU tick\n            self._tick += 1\n            self._ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self._ecache[key] = (free, self._tick)\n        if len(self._ecache) - self._ecache_last_prune > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self._ecache:\n            return\n        cutoff = self._tick - 4000\n        to_del = []\n        for k, v in self._ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            i = 0\n            for k in list(self._ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self._ecache:\n                del self._ecache[k]\n        self._ecache_last_prune = len(self._ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x0, y0, z0, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x0, y0, z0), (x0 + w, y0 + h, z0 + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x0, y0, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x0, y0), (x0 + w, y0 + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect(self, p0, p1, bmin, bmax):\n        # slab intersection for 2D/3D segment vs AABB\n        tmin = 0.0\n        tmax = 1.0\n        n = self.dims\n        for i in range(n):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Path assembly and postprocess\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return pa + pb[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _los_collapse(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        last = 0\n        k = 1\n        while k < len(path) - 1:\n            if self._edge_free(path[last], path[k + 1]):\n                k += 1\n                continue\n            out.append(path[k])\n            last = k\n            k += 1\n        out.append(path[-1])\n        return out\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best = self._path_len(pts)\n        n = len(pts)\n        iters = min(self.smoothing_iters, max(1, n - 2))\n        for t in range(iters):\n            i = (t % (n - 2))\n            j = min(n - 1, i + 2 + (t % max(1, (n - i - 1))))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best + 1e-12:\n                    pts = new_pts\n                    best = L\n                    n = len(pts)\n        return pts\n\n    def _postprocess(self, path):\n        p = self._los_collapse(path)\n        p = self._shortcut(p)\n        return p",
            "objective": -38.51088,
            "time_improvement": 67.0,
            "length_improvement": 15.0,
            "smoothness_improvement": 1919.0,
            "node_improvement": 85.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01389298439025879,
                    "num_nodes_avg": 79.0,
                    "path_length_avg": 164.28407730787757,
                    "smoothness_avg": 0.04754812951617681,
                    "success_improvement": 0.0,
                    "time_improvement": 43.68765033257988,
                    "node_improvement": 80.10576680936792,
                    "length_improvement": 9.953293979757886,
                    "smoothness_improvement": 644.2314793440236,
                    "objective_score": 22.299428884348814
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.015888690948486328,
                    "num_nodes_avg": 96.0,
                    "path_length_avg": 256.1129773273841,
                    "smoothness_avg": 0.12192815124399099,
                    "success_improvement": 0.0,
                    "time_improvement": 90.5001254447587,
                    "node_improvement": 93.54968756299134,
                    "length_improvement": 14.502116364807549,
                    "smoothness_improvement": 3037.299152805466,
                    "objective_score": 51.03780321633946
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016379070281982423,
                    "num_nodes_avg": 140.0,
                    "path_length_avg": 121.59420940833631,
                    "smoothness_avg": 0.17113765919663135,
                    "success_improvement": 0.0,
                    "time_improvement": 67.55123758529757,
                    "node_improvement": 82.19961856325493,
                    "length_improvement": 19.24291580502608,
                    "smoothness_improvement": 2076.858392913151,
                    "objective_score": 42.195412723170676
                }
            ],
            "success_rate": 1.0
        },
        "objective": 31.799999999999997,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - High per-iteration overhead from local rewiring, cost propagation, and frequent reparenting operations.\n   - Expensive parent selection that evaluates many candidates and repeats collision checks.\n   - Nearest-neighbor lookups that often fall back to wide scans due to sparse hash coverage.\n   - Connect attempts that grow the opposite tree even on failure, inflating future search and checks.\n   - Repeated compression/rewiring during connect steps adding extra edge checks and bookkeeping.\n   - Aggressive post-smoothing with many random shortcut attempts increasing runtime.\n   - Fine-grained edge-cache keys and obstacle grids yielding lower cache hit rates and more AABB tests."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Removal of rewiring/cost management and use of a minimal node structure.\n   - Low-dispersion sampling (Halton) with light jitter to raise useful sample yield.\n   - Fast steering with early larger jumps and a single-step fallback to cut collision queries.\n   - Immediate connect-and-return strategy with fewer connect steps.\n   - Simpler, ring-bounded nearest search and stricter per-cell caps to limit local density.\n   - Coarser edge-cache quantization and larger obstacle grid cells to reduce collision-check load.\n   - Fewer smoothing iterations and deterministic, localized shortcutting.\n2. Expected mechanism of impact:\n   - Lower asymptotic and constant-factor costs per insertion by eliminating rewire scans and cost updates.\n   - Higher probability that each sample produces a valid extension, reducing wasted iterations.\n   - Fewer and shorter collision checks via early-accept steering and improved cache hit rate.\n   - Less growth on failed connections, keeping trees smaller and nearest/edge-checks cheaper.\n   - Reduced NN fallback scans and memory traffic due to localized search and caps.\n   - Shorter postprocessing phase with fewer shortcut attempts."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "BASIL-RRT: Bi-directional Adaptive Simplified Informed Lite with Rewire and Visibility. Two trees grow toward each other with simple grid-accelerated nearest search, duplicate suppression, best-parent selection, visibility jumps to higher ancestors, and light local rewiring. Guided sampling uses corridor and informed-ellipse biases to shorten routes. On connection, deterministic visibility compression, shortcutting, and elastic smoothing yield short, smooth paths efficiently.",
                "planning_mechanism": "Initialize bidirectional trees and spatial hashes. Repeat: sample a biased target (goal/corridor/informed/uniform), pick the nearest via grid, steer by a fixed step, and validate both node and edge. Choose the least-cost feasible parent from nearby nodes, insert, then visibility-jump to a visible ancestor and locally rewire cheaper neighbors. Probe the opposite tree for a direct or short bridge; if connected, assemble the path and postprocess with visibility compression, randomized shortcuts, and elastic smoothing. Maintain an incumbent best path for informed sampling.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.0,\n        goal_bias=0.15,\n        corridor_bias=0.45,\n        informed_bias=0.5,\n        cell_size_factor=1.2,\n        dupe_ratio=0.3,\n        connect_dist_factor=2.5,\n        rewire_mult=2.5,\n        neighbor_cap=32,\n        shortcuts=120,\n        elastic_iters=10\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.cell_size_factor = float(cell_size_factor)\n        self.dupe_ratio = float(dupe_ratio)\n        self.connect_dist_factor = float(connect_dist_factor)\n        self.rewire_mult = float(rewire_mult)\n        self.neighbor_cap = int(neighbor_cap)\n        self.shortcuts = int(max(0, shortcuts))\n        self.elastic_iters = int(max(0, elastic_iters))\n        self._rnd = 2463534242\n\n    # Public entry\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._seed_from_scene()\n        self._build_obstacle_grid()\n\n        # Endpoint validity\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Parameters\n        self.cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_ratio)\n        self.connect_dist = max(self.step_size, self.connect_dist_factor * self.step_size)\n        corridor_w = max(self.step_size, 0.2 * self._dist(self.start, self.goal))\n\n        # Trees and grids\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_insert(Ga, a_root)\n        self._grid_insert(Gb, b_root)\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            T = Ta if side_a else Tb\n            G = Ga if side_a else Gb\n            T_opp = Tb if side_a else Ta\n            G_opp = Gb if side_a else Ga\n            attractor = self.goal if side_a else self.start\n\n            # Target sampling\n            target = self._sample_target(attractor, best_len, corridor_w)\n            if target is None:\n                continue\n\n            # Nearest and steer\n            near = self._nearest_grid(G, target)\n            if near is None:\n                continue\n            new_pos = self._steer(near.position, target)\n            if not self._within_bounds(new_pos):\n                continue\n            if self._point_in_obstacles(new_pos):\n                continue\n            if self._has_nearby(G, new_pos, self.dupe_radius):\n                continue\n\n            # Best-parent selection with local neighbors\n            parent, new_cost = self._choose_parent(T, G, new_pos)\n            if parent is None:\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            T.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(G, new_node)\n\n            # Visibility jump to a cheaper visible ancestor\n            self._visibility_jump(new_node, edges)\n\n            # Local rewiring (length/cost reduction)\n            self._rewire_neighbors(G, new_node, edges)\n\n            # Try connect to opposite tree\n            other_near = self._nearest_grid(G_opp, new_node.position)\n            if other_near is not None:\n                dno = self._dist(new_node.position, other_near.position)\n                if dno <= self.connect_dist and self._edge_free(new_node.position, other_near.position):\n                    path = self._assemble_path(new_node, other_near, side_a)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # One-step probe from opposite tree\n                step_p = self._steer(other_near.position, new_node.position)\n                if self._within_bounds(step_p) and not self._point_in_obstacles(step_p):\n                    if not self._has_nearby(G_opp, step_p, self.dupe_radius):\n                        if self._edge_free(other_near.position, step_p):\n                            q = Node(step_p, other_near, other_near.cost + self._dist(other_near.position, step_p))\n                            other_near.add_child(q)\n                            T_opp.append(q)\n                            nodes.append(q)\n                            edges.append((other_near, q))\n                            self._grid_insert(G_opp, q)\n                            self._visibility_jump(q, edges)\n                            self._rewire_neighbors(G_opp, q, edges)\n                            if self._edge_free(new_node.position, q.position):\n                                path = self._assemble_path(new_node, q, side_a)\n                                path = self._postprocess(path)\n                                return PlannerResult(True, path, nodes, edges)\n\n            # Maintain incumbent best for informed sampling\n            if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                tmp = self._assemble_path(new_node, other_near, side_a)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._postprocess(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761\n        self._rnd = (s ^ 0x9E3779B9) & 0xffffffff\n        if self._rnd == 0:\n            self._rnd = 2463534242\n\n    def _rand(self):\n        self._rnd = (1664525 * self._rnd + 1013904223) & 0xffffffff\n        return self._rnd / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Sampling\n    def _sample_target(self, attractor, best_len, corridor_w):\n        for _ in range(16):\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p is not None and not self._point_in_obstacles(p):\n                    return p\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            elif r < self.goal_bias + self.corridor_bias:\n                t = self._rand()\n                base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n                if self.dims == 3:\n                    p = (self._rand_range(base[0] - corridor_w, base[0] + corridor_w),\n                         self._rand_range(base[1] - corridor_w, base[1] + corridor_w),\n                         self._rand_range(base[2] - corridor_w, base[2] + corridor_w))\n                else:\n                    p = (self._rand_range(base[0] - corridor_w, base[0] + corridor_w),\n                         self._rand_range(base[1] - corridor_w, base[1] + corridor_w))\n            else:\n                p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            p = self._clamp(p)\n            if not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if self._within_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Node spatial grid\n    def _cell_of(self, pos, cell=None):\n        cs = self.cell_size if cell is None else cell\n        if self.dims == 3:\n            return (int(pos[0] // cs), int(pos[1] // cs), int(pos[2] // cs))\n        return (int(pos[0] // cs), int(pos[1] // cs))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_grid(self, grid, pos):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        # Expand rings up to 3\n        for r in range(0, 4):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback: scan all buckets\n        for b in grid.values():\n            for n in b:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.dims == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _neighbors_within_radius(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        out = []\n        rr = radius * radius\n        for n in cand:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_nearby(self, grid, pos, radius):\n        neigh = self._neighbors_within_radius(grid, pos, radius, self.neighbor_cap)\n        return len(neigh) > 0\n\n    # Parent selection and optimization\n    def _choose_parent(self, tree, grid, new_pos):\n        n = len(tree)\n        # Dynamic radius ~ n^{-1/d}\n        dyn_r = max(self.step_size, self.rewire_mult * self.step_size * (1.0 / (1.0 + n)) ** (1.0 / max(1, self.dims)))\n        neigh = self._neighbors_within_radius(grid, new_pos, dyn_r, self.neighbor_cap)\n        if not neigh:\n            near = None\n            bestd = 1e100\n            for m in tree:\n                d = self._dist(m.position, new_pos)\n                if d < bestd:\n                    bestd = d\n                    near = m\n            neigh = [near] if near is not None else []\n        best_parent = None\n        best_cost = 1e100\n        for p in neigh:\n            d = self._dist(p.position, new_pos)\n            if d > dyn_r + 1e-9:\n                continue\n            if not self._edge_free(p.position, new_pos):\n                continue\n            gc = p.cost + d\n            if gc < best_cost:\n                best_cost = gc\n                best_parent = p\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    def _visibility_jump(self, node, edges):\n        cur_parent = node.parent\n        if cur_parent is None:\n            return\n        best_parent = cur_parent\n        best_cost = node.cost\n        anc = cur_parent.parent\n        while anc is not None:\n            if self._edge_free(anc.position, node.position):\n                c = anc.cost + self._dist(anc.position, node.position)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best_parent = anc\n            anc = anc.parent\n        if best_parent is not cur_parent:\n            self._reparent(node, best_parent, edges)\n\n    def _rewire_neighbors(self, grid, node, edges):\n        # Use same dynamic radius as parent selection from this node's tree size (approx via node.cost order not needed)\n        radius = max(self.step_size, self.rewire_mult * self.step_size * 0.9)\n        neigh = self._neighbors_within_radius(grid, node.position, radius, self.neighbor_cap)\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if node.cost + d + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        if child.parent is new_parent:\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old_parent = child.parent\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is parent and e[1] is child:\n                edges.pop(i)\n                break\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if abs(newc - ch.cost) > 1e-12:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    # Obstacles\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.dims == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.dims == 3:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Path assembly and post-process\n    def _assemble_path(self, u, v, side_a):\n        # u in current tree, v in opposite\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if side_a:\n            # start -> u then v -> goal\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _postprocess(self, path):\n        if len(path) < 2:\n            return path[:]\n        p = self._visibility_compress(path)\n        p = self._shortcut(p, self.shortcuts)\n        p = self._elastic(p, self.elastic_iters)\n        return p\n\n    def _visibility_compress(self, path):\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        while i < len(path):\n            far = i\n            j = i\n            while j < len(path):\n                if self._edge_free(anchor, path[j]):\n                    far = j\n                    j += 1\n                else:\n                    break\n            out.append(path[far])\n            anchor = path[far]\n            i = far + 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        best = self._path_len(pts)\n        n = len(pts)\n        noimp = 0\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n:\n                noimp += 1\n                if noimp > 16:\n                    break\n                continue\n            a, b = pts[i], pts[j - 1]\n            if self._edge_free(a, b):\n                candidate = pts[:i + 1] + pts[j - 1:]\n                L = self._path_len(candidate)\n                if L <= best + 1e-12:\n                    pts = candidate\n                    best = L\n                    n = len(pts)\n                    noimp = 0\n                else:\n                    noimp += 1\n            else:\n                noimp += 1\n            if noimp > 24:\n                break\n        return pts\n\n    def _elastic(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dims))\n                if self._point_in_obstacles(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if mid != pts[i]:\n                        pts[i] = mid\n                        moved = True\n            if not moved:\n                break\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts",
                "objective": -37.60553,
                "time_improvement": 63.0,
                "length_improvement": 17.0,
                "smoothness_improvement": 1737.0,
                "node_improvement": 84.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.01027677059173584,
                        "num_nodes_avg": 56.0,
                        "path_length_avg": 152.97087548687767,
                        "smoothness_avg": 0.05880624031240139,
                        "success_improvement": 0.0,
                        "time_improvement": 58.34522786771023,
                        "node_improvement": 85.89775875094435,
                        "length_improvement": 16.154239167002743,
                        "smoothness_improvement": 820.4453606838263,
                        "objective_score": 31.298338663933844
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.048004674911499026,
                        "num_nodes_avg": 233.0,
                        "path_length_avg": 260.1076340388263,
                        "smoothness_avg": 0.1240816945243068,
                        "success_improvement": 0.0,
                        "time_improvement": 71.29792559985403,
                        "node_improvement": 84.34455418934354,
                        "length_improvement": 13.168584974709937,
                        "smoothness_improvement": 3092.7113725425193,
                        "objective_score": 44.754085527494766
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.021122431755065917,
                        "num_nodes_avg": 136.0,
                        "path_length_avg": 118.36585536678952,
                        "smoothness_avg": 0.1098386556019516,
                        "success_improvement": 0.0,
                        "time_improvement": 58.154110224750575,
                        "node_improvement": 82.70820089001907,
                        "length_improvement": 21.38703484172179,
                        "smoothness_improvement": 1297.1395918106139,
                        "objective_score": 36.764151931511314
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "cross_over",
                "algorithm_description": "ARC-BiRRT: Adaptive Reuse-Cached, Ring-Hashed, Cost-Gated BiRRT-Connect. It accelerates bidirectional planning with exact edge-collision memoization, ring-hash nearest search, local LOS parent selection, per-cell cost-gated admission, and single-shot tree bridging; upon success it applies cache-reused visibility pruning and bounded shortcut smoothing for shorter, smoother paths.",
                "planning_mechanism": "Alternate expanding start/goal trees with small-beam guided sampling (goal/corridor bias); find a near node via ring-hash, steer one step, enforce node+edge checks and near-duplicate rejection; pick a best-cost parent among nearby ring neighbors that see the new point; admit only if per-cell capacity or cost improves; after insertion, attempt a direct LOS bridge to the opposite tree; on success, extract and cache-prune/shortcut the path and stop early.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.5,\n        beam_width=2,\n        goal_bias=0.3,\n        grid_cell_factor=1.6,\n        ring_max=3,\n        max_per_cell=6,\n        min_sep_factor=0.5,\n        los_neighbor_rings=1,\n        smoothing_iters=50,\n        corridor_bias=0.5\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.ring_max = ring_max\n        self.max_per_cell = max_per_cell\n        self.min_sep_factor = min_sep_factor\n        self.los_neighbor_rings = los_neighbor_rings\n        self.smoothing_iters = smoothing_iters\n        self.corridor_bias = corridor_bias\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # RNG state\n        self._lcg_state = 2463534242\n\n        # Caches\n        self._edge_cache = {}  # exact endpoints (ordered) -> bool blocked\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Derived params\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.3, self.step_size * self.min_sep_factor)\n        self.edge_res = max(0.5, min(1.0, self.step_size * 0.5))\n\n        # Reset caches\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            path = self._visibility_prune(path, obstacles, is_3d)\n            path = self._shortcut_smooth(path, obstacles, is_3d, iters=min(10, self.smoothing_iters))\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        bestcost_start = {}\n        bestcost_goal = {}\n\n        self._grid_add(grid_start, counts_start, bestcost_start, start_root)\n        self._grid_add(grid_goal, counts_goal, bestcost_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n\n            tree_a = start_tree if active_start else goal_tree\n            grid_a = grid_start if active_start else grid_goal\n            counts_a = counts_start if active_start else counts_goal\n            bestcost_a = bestcost_start if active_start else bestcost_goal\n\n            tree_b = goal_tree if active_start else start_tree\n            grid_b = grid_goal if active_start else grid_start\n            counts_b = counts_goal if active_start else counts_start\n            bestcost_b = bestcost_goal if active_start else bestcost_start\n\n            attractor = goal if active_start else start\n\n            for _ in range(self.beam_width):\n                x_rand = self._guided_sample(obstacles, is_3d, attractor)\n\n                nearest = self._nearest_hashed(grid_a, tree_a, x_rand)\n                if nearest is None:\n                    continue\n\n                new_pos = self._steer(nearest.position, x_rand)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                if self._near_duplicate(grid_a, new_pos, self.min_sep):\n                    continue\n\n                # Choose a parent among local neighbors with LOS (limited rings) for better path cost\n                parent = self._choose_parent_local(grid_a, new_pos, nearest, obstacles, is_3d)\n                if self._edge_blocked(parent.position, new_pos, obstacles, is_3d):\n                    continue  # safety\n\n                new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n                # Per-cell cost-gated admission\n                key_new = self._grid_key(new_pos)\n                ccount = counts_a.get(key_new, 0)\n                bestc = bestcost_a.get(key_new, float('inf'))\n                if ccount >= self.max_per_cell and not (new_cost + 1e-9 < bestc):\n                    continue\n\n                # Insert node\n                new_node = Node(new_pos, parent=parent, cost=new_cost)\n                parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((parent, new_node))\n                self._grid_add(grid_a, counts_a, bestcost_a, new_node)\n\n                # Try single-shot direct bridge to the other tree\n                other_near = self._nearest_hashed(grid_b, tree_b, new_node.position)\n                if other_near is not None:\n                    if not self._edge_blocked(new_node.position, other_near.position, obstacles, is_3d):\n                        path = self._extract_path(new_node, other_near, a_is_start_tree=active_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-9:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision and caching\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        if k in self._edge_cache:\n            return self._edge_cache[k]\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _guided_sample(self, obstacles, is_3d, attractor):\n        # Goal-biased with optional corridor pull (activated only after success; here kept generic)\n        if self._rand() < self.goal_bias:\n            p = attractor\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Mild blend toward attractor\n        alpha = 0.2\n        if self.dim == 3:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]),\n                   self._uniform(0.0, self.bounds[2]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(3))\n        else:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(2))\n        if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    # Grid / NN\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n        bc = bestcost.get(k)\n        if bc is None or node.cost < bc:\n            bestcost[k] = node.cost\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.ring_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback to limited random subset to avoid O(N)\n        if not tree:\n            return None\n        trials = min(64, len(tree))\n        for _ in range(trials):\n            idx = int(self._uniform(0, len(tree)))\n            n = tree[idx]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r = 1\n        cand = self._grid_ring_collect(grid, key, r)\n        rr = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # Parent selection among local neighbors with LOS\n    def _choose_parent_local(self, grid, new_pos, fallback_nearest, obstacles, is_3d):\n        key = self._grid_key(new_pos)\n        best_parent = fallback_nearest\n        best_cost = fallback_nearest.cost + self._dist(fallback_nearest.position, new_pos)\n        max_r = max(1, self.los_neighbor_rings)\n        for r in range(0, max_r + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            for n in cand:\n                if n is fallback_nearest or n is best_parent:\n                    pass\n                # Check LOS\n                if not self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                    c = n.cost + self._dist(n.position, new_pos)\n                    if c + 1e-9 < best_cost:\n                        best_cost = c\n                        best_parent = n\n        return best_parent\n\n    # Path\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
                "objective": -33.74569,
                "time_improvement": 58.0,
                "length_improvement": 18.0,
                "smoothness_improvement": 1051.0,
                "node_improvement": 90.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.010497808456420898,
                        "num_nodes_avg": 34.0,
                        "path_length_avg": 154.57051194099205,
                        "smoothness_avg": 0.03958955729868922,
                        "success_improvement": 0.0,
                        "time_improvement": 58.830179046785545,
                        "node_improvement": 91.4379249559305,
                        "length_improvement": 15.277453078640955,
                        "smoothness_improvement": 519.6625418241595,
                        "objective_score": 29.41383827034103
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.049208974838256835,
                        "num_nodes_avg": 116.0,
                        "path_length_avg": 236.11546529476226,
                        "smoothness_avg": 0.06943512420354042,
                        "success_improvement": 0.0,
                        "time_improvement": 69.28227518814471,
                        "node_improvement": 92.20587247194786,
                        "length_improvement": 21.177861477765767,
                        "smoothness_improvement": 1686.6157578555544,
                        "objective_score": 41.92447823238064
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.026494455337524415,
                        "num_nodes_avg": 117.0,
                        "path_length_avg": 122.03531483713664,
                        "smoothness_avg": 0.08227711903121854,
                        "success_improvement": 0.0,
                        "time_improvement": 45.98660915000911,
                        "node_improvement": 85.12396694214877,
                        "length_improvement": 18.94995458240024,
                        "smoothness_improvement": 946.5588810119002,
                        "objective_score": 29.898749899502377
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e1",
            "algorithm_description": "AURORA-BiRRT*: Adaptive Unified Rewire-Optimized Receding-Envelope BiRRT with Curvature-Aware Smoothing. It grows two trees with adaptive step sizing in clutter, dynamic-radius best-parent selection, bounded rewiring, and multi-step micro-bridging. Sampling blends goal, corridor, and informed prolate-ellipse regions using an incumbent path. A voxelized obstacle index accelerates exact slab-based segment-AABB checks. On connection, visibility compression, probabilistic shortcuts, and an angle-aware elastic smoother produce shorter, smoother paths quickly and robustly.",
            "planning_mechanism": "Alternate expanding start/goal trees. Each iteration: biased target sampling (goal/corridor/informed/uniform), ring-hash nearest, adaptive steer with local clutter feedback, and strict node+edge collision checks. Select a least-cost parent from radius-limited neighbors, insert, then leap to a visible ancestor and rewire a few cheaper neighbors. Attempt direct or multi-step micro-bridge to the opposite tree. Maintain an incumbent best length to focus informed sampling. On success, assemble and postprocess the path (visibility prune, bounded shortcuts, curvature-aware elastic smoothing) and return.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        pts = []\n        cur = self\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=7.0,\n        goal_bias=0.2,\n        corridor_bias=0.4,\n        informed_bias=0.5,\n        grid_cell_factor=1.25,\n        dupe_radius_factor=0.35,\n        connect_factor=2.75,\n        rewire_radius_mult=2.0,\n        neighbor_cap=48,\n        bridge_trials=2,\n        rewire_cap=8,\n        shortcut_trials=120,\n        smooth_iters=18\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dupe_radius_factor = float(dupe_radius_factor)\n        self.connect_factor = float(connect_factor)\n        self.rewire_radius_mult = float(rewire_radius_mult)\n        self.neighbor_cap = int(neighbor_cap)\n        self.bridge_trials = int(max(0, bridge_trials))\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.shortcut_trials = int(max(0, shortcut_trials))\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        # Validate endpoints\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_rng()\n        self._build_obs_index()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if self._segment_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Derived params\n        self.cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_r = max(0.5, self.step_size * self.dupe_radius_factor)\n        self.connect_dist = max(self.step_size, self.connect_factor * self.step_size)\n        self.corridor_w = max(self.step_size, 0.2 * self._dist(self.start, self.goal))\n\n        # Trees and grids\n        nodes = []\n        edges = []\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_put(Ga, a_root)\n        self._grid_put(Gb, b_root)\n\n        best_len = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            grow_a = (it % 2 == 0)\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n\n            target = self._sample_target(attractor, best_len)\n            if target is None:\n                continue\n\n            near = self._nearest(G, target, T)\n            if near is None:\n                continue\n\n            new_pos = self._steer_adaptive(near.position, target)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._point_blocked(new_pos):\n                continue\n            if self._has_duplicate(G, new_pos, self.dupe_r):\n                continue\n\n            parent, new_cost = self._choose_parent(G, T, new_pos)\n            if parent is None:\n                continue\n            if self._point_blocked(new_pos) or not self._segment_free(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            T.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_put(G, new_node)\n\n            # Ancestor visibility leap\n            self._ancestor_leap(new_node, edges)\n\n            # Local bounded rewiring\n            self._rewire_local(G, new_node, edges)\n\n            # Try to connect to the opposite tree\n            other = self._nearest(Gopp, new_node.position, Topp)\n            connected = False\n            end_node = None\n            if other is not None:\n                if self._dist(new_node.position, other.position) <= self.connect_dist and self._segment_free(new_node.position, other.position):\n                    connected = True\n                    end_node = other\n                else:\n                    # Micro-bridge steps from the opposite tree\n                    head = other\n                    for _ in range(self.bridge_trials):\n                        step_p = self._steer_adaptive(head.position, new_node.position)\n                        if not self._in_bounds(step_p) or self._point_blocked(step_p):\n                            break\n                        if self._has_duplicate(Gopp, step_p, self.dupe_r):\n                            break\n                        if not self._segment_free(head.position, step_p):\n                            break\n                        q = Node(step_p, head, head.cost + self._dist(head.position, step_p))\n                        head.add_child(q)\n                        Topp.append(q)\n                        nodes.append(q)\n                        edges.append((head, q))\n                        self._grid_put(Gopp, q)\n                        self._ancestor_leap(q, edges)\n                        self._rewire_local(Gopp, q, edges)\n                        head = q\n                        if self._segment_free(new_node.position, head.position):\n                            connected = True\n                            end_node = head\n                            break\n\n            if connected and end_node is not None:\n                path = self._assemble(new_node, end_node, grow_a)\n                path = self._postprocess(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Maintain incumbent for informed sampling\n            if other is not None and self._segment_free(new_node.position, other.position):\n                tmp = self._assemble(new_node, other, grow_a)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._postprocess(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s = (s * 2654435761 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 13) * 1103515245\n        self._rng = s if s != 0 else 2463534242\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and bounds\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer_adaptive(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        # Base step\n        step = self.step_size if d > self.step_size else d\n        # Estimate local clutter by obstacle index buckets overlapped by tentative step box\n        dirv = tuple((b[i] - a[i]) / d for i in range(self.dims))\n        trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n        clutter = self._box_bucket_density(a, trial)\n        if clutter > 10 and step > 0.5 * self.step_size:\n            step *= 0.6\n            trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n            clutter = self._box_bucket_density(a, trial)\n            if clutter > 14 and step > 0.3 * self.step_size:\n                step *= 0.6\n                trial = tuple(a[i] + dirv[i] * step for i in range(self.dims))\n        return self._clamp(trial)\n\n    # Sampling\n    def _sample_target(self, attractor, best_len):\n        for _ in range(16):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._sample_informed(best_len * 1.02)\n                if p is not None and not self._point_blocked(p):\n                    return p\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            elif r < self.goal_bias + self.corridor_bias:\n                t = self._rand()\n                base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n                if self.dims == 3:\n                    p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                         self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w),\n                         self._rand_range(base[2] - self.corridor_w, base[2] + self.corridor_w))\n                else:\n                    p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                         self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w))\n            else:\n                if self.dims == 3:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            p = self._clamp(p)\n            if not self._point_blocked(p):\n                return p\n        return None\n\n    def _sample_informed(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        # Axis-aligned rejection in prolate envelope\n        for _ in range(24):\n            if self.dims == 3:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half),\n                     self._rand_range(c[2] - half, c[2] + half))\n            else:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half))\n            if self._in_bounds(p) and (self._dist(p, self.start) + self._dist(p, self.goal)) <= max_sum:\n                return p\n        return None\n\n    # Node grid\n    def _cell_of(self, pos):\n        return tuple(int(pos[i] // self.cell) for i in range(self.dims))\n\n    def _grid_put(self, grid, node):\n        k = self._cell_of(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_nodes(self, grid, key, r):\n        out = []\n        if self.dims == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos, tree):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        for r in range(0, 4):\n            cand = self._ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback limited scan\n        if not tree:\n            return None\n        step = max(1, len(tree) // 64)\n        for i in range(0, len(tree), step):\n            n = tree[i]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap):\n        key = self._cell_of(pos)\n        r = max(1, int(radius // self.cell) + 1)\n        cand = self._ring_nodes(grid, key, r)\n        out = []\n        rr = radius * radius\n        for n in cand:\n            s = 0.0\n            p = n.position\n            for i in range(self.dims):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _has_duplicate(self, grid, pos, radius):\n        return len(self._neighbors(grid, pos, radius, self.neighbor_cap)) > 0\n\n    # Parent selection and optimization\n    def _choose_parent(self, grid, tree, new_pos):\n        n = max(1, len(tree))\n        # RRT* radius ~ (log(n)/n)^{1/d} scaled\n        base = (self.rewire_radius_mult * self.step_size)\n        dyn_r = max(self.step_size, base * ((1.0 + self._log1p(n)) / n) ** (1.0 / max(1, self.dims)))\n        neigh = self._neighbors(grid, new_pos, dyn_r, self.neighbor_cap)\n        if not neigh:\n            # fallback to nearest in tree\n            near = None\n            bestd = 1e100\n            for m in tree:\n                d = self._dist(m.position, new_pos)\n                if d < bestd:\n                    bestd = d\n                    near = m\n            neigh = [near] if near is not None else []\n        best_p = None\n        best_c = 1e100\n        for p in neigh:\n            d = self._dist(p.position, new_pos)\n            gc = p.cost + d\n            if gc + 1e-9 < best_c and self._segment_free(p.position, new_pos):\n                best_c = gc\n                best_p = p\n        if best_p is None:\n            return None, None\n        return best_p, best_c\n\n    def _log1p(self, x):\n        # simple series for small x; adequate for our integer n\n        return 0.5 if x <= 1.0 else self._fast_log(x + 1.0)\n\n    def _fast_log(self, x):\n        # crude monotonic approximation using change-of-base and piecewise\n        y = 0.0\n        t = x\n        while t > 2.718281828:\n            t *= 0.367879441  # divide by e\n            y += 1.0\n        # linear tail\n        return y + (t - 1.0) / 2.718281828\n\n    def _ancestor_leap(self, node, edges):\n        curp = node.parent\n        if curp is None:\n            return\n        bestp = curp\n        bestc = node.cost\n        anc = curp.parent\n        while anc is not None:\n            if self._segment_free(anc.position, node.position):\n                c = anc.cost + self._dist(anc.position, node.position)\n                if c + 1e-9 < bestc:\n                    bestc = c\n                    bestp = anc\n            anc = anc.parent\n        if bestp is not curp:\n            self._reparent(node, bestp, edges)\n\n    def _rewire_local(self, grid, node, edges):\n        radius = max(self.step_size, self.rewire_radius_mult * self.step_size)\n        neigh = self._neighbors(grid, node.position, radius, self.neighbor_cap)\n        improvements = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if node.cost + d + 1e-9 < nb.cost and self._segment_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n                improvements += 1\n                if improvements >= self.rewire_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        if child.parent is new_parent:\n            return\n        if not self._segment_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._remove_edge(edges, old, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        # propagate cost to subtree\n        stack = [child]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if abs(newc - ch.cost) > 1e-12:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is p and e[1] is c:\n                edges.pop(i)\n                return\n\n    # Obstacles and collision\n    def _build_obs_index(self):\n        # Cell size for obstacle spatial index\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.dims == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obs_grid.get(key)\n                            if b is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obs_grid.get(key)\n                        if b is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_blocked(self, p):\n        if self.dims == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _segment_free(self, a, b):\n        return not self._segment_hits(a, b)\n\n    def _box_bucket_density(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            s = 0\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            s += len(bkt)\n            return s\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            s = 0\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        s += len(bkt)\n            return s\n\n    def _segment_hits(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit3d(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit2d(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit2d(self, p0, p1, bmin, bmax):\n        # Slab method\n        t0, t1 = 0.0, 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _seg_box_hit3d(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Path assembly and postprocess\n    def _assemble(self, u, v, a_side):\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if a_side:\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _postprocess(self, path):\n        if len(path) < 2:\n            return path[:]\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.shortcut_trials)\n        p = self._elastic_angle_smooth(p, self.smooth_iters)\n        return p\n\n    def _visibility_prune(self, path):\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._segment_free(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = list(path)\n        best = self._path_len(pts)\n        n = len(pts)\n        fail = 0\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1:\n                fail += 1\n                if fail > 24:\n                    break\n                continue\n            a, b = pts[i], pts[j - 1]\n            if self._segment_free(a, b):\n                cand = pts[:i + 1] + pts[j - 1:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    pts = cand\n                    best = L\n                    n = len(pts)\n                    fail = 0\n                else:\n                    fail += 1\n            else:\n                fail += 1\n            if fail > 48:\n                break\n        return pts\n\n    def _elastic_angle_smooth(self, path, iters):\n        if len(path) < 3 or iters <= 0:\n            return path[:]\n        pts = list(path)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                b = pts[i]\n                c = pts[i + 1]\n                # Angle-aware midpoint pull\n                mid = tuple(0.25 * a[k] + 0.5 * b[k] + 0.25 * c[k] for k in range(self.dims))\n                if self._point_blocked(mid):\n                    continue\n                if self._segment_free(a, mid) and self._segment_free(mid, c):\n                    if mid != b:\n                        pts[i] = mid\n                        moved = True\n                # Try skip if possible\n                if self._segment_free(a, c):\n                    pts[i] = c  # will be removed next pass by neighbors\n                    moved = True\n            # Compact duplicates\n            comp = [pts[0]]\n            for p in pts[1:]:\n                if p != comp[-1]:\n                    comp.append(p)\n            pts = comp\n            if not moved:\n                break\n            if len(pts) < 3:\n                break\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts",
            "objective": -39.0221,
            "time_improvement": 68.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1312.0,
            "node_improvement": 88.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009383320808410645,
                    "num_nodes_avg": 51.0,
                    "path_length_avg": 148.31907804876715,
                    "smoothness_avg": 0.03583382190014427,
                    "success_improvement": 0.0,
                    "time_improvement": 61.966642474939334,
                    "node_improvement": 87.15688743389575,
                    "length_improvement": 18.703963055278603,
                    "smoothness_improvement": 460.8771271269766,
                    "objective_score": 32.11675621128384
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.043584227561950684,
                    "num_nodes_avg": 172.0,
                    "path_length_avg": 228.72791182641134,
                    "smoothness_avg": 0.08818936081319215,
                    "success_improvement": 0.0,
                    "time_improvement": 73.9409183696743,
                    "node_improvement": 88.44319021702614,
                    "length_improvement": 23.644039464437803,
                    "smoothness_improvement": 2169.175773952521,
                    "objective_score": 47.21457805932758
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01668705940246582,
                    "num_nodes_avg": 82.0,
                    "path_length_avg": 122.67227871244054,
                    "smoothness_avg": 0.1106371606216832,
                    "success_improvement": 0.0,
                    "time_improvement": 66.9410768359495,
                    "node_improvement": 89.57406230133503,
                    "length_improvement": 18.526913505383728,
                    "smoothness_improvement": 1307.2965167220898,
                    "objective_score": 37.73495373762554
                }
            ],
            "success_rate": 1.0
        },
        "objective": 38.8,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient nearest-neighbor lookups (fallback full scans or low-fidelity approximations), causing slow expansions and many wasted iterations\n   - Costly or missing rewiring (either large-radius, unbounded subtree updates or no rewire at all), inflating per-insert overhead or delaying local improvements\n   - Weak tree-connection strategy (single-shot or one-step probes), leading to repeated failed bridges in narrow passages\n   - Collision checking overhead (naive step sampling, excessive LOS calls, or many failed checks from fixed large steps), especially in cluttered regions\n   - Over-aggressive duplicate/per-cell gating or coarse grid policies, rejecting useful nodes and stalling progress\n   - Fixed step sizing and biased sampling that trigger many infeasible targets in corridors, increasing rejection rate"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Adaptive steering that shortens steps in locally cluttered areas, reducing failed extensions and collision checks\n   - Spatially indexed, slab-based segment\u2013obstacle tests that restrict checks to nearby candidates\n   - Bounded, local rewiring with a cap on improvements to limit per-insert cost while still lowering costs\n   - Ring-hash nearest with lightweight, strided fallback to avoid O(N) scans yet retain good candidate quality\n   - Multi-step micro-bridging from the opposite tree to reliably close small gaps instead of repeated single-shot failures\n   - Informed and corridor-aware sampling guided by an incumbent path length to focus search where success is likely\n2. Expected mechanism of impact:\n   - Fewer failed samples and cheaper collision queries reduce average time per iteration\n   - Earlier and more reliable tree connections cut the number of iterations to first feasible path\n   - Capped rewiring keeps runtime near-linear in node count while preserving key cost improvements\n   - More accurate-but-efficient NN selection accelerates convergence without heavy global scans\n   - Targeted sampling concentrates expansions in promising regions, decreasing wasted exploration and planning time"
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "CORE-BiRRT*: A lean, informed bidirectional RRT with local RRT* rewiring. It uses a simple spatial hash for nearest queries, coarse obstacle binning for fast collision tests, single-step expansion with strict node+edge checks, greedy RRT-Connect style bridging, and a light two-stage smoother (visibility + elastic midpoint + shortcuts) for shorter, smoother paths.",
                "planning_mechanism": "Alternate start/goal tree expansion: sample (uniform/goal/corridor, ellipse after first path), steer one step, pick best-cost parent among local neighbors, insert if node- and edge-free, locally rewire neighbors to reduce costs, then greedily extend the opposite tree toward the new point; upon connection, extract, prune, smooth, and return.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=6.0,\n        connect_mult=3.0,\n        goal_bias=0.25,\n        corridor_bias=0.45,\n        grid_cell_factor=1.5,\n        rewire_radius_factor=2.0,\n        connect_cap=24,\n        smooth_iters=120\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_mult = float(connect_mult)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.rewire_radius_factor = float(rewire_radius_factor)\n        self.connect_cap = int(max(1, connect_cap))\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 987654321\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # RNG seed\n        self._seed_from_scene()\n\n        # Derived params\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.rewire_radius = max(self.step * 1.1, self.step * self.rewire_radius_factor)\n        self.connect_step = max(self.step, self.step * self.connect_mult)\n        self.dup_radius = max(0.25 * self.step, 0.5)\n\n        # Build obstacle bins\n        self._build_obs_bins()\n\n        # Start/goal validity\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize bidirectional trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None  # informed bound once a solution is found (not used if early return)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = tree_start if active_start else tree_goal\n            tree_b = tree_goal if active_start else tree_start\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            attractor = self.goal if active_start else self.start\n\n            s = self._guided_sample(attractor, best_len)\n            if s is None:\n                continue\n\n            nearest = self._nearest_grid(grid_a, s)\n            if nearest is None:\n                continue\n\n            newp = self._steer(nearest.position, s, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(grid_a, newp, self.dup_radius):\n                continue\n            if not self._edge_free(nearest.position, newp):\n                continue\n\n            # Choose best parent among local neighbors (RRT* local)\n            parent, new_cost = self._choose_best_parent(grid_a, newp, nearest)\n\n            # Safety checks before commit\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            # Insert node\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            tree_a.append(nn)\n            self._grid_add(grid_a, nn)\n\n            # Local rewiring: try to improve neighbors' cost via nn\n            neigh = self._neighbors_in_radius(grid_a, nn.position, self.rewire_radius)\n            for nb in neigh:\n                if nb is nn or nb is parent:\n                    continue\n                # New path cost through nn\n                cand_cost = nn.cost + self._dist(nn.position, nb.position)\n                if cand_cost + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                    old_parent = nb.parent\n                    if old_parent is not None:\n                        old_parent.remove_child(nb)\n                        self._remove_edge(edges, (old_parent, nb))\n                    nn.add_child(nb)\n                    nb.cost = cand_cost\n                    edges.append((nn, nb))\n                    self._propagate_cost(nb)\n\n            # Try to connect from other tree toward nn (RRT-Connect style)\n            meet = self._connect_grow(tree_b, grid_b, nn.position, nodes, edges)\n            if meet is not None:\n                # Connected: build final path\n                meet_node = meet  # node in other tree closest that achieved connection\n                if active_start:\n                    pa = self._trace_to_root(nn)             # start -> ... -> nn\n                    pb = self._trace_to_root(meet_node)      # goal  -> ... -> meet\n                    path = pa + pb[::-1]                     # start -> ... nn -> meet -> ... -> goal\n                else:\n                    pa = self._trace_to_root(meet_node)      # start -> ... -> meet\n                    pb = self._trace_to_root(nn)             # goal  -> ... -> nn\n                    path = pa + pb[::-1]                     # start -> ... meet -> nn -> ... -> goal\n                # Record no duplicate consecutive points\n                path2 = []\n                for p in path:\n                    if (not path2) or (p != path2[-1]):\n                        path2.append(p)\n                final = self._finalize_path(path2)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and helpers\n    def _seed_from_scene(self):\n        s = 0xA5A5A5A5 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 11) ^ (q << 7)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 7) * 1597334677) & 0xffffffff\n        if s == 0:\n            s = 987654321\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash for nodes\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            cand.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        cand.extend(lst)\n        return cand\n\n    def _nearest_grid(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, 3):\n            cand = self._grid_ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback scan across all buckets\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        nb = self._neighbors_in_radius(grid, pos, radius)\n        return len(nb) > 0\n\n    # Obstacles binning and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obin.get(key)\n                            if b is None:\n                                self.obin[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obin.get(key)\n                        if b is None:\n                            self.obin[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parent selection with local neighbors\n    def _choose_best_parent(self, grid, newp, fallback):\n        parent = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        neigh = self._neighbors_in_radius(grid, newp, self.rewire_radius)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                parent = n\n                best_cost = c\n        return parent, best_cost\n\n    # Connect step: RRT-Connect style growth from tree toward target\n    def _connect_grow(self, tree, grid, target_pos, nodes, edges):\n        # Start from nearest node in other tree\n        start = self._nearest_grid(grid, target_pos)\n        if start is None:\n            return None\n        cur = start\n        steps = 0\n        while steps < self.connect_cap:\n            # If direct connection possible, finish\n            if self._edge_free(cur.position, target_pos):\n                return cur\n            nxtp = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxtp)) or self._point_in_obstacles(nxtp):\n                return None\n            if not self._edge_free(cur.position, nxtp):\n                return None\n            # Commit this connect step\n            new_cost = cur.cost + self._dist(cur.position, nxtp)\n            nn = Node(nxtp, cur, new_cost)\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n        # Final try after cap\n        if self._edge_free(cur.position, target_pos):\n            return cur\n        return None\n\n    # Path handling\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _remove_edge(self, edges, e):\n        # e is (u, v)\n        try:\n            idx = edges.index(e)\n            edges.pop(idx)\n        except:\n            pass\n\n    def _propagate_cost(self, node):\n        # Update costs of subtree after rewiring\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    # Sampling\n    def _guided_sample(self, attractor, best_len):\n        r = self._rand()\n        # Informed sampling after first solution bound (ellipse around start-goal)\n        if best_len is not None and r < 0.6:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        # Goal/corridor biased sampling\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        if r < self.goal_bias + self.corridor_bias:\n            return self._corridor_point()\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.06 * sg)\n        if self.is3:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            oz = self._rand_range(-w, w)\n            p = (base[0] + ox, base[1] + oy, base[2] + oz)\n        else:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            p = (base[0] + ox, base[1] + oy)\n        return self._clamp(p)\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(20):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Smoothing\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _elastic_midpoint(self, pts, iters=2):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(iters):\n            changed = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if mid != b and self._edge_free(a, mid) and self._edge_free(mid, c):\n                    cur[i] = mid\n                    changed = True\n            if not changed:\n                break\n        return cur\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._visibility_prune(path)\n        p1 = self._elastic_midpoint(p0, iters=3)\n        p2 = self._shortcut(p1, self.smooth_iters)\n        p3 = self._visibility_prune(p2)\n        return p3",
                "objective": -30.28934,
                "time_improvement": 51.0,
                "length_improvement": 12.0,
                "smoothness_improvement": 1570.0,
                "node_improvement": 82.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.016851282119750975,
                        "num_nodes_avg": 79.0,
                        "path_length_avg": 190.23640673379288,
                        "smoothness_avg": 0.03324330254781312,
                        "success_improvement": 0.0,
                        "time_improvement": 31.696800023966244,
                        "node_improvement": 80.10576680936792,
                        "length_improvement": -4.271589019562566,
                        "smoothness_improvement": 420.3298738601826,
                        "objective_score": 9.047735964753246
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.059451723098754884,
                        "num_nodes_avg": 262.0,
                        "path_length_avg": 235.58120329866102,
                        "smoothness_avg": 0.12047403072161833,
                        "success_improvement": 0.0,
                        "time_improvement": 64.45371658607792,
                        "node_improvement": 82.39602230733051,
                        "length_improvement": 21.356213509943267,
                        "smoothness_improvement": 2999.8835844041396,
                        "objective_score": 47.14926100381003
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.02198073863983154,
                        "num_nodes_avg": 139.0,
                        "path_length_avg": 122.23450723412502,
                        "smoothness_avg": 0.109187917398101,
                        "success_improvement": 0.0,
                        "time_improvement": 56.4537086938224,
                        "node_improvement": 82.32676414494597,
                        "length_improvement": 18.81766047684322,
                        "smoothness_improvement": 1288.8622498901318,
                        "objective_score": 34.67102014370331
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "SAGE-Connect: A simplified adaptive BiRRT-Connect with local cost-aware parenting and light rewiring. It uses a uniform spatial hash for nearest/neighbor queries, coarse obstacle binning for fast collision checks, adaptive rewire radius, and minimal biased/informed sampling. It inserts only strictly node- and edge-free states, creates the exact meeting node to reduce kinks, and applies a compact densify+shortcut+visibility smoother for short, smooth paths.",
            "planning_mechanism": "Alternate growth from start/goal trees: sample (uniform with small goal bias; ellipse after first solution), steer one step, choose the best-cost parent among nearby nodes, add after node+edge checks, locally rewire cheaper neighbors, then greedily extend the opposite tree toward the new node and insert the exact meeting point; upon connection, extract, densify, shortcut, visibility-prune, and return.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=6.0,\n        connect_mult=2.0,\n        goal_bias=0.12,\n        grid_cell_factor=1.6,\n        rewire_base=2.2,\n        smooth_iters=120\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_mult = float(connect_mult)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.rewire_base = float(rewire_base)\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.connect_step = max(self.step, self.step * self.connect_mult)\n        self.dup_radius = max(0.5, 0.4 * self.step)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            Ta = tree_a if active_start else tree_b\n            Tb = tree_b if active_start else tree_a\n            Ga = grid_a if active_start else grid_b\n            Gb = grid_b if active_start else grid_a\n            attractor = self.goal if active_start else self.start\n\n            sample = self._sample(attractor, best_len)\n            if sample is None:\n                continue\n\n            na = self._nearest(Ga, sample)\n            if na is None:\n                continue\n\n            newp = self._steer(na.position, sample, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(Ga, newp, self.dup_radius):\n                continue\n            if not self._edge_free(na.position, newp):\n                continue\n\n            rew_rad = self._adaptive_rewire_radius(len(Ta))\n            parent, new_cost = self._choose_parent(Ga, newp, na, rew_rad)\n\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            Ta.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(Ga, nn)\n\n            self._local_rewire(Ga, nn, rew_rad, edges)\n\n            meet_node, reached = self._connect_toward(Tb, Gb, nn.position, nodes, edges)\n            if reached:\n                if active_start:\n                    pa = self._trace_to_root(nn)        # start -> ... -> nn\n                    pb = self._trace_to_root(meet_node) # goal  -> ... -> nn\n                    path = pa + pb[-2::-1]              # avoid duplicate nn\n                else:\n                    pa = self._trace_to_root(meet_node) # start -> ... -> nn\n                    pb = self._trace_to_root(nn)        # goal  -> ... -> nn\n                    path = pa + pb[-2::-1]\n\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 13) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found_any = False\n        for r in range(0, 4):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found_any = True\n            if found_any:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius)) > 0\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.2)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parenting and rewiring\n    def _choose_parent(self, grid, newp, fallback, radius):\n        parent = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        neigh = self._neighbors_in_radius(grid, newp, radius)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                parent = n\n                best_cost = c\n        return parent, best_cost\n\n    def _local_rewire(self, grid, nn, radius, edges):\n        neigh = self._neighbors_in_radius(grid, nn.position, radius)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            cand = nn.cost + self._dist(nn.position, nb.position)\n            if cand + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                nn.add_child(nb)\n                nb.cost = cand\n                edges.append((nn, nb))\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        try:\n            idx = edges.index(e)\n            edges.pop(idx)\n        except:\n            pass\n\n    def _adaptive_rewire_radius(self, n_nodes):\n        # Shrink with tree size without log; simple exponential decay\n        base = max(self.step * 1.2, self.step * self.rewire_base)\n        decay = pow(0.5, n_nodes / 2500.0)\n        return max(self.step * 1.2, base * decay)\n\n    # BiRRT-Connect growth from other tree toward target; insert exact meeting node if visible\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < 64:\n            if self._edge_free(cur.position, target_pos):\n                # Insert the exact meeting point for a clean junction\n                if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                    if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        cur.add_child(nn)\n                        tree.append(nn)\n                        nodes.append(nn)\n                        edges.append((cur, nn))\n                        self._grid_add(grid, nn)\n                        return nn, True\n                # If too close, treat current as meeting node\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(grid, nxt, self.dup_radius * 0.75):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n        # Final try after capped steps\n        if self._edge_free(cur.position, target_pos):\n            if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    edges.append((cur, nn))\n                    self._grid_add(grid, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.55:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _densify(self, pts, seg_len):\n        if len(pts) < 2:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts)):\n            a = out[-1]\n            b = pts[i]\n            d = self._dist(a, b)\n            if d <= seg_len * 1.05:\n                out.append(b)\n                continue\n            nseg = int(d / seg_len)\n            if nseg < 1:\n                out.append(b)\n                continue\n            for k in range(1, nseg + 1):\n                t = k / float(nseg + 1)\n                inter = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n                if self._edge_free(out[-1], inter):\n                    out.append(inter)\n                else:\n                    break\n            if self._edge_free(out[-1], b):\n                out.append(b)\n            else:\n                out.append(b)\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._densify(path, seg_len=max(1.0, 0.5 * self.step))\n        p1 = self._shortcut(p0, self.smooth_iters)\n        p2 = self._visibility_prune(p1)\n        p3 = self._shortcut(p2, max(20, self.smooth_iters // 2))\n        return self._dedup(p3)",
            "objective": -39.95809,
            "time_improvement": 69.0,
            "length_improvement": 21.0,
            "smoothness_improvement": 1361.0,
            "node_improvement": 85.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008446240425109863,
                    "num_nodes_avg": 40.0,
                    "path_length_avg": 154.00203649529243,
                    "smoothness_avg": 0.0463463750398735,
                    "success_improvement": 0.0,
                    "time_improvement": 65.76490472936995,
                    "node_improvement": 89.92697053638882,
                    "length_improvement": 15.589043478498803,
                    "smoothness_improvement": 625.4214121382626,
                    "objective_score": 32.21000456660158
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02304682731628418,
                    "num_nodes_avg": 136.0,
                    "path_length_avg": 230.09301068249903,
                    "smoothness_avg": 0.08849989105200873,
                    "success_improvement": 0.0,
                    "time_improvement": 86.220263890156,
                    "node_improvement": 90.86205738090439,
                    "length_improvement": 23.188330174083777,
                    "smoothness_improvement": 2177.1659406631616,
                    "objective_score": 50.66490697481287
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02282891273498535,
                    "num_nodes_avg": 204.0,
                    "path_length_avg": 115.03810237530747,
                    "smoothness_avg": 0.10863321186734835,
                    "success_improvement": 0.0,
                    "time_improvement": 54.77338134763434,
                    "node_improvement": 74.06230133502861,
                    "length_improvement": 23.597169928095134,
                    "smoothness_improvement": 1281.8064364830614,
                    "objective_score": 36.99934854356269
                }
            ],
            "success_rate": 1.0
        },
        "objective": 34.199999999999996,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Nearest-neighbor lookups often degrade to full scans due to limited grid-ring search, increasing per-iteration cost.\n   - Fixed, relatively large rewiring radius yields many neighbor queries and collision checks as the tree grows.\n   - Strong goal/corridor sampling bias causes high rejection rates and repeated attempts along blocked corridors.\n   - Greedy connection grows with long steps and does not insert the exact meeting point, creating abrupt junctions and extra smoothing work.\n   - Weak duplicate-spacing during connect inflates node count and grid load, slowing all queries.\n   - Smoothing order without prior densification triggers many visibility checks and leaves more work to random shortcuts."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Adaptive rewire radius that shrinks with tree size, limiting neighbor and collision checks.\n   - Reduced bias toward attractors (no corridor bias, lower goal bias) with simple informed sampling only when a bound exists.\n   - More tolerant spatial hashing (slightly larger cells and a wider initial ring) to avoid fallback full scans in nearest queries.\n   - Stricter duplicate-spacing and proximity checks during connect growth, plus smaller connection step and insertion of the exact meeting node.\n   - Coarser obstacle binning to cut candidate obstacle tests per edge.\n   - Streamlined post-processing: early densification followed by shortcutting and a single visibility pass, with final light shortcut and deduplication.\n2. Expected mechanism of impact:\n   - Fewer neighbors per expansion and fewer segment tests reduce constant factors in each iteration, accelerating growth.\n   - Less time wasted on biased samples into clutter decreases failed steering and collision-check attempts.\n   - Lower O(N) fallbacks in nearest queries keep lookups near constant time in practice.\n   - Reduced node proliferation shrinks grid/bucket sizes, speeding up all spatial queries and rewiring.\n   - Faster collision checks from coarser bins lower per-edge validation time.\n   - Cleaner connection points and more effective smoothing order cut post-solution processing time."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "SiBiRRT*-L: Simple Informed Bi-directional RRT* with Light Rewiring. Two trees grow from start and goal with uniform/informed sampling and small goal bias. Each new point picks the best feasible parent within a radius and rewires nearby nodes if cheaper. A minimal incremental bridge connects the trees when feasible. The final route is pruned and shortcut for length and smoothness.",
                "planning_mechanism": "Alternate expanding start/goal trees. For each sample: choose target (uniform, goal-biased, or informed ellipse if a bound exists), steer a step from the nearest, and reject if node/edge collide or near-duplicate. Select the lowest-cost feasible parent within a radius, insert the node, and locally rewire cheaper neighbors (avoiding cycles). Try to connect to the other tree by direct edge or short incremental steps; if successful, build the full path and post-process with visibility pruning and bounded shortcutting, then return.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            if self not in new_parent.children:\n                new_parent.children.append(self)\n\n    def is_ancestor_of(self, other):\n        cur = other\n        while cur is not None:\n            if cur is self:\n                return True\n            cur = cur.parent\n        return False\n\n    def propagate_cost(self, delta):\n        if abs(delta) <= 0.0:\n            return\n        self.cost += delta\n        for c in self.children:\n            c.propagate_cost(delta)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3500,\n        step_size=8.0,\n        goal_bias=0.15,\n        informed_bias=0.5,\n        parent_radius_factor=3.0,\n        rewire_radius_factor=3.0,\n        dupe_radius_ratio=0.45,\n        cell_factor=1.25,\n        connect_steps=10,\n        shortcut_attempts=80\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.parent_radius_factor = float(parent_radius_factor)\n        self.rewire_radius_factor = float(rewire_radius_factor)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.cell_factor = float(cell_factor)\n        self.connect_steps = int(connect_steps)\n        self.shortcut_attempts = int(shortcut_attempts)\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # Validate endpoints\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacle(self.start) or self._point_in_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._seed_rng()\n        self.cell_size = max(1.0, self.step_size * self.cell_factor)\n        self.dupe_radius = max(0.4, self.step_size * self.dupe_radius_ratio)\n        self.parent_radius = max(self.step_size, self.parent_radius_factor * self.step_size)\n        self.rewire_radius = max(self.step_size * 2.0, self.rewire_radius_factor * self.step_size)\n\n        # Direct path early exit\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.children.append(n1)\n            path = [self.start, self.goal]\n            return PlannerResult(True, self._finalize_path(path), [n0, n1], [(n0, n1)])\n\n        # Trees and grids\n        nodes = []\n        edges = []\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n        A, B = [a_root], [b_root]\n        GA, GB = {}, {}\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            grow_A = (it % 2 == 0)\n            T = A if grow_A else B\n            O = B if grow_A else A\n            G = GA if grow_A else GB\n            GO = GB if grow_A else GA\n            attractor = self.goal if grow_A else self.start\n\n            qrand = self._sample(attractor, best_len)\n            if qrand is None:\n                continue\n\n            qnear = self._nearest(G, qrand)\n            if qnear is None:\n                continue\n\n            qnew_pos = self._steer(qnear.position, qrand)\n            if not self._in_bounds(qnew_pos):\n                continue\n            if self._point_in_obstacle(qnew_pos):\n                continue\n            if not self._edge_free(qnear.position, qnew_pos):\n                continue\n            if self._has_near(G, qnew_pos, self.dupe_radius):\n                continue\n\n            # Best parent within radius\n            parent = None\n            parent_cost = float('inf')\n            parents = self._neighbors_in_radius(G, qnew_pos, self.parent_radius)\n            if not parents:\n                parents = [qnear]\n            for p in parents:\n                if not self._edge_free(p.position, qnew_pos):\n                    continue\n                c = p.cost + self._dist(p.position, qnew_pos)\n                if c < parent_cost:\n                    parent_cost = c\n                    parent = p\n            if parent is None:\n                continue\n\n            # Insert new node (both node and edge already validated)\n            qnew = Node(qnew_pos, parent, parent_cost)\n            parent.children.append(qnew)\n            T.append(qnew)\n            nodes.append(qnew)\n            edges.append((parent, qnew))\n            self._grid_add(G, qnew)\n\n            # Local rewiring\n            nbrs = self._neighbors_in_radius(G, qnew.position, self.rewire_radius)\n            for w in nbrs:\n                if w is qnew or w is qnew.parent:\n                    continue\n                # avoid cycle: don't rewire ancestors through descendant\n                if w.is_ancestor_of(qnew):\n                    continue\n                if not self._edge_free(qnew.position, w.position):\n                    continue\n                cand = qnew.cost + self._dist(qnew.position, w.position)\n                if cand + 1e-12 < w.cost:\n                    oldp = w.parent\n                    self._replace_edge(edges, oldp, w, qnew)\n                    w.attach(qnew)\n                    delta = cand - w.cost\n                    w.propagate_cost(delta)\n\n            # Try direct connect to other tree\n            o_near = self._nearest(GO, qnew.position)\n            if o_near is not None:\n                if self._edge_free(o_near.position, qnew.position):\n                    edges.append((o_near, qnew))\n                    path = self._extract_path(qnew, o_near)\n                    best_len = self._path_len(path)\n                    return PlannerResult(True, self._finalize_path(path), nodes, edges)\n\n                # Minimal incremental bridge from other side\n                ok, bridge_nodes = self._bridge_chain(o_near, qnew.position, O, GO)\n                if ok:\n                    last = bridge_nodes[-1] if bridge_nodes else o_near\n                    if self._edge_free(last.position, qnew.position):\n                        edges.append((last, qnew))\n                        path = self._extract_path(qnew, last)\n                        best_len = self._path_len(path)\n                        return PlannerResult(True, self._finalize_path(path), nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s ^= (int(v * 997 + 0.5) + 0x9E3779B97F4A7C15 + (s << 6) + (s >> 2)) & 0xffffffff\n            s &= 0xffffffff\n        s ^= (len(self.obstacles) + 1) * 2654435761 & 0xffffffff\n        if s == 0:\n            s = 2463534242\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= self.step_size:\n            tgt = b\n        else:\n            r = self.step_size / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n        return tuple(max(0.0, min(tgt[i], self.bounds[i])) for i in range(self.dims))\n\n    # Spatial hashing\n    def _cell_key(self, p):\n        if self.is3d:\n            return (int(p[0] // self.cell_size), int(p[1] // self.cell_size), int(p[2] // self.cell_size))\n        return (int(p[0] // self.cell_size), int(p[1] // self.cell_size))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bd:\n                    bd = d\n                    best = n\n            if best is not None:\n                return best\n        # fallback\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < bd:\n                    bd = d\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell_size) + 1)\n        out = []\n        if self.is3d:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            out.append(n)\n        return out\n\n    def _has_near(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell_size) + 1)\n        if self.is3d:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # Collision\n    def _point_in_obstacle(self, p):\n        if self.is3d:\n            px, py, pz = p\n            for x, y, z, w, h, d in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for x, y, w, h in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        if self.is3d:\n            for x, y, z, w, h, d in self.obstacles:\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return False\n            return True\n        else:\n            for x, y, w, h in self.obstacles:\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return False\n            return True\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Edges\n    def _replace_edge(self, edges, old_parent, child, new_parent):\n        if old_parent is not None:\n            idx = -1\n            for i in range(len(edges)):\n                if edges[i][0] is old_parent and edges[i][1] is child:\n                    idx = i\n                    break\n            if idx >= 0:\n                edges.pop(idx)\n        if new_parent is not None:\n            edges.append((new_parent, child))\n\n    # Bridge from other tree toward position\n    def _bridge_chain(self, start_node, target_pos, other_tree_nodes, other_grid):\n        path_nodes = []\n        cur = start_node\n        for _ in range(self.connect_steps):\n            step_pos = self._steer(cur.position, target_pos)\n            if not self._in_bounds(step_pos):\n                return False, []\n            if self._point_in_obstacle(step_pos):\n                return False, []\n            if not self._edge_free(cur.position, step_pos):\n                return False, []\n            if self._has_near(other_grid, step_pos, self.dupe_radius):\n                # snap to nearest if helpful\n                snap = self._nearest(other_grid, step_pos)\n                if snap is not None:\n                    cur = snap\n                    continue\n            # commit node into the other tree\n            q = Node(step_pos, cur, cur.cost + self._dist(cur.position, step_pos))\n            cur.children.append(q)\n            other_tree_nodes.append(q)\n            path_nodes.append(q)\n            self._grid_add(other_grid, q)\n            cur = q\n            if self._dist(cur.position, target_pos) <= self.step_size:\n                return True, path_nodes\n        return False, []\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        for _ in range(20):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p and self._in_bounds(p) and not self._point_in_obstacle(p):\n                    return p\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._in_bounds(p) and not self._point_in_obstacle(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(16):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._in_bounds(p) and not self._point_in_obstacle(p):\n                return p\n        return None\n\n    # Path ops\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return pa + pb[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pruned[-1], path[j]):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_L = self._path_len(pts)\n        tries = 0\n        while tries < attempts and len(pts) > 2:\n            n = len(pts)\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best_L + 1e-12:\n                    pts = cand\n                    best_L = L\n            tries += 1\n        return pts\n\n    def _finalize_path(self, path):\n        if not path:\n            return []\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        return p",
                "objective": -25.64842,
                "time_improvement": 34.0,
                "length_improvement": 18.0,
                "smoothness_improvement": 953.0,
                "node_improvement": 84.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.008201861381530761,
                        "num_nodes_avg": 27.0,
                        "path_length_avg": 167.14602448004797,
                        "smoothness_avg": 0.04070846924210914,
                        "success_improvement": 0.0,
                        "time_improvement": 66.75544482981553,
                        "node_improvement": 93.20070511206245,
                        "length_improvement": 8.384615384236236,
                        "smoothness_improvement": 537.175943494856,
                        "objective_score": 27.74328239696068
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.02028026580810547,
                        "num_nodes_avg": 98.0,
                        "path_length_avg": 228.92890734511678,
                        "smoothness_avg": 0.05758490636878498,
                        "success_improvement": 0.0,
                        "time_improvement": 87.8743955843445,
                        "node_improvement": 93.41530605388698,
                        "length_improvement": 23.5769413749587,
                        "smoothness_improvement": 1381.7011176003928,
                        "objective_score": 47.41698908828054
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.07745046615600586,
                        "num_nodes_avg": 280.0,
                        "path_length_avg": 117.65538179344631,
                        "smoothness_avg": 0.08177788722082871,
                        "success_improvement": 0.0,
                        "time_improvement": -53.437999345345396,
                        "node_improvement": 64.39923712650986,
                        "length_improvement": 21.858897560020345,
                        "smoothness_improvement": 940.2086892332006,
                        "objective_score": 1.78498217857459
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "BiCon-Lite*: Simplified Bi-directional RRT-Connect with local best-parent and light rewiring. It grows two trees from start and goal using uniform sampling with small goal bias and informed sampling once a path bound is known. Each added node is chosen from a few nearest candidates by lowest path cost if the edge is collision-free; after insertion, nearby nodes can be rewired if cheaper. Trees greedily connect toward each other; upon connection, the path is visibility-pruned and shortcut for length and smoothness.",
            "planning_mechanism": "Alternate expanding start/goal trees. For each iteration: sample a target (uniform, goal-biased, or informed ellipse), steer one step from the nearest node, reject if outside/duplicate/colliding, then pick a best feasible parent among k-nearest to insert. Lightly rewire nearby neighbors if the new route is cheaper (cycle-safe). Attempt a greedy connect from the opposite tree toward the new node by incremental steps; if it reaches within one step and the final edge is free, extract the full path (start-to-A, cross-edge, B-to-goal), then prune and shortcut. Always check node and edge collisions before adding any node or edge.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n\n    def attach(self, new_parent):\n        if new_parent is self.parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            if self not in new_parent.children:\n                new_parent.children.append(self)\n\n    def is_ancestor_of(self, other):\n        cur = other\n        while cur is not None:\n            if cur is self:\n                return True\n            cur = cur.parent\n        return False\n\n    def propagate_cost(self, delta):\n        if delta == 0.0:\n            return\n        self.cost += delta\n        for c in self.children:\n            c.propagate_cost(delta)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=10.0,\n        goal_bias=0.1,\n        informed_bias=0.5,\n        dupe_radius_ratio=0.5,\n        neighbor_radius_factor=2.5,\n        k_near=5,\n        shortcut_attempts=80\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.neighbor_radius_factor = float(neighbor_radius_factor)\n        self.k_near = int(k_near)\n        self.shortcut_attempts = int(shortcut_attempts)\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obstacle(self.start) or self._point_in_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._seed_rng()\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.neighbor_radius = max(self.step_size * 1.5, self.step_size * self.neighbor_radius_factor)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            edges = [(n0, n1)]\n            return PlannerResult(True, self._finalize_path([self.start, self.goal]), [n0, n1], edges)\n\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        A = [a_root]\n        B = [b_root]\n\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            grow_A = (it % 2 == 0)\n            T = A if grow_A else B\n            O = B if grow_A else A\n            attractor = self.goal if grow_A else self.start\n\n            qrand = self._sample(attractor, best_len)\n            if qrand is None:\n                continue\n\n            qnear = self._nearest_in(T, qrand)\n            if qnear is None:\n                continue\n\n            qnew_pos = self._steer(qnear.position, qrand)\n            if not self._in_bounds(qnew_pos):\n                continue\n            if self._point_in_obstacle(qnew_pos):\n                continue\n            if self._has_near_in(T, qnew_pos, self.dupe_radius):\n                continue\n\n            parent = self._best_parent(T, qnew_pos, qnear)\n            if parent is None:\n                continue\n            if not self._edge_free(parent.position, qnew_pos):\n                continue\n\n            qnew_cost = parent.cost + self._dist(parent.position, qnew_pos)\n            qnew = Node(qnew_pos, parent, qnew_cost)\n            T.append(qnew)\n            nodes.append(qnew)\n            edges.append((parent, qnew))\n\n            self._light_rewire(T, qnew, edges)\n\n            ok, last_other, added = self._connect_toward(O, qnew.position, nodes, edges)\n            if ok and last_other is not None:\n                edges.append((last_other, qnew))\n                path = self._extract_path(qnew, last_other)\n                best_len = self._path_len(path)\n                return PlannerResult(True, self._finalize_path(path), nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0xA5A5A5A5\n        for v in self.start + self.goal:\n            s ^= (int(v * 1315423911) + (s << 7) + (s >> 3)) & 0xffffffff\n            s &= 0xffffffff\n        s ^= (len(self.obstacles) * 0x9E3779B9) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            tgt = a\n        elif d <= self.step_size:\n            tgt = b\n        else:\n            r = self.step_size / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n        out = tuple(max(0.0, min(tgt[i], self.bounds[i])) for i in range(self.dims))\n        return out\n\n    # Nearest and neighbors\n    def _nearest_in(self, nodes_list, pos):\n        best = None\n        bd = 1e100\n        for n in nodes_list:\n            d = self._dist(n.position, pos)\n            if d < bd:\n                bd = d\n                best = n\n        return best\n\n    def _k_nearest_in(self, nodes_list, pos, k):\n        if not nodes_list:\n            return []\n        pairs = []\n        for n in nodes_list:\n            pairs.append((self._dist(n.position, pos), n))\n        pairs.sort(key=lambda x: x[0])\n        out = [n for _, n in pairs[:max(1, k)]]\n        return out\n\n    def _neighbors_radius(self, nodes_list, pos, radius):\n        out = []\n        r = float(radius)\n        for n in nodes_list:\n            if self._dist(n.position, pos) <= r:\n                out.append(n)\n        return out\n\n    def _has_near_in(self, nodes_list, pos, radius):\n        r = float(radius)\n        for n in nodes_list:\n            if self._dist(n.position, pos) <= r:\n                return True\n        return False\n\n    # Parent selection\n    def _best_parent(self, nodes_list, qpos, fallback):\n        cands = self._k_nearest_in(nodes_list, qpos, self.k_near)\n        if fallback not in cands:\n            cands.append(fallback)\n        best = None\n        best_cost = 1e100\n        for p in cands:\n            if not self._edge_free(p.position, qpos):\n                continue\n            c = p.cost + self._dist(p.position, qpos)\n            if c < best_cost:\n                best_cost = c\n                best = p\n        return best\n\n    # Light rewiring\n    def _light_rewire(self, nodes_list, qnew, edges):\n        nbrs = self._neighbors_radius(nodes_list, qnew.position, self.neighbor_radius)\n        rewired = 0\n        for w in nbrs:\n            if w is qnew or w is qnew.parent:\n                continue\n            if w.is_ancestor_of(qnew):\n                continue\n            d = self._dist(qnew.position, w.position)\n            cand_cost = qnew.cost + d\n            if cand_cost + 1e-12 < w.cost and self._edge_free(qnew.position, w.position):\n                oldp = w.parent\n                self._replace_edge(edges, oldp, w, qnew)\n                w.attach(qnew)\n                delta = cand_cost - w.cost\n                w.propagate_cost(delta)\n                rewired += 1\n                if rewired >= 10:\n                    break\n\n    # Connect toward a target (other tree growth)\n    def _connect_toward(self, tree_nodes, target_pos, all_nodes, edges):\n        if not tree_nodes:\n            return False, None, []\n        cur = self._nearest_in(tree_nodes, target_pos)\n        added = []\n        for _ in range(1000):\n            nxt = self._steer(cur.position, target_pos)\n            if self._dist(cur.position, nxt) <= 1e-9:\n                break\n            if not self._in_bounds(nxt):\n                break\n            if self._point_in_obstacle(nxt):\n                break\n            if self._has_near_in(tree_nodes, nxt, self.dupe_radius):\n                # If very close to some node, snap to the nearest and continue\n                cur = self._nearest_in(tree_nodes, nxt)\n                if self._dist(cur.position, target_pos) <= self.step_size and self._edge_free(cur.position, target_pos):\n                    return True, cur, added\n                continue\n            if not self._edge_free(cur.position, nxt):\n                break\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            q = Node(nxt, cur, new_cost)\n            tree_nodes.append(q)\n            all_nodes.append(q)\n            edges.append((cur, q))\n            added.append(q)\n            cur = q\n            if self._dist(cur.position, target_pos) <= self.step_size and self._edge_free(cur.position, target_pos):\n                return True, cur, added\n        return False, cur, added\n\n    # Collision\n    def _point_in_obstacle(self, p):\n        if self.is3d:\n            px, py, pz = p\n            for x, y, z, w, h, d in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            px, py = p\n            for x, y, w, h in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        if self.is3d:\n            for x, y, z, w, h, d in self.obstacles:\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return False\n            return True\n        else:\n            for x, y, w, h in self.obstacles:\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return False\n            return True\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Edges\n    def _replace_edge(self, edges, old_parent, child, new_parent):\n        if old_parent is not None:\n            rm = -1\n            for i, (u, v) in enumerate(edges):\n                if u is old_parent and v is child:\n                    rm = i\n                    break\n            if rm >= 0:\n                edges.pop(rm)\n        if new_parent is not None:\n            exists = False\n            for u, v in edges:\n                if u is new_parent and v is child:\n                    exists = True\n                    break\n            if not exists:\n                edges.append((new_parent, child))\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        for _ in range(24):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p is not None and not self._point_in_obstacle(p):\n                    return p\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._in_bounds(p) and not self._point_in_obstacle(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(16):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path ops\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        return pa + pb[::-1]\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pruned[-1], path[j]):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        best_L = self._path_len(pts)\n        tries = 0\n        while tries < attempts and len(pts) > 2:\n            n = len(pts)\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best_L + 1e-12:\n                    pts = cand\n                    best_L = L\n            tries += 1\n        return pts\n\n    def _finalize_path(self, path):\n        if not path:\n            return []\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        return p",
            "objective": -42.61971,
            "time_improvement": 88.0,
            "length_improvement": 13.0,
            "smoothness_improvement": 1715.0,
            "node_improvement": 94.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.005434727668762207,
                    "num_nodes_avg": 33.0,
                    "path_length_avg": 172.03461483544805,
                    "smoothness_avg": 0.051447969062332066,
                    "success_improvement": 0.0,
                    "time_improvement": 77.97145118473429,
                    "node_improvement": 91.68975069252078,
                    "length_improvement": 5.705101545770078,
                    "smoothness_improvement": 705.2724368784732,
                    "objective_score": 30.3408584672747
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.012911844253540038,
                    "num_nodes_avg": 78.0,
                    "path_length_avg": 254.30361579440722,
                    "smoothness_avg": 0.12651907716440625,
                    "success_improvement": 0.0,
                    "time_improvement": 92.27998699936137,
                    "node_improvement": 94.75912114493046,
                    "length_improvement": 15.106133324099327,
                    "smoothness_improvement": 3155.4269834480324,
                    "objective_score": 52.52481101150817
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0025941610336303713,
                    "num_nodes_avg": 30.0,
                    "path_length_avg": 125.19016890049133,
                    "smoothness_avg": 0.10884440067125287,
                    "success_improvement": 0.0,
                    "time_improvement": 94.86067807289716,
                    "node_improvement": 96.18563254926892,
                    "length_improvement": 16.854650731526867,
                    "smoothness_improvement": 1284.492742480391,
                    "objective_score": 44.99345757318722
                }
            ],
            "success_rate": 1.0
        },
        "objective": 31.199999999999996,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient nearest/neighbor lookups with repeated region scans and frequent full fallbacks, creating high constant overhead per iteration\n   - Broad neighbor radii and unbounded rewiring triggering many collision checks, cycle guards, and subtree cost propagations\n   - Heavy bookkeeping during bridging and rewiring (edge replacement scans, child list maintenance), inflating per-step latency\n   - Small expansion steps and lenient duplicate suppression causing dense trees, larger node/edge sets, and escalating O(N)/O(E) passes"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Larger expansion step reducing required iterations and bridge steps\n   - Fixed-size k-nearest parent selection limiting neighbor evaluations and collision tests\n   - Capped \u201clight\u201d rewiring to bound reparenting, edge updates, and cost propagation\n   - Simpler data access (direct list scans) avoiding ring-based spatial lookups and index maintenance\n   - More aggressive duplicate suppression lowering node/edge counts throughout planning\n   - Greedy connect procedure that grows the opposite tree in one pass, reducing repeated queries and updates\n2. Expected mechanism of impact:\n   - Fewer samples and edges evaluated per connection attempt, cutting collision-check volume and ancestor checks\n   - Bounded neighbor sets and rewiring operations shrinking worst-case work per iteration\n   - Eliminating heavy spatial-index overhead and dictionary churn, improving constant factors for moderate tree sizes\n   - Reduced tree density limiting the cost of subsequent nearest/neighbor scans and bookkeeping\n   - Shorter connect phases with early snapping/termination decreasing total expansions before a valid path is found"
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "SAGE-Connect: A simplified adaptive BiRRT-Connect with local cost-aware parenting and light rewiring. It uses a uniform spatial hash for nearest/neighbor queries, coarse obstacle binning for fast collision checks, adaptive rewire radius, and minimal biased/informed sampling. It inserts only strictly node- and edge-free states, creates the exact meeting node to reduce kinks, and applies a compact densify+shortcut+visibility smoother for short, smooth paths.",
                "planning_mechanism": "Alternate growth from start/goal trees: sample (uniform with small goal bias; ellipse after first solution), steer one step, choose the best-cost parent among nearby nodes, add after node+edge checks, locally rewire cheaper neighbors, then greedily extend the opposite tree toward the new node and insert the exact meeting point; upon connection, extract, densify, shortcut, visibility-prune, and return.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=6.0,\n        connect_mult=2.0,\n        goal_bias=0.12,\n        grid_cell_factor=1.6,\n        rewire_base=2.2,\n        smooth_iters=120\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_mult = float(connect_mult)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.rewire_base = float(rewire_base)\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.connect_step = max(self.step, self.step * self.connect_mult)\n        self.dup_radius = max(0.5, 0.4 * self.step)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            Ta = tree_a if active_start else tree_b\n            Tb = tree_b if active_start else tree_a\n            Ga = grid_a if active_start else grid_b\n            Gb = grid_b if active_start else grid_a\n            attractor = self.goal if active_start else self.start\n\n            sample = self._sample(attractor, best_len)\n            if sample is None:\n                continue\n\n            na = self._nearest(Ga, sample)\n            if na is None:\n                continue\n\n            newp = self._steer(na.position, sample, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(Ga, newp, self.dup_radius):\n                continue\n            if not self._edge_free(na.position, newp):\n                continue\n\n            rew_rad = self._adaptive_rewire_radius(len(Ta))\n            parent, new_cost = self._choose_parent(Ga, newp, na, rew_rad)\n\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            Ta.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(Ga, nn)\n\n            self._local_rewire(Ga, nn, rew_rad, edges)\n\n            meet_node, reached = self._connect_toward(Tb, Gb, nn.position, nodes, edges)\n            if reached:\n                if active_start:\n                    pa = self._trace_to_root(nn)        # start -> ... -> nn\n                    pb = self._trace_to_root(meet_node) # goal  -> ... -> nn\n                    path = pa + pb[-2::-1]              # avoid duplicate nn\n                else:\n                    pa = self._trace_to_root(meet_node) # start -> ... -> nn\n                    pb = self._trace_to_root(nn)        # goal  -> ... -> nn\n                    path = pa + pb[-2::-1]\n\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 13) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found_any = False\n        for r in range(0, 4):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found_any = True\n            if found_any:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius)) > 0\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.2)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parenting and rewiring\n    def _choose_parent(self, grid, newp, fallback, radius):\n        parent = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        neigh = self._neighbors_in_radius(grid, newp, radius)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                parent = n\n                best_cost = c\n        return parent, best_cost\n\n    def _local_rewire(self, grid, nn, radius, edges):\n        neigh = self._neighbors_in_radius(grid, nn.position, radius)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            cand = nn.cost + self._dist(nn.position, nb.position)\n            if cand + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                nn.add_child(nb)\n                nb.cost = cand\n                edges.append((nn, nb))\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        try:\n            idx = edges.index(e)\n            edges.pop(idx)\n        except:\n            pass\n\n    def _adaptive_rewire_radius(self, n_nodes):\n        # Shrink with tree size without log; simple exponential decay\n        base = max(self.step * 1.2, self.step * self.rewire_base)\n        decay = pow(0.5, n_nodes / 2500.0)\n        return max(self.step * 1.2, base * decay)\n\n    # BiRRT-Connect growth from other tree toward target; insert exact meeting node if visible\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < 64:\n            if self._edge_free(cur.position, target_pos):\n                # Insert the exact meeting point for a clean junction\n                if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                    if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        cur.add_child(nn)\n                        tree.append(nn)\n                        nodes.append(nn)\n                        edges.append((cur, nn))\n                        self._grid_add(grid, nn)\n                        return nn, True\n                # If too close, treat current as meeting node\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(grid, nxt, self.dup_radius * 0.75):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n        # Final try after capped steps\n        if self._edge_free(cur.position, target_pos):\n            if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    edges.append((cur, nn))\n                    self._grid_add(grid, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.55:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _densify(self, pts, seg_len):\n        if len(pts) < 2:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts)):\n            a = out[-1]\n            b = pts[i]\n            d = self._dist(a, b)\n            if d <= seg_len * 1.05:\n                out.append(b)\n                continue\n            nseg = int(d / seg_len)\n            if nseg < 1:\n                out.append(b)\n                continue\n            for k in range(1, nseg + 1):\n                t = k / float(nseg + 1)\n                inter = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n                if self._edge_free(out[-1], inter):\n                    out.append(inter)\n                else:\n                    break\n            if self._edge_free(out[-1], b):\n                out.append(b)\n            else:\n                out.append(b)\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._densify(path, seg_len=max(1.0, 0.5 * self.step))\n        p1 = self._shortcut(p0, self.smooth_iters)\n        p2 = self._visibility_prune(p1)\n        p3 = self._shortcut(p2, max(20, self.smooth_iters // 2))\n        return self._dedup(p3)",
                "objective": -39.95809,
                "time_improvement": 69.0,
                "length_improvement": 21.0,
                "smoothness_improvement": 1361.0,
                "node_improvement": 85.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.008446240425109863,
                        "num_nodes_avg": 40.0,
                        "path_length_avg": 154.00203649529243,
                        "smoothness_avg": 0.0463463750398735,
                        "success_improvement": 0.0,
                        "time_improvement": 65.76490472936995,
                        "node_improvement": 89.92697053638882,
                        "length_improvement": 15.589043478498803,
                        "smoothness_improvement": 625.4214121382626,
                        "objective_score": 32.21000456660158
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.02304682731628418,
                        "num_nodes_avg": 136.0,
                        "path_length_avg": 230.09301068249903,
                        "smoothness_avg": 0.08849989105200873,
                        "success_improvement": 0.0,
                        "time_improvement": 86.220263890156,
                        "node_improvement": 90.86205738090439,
                        "length_improvement": 23.188330174083777,
                        "smoothness_improvement": 2177.1659406631616,
                        "objective_score": 50.66490697481287
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.02282891273498535,
                        "num_nodes_avg": 204.0,
                        "path_length_avg": 115.03810237530747,
                        "smoothness_avg": 0.10863321186734835,
                        "success_improvement": 0.0,
                        "time_improvement": 54.77338134763434,
                        "node_improvement": 74.06230133502861,
                        "length_improvement": 23.597169928095134,
                        "smoothness_improvement": 1281.8064364830614,
                        "objective_score": 36.99934854356269
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "BLITZ-BiRRT: Ultra-fast bidirectional RRT-Connect with hashed k-nearest parenting, single-hop connection, and capped leaf-only rewiring. It minimizes work per iteration, avoids chain growth in the passive tree, uses fast-decaying neighbor radii, and finishes with quick visibility pruning and few shortcuts.",
            "planning_mechanism": "Alternate expansions from start and goal: sample with goal/informed bias, steer one step, pick the best parent among k local hashed neighbors, insert after node and edge checks, optionally rewire a few leaf neighbors, then attempt a single line-of-sight connect from the opposite tree by inserting only the exact meeting node. On success, extract and quickly prune/shortcut the path; else continue.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=7.5,\n        goal_bias=0.2,\n        grid_cell_factor=1.6,\n        k_near=8,\n        ring_cap=2,\n        rewire_k=3,\n        smooth_iters=50\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.k_near = int(max(1, k_near))\n        self.ring_cap = int(max(1, ring_cap))\n        self.rewire_k = int(max(0, rewire_k))\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.5, 0.45 * self.step)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            Ta = tree_a if active_start else tree_b\n            Tb = tree_b if active_start else tree_a\n            Ga = grid_a if active_start else grid_b\n            Gb = grid_b if active_start else grid_a\n            attractor = self.goal if active_start else self.start\n\n            sample = self._sample(attractor, best_len)\n            if sample is None:\n                continue\n\n            near = self._nearest_limited(Ga, sample)\n            if near is None:\n                continue\n\n            newp = self._steer(near.position, sample, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(Ga, newp, self.dup_radius):\n                continue\n\n            parent, pcost = self._choose_parent_knn(Ga, newp, near, len(Ta))\n            if parent is None:\n                continue\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, pcost)\n            parent.add_child(nn)\n            Ta.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(Ga, nn)\n\n            if self.rewire_k > 0:\n                self._leaf_rewire(Ga, nn, self.rewire_k, edges)\n\n            meet_node, reached = self._try_direct_connect(Tb, Gb, nn.position, nodes, edges)\n            if reached:\n                if active_start:\n                    pa = self._trace_to_root(nn)\n                    pb = self._trace_to_root(meet_node)\n                    path = pa + pb[-2::-1]\n                else:\n                    pa = self._trace_to_root(meet_node)\n                    pb = self._trace_to_root(nn)\n                    path = pa + pb[-2::-1]\n\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 17) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(min(max(a[i], 0.0), self.bounds[i]) for i in range(self.dim))\n        if d2 <= step * step:\n            tgt = b\n        else:\n            d = d2 ** 0.5\n            r = step / d\n            tgt = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n        return tuple(min(max(tgt[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Spatial hash grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest_limited(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, self.ring_cap + 1):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback limited scan\n        cnt = 0\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                cnt += 1\n                if cnt >= 128:\n                    return best\n        return best\n\n    def _k_nearest_limited(self, grid, pos, k):\n        key = self._cell_key(pos)\n        cand = []\n        for r in range(0, self.ring_cap + 1):\n            cand.extend(self._grid_collect_ring(grid, key, r))\n            if len(cand) >= k:\n                break\n        if len(cand) < k:\n            for lst in grid.values():\n                cand.extend(lst)\n                if len(cand) >= 4 * k:\n                    break\n        # select k closest\n        scored = []\n        seen = set()\n        for n in cand:\n            if n in seen:\n                continue\n            seen.add(n)\n            scored.append((self._dist2(n.position, pos), n))\n        scored.sort(key=lambda x: x[0])\n        out = []\n        for i in range(min(k, len(scored))):\n            out.append(scored[i][1])\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell) + 1)\n        r2 = radius * radius\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                return True\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            return True\n        return False\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.2)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parenting and lightweight rewiring\n    def _parent_radius(self, n_nodes):\n        base = self.step * 2.0\n        decay = pow(0.35, n_nodes / 2000.0)\n        return max(self.step * 1.1, base * decay)\n\n    def _choose_parent_knn(self, grid, newp, fallback, n_nodes):\n        cand = self._k_nearest_limited(grid, newp, self.k_near)\n        if fallback not in cand:\n            cand.append(fallback)\n        scored = []\n        for n in cand:\n            c = n.cost + self._dist(n.position, newp)\n            scored.append((c, n))\n        scored.sort(key=lambda x: x[0])\n        for c, n in scored:\n            if self._edge_free(n.position, newp):\n                return n, c\n        # fallback if none visible\n        if self._edge_free(fallback.position, newp):\n            return fallback, fallback.cost + self._dist(fallback.position, newp)\n        return None, 0.0\n\n    def _leaf_rewire(self, grid, nn, k, edges):\n        neigh = self._k_nearest_limited(grid, nn.position, k + 2)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            if len(nb.children) != 0:\n                continue\n            cand_cost = nn.cost + self._dist(nn.position, nb.position)\n            if cand_cost + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                nn.add_child(nb)\n                nb.cost = cand_cost\n                edges.append((nn, nb))\n\n    def _remove_edge(self, edges, e):\n        try:\n            idx = edges.index(e)\n            edges.pop(idx)\n        except:\n            pass\n\n    # Single-hop connect\n    def _try_direct_connect(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest_limited(grid, target_pos)\n        if cur is None:\n            return None, False\n        if self._edge_free(cur.position, target_pos):\n            if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    edges.append((cur, nn))\n                    self._grid_add(grid, nn)\n                    return nn, True\n                return cur, True\n        return cur, False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.6:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(20):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._visibility_prune(path)\n        p2 = self._shortcut(p1, self.smooth_iters)\n        return self._dedup(p2)",
            "objective": -39.63489,
            "time_improvement": 74.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 1481.0,
            "node_improvement": 91.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0037497520446777345,
                    "num_nodes_avg": 34.0,
                    "path_length_avg": 158.58377479850697,
                    "smoothness_avg": 0.06862027615570403,
                    "success_improvement": 0.0,
                    "time_improvement": 84.80115269876273,
                    "node_improvement": 91.4379249559305,
                    "length_improvement": 13.07772011221747,
                    "smoothness_improvement": 974.0563331514488,
                    "objective_score": 38.157259542716545
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028076863288879393,
                    "num_nodes_avg": 111.0,
                    "path_length_avg": 232.17028789754096,
                    "smoothness_avg": 0.0872747392675918,
                    "success_improvement": 0.0,
                    "time_improvement": 83.21279707599672,
                    "node_improvement": 92.54182624470873,
                    "length_improvement": 22.494875248593353,
                    "smoothness_improvement": 2145.641902808952,
                    "objective_score": 49.18897378599979
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02327275276184082,
                    "num_nodes_avg": 98.0,
                    "path_length_avg": 128.55489761473706,
                    "smoothness_avg": 0.11192261290302685,
                    "success_improvement": 0.0,
                    "time_improvement": 53.89408482264104,
                    "node_improvement": 87.53973299427845,
                    "length_improvement": 14.619958130688596,
                    "smoothness_improvement": 1323.6473748585636,
                    "objective_score": 31.55843719949829
                }
            ],
            "success_rate": 1.0
        },
        "objective": 42.4,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Broad neighbor searches with slowly shrinking radii lead to large candidate sets, frequent global scans, and many collision checks per iteration.\n   - Connection growth in the opposite tree creates long chains, inflating node/edge counts and degrading query performance over time.\n   - Extensive rewiring updates many neighbors, triggers subtree cost recomputations, and uses costly edge removals, yielding near-quadratic overhead as trees scale.\n   - Post-processing relies on densification and many shortcut iterations, adding significant latency after a solution is found.\n   - Redundant feasibility checks and late rejection of invalid parents waste compute on samples that will be discarded."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Capped spatial search and k-nearest parenting to bound neighbor sets and avoid global scans.\n   - Single-hop direct connection that inserts only the meeting node, preventing passive-tree chain growth.\n   - Leaf-only, k-limited rewiring that avoids subtree propagation and expensive edge updates.\n   - Larger expansion step and higher goal/informed sampling bias to reduce node count and speed convergence.\n   - Lightweight finalize stage (visibility prune + few shortcuts) without densification to cut post-processing time.\n   - Slightly stricter duplicate-radius filtering to suppress near-duplicate insertions.\n2. Expected mechanism of impact:\n   - Per-iteration work is bounded, reducing collision checks and neighbor evaluations.\n   - Tree size remains compact, lowering costs of spatial lookup, nearest queries, and collision testing as planning progresses.\n   - Eliminates costly cost-propagation and linear-time edge operations during rewires.\n   - Fewer nodes and stronger directional bias shorten the search and increase the chance of early connections.\n   - Shorter smoothing pipeline yields near-instant usable paths with minimal quality trade-off, improving wall-clock time."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "SAGE-RRT*: a simple, adaptive, goal-enabled RRT* that emphasizes short, smooth paths with minimal overhead. It couples cost-based parent selection, local rewiring, and an immediate grandparent straightener with informed sampling after the first solution. Opportunistic goal bridging finds an early path; subsequent focused samples, incremental rewiring, and final LOS/shortcut smoothing reduce length and kinks while keeping checks lightweight.",
                "planning_mechanism": "Grow a single tree from start. For each target (goal/uniform/informed), steer a step from the nearest node, validate node and edge, then choose the cheapest visible parent among neighbors and insert. Perform a quick ancestor straightening and rewire neighbors that become cheaper via the new node. On every insert, attempt a direct connection to the goal; once any solution is found, sample within the start\u2013goal ellipse (c \u2264 c_best) to refine. Return the best path after LOS collapse and randomized shortcutting.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            i = 0\n            while i < len(self.parent.children):\n                if self.parent.children[i] is self:\n                    self.parent.children.pop(i)\n                    break\n                i += 1\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 goal_bias=0.25,\n                 cell_factor=1.6,\n                 rewire_factor=2.6,\n                 dupe_radius_ratio=0.3,\n                 smooth_shortcuts=100):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.cell_factor = float(cell_factor)\n        self.rewire_factor = float(rewire_factor)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self._rng = 246813579\n\n    def plan(self, map):\n        # Scene\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n\n        # Basic checks\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._build_obs_grid()\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Parameters derived\n        self.cell = max(1.0, self.step * self.cell_factor)\n        self.dupe_radius = max(0.3, self.dupe_ratio * self.step)\n        self.rewire_radius = max(1.5 * self.step, self.rewire_factor * self.step)\n\n        # Data holders\n        self._nodes = []\n        self._edges = []\n\n        # Tree and grid\n        root = Node(self.start, None, 0.0)\n        self._nodes.append(root)\n        self._grid = {}\n        self._grid_add(root)\n\n        # Solution tracking\n        self.best_goal = None\n        self.c_best = 1e100\n        self.c_min = self._dist(self.start, self.goal)\n\n        # Main loop\n        stall = 0\n        for it in range(self.max_iter):\n            # Target selection with informed bias after first solution\n            if self.best_goal is not None and self._rand() < 0.55:\n                target = self._sample_informed(self.c_best)\n            else:\n                target = self._sample_target(self.goal)\n\n            if target is None:\n                continue\n\n            qnear = self._nearest(self._grid, target)\n            if qnear is None:\n                qnear = root\n\n            qpos = self._steer(qnear.position, target, self.step)\n            if self._same_pos(qpos, qnear.position):\n                continue\n            if not self._in_bounds(qpos):\n                continue\n            if self._point_blocked(qpos):\n                continue\n            if not self._edge_free(qnear.position, qpos):\n                continue\n            if self._has_close(self._grid, qpos, self.dupe_radius):\n                continue\n\n            # Choose cheapest visible parent among neighbors\n            parent = qnear\n            best_cost = qnear.cost + self._dist(qnear.position, qpos)\n            neigh = self._neighbors(self._grid, qpos, self.rewire_radius)\n            i = 0\n            while i < len(neigh):\n                nb = neigh[i]\n                if nb is qnear:\n                    i += 1\n                    continue\n                dnb = self._dist(nb.position, qpos)\n                cand = nb.cost + dnb\n                if cand + 1e-12 < best_cost and self._edge_free(nb.position, qpos):\n                    parent = nb\n                    best_cost = cand\n                i += 1\n\n            # Insert node\n            new_node = Node(qpos, parent, best_cost)\n            new_node.attach(parent)\n            self._nodes.append(new_node)\n            self._edges.append((parent, new_node))\n            self._grid_add(new_node)\n\n            # Immediate ancestor straightening (grandparent shortcut)\n            gp = parent.parent\n            if gp is not None:\n                if self._edge_free(gp.position, new_node.position):\n                    cand_cost = gp.cost + self._dist(gp.position, new_node.position)\n                    if cand_cost + 1e-12 < new_node.cost:\n                        self._update_parent(new_node, gp, cand_cost)\n\n            # Local rewiring\n            self._rewire_around(new_node)\n\n            improved = False\n\n            # Opportunistic goal bridging\n            if self._edge_free(new_node.position, self.goal):\n                g_cost = new_node.cost + self._dist(new_node.position, self.goal)\n                if self.best_goal is None:\n                    self.best_goal = Node(self.goal, new_node, g_cost)\n                    self.best_goal.attach(new_node)\n                    self._nodes.append(self.best_goal)\n                    self._edges.append((new_node, self.best_goal))\n                    self.c_best = g_cost\n                    improved = True\n                else:\n                    # Try to improve existing goal attachment\n                    if g_cost + 1e-12 < self.c_best:\n                        # Replace goal parent\n                        self._remove_edge(self.best_goal.parent, self.best_goal)\n                        self.best_goal.attach(new_node)\n                        self._edges.append((new_node, self.best_goal))\n                        self.best_goal.cost = g_cost\n                        self.c_best = g_cost\n                        improved = True\n\n            if improved:\n                stall = 0\n            else:\n                stall += 1\n                if self.best_goal is not None and stall > 500:\n                    break\n\n        if self.best_goal is None:\n            return PlannerResult(False, [], self._nodes, self._edges)\n\n        raw_path = self._to_root(self.best_goal)\n        path = self._postprocess(raw_path)\n        return PlannerResult(True, path, self._nodes, self._edges)\n\n    # RNG\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and bounds\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _same_pos(self, a, b, eps=1e-9):\n        for i in range(self.dims):\n            if abs(a[i] - b[i]) > eps:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Obstacle grid\n    def _build_obs_grid(self):\n        self.obs_cell = max(4.0, self.step * 2.0)\n        self._ogrid = {}\n        if self.is3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self._ogrid.get(k)\n                            if b is None:\n                                self._ogrid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self._ogrid.get(k)\n                        if b is None:\n                            self._ogrid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _cell_candidates(self, a, b):\n        if self.is3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            out = []\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        lst = self._ogrid.get((cx, cy, cz))\n                        if lst:\n                            out.extend(lst)\n            return out\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            out = []\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    lst = self._ogrid.get((cx, cy))\n                    if lst:\n                        out.extend(lst)\n            return out\n\n    def _point_blocked(self, p):\n        if self.is3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self._ogrid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x0, y0, z0 = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= x0 <= x + w and y <= y0 <= y + h and z <= z0 <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self._ogrid.get((cx, cy))\n            if not bucket:\n                return False\n            x0, y0 = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= x0 <= x + w and y <= y0 <= y + h:\n                    return True\n            return False\n\n    def _seg_aabb_hit(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(self.dims):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        cand = self._cell_candidates(a, b)\n        if not cand:\n            return True\n        if self.is3d:\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_hit(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return False\n            return True\n        else:\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_hit(a, b, (x, y), (x + w, y + h)):\n                    return False\n            return True\n\n    # Node proximity grid\n    def _cell_key(self, pos):\n        if self.is3d:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, node):\n        k = self._cell_key(node.position)\n        b = self._grid.get(k)\n        if b is None:\n            self._grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, key, r):\n        out = []\n        if self.is3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = self._grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = self._grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos):\n        k = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        # Expand rings up to a reasonable bound\n        max_r = 3\n        for r in range(0, max_r + 1):\n            cand = self._grid_ring(k, r)\n            if cand:\n                i = 0\n                while i < len(cand):\n                    n = cand[i]\n                    d = self._dist(n.position, pos)\n                    if d < bd:\n                        bd = d\n                        best = n\n                    i += 1\n                if best is not None:\n                    return best\n        # Fallback scan\n        for b in grid.values():\n            i = 0\n            while i < len(b):\n                n = b[i]\n                d = self._dist(n.position, pos)\n                if d < bd:\n                    bd = d\n                    best = n\n                i += 1\n        return best\n\n    def _neighbors(self, grid, pos, radius):\n        k = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell) + 1)\n        lst = self._grid_ring(k, rc)\n        out = []\n        r2 = radius * radius\n        i = 0\n        while i < len(lst):\n            n = lst[i]\n            s = 0.0\n            p = n.position\n            for j in range(self.dims):\n                d = p[j] - pos[j]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n            i += 1\n        return out\n\n    def _has_close(self, grid, pos, radius):\n        k = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell) + 1)\n        lst = self._grid_ring(k, rc)\n        r2 = radius * radius\n        i = 0\n        while i < len(lst):\n            n = lst[i]\n            s = 0.0\n            p = n.position\n            for j in range(self.dims):\n                d = p[j] - pos[j]\n                s += d * d\n            if s <= r2:\n                return True\n            i += 1\n        return False\n\n    # Rewiring utilities\n    def _remove_edge(self, parent, child):\n        i = 0\n        while i < len(self._edges):\n            e = self._edges[i]\n            if e[0] is parent and e[1] is child:\n                self._edges.pop(i)\n                return\n            i += 1\n\n    def _update_parent(self, node, new_parent, new_cost):\n        old_parent = node.parent\n        if old_parent is new_parent:\n            node.cost = new_cost\n            return\n        self._remove_edge(old_parent, node)\n        node.attach(new_parent)\n        self._edges.append((new_parent, node))\n        delta = new_cost - node.cost\n        node.cost = new_cost\n        if abs(delta) > 1e-12:\n            self._propagate_cost(node, delta)\n\n    def _propagate_cost(self, node, delta):\n        stack = list(node.children)\n        while stack:\n            cur = stack.pop()\n            cur.cost += delta\n            if cur.children:\n                stack.extend(cur.children)\n\n    def _rewire_around(self, new_node):\n        neigh = self._neighbors(self._grid, new_node.position, self.rewire_radius)\n        i = 0\n        while i < len(neigh):\n            nb = neigh[i]\n            if nb is new_node or nb is new_node.parent:\n                i += 1\n                continue\n            d = self._dist(new_node.position, nb.position)\n            cand_cost = new_node.cost + d\n            if cand_cost + 1e-12 < nb.cost and self._edge_free(new_node.position, nb.position):\n                self._update_parent(nb, new_node, cand_cost)\n            i += 1\n\n    # Sampling\n    def _sample_target(self, attractor):\n        r = self._rand()\n        if r < self.goal_bias:\n            return attractor\n        return self._random_free()\n\n    def _random_free(self):\n        for _ in range(64):\n            if self.is3d:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if not self._point_blocked(p):\n                return p\n        # Fallback to a clamped center if repeated failures\n        if self.is3d:\n            c = (self.bounds[0] * 0.5, self.bounds[1] * 0.5, self.bounds[2] * 0.5)\n        else:\n            c = (self.bounds[0] * 0.5, self.bounds[1] * 0.5)\n        return self._clamp(c)\n\n    def _sample_informed(self, c_best):\n        # Rejection sampling inside the start-goal ellipse: ||x-s|| + ||x-g|| <= c_best\n        tries = 64\n        while tries > 0:\n            tries -= 1\n            p = self._random_free()\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= c_best + 1e-9:\n                return p\n        return self._random_free()\n\n    # Path utilities\n    def _to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    # Smoothing\n    def _los_collapse(self, path, rounds=3):\n        if len(path) < 3:\n            return path[:]\n        cur = path[:]\n        for _ in range(rounds):\n            out = [cur[0]]\n            anchor = cur[0]\n            i = 1\n            while i < len(cur) - 1:\n                if self._edge_free(anchor, cur[i + 1]):\n                    i += 1\n                    continue\n                out.append(cur[i])\n                anchor = cur[i]\n                i += 1\n            out.append(cur[-1])\n            if len(out) == len(cur):\n                break\n            cur = out\n        return cur\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        best = self._path_len(pts)\n        tries = 0\n        while tries < attempts and len(pts) >= 3:\n            n = len(pts)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j >= n:\n                tries += 1\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    pts = cand\n                    best = L\n            tries += 1\n        return pts\n\n    def _postprocess(self, path):\n        p = path[:]\n        p = self._los_collapse(p, rounds=3)\n        p = self._shortcut(p, self.smooth_shortcuts)\n        p = self._los_collapse(p, rounds=2)\n        return p",
                "objective": 247.09447,
                "time_improvement": -891.0,
                "length_improvement": 24.0,
                "smoothness_improvement": 1175.0,
                "node_improvement": -99.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.41948857307434084,
                        "num_nodes_avg": 1222.4,
                        "path_length_avg": 146.67470481344606,
                        "smoothness_avg": 0.037681881817291075,
                        "success_improvement": 0.0,
                        "time_improvement": -1600.310498082218,
                        "node_improvement": -207.8317804079577,
                        "length_improvement": 19.605270082319457,
                        "smoothness_improvement": 489.80327795666636,
                        "objective_score": -465.88097098549036
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.5094226598739624,
                        "num_nodes_avg": 1476.5,
                        "path_length_avg": 220.36455360152672,
                        "smoothness_avg": 0.07599133449472327,
                        "success_improvement": 0.0,
                        "time_improvement": -204.58464955296049,
                        "node_improvement": 0.7928509037156457,
                        "length_improvement": 26.43596916582338,
                        "smoothness_improvement": 1855.3117708950872,
                        "objective_score": -36.23725451191868
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.4885305166244507,
                        "num_nodes_avg": 1484.2,
                        "path_length_avg": 112.21087384877463,
                        "smoothness_avg": 0.10062767702074307,
                        "success_improvement": 0.0,
                        "time_improvement": -867.8333625393041,
                        "node_improvement": -88.70947234583599,
                        "length_improvement": 25.474880497263015,
                        "smoothness_improvement": 1179.976624141358,
                        "objective_score": -239.16519734272663
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "SWIFT-Connect: a lean bidirectional RRT-Connect with spatial hashing and duplicate suppression. It alternates tree growth, validates nodes and edges before commitment, greedily connects to the opposite tree, and exits on the first feasible bridge. Lightweight LOS collapse and shortcutting polish the path. The design trades heavy optimization for fast, robust, generalizable solves.",
            "planning_mechanism": "Alternate expanding start and goal trees. For each goal-biased sample, extend the active tree one validated step, then greedily advance the opposite tree toward it with multi-step connect; on a collision-free join, assemble the path and smooth via LOS and random shortcuts. Nearest lookups use a coarse grid; all samples stay within bounds and all nodes/edges are collision-checked before insertion.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            i = 0\n            while i < len(self.parent.children):\n                if self.parent.children[i] is self:\n                    self.parent.children.pop(i)\n                    break\n                i += 1\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 goal_bias=0.3,\n                 cell_factor=1.6,\n                 dupe_radius_ratio=0.4,\n                 smooth_shortcuts=80):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.cell_factor = float(cell_factor)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._build_obs_grid()\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        self.cell = max(1.0, self.step * self.cell_factor)\n        self.dupe_radius = max(0.5, self.dupe_ratio * self.step)\n\n        self._nodes = []\n        self._edges = []\n        rootA = Node(self.start, None, 0.0)\n        rootB = Node(self.goal, None, 0.0)\n        self._nodes.append(rootA)\n        self._nodes.append(rootB)\n\n        self._gridA = {}\n        self._gridB = {}\n        self._grid_add(self._gridA, rootA)\n        self._grid_add(self._gridB, rootB)\n\n        for it in range(self.max_iter):\n            use_A = (it % 2 == 0)\n            active_grid = self._gridA if use_A else self._gridB\n            other_grid = self._gridB if use_A else self._gridA\n            attractor = self.goal if use_A else self.start\n\n            target = self._sample_target(attractor)\n            if target is None:\n                continue\n\n            new_node = self._extend_one(active_grid, target)\n            if new_node is None:\n                continue\n\n            q_reached, ok = self._connect_greedy(other_grid, new_node.position)\n            if ok and self._edge_free(q_reached.position, new_node.position):\n                join = Node(new_node.position, q_reached, q_reached.cost + self._dist(q_reached.position, new_node.position))\n                join.attach(q_reached)\n                self._nodes.append(join)\n                self._edges.append((q_reached, join))\n                self._grid_add(other_grid, join)\n\n                if use_A:\n                    path1 = self._trace_to_root(new_node)\n                    path2 = self._trace_to_root(q_reached)\n                    path = path1 + list(reversed(path2))\n                else:\n                    path1 = self._trace_to_root(q_reached)\n                    path2 = self._trace_to_root(new_node)\n                    path = path1 + list(reversed(path2))\n\n                path = self._postprocess(path)\n                return PlannerResult(True, path, self._nodes, self._edges)\n\n        return PlannerResult(False, [], self._nodes, self._edges)\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _same_pos(self, a, b, eps=1e-9):\n        for i in range(self.dims):\n            if abs(a[i] - b[i]) > eps:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    def _build_obs_grid(self):\n        self.obs_cell = max(4.0, self.step * 2.0)\n        self._ogrid = {}\n        if self.is3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self._ogrid.get(k)\n                            if b is None:\n                                self._ogrid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self._ogrid.get(k)\n                        if b is None:\n                            self._ogrid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _cell_candidates(self, a, b):\n        if self.is3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            out = []\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        lst = self._ogrid.get((cx, cy, cz))\n                        if lst:\n                            out.extend(lst)\n            return out\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            out = []\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    lst = self._ogrid.get((cx, cy))\n                    if lst:\n                        out.extend(lst)\n            return out\n\n    def _point_blocked(self, p):\n        if self.is3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self._ogrid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x0, y0, z0 = p\n            i = 0\n            while i < len(bucket):\n                x, y, z, w, h, d = self.obstacles[bucket[i]]\n                if x <= x0 <= x + w and y <= y0 <= y + h and z <= z0 <= z + d:\n                    return True\n                i += 1\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self._ogrid.get((cx, cy))\n            if not bucket:\n                return False\n            x0, y0 = p\n            i = 0\n            while i < len(bucket):\n                x, y, w, h = self.obstacles[bucket[i]]\n                if x <= x0 <= x + w and y <= y0 <= y + h:\n                    return True\n                i += 1\n            return False\n\n    def _seg_aabb_hit(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(self.dims):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        cand = self._cell_candidates(a, b)\n        if not cand:\n            return True\n        if self.is3d:\n            i = 0\n            while i < len(cand):\n                x, y, z, w, h, d = self.obstacles[cand[i]]\n                if self._seg_aabb_hit(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return False\n                i += 1\n            return True\n        else:\n            i = 0\n            while i < len(cand):\n                x, y, w, h = self.obstacles[cand[i]]\n                if self._seg_aabb_hit(a, b, (x, y), (x + w, y + h)):\n                    return False\n                i += 1\n            return True\n\n    def _cell_key(self, pos):\n        if self.is3d:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3d:\n            dx = -r\n            while dx <= r:\n                dy = -r\n                while dy <= r:\n                    dz = -r\n                    while dz <= r:\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n                        dz += 1\n                    dy += 1\n                dx += 1\n        else:\n            dx = -r\n            while dx <= r:\n                dy = -r\n                while dy <= r:\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n                    dy += 1\n                dx += 1\n        return out\n\n    def _nearest(self, grid, pos):\n        k = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        max_r = 2\n        r = 0\n        while r <= max_r:\n            cand = self._grid_ring(grid, k, r)\n            if cand:\n                i = 0\n                while i < len(cand):\n                    n = cand[i]\n                    d = self._dist(n.position, pos)\n                    if d < bd:\n                        bd = d\n                        best = n\n                    i += 1\n                if best is not None:\n                    return best\n            r += 1\n        for b in grid.values():\n            i = 0\n            while i < len(b):\n                n = b[i]\n                d = self._dist(n.position, pos)\n                if d < bd:\n                    bd = d\n                    best = n\n                i += 1\n        return best\n\n    def _has_close(self, grid, pos, radius):\n        k = self._cell_key(pos)\n        rc = max(1, int(radius // self.cell) + 1)\n        lst = self._grid_ring(grid, k, rc)\n        r2 = radius * radius\n        i = 0\n        while i < len(lst):\n            n = lst[i]\n            s = 0.0\n            p = n.position\n            j = 0\n            while j < self.dims:\n                d = p[j] - pos[j]\n                s += d * d\n                j += 1\n            if s <= r2:\n                return True\n            i += 1\n        return False\n\n    def _extend_one(self, grid, target):\n        qnear = self._nearest(grid, target)\n        if qnear is None:\n            return None\n        qpos = self._steer(qnear.position, target, self.step)\n        if self._same_pos(qpos, qnear.position):\n            return None\n        if not self._in_bounds(qpos):\n            return None\n        if self._point_blocked(qpos):\n            return None\n        if not self._edge_free(qnear.position, qpos):\n            return None\n        if self._has_close(grid, qpos, self.dupe_radius):\n            return None\n        new_node = Node(qpos, qnear, qnear.cost + self._dist(qnear.position, qpos))\n        new_node.attach(qnear)\n        self._nodes.append(new_node)\n        self._edges.append((qnear, new_node))\n        self._grid_add(grid, new_node)\n        return new_node\n\n    def _connect_greedy(self, grid, target_pos):\n        qnear = self._nearest(grid, target_pos)\n        if qnear is None:\n            return None, False\n        cur = qnear\n        max_steps = max(1, int(self._dist(qnear.position, target_pos) / max(1e-9, self.step)) + 2)\n        if max_steps > 64:\n            max_steps = 64\n        steps = 0\n        while steps < max_steps:\n            if self._dist(cur.position, target_pos) <= self.step and self._edge_free(cur.position, target_pos):\n                return cur, True\n            qpos = self._steer(cur.position, target_pos, self.step)\n            if self._same_pos(qpos, cur.position):\n                break\n            if not self._in_bounds(qpos):\n                break\n            if self._point_blocked(qpos):\n                break\n            if not self._edge_free(cur.position, qpos):\n                break\n            if self._has_close(grid, qpos, self.dupe_radius):\n                break\n            nxt = Node(qpos, cur, cur.cost + self._dist(cur.position, qpos))\n            nxt.attach(cur)\n            self._nodes.append(nxt)\n            self._edges.append((cur, nxt))\n            self._grid_add(grid, nxt)\n            cur = nxt\n            steps += 1\n        return cur, False\n\n    def _sample_target(self, attractor):\n        if self._rand() < self.goal_bias:\n            return attractor\n        return self._random_free()\n\n    def _random_free(self):\n        tries = 64\n        while tries > 0:\n            tries -= 1\n            if self.is3d:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if not self._point_blocked(p):\n                return p\n        return None\n\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        i = 1\n        while i < len(path):\n            s += self._dist(path[i - 1], path[i])\n            i += 1\n        return s\n\n    def _los_collapse(self, path, rounds=3):\n        if len(path) < 3:\n            return path[:]\n        cur = path[:]\n        r = 0\n        while r < rounds:\n            out = [cur[0]]\n            anchor = cur[0]\n            i = 1\n            while i < len(cur) - 1:\n                if self._edge_free(anchor, cur[i + 1]):\n                    i += 1\n                    continue\n                out.append(cur[i])\n                anchor = cur[i]\n                i += 1\n            out.append(cur[-1])\n            if len(out) == len(cur):\n                break\n            cur = out\n            r += 1\n        return cur\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        best = self._path_len(pts)\n        t = 0\n        while t < attempts and len(pts) >= 3:\n            n = len(pts)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n - 1:\n                t += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    pts = cand\n                    best = L\n            t += 1\n        return pts\n\n    def _postprocess(self, path):\n        p = path[:]\n        p = self._los_collapse(p, rounds=3)\n        p = self._shortcut(p, self.smooth_shortcuts)\n        p = self._los_collapse(p, rounds=2)\n        return p",
            "objective": -41.85803,
            "time_improvement": 74.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 1880.0,
            "node_improvement": 82.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007715272903442383,
                    "num_nodes_avg": 73.0,
                    "path_length_avg": 160.85834898192107,
                    "smoothness_avg": 0.04902467731266237,
                    "success_improvement": 0.0,
                    "time_improvement": 68.72773096737596,
                    "node_improvement": 81.6167212289096,
                    "length_improvement": 11.83098995935377,
                    "smoothness_improvement": 667.3426587338824,
                    "objective_score": 31.05362655949446
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.025490784645080568,
                    "num_nodes_avg": 183.3,
                    "path_length_avg": 234.9419709193859,
                    "smoothness_avg": 0.12316192274741442,
                    "success_improvement": 0.0,
                    "time_improvement": 84.75901776753946,
                    "node_improvement": 87.68393469058657,
                    "length_improvement": 21.56960767742916,
                    "smoothness_improvement": 3069.0449822382448,
                    "objective_score": 53.71469484791056
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.015743160247802736,
                    "num_nodes_avg": 173.6,
                    "path_length_avg": 123.84164743815386,
                    "smoothness_avg": 0.15742682886839948,
                    "success_improvement": 0.0,
                    "time_improvement": 68.81104618621191,
                    "node_improvement": 77.92752701843611,
                    "length_improvement": 17.75027447711989,
                    "smoothness_improvement": 1902.4576431662642,
                    "objective_score": 40.80576675796682
                }
            ],
            "success_rate": 1.0
        },
        "objective": -341.6,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Excessive local optimization overhead (neighbor scans for parent selection and rewiring), with costly linear-time structure updates during reparenting, leading to near-quadratic growth in maintenance costs.\n   - Nearest-neighbor lookups frequently falling back to full scans due to shallow grid search, inflating per-iteration time.\n   - Rejection-heavy sampling that wastes iterations on invalid/low-utility targets; fallback targets can still be unhelpful in clutter.\n   - Large connection/rewire neighborhoods driving many redundant collision checks per insert.\n   - Duplicate-pruning and feasibility checks ordered late, performing collision tests on nodes later discarded.\n   - Continued refinement after a first solution (goal reattachment/stall loops) extending runtime without proportional gains."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Bidirectional growth with greedy multi-step connections that bridge trees quickly and stop at the first feasible join.\n   - Elimination of rewiring and neighbor-based parent optimization, removing heavy neighbor scans and reparent bookkeeping.\n   - Tighter duplicate suppression and early feasibility gating that prevent near-duplicate insertions and abort weak expansions early.\n   - Per-tree spatial hashing with small search rings and reduced node counts per tree, improving nearest queries.\n   - Simpler post-processing and no goal-refinement loop, avoiding extra iterations after a feasible path is found.\n2. Expected mechanism of impact:\n   - Fewer iterations to reach connectivity by directly targeting the opposite tree.\n   - Lower per-iteration cost via reduced neighbor/collision checks and avoidance of O(N^2) maintenance.\n   - Smaller working sets (nodes/edges) per tree, decreasing scan and hashing overhead.\n   - Less wasted work from rejected samples and late duplicate detection, improving effective expansion throughput."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "SAGE-Connect: A simplified adaptive BiRRT-Connect with local cost-aware parenting and light rewiring. It uses a uniform spatial hash for nearest/neighbor queries, coarse obstacle binning for fast collision checks, adaptive rewire radius, and minimal biased/informed sampling. It inserts only strictly node- and edge-free states, creates the exact meeting node to reduce kinks, and applies a compact densify+shortcut+visibility smoother for short, smooth paths.",
                "planning_mechanism": "Alternate growth from start/goal trees: sample (uniform with small goal bias; ellipse after first solution), steer one step, choose the best-cost parent among nearby nodes, add after node+edge checks, locally rewire cheaper neighbors, then greedily extend the opposite tree toward the new node and insert the exact meeting point; upon connection, extract, densify, shortcut, visibility-prune, and return.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=6.0,\n        connect_mult=2.0,\n        goal_bias=0.12,\n        grid_cell_factor=1.6,\n        rewire_base=2.2,\n        smooth_iters=120\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_mult = float(connect_mult)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.rewire_base = float(rewire_base)\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.connect_step = max(self.step, self.step * self.connect_mult)\n        self.dup_radius = max(0.5, 0.4 * self.step)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            Ta = tree_a if active_start else tree_b\n            Tb = tree_b if active_start else tree_a\n            Ga = grid_a if active_start else grid_b\n            Gb = grid_b if active_start else grid_a\n            attractor = self.goal if active_start else self.start\n\n            sample = self._sample(attractor, best_len)\n            if sample is None:\n                continue\n\n            na = self._nearest(Ga, sample)\n            if na is None:\n                continue\n\n            newp = self._steer(na.position, sample, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(Ga, newp, self.dup_radius):\n                continue\n            if not self._edge_free(na.position, newp):\n                continue\n\n            rew_rad = self._adaptive_rewire_radius(len(Ta))\n            parent, new_cost = self._choose_parent(Ga, newp, na, rew_rad)\n\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            Ta.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(Ga, nn)\n\n            self._local_rewire(Ga, nn, rew_rad, edges)\n\n            meet_node, reached = self._connect_toward(Tb, Gb, nn.position, nodes, edges)\n            if reached:\n                if active_start:\n                    pa = self._trace_to_root(nn)        # start -> ... -> nn\n                    pb = self._trace_to_root(meet_node) # goal  -> ... -> nn\n                    path = pa + pb[-2::-1]              # avoid duplicate nn\n                else:\n                    pa = self._trace_to_root(meet_node) # start -> ... -> nn\n                    pb = self._trace_to_root(nn)        # goal  -> ... -> nn\n                    path = pa + pb[-2::-1]\n\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 13) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found_any = False\n        for r in range(0, 4):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found_any = True\n            if found_any:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius)) > 0\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.2)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parenting and rewiring\n    def _choose_parent(self, grid, newp, fallback, radius):\n        parent = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        neigh = self._neighbors_in_radius(grid, newp, radius)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                parent = n\n                best_cost = c\n        return parent, best_cost\n\n    def _local_rewire(self, grid, nn, radius, edges):\n        neigh = self._neighbors_in_radius(grid, nn.position, radius)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            cand = nn.cost + self._dist(nn.position, nb.position)\n            if cand + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                nn.add_child(nb)\n                nb.cost = cand\n                edges.append((nn, nb))\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        try:\n            idx = edges.index(e)\n            edges.pop(idx)\n        except:\n            pass\n\n    def _adaptive_rewire_radius(self, n_nodes):\n        # Shrink with tree size without log; simple exponential decay\n        base = max(self.step * 1.2, self.step * self.rewire_base)\n        decay = pow(0.5, n_nodes / 2500.0)\n        return max(self.step * 1.2, base * decay)\n\n    # BiRRT-Connect growth from other tree toward target; insert exact meeting node if visible\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < 64:\n            if self._edge_free(cur.position, target_pos):\n                # Insert the exact meeting point for a clean junction\n                if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                    if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        cur.add_child(nn)\n                        tree.append(nn)\n                        nodes.append(nn)\n                        edges.append((cur, nn))\n                        self._grid_add(grid, nn)\n                        return nn, True\n                # If too close, treat current as meeting node\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(grid, nxt, self.dup_radius * 0.75):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n        # Final try after capped steps\n        if self._edge_free(cur.position, target_pos):\n            if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    edges.append((cur, nn))\n                    self._grid_add(grid, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.55:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _densify(self, pts, seg_len):\n        if len(pts) < 2:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts)):\n            a = out[-1]\n            b = pts[i]\n            d = self._dist(a, b)\n            if d <= seg_len * 1.05:\n                out.append(b)\n                continue\n            nseg = int(d / seg_len)\n            if nseg < 1:\n                out.append(b)\n                continue\n            for k in range(1, nseg + 1):\n                t = k / float(nseg + 1)\n                inter = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n                if self._edge_free(out[-1], inter):\n                    out.append(inter)\n                else:\n                    break\n            if self._edge_free(out[-1], b):\n                out.append(b)\n            else:\n                out.append(b)\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._densify(path, seg_len=max(1.0, 0.5 * self.step))\n        p1 = self._shortcut(p0, self.smooth_iters)\n        p2 = self._visibility_prune(p1)\n        p3 = self._shortcut(p2, max(20, self.smooth_iters // 2))\n        return self._dedup(p3)",
                "objective": -39.95809,
                "time_improvement": 69.0,
                "length_improvement": 21.0,
                "smoothness_improvement": 1361.0,
                "node_improvement": 85.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.008446240425109863,
                        "num_nodes_avg": 40.0,
                        "path_length_avg": 154.00203649529243,
                        "smoothness_avg": 0.0463463750398735,
                        "success_improvement": 0.0,
                        "time_improvement": 65.76490472936995,
                        "node_improvement": 89.92697053638882,
                        "length_improvement": 15.589043478498803,
                        "smoothness_improvement": 625.4214121382626,
                        "objective_score": 32.21000456660158
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.02304682731628418,
                        "num_nodes_avg": 136.0,
                        "path_length_avg": 230.09301068249903,
                        "smoothness_avg": 0.08849989105200873,
                        "success_improvement": 0.0,
                        "time_improvement": 86.220263890156,
                        "node_improvement": 90.86205738090439,
                        "length_improvement": 23.188330174083777,
                        "smoothness_improvement": 2177.1659406631616,
                        "objective_score": 50.66490697481287
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.02282891273498535,
                        "num_nodes_avg": 204.0,
                        "path_length_avg": 115.03810237530747,
                        "smoothness_avg": 0.10863321186734835,
                        "success_improvement": 0.0,
                        "time_improvement": 54.77338134763434,
                        "node_improvement": 74.06230133502861,
                        "length_improvement": 23.597169928095134,
                        "smoothness_improvement": 1281.8064364830614,
                        "objective_score": 36.99934854356269
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m3",
                "algorithm_description": "Bi-Guide ARC: A bidirectional, goal-aware RRT*-Connect with Adaptive Radius, spatial hashing, subtree cost propagation, and post-planning shortcut smoothing. It balances fast greedy connections with cost-optimal rewiring, focuses samples within an informed ellipsoid after the first solution, and uses a lightweight grid index for efficient nearest/near queries to improve path length and smoothness with lower planning time.",
                "planning_mechanism": "Alternate growing start/goal trees: sample (goal-biased; informed after first path), steer one step, select best parent within an adaptive radius, add if both node and edge are collision-free, locally rewire with subtree cost updates, then attempt a bounded greedy connect of the opposite tree to the new node. Maintain best path and stop upon time/iteration/no-improvement limits; finally apply randomized shortcut smoothing to the best path.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def detach_from_parent(self):\n        if self.parent is not None and self in self.parent.children:\n            self.parent.children.remove(self)\n        self.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 6000,\n        step_size: float = 5.0,\n        goal_bias: float = 0.15,\n        base_radius: float = 35.0,\n        max_radius: float = 60.0,\n        connect_steps: int = 20,\n        post_opt_iters: int = 300,\n        no_improve_limit: int = 180,\n        time_limit_sec: float = 20.0,\n        smooth_attempts: int = 120\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.base_radius = base_radius\n        self.max_radius = max_radius\n        self.connect_steps = connect_steps\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.time_limit_sec = time_limit_sec\n        self.smooth_attempts = smooth_attempts\n\n        # Spatial hash cell size\n        self.cell_size = max(8.0, step_size * 2.0)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Core containers\n        nodes = []\n        edges = []\n        success_state = False\n        best_path = []\n        best_cost = float('inf')\n\n        # Initialize trees and spatial hashes\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Dist between start and goal\n        c_min = self._dist(start_position, goal_position)\n\n        # States\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            # Alternate expansion direction\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n                grid_a, grid_b = grid_start, grid_goal\n                root_a, root_b = start_root, goal_root\n                sample_goal = goal_position\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n                grid_a, grid_b = grid_goal, grid_start\n                root_a, root_b = goal_root, start_root\n                sample_goal = start_position\n\n            # Sampling with goal bias and informed focus\n            x_rand = self._sample(bounds, obstacles, is_3d, start_position, goal_position, best_cost, c_min, sample_goal)\n\n            # Nearest in tree_a\n            a_near = self._nearest(grid_a, tree_a, x_rand, bounds)\n            a_new_pos = self._steer(a_near.position, x_rand, self.step_size)\n\n            # Bound check\n            if not self._in_bounds(a_new_pos, bounds):\n                self._advance_counters(found_first, True)\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Node and edge collision checks before adding\n            if self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n            if self._hit_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Best parent selection within adaptive radius\n            rad = self._adaptive_radius(len(tree_a), dim)\n            neighbors = self._grid_neighbors(grid_a, a_new_pos, rad)\n            if not neighbors:\n                neighbors = [a_near]\n\n            best_parent = None\n            best_g = float('inf')\n            for cand in neighbors:\n                if self._hit_obstacle(cand.position, a_new_pos, obstacles, is_3d):\n                    continue\n                g = cand.cost + self._dist(cand.position, a_new_pos)\n                if g < best_g:\n                    best_g = g\n                    best_parent = cand\n\n            if best_parent is None:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Add new node to tree_a\n            a_new = Node(a_new_pos, parent=None, cost=best_g)\n            best_parent.add_child(a_new)\n            tree_a.append(a_new)\n            nodes.append(a_new)\n            edges.append((best_parent, a_new))\n            self._grid_add(grid_a, a_new)\n\n            # Local rewiring from a_new\n            self._rewire_from(a_new, neighbors, obstacles, is_3d, edges)\n\n            # Attempt to connect tree_b to a_new (bounded)\n            b_meet = self._attempt_connect(tree_b, grid_b, a_new, obstacles, is_3d, bounds, nodes, edges, dim)\n\n            if b_meet is not None:\n                # Merge full path\n                if root_a is start_root:\n                    path_a = a_new.path_from_root()\n                    path_b = b_meet.path_from_root()\n                else:\n                    path_a = b_meet.path_from_root()\n                    path_b = a_new.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged = path_a + path_b[-2::-1]\n                else:\n                    merged = path_a + path_b[::-1]\n\n                cost = self._path_cost(merged)\n                if cost < best_cost - 1e-9:\n                    best_cost = cost\n                    best_path = merged\n                    success_state = True\n                    no_improve = 0\n                else:\n                    no_improve += 1\n\n                if not found_first:\n                    found_first = True\n                    post_iters = 0\n                else:\n                    post_iters += 1\n\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n            else:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n\n        # Final smoothing of best path\n        if success_state and best_path:\n            best_path = self._shortcut_smooth(best_path, obstacles, is_3d, attempts=self.smooth_attempts)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ------------------ Spatial Hash ------------------\n    def _key(self, pos):\n        return tuple(int(pos[d] // self.cell_size) for d in range(len(pos)))\n\n    def _grid_add(self, grid, node):\n        k = self._key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_neighbors(self, grid, pos, radius):\n        # Collect nodes in cells within radius\n        dim = len(pos)\n        span = int(max(1, math.ceil(radius / self.cell_size)))\n        key_center = self._key(pos)\n        result = []\n        if dim == 2:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    k = (key_center[0] + dx, key_center[1] + dy)\n                    if k in grid:\n                        for n in grid[k]:\n                            if self._dist(n.position, pos) <= radius:\n                                result.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        k = (key_center[0] + dx, key_center[1] + dy, key_center[2] + dz)\n                        if k in grid:\n                            for n in grid[k]:\n                                if self._dist(n.position, pos) <= radius:\n                                    result.append(n)\n        return result\n\n    def _nearest(self, grid, tree, pos, bounds):\n        # Try increasing radii using grid; fallback to full scan\n        radius = self.cell_size\n        for _ in range(4):\n            cands = self._grid_neighbors(grid, pos, radius)\n            if cands:\n                return min(cands, key=lambda n: self._dist(n.position, pos))\n            radius *= 2.0\n        return min(tree, key=lambda n: self._dist(n.position, pos))\n\n    # ------------------ Connect Attempt ------------------\n    def _attempt_connect(self, tree, grid, target_node, obstacles, is_3d, bounds, nodes, edges, dim):\n        target_pos = target_node.position\n\n        # Direct connect via best parent in radius\n        rad = self._adaptive_radius(len(tree), dim)\n        neigh = self._grid_neighbors(grid, target_pos, rad)\n        if not neigh:\n            # include nearest if none\n            neigh = [self._nearest(grid, tree, target_pos, bounds)]\n        best_parent = None\n        best_cost = float('inf')\n        for cand in neigh:\n            if self._hit_obstacle(cand.position, target_pos, obstacles, is_3d):\n                continue\n            g = cand.cost + self._dist(cand.position, target_pos)\n            if g < best_cost:\n                best_cost = g\n                best_parent = cand\n        if best_parent is not None and not self._is_in_obstacle(target_pos, obstacles, is_3d):\n            meet = Node(target_pos, parent=None, cost=best_cost)\n            best_parent.add_child(meet)\n            tree.append(meet)\n            nodes.append(meet)\n            edges.append((best_parent, meet))\n            self._grid_add(grid, meet)\n            # Local rewiring at seam improves junction quality\n            seam_neighbors = self._grid_neighbors(grid, target_pos, rad)\n            self._rewire_from(meet, seam_neighbors, obstacles, is_3d, edges)\n            return meet\n\n        # Greedy bounded stepping toward target\n        current = self._nearest(grid, tree, target_pos, bounds)\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(current.position, target_pos, self.step_size)\n            if not self._in_bounds(nxt, bounds):\n                return None\n            if self._is_in_obstacle(nxt, obstacles, is_3d):\n                return None\n            if self._hit_obstacle(current.position, nxt, obstacles, is_3d):\n                return None\n\n            # Insert with best parent among neighbors around nxt\n            neigh2 = self._grid_neighbors(grid, nxt, rad)\n            if not neigh2:\n                neigh2 = [current]\n            best_p = None\n            best_g2 = float('inf')\n            for cand in neigh2:\n                if self._hit_obstacle(cand.position, nxt, obstacles, is_3d):\n                    continue\n                g2 = cand.cost + self._dist(cand.position, nxt)\n                if g2 < best_g2:\n                    best_g2 = g2\n                    best_p = cand\n            if best_p is None:\n                return None\n\n            new_b = Node(nxt, parent=None, cost=best_g2)\n            best_p.add_child(new_b)\n            tree.append(new_b)\n            nodes.append(new_b)\n            edges.append((best_p, new_b))\n            self._grid_add(grid, new_b)\n\n            self._rewire_from(new_b, neigh2, obstacles, is_3d, edges)\n\n            if self._dist(new_b.position, target_pos) <= self.step_size:\n                if (not self._is_in_obstacle(target_pos, obstacles, is_3d)) and (not self._hit_obstacle(new_b.position, target_pos, obstacles, is_3d)):\n                    final_b = Node(target_pos, parent=None, cost=new_b.cost + self._dist(new_b.position, target_pos))\n                    new_b.add_child(final_b)\n                    tree.append(final_b)\n                    nodes.append(final_b)\n                    edges.append((new_b, final_b))\n                    self._grid_add(grid, final_b)\n                    return final_b\n                return None\n\n            current = new_b\n            steps += 1\n\n        return None\n\n    # ------------------ Rewiring ------------------\n    def _rewire_from(self, pivot, neighbors, obstacles, is_3d, edges):\n        for nb in neighbors:\n            if nb is pivot or nb.parent is None:\n                continue\n            if self._hit_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                continue\n            new_cost = pivot.cost + self._dist(pivot.position, nb.position)\n            if new_cost + 1e-12 < nb.cost:\n                old_parent = nb.parent\n                nb.detach_from_parent()\n                pivot.add_child(nb)\n                try:\n                    edges.remove((old_parent, nb))\n                except Exception:\n                    pass\n                edges.append((pivot, nb))\n                delta = new_cost - nb.cost\n                nb.cost = new_cost\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        # BFS update costs down the subtree to maintain coherence\n        queue = [node]\n        while queue:\n            cur = queue.pop(0)\n            for ch in cur.children:\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                queue.append(ch)\n\n    # ------------------ Sampling ------------------\n    def _sample(self, bounds, obstacles, is_3d, start, goal, c_best, c_min, biased_goal):\n        dim = len(bounds)\n        # Goal bias\n        if random.random() < self.goal_bias:\n            target = goal if biased_goal == goal else start\n            if not self._is_in_obstacle(target, obstacles, is_3d):\n                return target\n\n        # Informed sampling after first solution\n        if c_best < float('inf') and c_min > 1e-12:\n            for _ in range(50):\n                x = self._sample_informed_ellipsoid(start, goal, c_best, c_min, bounds)\n                if not self._is_in_obstacle(x, obstacles, is_3d):\n                    return x\n\n        # Uniform fallback\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]), random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_informed_ellipsoid(self, start, goal, c_best, c_min, bounds):\n        # Prolate ellipsoid with foci at start and goal\n        dim = len(bounds)\n        r1 = c_best / 2.0\n        r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        a1 = self._unit(self._vec(goal, start))\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r2)\n        else:\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._unit(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._unit(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r2, r2)\n\n        u = self._sample_unit_ball(dim)\n        x = [center[d] for d in range(dim)]\n        for i in range(dim):\n            for d in range(dim):\n                x[d] += basis[i][d] * radii[i] * u[i]\n        # Clamp to bounds\n        x = tuple(min(max(x[d], 0.0), bounds[d]) for d in range(dim))\n        return x\n\n    def _sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(vi * vi for vi in v))\n            if n > 1e-12:\n                v = [vi / n for vi in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    # ------------------ Geometry/Collision ------------------\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _vec(self, a, b):\n        return tuple(a[i] - b[i] for i in range(len(a)))\n\n    def _norm(self, v):\n        return math.sqrt(sum(vi * vi for vi in v))\n\n    def _unit(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return tuple(0.0 for _ in v)\n        return tuple(vi / n for vi in v)\n\n    def _cross(self, a, b):\n        # Only used in 3D informed sampling\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0.0 <= pos[i] <= bounds[i] for i in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _hit_obstacle(self, a, b, obstacles, is_3d, res=1.0):\n        L = self._dist(a, b)\n        steps = max(1, int(L / res))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(len(a)))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _path_cost(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(len(path) - 1):\n            s += self._dist(path[i], path[i + 1])\n        return s\n\n    # ------------------ Controls ------------------\n    def _adaptive_radius(self, n, dim):\n        if n <= 1:\n            return self.base_radius\n        # RRT* style shrinkage\n        r = self.base_radius * (math.log(n + 1) / (n + 1)) ** (1.0 / dim)\n        r = max(self.step_size * 1.5, min(self.max_radius, r))\n        return r\n\n    def _post_update(self, found_first, post_iters, no_improve):\n        if found_first:\n            post_iters += 1\n            no_improve += 1\n        return post_iters, no_improve\n\n    def _should_stop(self, found_first, post_iters, no_improve):\n        if not found_first:\n            return False\n        if post_iters >= self.post_opt_iters:\n            return True\n        if no_improve >= self.no_improve_limit:\n            return True\n        return False\n\n    # ------------------ Smoothing ------------------\n    def _shortcut_smooth(self, path, obstacles, is_3d, attempts=100):\n        if len(path) < 3:\n            return path[:]\n        best = path[:]\n        best_cost = self._path_cost(best)\n        n = len(best)\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = best[i]\n            b = best[j]\n            if not self._hit_obstacle(a, b, obstacles, is_3d):\n                # shortcut\n                new_path = best[:i + 1] + best[j:]\n                new_cost = self._path_cost(new_path)\n                if new_cost < best_cost - 1e-9:\n                    best = new_path\n                    best_cost = new_cost\n                    n = len(best)\n        # Greedy corner culling\n        changed = True\n        while changed and len(best) > 2:\n            changed = False\n            k = 1\n            while k < len(best) - 1:\n                if not self._hit_obstacle(best[k - 1], best[k + 1], obstacles, is_3d):\n                    best.pop(k)\n                    changed = True\n                else:\n                    k += 1\n        return best",
                "objective": 14.38104,
                "time_improvement": -107.0,
                "length_improvement": 18.0,
                "smoothness_improvement": 1417.0,
                "node_improvement": 44.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.11155118942260742,
                        "num_nodes_avg": 362.3,
                        "path_length_avg": 155.15168551902272,
                        "smoothness_avg": 0.04619305292125599,
                        "success_improvement": 0.0,
                        "time_improvement": -337.47630895645335,
                        "node_improvement": 8.76353563334173,
                        "length_improvement": 14.95890263123767,
                        "smoothness_improvement": 623.021588037589,
                        "objective_score": -89.15244316800546
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.08458755016326905,
                        "num_nodes_avg": 414.7,
                        "path_length_avg": 238.39539805931153,
                        "smoothness_avg": 0.09691449918612544,
                        "success_improvement": 0.0,
                        "time_improvement": 47.197902476841236,
                        "node_improvement": 72.13599408721359,
                        "length_improvement": 20.416754296733227,
                        "smoothness_improvement": 2393.679868751244,
                        "objective_score": 38.37782266484852
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.06439132690429687,
                        "num_nodes_avg": 395.9,
                        "path_length_avg": 123.34270106287966,
                        "smoothness_avg": 0.1047845601402689,
                        "success_improvement": 0.0,
                        "time_improvement": -31.272519594143017,
                        "node_improvement": 49.66306420851876,
                        "length_improvement": 18.081650902303785,
                        "smoothness_improvement": 1232.8518705925312,
                        "objective_score": 7.631494016102023
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "cross_over",
            "algorithm_description": "FENRIR-Connect: A fast, cost-aware BiRRT*-Connect variant with spatial hashing for nodes and obstacles, adaptive neighbor radius, duplicate suppression, and exact seam insertion. It prioritizes early direct-visibility connections, chooses lowest-cost parents, incrementally rewires local neighbors, and finishes with light visibility pruning plus a few randomized shortcuts for short, smooth paths at low planning time.",
            "planning_mechanism": "Alternate expansion from start and goal: sample (goal-biased; informed ellipse after first path), steer one step, pick the best-cost parent within an adaptive radius, add only if node and edge are collision-free, locally rewire cheaper neighbors, then greedily connect the opposite tree and insert the exact meeting point if visible; upon connection, extract and finalize the path via visibility pruning and brief shortcut smoothing, then return.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=5.5,\n        connect_mult=2.2,\n        goal_bias=0.14,\n        grid_cell_factor=1.8,\n        rewire_base=2.6,\n        dup_radius_factor=0.35,\n        smooth_attempts=120\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = float(step_size * connect_mult)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.rewire_base = float(rewire_base)\n        self.dup_factor = float(dup_radius_factor)\n        self.smooth_attempts = int(max(0, smooth_attempts))\n        self._rng = 88172645463393265 % (1 << 32)\n\n    # ------------------ Public API ------------------\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        # Spatial params\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.5, self.dup_factor * self.step)\n\n        # Build obstacle bins\n        self._build_obs_bins()\n\n        # Start/goal validity\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Direct visibility\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            final = self._finalize_path(path)\n            return PlannerResult(True, final, nodes, edges)\n\n        # Initialize trees and node grids\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        Ta, Tb = [root_a], [root_b]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, root_a)\n        self._grid_add(Gb, root_b)\n        nodes.extend([root_a, root_b])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            # Alternate expansion\n            active_from_start = (it % 2 == 0)\n            tree = Ta if active_from_start else Tb\n            other_tree = Tb if active_from_start else Ta\n            grid = Ga if active_from_start else Gb\n            other_grid = Gb if active_from_start else Ga\n            attractor = self.goal if active_from_start else self.start\n\n            s = self._sample(attractor, best_len)\n            if s is None:\n                continue\n\n            near = self._nearest(grid, s)\n            if near is None:\n                continue\n\n            newp = self._steer(near.position, s, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(grid, newp, self.dup_radius):\n                continue\n\n            # Parent selection within adaptive radius\n            radius = self._rewire_radius(len(tree))\n            parent, new_cost = self._best_parent(grid, near, newp, radius)\n            if parent is None:\n                continue\n\n            # Strict checks before adding node/edge\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid, nn)\n\n            # Local rewiring\n            self._rewire_neighbors(grid, nn, radius, edges)\n\n            # Greedy connect other tree toward nn; insert exact meeting if visible\n            meet, reached = self._connect_toward(other_tree, other_grid, nn.position, nodes, edges)\n            if reached:\n                if active_from_start:\n                    pa = self._trace_to_root(nn)        # start -> ... -> meet\n                    pb = self._trace_to_root(meet)      # goal  -> ... -> meet\n                    path = pa + pb[-2::-1]\n                else:\n                    pa = self._trace_to_root(meet)      # start -> ... -> meet\n                    pb = self._trace_to_root(nn)        # goal  -> ... -> meet\n                    path = pa + pb[-2::-1]\n\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # ------------------ RNG ------------------\n    def _seed_from_scene(self):\n        s = 2166136261 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= q\n            s = (s * 16777619) & 0xffffffff\n        s ^= ((len(self.obstacles) + 97) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        # 32-bit LCG\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------------ Geometry ------------------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a[i] for i in range(self.dim))\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # ------------------ Spatial hash (nodes) ------------------\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, ring):\n        out = []\n        if self.is3:\n            for dx in range(-ring, ring + 1):\n                for dy in range(-ring, ring + 1):\n                    for dz in range(-ring, ring + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-ring, ring + 1):\n                for dy in range(-ring, ring + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        k = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, 4):\n            cand = self._grid_collect(grid, k, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_radius(self, grid, pos, radius):\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        k = self._cell_key(pos)\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((k[0] + dx, k[1] + dy, k[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((k[0] + dx, k[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        neigh = self._neighbors_radius(grid, pos, radius)\n        return len(neigh) > 0\n\n    # ------------------ Obstacles and collision ------------------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.25)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        # Collect candidate obstacles via bin bounds\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_overlap(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_overlap(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_overlap(self, p0, p1, bmin, bmax):\n        # Slab method\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            q = p1[i]\n            d = q - p\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t0 = (mn - p) * inv\n                t1 = (mx - p) * inv\n                if t0 > t1:\n                    tt = t0\n                    t0 = t1\n                    t1 = tt\n                if t0 > tmin:\n                    tmin = t0\n                if t1 < tmax:\n                    tmax = t1\n                if tmin > tmax:\n                    return False\n        return True\n\n    # ------------------ Parenting and rewiring ------------------\n    def _rewire_radius(self, n_nodes):\n        # Smooth decay with tree size; keep generous early radius\n        base = max(self.step * 1.5, self.step * self.rewire_base)\n        scale = 1.0 / (1.0 + 0.002 * n_nodes)\n        # dimension-aware shrink\n        exp = 1.0 / float(self.dim if self.dim > 0 else 1)\n        r = base * (scale ** exp)\n        return max(self.step * 1.25, r)\n\n    def _best_parent(self, grid, near, newp, radius):\n        parent = None\n        best = 1e100\n        neigh = self._neighbors_radius(grid, newp, radius)\n        if not neigh:\n            neigh = [near]\n        for n in neigh:\n            if not self._edge_free(n.position, newp):\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c < best:\n                best = c\n                parent = n\n        return parent, best if parent is not None else (None, None)\n\n    def _rewire_neighbors(self, grid, pivot, radius, edges):\n        neigh = self._neighbors_radius(grid, pivot.position, radius)\n        for nb in neigh:\n            if nb is pivot or nb.parent is None:\n                continue\n            cand = pivot.cost + self._dist(pivot.position, nb.position)\n            if cand + 1e-12 < nb.cost and self._edge_free(pivot.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                pivot.add_child(nb)\n                nb.cost = cand\n                edges.append((pivot, nb))\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        # remove first match\n        for i in range(len(edges)):\n            if edges[i][0] is e[0] and edges[i][1] is e[1]:\n                edges.pop(i)\n                return\n\n    # ------------------ Connect other tree ------------------\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n\n        # Direct connect if visible\n        if self._edge_free(cur.position, target_pos):\n            # Insert exact meeting if not too close\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    nc = Node(target_pos, cur, cur.cost + self._dist(cur.position, target_pos))\n                    cur.add_child(nc)\n                    tree.append(nc)\n                    nodes.append(nc)\n                    edges.append((cur, nc))\n                    self._grid_add(grid, nc)\n                    return nc, True\n            return cur, True\n\n        # Greedy bounded stepping\n        steps = 0\n        limit = 64\n        here = cur\n        while steps < limit:\n            nxt = self._steer(here.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                break\n            if not self._edge_free(here.position, nxt):\n                break\n            if self._too_close(grid, nxt, self.dup_radius * 0.75):\n                break\n            nn = Node(nxt, here, here.cost + self._dist(here.position, nxt))\n            here.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((here, nn))\n            self._grid_add(grid, nn)\n            here = nn\n            steps += 1\n            if self._edge_free(here.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                    if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                        meet = Node(target_pos, here, here.cost + self._dist(here.position, target_pos))\n                        here.add_child(meet)\n                        tree.append(meet)\n                        nodes.append(meet)\n                        edges.append((here, meet))\n                        self._grid_add(grid, meet)\n                        return meet, True\n                return here, True\n\n        # Final direct try\n        if self._edge_free(here.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    meet = Node(target_pos, here, here.cost + self._dist(here.position, target_pos))\n                    here.add_child(meet)\n                    tree.append(meet)\n                    nodes.append(meet)\n                    edges.append((here, meet))\n                    self._grid_add(grid, meet)\n                    return meet, True\n            return here, True\n\n        return here, False\n\n    # ------------------ Sampling ------------------\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.6:\n            p = self._sample_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            if self._in_bounds(attractor) and (not self._point_in_obstacles(attractor)):\n                return attractor\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(32):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum + 1e-9:\n                return p\n        return None\n\n    # ------------------ Path utilities ------------------\n    def _trace_to_root(self, node):\n        cur = node\n        pts = []\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        n = len(cur)\n        tries = 0\n        while tries < attempts and n > 2:\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cur = cur[:i + 1] + cur[j:]\n                n = len(cur)\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._visibility_prune(path)\n        p1 = self._shortcut(p0, max(20, self.smooth_attempts))\n        p2 = self._visibility_prune(p1)\n        return self._dedup(p2)",
            "objective": -40.03655,
            "time_improvement": 75.0,
            "length_improvement": 19.0,
            "smoothness_improvement": 1190.0,
            "node_improvement": 90.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00911562442779541,
                    "num_nodes_avg": 42.0,
                    "path_length_avg": 160.0835385997664,
                    "smoothness_avg": 0.0506179669795133,
                    "success_improvement": 0.0,
                    "time_improvement": 63.051694596676235,
                    "node_improvement": 89.42331906320827,
                    "length_improvement": 12.255675807468933,
                    "smoothness_improvement": 692.2811019039884,
                    "objective_score": 29.73031937300417
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02603757381439209,
                    "num_nodes_avg": 162.0,
                    "path_length_avg": 231.3416199523067,
                    "smoothness_avg": 0.08683134390642434,
                    "success_improvement": 0.0,
                    "time_improvement": 84.43209162029012,
                    "node_improvement": 89.11509776254786,
                    "length_improvement": 22.77150846059685,
                    "smoothness_improvement": 2134.233020801344,
                    "objective_score": 49.66369766645187
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010724067687988281,
                    "num_nodes_avg": 75.0,
                    "path_length_avg": 117.01222962601585,
                    "smoothness_avg": 0.06631602341986054,
                    "success_improvement": 0.0,
                    "time_improvement": 78.75442753856959,
                    "node_improvement": 90.46408137317228,
                    "length_improvement": 22.286048606012514,
                    "smoothness_improvement": 743.5349229609544,
                    "objective_score": 40.715632039983156
                }
            ],
            "success_rate": 1.0
        },
        "objective": 42.6,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Prolonged post-connection optimization and continued rewiring after a first feasible path, inflating runtime.\n   - Costly subtree cost propagation and linear-time edge removals during rewires; in some cases, queue-based updates with unfavorable complexity.\n   - Connect procedures that insert many intermediate and duplicate seam nodes, increasing collision checks and neighbor searches.\n   - Nearest/neighbor queries that frequently expand to wide radii or fall back to full scans due to radius/grid policies.\n   - Heavy smoothing pipelines (pre-densification plus multiple shortcut/visibility passes) causing excessive collision/visibility evaluations.\n   - Rewire radius and duplicate suppression thresholds that either yield large neighbor sets or trigger frequent insertion rejections."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Immediate seam insertion on direct visibility and prompt termination upon first valid connection.\n   - Dimension-aware, smoothly decaying rewire radius that limits neighbor sets as trees grow, reducing rewiring work.\n   - Balanced duplicate suppression (slightly smaller proximity threshold) that cuts rejection thrash without bloating trees.\n   - Streamlined finalization (visibility prune + a single intensified shortcut phase) removing pre-densification overhead.\n   - More focused sampling (higher informed-ellipse use and modestly higher goal bias) that finds connectable states faster.\n   - Slightly coarser obstacle binning and efficient segment\u2013box tests to shrink collision candidate sets.\n   - Stack-based cost propagation and direct edge removal by identity to lower per-rewire overhead.\n2. Expected mechanism of impact:\n   - Fewer collision and neighbor checks per iteration and per rewire, lowering constant factors in hot loops.\n   - Reduced node/edge insertions during connect and finalization, keeping spatial hashes small and nearest searches fast.\n   - Concentrated sampling decreases iterations to achieve a tree connection.\n   - Early exit eliminates long post-optimization tails, directly improving planning time."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "ABLE-RRT: Adaptive Best-Parent Light Elastic Bidirectional RRT-Connect. Two grids grow start/goal trees with mixture-biased sampling. Each extension selects a locally optimal parent within one-step radius to reduce path cost, enforces strict node/edge collision checks, and performs greedy connect to the opposite tree. AABB-pruned edge checks accelerate collision tests. Upon connection, a light two-stage smoother (visibility compression + shortcutting + optional rubber-band) improves length and smoothness while keeping runtime low.",
                "planning_mechanism": "Initialize bidirectional trees and coarse grids. Each iteration: sample (goal/corridor/uniform), find a near node via grid, propose a one-step point, choose the best parent among nearby nodes that can reach it collision-free, then insert. Greedily connect the other tree toward the new node; if a short, collision-free bridge closes the gap, assemble the path and apply lightweight smoothing.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=7.0,\n        goal_bias=0.20,\n        corridor_bias=0.40,\n        cell_size_factor=2.0,\n        edge_resolution=1.0,\n        dupe_radius_ratio=0.40,\n        neighbor_radius_ratio=1.25,\n        smooth_shortcuts=80,\n        rubber_iters=6\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.cell_size_factor = float(cell_size_factor)\n        self.edge_resolution = float(edge_resolution)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.neighbor_radius_ratio = float(neighbor_radius_ratio)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.rubber_iters = int(max(0, rubber_iters))\n\n    def plan(self, map):\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        obstacles = list(map.obstacles)\n\n        # Validate start/goal\n        if not self._within_bounds(start, bounds) or not self._within_bounds(goal, bounds):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight line\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_resolution):\n            n0 = Node(start, None, 0.0)\n            n1 = Node(goal, n0, self._distance(start, goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [start, goal], [n0, n1], [(n0, n1)])\n\n        # Init trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n        cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        grid_start, grid_goal = {}, {}\n        self._grid_insert(grid_start, start_root.position, start_root, cell_size, dim)\n        self._grid_insert(grid_goal, goal_root.position, goal_root, cell_size, dim)\n\n        dsg = self._distance(start, goal)\n        corridor_w = max(self.step_size, 0.18 * dsg)\n        dupe_radius = max(0.5, self.dupe_radius_ratio * self.step_size)\n        neighbor_radius = max(self.step_size, self.neighbor_radius_ratio * self.step_size)\n\n        for it in range(self.max_iter):\n            # Alternate growth\n            if it % 2 == 0:\n                grow_tree, grow_grid, grow_root = start_tree, grid_start, start_root\n                other_tree, other_grid, other_root = goal_tree, grid_goal, goal_root\n                other_root_pos = goal\n                a_is_start_side = True\n            else:\n                grow_tree, grow_grid, grow_root = goal_tree, grid_goal, goal_root\n                other_tree, other_grid, other_root = start_tree, grid_start, start_root\n                other_root_pos = start\n                a_is_start_side = False\n\n            target = self._sample_target(bounds, obstacles, is_3d, start, goal, corridor_w, other_root_pos)\n            a_near = self._nearest_from_grid(grow_tree, grow_grid, target, cell_size, dim)\n\n            # Propose a one-step point\n            proposed = self._steer(a_near.position, target, self.step_size)\n            if not self._within_bounds(proposed, bounds):\n                continue\n            if self._is_in_obstacle(proposed, obstacles, is_3d):\n                continue\n            if self._exists_close(grow_grid, proposed, dupe_radius, cell_size, dim):\n                continue\n\n            # Choose best parent among neighbors that can reach proposed within one step\n            candidates = self._neighbors_within_radius(grow_grid, proposed, neighbor_radius, cell_size, dim)\n            if a_near not in candidates:\n                candidates.append(a_near)\n            best_parent = None\n            best_cost = float('inf')\n            for cand in candidates:\n                dcp = self._distance(cand.position, proposed)\n                if dcp > self.step_size + 1e-9:\n                    continue\n                if self._is_edge_in_obstacle(cand.position, proposed, obstacles, is_3d, self.edge_resolution):\n                    continue\n                cost = cand.cost + dcp\n                if cost < best_cost:\n                    best_cost = cost\n                    best_parent = cand\n            if best_parent is None:\n                continue\n\n            # Commit new node (both node and edge already validated)\n            new_node = Node(proposed, best_parent, best_cost)\n            best_parent.add_child(new_node)\n            grow_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            self._grid_insert(grow_grid, new_node.position, new_node, cell_size, dim)\n\n            # Greedy connect from the other tree toward new_node\n            b_near = self._nearest_from_grid(other_tree, other_grid, new_node.position, cell_size, dim)\n            b_last = self._greedy_extend(other_tree, other_grid, b_near, new_node.position,\n                                         nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if b_last is None:\n                continue\n\n            # Try final short bridge\n            if self._distance(b_last.position, new_node.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(b_last.position, new_node.position, obstacles, is_3d, self.edge_resolution):\n                    edges.append((b_last, new_node))\n                    # Assemble path\n                    if a_is_start_side:\n                        pa = new_node.path_from_root()\n                        pb = b_last.path_from_root()\n                        raw_path = pa + pb[::-1]\n                    else:\n                        pa = new_node.path_from_root()\n                        pb = b_last.path_from_root()\n                        raw_path = pb + pa[::-1]\n                    # Smooth\n                    path = self._compress_visibility(raw_path, obstacles, is_3d)\n                    path = self._shortcut_path(path, obstacles, is_3d, bounds, self.smooth_shortcuts)\n                    path = self._rubber_band(path, obstacles, is_3d, self.rubber_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---- Geometry utilities ----\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(len(a)):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p, bounds):\n        for i in range(len(bounds)):\n            if p[i] < 0.0 or p[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._distance(from_pos, to_pos)\n        if d <= step:\n            return tuple(to_pos[i] for i in range(len(to_pos)))\n        r = step / (d + 1e-12)\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    # ---- Sampling ----\n    def _sample_target(self, bounds, obstacles, is_3d, start, goal, corridor_w, other_root_pos):\n        import random  # Local import to avoid global requirement; acceptable inline\n        r = random.random()\n        if r < self.goal_bias:\n            return other_root_pos\n        elif r < self.goal_bias + self.corridor_bias:\n            t = random.random()\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(len(bounds)))\n            if len(bounds) == 3:\n                return (\n                    self._clamp(base[0] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[0]),\n                    self._clamp(base[1] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[1]),\n                    self._clamp(base[2] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[2]),\n                )\n            else:\n                return (\n                    self._clamp(base[0] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[0]),\n                    self._clamp(base[1] + random.uniform(-corridor_w, corridor_w), 0.0, bounds[1]),\n                )\n        else:\n            # rejection sample in free space\n            for _ in range(32):\n                if len(bounds) == 3:\n                    p = (random.uniform(0.0, bounds[0]),\n                         random.uniform(0.0, bounds[1]),\n                         random.uniform(0.0, bounds[2]))\n                else:\n                    p = (random.uniform(0.0, bounds[0]),\n                         random.uniform(0.0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback (may be occupied; extension will reject)\n            if len(bounds) == 3:\n                return (random.uniform(0.0, bounds[0]),\n                        random.uniform(0.0, bounds[1]),\n                        random.uniform(0.0, bounds[2]))\n            else:\n                return (random.uniform(0.0, bounds[0]),\n                        random.uniform(0.0, bounds[1]))\n\n    def _clamp(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---- Collision utilities ----\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for x, y, z, w, h, d in obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for x, y, w, h in obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _seg_aabb_overlap(self, a, b, obs, is_3d):\n        if is_3d:\n            x, y, z, w, h, d = obs\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            if maxx < x or minx > x + w or maxy < y or miny > y + h or maxz < z or minz > z + d:\n                return False\n            return True\n        else:\n            x, y, w, h = obs\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            if maxx < x or minx > x + w or maxy < y or miny > y + h:\n                return False\n            return True\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._distance(a, b)\n        steps = int(max(1, d / max(1e-9, resolution)))\n        # Pre-filter obstacles by segment AABB overlap\n        relevant = []\n        for obs in obstacles:\n            if self._seg_aabb_overlap(a, b, obs, is_3d):\n                relevant.append(obs)\n        if not relevant:\n            return False\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(len(a)))\n            if self._is_in_obstacle(p, relevant, is_3d):\n                return True\n        return False\n\n    # ---- Grid NN and neighborhood ----\n    def _cell_index(self, pos, cell_size, dim):\n        if dim == 2:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size))\n        else:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size), int(pos[2] // cell_size))\n\n    def _grid_insert(self, grid, pos, node, cell_size, dim):\n        idx = self._cell_index(pos, cell_size, dim)\n        bucket = grid.get(idx)\n        if bucket is None:\n            grid[idx] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_from_grid(self, tree, grid, point, cell_size, dim, max_rings=3):\n        if len(tree) < 32:\n            best = None\n            bestd = float('inf')\n            for n in tree:\n                d = self._distance(n.position, point)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            return best\n        center = self._cell_index(point, cell_size, dim)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, max_rings + 1):\n            cand = []\n            if dim == 2:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        idx = (center[0] + dx, center[1] + dy)\n                        if idx in grid:\n                            cand.extend(grid[idx])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if idx in grid:\n                                cand.extend(grid[idx])\n            if cand:\n                for n in cand:\n                    d = self._distance(n.position, point)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                        found = True\n            if found:\n                break\n        if best is None:\n            # fallback linear\n            best = tree[0]\n            bestd = self._distance(best.position, point)\n            for n in tree:\n                d = self._distance(n.position, point)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_within_radius(self, grid, point, radius, cell_size, dim):\n        cells = int(radius / max(1e-9, cell_size)) + 1\n        center = self._cell_index(point, cell_size, dim)\n        out = []\n        if dim == 2:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    idx = (center[0] + dx, center[1] + dy)\n                    if idx in grid:\n                        out.extend(grid[idx])\n        else:\n            for dx in range(-cells, cells + 1):\n                for dy in range(-cells, cells + 1):\n                    for dz in range(-cells, cells + 1):\n                        idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                        if idx in grid:\n                            out.extend(grid[idx])\n        # filter by true distance\n        rr = radius * radius\n        fil = []\n        for n in out:\n            s = 0.0\n            p = n.position\n            for i in range(dim):\n                d = p[i] - point[i]\n                s += d * d\n            if s <= rr:\n                fil.append(n)\n        return fil\n\n    def _exists_close(self, grid, pos, radius, cell_size, dim):\n        neigh = self._neighbors_within_radius(grid, pos, radius, cell_size, dim)\n        return len(neigh) > 0\n\n    # ---- Extend/connect ----\n    def _greedy_extend(self, tree, grid, from_node, target_pos, nodes, edges, obstacles, is_3d, bounds, cell_size, dim):\n        current = from_node\n        last_new = None\n        while True:\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if not self._within_bounds(step_pos, bounds):\n                break\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                break\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d, self.edge_resolution):\n                break\n            new_node = Node(step_pos, current, current.cost + self._distance(current.position, step_pos))\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node.position, new_node, cell_size, dim)\n            last_new = new_node\n            current = new_node\n            if self._distance(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    # ---- Smoothing ----\n    def _compress_visibility(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        last = path[0]\n        i = 1\n        while i < len(path):\n            far = i\n            j = i\n            while j < len(path):\n                if self._is_edge_in_obstacle(last, path[j], obstacles, is_3d, self.edge_resolution):\n                    break\n                far = j\n                j += 1\n            out.append(path[far])\n            last = path[far]\n            i = far + 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, attempts):\n        if len(path) < 3:\n            return list(path)\n        import random\n        pts = list(path)\n        n = len(pts)\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_resolution):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts\n\n    def _rubber_band(self, path, obstacles, is_3d, iters):\n        if len(path) < 3 or iters <= 0:\n            return list(path)\n        pts = list(path)\n        for _ in range(iters):\n            changed = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(len(a)))\n                if self._is_in_obstacle(mid, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(a, mid, obstacles, is_3d, self.edge_resolution):\n                    continue\n                if self._is_edge_in_obstacle(mid, c, obstacles, is_3d, self.edge_resolution):\n                    continue\n                if mid != pts[i]:\n                    pts[i] = mid\n                    changed = True\n            if not changed:\n                break\n        return pts",
                "objective": -37.59775,
                "time_improvement": 66.0,
                "length_improvement": 14.0,
                "smoothness_improvement": 1905.0,
                "node_improvement": 85.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.009185576438903808,
                        "num_nodes_avg": 64.4,
                        "path_length_avg": 170.56202690395023,
                        "smoothness_avg": 0.04785735504538155,
                        "success_improvement": 0.0,
                        "time_improvement": 62.768158532802346,
                        "node_improvement": 83.782422563586,
                        "length_improvement": 6.512250325673065,
                        "smoothness_improvement": 649.0715303700621,
                        "objective_score": 25.983155407094852
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.027295637130737304,
                        "num_nodes_avg": 154.6,
                        "path_length_avg": 240.5028644826979,
                        "smoothness_avg": 0.12901280114279629,
                        "success_improvement": 0.0,
                        "time_improvement": 83.67989348599582,
                        "node_improvement": 89.61230934623397,
                        "length_improvement": 19.713221344549247,
                        "smoothness_improvement": 3219.5922975687886,
                        "objective_score": 53.02986234037223
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.02437562942504883,
                        "num_nodes_avg": 141.5,
                        "path_length_avg": 127.88160399822759,
                        "smoothness_avg": 0.15294445433893913,
                        "success_improvement": 0.0,
                        "time_improvement": 51.70916332215004,
                        "node_improvement": 82.00890019071836,
                        "length_improvement": 15.067127691977475,
                        "smoothness_improvement": 1845.4421700060007,
                        "objective_score": 33.7802364618615
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m3",
                "algorithm_description": "SAGE-Connect: A simplified adaptive BiRRT-Connect with local cost-aware parenting and light rewiring. It uses a uniform spatial hash for nearest/neighbor queries, coarse obstacle binning for fast collision checks, adaptive rewire radius, and minimal biased/informed sampling. It inserts only strictly node- and edge-free states, creates the exact meeting node to reduce kinks, and applies a compact densify+shortcut+visibility smoother for short, smooth paths.",
                "planning_mechanism": "Alternate growth from start/goal trees: sample (uniform with small goal bias; ellipse after first solution), steer one step, choose the best-cost parent among nearby nodes, add after node+edge checks, locally rewire cheaper neighbors, then greedily extend the opposite tree toward the new node and insert the exact meeting point; upon connection, extract, densify, shortcut, visibility-prune, and return.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=6.0,\n        connect_mult=2.0,\n        goal_bias=0.12,\n        grid_cell_factor=1.6,\n        rewire_base=2.2,\n        smooth_iters=120\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_mult = float(connect_mult)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.rewire_base = float(rewire_base)\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.connect_step = max(self.step, self.step * self.connect_mult)\n        self.dup_radius = max(0.5, 0.4 * self.step)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            Ta = tree_a if active_start else tree_b\n            Tb = tree_b if active_start else tree_a\n            Ga = grid_a if active_start else grid_b\n            Gb = grid_b if active_start else grid_a\n            attractor = self.goal if active_start else self.start\n\n            sample = self._sample(attractor, best_len)\n            if sample is None:\n                continue\n\n            na = self._nearest(Ga, sample)\n            if na is None:\n                continue\n\n            newp = self._steer(na.position, sample, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._too_close(Ga, newp, self.dup_radius):\n                continue\n            if not self._edge_free(na.position, newp):\n                continue\n\n            rew_rad = self._adaptive_rewire_radius(len(Ta))\n            parent, new_cost = self._choose_parent(Ga, newp, na, rew_rad)\n\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            Ta.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(Ga, nn)\n\n            self._local_rewire(Ga, nn, rew_rad, edges)\n\n            meet_node, reached = self._connect_toward(Tb, Gb, nn.position, nodes, edges)\n            if reached:\n                if active_start:\n                    pa = self._trace_to_root(nn)        # start -> ... -> nn\n                    pb = self._trace_to_root(meet_node) # goal  -> ... -> nn\n                    path = pa + pb[-2::-1]              # avoid duplicate nn\n                else:\n                    pa = self._trace_to_root(meet_node) # start -> ... -> nn\n                    pb = self._trace_to_root(nn)        # goal  -> ... -> nn\n                    path = pa + pb[-2::-1]\n\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 13) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found_any = False\n        for r in range(0, 4):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found_any = True\n            if found_any:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius)) > 0\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.2)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parenting and rewiring\n    def _choose_parent(self, grid, newp, fallback, radius):\n        parent = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        neigh = self._neighbors_in_radius(grid, newp, radius)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                parent = n\n                best_cost = c\n        return parent, best_cost\n\n    def _local_rewire(self, grid, nn, radius, edges):\n        neigh = self._neighbors_in_radius(grid, nn.position, radius)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            cand = nn.cost + self._dist(nn.position, nb.position)\n            if cand + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                nn.add_child(nb)\n                nb.cost = cand\n                edges.append((nn, nb))\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        try:\n            idx = edges.index(e)\n            edges.pop(idx)\n        except:\n            pass\n\n    def _adaptive_rewire_radius(self, n_nodes):\n        # Shrink with tree size without log; simple exponential decay\n        base = max(self.step * 1.2, self.step * self.rewire_base)\n        decay = pow(0.5, n_nodes / 2500.0)\n        return max(self.step * 1.2, base * decay)\n\n    # BiRRT-Connect growth from other tree toward target; insert exact meeting node if visible\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < 64:\n            if self._edge_free(cur.position, target_pos):\n                # Insert the exact meeting point for a clean junction\n                if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                    if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        cur.add_child(nn)\n                        tree.append(nn)\n                        nodes.append(nn)\n                        edges.append((cur, nn))\n                        self._grid_add(grid, nn)\n                        return nn, True\n                # If too close, treat current as meeting node\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(grid, nxt, self.dup_radius * 0.75):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n        # Final try after capped steps\n        if self._edge_free(cur.position, target_pos):\n            if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    edges.append((cur, nn))\n                    self._grid_add(grid, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.55:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _densify(self, pts, seg_len):\n        if len(pts) < 2:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts)):\n            a = out[-1]\n            b = pts[i]\n            d = self._dist(a, b)\n            if d <= seg_len * 1.05:\n                out.append(b)\n                continue\n            nseg = int(d / seg_len)\n            if nseg < 1:\n                out.append(b)\n                continue\n            for k in range(1, nseg + 1):\n                t = k / float(nseg + 1)\n                inter = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n                if self._edge_free(out[-1], inter):\n                    out.append(inter)\n                else:\n                    break\n            if self._edge_free(out[-1], b):\n                out.append(b)\n            else:\n                out.append(b)\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._densify(path, seg_len=max(1.0, 0.5 * self.step))\n        p1 = self._shortcut(p0, self.smooth_iters)\n        p2 = self._visibility_prune(p1)\n        p3 = self._shortcut(p2, max(20, self.smooth_iters // 2))\n        return self._dedup(p3)",
                "objective": -39.95809,
                "time_improvement": 69.0,
                "length_improvement": 21.0,
                "smoothness_improvement": 1361.0,
                "node_improvement": 85.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.008446240425109863,
                        "num_nodes_avg": 40.0,
                        "path_length_avg": 154.00203649529243,
                        "smoothness_avg": 0.0463463750398735,
                        "success_improvement": 0.0,
                        "time_improvement": 65.76490472936995,
                        "node_improvement": 89.92697053638882,
                        "length_improvement": 15.589043478498803,
                        "smoothness_improvement": 625.4214121382626,
                        "objective_score": 32.21000456660158
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.02304682731628418,
                        "num_nodes_avg": 136.0,
                        "path_length_avg": 230.09301068249903,
                        "smoothness_avg": 0.08849989105200873,
                        "success_improvement": 0.0,
                        "time_improvement": 86.220263890156,
                        "node_improvement": 90.86205738090439,
                        "length_improvement": 23.188330174083777,
                        "smoothness_improvement": 2177.1659406631616,
                        "objective_score": 50.66490697481287
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.02282891273498535,
                        "num_nodes_avg": 204.0,
                        "path_length_avg": 115.03810237530747,
                        "smoothness_avg": 0.10863321186734835,
                        "success_improvement": 0.0,
                        "time_improvement": 54.77338134763434,
                        "node_improvement": 74.06230133502861,
                        "length_improvement": 23.597169928095134,
                        "smoothness_improvement": 1281.8064364830614,
                        "objective_score": 36.99934854356269
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "NOVA-BRRT*: A bidirectional RRT*-Connect variant with dual spatial hashes, exact-bridge meeting, density-aware duplicate control, and lazy local rewiring. It uses obstacle binning and slab-segment tests for fast collision checks, selects best-cost parents within an adaptive radius, rewires cheaper neighbors, and connects greedily from the opposite tree with insertion of the exact meeting node for kink-free junctions. After a connection, a compact visibility prune + guided shortcut + midpoint relaxation yields smooth, short paths with minimal overhead.",
            "planning_mechanism": "Alternate growing start/goal trees. Each iteration: biased/informed sample (goal/corridor/ellipse), find a near node via grid, steer one step, choose the best parent among neighbors and verify node+edge, add and locally rewire. Greedily extend the other tree toward the new node; if visibility holds, insert the exact meeting node. On connection, assemble a continuous path (no duplicate junction), visibility-prune, shortcut, midpoint-smooth, and return.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        pts = []\n        cur = self\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5500,\n        step_size=6.0,\n        connect_mult=2.0,\n        grid_cell_factor=1.4,\n        goal_bias=0.10,\n        corridor_bias=0.25,\n        rewire_factor=2.4,\n        smooth_shortcuts=90\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = float(connect_mult) * self.step\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.rewire_factor = float(rewire_factor)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self._rng = 123456789\n\n    def plan(self, map):\n        # Scene\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._edges_set = {}\n\n        # Basic validation\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Seed RNG and structures\n        self._seed_from_scene()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.5, 0.35 * self.step)\n        self.rewire_base = max(1.2 * self.step, self.rewire_factor * self.step)\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        # Corridor width for biased sampling\n        sg = self._dist(self.start, self.goal)\n        corridor_w = max(self.step, 0.18 * sg)\n        best_len = None  # enable informed sampling after first solution\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            Ta = tree_a if active_start else tree_b\n            Tb = tree_b if active_start else tree_a\n            Ga = grid_a if active_start else grid_b\n            Gb = grid_b if active_start else grid_a\n            attract = self.goal if active_start else self.start\n\n            # Sample target\n            target = self._sample_target(attract, best_len, corridor_w)\n            if target is None:\n                continue\n\n            na = self._nearest(Ga, target)\n            if na is None:\n                continue\n\n            newp = self._steer(na.position, target, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            # Density-aware duplicate suppression\n            if self._too_close(Ga, newp, self._adaptive_dup_radius(Ga, newp)):\n                continue\n\n            # Choose best parent within adaptive radius\n            rew_rad = self._adaptive_rewire_radius(len(Ta))\n            parent, new_cost = self._choose_parent(Ga, newp, na, rew_rad)\n            # Strict checks before commit\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            Ta.append(nn)\n            nodes.append(nn)\n            self._add_edge(edges, parent, nn)\n            self._grid_add(Ga, nn)\n\n            # Local rewiring\n            self._local_rewire(Ga, nn, rew_rad, edges)\n\n            # Try to connect from the other tree\n            meet_node, reached = self._connect_toward(Tb, Gb, nn.position, nodes, edges)\n            if not reached:\n                continue\n\n            # Build final path without duplicate junction\n            if active_start:\n                pa = self._trace_to_root(nn)         # start -> ... -> nn\n                pb = self._trace_to_root(meet_node)  # goal  -> ... -> nn\n                path = pa + pb[-2::-1]\n            else:\n                pa = self._trace_to_root(meet_node)  # start -> ... -> nn\n                pb = self._trace_to_root(nn)         # goal  -> ... -> nn\n                path = pa + pb[-2::-1]\n\n            # Smoothing\n            path = self._visibility_prune(path)\n            path = self._shortcut(path, self.smooth_shortcuts)\n            path = self._midpoint_relax(path, iters=6)\n\n            return PlannerResult(True, self._dedup(path), nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG utilities\n    def _seed_from_scene(self):\n        s = 0x9E3779B9 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= (q ^ (q >> 13) ^ ((q << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 29) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_pt(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp_pt(a)\n        if d2 <= step * step:\n            return self._clamp_pt(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp_pt(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash for nodes\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found_any = False\n        for r in range(0, 4):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found_any = True\n            if found_any:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius)) > 0\n\n    # Obstacles: binning and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.2)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        # Slab method\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Sampling\n    def _sample_target(self, attract, best_len, corridor_w):\n        r = self._rand()\n        # Informed ellipse after first solution\n        if best_len is not None and r < 0.60:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        # Goal bias\n        if r < self.goal_bias:\n            if self._in_bounds(attract) and (not self._point_in_obstacles(attract)):\n                return attract\n        # Corridor-biased\n        if r < self.goal_bias + self.corridor_bias:\n            t = self._rand()\n            base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n            if self.is3:\n                p = (\n                    self._clamp(base[0] + self._rand_range(-corridor_w, corridor_w), 0.0, self.bounds[0]),\n                    self._clamp(base[1] + self._rand_range(-corridor_w, corridor_w), 0.0, self.bounds[1]),\n                    self._clamp(base[2] + self._rand_range(-corridor_w, corridor_w), 0.0, self.bounds[2]),\n                )\n            else:\n                p = (\n                    self._clamp(base[0] + self._rand_range(-corridor_w, corridor_w), 0.0, self.bounds[0]),\n                    self._clamp(base[1] + self._rand_range(-corridor_w, corridor_w), 0.0, self.bounds[1]),\n                )\n            if (not self._point_in_obstacles(p)) and self._in_bounds(p):\n                return p\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _clamp(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(28):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                return p\n        return None\n\n    # Parenting and rewiring\n    def _choose_parent(self, grid, newp, fallback, radius):\n        parent = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        neigh = self._neighbors_in_radius(grid, newp, radius)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                parent = n\n                best_cost = c\n        return parent, best_cost\n\n    def _local_rewire(self, grid, nn, radius, edges):\n        neigh = self._neighbors_in_radius(grid, nn.position, radius)\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            cand = nn.cost + self._dist(nn.position, nb.position)\n            if cand + 1e-12 < nb.cost and self._edge_free(nn.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, oldp, nb)\n                nn.add_child(nb)\n                nb.cost = cand\n                self._add_edge(edges, nn, nb)\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    # Connect from other tree toward target, optionally inserting exact meeting node\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        # First, try direct visibility to exact meeting\n        if self._edge_free(cur.position, target_pos):\n            if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    # Strict checks already done above\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    self._add_edge(edges, cur, nn)\n                    self._grid_add(grid, nn)\n                    return nn, True\n            return cur, True  # meet at current if too close to insert node\n\n        # Greedy stepwise connect\n        while steps < 48:\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if self._too_close(grid, nxt, self.dup_radius * 0.75):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            self._add_edge(edges, cur, nn)\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n            if self._edge_free(cur.position, target_pos):\n                if (not self._point_in_obstacles(target_pos)) and self._in_bounds(target_pos):\n                    if not self._too_close(grid, target_pos, self.dup_radius * 0.75):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        mn = Node(target_pos, cur, new_cost)\n                        cur.add_child(mn)\n                        tree.append(mn)\n                        nodes.append(mn)\n                        self._add_edge(edges, cur, mn)\n                        self._grid_add(grid, mn)\n                        return mn, True\n                return cur, True\n        return cur, False\n\n    # Path helpers\n    def _trace_to_root(self, node):\n        return node.path_from_root()\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _midpoint_relax(self, pts, iters=6):\n        if len(pts) < 3 or iters <= 0:\n            return pts[:]\n        out = pts[:]\n        for _ in range(iters):\n            changed = False\n            for i in range(1, len(out) - 1):\n                a = out[i - 1]\n                c = out[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if self._point_in_obstacles(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if mid != out[i]:\n                        out[i] = mid\n                        changed = True\n            if not changed:\n                break\n        return out\n\n    # Adaptive radii\n    def _adaptive_rewire_radius(self, n_nodes):\n        decay = pow(0.5, n_nodes / 3000.0)\n        return max(1.2 * self.step, self.rewire_base * decay)\n\n    def _adaptive_dup_radius(self, grid, pos):\n        # Slightly reduce duplicate radius in dense areas to allow refinement\n        base = self.dup_radius\n        neigh = self._neighbors_in_radius(grid, pos, 2.5 * self.dup_radius)\n        if len(neigh) > 12:\n            return 0.6 * base\n        if len(neigh) > 6:\n            return 0.8 * base\n        return base\n\n    # Edge bookkeeping\n    def _add_edge(self, edges, a, b):\n        key = (a, b)\n        if key in self._edges_set:\n            return\n        edges.append((a, b))\n        self._edges_set[key] = 1\n\n    def _remove_edge(self, edges, a, b):\n        key = (a, b)\n        if key in self._edges_set:\n            # remove from list\n            for i in range(len(edges) - 1, -1, -1):\n                ea, eb = edges[i]\n                if ea is a and eb is b:\n                    edges.pop(i)\n                    break\n            del self._edges_set[key]",
            "objective": -40.90484,
            "time_improvement": 74.0,
            "length_improvement": 18.0,
            "smoothness_improvement": 1621.0,
            "node_improvement": 89.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009995555877685547,
                    "num_nodes_avg": 55.0,
                    "path_length_avg": 160.51471104652452,
                    "smoothness_avg": 0.04571645372029039,
                    "success_improvement": 0.0,
                    "time_improvement": 59.48507376866201,
                    "node_improvement": 86.14958448753463,
                    "length_improvement": 12.019343357036162,
                    "smoothness_improvement": 615.5617755907475,
                    "objective_score": 28.13493702277404
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030689311027526856,
                    "num_nodes_avg": 142.0,
                    "path_length_avg": 228.58360131426812,
                    "smoothness_avg": 0.11916107389456083,
                    "success_improvement": 0.0,
                    "time_improvement": 81.65081025910044,
                    "node_improvement": 90.45891285359134,
                    "length_improvement": 23.692214467138992,
                    "smoothness_improvement": 2966.1002595593727,
                    "objective_score": 53.541073055810394
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009439635276794433,
                    "num_nodes_avg": 83.0,
                    "path_length_avg": 124.8569736985716,
                    "smoothness_avg": 0.10854185440910273,
                    "success_improvement": 0.0,
                    "time_improvement": 81.29903119622774,
                    "node_improvement": 89.446916719644,
                    "length_improvement": 17.075943119591432,
                    "smoothness_improvement": 1280.6443763574832,
                    "objective_score": 41.038497112410596
                }
            ],
            "success_rate": 1.0
        },
        "objective": 42.4,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Nearest-neighbor lookups frequently degrade to linear scans due to coarse spatial hashing and limited search rings, increasing per-iteration cost as trees grow.\n   - Duplicate control is either too strict (wasting iterations with \u201ctoo-close\u201d rejections) or too loose (creating many near-duplicate nodes), both harming efficiency.\n   - Connect phases perform many small, collision-checked steps with frequent grid updates, yielding high constant factors and repeated work.\n   - Collision checking is costly (dense sampling or wide candidate sets), and some variants repeat point/edge tests redundantly.\n   - Rewiring and edge book-keeping incur O(E) operations and broad cost propagation, making each improvement expensive.\n   - Junction formation can introduce kinks or duplicate junction points, increasing smoothing workload.\n   - Post-processing is heavy (densification and large numbers of shortcuts), adding substantial overhead after a solution is found."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Obstacle binning with slab-based segment tests to shrink collision candidates and speed edge validation.\n   - Early direct-visibility meeting with exact junction insertion and a capped, shorter greedy connect loop.\n   - Density-aware duplicate suppression to reduce wasted \u201ctoo-close\u201d rejections in crowded areas while preventing sprawl in open regions.\n   - Hash-backed edge bookkeeping and targeted local rewiring to avoid O(E) edge operations and limit cost propagation scope.\n   - Combined informed/corridor/goal-biased sampling to focus expansions and cut iterations to first connection.\n   - Leaner finalization pipeline (visibility prune + bounded shortcutting + light relaxation) without densification.\n2. Expected mechanism of impact:\n   - Fewer obstacle candidates and constant-time intersection checks directly reduce collision-check time per edge.\n   - Early exact-bridge formation and capped connect steps cut the number of collision checks, grid inserts, and allocations during meeting attempts.\n   - Adaptive duplicate radius lowers the rate of failed insertions near narrow passages, reducing iteration waste.\n   - O(1) edge updates and localized rewiring shrink the cost of improving topology as the tree grows.\n   - More targeted sampling increases the probability of productive expansions, shortening time-to-first-path.\n   - Reduced smoothing work after connection decreases post-processing latency, yielding faster overall planning time."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "SAGE-Lite BiRRT*: Simple Adaptive Guided Efficient Bidirectional RRT* with Informed Sampling and Minimal Rewiring. It couples a light bidirectional RRT* growth with dynamic neighbor radii, duplicate suppression, and a single-step micro-bridge to connect the trees. A compact obstacle bin accelerates exact segment-AABB checks. On connection, a minimal three-stage post-processor (visibility, shortcuts, corner rounding) outputs short, smooth paths quickly and robustly.",
                "planning_mechanism": "Alternate expansions from start/goal trees. Each iteration: draw a target by mixing goal, corridor, uniform, and informed-ellipse sampling (once an incumbent exists). Steer one step from the nearest node; validate node and parent edge; select the least-cost parent among dynamic-radius neighbors; insert and lightly rewire a few neighbors. Attempt a direct snap or one validated micro-bridge from the opposite tree. Upon meeting, assemble and postprocess the path (visibility prune, randomized shortcuts, midpoint corner rounding) and return.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=7.0,\n        goal_bias=0.20,\n        corridor_bias=0.35,\n        informed_bias=0.55,\n        grid_cell_factor=1.6,\n        neighbor_factor=3.0,\n        neighbor_cap=40,\n        dup_factor=0.35,\n        connect_factor=2.25,\n        rewire_cap=8,\n        shortcut_trials=100,\n        round_passes=2\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_factor = float(neighbor_factor)\n        self.neighbor_cap = int(neighbor_cap)\n        self.dup_factor = float(dup_factor)\n        self.connect_factor = float(connect_factor)\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.shortcut_trials = int(max(0, shortcut_trials))\n        self.round_passes = int(max(0, round_passes))\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        nodes = []\n        edges = []\n\n        # Validate endpoints and bounds\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n\n        # Build obstacle bins\n        self._build_obs_bins()\n\n        # Node validity\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight-line solution\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Derived params\n        self.node_cell = max(1.0, self.step * self.grid_cell_factor)\n        self.neigh_base = max(self.step * 1.25, self.step * self.neighbor_factor)\n        self.dup_radius = max(0.4, self.step * self.dup_factor)\n        self.connect_dist = max(self.step, self.step * self.connect_factor)\n        self.corridor_w = max(self.step, 0.15 * self._dist(self.start, self.goal))\n\n        # Trees and grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [a_root], [b_root]\n        nodes.extend([a_root, b_root])\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, a_root)\n        self._grid_add(Gb, b_root)\n\n        best_len = None\n        best_path = None\n\n        for it in range(self.max_iter):\n            grow_a = (it & 1) == 0\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n\n            # Sampling\n            target = self._sample_target(attractor, best_len)\n            if target is None:\n                continue\n\n            # Nearest\n            near = self._nearest(G, target, T)\n            if near is None:\n                continue\n\n            # Steer\n            newp = self._steer(near.position, target, self.step)\n            if (not self._in_bounds(newp)) or self._point_blocked(newp):\n                continue\n            if self._has_duplicate(G, newp, self.dup_radius):\n                continue\n\n            # Parent selection among dynamic-radius neighbors\n            parent, new_cost = self._choose_parent(G, T, newp, near)\n            if parent is None:\n                continue\n\n            # Final checks before add (both required)\n            if self._point_blocked(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            # Insert node\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(G, nn)\n\n            # Light local rewiring\n            if self.rewire_cap > 0:\n                self._rewire_local(G, nn, edges)\n\n            # Try to connect to the opposite tree\n            other = self._nearest(Gopp, nn.position, Topp)\n            connected = False\n            meet = None\n            if other is not None:\n                if self._dist(nn.position, other.position) <= self.connect_dist and self._edge_free(nn.position, other.position):\n                    connected = True\n                    meet = other\n                else:\n                    # One-step micro-bridge from opposite tree\n                    br_p = self._steer(other.position, nn.position, self.connect_dist)\n                    if self._in_bounds(br_p) and (not self._point_blocked(br_p)) and (not self._has_duplicate(Gopp, br_p, self.dup_radius)):\n                        if self._edge_free(other.position, br_p):\n                            qb = Node(br_p, other, other.cost + self._dist(other.position, br_p))\n                            # Both checks already done; add\n                            other.add_child(qb)\n                            Topp.append(qb)\n                            nodes.append(qb)\n                            edges.append((other, qb))\n                            self._grid_add(Gopp, qb)\n                            if self._edge_free(nn.position, qb.position):\n                                connected = True\n                                meet = qb\n\n            # Maintain incumbent (for informed sampling)\n            if other is not None and self._edge_free(nn.position, other.position):\n                tmp = self._assemble(nn, other, grow_a)\n                L = self._path_len(tmp)\n                if best_len is None or L < best_len:\n                    best_len = L\n                    best_path = tmp\n\n            if connected and meet is not None:\n                raw = self._assemble(nn, meet, grow_a)\n                path = self._postprocess(raw)\n                return PlannerResult(True, path, Ta + Tb, edges)\n\n        # Fall back to best seen (if any)\n        if best_path is not None:\n            path = self._postprocess(best_path)\n            return PlannerResult(True, path, Ta + Tb, edges)\n\n        return PlannerResult(False, [], Ta + Tb, edges)\n\n    # ---------- RNG ----------\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s ^= (int((v + 0.5) * 997) + 13) & 0xffffffff\n            s = (s * 1664525 + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) + 31) * 1103515245 & 0xffffffff\n        self._rng = s if s != 0 else 2463534242\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # ---------- Node spatial hashing ----------\n    def _cell_key(self, p):\n        return tuple(int(p[i] // self.node_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _ring_nodes(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos, tree):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 4):\n            cand = self._ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # light fallback scan\n        if not tree:\n            return None\n        step = max(1, len(tree) // 64)\n        for i in range(0, len(tree), step):\n            n = tree[i]\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        span = int(radius // self.node_cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.dim == 3:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _has_duplicate(self, grid, pos, radius):\n        return len(self._neighbors(grid, pos, radius, self.neighbor_cap)) > 0\n\n    # ---------- Parent selection / rewiring ----------\n    def _dyn_radius(self, n):\n        # Monotone decreasing radius ~ base * n^(-1/d)\n        n = max(1, n)\n        e = -1.0 / float(max(1, self.dim))\n        return max(self.step * 1.25, self.neigh_base * (n ** e))\n\n    def _choose_parent(self, grid, tree, new_pos, fallback_near):\n        n = max(1, len(tree))\n        radius = self._dyn_radius(n)\n        neigh = self._neighbors(grid, new_pos, radius, self.neighbor_cap)\n        if not neigh:\n            neigh = [fallback_near] if fallback_near is not None else []\n        best_p = None\n        best_c = 1e100\n        for p in neigh:\n            if p is None:\n                continue\n            d = self._dist(p.position, new_pos)\n            gc = p.cost + d\n            if gc + 1e-12 < best_c and self._edge_free(p.position, new_pos):\n                best_c = gc\n                best_p = p\n        if best_p is None:\n            return None, None\n        return best_p, best_c\n\n    def _rewire_local(self, grid, new_node, edges):\n        radius = max(self.step * 1.25, self.neigh_base)\n        neigh = self._neighbors(grid, new_node.position, radius, self.neighbor_cap)\n        improvements = 0\n        for nb in neigh:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            # avoid cycles\n            cur = new_node\n            cyc = False\n            while cur is not None:\n                if cur is nb:\n                    cyc = True\n                    break\n                cur = cur.parent\n            if cyc:\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand + 1e-12 < nb.cost:\n                self._reparent(nb, new_node, edges)\n                improvements += 1\n                if improvements >= self.rewire_cap:\n                    break\n\n    def _reparent(self, child, new_parent, edges):\n        if child.parent is new_parent:\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._remove_edge(edges, old, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        # propagate costs\n        stack = [child]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                newc = u.cost + self._dist(u.position, ch.position)\n                if abs(newc - ch.cost) > 1e-12:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                edges.pop(i)\n                break\n\n    # ---------- Obstacles & collision ----------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self.dim == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            self._obin_add((i, j, k), idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        self._obin_add((i, j), idx)\n\n    def _obin_add(self, key, idx):\n        lst = self.obin.get(key)\n        if lst is None:\n            self.obin[key] = [idx]\n        else:\n            lst.append(idx)\n\n    def _bucket_candidates(self, a, b):\n        if self.dim == 3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            return cand\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            return cand\n\n    def _point_blocked(self, p):\n        if self.dim == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            lst = self.obin.get((ix, iy, iz))\n            if not lst:\n                return False\n            x, y, z = p\n            for idx in lst:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            lst = self.obin.get((ix, iy))\n            if not lst:\n                return False\n            x, y = p\n            for idx in lst:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        cand = self._bucket_candidates(a, b)\n        if not cand:\n            return True\n        if self.dim == 3:\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            q = p1[i]\n            d = q - p\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # ---------- Sampling ----------\n    def _sample_target(self, attractor, best_len):\n        tries = 18\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            p = None\n            if best_len is not None and r < self.informed_bias:\n                p = self._sample_informed(best_len * 1.02)\n            if p is None:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    p = attractor\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    t = self._rand()\n                    base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n                    if self.dim == 3:\n                        p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                             self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w),\n                             self._rand_range(base[2] - self.corridor_w, base[2] + self.corridor_w))\n                    else:\n                        p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                             self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w))\n                else:\n                    if self.dim == 3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if p is None:\n                continue\n            p = self._clamp(p)\n            if (not self._point_blocked(p)):\n                return p\n        return None\n\n    def _sample_informed(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        for _ in range(24):\n            if self.dim == 3:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half),\n                     self._rand_range(c[2] - half, c[2] + half))\n            else:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= max_sum + 1e-9:\n                return p\n        return None\n\n    # ---------- Path assembly and postprocess ----------\n    def _trace(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble(self, u, v, a_side):\n        pu = self._trace(u)\n        pv = self._trace(v)\n        if a_side:\n            # start->u + v->goal reversed; remove duplicate root if present\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        out[0] = pts[0]\n        out[-1] = pts[-1]\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3 or attempts <= 0:\n            return pts[:]\n        cur = list(pts)\n        best = self._path_len(cur)\n        fail = 0\n        for _ in range(attempts):\n            if len(cur) < 3:\n                break\n            i = int(self._rand_range(0, len(cur) - 2))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j <= i + 1:\n                fail += 1\n                if fail > 32:\n                    break\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    cur = cand\n                    best = L\n                    fail = 0\n                else:\n                    fail += 1\n            else:\n                fail += 1\n            if fail > 64:\n                break\n        return cur\n\n    def _round_corners(self, pts, passes=2):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            k = 1\n            while k < len(cur) - 1:\n                a = cur[k - 1]\n                b = cur[k]\n                c = cur[k + 1]\n                mid = tuple(0.5 * (a[i] + c[i]) for i in range(self.dim))\n                if (not self._point_blocked(mid)) and self._edge_free(a, mid) and self._edge_free(mid, c):\n                    cur[k] = mid\n                k += 1\n        cur[0] = pts[0]\n        cur[-1] = pts[-1]\n        return cur\n\n    def _postprocess(self, path):\n        p0 = self._visibility_prune(path)\n        p1 = self._shortcut(p0, self.shortcut_trials)\n        p2 = self._round_corners(p1, self.round_passes)\n        return p2",
                "objective": -29.26225,
                "time_improvement": 36.0,
                "length_improvement": 17.0,
                "smoothness_improvement": 1620.0,
                "node_improvement": 80.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.022170615196228028,
                        "num_nodes_avg": 92.0,
                        "path_length_avg": 164.5827711468657,
                        "smoothness_avg": 0.04990219356864121,
                        "success_improvement": 0.0,
                        "time_improvement": 10.135979412227993,
                        "node_improvement": 76.83203223369428,
                        "length_improvement": 9.78957515350173,
                        "smoothness_improvement": 681.0776936970007,
                        "objective_score": 12.31992738425444
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03230597972869873,
                        "num_nodes_avg": 136.0,
                        "path_length_avg": 230.58069328423707,
                        "smoothness_avg": 0.08789056707516853,
                        "success_improvement": 0.0,
                        "time_improvement": 80.68420137304992,
                        "node_improvement": 90.86205738090439,
                        "length_improvement": 23.02552768445824,
                        "smoothness_improvement": 2161.487595860742,
                        "objective_score": 48.82801500189363
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.042160534858703615,
                        "num_nodes_avg": 207.0,
                        "path_length_avg": 121.44328067218183,
                        "smoothness_avg": 0.16651569855581902,
                        "success_improvement": 0.0,
                        "time_improvement": 16.47528489991484,
                        "node_improvement": 73.68086458995549,
                        "length_improvement": 19.343155485125788,
                        "smoothness_improvement": 2018.0673947196651,
                        "objective_score": 26.63881573464825
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "MINI-Connect BiRRT+: A compact bidirectional RRT-Connect with informed bias, duplicate suppression, obstacle binning, and safe corner smoothing. It emphasizes fast, robust planning with competitive path length and high smoothness through a simple expansion core and lightweight post-processing.",
            "planning_mechanism": "Planning mechanism: Alternate single-step growth from start/goal trees toward a biased target; validate both node and edge before insertion. After each accepted step, greedily connect the opposite tree with repeated steps toward the new point. On meeting, assemble and refine the path via visibility pruning, randomized shortcuts, and collision-aware corner smoothing. An incumbent path, updated opportunistically by cross-tree visibility, enables informed sampling.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=8.0,\n        goal_bias=0.25,\n        corridor_bias=0.25,\n        informed_bias=0.50,\n        grid_cell_factor=2.0,\n        dup_factor=0.5,\n        shortcut_trials=120,\n        smooth_passes=3\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dup_factor = float(dup_factor)\n        self.shortcut_trials = int(max(0, shortcut_trials))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        nodes = []\n        edges = []\n        self._nodes = nodes\n        self._edges = edges\n\n        # Validate endpoints\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight-line solution\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Derived params\n        self.node_cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.4, self.step * self.dup_factor)\n        self.corridor_w = max(self.step, 0.15 * self._dist(self.start, self.goal))\n\n        # Trees and node grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, a_root)\n        self._grid_add(Gb, b_root)\n        nodes.extend([a_root, b_root])\n\n        best_path = None\n        best_len = None\n\n        for it in range(self.max_iter):\n            grow_a = (it & 1) == 0\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n\n            target = self._sample_target(attractor, best_len)\n            if target is None:\n                continue\n\n            # Extend one step from nearest towards target\n            base = self._nearest(G, target, T)\n            if base is None:\n                continue\n            new_node = self._extend_from(base, target, T, G)\n            if new_node is None:\n                continue\n\n            # Opportunistic incumbent update via direct cross-tree visibility\n            other = self._nearest(Gopp, new_node.position, Topp)\n            if other is not None and self._edge_free(new_node.position, other.position):\n                cand = self._assemble(new_node, other, grow_a)\n                L = self._path_len(cand)\n                if best_len is None or L < best_len:\n                    best_len = L\n                    best_path = cand\n\n            # Try greedy connect from opposite tree towards the new node\n            meet = self._connect_towards(Topp, Gopp, new_node.position)\n            if meet is not None and meet.position == new_node.position:\n                raw = self._assemble(new_node, meet, grow_a)\n                path = self._postprocess(raw)\n                return PlannerResult(True, path, Ta + Tb, edges)\n\n        # Fallback to best found\n        if best_path is not None:\n            path = self._postprocess(best_path)\n            return PlannerResult(True, path, Ta + Tb, edges)\n\n        return PlannerResult(False, [], Ta + Tb, edges)\n\n    # ---------- RNG ----------\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s ^= (int((v + 0.5) * 977) + 41) & 0xffffffff\n            s = (s * 1664525 + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) + 17) * 1103515245 & 0xffffffff\n        self._rng = s if s != 0 else 2463534242\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # ---------- Node spatial hashing ----------\n    def _cell_key(self, p):\n        return tuple(int(p[i] // self.node_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_query(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        span = int(radius // self.node_cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.dim == 3:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _nearest(self, grid, pos, tree):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        # expand ring up to radius 3\n        for r in range(0, 4):\n            cand = []\n            if self.dim == 3:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if lst:\n                                cand.extend(lst)\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy))\n                        if lst:\n                            cand.extend(lst)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # fallback light scan\n        if not tree:\n            return None\n        step = max(1, len(tree) // 64)\n        for i in range(0, len(tree), step):\n            n = tree[i]\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _has_duplicate(self, grid, pos, radius):\n        return len(self._grid_query(grid, pos, radius)) > 0\n\n    # ---------- Obstacles & collision ----------\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self.dim == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            self._obin_add((i, j, k), idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        self._obin_add((i, j), idx)\n\n    def _obin_add(self, key, idx):\n        lst = self.obin.get(key)\n        if lst is None:\n            self.obin[key] = [idx]\n        else:\n            lst.append(idx)\n\n    def _bucket_candidates(self, a, b):\n        if self.dim == 3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            return cand\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            return cand\n\n    def _point_blocked(self, p):\n        if self.dim == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            lst = self.obin.get((ix, iy, iz))\n            if not lst:\n                return False\n            x, y, z = p\n            for idx in lst:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            lst = self.obin.get((ix, iy))\n            if not lst:\n                return False\n            x, y = p\n            for idx in lst:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            q = p1[i]\n            d = q - p\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        cand = self._bucket_candidates(a, b)\n        if not cand:\n            return True\n        if self.dim == 3:\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    # ---------- Expansion ----------\n    def _extend_from(self, base, target, tree, grid):\n        newp = self._steer(base.position, target, self.step)\n        if newp == base.position:\n            return None\n        if (not self._in_bounds(newp)) or self._point_blocked(newp):\n            return None\n        if not self._edge_free(base.position, newp):\n            return None\n        if self._has_duplicate(grid, newp, self.dup_radius):\n            return None\n        nn = Node(newp, base, base.cost + self._dist(base.position, newp))\n        base.add_child(nn)\n        tree.append(nn)\n        self._nodes.append(nn)\n        self._edges.append((base, nn))\n        self._grid_add(grid, nn)\n        return nn\n\n    def _connect_towards(self, tree, grid, target_point):\n        # Greedy multiple steps toward target; returns last added node, or None if blocked immediately.\n        base = self._nearest(grid, target_point, tree)\n        if base is None:\n            return None\n        last = None\n        cap = 64\n        while cap > 0:\n            cap -= 1\n            nxt = self._extend_from(base, target_point, tree, grid)\n            if nxt is None:\n                break\n            last = nxt\n            base = nxt\n            if nxt.position == target_point:\n                return nxt\n            # If we are very close and can snap exactly\n            if self._dist(nxt.position, target_point) <= self.step and self._edge_free(nxt.position, target_point):\n                # Snap: ensure point-valid and no duplicate\n                tp = target_point\n                if (not self._point_blocked(tp)) and (not self._has_duplicate(grid, tp, self.dup_radius)):\n                    snap = Node(tp, nxt, nxt.cost + self._dist(nxt.position, tp))\n                    nxt.add_child(snap)\n                    tree.append(snap)\n                    self._nodes.append(snap)\n                    self._edges.append((nxt, snap))\n                    self._grid_add(grid, snap)\n                    return snap\n                else:\n                    # cannot snap; stop\n                    break\n        return last\n\n    # ---------- Sampling ----------\n    def _sample_target(self, attractor, best_len):\n        tries = 18\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            p = None\n            if best_len is not None and r < self.informed_bias:\n                p = self._sample_informed(best_len * 1.02)\n            if p is None:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    p = attractor\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    t = self._rand()\n                    base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n                    if self.dim == 3:\n                        p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                             self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w),\n                             self._rand_range(base[2] - self.corridor_w, base[2] + self.corridor_w))\n                    else:\n                        p = (self._rand_range(base[0] - self.corridor_w, base[0] + self.corridor_w),\n                             self._rand_range(base[1] - self.corridor_w, base[1] + self.corridor_w))\n                else:\n                    if self.dim == 3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if p is None:\n                continue\n            p = self._clamp(p)\n            if not self._point_blocked(p):\n                return p\n        return None\n\n    def _sample_informed(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        for _ in range(24):\n            if self.dim == 3:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half),\n                     self._rand_range(c[2] - half, c[2] + half))\n            else:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= max_sum + 1e-9:\n                return p\n        return None\n\n    # ---------- Path assembly and postprocess ----------\n    def _trace(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble(self, u, v, a_side):\n        pu = self._trace(u)\n        pv = self._trace(v)\n        if a_side:\n            # start->u + v->goal reversed\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        out[0] = pts[0]\n        out[-1] = pts[-1]\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3 or attempts <= 0:\n            return pts[:]\n        cur = list(pts)\n        best = self._path_len(cur)\n        stall = 0\n        for _ in range(attempts):\n            if len(cur) < 3:\n                break\n            i = int(self._rand_range(0, len(cur) - 2))\n            j = int(self._rand_range(i + 2, len(cur)))\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    cur = cand\n                    best = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            if stall > 64:\n                break\n        return cur\n\n    def _smooth_corners(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            k = 1\n            while k < len(cur) - 1:\n                a = cur[k - 1]\n                b = cur[k]\n                c = cur[k + 1]\n                # Weighted corner pull\n                newp = tuple(0.25 * a[i] + 0.5 * b[i] + 0.25 * c[i] for i in range(self.dim))\n                if (not self._point_blocked(newp)) and self._edge_free(a, newp) and self._edge_free(newp, c):\n                    cur[k] = newp\n                k += 1\n        cur[0] = pts[0]\n        cur[-1] = pts[-1]\n        return cur\n\n    def _postprocess(self, path):\n        p0 = self._visibility_prune(path)\n        p1 = self._shortcut(p0, self.shortcut_trials)\n        p2 = self._smooth_corners(p1, self.smooth_passes)\n        return p2",
            "objective": -42.99999,
            "time_improvement": 72.0,
            "length_improvement": 16.0,
            "smoothness_improvement": 2430.0,
            "node_improvement": 87.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.014277505874633788,
                    "num_nodes_avg": 76.0,
                    "path_length_avg": 167.21355485066445,
                    "smoothness_avg": 0.04013469633201503,
                    "success_improvement": 0.0,
                    "time_improvement": 42.1290717238007,
                    "node_improvement": 80.86124401913875,
                    "length_improvement": 8.347600918014143,
                    "smoothness_improvement": 528.1951514840665,
                    "objective_score": 20.288257825369026
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022111225128173827,
                    "num_nodes_avg": 121.0,
                    "path_length_avg": 242.3049263601756,
                    "smoothness_avg": 0.1876430362390729,
                    "success_improvement": 0.0,
                    "time_improvement": 86.77966198339568,
                    "node_improvement": 91.869918699187,
                    "length_improvement": 19.111641220372025,
                    "smoothness_improvement": 4728.1904762473905,
                    "objective_score": 61.14183570847888
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.007026815414428711,
                    "num_nodes_avg": 81.0,
                    "path_length_avg": 121.51158192729731,
                    "smoothness_avg": 0.167728285331934,
                    "success_improvement": 0.0,
                    "time_improvement": 86.07909606654616,
                    "node_improvement": 89.70120788302607,
                    "length_improvement": 19.297793043634346,
                    "smoothness_improvement": 2033.4914090080024,
                    "objective_score": 47.569861691184464
                }
            ],
            "success_rate": 1.0
        },
        "objective": 28.799999999999997,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - High per-iteration overhead from neighbor-based parent selection and local rewiring, including repeated collision checks, cycle detection, and subtree cost propagation.\n   - Excess node growth from unsuccessful connection attempts that still insert intermediate nodes, inflating future nearest/neighbor queries.\n   - Frequent fallback scans in nearest searches when spatial hashing misses, adding extra passes over growing trees.\n   - Sampling with strict gating and many rejection trials in cluttered regions, wasting iterations before a usable target is obtained.\n   - Redundant validity checks (point/edge) along multiple stages of insertion and optimization, increasing collision-test load.\n   - Heavy post-processing with many shortcut trials and visibility passes after building large, jagged trees."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Removal of neighbor-based parent optimization and rewiring; single-parent extensions only.\n   - Larger growth steps that reduce the number of iterations and total nodes required to span the space.\n   - Coarser node hashing and stronger duplicate suppression, lowering tree density and lookup overhead.\n   - Greedy opposite-tree connection that advances multiple steps toward the meet point, often closing the gap earlier.\n   - Opportunistic cross-tree visibility to form an incumbent quickly, enabling earlier informed sampling focus.\n2. Expected mechanism of impact:\n   - Eliminating rewiring avoids O(k-neighbor) edge tests and O(subtree) cost updates per insertion, cutting collision checks and memory traffic.\n   - Fewer, longer steps shrink the search horizon, reducing total expansions, nearest lookups, and post-process workload.\n   - Reduced node density lowers the cost of spatial queries and the chance of fallback scans, accelerating nearest/duplicate checks.\n   - Early, directed connect attempts curtail random exploration and iteration count once a viable corridor opens.\n   - Rapid incumbent discovery narrows the sampling region, decreasing rejected samples and focusing expansions on promising areas, further reducing runtime."
        }
    },
    {
        "parents": [
            {
                "operator": "e1",
                "algorithm_description": "ARROW-RRT*: Adaptive Ribbon-biTree with Weighted-Optimal Rewiring and Opportunistic Connect. It grows two informed, grid-indexed trees with dynamic long-step steering, curvature-aware parent selection, multi-hop visible-ancestor compression, and capped, cycle-safe rewiring. Admission uses a per-cell f-gate (g+h) to curb bloat, while a fast RRT-Connect-style opportunistic bridge commits only collision-free steps. Final paths are refined via visibility pruning, corner collapse, and elastic line-search smoothing. Robust node/edge collision checks are enforced at every add or reparent.",
                "planning_mechanism": "Alternate expanding start/goal trees. Each iteration: draw a target (uniform/goal/ribbon/ellipse), pick nearest via grid, long-step steer toward it, validate node and edge, gate by per-cell f = g+h, insert, compress to a visible better ancestor, then locally rewire neighbors. Try to connect directly to the other tree; otherwise greedily extend the other tree toward the new node with validated steps. On a successful merge, assemble and refine the path and return.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step=6.0,\n                 long_step_factor=2.2,\n                 goal_bias=0.18,\n                 informed_bias=0.5,\n                 ribbon_bias=0.22,\n                 grid_factor=1.4,\n                 ring_max=3,\n                 neighbor_radius_scale=3.2,\n                 dupe_ratio=0.45,\n                 cell_cap=10,\n                 gate_relax=1.25,\n                 rewire_cap=18,\n                 connect_steps=6,\n                 compress_hops=6,\n                 shortcut_attempts=100,\n                 smooth_passes=8,\n                 curvature_weight=0.1):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.long_step = float(step * long_step_factor)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.ribbon_bias = float(ribbon_bias)\n        self.grid_factor = float(grid_factor)\n        self.ring_max = int(ring_max)\n        self.neighbor_radius_scale = float(neighbor_radius_scale)\n        self.dupe_ratio = float(dupe_ratio)\n        self.cell_cap = int(cell_cap)\n        self.gate_relax = float(gate_relax)\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(1, connect_steps))\n        self.compress_hops = int(max(0, compress_hops))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self.curv_w = float(curvature_weight)\n        self._rng = 1234567\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._eindex = {}  # (id(p), id(c)) -> index in edges\n\n        # Basic validation\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self._build_obs_index()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early direct connection\n        if self._edge_free(self.start, self.goal):\n            a = Node(self.start, None, 0.0)\n            b = Node(self.goal, a, self._dist(self.start, self.goal))\n            a.add_child(b)\n            nodes.extend([a, b])\n            self._edges_add(edges, a, b)\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Structures\n        self.node_cell = max(1.0, self.step * self.grid_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        count_a, count_b = {}, {}\n        fbest_a, fbest_b = {}, {}\n\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        self._cell_inc(count_a, start_root.position)\n        self._cell_inc(count_b, goal_root.position)\n        self._cell_fbest_update(fbest_a, start_root.position, start_root.cost + self._dist(start_root.position, self.goal))\n        self._cell_fbest_update(fbest_b, goal_root.position, goal_root.cost + self._dist(goal_root.position, self.start))\n\n        best_len = float('inf')\n        sg = self._dist(self.start, self.goal)\n        corridor = max(self.step, 0.25 * sg)\n\n        for it in range(self.max_iter):\n            forward = (it % 2 == 0)\n            tree = tree_a if forward else tree_b\n            other_tree = tree_b if forward else tree_a\n            grid = grid_a if forward else grid_b\n            other_grid = grid_b if forward else grid_a\n            counts = count_a if forward else count_b\n            other_counts = count_b if forward else count_a\n            fbest = fbest_a if forward else fbest_b\n            other_fbest = fbest_b if forward else fbest_a\n            attractor = self.goal if forward else self.start\n            back = self.start if forward else self.goal\n\n            # Sample target\n            target = self._sample_target(best_len, sg, corridor, attractor)\n            if target is None:\n                continue\n\n            # Nearest and dynamic steering\n            near = self._nearest(grid, tree, target)\n            if near is None:\n                continue\n            q_new = self._steer_dynamic(near.position, target)\n            if (not self._in_bounds(q_new)) or self._point_blocked(q_new):\n                continue\n            if self._exists_close(grid, q_new, self.dupe_radius):\n                continue\n            if not self._edge_free(near.position, q_new):\n                continue\n\n            # Choose parent among neighbors with curvature penalty\n            radius = self._adaptive_radius(len(tree))\n            neigh = self._neighbors_within(grid, q_new, radius, 96)\n            parent, new_cost = self._choose_parent(neigh, near, q_new)\n\n            if parent is None:\n                continue\n            if self._point_blocked(q_new) or (not self._edge_free(parent.position, q_new)):\n                continue\n\n            # Admission gate: per-cell f = g + h\n            key = self._cell_key(q_new)\n            cc = counts.get(key, 0)\n            f_val = new_cost + self._dist(q_new, attractor)\n            fb = fbest.get(key, float('inf'))\n            if cc >= self.cell_cap and not (f_val + 1e-9 < fb * self.gate_relax):\n                continue\n\n            # Insert node (both checks passed)\n            nn = Node(q_new, parent, new_cost)\n            parent.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            self._grid_add(grid, nn)\n            self._cell_inc(counts, nn.position)\n            self._cell_fbest_update(fbest, nn.position, f_val)\n            self._edges_add(edges, parent, nn)\n\n            # Multi-hop visible ancestor compression\n            if self.compress_hops > 0:\n                self._compress_to_visible_ancestor(nn, edges, self.compress_hops)\n\n            # Local rewiring\n            if self.rewire_cap > 0:\n                self._rewire_neighbors(grid, nn, radius, edges, self.rewire_cap)\n\n            # Connection attempt to other tree\n            other_near = self._nearest(other_grid, other_tree, nn.position)\n            if other_near is not None:\n                # Direct\n                if self._edge_free(nn.position, other_near.position):\n                    path = self._assemble_path(nn, other_near, forward)\n                    best_len = self._path_len(path)\n                    path = self._refine_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # Opportunistic greedy extend from other side\n                bridged = self._greedy_extend(other_tree, other_grid, other_counts, other_fbest, other_near, nn.position, radius, edges)\n                if bridged is not None and self._edge_free(bridged.position, nn.position):\n                    path = self._assemble_path(nn, bridged, forward)\n                    L = self._path_len(path)\n                    if L < best_len:\n                        best_len = L\n                    path = self._refine_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n            # Update incumbent bound if straight link becomes available later\n            if other_near is not None and self._edge_free(nn.position, other_near.position):\n                tmp = self._assemble_path(nn, other_near, forward)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    corridor = max(self.step, 0.2 * best_len)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        v = 2166136261\n        for t in self.start + self.goal:\n            v ^= int(t * 10007 + 0.5) & 0xffffffff\n            v = (v * 16777619) & 0xffffffff\n        v ^= (len(self.obstacles) + 31) & 0xffffffff\n        self._rng = (v ^ 0x9E3779B9) & 0xffffffff\n        if self._rng == 0:\n            self._rng = 1234567\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _vec(self, a, b):\n        return tuple(b[i] - a[i] for i in range(self.dim))\n\n    def _cos(self, u, v):\n        du = 0.0\n        dv = 0.0\n        dot = 0.0\n        for i in range(self.dim):\n            ui = u[i]\n            vi = v[i]\n            dot += ui * vi\n            du += ui * ui\n            dv += vi * vi\n        if du <= 1e-18 or dv <= 1e-18:\n            return 1.0\n        c = dot / ((du ** 0.5) * (dv ** 0.5))\n        if c < -1.0:\n            c = -1.0\n        if c > 1.0:\n            c = 1.0\n        return c\n\n    # Steering\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(self._lerp(a, b, r))\n\n    def _steer_dynamic(self, a, b):\n        # If LOS, take a longer stride toward the target\n        if self._edge_free(a, b):\n            d = self._dist(a, b)\n            step = self.long_step if d > self.long_step else d\n            return self._steer(a, b, step)\n        return self._steer(a, b, self.step)\n\n    # Sampling\n    def _sample_target(self, best_len, sg, corridor, attractor):\n        for _ in range(28):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._sample_informed_ellipse(self.start, self.goal, best_len * 1.01)\n                if p is not None and not self._point_blocked(p):\n                    return p\n            elif r < self.goal_bias:\n                if not self._point_blocked(attractor):\n                    return attractor\n            elif r < self.goal_bias + self.ribbon_bias:\n                # Ribbon sampling along start-goal with bounded lateral jitter\n                t = self._rand()\n                base = self._lerp(self.start, self.goal, t)\n                w = corridor\n                if self.is3:\n                    p = (self._rand_range(base[0] - w, base[0] + w),\n                         self._rand_range(base[1] - w, base[1] + w),\n                         self._rand_range(base[2] - w, base[2] + w))\n                else:\n                    p = (self._rand_range(base[0] - w, base[0] + w),\n                         self._rand_range(base[1] - w, base[1] + w))\n                p = self._clamp(p)\n                if not self._point_blocked(p):\n                    return p\n            else:\n                if self.is3:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n                if not self._point_blocked(p):\n                    return p\n        return None\n\n    def _sample_informed_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(28):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and (not self._point_blocked(p)):\n                return p\n        return None\n\n    # Node grid\n    def _cell_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.node_cell), int(pos[1] // self.node_cell), int(pos[2] // self.node_cell))\n        return (int(pos[0] // self.node_cell), int(pos[1] // self.node_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _cell_inc(self, counts, pos):\n        k = self._cell_key(pos)\n        counts[k] = counts.get(k, 0) + 1\n\n    def _cell_fbest_update(self, fbest, pos, f):\n        k = self._cell_key(pos)\n        fb = fbest.get(k)\n        if fb is None or f + 1e-12 < fb:\n            fbest[k] = f\n\n    def _ring_cells(self, key, r):\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        yield (key[0] + dx, key[1] + dy, key[2] + dz)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    yield (key[0] + dx, key[1] + dy)\n\n    def _nearest(self, grid, tree, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, self.ring_max + 1):\n            cand = []\n            seen = set()\n            for cell in self._ring_cells(key, r):\n                b = grid.get(cell)\n                if b:\n                    for n in b:\n                        nid = id(n)\n                        if nid not in seen:\n                            seen.add(nid)\n                            cand.append(n)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        r_cells = int(radius // self.node_cell) + 1\n        r2 = radius * radius\n        cand = []\n        seen = set()\n        for cell in self._ring_cells(key, r_cells):\n            b = grid.get(cell)\n            if not b:\n                continue\n            for n in b:\n                nid = id(n)\n                if nid in seen:\n                    continue\n                seen.add(nid)\n                d2 = 0.0\n                p = n.position\n                for i in range(self.dim):\n                    di = p[i] - pos[i]\n                    d2 += di * di\n                if d2 <= r2:\n                    cand.append(n)\n                    if len(cand) >= cap:\n                        return cand\n        return cand\n\n    def _exists_close(self, grid, pos, radius):\n        nb = self._neighbors_within(grid, pos, radius, 1)\n        return len(nb) > 0\n\n    def _adaptive_radius(self, n_nodes_in_tree):\n        # Smoothly decreasing neighbor radius without log; favors early exploration, later refinement\n        t = float(n_nodes_in_tree)\n        base = 1.2 * self.step\n        extra = self.neighbor_radius_scale * self.step / ((1.0 + t) ** 0.33)\n        r = base + extra\n        if r < 1.1 * self.step:\n            r = 1.1 * self.step\n        return r\n\n    # Obstacles and collisions\n    def _build_obs_index(self):\n        self.obs_cell = max(3.0, self.step * 1.8)\n        self.ogrid = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.ogrid.get(k)\n                            if b is None:\n                                self.ogrid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.ogrid.get(k)\n                        if b is None:\n                            self.ogrid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.ogrid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.ogrid.get((cx, cy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.ogrid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.ogrid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parent selection, compression, rewiring\n    def _choose_parent(self, neighbors, fallback_near, q_new):\n        best = None\n        best_cost = 1e100\n        # include fallback_near in candidates\n        cand = list(neighbors)\n        if fallback_near not in cand:\n            cand.append(fallback_near)\n        for n in cand:\n            if not self._edge_free(n.position, q_new):\n                continue\n            base = n.cost + self._dist(n.position, q_new)\n            pen = 0.0\n            if n.parent is not None:\n                u = self._vec(n.parent.position, n.position)\n                v = self._vec(n.position, q_new)\n                c = self._cos(u, v)\n                pen = self.curv_w * self.step * max(0.0, 1.0 - c)\n            cst = base + pen\n            if cst + 1e-12 < best_cost:\n                best_cost = cst\n                best = n\n        if best is None:\n            return None, None\n        return best, best_cost\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _edges_add(self, edges, parent, child):\n        key = (id(parent), id(child))\n        if key in self._eindex:\n            return\n        edges.append((parent, child))\n        self._eindex[key] = len(edges) - 1\n\n    def _edges_remove(self, edges, parent, child):\n        key = (id(parent), id(child))\n        idx = self._eindex.get(key)\n        if idx is None:\n            return\n        last = len(edges) - 1\n        if idx != last:\n            edges[idx] = edges[last]\n            pk, ck = id(edges[idx][0]), id(edges[idx][1])\n            self._eindex[(pk, ck)] = idx\n        edges.pop()\n        self._eindex.pop(key, None)\n\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        if self._point_blocked(child.position) or self._point_blocked(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._edges_remove(edges, old, child)\n        new_parent.add_child(child)\n        self._edges_add(edges, new_parent, child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        # propagate costs\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            for c in n.children:\n                stack.append(c)\n\n    def _compress_to_visible_ancestor(self, node, edges, hop_limit):\n        curp = node.parent\n        if curp is None:\n            return\n        anc = curp.parent\n        best = curp\n        bestc = node.cost\n        hops = 0\n        while anc is not None and hops < hop_limit:\n            if self._edge_free(anc.position, node.position):\n                c = anc.cost + self._dist(anc.position, node.position)\n                if c + 1e-12 < bestc:\n                    bestc = c\n                    best = anc\n            anc = anc.parent\n            hops += 1\n        if best is not curp:\n            self._reparent(node, best, edges)\n\n    def _rewire_neighbors(self, grid, node, radius, edges, cap):\n        neigh = self._neighbors_within(grid, node.position, radius, 128)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            newc = node.cost + self._dist(node.position, nb.position)\n            if newc + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= cap:\n                    break\n\n    # Bridge\n    def _greedy_extend(self, tree, grid, counts, fbest, from_node, target_pos, radius, edges):\n        prev = from_node\n        steps = 0\n        while steps < self.connect_steps:\n            steps += 1\n            nxtp = self._steer_dynamic(prev.position, target_pos)\n            if (not self._in_bounds(nxtp)) or self._point_blocked(nxtp):\n                return None\n            if not self._edge_free(prev.position, nxtp):\n                return None\n            # choose parent among local neighbors for this side as well\n            nb = self._neighbors_within(grid, nxtp, radius, 64)\n            p, cost = self._choose_parent(nb, prev, nxtp)\n            if p is None:\n                return None\n            # admission gate on this side\n            key = self._cell_key(nxtp)\n            cc = counts.get(key, 0)\n            f_val = cost + self._dist(nxtp, (self.start if (tree[0].position == self.goal) else self.goal))\n            fb = fbest.get(key, float('inf'))\n            if cc >= self.cell_cap and not (f_val + 1e-9 < fb * self.gate_relax):\n                return prev\n            # add node with checks\n            q = Node(nxtp, p, cost)\n            if self._point_blocked(q.position) or (not self._edge_free(p.position, q.position)):\n                return None\n            p.add_child(q)\n            tree.append(q)\n            self._grid_add(grid, q)\n            self._cell_inc(counts, q.position)\n            self._cell_fbest_update(fbest, q.position, f_val)\n            self._edges_add(edges, p, q)\n            # light compression and tiny rewiring on other side chain\n            self._compress_to_visible_ancestor(q, edges, 2)\n            prev = q\n            if self._edge_free(prev.position, target_pos):\n                return prev\n        return prev\n\n    # Path assembly and refinement\n    def _assemble_path(self, a_leaf, b_leaf, a_forward):\n        pa = a_leaf.path_to_root()\n        pb = b_leaf.path_to_root()\n        if a_forward:\n            return pa + pb[::-1]\n        else:\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _refine_path(self, path):\n        if len(path) < 2:\n            return path[:]\n        p0 = self._visibility_prune(path)\n        p1 = self._corner_collapse(p0)\n        p2 = self._elastic_smooth(p1, self.smooth_passes)\n        return p2\n\n    def _visibility_prune(self, pts):\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _corner_collapse(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 2:\n            a = out[-1]\n            c = pts[i + 2]\n            if self._edge_free(a, c):\n                out.append(c)\n                i += 2\n            else:\n                out.append(pts[i + 1])\n                i += 1\n        if out[-1] != pts[-1]:\n            out.append(pts[-1])\n        return out\n\n    def _elastic_smooth(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                target = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                # line search toward target\n                t = 1.0\n                best = b\n                while t > 1e-3:\n                    cand = tuple(b[k] + (target[k] - b[k]) * t for k in range(self.dim))\n                    if (not self._point_blocked(cand)) and self._edge_free(a, cand) and self._edge_free(cand, c):\n                        best = cand\n                        break\n                    t *= 0.5\n                if best != b:\n                    cur[i] = best\n                    moved = True\n            if not moved:\n                break\n        return cur",
                "objective": -33.74014,
                "time_improvement": 54.0,
                "length_improvement": 15.0,
                "smoothness_improvement": 1770.0,
                "node_improvement": 88.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.02561943531036377,
                        "num_nodes_avg": 90.0,
                        "path_length_avg": 173.11440391725938,
                        "smoothness_avg": 0.0720177255970773,
                        "success_improvement": 0.0,
                        "time_improvement": -3.8431023136117632,
                        "node_improvement": 77.33568370687485,
                        "length_improvement": 5.113252039676346,
                        "smoothness_improvement": 1027.2337945884865,
                        "objective_score": 7.051189502664712
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.019404673576354982,
                        "num_nodes_avg": 81.0,
                        "path_length_avg": 243.30655936651905,
                        "smoothness_avg": 0.09368068120607763,
                        "success_improvement": 0.0,
                        "time_improvement": 88.39791362558161,
                        "node_improvement": 94.55754888127393,
                        "length_improvement": 18.777267292447043,
                        "smoothness_improvement": 2310.471402899671,
                        "objective_score": 49.338091477641065
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.01148691177368164,
                        "num_nodes_avg": 63.0,
                        "path_length_avg": 120.97749511986653,
                        "smoothness_avg": 0.1629992507037538,
                        "success_improvement": 0.0,
                        "time_improvement": 77.24314844458131,
                        "node_improvement": 91.98982835346472,
                        "length_improvement": 19.652508070649073,
                        "smoothness_improvement": 1973.3384375985765,
                        "objective_score": 44.83114156375672
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "time_expert",
                "algorithm_description": "FLASH-IBiRRT: A fast, informed bidirectional RRT-Connect with bounded parenting and zero-cost rewiring. It grows two trees with large-step greedy connections, uses a compact spatial hash and obstacle bins for O(1)-like queries, schedules goal/segment-biased sampling, and returns on the first valid connection. Post-processing applies a single shortcut pass and visibility pruning for quick, smooth paths.",
                "planning_mechanism": "Alternate expansions from start/goal: sample (goal/line/uniform), steer one step from the active tree, insert only if node- and edge-free, then greedily connect the opposite tree with larger steps, inserting the exact meeting point when visible. No global rewiring; a small, local best-parent choice near the extension reduces cost at negligible overhead. Early exit upon connection, followed by fast shortcut and visibility prune.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=7.5,\n        connect_factor=2.6,\n        goal_bias=0.18,\n        line_bias=0.22,\n        grid_cell_factor=2.0,\n        k_parent=6,\n        smooth_attempts=60\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = self.step * float(connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.k_parent = int(max(1, k_parent))\n        self.smooth_attempts = int(max(0, smooth_attempts))\n        self._rng = 246813579\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dup_radius = max(0.4, 0.35 * self.step)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            final = self._finalize_path(path)\n            return PlannerResult(True, final, nodes, edges)\n\n        # Initialize trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [start_root], [goal_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n        nodes.extend([start_root, goal_root])\n\n        for it in range(self.max_iter):\n            # Two fast passes per iteration: grow both sides toward a single sample\n            attract_a = self.goal\n            attract_b = self.start\n            sample = self._sample(attract_a, attract_b)\n            if sample is None:\n                continue\n\n            # pass 1: start tree\n            res = self._expand_and_connect(Ta, Ga, Tb, Gb, sample, nodes, edges, active_is_start=True)\n            if res is not None:\n                path = res\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n            # pass 2: goal tree\n            res = self._expand_and_connect(Tb, Gb, Ta, Ga, sample, nodes, edges, active_is_start=False)\n            if res is not None:\n                path = res\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # Core expansion + connection\n    def _expand_and_connect(self, Ta, Ga, Tb, Gb, sample, nodes, edges, active_is_start):\n        na = self._nearest(Ga, sample)\n        if na is None:\n            return None\n\n        # Choose a lightweight best parent among k nearest in the grid ring\n        target = self._steer(na.position, sample, self.step)\n        if (not self._in_bounds(target)) or self._point_in_obstacles(target):\n            return None\n\n        parent = self._best_parent(Ga, target, na, self.k_parent)\n        if parent is None:\n            return None\n\n        if (not self._edge_free(parent.position, target)):\n            return None\n\n        if self._too_close(Ga, target, self.dup_radius):\n            return None\n\n        new_cost = parent.cost + self._dist(parent.position, target)\n        nn = Node(target, parent, new_cost)\n        parent.add_child(nn)\n        Ta.append(nn)\n        nodes.append(nn)\n        edges.append((parent, nn))\n        self._grid_add(Ga, nn)\n\n        meet_node, reached = self._connect_toward(Tb, Gb, nn.position, nodes, edges)\n        if reached:\n            pa = self._trace_to_root(nn)\n            pb = self._trace_to_root(meet_node)\n            if active_is_start:\n                # pa goes start->...->nn, pb goes goal->...->meet\n                # Join paths; include meet if different from nn\n                if pa[-1] != pb[-1]:\n                    path = pa + [pb[-1]] + pb[-2::-1]\n                else:\n                    path = pa + pb[-2::-1]\n            else:\n                # pa goes goal->...->nn, pb goes start->...->meet\n                if pa[-1] != pb[-1]:\n                    path = pb + [pa[-1]] + pa[-2::-1]\n                else:\n                    path = pb + pa[-2::-1]\n            return self._dedup(path)\n        return None\n\n    # RNG and sampling\n    def _seed_from_scene(self):\n        s = 0xA341316C & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 11400714819323198485 & 0xffffffff)\n            s ^= (q ^ (q >> 15) ^ ((q << 9) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 29) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 246813579\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _sample(self, attract_a, attract_b):\n        r = self._rand()\n        # Goal bias\n        if r < self.goal_bias:\n            return attract_a\n        # Segment (start-goal) bias\n        if r < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                return (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                        self.start[1] + (self.goal[1] - self.start[1]) * t,\n                        self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                return (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                        self.start[1] + (self.goal[1] - self.start[1]) * t)\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash for nodes\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _k_nearest(self, grid, pos, kmax):\n        key = self._cell_key(pos)\n        heap = []\n        # simple partial selection without imports\n        cand = []\n        for r in range(0, 2):\n            cand.extend(self._grid_collect(grid, key, r))\n        if not cand:\n            for lst in grid.values():\n                cand.extend(lst)\n        # unique nodes (avoid tiny overhead of set by ID)\n        seen = {}\n        out = []\n        for n in cand:\n            if id(n) in seen:\n                continue\n            seen[id(n)] = True\n            out.append((self._dist2(n.position, pos), n))\n        out.sort(key=lambda x: x[0])\n        return [n for (_, n) in out[:kmax]]\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            if key in self.obin:\n                                self.obin[key].append(idx)\n                            else:\n                                self.obin[key] = [idx]\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        if key in self.obin:\n                            self.obin[key].append(idx)\n                        else:\n                            self.obin[key] = [idx]\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Local best parent (bounded k-NN)\n    def _best_parent(self, grid, newp, fallback, kmax):\n        best = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        kn = self._k_nearest(grid, newp, kmax)\n        for n in kn:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = c\n        return best\n\n    # Greedy connect from the other tree toward a target position\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < 48:\n            if self._edge_free(cur.position, target_pos):\n                # Insert exact meeting point if sufficiently far/unique\n                if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                    if not self._too_close(grid, target_pos, 0.75 * self.dup_radius):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        cur.add_child(nn)\n                        tree.append(nn)\n                        nodes.append(nn)\n                        edges.append((cur, nn))\n                        self._grid_add(grid, nn)\n                        return nn, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(grid, nxt, 0.75 * self.dup_radius):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n        # Last visibility try\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._too_close(grid, target_pos, 0.75 * self.dup_radius):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    edges.append((cur, nn))\n                    self._grid_add(grid, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Utilities\n    def _neighbors_in_radius(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        nbr = self._neighbors_in_radius(grid, pos, radius)\n        return len(nbr) > 0\n\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    # Fast, light smoothing\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._shortcut(path, self.smooth_attempts)\n        p2 = self._visibility_prune(p1)\n        return self._dedup(p2)",
                "objective": -37.07801,
                "time_improvement": 75.0,
                "length_improvement": 11.0,
                "smoothness_improvement": 1629.0,
                "node_improvement": 89.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.014019584655761719,
                        "num_nodes_avg": 83.0,
                        "path_length_avg": 188.21860119077922,
                        "smoothness_avg": 0.04147767672480912,
                        "success_improvement": 0.0,
                        "time_improvement": 43.17450224151976,
                        "node_improvement": 79.0984638630068,
                        "length_improvement": -3.1655978272618333,
                        "smoothness_improvement": 549.2157109598944,
                        "objective_score": 13.799070530898302
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.009280896186828614,
                        "num_nodes_avg": 72.0,
                        "path_length_avg": 247.55425918283944,
                        "smoothness_avg": 0.12140082327282926,
                        "success_improvement": 0.0,
                        "time_improvement": 94.45093684426602,
                        "node_improvement": 95.16226567224349,
                        "length_improvement": 17.35926283049915,
                        "smoothness_improvement": 3023.7306242884893,
                        "objective_score": 53.869491873021744
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.005894255638122558,
                        "num_nodes_avg": 52.0,
                        "path_length_avg": 124.23642750462632,
                        "smoothness_avg": 0.11125496209005074,
                        "success_improvement": 0.0,
                        "time_improvement": 88.32282311998175,
                        "node_improvement": 93.38842975206612,
                        "length_improvement": 17.48808035437552,
                        "smoothness_improvement": 1315.154905798364,
                        "objective_score": 43.56546967761165
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "SAGE-Connect*: Simple Adaptive Grid Explorer with Informed Bidirectional Growth, Gentle Rewiring, and Fast Smoothing. It builds two trees from start and goal using a compact spatial hash, adaptive neighbor radius, LOS-aware stepping, lightweight k-best parenting, capped local rewiring, and a restrained greedy connect. Once a valid bridge is found, the path is shortcut-pruned and elastically smoothed with collision-aware line search for robust, short, and smooth trajectories.",
            "planning_mechanism": "Alternate expanding start/goal trees. Each iteration: draw a target (goal/segment/uniform; switch to informed-ellipse once a path exists), pick nearest via grid, steer with LOS-adaptive step, enforce node and edge collision checks, suppress duplicates, select a low-cost parent from nearby nodes, add the node, and locally rewire a few neighbors if the new route is cheaper (cycle-safe, edge-checked). Attempt a short greedy connect from the other tree; on success, assemble the bidirectional path, then apply shortcutting and visibility pruning followed by elastic midpoint smoothing before returning.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step=6.0,\n        connect_factor=1.9,\n        goal_bias=0.16,\n        line_bias=0.22,\n        informed_bias=0.45,\n        grid_cell_factor=1.6,\n        neighbor_radius_scale=3.0,\n        dupe_ratio=0.4,\n        rewire_cap=12,\n        connect_steps=12,\n        shortcut_attempts=90,\n        smooth_passes=6\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.connect_step = float(step * connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_radius_scale = float(neighbor_radius_scale)\n        self.dupe_ratio = float(dupe_ratio)\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(1, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 123456789\n        self._eindex = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._eindex = {}\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            self._edges_add(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Trees and grids\n        Ta, Tb = [], []\n        Ga, Gb = {}, {}\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta.append(start_root)\n        Tb.append(goal_root)\n        nodes.extend([start_root, goal_root])\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            # Sample a common target for both directions for coherence\n            sample = self._sample_target(best_len)\n            if sample is None:\n                continue\n\n            # Expand from start side\n            res = self._expand_and_maybe_connect(Ta, Ga, Tb, Gb, sample, nodes, edges)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n            # Expand from goal side\n            res = self._expand_and_maybe_connect(Tb, Gb, Ta, Ga, sample, nodes, edges)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # Core expansion and connection\n    def _expand_and_maybe_connect(self, Ta, Ga, Tb, Gb, target, nodes, edges):\n        na = self._nearest(Ga, target)\n        if na is None:\n            return None\n        q_new = self._steer_dynamic(na.position, target)\n        if (not self._in_bounds(q_new)) or self._point_blocked(q_new):\n            return None\n        if self._too_close(Ga, q_new, self.dupe_radius):\n            return None\n\n        parent = self._select_parent(Ga, q_new, na)\n        if parent is None:\n            return None\n        # Both checks before adding node/edge\n        if self._point_blocked(q_new) or (not self._edge_free(parent.position, q_new)):\n            return None\n\n        cost = parent.cost + self._dist(parent.position, q_new)\n        nn = Node(q_new, parent, cost)\n        parent.add_child(nn)\n        Ta.append(nn)\n        nodes.append(nn)\n        self._grid_add(Ga, nn)\n        self._edges_add(edges, parent, nn)\n\n        # Gentle local rewiring\n        if self.rewire_cap > 0:\n            self._rewire_neighbors(Ga, nn, edges, self.rewire_cap)\n\n        # Try greedy connect from the opposite tree\n        meet, ok = self._greedy_connect(Tb, Gb, nn.position, nodes, edges)\n        if ok:\n            pa = nn.path_to_root()\n            pb = meet.path_to_root()\n            # Determine which root belongs to which\n            if Ta[0].position == self.start:\n                # pa: start->..., pb: goal->...\n                path = pa + pb[-2::-1]\n            else:\n                # pa: goal->..., pb: start->...\n                path = pb + pa[-2::-1]\n            L = self._path_len(path)\n            return (self._dedup(path), L)\n        return None\n\n    # RNG\n    def _seed_rng(self):\n        s = 2166136261\n        for v in self.start + self.goal:\n            s ^= int(v * 10007 + 0.5) & 0xffffffff\n            s = (s * 16777619) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Sampling\n    def _sample_target(self, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._sample_informed_ellipse(self.start, self.goal, best_len * 1.01)\n            if p is not None and self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return self.goal\n        if r2 < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t,\n                     self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t)\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_informed_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and (not self._point_blocked(p)):\n                return p\n        return None\n\n    # Geometry helpers\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(self._lerp(a, b, r))\n\n    def _steer_dynamic(self, a, b):\n        if self._edge_free(a, b):\n            d = self._dist(a, b)\n            step = self.connect_step if d > self.connect_step else d\n            return self._steer(a, b, step)\n        return self._steer(a, b, self.step)\n\n    # Node grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n            if best is not None:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        seen = {}\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            i2 = id(n)\n                            if i2 in seen:\n                                continue\n                            seen[i2] = True\n                            d2 = 0.0\n                            p = n.position\n                            for i in range(self.dim):\n                                di = p[i] - pos[i]\n                                d2 += di * di\n                            if d2 <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        i2 = id(n)\n                        if i2 in seen:\n                            continue\n                        seen[i2] = True\n                        d2 = 0.0\n                        p = n.position\n                        for i in range(self.dim):\n                            di = p[i] - pos[i]\n                            d2 += di * di\n                        if d2 <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _adaptive_radius(self, n_nodes):\n        t = float(max(1, n_nodes))\n        base = 1.2 * self.step\n        extra = self.neighbor_radius_scale * self.step / ((1.0 + t) ** (1.0 / 3.0))\n        r = base + extra\n        if r < 1.05 * self.step:\n            r = 1.05 * self.step\n        return r\n\n    def _too_close(self, grid, pos, radius):\n        nb = self._neighbors_within(grid, pos, radius, 1)\n        return len(nb) > 0\n\n    # Parent selection\n    def _select_parent(self, grid, newp, fallback_near):\n        r = self._adaptive_radius(len(grid))\n        neigh = self._neighbors_within(grid, newp, r, 96)\n        best = fallback_near\n        best_cost = fallback_near.cost + self._dist(fallback_near.position, newp)\n        for n in neigh:\n            if n is fallback_near:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = c\n        return best\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _rewire_neighbors(self, grid, node, edges, cap):\n        r = self._adaptive_radius(len(grid))\n        neigh = self._neighbors_within(grid, node.position, r, 128)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            if self._point_blocked(nb.position) or self._point_blocked(node.position):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            newc = node.cost + self._dist(node.position, nb.position)\n            if newc + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= cap:\n                    break\n\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        if self._point_blocked(child.position) or self._point_blocked(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._edges_remove(edges, old, child)\n        new_parent.add_child(child)\n        self._edges_add(edges, new_parent, child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            for c in n.children:\n                stack.append(c)\n\n    # Greedy connect\n    def _greedy_connect(self, T, G, target_pos, nodes, edges):\n        cur = self._nearest(G, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < self.connect_steps:\n            # Visible? insert exact meeting point\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                    if not self._too_close(G, target_pos, 0.75 * self.dupe_radius):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                            return cur, True\n                        cur.add_child(nn)\n                        T.append(nn)\n                        nodes.append(nn)\n                        self._grid_add(G, nn)\n                        self._edges_add(edges, cur, nn)\n                        return nn, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(G, nxt, 0.75 * self.dupe_radius):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                return cur, False\n            cur.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            self._grid_add(G, nn)\n            self._edges_add(edges, cur, nn)\n            cur = nn\n            steps += 1\n        # Final visibility check\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                if not self._too_close(G, target_pos, 0.75 * self.dupe_radius):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                        return cur, True\n                    cur.add_child(nn)\n                    T.append(nn)\n                    nodes.append(nn)\n                    self._grid_add(G, nn)\n                    self._edges_add(edges, cur, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(3.5, self.step * 1.6)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Edge bookkeeping\n    def _edges_add(self, edges, parent, child):\n        key = (id(parent), id(child))\n        if key in self._eindex:\n            return\n        edges.append((parent, child))\n        self._eindex[key] = len(edges) - 1\n\n    def _edges_remove(self, edges, parent, child):\n        key = (id(parent), id(child))\n        idx = self._eindex.get(key)\n        if idx is None:\n            return\n        last = len(edges) - 1\n        if idx != last:\n            edges[idx] = edges[last]\n            pk, ck = id(edges[idx][0]), id(edges[idx][1])\n            self._eindex[(pk, ck)] = idx\n        edges.pop()\n        self._eindex.pop(key, None)\n\n    # Path utilities and smoothing\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _elastic_smooth(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                target = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                t = 1.0\n                best = b\n                while t > 1e-3:\n                    cand = tuple(b[k] + (target[k] - b[k]) * t for k in range(self.dim))\n                    cand = self._clamp(cand)\n                    if (not self._point_blocked(cand)) and self._edge_free(a, cand) and self._edge_free(cand, c):\n                        best = cand\n                        break\n                    t *= 0.5\n                if best != b:\n                    cur[i] = best\n                    moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._shortcut(path, self.shortcut_attempts)\n        p2 = self._visibility_prune(p1)\n        p3 = self._elastic_smooth(p2, self.smooth_passes)\n        return self._dedup(p3)",
            "objective": -47.53913,
            "time_improvement": 86.0,
            "length_improvement": 21.0,
            "smoothness_improvement": 1812.0,
            "node_improvement": 93.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.004579019546508789,
                    "num_nodes_avg": 30.0,
                    "path_length_avg": 146.96078572191126,
                    "smoothness_avg": 0.03859037591406768,
                    "success_improvement": 0.0,
                    "time_improvement": 81.43988774523116,
                    "node_improvement": 92.44522790229162,
                    "length_improvement": 19.448464603147585,
                    "smoothness_improvement": 504.0231833977275,
                    "objective_score": 38.621161002446534
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023305273056030272,
                    "num_nodes_avg": 122.0,
                    "path_length_avg": 229.66193713526982,
                    "smoothness_avg": 0.11885248032537557,
                    "success_improvement": 0.0,
                    "time_improvement": 86.065738755588,
                    "node_improvement": 91.80272794463482,
                    "length_improvement": 23.332234931912975,
                    "smoothness_improvement": 2958.1599247532718,
                    "objective_score": 54.609862209590545
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.004154682159423828,
                    "num_nodes_avg": 32.0,
                    "path_length_avg": 120.49632735979439,
                    "smoothness_avg": 0.1630888303105967,
                    "success_improvement": 0.0,
                    "time_improvement": 91.76911192279043,
                    "node_improvement": 95.93134138588684,
                    "length_improvement": 19.972076786142434,
                    "smoothness_improvement": 1974.4778835855395,
                    "objective_score": 49.38636906645029
                }
            ],
            "success_rate": 1.0
        },
        "objective": 47.2,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient nearest/neighbor searches with frequent fallbacks to full scans due to coarse spatial grids and small search radii\n   - Oversized connection strides and long greedy-connect loops causing repeated collision failures and wasted expansion attempts\n   - Rejection-heavy sampling (goal/line/ribbon or ellipse) that over-samples blocked regions and stalls progress in clutter\n   - Missing or heavy-handed rewiring in some variants, leading to suboptimal parents, longer detours, and more nodes before a bridge forms\n   - Curvature-penalized parent choice and per-cell admission gates adding many extra edge checks without consistent payoff\n   - Early acceptance of suboptimal bridges and limited post-optimization, leaving longer routes that hinder informed sampling focus\n   - Smoothing stages either too light (leaving kinks) or too heavy (extra passes), adding compute without proportional benefit"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - LOS-aware, reduced connection stride with a strict cap on connect steps to curb failed edge checks\n   - Shared-target bidirectional growth for coherent expansions and faster meeting of the trees\n   - Informed-ellipse sampling after the first incumbent to concentrate samples where improvements are plausible\n   - Adaptive neighbor radius with capped local rewiring to quickly lower local costs and ease future connections\n   - Lean collision binning and simplified grid queries to avoid frequent O(N) fallbacks\n   - Early exact-meeting insertion when visibility holds, minimizing incremental connect attempts\n   - Lightweight, staged smoothing (shortcut + visibility + few elastic passes) to trim post-processing time\n2. Expected mechanism of impact:\n   - Fewer large-step collisions and shorter connect loops reduce expensive edge and point checks per iteration\n   - Coherent dual-tree targeting increases the probability of successful extensions, cutting iterations to first solution\n   - Focused sampling shrinks the search domain after an incumbent appears, accelerating convergence and reducing rejections\n   - Local rewiring improves parent quality early, enabling shorter bridges and fewer nodes, which reduces downstream checks\n   - More effective spatial hashing limits neighbor/nearest scans, avoiding quadratic fallbacks as the tree grows\n   - Early visibility-based meeting lowers path assembly overhead and curtails additional connect expansions\n   - A balanced smoothing pipeline removes most kinks with minimal passes, limiting compute after solution discovery"
        }
    },
    {
        "parents": [
            {
                "operator": "cross_over",
                "algorithm_description": "FLASH-Infer-R*: Fast Lazy-bridged Adaptive Sampling BiRRT* with Hashed Neighbors and Cached Collisions. It balances two RRT* trees using a dual hash-grid for O(1)-ish neighbor/nearest queries, selects least-cost parents with turn-aware scoring, does bounded local rewiring with O(1) edge maintenance, and uses a lazy micro-bridge that commits only if a short connector succeeds. Collision checks are obstacle-binned and memoized. After connection it applies visibility collapse, shortcuts, and safe rounding for shorter, smoother paths at low time.",
                "planning_mechanism": "Mechanism: Alternate growing start/goal trees with goal/corridor-biased sampling. For each sample: find a nearby anchor via ringed hash-grid, steer one step, select the best visible parent among local neighbors (no hard distance cap), validate both node and edge, insert, and lightly rewire. Probe the opposite tree: first try direct line-of-sight; else simulate a few greedily steered steps (lazy micro-bridge) and commit only if the final link closes. On success, assemble and smooth the path and return.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            # detach from old parent\n            p = self.parent\n            for i in range(len(p.children) - 1, -1, -1):\n                if p.children[i] is self:\n                    p.children.pop(i)\n                    break\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4500,\n                 step_size=6.0,\n                 goal_bias=0.32,\n                 corridor_bias=0.28,\n                 grid_cell_factor=1.6,\n                 neighbor_radius_factor=2.3,\n                 dupe_radius_ratio=0.28,\n                 k_parent_cap=24,\n                 k_rewire=6,\n                 connect_hops=3,\n                 smoothing_shortcuts=100,\n                 smoothing_rounds=5):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.cell_factor = float(grid_cell_factor)\n        self.nei_factor = float(neighbor_radius_factor)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.k_parent_cap = int(max(4, k_parent_cap))\n        self.k_rewire = int(max(0, k_rewire))\n        self.connect_hops = int(max(1, connect_hops))\n        self.smoothing_shortcuts = int(max(0, smoothing_shortcuts))\n        self.smoothing_rounds = int(max(0, smoothing_rounds))\n        self._rng = 123456789\n\n    def plan(self, map):\n        # Setup\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", [])) if getattr(map, \"obstacles\", None) is not None else []\n        self._seed_rng()\n\n        nodes = []\n        edges = []\n        self._edge_idx = {}  # (id(p), id(c)) -> index in edges\n\n        # Validate endpoints and bounds\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Build obstacle bins first\n        self._build_obs_bins()\n        self._seg_cache = {}\n        self._seg_tick = 0\n        self._seg_cap = 4096\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight-line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            nodes.extend([n0, n1])\n            self._add_edge(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._postprocess(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Spatial params\n        self.cell = max(1.0, self.step * self.cell_factor)\n        self.nei_radius = max(1.5 * self.step, self.step * self.nei_factor)\n        self.dupe_radius = max(0.35, self.step * self.dupe_ratio)\n\n        # Trees and grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        A, B = [a_root], [b_root]\n        GA, GB = {}, {}\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n        nodes.extend([a_root, b_root])\n\n        frontierA, frontierB = [a_root], [b_root]\n\n        for it in range(self.max_iter):\n            # Balanced alternating growth\n            if it % 3 == 2:\n                growA = (len(A) <= len(B))\n            else:\n                growA = (it % 2 == 0)\n            T = A if growA else B\n            O = B if growA else A\n            G = GA if growA else GB\n            GO = GB if growA else GA\n            frontier = frontierA if growA else frontierB\n            frontierO = frontierB if growA else frontierA\n            attract = self.goal if growA else self.start\n\n            # Guided sample\n            target = self._sample_target(attract)\n            if target is None:\n                continue\n\n            # Nearest anchor\n            qnear = self._nearest(G, frontier, target, max_rings=2)\n            if qnear is None:\n                qnear = T[-1]\n            qnew_pos = self._steer(qnear.position, target, self.step)\n            if (not self._in_bounds(qnew_pos)) or self._point_blocked(qnew_pos):\n                continue\n            if self._has_close(G, qnew_pos, self.dupe_radius):\n                continue\n\n            # Best-parent selection (turn-aware, bounded candidates)\n            parent, bestc = self._choose_parent(G, qnew_pos, qnear)\n            if parent is None:\n                continue\n\n            # Both checks before insertion\n            if self._point_blocked(qnew_pos):\n                continue\n            if not self._edge_free(parent.position, qnew_pos):\n                continue\n\n            qnode = Node(qnew_pos, parent, bestc)\n            qnode.attach(parent)\n            T.append(qnode)\n            nodes.append(qnode)\n            self._grid_add(G, qnode)\n            self._add_edge(edges, parent, qnode)\n\n            frontier.append(qnode)\n            if len(frontier) > 160:\n                del frontier[:16]\n\n            # Bounded local rewiring\n            if self.k_rewire > 0:\n                self._rewire_local(qnode, G, edges, k=self.k_rewire)\n\n            # Try to connect to opposite tree\n            other_near = self._nearest(GO, frontierO, qnode.position, max_rings=2)\n            if other_near is not None:\n                # Direct LOS bridge\n                if self._edge_free(qnode.position, other_near.position):\n                    path = self._assemble_path(qnode, other_near, growA)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n                # Lazy micro-bridge on the opposite tree\n                qlast = self._micro_bridge(O, GO, other_near, qnode.position)\n                if qlast is not None and self._edge_free(qnode.position, qlast.position):\n                    path = self._assemble_path(qnode, qlast, growA)\n                    path = self._postprocess(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s ^= (int(v * 2654435761) & 0xffffffff)\n            s = (s * 1664525 + 1013904223) & 0xffffffff\n        s ^= len(self.obstacles) * 374761393\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        # xorshift32\n        x = self._rng & 0xffffffff\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Obstacle bins and collisions\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self._obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self._obin.get(key)\n                            if lst is None:\n                                self._obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self._obin.get(key)\n                        if lst is None:\n                            self._obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_bucket(self, p):\n        if self.is3:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell),\n                                   int(p[2] // self.obs_cell)))\n        else:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell)))\n\n    def _point_blocked(self, p):\n        bucket = self._point_bucket(p)\n        if not bucket:\n            return False\n        if self.is3:\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _seg_box_intersect(self, a, b, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(self.dim):\n            p = a[i]\n            d = b[i] - a[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _edge_cache_key(self, a, b):\n        # quantize endpoints to reduce cache keys\n        s = self.obs_cell if self.obs_cell > 0 else 1.0\n        qa = []\n        qb = []\n        for i in range(self.dim):\n            qa.append(int(a[i] / s * 8.0))\n            qb.append(int(b[i] / s * 8.0))\n        ka = tuple(qa)\n        kb = tuple(qb)\n        if ka <= kb:\n            return (ka, kb)\n        else:\n            return (kb, ka)\n\n    def _edge_free(self, a, b):\n        # Cached obstacle-binned segment test\n        key = self._edge_cache_key(a, b)\n        hit = self._seg_cache.get(key)\n        if hit is not None:\n            return hit\n        # candidate obstacles by segment bbox\n        if self.is3:\n            mn = (min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            iz0 = int(max(0.0, mn[2]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self._obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if cand:\n                for idx in cand:\n                    ox, oy, oz, w, h, d = self.obstacles[idx]\n                    if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                        self._cache_seg(key, False)\n                        return False\n            self._cache_seg(key, True)\n            return True\n        else:\n            mn = (min(a[0], b[0]), min(a[1], b[1]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self._obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if cand:\n                for idx in cand:\n                    ox, oy, w, h = self.obstacles[idx]\n                    if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                        self._cache_seg(key, False)\n                        return False\n            self._cache_seg(key, True)\n            return True\n\n    def _cache_seg(self, key, val):\n        # tiny LRU-like reset to bound memory\n        self._seg_cache[key] = val\n        self._seg_tick += 1\n        if self._seg_tick >= self._seg_cap:\n            self._seg_cache.clear()\n            self._seg_tick = 0\n\n    # Grid utilities\n    def _cell_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, frontier, pos, max_rings=2):\n        kk = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring(grid, kk, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bd:\n                        bd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # fallback to recent frontier to avoid full scan\n        if frontier:\n            lim = min(32, len(frontier))\n            for i in range(lim):\n                n = frontier[-1 - i]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bd:\n                    bd = d2\n                    best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap=None):\n        kk = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        limit = self.k_parent_cap if cap is None else int(cap)\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((kk[0] + dx, kk[1] + dy, kk[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if len(out) >= limit:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((kk[0] + dx, kk[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if len(out) >= limit:\n                                return out\n        return out\n\n    def _has_close(self, grid, pos, radius):\n        ns = self._neighbors(grid, pos, radius, cap=6)\n        return len(ns) > 0\n\n    # Parent selection with small turn penalty\n    def _choose_parent(self, grid, new_pos, fallback):\n        cand = self._neighbors(grid, new_pos, self.nei_radius, cap=self.k_parent_cap)\n        if fallback not in cand:\n            cand.append(fallback)\n        # Prefer closest few by distance to reduce collisions\n        cand.sort(key=lambda n: self._dist2(n.position, new_pos))\n        best = None\n        best_cost = 1e100\n        for p in cand:\n            if not self._edge_free(p.position, new_pos):\n                continue\n            d = self._dist(p.position, new_pos)\n            c = p.cost + d\n            # Turn penalty: prefer smoother joins\n            if p.parent is not None:\n                u = tuple(p.position[i] - p.parent.position[i] for i in range(self.dim))\n                v = tuple(new_pos[i] - p.position[i] for i in range(self.dim))\n                nu = max(1e-12, self._dist((0.0,) * self.dim, u))\n                nv = max(1e-12, self._dist((0.0,) * self.dim, v))\n                dot = 0.0\n                for i in range(self.dim):\n                    dot += u[i] * v[i]\n                cosang = max(-1.0, min(1.0, dot / (nu * nv)))\n                c += 0.06 * self.step * (1.0 - cosang)\n            if c < best_cost:\n                best_cost = c\n                best = p\n        return best, best_cost\n\n    # Rewiring\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_delta(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire_local(self, new_node, grid, edges, k=6):\n        neigh = self._neighbors(grid, new_node.position, self.nei_radius, cap=32)\n        if not neigh:\n            return\n        neigh.sort(key=lambda n: self._dist2(n.position, new_node.position))\n        count = 0\n        for nb in neigh:\n            if count >= k:\n                break\n            if nb is new_node or nb is new_node.parent:\n                continue\n            if self._is_ancestor(nb, new_node):\n                continue\n            if self._point_blocked(nb.position):\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand_cost + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    # detach from old parent\n                    for i in range(len(oldp.children) - 1, -1, -1):\n                        if oldp.children[i] is nb:\n                            oldp.children.pop(i)\n                            break\n                    self._remove_edge(edges, oldp, nb)\n                nb.attach(new_node)\n                nb.cost = cand_cost\n                self._add_edge(edges, new_node, nb)\n                self._propagate_delta(nb, 0.0)  # costs already absolute; children remain consistent\n                count += 1\n\n    # Micro-bridge: simulate steps in the opposite tree, commit only if final closure is free\n    def _micro_bridge(self, tree, grid, near_node, target_pos):\n        cur = near_node.position\n        chain = []\n        success = False\n        last = None\n        for _ in range(self.connect_hops):\n            nxt = self._steer(cur, target_pos, self.step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                break\n            if self._has_close(grid, nxt, self.dupe_radius * 0.7):\n                break\n            if not self._edge_free(cur, nxt):\n                break\n            chain.append(nxt)\n            cur = nxt\n            if self._edge_free(cur, target_pos):\n                success = True\n                last = cur\n                break\n        if not success or last is None:\n            return None\n        # Commit chain with both checks on each insertion\n        prev = near_node\n        for p in chain:\n            if self._point_blocked(p):\n                return None\n            if not self._edge_free(prev.position, p):\n                return None\n            nn = Node(p, prev, prev.cost + self._dist(prev.position, p))\n            nn.attach(prev)\n            tree.append(nn)\n            self._grid_add(grid, nn)\n            prev = nn\n        return prev\n\n    # Edge list maintenance (O(1) remove by swap)\n    def _add_edge(self, edges, p, c):\n        edges.append((p, c))\n        self._edge_idx[(id(p), id(c))] = len(edges) - 1\n\n    def _remove_edge(self, edges, p, c):\n        key = (id(p), id(c))\n        idx = self._edge_idx.get(key)\n        if idx is None:\n            return\n        last_idx = len(edges) - 1\n        if idx != last_idx:\n            lp, lc = edges[last_idx]\n            edges[idx] = (lp, lc)\n            self._edge_idx[(id(lp), id(lc))] = idx\n        edges.pop()\n        del self._edge_idx[key]\n\n    # Sampling\n    def _sample_target(self, attract):\n        tries = 28\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attract\n            elif r < self.goal_bias + self.corridor_bias:\n                p = self._corridor_point()\n            else:\n                if self.is3:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        return None\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.08 * sg)\n        if self.is3:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w),\n                                base[2] + self._rand_range(-w, w)))\n        else:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w)))\n\n    # Path assembly and post-processing\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble_path(self, a_end, b_end, a_side_grew):\n        if a_side_grew:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pa[0] == pb[-1]:\n                pb = pb[:-1]\n            return pa + pb[::-1]\n        else:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pb[0] == pa[-1]:\n                pa = pa[:-1]\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _vis_collapse(self, pts, passes=2):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            i = 0\n            changed = False\n            while i < len(cur) - 2:\n                j = len(cur) - 1\n                while j > i + 1:\n                    if self._edge_free(cur[i], cur[j]):\n                        if j > i + 1:\n                            del cur[i + 1:j]\n                            changed = True\n                        break\n                    j -= 1\n                i += 1\n            if not changed:\n                break\n        return cur\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        stall = 0\n        while tries < attempts and len(cur) > 2:\n            n = len(cur)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n - 1:\n                tries += 1\n                continue\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-12 <= bestL:\n                    cur = cand\n                    bestL = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            tries += 1\n            if stall > 28:\n                break\n        return cur\n\n    def _round_corners(self, pts, passes):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                # weighted midpoint for gentler arcs\n                mid = tuple(0.5 * a[k] + 0.5 * c[k] for k in range(self.dim))\n                if (not self._in_bounds(mid)) or self._point_blocked(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if cur[i] != mid:\n                        cur[i] = mid\n                        moved = True\n            if not moved:\n                break\n        return cur\n\n    def _postprocess(self, path):\n        if len(path) < 3:\n            return path[:]\n        p = self._vis_collapse(path, passes=2)\n        p = self._shortcut(p, self.smoothing_shortcuts)\n        p = self._round_corners(p, self.smoothing_rounds)\n        return p",
                "objective": -17.98581,
                "time_improvement": -7.0,
                "length_improvement": 18.0,
                "smoothness_improvement": 1855.0,
                "node_improvement": 80.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.010794711112976075,
                        "num_nodes_avg": 57.0,
                        "path_length_avg": 161.75424797251898,
                        "smoothness_avg": 0.044564526464737714,
                        "success_improvement": 0.0,
                        "time_improvement": 56.24586268311703,
                        "node_improvement": 85.64593301435407,
                        "length_improvement": 11.339933526179076,
                        "smoothness_improvement": 597.5316125912756,
                        "objective_score": 26.665376983598932
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03298354148864746,
                        "num_nodes_avg": 125.0,
                        "path_length_avg": 236.8705941519225,
                        "smoothness_avg": 0.11887162179563142,
                        "success_improvement": 0.0,
                        "time_improvement": 80.2790860779126,
                        "node_improvement": 91.6011556809783,
                        "length_improvement": 20.92577773006667,
                        "smoothness_improvement": 2958.652448569999,
                        "objective_score": 51.432454704263776
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.13026626110076905,
                        "num_nodes_avg": 300.0,
                        "path_length_avg": 117.33791794535846,
                        "smoothness_avg": 0.1657140101627679,
                        "success_improvement": 0.0,
                        "time_improvement": -158.0719713841316,
                        "node_improvement": 61.85632549268912,
                        "length_improvement": 22.069741931916344,
                        "smoothness_improvement": 2007.8699775345367,
                        "objective_score": -24.140396368416987
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "cross_over",
            "algorithm_description": "RAPIDS-IRRT*: Rapid Adaptive Prolate Informed Dual-tree RRT* with Indexed Obstacles and Segment Cache. It combines two balanced RRT* trees, a coarse hash-grid for O(1)-ish neighbors, a large, quantized edge-collision cache over obstacle bins, dynamic radius best-parent selection and bounded rewiring. After the first solution, it switches to ellipsoidal informed sampling to shrink path length quickly. Fast LOS bridging, duplicate suppression, and early visibility postprocessing reduce expansions and time.",
            "planning_mechanism": "Alternating tree growth with goal/corridor/informed-biased sampling. For each sample, find a nearby anchor from the hash-grid, steer, pick the least-cost parent among local neighbors (dynamic radius), verify point and edge, insert and lightly rewire neighbors. Probe the opposite tree with direct LOS or a short micro-bridge; on success assemble, visibility-collapse, shortcut, and round, then return. Collision checks use binned AABBs and a coarse LRU segment cache; nearest/neighbor queries use a coarse spatial grid with ring expansion and frontier fallback for speed.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = None\n        self.cost = float(cost)\n        self.children = []\n        if parent is not None:\n            self.attach(parent)\n\n    def attach(self, parent):\n        # Ensure proper detachment and consistent child registration\n        if self.parent is parent:\n            if parent is not None:\n                found = False\n                for ch in parent.children:\n                    if ch is self:\n                        found = True\n                        break\n                if not found:\n                    parent.children.append(self)\n            return\n        if self.parent is not None:\n            old = self.parent\n            for i in range(len(old.children) - 1, -1, -1):\n                if old.children[i] is self:\n                    old.children.pop(i)\n                    break\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4500,\n                 step_size=6.0,\n                 goal_bias=0.35,\n                 corridor_bias=0.30,\n                 informed_bias=0.55,\n                 grid_cell_factor=2.0,\n                 base_neighbor_radius=18.0,\n                 dupe_radius_ratio=0.30,\n                 k_parent_cap=24,\n                 k_rewire=10,\n                 connect_hops=3,\n                 smoothing_shortcuts=120,\n                 smoothing_rounds=4):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.cell_factor = float(grid_cell_factor)\n        self.base_nei = float(base_neighbor_radius)\n        self.dupe_ratio = float(dupe_radius_ratio)\n        self.k_parent_cap = int(max(6, k_parent_cap))\n        self.k_rewire = int(max(0, k_rewire))\n        self.connect_hops = int(max(1, connect_hops))\n        self.smoothing_shortcuts = int(max(0, smoothing_shortcuts))\n        self.smoothing_rounds = int(max(0, smoothing_rounds))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", [])) if getattr(map, \"obstacles\", None) is not None else []\n        nodes = []\n        edges = []\n        self._edge_idx = {}  # (id(p), id(c)) -> index\n        self._seed_rng()\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Build obstacle bins and segment cache\n        self._build_obs_bins()\n        self._seg_cache = {}\n        self._seg_tick = 0\n        self._seg_cap = 16384  # larger cache for reuse\n\n        # Endpoint validity\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight-line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            nodes.extend([n0, n1])\n            self._add_edge(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._postprocess(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Spatial params\n        self.cell = max(1.0, self.step * self.cell_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n\n        # Trees\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        A, B = [a_root], [b_root]\n        GA, GB = {}, {}\n        self._grid_add(GA, a_root)\n        self._grid_add(GB, b_root)\n        nodes.extend([a_root, b_root])\n        frontierA, frontierB = [a_root], [b_root]\n\n        # Informed sampling state\n        cmin = self._dist(self.start, self.goal)\n        best_path = None\n        best_len = 1e100\n\n        for it in range(self.max_iter):\n            # Alternate growth with slight bias toward smaller tree\n            if it % 3 == 2:\n                growA = (len(A) <= len(B))\n            else:\n                growA = (it % 2 == 0)\n            T = A if growA else B\n            O = B if growA else A\n            G = GA if growA else GB\n            GO = GB if growA else GA\n            frontier = frontierA if growA else frontierB\n            frontierO = frontierB if growA else frontierA\n            attract = self.goal if growA else self.start\n\n            # Dynamic neighbor radius (decreases with total nodes)\n            n_tot = max(2, len(A) + len(B))\n            r_nei = max(1.5 * self.step, self.base_nei / ((n_tot) ** (1.0 / (self.dim + 1.0))))\n\n            # Sampling\n            target = self._sample_target(attract, best_len, cmin)\n            if target is None:\n                continue\n\n            # Nearest anchor\n            qnear = self._nearest(G, frontier, target, max_rings=2)\n            if qnear is None:\n                qnear = T[-1]\n            qnew_pos = self._steer(qnear.position, target, self.step)\n            if (not self._in_bounds(qnew_pos)) or self._point_blocked(qnew_pos):\n                continue\n            if self._has_close(G, qnew_pos, self.dupe_radius):\n                continue\n\n            # Choose best parent among neighbors\n            parent, bestc = self._choose_parent(G, qnew_pos, qnear, r_nei)\n            if parent is None:\n                continue\n\n            # Mandatory checks before insertion\n            if self._point_blocked(qnew_pos):\n                continue\n            if not self._edge_free(parent.position, qnew_pos):\n                continue\n\n            # Insert node\n            qnode = Node(qnew_pos, parent, bestc)\n            T.append(qnode)\n            nodes.append(qnode)\n            self._grid_add(G, qnode)\n            self._add_edge(edges, parent, qnode)\n\n            frontier.append(qnode)\n            if len(frontier) > 160:\n                del frontier[:16]\n\n            # Local rewiring\n            if self.k_rewire > 0:\n                self._rewire_local(qnode, G, edges, r_nei, k=self.k_rewire)\n\n            # Try to connect to opposite tree\n            other_near = self._nearest(GO, frontierO, qnode.position, max_rings=2)\n            connected = False\n            meet = None\n            if other_near is not None:\n                if self._edge_free(qnode.position, other_near.position):\n                    connected = True\n                    meet = other_near\n                else:\n                    # Short micro-bridge on O toward qnode\n                    mb = self._micro_bridge(O, GO, other_near, qnode.position)\n                    if mb is not None and self._edge_free(qnode.position, mb.position):\n                        connected = True\n                        meet = mb\n\n            if connected and meet is not None:\n                path = self._assemble_path(qnode, meet, growA)\n                path = self._postprocess(path)\n                L = self._path_len(path)\n                if L < best_len:\n                    best_len = L\n                    best_path = path\n                # Return immediately to reduce planning time\n                return PlannerResult(True, best_path, nodes, edges)\n\n        # If loop ends without connection, return best if any\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        for v in self.start + self.goal:\n            s ^= (int(v * 2654435761) & 0xffffffff)\n            s = (s * 1664525 + 1013904223) & 0xffffffff\n        s ^= len(self.obstacles) * 374761393\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        x = self._rng & 0xffffffff\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Obstacles and collisions\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.8)\n        self._obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self._obin.get(key)\n                            if lst is None:\n                                self._obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self._obin.get(key)\n                        if lst is None:\n                            self._obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_bucket(self, p):\n        if self.is3:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell),\n                                   int(p[2] // self.obs_cell)))\n        else:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell)))\n\n    def _point_blocked(self, p):\n        bucket = self._point_bucket(p)\n        if not bucket:\n            return False\n        if self.is3:\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _seg_box_intersect(self, a, b, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(self.dim):\n            p = a[i]\n            d = b[i] - a[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _edge_cache_key(self, a, b):\n        s = self.obs_cell if self.obs_cell > 0 else 1.0\n        qa = []\n        qb = []\n        for i in range(self.dim):\n            qa.append(int(a[i] / s * 4.0))\n            qb.append(int(b[i] / s * 4.0))\n        ka = tuple(qa)\n        kb = tuple(qb)\n        if ka <= kb:\n            return (ka, kb)\n        else:\n            return (kb, ka)\n\n    def _cache_seg(self, key, val):\n        self._seg_cache[key] = val\n        self._seg_tick += 1\n        if self._seg_tick >= self._seg_cap:\n            self._seg_cache.clear()\n            self._seg_tick = 0\n\n    def _edge_free(self, a, b):\n        key = self._edge_cache_key(a, b)\n        hit = self._seg_cache.get(key)\n        if hit is not None:\n            return hit\n        if self.is3:\n            mn = (min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            iz0 = int(max(0.0, mn[2]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self._obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if cand:\n                for idx in cand:\n                    ox, oy, oz, w, h, d = self.obstacles[idx]\n                    if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                        self._cache_seg(key, False)\n                        return False\n            self._cache_seg(key, True)\n            return True\n        else:\n            mn = (min(a[0], b[0]), min(a[1], b[1]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self._obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if cand:\n                for idx in cand:\n                    ox, oy, w, h = self.obstacles[idx]\n                    if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                        self._cache_seg(key, False)\n                        return False\n            self._cache_seg(key, True)\n            return True\n\n    # Grid utilities\n    def _cell_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, frontier, pos, max_rings=2):\n        kk = self._cell_key(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring(grid, kk, r)\n            if cand:\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bd:\n                        bd = d2\n                        best = n\n                if best is not None:\n                    return best\n        # fallback to recent frontier\n        if frontier:\n            lim = min(32, len(frontier))\n            for i in range(lim):\n                n = frontier[-1 - i]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bd:\n                    bd = d2\n                    best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap=None):\n        kk = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        limit = self.k_parent_cap if cap is None else int(cap)\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((kk[0] + dx, kk[1] + dy, kk[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if len(out) >= limit:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((kk[0] + dx, kk[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if len(out) >= limit:\n                                return out\n        return out\n\n    def _has_close(self, grid, pos, radius):\n        ns = self._neighbors(grid, pos, radius, cap=8)\n        return len(ns) > 0\n\n    # Parent selection (pure geometric cost)\n    def _choose_parent(self, grid, new_pos, fallback, radius):\n        cand = self._neighbors(grid, new_pos, radius, cap=self.k_parent_cap)\n        if fallback not in cand:\n            cand.append(fallback)\n        cand.sort(key=lambda n: self._dist2(n.position, new_pos))\n        best = None\n        best_cost = 1e100\n        for p in cand:\n            # Both checks for the candidate edge\n            if not self._edge_free(p.position, new_pos):\n                continue\n            d = self._dist(p.position, new_pos)\n            c = p.cost + d\n            if c < best_cost:\n                best_cost = c\n                best = p\n        return best, best_cost\n\n    # Rewiring with subtree cost updates\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_delta(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire_local(self, new_node, grid, edges, radius, k=10):\n        neigh = self._neighbors(grid, new_node.position, radius, cap=48)\n        if not neigh:\n            return\n        neigh.sort(key=lambda n: self._dist2(n.position, new_node.position))\n        count = 0\n        for nb in neigh:\n            if count >= k:\n                break\n            if nb is new_node or nb is new_node.parent:\n                continue\n            if self._is_ancestor(nb, new_node):\n                continue\n            if self._point_blocked(nb.position):\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand_cost + 1e-9 < nb.cost:\n                oldp = nb.parent\n                old_cost = nb.cost\n                if oldp is not None:\n                    # detach from old parent\n                    for i in range(len(oldp.children) - 1, -1, -1):\n                        if oldp.children[i] is nb:\n                            oldp.children.pop(i)\n                            break\n                    self._remove_edge(edges, oldp, nb)\n                nb.attach(new_node)\n                nb.cost = cand_cost\n                self._add_edge(edges, new_node, nb)\n                self._propagate_delta(nb, cand_cost - old_cost)\n                count += 1\n\n    # Micro-bridge: create short chain in opposite tree, commit only if closure works\n    def _micro_bridge(self, tree, grid, near_node, target_pos):\n        cur = near_node.position\n        chain = []\n        last_ok = None\n        for _ in range(self.connect_hops):\n            nxt = self._steer(cur, target_pos, self.step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return None\n            if self._has_close(grid, nxt, self.dupe_radius * 0.7):\n                return None\n            if not self._edge_free(cur, nxt):\n                return None\n            chain.append(nxt)\n            cur = nxt\n            last_ok = cur\n            if self._edge_free(cur, target_pos):\n                break\n        if last_ok is None:\n            return None\n        # Commit with checks\n        prev = near_node\n        for p in chain:\n            if self._point_blocked(p):\n                return None\n            if not self._edge_free(prev.position, p):\n                return None\n            nn = Node(p, prev, prev.cost + self._dist(prev.position, p))\n            tree.append(nn)\n            self._grid_add(grid, nn)\n            prev = nn\n        return prev\n\n    # Edge list maintenance\n    def _add_edge(self, edges, p, c):\n        edges.append((p, c))\n        self._edge_idx[(id(p), id(c))] = len(edges) - 1\n\n    def _remove_edge(self, edges, p, c):\n        key = (id(p), id(c))\n        idx = self._edge_idx.get(key)\n        if idx is None:\n            return\n        last_idx = len(edges) - 1\n        if idx != last_idx:\n            lp, lc = edges[last_idx]\n            edges[idx] = (lp, lc)\n            self._edge_idx[(id(lp), id(lc))] = idx\n        edges.pop()\n        del self._edge_idx[key]\n\n    # Sampling\n    def _sample_target(self, attract, c_best, c_min):\n        tries = 28\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            if c_best < 1e99 and r < self.informed_bias:\n                p = self._sample_in_ellipse(c_best, c_min)\n            elif r < self.goal_bias + (0.0 if c_best < 1e99 else 0.0):\n                p = attract\n            elif r < self.goal_bias + self.corridor_bias:\n                p = self._corridor_point()\n            else:\n                p = self._uniform_point()\n            if p is not None and self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        return None\n\n    def _uniform_point(self):\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step, 0.10 * sg)\n        if self.is3:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w),\n                                base[2] + self._rand_range(-w, w)))\n        else:\n            return self._clamp((base[0] + self._rand_range(-w, w),\n                                base[1] + self._rand_range(-w, w)))\n\n    def _sample_in_ellipse(self, c_best, c_min):\n        # Prolate hyperspheroid with foci at start and goal\n        if c_best < c_min + 1e-9:\n            return None\n        a = 0.5 * c_best  # major radius\n        if a <= 1e-9:\n            return None\n        if self.is3:\n            b_sq = a * a - (c_min * c_min) * 0.25\n            if b_sq <= 1e-9:\n                return None\n            b = b_sq ** 0.5\n            # Unit vector along start->goal\n            u = (self.goal[0] - self.start[0], self.goal[1] - self.start[1], self.goal[2] - self.start[2])\n            un = self._norm(u)\n            if un <= 1e-12:\n                return None\n            e1 = (u[0] / un, u[1] / un, u[2] / un)\n            # Build orthonormal basis\n            ref = (1.0, 0.0, 0.0) if abs(e1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            e2 = self._cross(e1, ref)\n            e2n = self._norm(e2)\n            if e2n <= 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                e2 = self._cross(e1, ref)\n                e2n = self._norm(e2)\n                if e2n <= 1e-12:\n                    return None\n            e2 = (e2[0] / e2n, e2[1] / e2n, e2[2] / e2n)\n            e3 = self._cross(e1, e2)\n            # Sample inside unit ball\n            for _ in range(10):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                z = self._rand_range(-1.0, 1.0)\n                if x * x + y * y + z * z <= 1.0:\n                    # scale\n                    rx = (self._rand() ** (1.0 / 3.0))\n                    x *= rx\n                    y *= rx\n                    z *= rx\n                    # transform to ellipse\n                    cx = a * x\n                    cy = b * y\n                    cz = b * z\n                    # rotate and translate to center\n                    center = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dim))\n                    vx = (e1[0] * cx + e2[0] * cy + e3[0] * cz)\n                    vy = (e1[1] * cx + e2[1] * cy + e3[1] * cz)\n                    vz = (e1[2] * cx + e2[2] * cy + e3[2] * cz)\n                    p = (center[0] + vx, center[1] + vy, center[2] + vz)\n                    if self._in_bounds(p):\n                        return p\n            return None\n        else:\n            b_sq = a * a - (c_min * c_min) * 0.25\n            if b_sq <= 1e-9:\n                return None\n            b = b_sq ** 0.5\n            dx = self.goal[0] - self.start[0]\n            dy = self.goal[1] - self.start[1]\n            un = (dx * dx + dy * dy) ** 0.5\n            if un <= 1e-12:\n                return None\n            cos_t = dx / un\n            sin_t = dy / un\n            center = ((self.start[0] + self.goal[0]) * 0.5,\n                      (self.start[1] + self.goal[1]) * 0.5)\n            # Sample inside unit disk\n            for _ in range(12):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                if x * x + y * y <= 1.0:\n                    r = (self._rand() ** 0.5)\n                    x *= r\n                    y *= r\n                    # scale\n                    ex = a * x\n                    ey = b * y\n                    # rotate\n                    rx = cos_t * ex - sin_t * ey\n                    ry = sin_t * ex + cos_t * ey\n                    p = (center[0] + rx, center[1] + ry)\n                    if self._in_bounds(p):\n                        return p\n            return None\n\n    def _norm(self, v):\n        s = 0.0\n        for i in range(len(v)):\n            s += v[i] * v[i]\n        return s ** 0.5\n\n    def _cross(self, a, b):\n        return (a[1] * b[2] - a[2] * b[1],\n                a[2] * b[0] - a[0] * b[2],\n                a[0] * b[1] - a[1] * b[0])\n\n    # Path utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _assemble_path(self, a_end, b_end, a_side_grew):\n        if a_side_grew:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pa[0] == pb[-1]:\n                pb = pb[:-1]\n            return pa + pb[::-1]\n        else:\n            pa = self._path_to_root(a_end)\n            pb = self._path_to_root(b_end)\n            if pa and pb and pb[0] == pa[-1]:\n                pa = pa[:-1]\n            return pb + pa[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _vis_collapse(self, pts, passes=2):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            i = 0\n            changed = False\n            while i < len(cur) - 2:\n                j = len(cur) - 1\n                while j > i + 1:\n                    if self._edge_free(cur[i], cur[j]):\n                        if j > i + 1:\n                            del cur[i + 1:j]\n                            changed = True\n                        break\n                    j -= 1\n                i += 1\n            if not changed:\n                break\n        return cur\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        stall = 0\n        while tries < attempts and len(cur) > 2:\n            n = len(cur)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j <= i + 1 or j > n - 1:\n                tries += 1\n                continue\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-12 <= bestL:\n                    cur = cand\n                    bestL = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            tries += 1\n            if stall > 28:\n                break\n        return cur\n\n    def _round_corners(self, pts, passes):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                mid = tuple(0.5 * a[k] + 0.5 * c[k] for k in range(self.dim))\n                if (not self._in_bounds(mid)) or self._point_blocked(mid):\n                    continue\n                if self._edge_free(a, mid) and self._edge_free(mid, c):\n                    if cur[i] != mid:\n                        cur[i] = mid\n                        moved = True\n            if not moved:\n                break\n        return cur\n\n    def _postprocess(self, path):\n        if len(path) < 3:\n            return path[:]\n        p = self._vis_collapse(path, passes=2)\n        p = self._shortcut(p, self.smoothing_shortcuts)\n        p = self._round_corners(p, self.smoothing_rounds)\n        return p",
            "objective": -38.81705,
            "time_improvement": 73.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 1331.0,
            "node_improvement": 89.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007626032829284668,
                    "num_nodes_avg": 42.0,
                    "path_length_avg": 150.30466036531917,
                    "smoothness_avg": 0.042772972605090796,
                    "success_improvement": 0.0,
                    "time_improvement": 69.08944722064112,
                    "node_improvement": 89.42331906320827,
                    "length_improvement": 17.615633924011192,
                    "smoothness_improvement": 569.4899042663268,
                    "objective_score": 34.143664041930684
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04364337921142578,
                    "num_nodes_avg": 179.0,
                    "path_length_avg": 226.32721347498054,
                    "smoothness_avg": 0.08650527069846632,
                    "success_improvement": 0.0,
                    "time_improvement": 73.90555150077547,
                    "node_improvement": 87.97285493516092,
                    "length_improvement": 24.445461674416084,
                    "smoothness_improvement": 2125.842922299545,
                    "objective_score": 47.468157066380016
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01258089542388916,
                    "num_nodes_avg": 77.0,
                    "path_length_avg": 135.9262852877516,
                    "smoothness_avg": 0.10978088951272895,
                    "success_improvement": 0.0,
                    "time_improvement": 75.07584499328578,
                    "node_improvement": 90.20979020979021,
                    "length_improvement": 9.724233426033248,
                    "smoothness_improvement": 1296.4048114195507,
                    "objective_score": 34.83931761070344
                }
            ],
            "success_rate": 1.0
        },
        "objective": 11.799999999999997,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient nearest/neighbor retrieval from fixed, relatively large search radii and fine grids, scanning many candidates per expansion\n   - Heavy collision-check load due to limited segment-cache reuse, fine cache quantization, and frequent re-tests of similar segments\n   - Inconsistent tree bookkeeping during attach/rewire leading to stale subtree costs, misguiding parent selection and requiring extra expansions\n   - Mixed geometric/turn penalties in parent selection producing non-comparable costs, weakening rewiring and prolonging convergence\n   - Broad, weakly guided sampling that spends iterations in low-value regions away from the start\u2013goal corridor\n   - Micro-bridge attempts that build partial chains which later fail, adding overhead without progress"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Reliable child registration and subtree cost propagation, with pure geometric costs for parent choice and rewiring\n   - Dynamic neighbor radius and coarser spatial hashing to bound candidate counts for nearest/parent/rewire queries\n   - Larger, more reusable segment-collision cache with obstacle binning and coarser key quantization\n   - More targeted sampling biased toward the start\u2013goal corridor (and informed region when available)\n   - Early acceptance of the first valid bridge and stricter micro-bridge pruning to abandon unpromising chains\n2. Expected mechanism of impact:\n   - Correct costs prevent futile growth and reduce re-expansions, accelerating the first feasible connection\n   - Bounded neighbor sets lower per-iteration computation in dense trees\n   - Higher collision-cache hit rates cut edge-validation time, the dominant runtime cost in cluttered maps\n   - Sampling focused on promising regions increases the yield of useful expansions\n   - Pruned micro-bridging avoids wasted collision checks on failing connectors"
        }
    },
    {
        "parents": [
            {
                "operator": "path_expert",
                "algorithm_description": "FOCUS-IBRRT*: Focused Optimal k-nearest Informed BiRRT* with volume-calibrated neighbor radius, exact prolate hyperspheroid sampling aligned to the start\u2013goal axis, direct line-of-sight strides, k-nearest least-cost parent selection, bounded benefit-ordered rewiring, and aggressive visibility-based shortcutting. It reduces path length by concentrating samples inside the informed lens once an incumbent exists, optimizing parent choice over a theoretically grounded neighbor set, and post-connection path compression.",
                "planning_mechanism": "Alternate growing the two trees. Each iteration: sample a target (goal/corridor/informed/uniform), find the nearest in a hashed grid, take a direct line-of-sight stride if possible else a bounded step, then choose the least-cost parent among a k-nearest (or radius) set derived from free-space volume and log(n)/n. Insert only after node and edge collision checks, then rewire nearby nodes if a shorter collision-free connection exists. Try to connect to the opposite tree. Maintain the best path length to focus informed sampling. On success, assemble and apply visibility pruning and multi-pass shortcuts to minimize length before returning.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = parent\n        if parent is not None:\n            if self not in parent.children:\n                parent.children.append(self)\n\n    def path_from_root(self):\n        out = []\n        cur = self\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        out.reverse()\n        return out\nclass Planner:\n    def __init__(\n        self,\n        max_iter=7000,\n        step_size=6.0,\n        goal_bias=0.18,\n        corridor_bias=0.25,\n        informed_bias=0.55,\n        connect_factor=2.25,\n        k_factor=10.0,\n        k_cap=120,\n        rewire_cap=16,\n        dupe_radius_factor=0.25,\n        grid_cell_factor=1.1,\n        shortcut_passes=3,\n        shortcut_attempts=220\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.connect_factor = float(connect_factor)\n        self.k_factor = float(k_factor)\n        self.k_cap = int(k_cap)\n        self.rewire_cap = int(rewire_cap)\n        self.dupe_rf = float(dupe_radius_factor)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.shortcut_passes = int(shortcut_passes)\n        self.shortcut_attempts = int(shortcut_attempts)\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n        self._seed_rng()\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._build_obs_index()\n\n        if self._inside_obstacle(self.start) or self._inside_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight line\n        if self._los(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Derived constants\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_r = max(0.25, self.step * self.dupe_rf)\n        self.connect_dist = max(self.step, self.connect_factor * self.step)\n        self.axis = self._unit(self._sub(self.goal, self.start))\n        self.corridor_w = max(self.step, 0.15 * self._dist(self.start, self.goal))\n\n        # Trees and spatial hash\n        Aroot = Node(self.start, None, 0.0)\n        Broot = Node(self.goal, None, 0.0)\n        nodes = [Aroot, Broot]\n        edges = []\n        Ta, Tb = [Aroot], [Broot]\n        Ga, Gb = {}, {}\n        self._grid_put(Ga, Aroot)\n        self._grid_put(Gb, Broot)\n\n        # Free-space volume for RRT* radius\n        self.mu_free = self._free_volume()\n        self.zeta = 3.141592653589793 if self.dims == 2 else (4.0 * 3.141592653589793 / 3.0)\n        self.gamma_rrt = 2.6 * ((1.0 + 1.0 / self.dims) ** (1.0 / self.dims)) * (max(self.mu_free, 1e-9) / self.zeta) ** (1.0 / self.dims)\n\n        best_len = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            grow_a = (len(Ta) <= len(Tb))  # grow smaller tree to balance\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n\n            target = self._sample_target(attractor, best_len)\n            if target is None:\n                continue\n\n            near = self._nearest(G, T, target)\n            if near is None:\n                continue\n\n            new_pos = self._stride(near.position, target)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._inside_obstacle(new_pos):\n                continue\n            if self._too_close(G, new_pos, self.dupe_r):\n                continue\n\n            parent, new_cost = self._select_parent(G, T, new_pos)\n            if parent is None:\n                continue\n            # Both checks before add\n            if self._inside_obstacle(new_pos):\n                continue\n            if not self._los(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, None, new_cost)\n            new_node.attach(parent)\n            T.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_put(G, new_node)\n\n            # Local bounded rewiring (benefit-ordered)\n            self._rewire(G, new_node, edges)\n\n            # Try to connect to the opposite tree\n            other = self._nearest(Gopp, Topp, new_node.position)\n            connected = False\n            end_node = None\n            if other is not None:\n                dno = self._dist(new_node.position, other.position)\n                if dno <= self.connect_dist and self._los(new_node.position, other.position):\n                    connected = True\n                    end_node = other\n                else:\n                    # Single micro-bridge step from opposite tree toward the new node\n                    step_p = self._toward(other.position, new_node.position, self.step)\n                    if self._in_bounds(step_p) and (not self._inside_obstacle(step_p)) and (not self._too_close(Gopp, step_p, self.dupe_r)) and self._los(other.position, step_p):\n                        q = Node(step_p, None, other.cost + self._dist(other.position, step_p))\n                        q.attach(other)\n                        Topp.append(q)\n                        nodes.append(q)\n                        edges.append((other, q))\n                        self._grid_put(Gopp, q)\n                        # Short connection check\n                        if self._los(new_node.position, q.position):\n                            connected = True\n                            end_node = q\n\n            if connected and end_node is not None:\n                path = self._assemble(new_node, end_node, grow_a)\n                path = self._compress(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Maintain incumbent best for informed sampling\n            if other is not None and self._los(new_node.position, other.position):\n                tmp = self._assemble(new_node, other, grow_a)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._compress(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0\n        for v in (self.start + self.goal):\n            s = (s * 1664525 + int(997 * v + 0.5) + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        self._rng = s if s != 0 else 123456789\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _add(self, a, b):\n        return tuple(a[i] + b[i] for i in range(self.dims))\n\n    def _sub(self, a, b):\n        return tuple(a[i] - b[i] for i in range(self.dims))\n\n    def _scale(self, a, s):\n        return tuple(a[i] * s for i in range(self.dims))\n\n    def _dot(self, a, b):\n        return sum(a[i] * b[i] for i in range(self.dims))\n\n    def _norm(self, a):\n        return self._dist(a, tuple(0.0 for _ in range(self.dims)))\n\n    def _unit(self, a):\n        n = self._norm(a)\n        if n <= 1e-12:\n            return tuple(0.0 for _ in range(self.dims))\n        inv = 1.0 / n\n        return tuple(a[i] * inv for i in range(self.dims))\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    # Log approximation (for n>=1)\n    def _ln(self, x):\n        if x <= 0.0:\n            return -1e9\n        k = 0\n        while x > 2.0:\n            x *= 0.5\n            k += 1\n        # x in (0,2]\n        y = x - 1.0\n        term = y\n        s = term\n        i = 2.0\n        while abs(term) > 1e-6:\n            term *= -y * (i - 1.0) / i\n            s += term\n            i += 1.0\n            if i > 32.0:\n                break\n        # ln(x) = s + k*ln(2)\n        return s + k * 0.6931471805599453\n\n    # Obstacle index\n    def _build_obs_index(self):\n        self.obs_cell = max(3.0, self.step * 1.3)\n        self.og = {}\n        if self.dims == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.og.get(key)\n                            if b is None:\n                                self.og[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.og.get(key)\n                        if b is None:\n                            self.og[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _inside_obstacle(self, p):\n        if self.dims == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.og.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.og.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    # Segment vs obstacle intersection\n    def _los(self, a, b):\n        return not self._hit_seg(a, b)\n\n    def _hit_seg(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            seen = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        ids = self.og.get((i, j, k))\n                        if ids:\n                            for idx in ids:\n                                if idx in seen:\n                                    continue\n                                seen.add(idx)\n                                ox, oy, oz, w, h, d = self.obstacles[idx]\n                                if self._seg_box(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            seen = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    ids = self.og.get((i, j))\n                    if ids:\n                        for idx in ids:\n                            if idx in seen:\n                                continue\n                            seen.add(idx)\n                            ox, oy, w, h = self.obstacles[idx]\n                            if self._seg_box(a, b, (ox, oy), (ox + w, oy + h)):\n                                return True\n            return False\n\n    def _seg_box(self, p0, p1, bmin, bmax):\n        # Liang-Barsky slab\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Spatial hashing for nodes\n    def _key_of(self, pos):\n        return tuple(int(pos[i] // self.cell) for i in range(self.dims))\n\n    def _grid_put(self, grid, node):\n        k = self._key_of(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_fetch(self, grid, key, radius):\n        out = []\n        if self.dims == 3:\n            for dx in range(-radius, radius + 1):\n                for dy in range(-radius, radius + 1):\n                    for dz in range(-radius, radius + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-radius, radius + 1):\n                for dy in range(-radius, radius + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._key_of(pos)\n        best, bestd = None, 1e100\n        found = False\n        for r in range(0, 6):\n            cand = self._ring_fetch(grid, key, r)\n            if cand:\n                found = True\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                break\n        if not found:\n            # Random subsample fallback\n            if not tree:\n                return None\n            step = max(1, len(tree) // 32)\n            for i in range(0, len(tree), step):\n                n = tree[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_radius(self, grid, pos, radius, cap):\n        key = self._key_of(pos)\n        r = max(1, int(radius // self.cell) + 1)\n        cand = self._ring_fetch(grid, key, r)\n        out = []\n        rr = radius * radius\n        for n in cand:\n            d2 = 0.0\n            np = n.position\n            for i in range(self.dims):\n                dd = np[i] - pos[i]\n                d2 += dd * dd\n            if d2 <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _neighbors_k(self, grid, tree, pos, k):\n        # Gather from local rings and expand until we have >=k\n        key = self._key_of(pos)\n        picked = []\n        for r in range(0, 6):\n            cand = self._ring_fetch(grid, key, r)\n            if cand:\n                picked.extend(cand)\n            if len(picked) >= k:\n                break\n        if len(picked) < k:\n            # augment with sparse subsample\n            step = max(1, max(len(tree) // (k + 1), 1))\n            for i in range(0, len(tree), step):\n                picked.append(tree[i])\n                if len(picked) >= k:\n                    break\n        # sort by distance\n        picked = list({id(n): n for n in picked}.values())\n        picked.sort(key=lambda n: self._dist(n.position, pos))\n        return picked[:k]\n\n    def _too_close(self, grid, pos, r):\n        neigh = self._neighbors_radius(grid, pos, r, 1)\n        return len(neigh) > 0\n\n    # Parent selection\n    def _select_parent(self, grid, tree, pos):\n        n = max(1, len(tree))\n        ln = self._ln(float(n + 1))\n        # RRT* radius\n        r_rrt = (self.gamma_rrt * (ln / float(n))) ** (1.0 / self.dims) if n > 1 else self.step * 2.0\n        r_rrt = min(max(self.step, r_rrt), self.step * 6.0)\n        k = int(min(self.k_cap, max(2, int(self.k_factor * max(1.0, ln)))))\n        cand = self._neighbors_radius(grid, pos, r_rrt, self.k_cap)\n        if len(cand) < 2:\n            cand = self._neighbors_k(grid, tree, pos, k)\n        best_p = None\n        best_c = 1e100\n        for p in cand:\n            newc = p.cost + self._dist(p.position, pos)\n            if newc + 1e-9 < best_c and self._los(p.position, pos):\n                best_p = p\n                best_c = newc\n        return (best_p, best_c) if best_p is not None else (None, None)\n\n    # Rewiring\n    def _rewire(self, grid, node, edges):\n        # Use the same RRT* radius, prioritize by potential improvement\n        nset = self._neighbors_radius(grid, node.position, max(self.step * 4.0, self.step * 1.5), self.k_cap)\n        cand = []\n        for nb in nset:\n            if nb is node or nb is node.parent:\n                continue\n            # avoid cycles\n            if self._is_ancestor(nb, node):\n                continue\n            alt = node.cost + self._dist(node.position, nb.position)\n            gain = nb.cost - alt\n            if gain > 1e-9:\n                cand.append((gain, nb))\n        cand.sort(key=lambda x: -x[0])\n        changed = 0\n        for gain, nb in cand:\n            if changed >= self.rewire_cap:\n                break\n            if not self._los(node.position, nb.position):\n                continue\n            # Both checks (node already exists and valid)\n            oldp = nb.parent\n            if oldp is node:\n                continue\n            # Reparent\n            if oldp is not None:\n                try:\n                    oldp.children.remove(nb)\n                except:\n                    pass\n                self._remove_edge(edges, oldp, nb)\n            nb.attach(node)\n            edges.append((node, nb))\n            old_cost = nb.cost\n            nb.cost = node.cost + self._dist(node.position, nb.position)\n            # propagate to subtree\n            stack = [nb]\n            while stack:\n                cur = stack.pop()\n                for ch in cur.children:\n                    ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                    stack.append(ch)\n            changed += 1\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is p and e[1] is c:\n                edges.pop(i)\n                return\n\n    # Sampling\n    def _sample_target(self, attractor, best_len):\n        for _ in range(24):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._sample_informed(best_len)\n                if p is not None and not self._inside_obstacle(p):\n                    return p\n            r2 = self._rand()\n            if r2 < self.goal_bias:\n                p = attractor\n            elif r2 < self.goal_bias + self.corridor_bias:\n                p = self._sample_corridor()\n            else:\n                p = self._sample_uniform()\n            if self._in_bounds(p) and (not self._inside_obstacle(p)):\n                return p\n        return None\n\n    def _sample_uniform(self):\n        if self.dims == 3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_corridor(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        if self.dims == 2:\n            # lateral offset perpendicular to axis\n            n = (-self.axis[1], self.axis[0])\n            off = self._scale(n, self._rand_range(-self.corridor_w, self.corridor_w))\n            p = self._add(base, off)\n        else:\n            # random combination of two orthonormal perpendiculars\n            u1, u2 = self._perp_basis(self.axis)\n            off = self._add(self._scale(u1, self._rand_range(-self.corridor_w, self.corridor_w)),\n                            self._scale(u2, self._rand_range(-self.corridor_w, self.corridor_w)))\n            p = self._add(base, off)\n        return self._clamp(p)\n\n    def _sample_informed(self, c_best):\n        cmin = self._dist(self.start, self.goal)\n        if not (c_best < float('inf')) or c_best <= cmin + 1e-9:\n            return None\n        a = 0.5 * c_best\n        l = 0.5 * cmin\n        if a <= l + 1e-12:\n            return None\n        b = (a * a - l * l) ** 0.5\n        center = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dims))\n        # sample uniformly in unit ball via rejection\n        if self.dims == 2:\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                if x * x + y * y <= 1.0:\n                    # scale to ellipse aligned with axis\n                    major = a * x\n                    minor = b * y\n                    n = (-self.axis[1], self.axis[0])\n                    p = self._add(center, self._add(self._scale(self.axis, major), self._scale(n, minor)))\n                    if self._in_bounds(p):\n                        return self._clamp(p)\n        else:\n            u1, u2 = self._perp_basis(self.axis)\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                z = self._rand_range(-1.0, 1.0)\n                if x * x + y * y + z * z <= 1.0:\n                    major = a * x\n                    minor1 = b * y\n                    minor2 = b * z\n                    p = self._add(center,\n                                  self._add(self._scale(self.axis, major),\n                                            self._add(self._scale(u1, minor1), self._scale(u2, minor2))))\n                    if self._in_bounds(p):\n                        return self._clamp(p)\n        return None\n\n    def _perp_basis(self, v):\n        # returns two orthonormal vectors perpendicular to v (3D)\n        if abs(v[0]) < 0.9:\n            tmp = (1.0, 0.0, 0.0)\n        else:\n            tmp = (0.0, 1.0, 0.0)\n        u1 = self._sub(tmp, self._scale(v, self._dot(tmp, v)))\n        n1 = self._norm(u1)\n        if n1 <= 1e-12:\n            u1 = (0.0, 0.0, 1.0)\n            n1 = 1.0\n        u1 = self._scale(u1, 1.0 / n1)\n        # cross v x u1\n        u2 = (v[1] * u1[2] - v[2] * u1[1],\n              v[2] * u1[0] - v[0] * u1[2],\n              v[0] * u1[1] - v[1] * u1[0])\n        n2 = self._norm(u2)\n        if n2 <= 1e-12:\n            u2 = (0.0, 0.0, 1.0)\n            n2 = 1.0\n        u2 = self._scale(u2, 1.0 / n2)\n        return u1, u2\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    # Stepping/steer\n    def _stride(self, a, target):\n        # If line-of-sight, go straight to target (bounded by connect range to avoid duplicates)\n        if self._los(a, target):\n            d = self._dist(a, target)\n            if d <= self.step * 4.0:\n                return self._clamp(target)\n            else:\n                return self._toward(a, target, self.step * 2.0)\n        # Otherwise bounded step\n        return self._toward(a, target, self.step)\n\n    def _toward(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        s = step if d > step else d\n        dirv = tuple((b[i] - a[i]) / d for i in range(self.dims))\n        p = tuple(a[i] + dirv[i] * s for i in range(self.dims))\n        return self._clamp(p)\n\n    # Path assembly\n    def _assemble(self, u, v, a_side):\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if a_side:\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    # Path utilities\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _compress(self, path):\n        if len(path) <= 2:\n            return path[:]\n        # 1) Greedy visibility pruning (string pulling)\n        pts = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            extended = False\n            while j > i + 1:\n                if self._los(pts[-1], path[j]):\n                    pts.append(path[j])\n                    i = j\n                    extended = True\n                    break\n                j -= 1\n            if not extended:\n                pts.append(path[i + 1])\n                i += 1\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        # 2) Deterministic shortcut passes then randomized attempts\n        pts = self._shortcut_pass(pts)\n        for _ in range(max(0, self.shortcut_passes - 1)):\n            pts = self._shortcut_random(pts, self.shortcut_attempts)\n        return pts\n\n    def _shortcut_pass(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = list(path)\n        improved = True\n        while improved:\n            improved = False\n            i = 0\n            while i + 2 < len(pts):\n                j = i + 2\n                if self._los(pts[i], pts[j]):\n                    # if using this chord shortens length between i..j\n                    seg_old = 0.0\n                    for k in range(i + 1, j + 1):\n                        seg_old += self._dist(pts[k - 1], pts[k])\n                    seg_new = self._dist(pts[i], pts[j])\n                    if seg_new + 1e-9 < seg_old:\n                        pts = pts[:i + 1] + pts[j:]\n                        improved = True\n                        # stay at same i to try extend further\n                        continue\n                i += 1\n        return pts\n\n    def _shortcut_random(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = list(path)\n        best = self._path_len(pts)\n        n = len(pts)\n        stall = 0\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            a = pts[i]\n            b = pts[j - 1]\n            if self._los(a, b):\n                # check improvement\n                seg_old = 0.0\n                for k in range(i + 1, j):\n                    seg_old += self._dist(pts[k - 1], pts[k])\n                seg_new = self._dist(a, b)\n                if seg_new + 1e-9 < seg_old:\n                    pts = pts[:i + 1] + pts[j - 1:]\n                    n = len(pts)\n                    best = self._path_len(pts)\n                    stall = 0\n                    continue\n            stall += 1\n            if stall > 64:\n                break\n        return pts\n\n    # Volume\n    def _free_volume(self):\n        if self.dims == 2:\n            area = self.bounds[0] * self.bounds[1]\n            occ = 0.0\n            for ox, oy, w, h in self.obstacles:\n                w = max(0.0, min(w, self.bounds[0] - max(0.0, ox)))\n                h = max(0.0, min(h, self.bounds[1] - max(0.0, oy)))\n                if w > 0 and h > 0:\n                    occ += w * h\n            return max(area - occ, 1.0)\n        else:\n            vol = self.bounds[0] * self.bounds[1] * self.bounds[2]\n            occ = 0.0\n            for ox, oy, oz, w, h, d in self.obstacles:\n                w = max(0.0, min(w, self.bounds[0] - max(0.0, ox)))\n                h = max(0.0, min(h, self.bounds[1] - max(0.0, oy)))\n                d = max(0.0, min(d, self.bounds[2] - max(0.0, oz)))\n                if w > 0 and h > 0 and d > 0:\n                    occ += w * h * d\n            return max(vol - occ, 1.0)",
                "objective": -35.21019,
                "time_improvement": 63.0,
                "length_improvement": 14.0,
                "smoothness_improvement": 1597.0,
                "node_improvement": 91.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.015950322151184082,
                        "num_nodes_avg": 50.0,
                        "path_length_avg": 166.92643526049486,
                        "smoothness_avg": 0.055910285668953376,
                        "success_improvement": 0.0,
                        "time_improvement": 42.170966930511455,
                        "node_improvement": 87.40871317048602,
                        "length_improvement": 8.504975715087154,
                        "smoothness_improvement": 775.1173818477029,
                        "objective_score": 21.62986241744424
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03612496852874756,
                        "num_nodes_avg": 87.0,
                        "path_length_avg": 242.7480790589756,
                        "smoothness_avg": 0.12274371886855026,
                        "success_improvement": 0.0,
                        "time_improvement": 78.16944712989631,
                        "node_improvement": 94.1544043539609,
                        "length_improvement": 18.963704094069396,
                        "smoothness_improvement": 3058.2842952149917,
                        "objective_score": 50.12047807148549
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.015928983688354492,
                        "num_nodes_avg": 69.0,
                        "path_length_avg": 129.74285308846646,
                        "smoothness_avg": 0.08321157406704471,
                        "success_improvement": 0.0,
                        "time_improvement": 69.29803801729228,
                        "node_improvement": 91.2269548633185,
                        "length_improvement": 13.830974669398307,
                        "smoothness_improvement": 958.4450800933132,
                        "objective_score": 33.88022160729324
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m2",
                "algorithm_description": "HASTE-BiRRT (Heuristically Accelerated Sparse Tree Expansion BiRRT): a bidirectional planner that couples tiny-beam, corridor/informed sampling with dual-anchored hashed nearest search, bounded per-cell growth, and a two-sided edge memo caching both blocked and free checks. It inserts single-parent nodes with multi-ancestor LOS compression to keep trees shallow, uses a short single-step greedy connect to limit overhead, and maintains an early-updating best path to focus informed sampling. A bounded shortcut with forward LOS collapse returns smooth, short paths quickly.",
                "planning_mechanism": "Alternate growth of start/goal trees. Each side samples a small beam (goal/corridor/uniform, switching to informed ellipse after a provisional path). For each sample, find a near node via grid+anchors, steer once, enforce node and edge validity (with memoized edge checks), suppress near-duplicates and throttle per-cell growth; keep the candidate that minimizes a heuristic combining distance to the opposite tree and cost-to-come. Insert the node, apply multi-ancestor LOS compression, then attempt a direct bridge or a single-step greedy connect from the opposite tree. On success, extract and bounded-shortcut the path with LOS collapse; otherwise iterate to a cap.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=10.0,\n                 collision_step=1.0,\n                 beam_k=2,\n                 goal_bias=0.15,\n                 corridor_bias=0.55,\n                 informed_bias=0.65,\n                 grid_cell=None,\n                 max_rings=3,\n                 dupe_radius_ratio=0.45,\n                 min_sep_ratio=0.30,\n                 cell_expand_limit=2,\n                 anchor_stride=20,\n                 connect_attempts=1,\n                 compress_depth=3,\n                 smoothing_iters=24,\n                 edge_cache_max=20000):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_step = collision_step\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.grid_cell = grid_cell\n        self.max_rings = max_rings\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.min_sep_ratio = min_sep_ratio\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.anchor_stride = max(1, int(anchor_stride))\n        self.connect_attempts = max(1, int(connect_attempts))\n        self.compress_depth = max(1, int(compress_depth))\n        self.smoothing_iters = smoothing_iters\n        self.edge_cache_max = max(1000, int(edge_cache_max))\n\n        # runtime\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self.edge_cache = None  # key -> 1(blocked) or 2(free)\n\n        self.start = None\n        self.goal = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # setup discretizations\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.5)))\n        self.cache_bin = max(1.0, self.edge_res)\n        self.edge_cache = {}\n\n        # validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # early straight connection\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # initialize trees and structures\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        edges = []\n        nodes = [start_root, goal_root]\n\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        anchors_a, anchors_b = [start_root], [goal_root]\n        cell_expands_a, cell_expands_b = {}, {}\n\n        best_path_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        base_corridor_w = max(self.step_size, 0.2 * d_sg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            anchors1 = anchors_a if active_start else anchors_b\n            anchors2 = anchors_b if active_start else anchors_a\n            throttles1 = cell_expands_a if active_start else cell_expands_b\n            throttles2 = cell_expands_b if active_start else cell_expands_a\n            other_root = self.goal if active_start else self.start\n\n            best_parent = None\n            best_new = None\n            best_score = float('inf')\n\n            for _ in range(self.beam_k):\n                # sampling strategy\n                r = self._rand()\n                if best_path_len < float('inf') and r < self.informed_bias:\n                    x_rand = self._sample_informed(best_path_len, obstacles, is_3d)\n                else:\n                    r2 = self._rand()\n                    if r2 < self.goal_bias:\n                        x_rand = other_root\n                    elif r2 < self.goal_bias + self.corridor_bias:\n                        width = base_corridor_w\n                        if best_path_len < float('inf'):\n                            slack = max(0.0, best_path_len - d_sg)\n                            width = max(self.step_size, 0.2 * slack + base_corridor_w)\n                        x_rand = self._sample_corridor(width, obstacles, is_3d)\n                    else:\n                        x_rand = self._sample_free(obstacles, is_3d)\n\n                near = self._nearest_hashed(grid1, tree1, anchors1, x_rand)\n                if near is None:\n                    continue\n\n                new_pos = self._steer(near.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                # Node collision check before any insertion\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n\n                # duplicate suppression and throttle\n                if self._dist(near.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid1, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                kcell = self._grid_key(new_pos)\n                if throttles1.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n\n                # Edge collision check before considering\n                if self._edge_blocked_memo(near.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Heuristic score: distance to opposite-tree nearest + mild cost term\n                other_near = self._nearest_hashed(grid2, tree2, anchors2, new_pos)\n                to_other = self._dist(new_pos, other_near.position) if other_near is not None else self._dist(new_pos, other_root)\n                cost_term = (near.cost + self._dist(near.position, new_pos)) * 0.05\n                score = to_other + cost_term\n\n                if score < best_score:\n                    best_score = score\n                    best_parent = near\n                    best_new = new_pos\n\n            if best_parent is None:\n                continue\n\n            # Final validity before insertion (both checks)\n            if self._is_in_obstacle(best_new, obstacles, is_3d):\n                continue\n            if self._edge_blocked_memo(best_parent.position, best_new, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_cost = best_parent.cost + self._dist(best_parent.position, best_new)\n            new_node = Node(best_new, best_parent, new_cost)\n            best_parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            self._grid_add(grid1, new_node)\n            kc = self._grid_key(best_new)\n            throttles1[kc] = throttles1.get(kc, 0) + 1\n            if len(tree1) % self.anchor_stride == 0:\n                anchors1.append(new_node)\n\n            # Multi-ancestor LOS compression (up to compress_depth)\n            self._compress_to_ancestors(new_node, obstacles, is_3d, edges, self.compress_depth)\n\n            # Try direct bridge\n            other_near = self._nearest_hashed(grid2, tree2, anchors2, new_node.position)\n            if other_near is not None and not self._edge_blocked_memo(new_node.position, other_near.position, obstacles, is_3d):\n                path = self._extract_path(new_node, other_near)\n                best_path_len = self._path_length(path)\n                path = self._smooth_path(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Short greedy connect from the other side (single-step attempts)\n            p = other_near\n            attempts = 0\n            while p is not None and attempts < self.connect_attempts:\n                step_pos = self._steer(p.position, new_node.position, self.step_size)\n                if not self._in_bounds(step_pos):\n                    break\n                if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(grid2, step_pos, self.step_size * self.dupe_radius_ratio):\n                    break\n                if self._edge_blocked_memo(p.position, step_pos, obstacles, is_3d):\n                    break\n\n                # Insert micro-step node (both checks passed)\n                q = Node(step_pos, p, p.cost + self._dist(p.position, step_pos))\n                p.add_child(q)\n                tree2.append(q)\n                nodes.append(q)\n                edges.append((p, q))\n                self._grid_add(grid2, q)\n                if len(tree2) % self.anchor_stride == 0:\n                    anchors2.append(q)\n                throttles2[self._grid_key(step_pos)] = throttles2.get(self._grid_key(step_pos), 0) + 1\n\n                # optional small compression on the micro-step\n                self._compress_to_ancestors(q, obstacles, is_3d, edges, 2)\n\n                # Check bridge to new_node\n                if not self._edge_blocked_memo(new_node.position, q.position, obstacles, is_3d):\n                    path = self._extract_path(new_node, q)\n                    best_path_len = self._path_length(path)\n                    path = self._smooth_path(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, nodes, edges)\n\n                p = q\n                attempts += 1\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp_tuple(to_pos)\n        if d <= 1e-12:\n            return self._clamp_tuple(from_pos)\n        r = step / d\n        return self._clamp_tuple(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Edge memo (blocked and free)\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        state = self.edge_cache.get(key)\n        if state is not None:\n            return state == 1\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d)\n        self.edge_cache[key] = 1 if blocked else 2\n        # bounded cache pruning to limit rechecks without frequent full clears\n        if len(self.edge_cache) > self.edge_cache_max:\n            self._prune_edge_cache()\n        return blocked\n\n    def _prune_edge_cache(self):\n        # remove roughly half of items deterministically\n        to_remove = []\n        count = 0\n        for k in self.edge_cache:\n            if (count % 2) == 0:\n                to_remove.append(k)\n            count += 1\n            if len(to_remove) >= self.edge_cache_max // 2:\n                break\n        for k in to_remove:\n            try:\n                del self.edge_cache[k]\n            except:\n                pass\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            # rejection within sphere\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        else:\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        # prolate ellipse: sum of distances to foci <= best_len\n        for _ in range(48):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= best_len and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # fallback\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)\n\n    # Grid hashing\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, tree, anchors, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # anchor fallback\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # rare: full scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(max(1, radius / self.grid_cell)) + 1\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Compression\n    def _compress_to_ancestors(self, node, obstacles, is_3d, edges, depth_limit):\n        cur_parent = node.parent\n        depth = 0\n        while cur_parent is not None and depth < depth_limit:\n            gp = cur_parent.parent\n            if gp is None:\n                break\n            if not self._edge_blocked_memo(gp.position, node.position, obstacles, is_3d):\n                # update parent-child relations\n                cur_parent.remove_child(node)\n                self._edges_remove(edges, cur_parent, node)\n                gp.add_child(node)\n                edges.append((gp, node))\n                node.cost = gp.cost + self._dist(gp.position, node.position)\n                cur_parent = gp\n                depth += 1\n            else:\n                break\n\n    # Edges helpers\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node):\n        path_a = self._path_to_root(a_node)\n        path_b = []\n        cur = b_node\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _smooth_path(self, path, obstacles, is_3d, iters):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        no_improve = 0\n        last_len = self._path_length(pts)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d):\n                new_pts = pts[:i + 1] + pts[j:]\n                new_len = self._path_length(new_pts)\n                if new_len <= last_len:\n                    pts = new_pts\n                    last_len = new_len\n                    no_improve = 0\n                else:\n                    no_improve += 1\n            else:\n                no_improve += 1\n            if no_improve >= 8:\n                break\n        # Forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            k = 1\n            while k < len(pts) - 1:\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n                k += 1\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
                "objective": -26.1688,
                "time_improvement": 35.0,
                "length_improvement": 11.0,
                "smoothness_improvement": 1792.0,
                "node_improvement": 88.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.027369928359985352,
                        "num_nodes_avg": 65.0,
                        "path_length_avg": 171.28307479198807,
                        "smoothness_avg": 0.05148806664012615,
                        "success_improvement": 0.0,
                        "time_improvement": -7.338122500577379,
                        "node_improvement": 83.63132712163183,
                        "length_improvement": 6.11703255250457,
                        "smoothness_improvement": 705.9000510442344,
                        "objective_score": 4.9982830365507
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.04116971492767334,
                        "num_nodes_avg": 116.3,
                        "path_length_avg": 248.99030586642007,
                        "smoothness_avg": 0.12529040112374196,
                        "success_improvement": 0.0,
                        "time_improvement": 74.30062345562982,
                        "node_improvement": 92.18571524558222,
                        "length_improvement": 16.879869113207995,
                        "smoothness_improvement": 3123.8122639421595,
                        "objective_score": 48.037169824324536
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.030934453010559082,
                        "num_nodes_avg": 94.2,
                        "path_length_avg": 133.85366176833466,
                        "smoothness_avg": 0.12940331913875977,
                        "success_improvement": 0.0,
                        "time_improvement": 36.934929218056986,
                        "node_improvement": 88.02288620470438,
                        "length_improvement": 11.10077127990379,
                        "smoothness_improvement": 1546.0006678855698,
                        "objective_score": 25.470944872787218
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "SAGE-IBiRRT*: Simple Adaptive Guided Efficient Informed BiRRT*. A lean bidirectional RRT* that balances trees, uses a single hashed grid for fast nearest and neighbor queries, minimalist informed/corridor sampling, bounded LOS strides, k-free RRT* radius with benefit-capped rewiring via O(1) edge updates, and a two-stage shortcut (greedy visibility pull + light randomized). It maintains an incumbent for informed sampling but returns immediately on a validated bridge after local optimization, reducing search time while preserving high-quality, smooth paths.",
            "planning_mechanism": "Alternate growing the two trees (start/goal). Each iteration: sample a target (goal/corridor/informed/uniform), pick nearest via hashed rings, take a bounded LOS stride, reject out-of-bounds/inside-obstacle/near-duplicate. Select a least-cost parent among radius neighbors (RRT* radius from log(n)/n); validate both node and edge before insertion, then benefit-order rewire nearby nodes with O(1) edge updates. Attempt a short bridge to the opposite tree (direct or up to a few micro-steps). On connection, assemble and apply greedy visibility pulling followed by a few randomized shortcuts, and return. Maintain and use the best-so-far path length to guide informed sampling during search.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = parent\n        if parent is not None:\n            if self not in parent.children:\n                parent.children.append(self)\n\n    def path_from_root(self):\n        out = []\n        cur = self\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        out.reverse()\n        return out\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=8.0,\n                 connect_factor=3.0,\n                 goal_bias=0.12,\n                 corridor_bias=0.35,\n                 informed_bias=0.6,\n                 grid_cell_factor=1.0,\n                 dupe_radius_factor=0.35,\n                 rewire_cap=12,\n                 micro_bridge_steps=2,\n                 shortcut_attempts=160):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_factor = float(connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dupe_rf = float(dupe_radius_factor)\n        self.rewire_cap = int(rewire_cap)\n        self.micro_bridge_steps = int(micro_bridge_steps)\n        self.shortcut_attempts = int(shortcut_attempts)\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n        self._seed_rng()\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._build_obs_index()\n\n        if self._inside_obstacle(self.start) or self._inside_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # setup\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_r = max(0.25, self.step * self.dupe_rf)\n        self.connect_dist = max(self.step, self.connect_factor * self.step)\n        self.axis = self._unit(self._sub(self.goal, self.start))\n        self.corridor_w = max(self.step, 0.2 * self._dist(self.start, self.goal))\n\n        Aroot = Node(self.start, None, 0.0)\n        Broot = Node(self.goal, None, 0.0)\n        Ta, Tb = [Aroot], [Broot]\n        Ga, Gb = {}, {}\n        self._grid_put(Ga, Aroot)\n        self._grid_put(Gb, Broot)\n\n        nodes = [Aroot, Broot]\n        self.edges = []\n        self._edge_idx = {}\n\n        # RRT* constants\n        self.mu_free = self._approx_free_volume()\n        self.zeta = 3.141592653589793 if self.dims == 2 else (4.0 * 3.141592653589793 / 3.0)\n        self.gamma_rrt = 2.4 * ((1.0 + 1.0 / self.dims) ** (1.0 / self.dims)) * (max(self.mu_free, 1e-9) / self.zeta) ** (1.0 / self.dims)\n\n        best_len = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            grow_a = (len(Ta) <= len(Tb))\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n\n            target = self._sample_target(attractor, best_len)\n            if target is None:\n                continue\n\n            near = self._nearest(G, T, target)\n            if near is None:\n                continue\n\n            new_pos = self._stride(near.position, target)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._inside_obstacle(new_pos):\n                continue\n            if self._too_close(G, new_pos, self.dupe_r):\n                continue\n\n            parent, new_cost = self._select_parent(G, T, new_pos)\n            if parent is None:\n                # fallback to nearest if edge free\n                if self._edge_free(near.position, new_pos):\n                    parent = near\n                    new_cost = near.cost + self._dist(near.position, new_pos)\n                else:\n                    continue\n\n            # Both checks right before insertion\n            if self._inside_obstacle(new_pos):\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, None, new_cost)\n            new_node.attach(parent)\n            T.append(new_node)\n            nodes.append(new_node)\n            self._add_edge(parent, new_node)\n            self._grid_put(G, new_node)\n\n            # Rewire nearby nodes (benefit-ordered, capped)\n            self._rewire(G, new_node)\n\n            # Try to connect to opposite tree\n            other = self._nearest(Gopp, Topp, new_node.position)\n            connected = False\n            end_node = None\n            if other is not None:\n                if self._dist(new_node.position, other.position) <= self.connect_dist and self._edge_free(new_node.position, other.position):\n                    connected = True\n                    end_node = other\n                else:\n                    # short micro-bridge from opposite tree\n                    p = other\n                    for _ in range(self.micro_bridge_steps):\n                        step_p = self._toward(p.position, new_node.position, self.step)\n                        if not self._in_bounds(step_p):\n                            break\n                        if self._inside_obstacle(step_p):\n                            break\n                        if self._too_close(Gopp, step_p, self.dupe_r):\n                            break\n                        if not self._edge_free(p.position, step_p):\n                            break\n                        q = Node(step_p, None, p.cost + self._dist(p.position, step_p))\n                        q.attach(p)\n                        Topp.append(q)\n                        nodes.append(q)\n                        self._add_edge(p, q)\n                        self._grid_put(Gopp, q)\n                        if self._edge_free(new_node.position, q.position):\n                            connected = True\n                            end_node = q\n                            break\n                        p = q\n\n            if connected and end_node is not None:\n                path = self._assemble(new_node, end_node, grow_a)\n                path = self._smooth(path)\n                return PlannerResult(True, path, nodes, self.edges)\n\n            # Maintain incumbent best for informed sampling\n            if other is not None and self._edge_free(new_node.position, other.position):\n                tmp = self._assemble(new_node, other, grow_a)\n                L = self._path_len(tmp)\n                if L < best_len:\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._smooth(best_path)\n            return PlannerResult(True, best_path, nodes, self.edges)\n        return PlannerResult(False, [], nodes, self.edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0\n        for v in (self.start + self.goal):\n            s = (s * 1664525 + int(977 * v + 0.5) + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        self._rng = s if s != 0 else 123456789\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _add(self, a, b):\n        return tuple(a[i] + b[i] for i in range(self.dims))\n\n    def _sub(self, a, b):\n        return tuple(a[i] - b[i] for i in range(self.dims))\n\n    def _scale(self, a, s):\n        return tuple(a[i] * s for i in range(self.dims))\n\n    def _dot(self, a, b):\n        return sum(a[i] * b[i] for i in range(self.dims))\n\n    def _norm(self, a):\n        return self._dist(a, tuple(0.0 for _ in range(self.dims)))\n\n    def _unit(self, a):\n        n = self._norm(a)\n        if n <= 1e-12:\n            return tuple(0.0 for _ in range(self.dims))\n        inv = 1.0 / n\n        return tuple(a[i] * inv for i in range(self.dims))\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    # Obstacle index\n    def _build_obs_index(self):\n        self.obs_cell = max(3.0, self.step * 1.2)\n        self.og = {}\n        if self.dims == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.og.get(key)\n                            if b is None:\n                                self.og[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.og.get(key)\n                        if b is None:\n                            self.og[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _inside_obstacle(self, p):\n        if self.dims == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.og.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.og.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    # Edge collision\n    def _edge_free(self, a, b):\n        return not self._hit_seg(a, b)\n\n    def _hit_seg(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            seen = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        ids = self.og.get((i, j, k))\n                        if ids:\n                            for idx in ids:\n                                if idx in seen:\n                                    continue\n                                seen.add(idx)\n                                ox, oy, oz, w, h, d = self.obstacles[idx]\n                                if self._seg_box(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            seen = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    ids = self.og.get((i, j))\n                    if ids:\n                        for idx in ids:\n                            if idx in seen:\n                                continue\n                            seen.add(idx)\n                            ox, oy, w, h = self.obstacles[idx]\n                            if self._seg_box(a, b, (ox, oy), (ox + w, oy + h)):\n                                return True\n            return False\n\n    def _seg_box(self, p0, p1, bmin, bmax):\n        # Liang-Barsky / slab method for segment vs AABB\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Spatial hashing for nodes\n    def _key_of(self, pos):\n        return tuple(int(pos[i] // self.cell) for i in range(self.dims))\n\n    def _grid_put(self, grid, node):\n        k = self._key_of(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_fetch(self, grid, key, radius):\n        out = []\n        if self.dims == 3:\n            for dx in range(-radius, radius + 1):\n                for dy in range(-radius, radius + 1):\n                    for dz in range(-radius, radius + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-radius, radius + 1):\n                for dy in range(-radius, radius + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._key_of(pos)\n        best, bestd = None, 1e100\n        r = 0\n        found_any = False\n        while r <= 6:\n            cand = self._ring_fetch(grid, key, r)\n            if cand:\n                found_any = True\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                break\n            r += 1\n        if not found_any:\n            # fallback full sparse scan\n            step = max(1, len(tree) // 64) if tree else 1\n            for i in range(0, len(tree), step):\n                n = tree[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_radius(self, grid, pos, radius, cap=256):\n        key = self._key_of(pos)\n        rc = max(1, int(radius // self.cell) + 1)\n        cand = self._ring_fetch(grid, key, rc)\n        out = []\n        rr = radius * radius\n        for n in cand:\n            d2 = 0.0\n            np = n.position\n            for i in range(self.dims):\n                dd = np[i] - pos[i]\n                d2 += dd * dd\n            if d2 <= rr:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _too_close(self, grid, pos, r):\n        return len(self._neighbors_radius(grid, pos, r, 1)) > 0\n\n    # Parent selection with RRT* radius\n    def _select_parent(self, grid, tree, pos):\n        n = max(1, len(tree))\n        # simple ln approximation via change-of-base on 2\n        ln = self._ln(float(n + 1))\n        r_rrt = (self.gamma_rrt * (ln / float(n))) ** (1.0 / self.dims) if n > 1 else self.step * 2.0\n        r_rrt = min(max(self.step, r_rrt), self.step * 6.0)\n        cand = self._neighbors_radius(grid, pos, r_rrt, 256)\n        if not cand:\n            return (None, None)\n        best_p = None\n        best_c = 1e100\n        # evaluate cost + LOS (edge free)\n        for p in cand:\n            c_try = p.cost + self._dist(p.position, pos)\n            if c_try + 1e-9 < best_c and self._edge_free(p.position, pos):\n                best_p = p\n                best_c = c_try\n        return (best_p, best_c) if best_p is not None else (None, None)\n\n    # Rewiring\n    def _rewire(self, grid, node):\n        n = max(1, len(node.children) + 1)  # local proxy to keep radius scale conservative\n        ln = self._ln(float(n + 1))\n        r_rrt = (self.gamma_rrt * max(ln, 1.0) / float(max(2, n))) ** (1.0 / self.dims)\n        r_rrt = min(max(self.step * 1.5, r_rrt * self.step * 6.0), self.step * 6.0)\n        neigh = self._neighbors_radius(grid, node.position, r_rrt, 256)\n        cand = []\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            alt = node.cost + self._dist(node.position, nb.position)\n            gain = nb.cost - alt\n            if gain > 1e-9:\n                cand.append((gain, nb))\n        cand.sort(key=lambda x: -x[0])\n        changed = 0\n        for gain, nb in cand:\n            if changed >= self.rewire_cap:\n                break\n            if not self._edge_free(node.position, nb.position):\n                continue\n            oldp = nb.parent\n            if oldp is node:\n                continue\n            if oldp is not None:\n                try:\n                    oldp.children.remove(nb)\n                except:\n                    pass\n                self._remove_edge(oldp, nb)\n            nb.attach(node)\n            self._add_edge(node, nb)\n            nb.cost = node.cost + self._dist(node.position, nb.position)\n            # propagate costs\n            stack = [nb]\n            while stack:\n                cur = stack.pop()\n                for ch in cur.children:\n                    ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                    stack.append(ch)\n            changed += 1\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    # Edges utilities (O(1) updates via swap-pop)\n    def _add_edge(self, p, c):\n        self.edges.append((p, c))\n        self._edge_idx[c] = len(self.edges) - 1\n\n    def _remove_edge(self, p, c):\n        idx = self._edge_idx.get(c)\n        if idx is None:\n            # fallback linear search (rare)\n            for i in range(len(self.edges)):\n                if self.edges[i][0] is p and self.edges[i][1] is c:\n                    idx = i\n                    break\n        if idx is None:\n            return\n        last = len(self.edges) - 1\n        if idx != last:\n            self.edges[idx] = self.edges[last]\n            _, moved_child = self.edges[idx]\n            self._edge_idx[moved_child] = idx\n        self.edges.pop()\n        try:\n            del self._edge_idx[c]\n        except:\n            pass\n\n    # Sampling\n    def _sample_target(self, attractor, best_len):\n        # attempt informed, else corridor/goal/uniform\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._sample_informed(best_len)\n            if p is not None and self._in_bounds(p) and not self._inside_obstacle(p):\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            p = attractor\n        elif r2 < self.goal_bias + self.corridor_bias:\n            p = self._sample_corridor()\n        else:\n            p = self._sample_uniform()\n        if self._in_bounds(p) and not self._inside_obstacle(p):\n            return p\n        return None\n\n    def _sample_uniform(self):\n        if self.dims == 3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_corridor(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        if self.dims == 2:\n            n = (-self.axis[1], self.axis[0])\n            off = self._scale(n, self._rand_range(-self.corridor_w, self.corridor_w))\n            p = self._add(base, off)\n        else:\n            u1, u2 = self._perp_basis(self.axis)\n            off = self._add(self._scale(u1, self._rand_range(-self.corridor_w, self.corridor_w)),\n                            self._scale(u2, self._rand_range(-self.corridor_w, self.corridor_w)))\n            p = self._add(base, off)\n        return self._clamp(p)\n\n    def _sample_informed(self, c_best):\n        cmin = self._dist(self.start, self.goal)\n        if not (c_best < float('inf')) or c_best <= cmin + 1e-9:\n            return None\n        a = 0.5 * c_best\n        l = 0.5 * cmin\n        if a <= l + 1e-12:\n            return None\n        b = (a * a - l * l) ** 0.5\n        center = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dims))\n        if self.dims == 2:\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                if x * x + y * y <= 1.0:\n                    n = (-self.axis[1], self.axis[0])\n                    p = self._add(center, self._add(self._scale(self.axis, a * x), self._scale(n, b * y)))\n                    if self._in_bounds(p):\n                        return self._clamp(p)\n        else:\n            u1, u2 = self._perp_basis(self.axis)\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                z = self._rand_range(-1.0, 1.0)\n                if x * x + y * y + z * z <= 1.0:\n                    p = self._add(center,\n                                  self._add(self._scale(self.axis, a * x),\n                                            self._add(self._scale(u1, b * y), self._scale(u2, b * z))))\n                    if self._in_bounds(p):\n                        return self._clamp(p)\n        return None\n\n    def _perp_basis(self, v):\n        if self.dims == 2:\n            return (-v[1], v[0])\n        # 3D: two orthonormal perpendiculars to v\n        if abs(v[0]) < 0.9:\n            tmp = (1.0, 0.0, 0.0)\n        else:\n            tmp = (0.0, 1.0, 0.0)\n        u1 = self._sub(tmp, self._scale(v, self._dot(tmp, v)))\n        n1 = self._norm(u1)\n        if n1 <= 1e-12:\n            u1 = (0.0, 0.0, 1.0)\n            n1 = 1.0\n        u1 = self._scale(u1, 1.0 / n1)\n        u2 = (v[1] * u1[2] - v[2] * u1[1],\n              v[2] * u1[0] - v[0] * u1[2],\n              v[0] * u1[1] - v[1] * u1[0])\n        n2 = self._norm(u2)\n        if n2 <= 1e-12:\n            u2 = (0.0, 0.0, 1.0)\n            n2 = 1.0\n        u2 = self._scale(u2, 1.0 / n2)\n        return u1, u2\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    # Steer\n    def _stride(self, a, target):\n        if self._edge_free(a, target):\n            d = self._dist(a, target)\n            if d <= self.step * 3.0:\n                return self._clamp(target)\n            else:\n                return self._toward(a, target, self.step * 2.0)\n        return self._toward(a, target, self.step)\n\n    def _toward(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        s = step if d > step else d\n        dirv = tuple((b[i] - a[i]) / d for i in range(self.dims))\n        p = tuple(a[i] + dirv[i] * s for i in range(self.dims))\n        return self._clamp(p)\n\n    # Path assembly and smoothing\n    def _assemble(self, u, v, a_side):\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if a_side:\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _smooth(self, path):\n        if len(path) <= 2:\n            return list(path)\n        # greedy visibility pulling\n        pts = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pts[-1], path[j]):\n                    pts.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pts.append(path[i + 1])\n                i += 1\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        # light randomized shortcuts\n        best = self._path_len(pts)\n        n = len(pts)\n        attempts = self.shortcut_attempts\n        stall = 0\n        while attempts > 0 and n >= 3 and stall < 64:\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            a = pts[i]\n            b = pts[j - 1]\n            if self._edge_free(a, b):\n                # improve if shorter\n                old = 0.0\n                for k in range(i + 1, j):\n                    old += self._dist(pts[k - 1], pts[k])\n                newd = self._dist(a, b)\n                if newd + 1e-9 < old:\n                    pts = pts[:i + 1] + pts[j - 1:]\n                    n = len(pts)\n                    best = self._path_len(pts)\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            attempts -= 1\n        return pts\n\n    # Utilities\n    def _ln(self, x):\n        if x <= 0.0:\n            return -1e9\n        k = 0\n        while x > 2.0:\n            x *= 0.5\n            k += 1\n        y = x - 1.0\n        term = y\n        s = term\n        i = 2.0\n        while abs(term) > 1e-6 and i < 48.0:\n            term *= -y * (i - 1.0) / i\n            s += term\n            i += 1.0\n        return s + k * 0.6931471805599453\n\n    def _approx_free_volume(self):\n        if self.dims == 2:\n            area = self.bounds[0] * self.bounds[1]\n            occ = 0.0\n            for ox, oy, w, h in self.obstacles:\n                w = max(0.0, min(w, self.bounds[0] - max(0.0, ox)))\n                h = max(0.0, min(h, self.bounds[1] - max(0.0, oy)))\n                if w > 0 and h > 0:\n                    occ += w * h\n            return max(area - occ, 1.0)\n        else:\n            vol = self.bounds[0] * self.bounds[1] * self.bounds[2]\n            occ = 0.0\n            for ox, oy, oz, w, h, d in self.obstacles:\n                w = max(0.0, min(w, self.bounds[0] - max(0.0, ox)))\n                h = max(0.0, min(h, self.bounds[1] - max(0.0, oy)))\n                d = max(0.0, min(d, self.bounds[2] - max(0.0, oz)))\n                if w > 0 and h > 0 and d > 0:\n                    occ += w * h * d\n            return max(vol - occ, 1.0)",
            "objective": -39.32983,
            "time_improvement": 73.0,
            "length_improvement": 7.0,
            "smoothness_improvement": 2685.0,
            "node_improvement": 92.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009373879432678223,
                    "num_nodes_avg": 41.0,
                    "path_length_avg": 181.58636678228862,
                    "smoothness_avg": 0.053454954582751554,
                    "success_improvement": 0.0,
                    "time_improvement": 62.734279772748366,
                    "node_improvement": 89.67514479979855,
                    "length_improvement": 0.4696349465113734,
                    "smoothness_improvement": 736.6861185118518,
                    "objective_score": 22.78549549229059
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022876167297363283,
                    "num_nodes_avg": 73.0,
                    "path_length_avg": 263.0467863715604,
                    "smoothness_avg": 0.2078331276053119,
                    "success_improvement": 0.0,
                    "time_improvement": 85.72119713863205,
                    "node_improvement": 95.09507491769132,
                    "length_improvement": 12.187411327234097,
                    "smoothness_improvement": 5247.696069435725,
                    "objective_score": 59.267286285108696
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013928437232971191,
                    "num_nodes_avg": 61.0,
                    "path_length_avg": 140.06179758594084,
                    "smoothness_avg": 0.1706252860791988,
                    "success_improvement": 0.0,
                    "time_improvement": 71.32812116571944,
                    "node_improvement": 92.2441195168468,
                    "length_improvement": 6.977623069509789,
                    "smoothness_improvement": 2070.3410446788585,
                    "objective_score": 35.93671541481599
                }
            ],
            "success_rate": 1.0
        },
        "objective": 39.8,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Redundant collision and visibility checks across sampling, parent selection, steering, connection, and smoothing, inflating per-iteration cost\n   - Nearest-neighbor search constrained to small grid rings with frequent linear or wide fallbacks, causing O(n) scans in sparse cells\n   - Rewiring/compression rely on linear edge removal and subtree updates, yielding O(E) edge maintenance overhead\n   - Bridge attempts limited to single micro-steps and short connect ranges, requiring many iterations to close small gaps\n   - Heavy rejection in sampling (wide informed/corridor regions, multiple retries) wastes effort in cluttered areas\n   - Post-processing smoothers perform many uncached edge discretization checks, adding substantial tail latency\n   - Weak guidance toward lower-cost parents (or absent rewiring) leads to longer detours, increasing iterations to connect\n   - Duplicate/spacing filters and inconsistent strides create sparse local coverage near obstacles, reducing good parent/neighbor availability"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Spatially indexed, slab-based edge tests that query only nearby obstacles (no fine discretization, no churny memo cache)\n   - O(1) edge bookkeeping via indexed swap-pop updates during rewiring, plus benefit-ordered, capped rewiring in an RRT*-radius\n   - LOS-bounded long strides and acceptance fallback to nearest valid parent when radius candidates fail, reducing stalls\n   - Multi-step micro-bridging toward the opposite tree per iteration with a larger connect window, increasing bridge success rate\n   - Balanced bidirectional growth with incumbent-guided informed sampling to tighten the sampling domain earlier\n   - Lightweight smoothing (greedy pull + limited randomized shortcuts) replacing heavy, repeated collision-discretized smoothing\n   - Fewer sampling retries and a simpler corridor sampler aligned with the start\u2013goal axis\n2. Expected mechanism of impact:\n   - Fewer and cheaper collision checks per edge (bucketed AABB intersections), lowering constant factors per iteration\n   - Reduced edge maintenance complexity during rewiring (O(1) vs. O(E)), cutting overhead as trees grow\n   - Higher node acceptance rate and longer safe strides decrease node count and total iterations to first connection\n   - More effective bridging (multiple micro-steps + wider connect) shortens the time to assemble a feasible path\n   - Earlier, tighter informed sampling focuses exploration, reducing wasted expansions in irrelevant regions\n   - Shorter, lighter post-processing minimizes tail time after connection, improving overall planning latency"
        }
    },
    {
        "parents": [
            {
                "operator": "m1",
                "algorithm_description": "FALCON-IBiRRT*: Fast Adaptive Local-Connect Optimizing, Curvature-aware Informed BiRRT*. It grows two sparse trees with hashed-grid k-nearest search, long-then-short steering, curvature-regularized parent selection, bounded local rewiring with capped cost propagation, and a best-of-beam cross-tree connection. Sampling blends goal/corridor/Halton and switches to an ellipse once an incumbent path exists. A dual-state edge memo with fine quantization accelerates collision checks without false rejections. After bridging, the path is pruned, shortcut, and elastically smoothed with a curvature term to improve length and smoothness while preserving feasibility.",
                "planning_mechanism": "Alternate expansions from start/goal roots. Per iteration: sample (goal/ellipse/corridor/Halton/uniform), find a near node via a hashed grid, attempt a long then short steer (both node and edge checks). Gate insertions with an A*-like f=g+h bound when an incumbent exists. Choose a parent among k-nearest by minimizing cost plus a small angle penalty, then insert and locally rewire only k neighbors with a capped subtree update. Attempt to bridge using the best-cost candidate among k nearest nodes in the opposite tree; otherwise grow a few guided steps from the other side and retry. On success, assemble start-to-goal, visibility-prune, shortcut, and curvature-aware elastic smooth, then return.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = set()\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.add(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=6.0,\n                 neighbor_k=16,\n                 goal_bias=0.20,\n                 ellipse_bias=0.60,\n                 corridor_bias=0.50,\n                 beam_k=4,\n                 connect_steps=2,\n                 grid_cell_factor=1.20,\n                 heur_gate_init=1.20,\n                 heur_gate_final=1.05,\n                 beta_angle=0.045,\n                 dupe_ratio=0.40,\n                 cell_expand_limit=3,\n                 anchor_stride=18,\n                 smoothing_trials=120,\n                 elastic_passes=4,\n                 edge_cache_max=30000):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_k = neighbor_k\n        self.goal_bias = goal_bias\n        self.ellipse_bias = ellipse_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.connect_steps = connect_steps\n        self.grid_cell_factor = grid_cell_factor\n        self.heur_gate_init = heur_gate_init\n        self.heur_gate_final = heur_gate_final\n        self.beta_angle = beta_angle\n        self.dupe_ratio = dupe_ratio\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.anchor_stride = max(1, int(anchor_stride))\n        self.smoothing_trials = smoothing_trials\n        self.elastic_passes = elastic_passes\n        self.edge_cache_max = max(2000, int(edge_cache_max))\n\n        # runtime\n        self.dim = 2\n        self.bounds = None\n        self.cell = 1.0\n        self._seed = 1337\n        self._halton_idx = 1\n        self._edge_cache = {}\n        self._cache_bin = 1.0\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obs(start, obstacles, is_3d) or self._point_in_obs(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # setup discretizations and caches\n        self.cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self._seed = 1337\n        self._halton_idx = 1\n        self._edge_cache = {}\n        self._cache_bin = max(0.5, self.step_size * 0.2)\n\n        # direct path early exit\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.add(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # initialize trees, grids, anchors, throttles\n        a_root = Node(start, None, 0.0)\n        b_root = Node(goal, None, 0.0)\n        tree_a, tree_b = [a_root], [b_root]\n        grid_a, grid_b = {}, {}\n        anchors_a, anchors_b = [a_root], [b_root]\n        throttle_a, throttle_b = {}, {}\n        all_nodes = [a_root, b_root]\n\n        self._grid_add(grid_a, a_root)\n        self._grid_add(grid_b, b_root)\n\n        best_path = None\n        c_best = float('inf')\n        d_sg = self._dist(start, goal)\n\n        for it in range(self.max_iter):\n            from_start = (it % 2 == 0)\n            if from_start:\n                tree_x, tree_y = tree_a, tree_b\n                grid_x, grid_y = grid_a, grid_b\n                anchors_x, anchors_y = anchors_a, anchors_b\n                throttle_x, throttle_y = throttle_a, throttle_b\n                root_x, root_y = a_root, b_root\n                attractor = goal\n            else:\n                tree_x, tree_y = tree_b, tree_a\n                grid_x, grid_y = grid_b, grid_a\n                anchors_x, anchors_y = anchors_b, anchors_a\n                throttle_x, throttle_y = throttle_b, throttle_a\n                root_x, root_y = b_root, a_root\n                attractor = start\n\n            # sampling\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = attractor\n            else:\n                used_informed = (c_best < float('inf') and self._rand() < self.ellipse_bias)\n                if used_informed:\n                    x_rand = self._ellipse_accept_sample(root_x.position, root_y.position, c_best, 10)\n                else:\n                    if self._rand() < self.corridor_bias:\n                        width = max(self.step_size, 0.2 * d_sg if c_best == float('inf') else 0.15 * c_best)\n                        x_rand = self._corridor_sample(root_x.position, root_y.position, width, obstacles, is_3d)\n                    else:\n                        if self._rand() < 0.6:\n                            x_rand = self._halton_sample()\n                        else:\n                            x_rand = self._uniform_free(obstacles, is_3d)\n\n            # nearest in active tree\n            n_near = self._nearest_hashed(grid_x, tree_x, anchors_x, x_rand)\n            if n_near is None:\n                continue\n\n            # long-then-short steer with checks\n            x_new_pos = None\n            tgt = self._steer(n_near.position, x_rand, 1.8 * self.step_size)\n            if self._in_bounds(tgt) and not self._point_in_obs(tgt, obstacles, is_3d):\n                if not self._edge_blocked(n_near.position, tgt, obstacles, is_3d):\n                    x_new_pos = tgt\n            if x_new_pos is None:\n                tgt = self._steer(n_near.position, x_rand, self.step_size)\n                if not self._in_bounds(tgt) or self._point_in_obs(tgt, obstacles, is_3d):\n                    continue\n                if self._edge_blocked(n_near.position, tgt, obstacles, is_3d):\n                    continue\n                x_new_pos = tgt\n\n            # per-cell throttle and near-duplicate suppression\n            kcell = self._grid_key(x_new_pos)\n            if throttle_x.get(kcell, 0) >= self.cell_expand_limit:\n                continue\n            if self._exists_close(grid_x, x_new_pos, self.step_size * self.dupe_ratio):\n                continue\n\n            # heuristic gate if incumbent exists\n            if c_best < float('inf'):\n                g_tent = n_near.cost + self._dist(n_near.position, x_new_pos)\n                f_tent = g_tent + self._dist(x_new_pos, root_y.position)\n                if f_tent >= self._interp_gate(it) * c_best:\n                    continue\n\n            # choose parent among k-nearest\n            neigh = self._k_nearest_nodes(grid_x, x_new_pos, self.neighbor_k)\n            parent, new_cost = self._choose_parent(x_new_pos, n_near, neigh, obstacles, is_3d)\n            if parent is None:\n                continue\n\n            # final validity before insertion (both checks)\n            if self._point_in_obs(x_new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked(parent.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            # insert node\n            x_new = Node(x_new_pos, None, new_cost)\n            x_new.attach(parent)\n            tree_x.append(x_new)\n            all_nodes.append(x_new)\n            self._grid_add(grid_x, x_new)\n            throttle_x[kcell] = throttle_x.get(kcell, 0) + 1\n            if len(tree_x) % self.anchor_stride == 0:\n                anchors_x.append(x_new)\n\n            # bounded local rewiring\n            self._rewire_local(x_new, neigh, obstacles, is_3d, cap_updates=64)\n\n            # best-of-beam connect attempt from other tree\n            bridge = None\n            beam = self._k_nearest_nodes(grid_y, x_new.position, min(self.beam_k, len(tree_y)))\n            best_bridge = None\n            best_bridge_cost = float('inf')\n            for cand in beam:\n                if not self._edge_blocked(x_new.position, cand.position, obstacles, is_3d):\n                    total = x_new.cost + self._dist(x_new.position, cand.position) + cand.cost\n                    if total < best_bridge_cost:\n                        best_bridge_cost = total\n                        best_bridge = cand\n            if best_bridge is not None:\n                bridge = best_bridge\n\n            # guided small-step connect if no direct bridge\n            if bridge is None and beam:\n                cur = beam[0]\n                steps = 0\n                while steps < self.connect_steps and cur is not None and bridge is None:\n                    step_try = self._steer(cur.position, x_new.position, 1.5 * self.step_size)\n                    step_pos = None\n                    if self._in_bounds(step_try) and not self._point_in_obs(step_try, obstacles, is_3d):\n                        if not self._edge_blocked(cur.position, step_try, obstacles, is_3d):\n                            step_pos = step_try\n                    if step_pos is None:\n                        step_try = self._steer(cur.position, x_new.position, self.step_size)\n                        if not self._in_bounds(step_try) or self._point_in_obs(step_try, obstacles, is_3d):\n                            break\n                        if self._edge_blocked(cur.position, step_try, obstacles, is_3d):\n                            break\n                        step_pos = step_try\n\n                    if self._exists_close(grid_y, step_pos, self.step_size * self.dupe_ratio):\n                        break\n\n                    # heuristic gate for the other side\n                    if c_best < float('inf'):\n                        g2 = cur.cost + self._dist(cur.position, step_pos)\n                        f2 = g2 + self._dist(step_pos, root_x.position)\n                        if f2 >= self._interp_gate(it) * c_best:\n                            break\n\n                    neigh_b = self._k_nearest_nodes(grid_y, step_pos, self.neighbor_k)\n                    p_b, c_b = self._choose_parent(step_pos, cur, neigh_b, obstacles, is_3d)\n                    if p_b is None:\n                        break\n\n                    # final validity before insertion (both checks)\n                    if self._point_in_obs(step_pos, obstacles, is_3d):\n                        break\n                    if self._edge_blocked(p_b.position, step_pos, obstacles, is_3d):\n                        break\n\n                    nxt = Node(step_pos, None, c_b)\n                    nxt.attach(p_b)\n                    tree_y.append(nxt)\n                    all_nodes.append(nxt)\n                    self._grid_add(grid_y, nxt)\n                    if len(tree_y) % self.anchor_stride == 0:\n                        anchors_y.append(nxt)\n                    kcy = self._grid_key(step_pos)\n                    throttle_y[kcy] = throttle_y.get(kcy, 0) + 1\n\n                    self._rewire_local(nxt, neigh_b, obstacles, is_3d, cap_updates=48)\n\n                    if not self._edge_blocked(nxt.position, x_new.position, obstacles, is_3d):\n                        bridge = nxt\n                        break\n                    cur = nxt\n                    steps += 1\n\n            # assemble and post-process on success\n            if bridge is not None:\n                if from_start:\n                    pa = self._path_to_root(x_new)\n                    pb = self._path_to_root(bridge)\n                    path = pa + list(reversed(pb))\n                else:\n                    pa = self._path_to_root(x_new)\n                    pb = self._path_to_root(bridge)\n                    path = pb + list(reversed(pa))\n\n                path = self._vis_prune(path, obstacles, is_3d)\n                path = self._shortcut(path, obstacles, is_3d, self.smoothing_trials)\n                path = self._elastic_smooth(path, obstacles, is_3d, self.elastic_passes)\n\n                L = self._path_length(path)\n                if L < c_best:\n                    c_best = L\n                    best_path = path\n                # early return with coherent edges\n                edges = []\n                for n in all_nodes:\n                    if n.parent is not None:\n                        edges.append((n.parent, n))\n                return PlannerResult(True, best_path, all_nodes, edges)\n\n        edges = []\n        for n in all_nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return PlannerResult(best_path is not None, best_path if best_path else [], all_nodes, edges)\n\n    # RNG and sampling\n    def _rand(self):\n        self._seed = (1664525 * self._seed + 1013904223) % (1 << 31)\n        return self._seed / float(1 << 31)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _uniform_free(self, obstacles, is_3d):\n        # single-shot uniform inside bounds; if inside obstacle, retry a few times then fallback\n        for _ in range(8):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._point_in_obs(p, obstacles, is_3d):\n                return p\n        # fallback to halton\n        return self._halton_sample()\n\n    def _halton(self, index, base):\n        f = 1.0\n        r = 0.0\n        i = index\n        while i > 0:\n            f *= 1.0 / base\n            r += f * (i % base)\n            i //= base\n        return r\n\n    def _halton_sample(self):\n        bases = [2, 3, 5]\n        idx = self._halton_idx\n        self._halton_idx += 1\n        coords = []\n        for d in range(self.dim):\n            u = self._halton(idx, bases[d])\n            coords.append(u * self.bounds[d])\n        return tuple(coords)\n\n    def _ellipse_accept_sample(self, a, b, c_best, tries):\n        if c_best == float('inf'):\n            return self._halton_sample()\n        for _ in range(tries):\n            p = self._halton_sample()\n            if self._dist(p, a) + self._dist(p, b) <= c_best + 1e-9:\n                return p\n        return self._halton_sample()\n\n    def _corridor_sample(self, a, b, width, obstacles, is_3d):\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n        if self.dim == 2:\n            # sample inside circle radius = width\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy))\n                    if not self._point_in_obs(p, obstacles, is_3d):\n                        return p\n        else:\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._point_in_obs(p, obstacles, is_3d):\n                        return p\n        return self._uniform_free(obstacles, is_3d)\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5 if s > 0.0 else 0.0\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        out = []\n        for i in range(self.dim):\n            v = p[i]\n            if v < 0.0:\n                v = 0.0\n            if v > self.bounds[i]:\n                v = self.bounds[i]\n            out.append(v)\n        return tuple(out)\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Obstacles and collisions\n    def _point_in_obs(self, p, obstacles, is_3d):\n        if is_3d:\n            x, y, z = p\n            for o in obstacles:\n                ox, oy, oz, w, h, d = o\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n        else:\n            x, y = p\n            for o in obstacles:\n                ox, oy, w, h = o\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        q = self._cache_bin\n        if self.dim == 3:\n            qa = (int(a[0] / q + 0.5), int(a[1] / q + 0.5), int(a[2] / q + 0.5))\n            qb = (int(b[0] / q + 0.5), int(b[1] / q + 0.5), int(b[2] / q + 0.5))\n        else:\n            qa = (int(a[0] / q + 0.5), int(a[1] / q + 0.5))\n            qb = (int(b[0] / q + 0.5), int(b[1] / q + 0.5))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        key = self._edge_key(a, b)\n        state = self._edge_cache.get(key)\n        if state is not None:\n            return state == 1\n        # broadphase AABB overlap then slab intersection\n        blocked = False\n        if is_3d:\n            ax, ay, az = a\n            bx, by, bz = b\n            minx = ax if ax < bx else bx\n            maxx = ax if ax > bx else bx\n            miny = ay if ay < by else by\n            maxy = ay if ay > by else by\n            minz = az if az < bz else bz\n            maxz = az if az > bz else bz\n            for box in obstacles:\n                ox, oy, oz, w, h, d = box\n                bx0, bx1 = ox, ox + w\n                by0, by1 = oy, oy + h\n                bz0, bz1 = oz, oz + d\n                if maxx < bx0 or bx1 < minx or maxy < by0 or by1 < miny or maxz < bz0 or bz1 < minz:\n                    continue\n                if self._seg_box_intersect_3d(a, b, box):\n                    blocked = True\n                    break\n        else:\n            ax, ay = a\n            bx, by = b\n            minx = ax if ax < bx else bx\n            maxx = ax if ax > bx else bx\n            miny = ay if ay < by else by\n            maxy = ay if ay > by else by\n            for box in obstacles:\n                ox, oy, w, h = box\n                bx0, bx1 = ox, ox + w\n                by0, by1 = oy, oy + h\n                if maxx < bx0 or bx1 < minx or maxy < by0 or by1 < miny:\n                    continue\n                if self._seg_box_intersect_2d(a, b, box):\n                    blocked = True\n                    break\n        self._edge_cache[key] = 1 if blocked else 2\n        if len(self._edge_cache) > self.edge_cache_max:\n            self._prune_edge_cache()\n        return blocked\n\n    def _prune_edge_cache(self):\n        # delete half in FIFO-ish order\n        to_del = []\n        c = 0\n        for k in self._edge_cache:\n            if (c % 2) == 0:\n                to_del.append(k)\n            c += 1\n            if len(to_del) >= self.edge_cache_max // 2:\n                break\n        for k in to_del:\n            try:\n                del self._edge_cache[k]\n            except:\n                pass\n\n    def _seg_box_intersect_2d(self, a, b, box):\n        x, y, w, h = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        ax, ay = a\n        bx, by = b\n        dx = bx - ax\n        dy = by - ay\n        tmin, tmax = 0.0, 1.0\n\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            t1 = (minx - ax) * inv\n            t2 = (maxx - ax) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            t1 = (miny - ay) * inv\n            t2 = (maxy - ay) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    def _seg_box_intersect_3d(self, a, b, box):\n        x, y, z, w, h, d = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        minz, maxz = z, z + d\n        ax, ay, az = a\n        bx, by, bz = b\n        dx = bx - ax\n        dy = by - ay\n        dz = bz - az\n        tmin, tmax = 0.0, 1.0\n\n        # X\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            t1 = (minx - ax) * inv\n            t2 = (maxx - ax) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        # Y\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            t1 = (miny - ay) * inv\n            t2 = (maxy - ay) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        # Z\n        if dz == 0.0:\n            if az < minz or az > maxz:\n                return False\n        else:\n            inv = 1.0 / dz\n            t1 = (minz - az) * inv\n            t2 = (maxz - az) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    # Spatial hashing\n    def _grid_key(self, pos):\n        if self.dim == 3:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        else:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, nodes, anchors, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 3):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # anchor fallback\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        # final fallback limited scan\n        if best is None and nodes:\n            step = max(1, len(nodes) // min(96, len(nodes)))\n            for i in range(0, len(nodes), step):\n                n = nodes[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _k_nearest_nodes(self, grid, pos, kcap):\n        key = self._grid_key(pos)\n        ring = 0\n        items = []\n        while len(items) < kcap and ring <= 3:\n            cand = self._collect_ring(grid, key, ring)\n            for n in cand:\n                items.append((self._dist(n.position, pos), n))\n            ring += 1\n        if not items:\n            return []\n        items.sort(key=lambda x: x[0])\n        res = []\n        seen = set()\n        for d, n in items:\n            if n in seen:\n                continue\n            seen.add(n)\n            res.append(n)\n            if len(res) >= kcap:\n                break\n        return res\n\n    def _exists_close(self, grid, pos, radius):\n        cand = self._collect_ring(grid, self._grid_key(pos), 1)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Parent selection and local rewiring\n    def _choose_parent(self, new_pos, fallback, neighbors, obstacles, is_3d):\n        beta = self.beta_angle * max(1.0, self.step_size)\n        best_p = None\n        best_eff = float('inf')\n        best_cost = float('inf')\n\n        def angle_penalty(p):\n            if p is None or p.parent is None:\n                return 0.0\n            a = p.parent.position\n            b = p.position\n            c = new_pos\n            v1 = tuple(b[i] - a[i] for i in range(self.dim))\n            v2 = tuple(c[i] - b[i] for i in range(self.dim))\n            n1 = 0.0\n            n2 = 0.0\n            dot = 0.0\n            for i in range(self.dim):\n                n1 += v1[i] * v1[i]\n                n2 += v2[i] * v2[i]\n                dot += v1[i] * v2[i]\n            if n1 <= 1e-12 or n2 <= 1e-12:\n                return 0.0\n            cosang = dot / ((n1 ** 0.5) * (n2 ** 0.5))\n            if cosang > 1.0:\n                cosang = 1.0\n            if cosang < -1.0:\n                cosang = -1.0\n            return (1.0 - cosang)\n\n        cand = [fallback] + neighbors\n        seen = set()\n        for p in cand:\n            if p in seen:\n                continue\n            seen.add(p)\n            if self._edge_blocked(p.position, new_pos, obstacles, is_3d):\n                continue\n            g = p.cost + self._dist(p.position, new_pos)\n            eff = g + beta * angle_penalty(p)\n            if eff < best_eff - 1e-12 or (abs(eff - best_eff) <= 1e-12 and g < best_cost - 1e-12):\n                best_eff = eff\n                best_cost = g\n                best_p = p\n\n        if best_p is None:\n            return None, float('inf')\n        return best_p, best_cost\n\n    def _rewire_local(self, new_node, neighbors, obstacles, is_3d, cap_updates=64):\n        # local, bounded subtree cost propagation to avoid O(subtree) worst-case\n        updates_left = cap_updates\n        for m in neighbors:\n            if m is new_node or m is new_node.parent:\n                continue\n            alt = new_node.cost + self._dist(new_node.position, m.position)\n            if alt + 1e-12 < m.cost:\n                if not self._edge_blocked(new_node.position, m.position, obstacles, is_3d):\n                    delta = alt - m.cost\n                    m.attach(new_node)\n                    m.cost = alt\n                    # bounded propagation\n                    if delta != 0.0 and updates_left > 0:\n                        stack = [m]\n                        while stack and updates_left > 0:\n                            cur = stack.pop()\n                            for ch in cur.children:\n                                ch.cost += delta\n                                updates_left -= 1\n                                if updates_left <= 0:\n                                    break\n                                stack.append(ch)\n\n    # Heuristic gate interpolation\n    def _interp_gate(self, it):\n        t = 0.0\n        if self.max_iter > 1:\n            t = min(1.0, max(0.0, it / float(self.max_iter - 1)))\n        return self.heur_gate_init + (self.heur_gate_final - self.heur_gate_init) * t\n\n    # Path helpers and post-processing\n    def _path_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        out.reverse()\n        return out\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _vis_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(pruned[-1], path[j], obstacles, is_3d):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut(self, path, obstacles, is_3d, trials):\n        if not path or len(path) < 3:\n            return list(path)\n        pts = list(path)\n        n = len(pts)\n        for _ in range(trials):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts\n\n    def _elastic_smooth(self, path, obstacles, is_3d, passes):\n        if not path or len(path) < 3:\n            return list(path)\n        pts = list(path)\n        alpha = 0.35\n        lam_curv = 0.25\n        for _ in range(passes):\n            changed = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                b = pts[i]\n                c = pts[i + 1]\n                # curvature proxy (1 - cos theta)\n                v1 = tuple(b[d] - a[d] for d in range(self.dim))\n                v2 = tuple(c[d] - b[d] for d in range(self.dim))\n                n1 = 0.0\n                n2 = 0.0\n                dot = 0.0\n                for d in range(self.dim):\n                    n1 += v1[d] * v1[d]\n                    n2 += v2[d] * v2[d]\n                    dot += v1[d] * v2[d]\n                curv = 0.0\n                if n1 > 1e-12 and n2 > 1e-12:\n                    cs = dot / ((n1 ** 0.5) * (n2 ** 0.5))\n                    if cs > 1.0:\n                        cs = 1.0\n                    if cs < -1.0:\n                        cs = -1.0\n                    curv = (1.0 - cs)\n\n                # elastic update\n                newp = tuple(b[d] - alpha * (a[d] - 2.0 * b[d] + c[d]) for d in range(self.dim))\n                newp = self._clamp(newp)\n                if self._point_in_obs(newp, obstacles, is_3d):\n                    continue\n                if self._edge_blocked(a, newp, obstacles, is_3d) or self._edge_blocked(newp, c, obstacles, is_3d):\n                    continue\n\n                old_len = self._dist(a, b) + self._dist(b, c)\n                new_len = self._dist(a, newp) + self._dist(newp, c)\n                # accept if combined length+curvature is not worse\n                if new_len + lam_curv * curv <= old_len + lam_curv * curv + 1e-9 or new_len <= old_len - 1e-6:\n                    pts[i] = newp\n                    changed = True\n            if not changed:\n                break\n        return pts",
                "objective": -16.97025,
                "time_improvement": 5.0,
                "length_improvement": 7.0,
                "smoothness_improvement": 2192.0,
                "node_improvement": 73.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.052840685844421385,
                        "num_nodes_avg": 197.0,
                        "path_length_avg": 203.51716340437997,
                        "smoothness_avg": 0.03564516535700144,
                        "success_improvement": 0.0,
                        "time_improvement": -110.06737172548581,
                        "node_improvement": 50.390329891714934,
                        "length_improvement": -11.550982197767924,
                        "smoothness_improvement": 457.9242425525507,
                        "objective_score": -37.661179623543745
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.04449014663696289,
                        "num_nodes_avg": 224.0,
                        "path_length_avg": 235.11380675537984,
                        "smoothness_avg": 0.18980390385986798,
                        "success_improvement": 0.0,
                        "time_improvement": 72.23022437085577,
                        "node_improvement": 84.9492709803131,
                        "length_improvement": 21.51224392935409,
                        "smoothness_improvement": 4783.791156540485,
                        "objective_score": 58.495369451571605
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.02237374782562256,
                        "num_nodes_avg": 117.0,
                        "path_length_avg": 132.46071930860833,
                        "smoothness_avg": 0.11286258911854459,
                        "success_improvement": 0.0,
                        "time_improvement": 53.943333627806076,
                        "node_improvement": 85.12396694214877,
                        "length_improvement": 12.025897336861902,
                        "smoothness_improvement": 1335.603802938122,
                        "objective_score": 30.076557505149573
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "LION-ABiRT*: Lazy Informed Ordered-Neighbors Anytime Bi-directional RRT*. It alternates growth of two trees using ring-hash nearest lookup, adaptive step steering, and lazy parent selection that orders k-nearest candidates by a cost+smoothness surrogate and collision-checks only until a feasible parent is found. A dynamic A*-like f=g+h gate with informed (elliptical) and corridor-biased sampling focuses search once an incumbent path exists. Local, bounded rewiring improves costs with capped subtree propagation. Cross-tree connection ranks opposite-tree candidates by estimated total cost and tests only the best few, with short micro-bridges when needed. On success, a light visibility prune, targeted shortcuts, and curvature-aware elastic smoothing produce a short, smooth path. It warm-starts from a previously valid solution when possible and returns the first improved feasible path to reduce time.",
            "planning_mechanism": "Mechanism: Initialize two trees at start/goal. Per iteration: sample (goal/informed-ellipse/corridor/low-discrepancy/uniform), find a near node via ring-hash, adaptively steer with decreasing step until a valid edge is found, gate by f-bound, and lazily choose a smooth, low-cost parent among ordered k-neighbors with a single successful collision test. Insert, then locally rewire k neighbors with capped cost propagation. Try to connect to the opposite tree by testing the top-ranked beam candidates; otherwise, insert a few guided micro-steps from the other tree toward the new node and retry. When bridged, assemble, prune, shortcut around largest bends, smooth elastically under collision and bounds, and return.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = set()\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.add(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_min=3.0,\n                 step_max=7.0,\n                 neighbor_k=14,\n                 ring_max=2,\n                 goal_bias=0.18,\n                 informed_bias=0.65,\n                 corridor_bias=0.55,\n                 beam_k=8,\n                 connect_steps=3,\n                 grid_cell_factor=1.10,\n                 gate_init=1.25,\n                 gate_final=1.05,\n                 angle_weight=0.035,\n                 dupe_ratio_far=0.50,\n                 dupe_ratio_near=0.22,\n                 anchor_stride=16,\n                 smoothing_trials=60,\n                 smooth_passes=3,\n                 edge_cache_max=20000):\n        self.max_iter = max_iter\n        self.step_min = step_min\n        self.step_max = step_max\n        self.neighbor_k = neighbor_k\n        self.ring_max = ring_max\n        self.goal_bias = goal_bias\n        self.informed_bias = informed_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.connect_steps = connect_steps\n        self.grid_cell_factor = grid_cell_factor\n        self.gate_init = gate_init\n        self.gate_final = gate_final\n        self.angle_weight = angle_weight\n        self.dupe_ratio_far = dupe_ratio_far\n        self.dupe_ratio_near = dupe_ratio_near\n        self.anchor_stride = max(1, int(anchor_stride))\n        self.smoothing_trials = smoothing_trials\n        self.smooth_passes = smooth_passes\n        self.edge_cache_max = max(2000, int(edge_cache_max))\n\n        # runtime state\n        self.dim = 2\n        self.bounds = None\n        self.cell = 1.0\n        self._seed = 7\n        self._halton_idx = 1\n        self._edge_cache = {}\n        self._cache_bin = 1.0\n        self.prev_path = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._point_in_obs(start, obstacles, is_3d) or self._point_in_obs(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # warm-start with previous solution if still valid\n        if self.prev_path and self._same_ends(self.prev_path, start, goal):\n            if self._path_free(self.prev_path, obstacles, is_3d):\n                nodes = []\n                edges = []\n                s = Node(start, None, 0.0)\n                nodes.append(s)\n                last = s\n                cost = 0.0\n                for i in range(1, len(self.prev_path)):\n                    p = self.prev_path[i]\n                    n = Node(p, None, 0.0)\n                    cost += self._dist(last.position, p)\n                    n.cost = cost\n                    n.attach(last)\n                    nodes.append(n)\n                    last = n\n                for n in nodes:\n                    if n.parent is not None:\n                        edges.append((n.parent, n))\n                return PlannerResult(True, list(self.prev_path), nodes, edges)\n\n        # direct LOS early exit\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.add(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            path = [start, goal]\n            self.prev_path = path\n            return PlannerResult(True, path, nodes, edges)\n\n        # setup discretizations and caches\n        self.cell = max(1.0, self.step_max * self.grid_cell_factor)\n        self._seed = 7\n        self._halton_idx = 1\n        self._edge_cache = {}\n        self._cache_bin = max(0.5, 0.1 * self.step_max)\n\n        # init trees\n        a_root = Node(start, None, 0.0)\n        b_root = Node(goal, None, 0.0)\n        tree_a, tree_b = [a_root], [b_root]\n        grid_a, grid_b = {}, {}\n        anchors_a, anchors_b = [a_root], [b_root]\n        self._grid_add(grid_a, a_root)\n        self._grid_add(grid_b, b_root)\n        all_nodes = [a_root, b_root]\n\n        best_path = None\n        c_best = float('inf')\n        sg_dist = self._dist(start, goal)\n\n        for it in range(self.max_iter):\n            from_start = (it % 2 == 0)\n            if from_start:\n                tree_x, tree_y = tree_a, tree_b\n                grid_x, grid_y = grid_a, grid_b\n                anchors_x, anchors_y = anchors_a, anchors_b\n                root_x, root_y = a_root, b_root\n                attractor = goal\n            else:\n                tree_x, tree_y = tree_b, tree_a\n                grid_x, grid_y = grid_b, grid_a\n                anchors_x, anchors_y = anchors_b, anchors_a\n                root_x, root_y = b_root, a_root\n                attractor = start\n\n            # sample\n            r = self._rand()\n            if r < self.goal_bias:\n                x_rand = attractor\n            else:\n                used_informed = (c_best < float('inf') and self._rand() < self.informed_bias)\n                if used_informed:\n                    x_rand = self._ellipse_sample(root_x.position, root_y.position, c_best, 8)\n                else:\n                    if self._rand() < self.corridor_bias:\n                        width = max(self.step_max, 0.2 * (sg_dist if c_best == float('inf') else c_best))\n                        x_rand = self._corridor_sample(root_x.position, root_y.position, width, obstacles, is_3d)\n                    else:\n                        if self._rand() < 0.6:\n                            x_rand = self._halton_sample()\n                        else:\n                            x_rand = self._uniform_free(obstacles, is_3d)\n\n            # nearest\n            n_near = self._nearest_hashed(grid_x, tree_x, anchors_x, x_rand)\n            if n_near is None:\n                continue\n\n            # adaptive steer (shortening until feasible)\n            tried = False\n            x_new_pos = None\n            for scale in (1.1, 1.0, 0.7, 0.45):\n                step = max(self.step_min, min(self.step_max, scale * self.step_max))\n                tgt = self._steer(n_near.position, x_rand, step)\n                if not self._in_bounds(tgt) or self._point_in_obs(tgt, obstacles, is_3d):\n                    continue\n                tried = True\n                if not self._edge_blocked(n_near.position, tgt, obstacles, is_3d):\n                    x_new_pos = tgt\n                    break\n            if not tried or x_new_pos is None:\n                continue\n\n            # heuristic gate\n            if c_best < float('inf'):\n                g_tent = n_near.cost + self._dist(n_near.position, x_new_pos)\n                f_tent = g_tent + self._dist(x_new_pos, root_y.position)\n                if f_tent >= self._interp_gate(it) * c_best:\n                    continue\n\n            # per-cell throttle via duplicate suppression radius\n            kcell = self._grid_key(x_new_pos)\n            near_ratio = self.dupe_ratio_near if c_best < float('inf') else self.dupe_ratio_far\n            if self._exists_close(grid_x, x_new_pos, self.step_max * near_ratio):\n                continue\n\n            # choose parent lazily among ordered neighbors\n            neigh = self._k_nearest_nodes(grid_x, x_new_pos, self.neighbor_k)\n            parent, new_cost = self._lazy_choose_parent(x_new_pos, n_near, neigh, obstacles, is_3d, attractor)\n\n            if parent is None:\n                continue\n\n            # final checks before insertion\n            if self._point_in_obs(x_new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked(parent.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            # insert\n            x_new = Node(x_new_pos, None, new_cost)\n            x_new.attach(parent)\n            tree_x.append(x_new)\n            all_nodes.append(x_new)\n            self._grid_add(grid_x, x_new)\n            if len(tree_x) % self.anchor_stride == 0:\n                anchors_x.append(x_new)\n\n            # local rewiring with capped propagation\n            self._rewire_local(x_new, neigh, obstacles, is_3d, cap_updates=48)\n\n            # attempt to connect to other tree\n            bridge = None\n            beam = self._k_nearest_nodes(grid_y, x_new.position, min(self.beam_k, max(1, len(tree_y))))\n            # rank beam by estimated total cost\n            scored = []\n            for cand in beam:\n                est = x_new.cost + self._dist(x_new.position, cand.position) + cand.cost\n                scored.append((est, cand))\n            scored.sort(key=lambda t: t[0])\n\n            best_total = float('inf')\n            best_cand = None\n            for _, cand in scored:\n                if not self._edge_blocked(x_new.position, cand.position, obstacles, is_3d):\n                    total = x_new.cost + self._dist(x_new.position, cand.position) + cand.cost\n                    if total < best_total:\n                        best_total = total\n                        best_cand = cand\n                        bridge = cand\n                        break  # accept first feasible best-ranked\n            # guided micro-bridge from other tree if no direct bridge\n            if bridge is None and scored:\n                cur = scored[0][1]\n                steps = 0\n                while steps < self.connect_steps and bridge is None:\n                    step_try = self._steer(cur.position, x_new.position, max(self.step_min, 0.8 * self.step_max))\n                    if not self._in_bounds(step_try) or self._point_in_obs(step_try, obstacles, is_3d):\n                        break\n                    # heuristic gate on other side\n                    if c_best < float('inf'):\n                        g2 = cur.cost + self._dist(cur.position, step_try)\n                        f2 = g2 + self._dist(step_try, root_x.position)\n                        if f2 >= self._interp_gate(it) * c_best:\n                            break\n                    # dupe suppression for other side\n                    if self._exists_close(grid_y, step_try, self.step_max * near_ratio):\n                        break\n                    neigh_b = self._k_nearest_nodes(grid_y, step_try, self.neighbor_k)\n                    p_b, c_b = self._lazy_choose_parent(step_try, cur, neigh_b, obstacles, is_3d, x_new.position)\n                    if p_b is None:\n                        break\n                    if self._point_in_obs(step_try, obstacles, is_3d) or self._edge_blocked(p_b.position, step_try, obstacles, is_3d):\n                        break\n                    nxt = Node(step_try, None, c_b)\n                    nxt.attach(p_b)\n                    tree_y.append(nxt)\n                    all_nodes.append(nxt)\n                    self._grid_add(grid_y, nxt)\n                    if len(tree_y) % self.anchor_stride == 0:\n                        anchors_y.append(nxt)\n                    self._rewire_local(nxt, neigh_b, obstacles, is_3d, cap_updates=32)\n                    if not self._edge_blocked(nxt.position, x_new.position, obstacles, is_3d):\n                        bridge = nxt\n                        break\n                    cur = nxt\n                    steps += 1\n\n            if bridge is not None:\n                # assemble path\n                pa = self._trace_positions(x_new)\n                pb = self._trace_positions(bridge)\n                if from_start:\n                    path = pa + list(reversed(pb))\n                else:\n                    path = pb + list(reversed(pa))\n                # post-process\n                path = self._vis_prune(path, obstacles, is_3d)\n                path = self._shortcut_curvature_focused(path, obstacles, is_3d, self.smoothing_trials)\n                path = self._elastic_smooth(path, obstacles, is_3d, self.smooth_passes)\n                L = self._path_length(path)\n                if L < c_best:\n                    c_best = L\n                    best_path = path\n                # build coherent edges\n                edges = []\n                for n in all_nodes:\n                    if n.parent is not None:\n                        edges.append((n.parent, n))\n                self.prev_path = best_path\n                return PlannerResult(True, best_path, all_nodes, edges)\n\n        edges = []\n        for n in all_nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        ok = best_path is not None\n        if ok:\n            self.prev_path = best_path\n        return PlannerResult(ok, best_path if ok else [], all_nodes, edges)\n\n    # RNG / sampling\n    def _rand(self):\n        self._seed = (1103515245 * self._seed + 12345) % (1 << 31)\n        return self._seed / float(1 << 31)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _halton(self, index, base):\n        f = 1.0\n        r = 0.0\n        i = index\n        while i > 0:\n            f *= 1.0 / base\n            r += f * (i % base)\n            i //= base\n        return r\n\n    def _halton_sample(self):\n        bases = [2, 3, 5]\n        idx = self._halton_idx\n        self._halton_idx += 1\n        coords = []\n        for d in range(self.dim):\n            u = self._halton(idx, bases[d])\n            coords.append(u * self.bounds[d])\n        return tuple(coords)\n\n    def _uniform_free(self, obstacles, is_3d):\n        for _ in range(8):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._point_in_obs(p, obstacles, is_3d):\n                return p\n        return self._halton_sample()\n\n    def _ellipse_sample(self, a, b, c_best, tries):\n        if c_best == float('inf'):\n            return self._halton_sample()\n        for _ in range(tries):\n            p = self._halton_sample()\n            if self._dist(p, a) + self._dist(p, b) <= c_best + 1e-9:\n                return p\n        return self._halton_sample()\n\n    def _corridor_sample(self, a, b, width, obstacles, is_3d):\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n        if self.dim == 2:\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy))\n                    if not self._point_in_obs(p, obstacles, is_3d):\n                        return p\n        else:\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._point_in_obs(p, obstacles, is_3d):\n                        return p\n        return self._uniform_free(obstacles, is_3d)\n\n    # Geometry / utilities\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5 if s > 0.0 else 0.0\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        out = []\n        for i in range(self.dim):\n            v = p[i]\n            if v < 0.0:\n                v = 0.0\n            if v > self.bounds[i]:\n                v = self.bounds[i]\n            out.append(v)\n        return tuple(out)\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _same_ends(self, path, start, goal):\n        if not path or len(path) < 2:\n            return False\n        return path[0] == start and path[-1] == goal\n\n    # Obstacles/collisions\n    def _point_in_obs(self, p, obstacles, is_3d):\n        if is_3d:\n            x, y, z = p\n            for o in obstacles:\n                ox, oy, oz, w, h, d = o\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n        else:\n            x, y = p\n            for o in obstacles:\n                ox, oy, w, h = o\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        q = self._cache_bin\n        if self.dim == 3:\n            qa = (int(a[0] / q + 0.5), int(a[1] / q + 0.5), int(a[2] / q + 0.5))\n            qb = (int(b[0] / q + 0.5), int(b[1] / q + 0.5), int(b[2] / q + 0.5))\n        else:\n            qa = (int(a[0] / q + 0.5), int(a[1] / q + 0.5))\n            qb = (int(b[0] / q + 0.5), int(b[1] / q + 0.5))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        key = self._edge_key(a, b)\n        state = self._edge_cache.get(key)\n        if state is not None:\n            return state == 1\n        blocked = False\n        if is_3d:\n            ax, ay, az = a\n            bx, by, bz = b\n            minx = ax if ax < bx else bx\n            maxx = ax if ax > bx else bx\n            miny = ay if ay < by else by\n            maxy = ay if ay > by else by\n            minz = az if az < bz else bz\n            maxz = az if az > bz else bz\n            for box in obstacles:\n                ox, oy, oz, w, h, d = box\n                bx0, bx1 = ox, ox + w\n                by0, by1 = oy, oy + h\n                bz0, bz1 = oz, oz + d\n                if maxx < bx0 or bx1 < minx or maxy < by0 or by1 < miny or maxz < bz0 or bz1 < minz:\n                    continue\n                if self._seg_box_intersect_3d(a, b, box):\n                    blocked = True\n                    break\n        else:\n            ax, ay = a\n            bx, by = b\n            minx = ax if ax < bx else bx\n            maxx = ax if ax > bx else bx\n            miny = ay if ay < by else by\n            maxy = ay if ay > by else by\n            for box in obstacles:\n                ox, oy, w, h = box\n                bx0, bx1 = ox, ox + w\n                by0, by1 = oy, oy + h\n                if maxx < bx0 or bx1 < minx or maxy < by0 or by1 < miny:\n                    continue\n                if self._seg_box_intersect_2d(a, b, box):\n                    blocked = True\n                    break\n        self._edge_cache[key] = 1 if blocked else 2\n        if len(self._edge_cache) > self.edge_cache_max:\n            self._prune_edge_cache()\n        return blocked\n\n    def _prune_edge_cache(self):\n        # remove roughly half of entries by skipping every other key\n        to_del = []\n        c = 0\n        for k in self._edge_cache:\n            if (c & 1) == 0:\n                to_del.append(k)\n            c += 1\n            if len(to_del) >= self.edge_cache_max // 2:\n                break\n        for k in to_del:\n            try:\n                del self._edge_cache[k]\n            except:\n                pass\n\n    def _seg_box_intersect_2d(self, a, b, box):\n        x, y, w, h = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        ax, ay = a\n        bx, by = b\n        dx = bx - ax\n        dy = by - ay\n        tmin, tmax = 0.0, 1.0\n\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            t1 = (minx - ax) * inv\n            t2 = (maxx - ax) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            t1 = (miny - ay) * inv\n            t2 = (maxy - ay) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    def _seg_box_intersect_3d(self, a, b, box):\n        x, y, z, w, h, d = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        minz, maxz = z, z + d\n        ax, ay, az = a\n        bx, by, bz = b\n        dx = bx - ax\n        dy = by - ay\n        dz = bz - az\n        tmin, tmax = 0.0, 1.0\n\n        # X\n        if dx == 0.0:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            t1 = (minx - ax) * inv\n            t2 = (maxx - ax) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        # Y\n        if dy == 0.0:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            t1 = (miny - ay) * inv\n            t2 = (maxy - ay) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        # Z\n        if dz == 0.0:\n            if az < minz or az > maxz:\n                return False\n        else:\n            inv = 1.0 / dz\n            t1 = (minz - az) * inv\n            t2 = (maxz - az) * inv\n            if t1 > t2:\n                t1, t2 = t2, t1\n            if t1 > tmin:\n                tmin = t1\n            if t2 < tmax:\n                tmax = t2\n            if tmin > tmax:\n                return False\n\n        return tmax >= 0.0 and tmin <= 1.0\n\n    def _path_free(self, path, obstacles, is_3d):\n        if not path or len(path) < 2:\n            return False\n        for p in path:\n            if not self._in_bounds(p) or self._point_in_obs(p, obstacles, is_3d):\n                return False\n        for i in range(1, len(path)):\n            if self._edge_blocked(path[i - 1], path[i], obstacles, is_3d):\n                return False\n        return True\n\n    # Spatial hashing\n    def _grid_key(self, pos):\n        if self.dim == 3:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        else:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, nodes, anchors, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.ring_max + 1):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # anchor fallback\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        # lightweight strided scan fallback\n        if best is None and nodes:\n            stride = max(1, len(nodes) // min(64, len(nodes)))\n            for i in range(0, len(nodes), stride):\n                n = nodes[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _k_nearest_nodes(self, grid, pos, kcap):\n        key = self._grid_key(pos)\n        items = []\n        ring = 0\n        while len(items) < kcap and ring <= self.ring_max:\n            cand = self._collect_ring(grid, key, ring)\n            for n in cand:\n                items.append((self._dist(n.position, pos), n))\n            ring += 1\n        if not items:\n            return []\n        items.sort(key=lambda x: x[0])\n        res = []\n        seen = set()\n        for d, n in items:\n            if n in seen:\n                continue\n            seen.add(n)\n            res.append(n)\n            if len(res) >= kcap:\n                break\n        return res\n\n    def _exists_close(self, grid, pos, radius):\n        cand = self._collect_ring(grid, self._grid_key(pos), 1)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Parent selection, rewiring\n    def _angle_penalty(self, parent, new_pos):\n        if parent is None or parent.parent is None:\n            return 0.0\n        a = parent.parent.position\n        b = parent.position\n        c = new_pos\n        v1 = tuple(b[i] - a[i] for i in range(self.dim))\n        v2 = tuple(c[i] - b[i] for i in range(self.dim))\n        n1 = 0.0\n        n2 = 0.0\n        dot = 0.0\n        for i in range(self.dim):\n            n1 += v1[i] * v1[i]\n            n2 += v2[i] * v2[i]\n            dot += v1[i] * v2[i]\n        if n1 <= 1e-12 or n2 <= 1e-12:\n            return 0.0\n        cs = dot / ((n1 ** 0.5) * (n2 ** 0.5))\n        if cs > 1.0:\n            cs = 1.0\n        if cs < -1.0:\n            cs = -1.0\n        return (1.0 - cs)\n\n    def _lazy_choose_parent(self, new_pos, fallback, neighbors, obstacles, is_3d, attractor):\n        # order candidates by g + dist + smoothness surrogate to reduce collision checks\n        beta = self.angle_weight * max(1.0, self.step_max)\n        cand = [fallback] + neighbors\n        scored = []\n        seen = set()\n        for p in cand:\n            if p in seen:\n                continue\n            seen.add(p)\n            d = self._dist(p.position, new_pos)\n            g = p.cost + d\n            smooth = beta * self._angle_penalty(p, new_pos)\n            # small bias toward pointing to attractor\n            to_attr = 0.0\n            if attractor is not None:\n                to_attr = 0.02 * self._dist(new_pos, attractor)\n            scored.append((g + smooth + to_attr, p, g))\n        scored.sort(key=lambda t: t[0])\n        for _, p, g in scored:\n            if not self._edge_blocked(p.position, new_pos, obstacles, is_3d):\n                return p, g\n        return None, float('inf')\n\n    def _propagate_delta(self, node, delta, cap_updates):\n        # bounded subtree cost propagation\n        stack = [node]\n        updates = 0\n        while stack and updates < cap_updates:\n            cur = stack.pop()\n            for ch in list(cur.children):\n                ch.cost += delta\n                updates += 1\n                if updates >= cap_updates:\n                    break\n                stack.append(ch)\n\n    def _rewire_local(self, new_node, neighbors, obstacles, is_3d, cap_updates=48):\n        updates_left = cap_updates\n        for m in neighbors:\n            if m is new_node or m is new_node.parent:\n                continue\n            alt = new_node.cost + self._dist(new_node.position, m.position)\n            if alt + 1e-12 < m.cost:\n                if not self._edge_blocked(new_node.position, m.position, obstacles, is_3d):\n                    delta = alt - m.cost\n                    old_parent = m.parent\n                    m.attach(new_node)\n                    m.cost = alt\n                    if delta != 0.0 and updates_left > 0:\n                        used_before = cap_updates - updates_left\n                        self._propagate_delta(m, delta, updates_left)\n                        used_after = cap_updates - updates_left\n                        updates_left -= max(1, used_after - used_before)\n\n    # Heuristic gate schedule\n    def _interp_gate(self, it):\n        if self.max_iter <= 1:\n            return self.gate_final\n        t = min(1.0, max(0.0, it / float(self.max_iter - 1)))\n        return self.gate_init + (self.gate_final - self.gate_init) * t\n\n    # Path helpers and post-processing\n    def _trace_positions(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        out.reverse()\n        return out\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _vis_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(pruned[-1], path[j], obstacles, is_3d):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut_curvature_focused(self, path, obstacles, is_3d, trials):\n        if not path or len(path) < 3:\n            return list(path)\n        pts = list(path)\n        n = len(pts)\n        for _ in range(trials):\n            if n < 3:\n                break\n            # bias toward larger bends\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            # prefer skipping around corners\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts\n\n    def _elastic_smooth(self, path, obstacles, is_3d, passes):\n        if not path or len(path) < 3:\n            return list(path)\n        pts = list(path)\n        alpha = 0.32\n        lam_curv = 0.30\n        for _ in range(passes):\n            changed = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                b = pts[i]\n                c = pts[i + 1]\n                # curvature proxy\n                v1 = tuple(b[d] - a[d] for d in range(self.dim))\n                v2 = tuple(c[d] - b[d] for d in range(self.dim))\n                n1 = 0.0\n                n2 = 0.0\n                dot = 0.0\n                for d in range(self.dim):\n                    n1 += v1[d] * v1[d]\n                    n2 += v2[d] * v2[d]\n                    dot += v1[d] * v2[d]\n                curv = 0.0\n                if n1 > 1e-12 and n2 > 1e-12:\n                    cs = dot / ((n1 ** 0.5) * (n2 ** 0.5))\n                    if cs > 1.0:\n                        cs = 1.0\n                    if cs < -1.0:\n                        cs = -1.0\n                    curv = (1.0 - cs)\n                # elastic update\n                newp = tuple(b[d] - alpha * (a[d] - 2.0 * b[d] + c[d]) for d in range(self.dim))\n                newp = self._clamp(newp)\n                if self._point_in_obs(newp, obstacles, is_3d):\n                    continue\n                if self._edge_blocked(a, newp, obstacles, is_3d) or self._edge_blocked(newp, c, obstacles, is_3d):\n                    continue\n                old_len = self._dist(a, b) + self._dist(b, c)\n                new_len = self._dist(a, newp) + self._dist(newp, c)\n                if new_len + lam_curv * curv <= old_len + lam_curv * curv + 1e-9 or new_len <= old_len - 1e-6:\n                    pts[i] = newp\n                    changed = True\n            if not changed:\n                break\n        return pts",
            "objective": -43.64906,
            "time_improvement": 86.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 1496.0,
            "node_improvement": 96.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007047319412231445,
                    "num_nodes_avg": 24.1,
                    "path_length_avg": 155.28141234263038,
                    "smoothness_avg": 0.03865255099982554,
                    "success_improvement": 0.0,
                    "time_improvement": 71.98348501765808,
                    "node_improvement": 93.93099974817426,
                    "length_improvement": 14.887797303565245,
                    "smoothness_improvement": 504.99635850519775,
                    "objective_score": 33.052705679962564
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.00686192512512207,
                    "num_nodes_avg": 27.8,
                    "path_length_avg": 236.27561310776304,
                    "smoothness_avg": 0.12059056051198921,
                    "success_improvement": 0.0,
                    "time_improvement": 95.71693654634275,
                    "node_improvement": 98.13209702344957,
                    "length_improvement": 21.124399528186895,
                    "smoothness_improvement": 3002.881979843398,
                    "objective_score": 56.404130580031946
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.004746818542480468,
                    "num_nodes_avg": 23.7,
                    "path_length_avg": 126.69003120079826,
                    "smoothness_avg": 0.08501065961584595,
                    "success_improvement": 0.0,
                    "time_improvement": 90.2286090089029,
                    "node_improvement": 96.98664971392243,
                    "length_improvement": 15.85851360743081,
                    "smoothness_improvement": 981.3293154793831,
                    "objective_score": 41.49033744452626
                }
            ],
            "success_rate": 1.0
        },
        "objective": 19.200000000000003,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Excessive collision checking during parent selection and cross-tree connection (testing many candidates before commit).\n   - Wide neighbor retrieval and sorting around queries, plus costly nearest fallbacks, increasing per-iteration overhead.\n   - Frequent failed connect attempts due to small beams and short micro-bridges, inflating expansion count.\n   - Heavy post-processing (many shortcut trials and smoothing passes) dominating tail latency.\n   - Coarse edge-cache quantization causing false \u201cblocked\u201d results and extra expansions.\n   - Rigid duplicate/throttling rules leading to wasted samples and skipped useful insertions."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Lazy, ordered parent selection that stops after the first feasible candidate, reducing edge collision checks.\n   - Ranked beam connection that tests only top candidates and accepts the first feasible bridge.\n   - Tighter neighborhood search (smaller ring/cap) and lighter nearest fallbacks to cut neighbor scans and sorting.\n   - Reduced post-processing effort (fewer shortcut trials and smoothing passes).\n   - Adaptive duplicate suppression (near/far radii) to avoid wasted iterations without over-throttling.\n   - Warm-start reuse of a previously valid path to bypass planning when possible.\n   - Finer edge-cache keying to avoid false rejections and the extra expansions they trigger.\n2. Expected mechanism of impact:\n   - Fewer expensive collision queries and smaller candidate sets lower per-iteration cost.\n   - Earlier, more reliable bridging cuts the number of growth iterations required to find a solution.\n   - Less aggressive smoothing/shortcutting shortens post-solve time.\n   - Better cache accuracy and duplicate handling prevent fruitless expansions, accelerating convergence and reducing total runtime."
        }
    },
    {
        "parents": [
            {
                "operator": "m1",
                "algorithm_description": "BLINK-IBiRRT-BC: Beam-Lazy Informed BiRRT-Connect with k-parent beam selection, ring-grid nearest, cached AABB edge checks, and short micro-bridges. It alternates trees, samples via ellipse/corridor/goal bias, lazily f-gates before collisions, attaches to the best of k neighbors (turn-aware), attempts bounded opposite-tree bridging, and returns a visibility-pruned, briefly-shortcutted path fast.",
                "planning_mechanism": "Alternate bidirectional growth with informed/corridor/goal-biased sampling. For each sample: ring-grid nearest \u2192 one-step steer \u2192 lazy f-gate \u2192 k-neighbor parent choice with cached edge validation \u2192 insert. Then try direct or few-step opposite-tree connect with the same checks. On first bridge: assemble, visibility-prune, bounded shortcut, return. Edge and node collisions are checked before every insertion/edge use; obstacle and edge queries are accelerated by a spatial hash and cache.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        pts = []\n        cur = self\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=6.0,\n        goal_bias=0.18,\n        corridor_bias=0.45,\n        informed_bias=0.6,\n        grid_cell_factor=1.4,\n        min_sep_factor=0.45,\n        ring_max=3,\n        k_parent=14,\n        neighbor_factor=2.2,\n        connect_steps=8,\n        heur_gate=1.02,\n        shortcut_trials=70\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.min_sep_factor = float(min_sep_factor)\n        self.ring_max = int(ring_max)\n        self.k_parent = int(k_parent)\n        self.neighbor_factor = float(neighbor_factor)\n        self.connect_steps = int(connect_steps)\n        self.heur_gate = float(heur_gate)\n        self.shortcut_trials = int(shortcut_trials)\n\n        self._seed = 146959810\n        self._edge_cache = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n        self._edge_cache = {}\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._seed_rng(self.start + self.goal)\n\n        # Build obstacle spatial hash\n        self.obs_cell = max(4.0, self.step_size * 1.6)\n        self._build_obs_grid()\n\n        # Node feasibility\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            s = Node(self.start, None, 0.0)\n            g = Node(self.goal, s, self._dist(self.start, self.goal))\n            s.add_child(g)\n            return PlannerResult(True, [self.start, self.goal], [s, g], [(s, g)])\n\n        # Derived params\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.4, self.step_size * self.min_sep_factor)\n        sg = self._dist(self.start, self.goal)\n        self.corridor_w = max(self.step_size * 1.25, 0.2 * sg)\n\n        # Trees and grids\n        nodes = []\n        edges = []\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, a_root)\n        self._grid_add(Gb, b_root)\n\n        c_best = float('inf')\n        best_path = None\n        informed = False\n\n        for it in range(self.max_iter):\n            grow_a = (it % 2 == 0)\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            root_x = a_root if grow_a else b_root\n            root_y = b_root if grow_a else a_root\n            attractor = self.goal if grow_a else self.start\n\n            # Sampling\n            target = None\n            r = self._rand()\n            if informed and r < self.informed_bias:\n                target = self._sample_ellipse(root_x.position, root_y.position, c_best)\n            if target is None:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    target = attractor\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    w = self.corridor_w if not informed or c_best == float('inf') else max(self.step_size, 0.15 * c_best)\n                    target = self._sample_corridor(root_x.position, root_y.position, w)\n                else:\n                    target = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n            target = self._clamp(target)\n            if self._point_blocked(target):\n                continue\n\n            # Nearest\n            near = self._nearest(G, T, target)\n            if near is None:\n                continue\n\n            # Steer\n            new_pos = self._steer(near.position, target, self.step_size)\n            if not self._in_bounds(new_pos) or self._point_blocked(new_pos):\n                continue\n            if self._near_duplicate(G, new_pos, self.min_sep):\n                continue\n\n            # Lazy f-gate\n            g_tent = near.cost + self._dist(near.position, new_pos)\n            if informed and c_best < float('inf'):\n                f_est = g_tent + self._dist(new_pos, root_y.position)\n                if f_est >= self.heur_gate * c_best:\n                    continue\n\n            # Beam parent selection among neighbors\n            radius = self._neighbor_radius(len(T))\n            neigh = self._neighbors(G, new_pos, radius, self.k_parent)\n            if near not in neigh:\n                neigh.append(near)\n            parent, new_cost = self._choose_parent(new_pos, neigh)\n            if parent is None:\n                continue\n\n            # Mandatory checks before insertion\n            if self._point_blocked(new_pos):\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            T.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(G, new_node)\n\n            # Try connect to opposite tree\n            bridged = self._try_connect(new_node, Topp, Gopp, root_x, c_best if informed else float('inf'), nodes, edges)\n            if bridged is not None:\n                if grow_a:\n                    pa = new_node.path_from_root()\n                    pb = bridged.path_from_root()\n                    if pa and pb and pa[0] == pb[-1]:\n                        pb = pb[:-1]\n                    path = pa + pb[::-1]\n                else:\n                    pa = new_node.path_from_root()\n                    pb = bridged.path_from_root()\n                    if pb and pa and pb[0] == pa[-1]:\n                        pa = pa[:-1]\n                    path = pb + pa[::-1]\n\n                path = self._visibility_prune(path)\n                path = self._shortcut(path, self.shortcut_trials)\n\n                L = self._path_len(path)\n                if L < c_best:\n                    c_best = L\n                    best_path = path\n                    informed = True\n                    return PlannerResult(True, best_path, nodes, edges)\n\n            # Opportunistic incumbent from visible nearest in other tree\n            other = self._nearest(Gopp, Topp, new_node.position)\n            if other is not None and self._edge_free(new_node.position, other.position):\n                if grow_a:\n                    pa = new_node.path_from_root()\n                    pb = other.path_from_root()\n                    cand = pa + pb[::-1] if (pa and pb and pa[0] != pb[-1]) else pa + pb[-2::-1]\n                else:\n                    pa = new_node.path_from_root()\n                    pb = other.path_from_root()\n                    cand = pb + pa[::-1] if (pb and pa and pb[0] != pa[-1]) else pb + pa[-2::-1]\n                L = self._path_len(cand)\n                if L < c_best:\n                    c_best = L\n                    best_path = cand\n                    informed = True\n\n        if best_path is not None and len(best_path) >= 2:\n            best_path = self._visibility_prune(best_path)\n            best_path = self._shortcut(best_path, max(20, self.shortcut_trials // 2))\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self, data):\n        h = 2166136261\n        for v in data:\n            iv = int(v * 997 + 0.5) & 0xffffffff\n            h ^= iv\n            h = (h * 16777619) & 0xffffffff\n        self._seed = h if h != 0 else 146959810\n\n    def _rand(self):\n        self._seed = (1664525 * self._seed + 1013904223) & 0xffffffff\n        return self._seed / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Sampling helpers\n    def _sample_corridor(self, a, b, width):\n        t = self._rand()\n        base = tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n        if self.dim == 2:\n            abx = b[0] - a[0]\n            aby = b[1] - a[1]\n            n = (abx * abx + aby * aby) ** 0.5\n            if n <= 1e-12:\n                return tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n            vx = abx / n\n            vy = aby / n\n            px, py = -vy, vx\n            mag = self._rand_range(-width, width)\n            return self._clamp((base[0] + px * mag, base[1] + py * mag))\n        else:\n            # random vector orthogonal to ab\n            ab = (b[0] - a[0], b[1] - a[1], b[2] - a[2])\n            n = (ab[0]*ab[0] + ab[1]*ab[1] + ab[2]*ab[2]) ** 0.5\n            if n <= 1e-12:\n                return tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n            v = (ab[0]/n, ab[1]/n, ab[2]/n)\n            r = (self._rand_range(-1.0, 1.0), self._rand_range(-1.0, 1.0), self._rand_range(-1.0, 1.0))\n            dot = r[0]*v[0] + r[1]*v[1] + r[2]*v[2]\n            u = (r[0]-dot*v[0], r[1]-dot*v[1], r[2]-dot*v[2])\n            un = (u[0]*u[0] + u[1]*u[1] + u[2]*u[2]) ** 0.5\n            if un <= 1e-12:\n                u = (v[1], -v[0], 0.0)\n                un = (u[0]*u[0] + u[1]*u[1] + u[2]*u[2]) ** 0.5\n            u = (u[0]/un, u[1]/un, u[2]/un)\n            mag = self._rand_range(-width, width)\n            return self._clamp((base[0] + u[0]*mag, base[1] + u[1]*mag, base[2] + u[2]*mag))\n\n    def _sample_ellipse(self, a, b, c_best):\n        if c_best == float('inf'):\n            return None\n        tries = 12\n        for _ in range(tries):\n            p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n            if self._dist(p, a) + self._dist(p, b) <= c_best + 1e-9:\n                if not self._point_blocked(p):\n                    return p\n        return None\n\n    # Node grid\n    def _grid_key(self, pos):\n        if self.dim == 3:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        else:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best, bestd = None, 1e100\n        found = False\n        for r in range(0, self.ring_max + 1):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                found = True\n                break\n        if not found:\n            if not tree:\n                return None\n            step = max(1, len(tree) // 64)\n            for i in range(0, len(tree), step):\n                n = tree[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, kmax):\n        ring = int(radius // self.cell_size) + 1\n        cand = self._collect_ring(grid, self._grid_key(pos), ring)\n        out = []\n        rr = radius + 1e-9\n        for n in cand:\n            d = self._dist(n.position, pos)\n            if d <= rr:\n                out.append((d, n))\n        out.sort(key=lambda x: x[0])\n        return [n for (_, n) in out[:kmax]]\n\n    def _neighbor_radius(self, ncount):\n        base = self.neighbor_factor * self.step_size\n        if ncount < 250:\n            return base * 2.0\n        if ncount < 1000:\n            return base * 1.5\n        return base * 1.2\n\n    def _near_duplicate(self, grid, pos, radius):\n        cand = self._collect_ring(grid, self._grid_key(pos), 1)\n        rr = radius + 1e-9\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # Parent choice with mild turn penalty\n    def _choose_parent(self, new_pos, neighbors):\n        best_p = None\n        best_cost = 1e100\n        best_tie = 1e100\n        for p in neighbors:\n            if p is None:\n                continue\n            cand_cost = p.cost + self._dist(p.position, new_pos)\n            tie = 0.0\n            if p.parent is not None:\n                a = p.parent.position\n                b = p.position\n                c = new_pos\n                v1 = tuple(b[i] - a[i] for i in range(self.dim))\n                v2 = tuple(c[i] - b[i] for i in range(self.dim))\n                n1 = 0.0\n                n2 = 0.0\n                dot = 0.0\n                for i in range(self.dim):\n                    n1 += v1[i]*v1[i]\n                    n2 += v2[i]*v2[i]\n                    dot += v1[i]*v2[i]\n                if n1 > 1e-12 and n2 > 1e-12:\n                    cosang = dot / ((n1**0.5)*(n2**0.5))\n                    if cosang > 1.0:\n                        cosang = 1.0\n                    if cosang < -1.0:\n                        cosang = -1.0\n                    tie = 1.0 - cosang\n            score = cand_cost + 0.03 * tie\n            if score + 1e-12 < best_cost + 0.03 * best_tie:\n                best_cost = cand_cost\n                best_tie = tie\n                best_p = p\n        if best_p is None:\n            return None, None\n        return best_p, best_cost\n\n    # Connect attempt toward other tree\n    def _try_connect(self, node, Topp, Gopp, root_x, c_best, nodes, edges):\n        # Direct\n        other = self._nearest(Gopp, Topp, node.position)\n        if other is not None and self._edge_free(node.position, other.position):\n            return other\n\n        # Micro-bridge: extend opposite tree a few steps toward node\n        head = other\n        steps = 0\n        while head is not None and steps < self.connect_steps:\n            step_pos = self._steer(head.position, node.position, self.step_size)\n            if not self._in_bounds(step_pos) or self._point_blocked(step_pos):\n                break\n            if self._near_duplicate(Gopp, step_pos, self.min_sep):\n                break\n\n            # lazy f-gate for opposite tree step\n            g_tent = head.cost + self._dist(head.position, step_pos)\n            if c_best < float('inf'):\n                f_est = g_tent + self._dist(step_pos, root_x.position)\n                if f_est >= self.heur_gate * c_best:\n                    break\n\n            # parent selection in opposite tree\n            radius = self._neighbor_radius(len(Topp))\n            neigh = self._neighbors(Gopp, step_pos, radius, self.k_parent)\n            if head not in neigh:\n                neigh.append(head)\n            parent, new_cost = self._choose_parent(step_pos, neigh)\n            if parent is None:\n                break\n\n            if self._point_blocked(step_pos):\n                break\n            if not self._edge_free(parent.position, step_pos):\n                break\n\n            q = Node(step_pos, parent, new_cost)\n            parent.add_child(q)\n            Topp.append(q)\n            nodes.append(q)\n            edges.append((parent, q))\n            self._grid_add(Gopp, q)\n            head = q\n            steps += 1\n\n            if self._edge_free(head.position, node.position):\n                return head\n        return None\n\n    # Obstacles and collisions\n    def _build_obs_grid(self):\n        self.obs_grid = {}\n        if self.dim == 3:\n            for idx, o in enumerate(self.obstacles):\n                ox, oy, oz, w, h, d = o\n                ix0 = int(max(0.0, ox) // self.obs_cell)\n                iy0 = int(max(0.0, oy) // self.obs_cell)\n                iz0 = int(max(0.0, oz) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], ox + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], oy + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], oz + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obs_grid.get(key)\n                            if b is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                ox, oy, w, h = o\n                ix0 = int(max(0.0, ox) // self.obs_cell)\n                iy0 = int(max(0.0, oy) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], ox + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], oy + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obs_grid.get(key)\n                        if b is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_blocked(self, p):\n        if self.dim == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_free(self, a, b):\n        k = self._edge_key(a, b)\n        cached = self._edge_cache.get(k)\n        if cached is not None:\n            return cached\n        hit = self._segment_hits(a, b)\n        self._edge_cache[k] = not hit\n        return not hit\n\n    def _segment_hits(self, a, b):\n        if self.dim == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                box = self.obstacles[idx]\n                if self._seg_box_hit3d(a, b, box):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                box = self.obstacles[idx]\n                if self._seg_box_hit2d(a, b, box):\n                    return True\n            return False\n\n    def _seg_box_hit2d(self, a, b, box):\n        x, y, w, h = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        t0, t1 = 0.0, 1.0\n        ax, ay = a\n        bx, by = b\n        dx = bx - ax\n        dy = by - ay\n\n        if abs(dx) < 1e-12:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            tA = (minx - ax) * inv\n            tB = (maxx - ax) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n\n        if abs(dy) < 1e-12:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            tA = (miny - ay) * inv\n            tB = (maxy - ay) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n\n        return t1 >= 0.0 and t0 <= 1.0\n\n    def _seg_box_hit3d(self, a, b, box):\n        x, y, z, w, h, d = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        minz, maxz = z, z + d\n        t0, t1 = 0.0, 1.0\n        ax, ay, az = a\n        bx, by, bz = b\n        dx = bx - ax\n        dy = by - ay\n        dz = bz - az\n\n        if abs(dx) < 1e-12:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            tA = (minx - ax) * inv\n            tB = (maxx - ax) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n\n        if abs(dy) < 1e-12:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            tA = (miny - ay) * inv\n            tB = (maxy - ay) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n\n        if abs(dz) < 1e-12:\n            if az < minz or az > maxz:\n                return False\n        else:\n            inv = 1.0 / dz\n            tA = (minz - az) * inv\n            tB = (maxz - az) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n\n        return t1 >= 0.0 and t0 <= 1.0\n\n    # Path helpers\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = list(path)\n        n = len(pts)\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            a = pts[i]\n            b = pts[j - 1]\n            if self._edge_free(a, b):\n                pts = pts[:i + 1] + pts[j - 1:]\n                n = len(pts)\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L",
                "objective": 2.01451,
                "time_improvement": -58.0,
                "length_improvement": 11.0,
                "smoothness_improvement": 1676.0,
                "node_improvement": 78.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.06051402091979981,
                        "num_nodes_avg": 149.0,
                        "path_length_avg": 168.74800030511412,
                        "smoothness_avg": 0.08768847756274413,
                        "success_improvement": 0.0,
                        "time_improvement": -140.57260279685548,
                        "node_improvement": 62.47796524804835,
                        "length_improvement": 7.506547049586077,
                        "smoothness_improvement": 1272.5150924337281,
                        "objective_score": -31.30527714713636
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.16808838844299318,
                        "num_nodes_avg": 199.0,
                        "path_length_avg": 251.51032001527568,
                        "smoothness_avg": 0.0719177185855428,
                        "success_improvement": 0.0,
                        "time_improvement": -4.917092564678633,
                        "node_improvement": 86.62903984411744,
                        "length_improvement": 16.03861585573451,
                        "smoothness_improvement": 1750.494699444932,
                        "objective_score": 16.900515241261775
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.061801910400390625,
                        "num_nodes_avg": 122.0,
                        "path_length_avg": 134.24728198755182,
                        "smoothness_avg": 0.16546711615085777,
                        "success_improvement": 0.0,
                        "time_improvement": -27.220079115011238,
                        "node_improvement": 84.48823903369357,
                        "length_improvement": 10.839347472480403,
                        "smoothness_improvement": 2004.7295039268602,
                        "objective_score": 8.361232268619172
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "path_expert",
                "algorithm_description": "PL-IRRT* (Path-Length Optimized Informed RRT*): a single-tree, cost-optimal planner with consistent rewiring, tight goal-side connections, informed/tube sampling around the incumbent path, fast k-nearest via spatial hashing and quickselect, and post-optimization length-only refinement (compression, shortcutting, elastic band).",
                "planning_mechanism": "Each iteration samples (goal/line/ellipse/tube), steers a step, validates node and edge, selects the minimum-cost valid parent within an adaptive RRT* radius, inserts the node, and consistently rewires cheaper neighbors with proper cost propagation. Upon any valid connection to the goal, it updates the incumbent path and switches to informed and tube-biased sampling to minimize path length. Finally, it compresses, shortcuts, and applies an elastic length optimizer before returning.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            ch = self.parent.children\n            for i in range(len(ch)):\n                if ch[i] is self:\n                    ch.pop(i)\n                    break\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=4.0,\n                 gamma_radius=72.0,\n                 min_radius_factor=1.0,\n                 goal_bias=0.14,\n                 line_bias=0.30,\n                 tube_bias=0.30,\n                 connect_factor=2.5,\n                 near_cap=96,\n                 post_opt_iters=700,\n                 max_no_improve=260,\n                 smoothing_iters=240,\n                 elastic_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_radius = gamma_radius\n        self.min_radius_factor = min_radius_factor\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.tube_bias = tube_bias\n        self.connect_factor = connect_factor\n        self.near_cap = near_cap\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.elastic_iters = elastic_iters\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        root = Node(start, None, 0.0)\n        nodes = [root]\n\n        cell = max(1.0, 0.8 * self.step_size)\n        grid = {}\n        self._grid_add(grid, root, cell)\n\n        occ_cell = max(0.25, 0.3 * self.step_size)\n        occ = {self._grid_key(start, occ_cell): True}\n\n        success = False\n        goal_node = None\n        best_cost = float('inf')\n        c_lb = self._dist(start, goal)\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n        incumbent_path = None\n\n        for it in range(self.max_iter):\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                if found_first:\n                    r = self._rand()\n                    if r < self.tube_bias and incumbent_path is not None:\n                        x_rand = self._sample_tube(incumbent_path)\n                    else:\n                        x_rand = self._sample_informed(start, goal, best_cost)\n                else:\n                    if self._rand() < self.line_bias:\n                        x_rand = self._sample_on_line(start, goal)\n                    else:\n                        x_rand = self._sample_uniform()\n\n            n_nearest = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_nearest.position, x_rand, self.step_size)\n\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            if not found_first:\n                k_occ = self._grid_key(x_new_pos, occ_cell)\n                if k_occ in occ:\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n                    continue\n\n            if self._is_edge_in_obstacle(n_nearest.position, x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            r_near = self._rrtstar_radius(max(2, len(nodes)))\n            near_nodes = self._near(grid, x_new_pos, r_near, cell)\n            if near_nodes and len(near_nodes) > self.near_cap:\n                near_nodes = self._k_nearest(near_nodes, x_new_pos, self.near_cap)\n\n            best_parent = n_nearest\n            best_pc = n_nearest.cost + self._dist(n_nearest.position, x_new_pos)\n\n            for nn in near_nodes:\n                if nn is n_nearest:\n                    continue\n                if found_first:\n                    lb = nn.cost + self._dist(nn.position, x_new_pos) + self._dist(x_new_pos, goal)\n                    if lb >= best_cost - 1e-12:\n                        pass\n                c = nn.cost + self._dist(nn.position, x_new_pos)\n                if c + 1e-12 < best_pc:\n                    if not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d):\n                        best_pc = c\n                        best_parent = nn\n\n            if self._is_edge_in_obstacle(best_parent.position, x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            x_new = Node(x_new_pos, None, best_pc)\n            x_new.attach(best_parent)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            if not found_first:\n                occ[self._grid_key(x_new_pos, occ_cell)] = True\n\n            improved = False\n\n            for nn in near_nodes:\n                if nn is x_new or nn is best_parent:\n                    continue\n                alt = x_new.cost + self._dist(x_new.position, nn.position)\n                if alt + 1e-12 < nn.cost:\n                    if not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d):\n                        nn.attach(x_new)\n                        nn.cost = alt\n                        self._propagate_costs_from(nn)\n\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                if self._is_direct_better(x_new, goal, best_cost, obstacles, is_3d):\n                    ctot = x_new.cost + self._dist(x_new.position, goal)\n                    if goal_node is None:\n                        goal_node = Node(goal, None, ctot)\n                        goal_node.attach(x_new)\n                        nodes.append(goal_node)\n                    else:\n                        goal_node.attach(x_new)\n                        goal_node.cost = ctot\n                    if ctot + 1e-12 < best_cost:\n                        best_cost = ctot\n                        success = True\n                        found_first = True\n                        improved = True\n                        post_iters = 0\n                        no_improve = 0\n                        incumbent_path = self._extract_path(goal_node)\n\n            if not improved and found_first:\n                post_iters += 1\n                no_improve += 1\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        path = []\n        if success and goal_node is not None:\n            path = self._extract_path(goal_node)\n            path = self._compress(path, obstacles, is_3d)\n            path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n            path = self._elastic_optimize(path, obstacles, is_3d, self.elastic_iters)\n\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(0.5 * self.step_size, 1.0)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        span = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > span:\n                span = self.bounds[i]\n        limit = span * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _k_nearest(self, nodes, center, k):\n        if len(nodes) <= k:\n            return nodes\n        dists = [self._dist(n.position, center) for n in nodes]\n        idx = list(range(len(nodes)))\n        self._nth_element(dists, idx, k)\n        sel = []\n        for i in range(k):\n            sel.append(nodes[idx[i]])\n        return sel\n\n    def _partition(self, arr, idx, left, right, pivot_index):\n        pivot_value = arr[pivot_index]\n        idx[pivot_index], idx[right] = idx[right], idx[pivot_index]\n        arr[pivot_index], arr[right] = arr[right], arr[pivot_index]\n        store = left\n        for i in range(left, right):\n            if arr[i] < pivot_value:\n                arr[i], arr[store] = arr[store], arr[i]\n                idx[i], idx[store] = idx[store], idx[i]\n                store += 1\n        arr[store], arr[right] = arr[right], arr[store]\n        idx[store], idx[right] = idx[right], idx[store]\n        return store\n\n    def _nth_element(self, arr, idx, n_small):\n        left = 0\n        right = len(arr) - 1\n        while True:\n            if left == right:\n                return\n            pivot = left + int(self._uniform(0, right - left + 1))\n            pivot = self._partition(arr, idx, left, right, pivot)\n            if n_small == pivot:\n                return\n            elif n_small < pivot:\n                right = pivot - 1\n            else:\n                left = pivot + 1\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    def _rrtstar_radius(self, n):\n        expo = 1.0 / float(max(2, self.dim))\n        r = self.gamma_radius * ((self._log_approx(n) / float(n)) ** expo)\n        rmin = max(self.min_radius_factor * self.step_size, 1e-6)\n        if r < rmin:\n            r = rmin\n        return r\n\n    def _propagate_costs_from(self, node):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                stack.append(c)\n\n    def _sample_uniform(self):\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _sample_on_line(self, a, b):\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[i] + t * (b[i] - a[i]) for i in range(self.dim))\n        jitter = 0.5 * self.step_size\n        return tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _sample_informed(self, start, goal, c_best):\n        if c_best < float('inf'):\n            for _ in range(32):\n                p = self._sample_uniform()\n                if self._dist(p, start) + self._dist(p, goal) <= c_best and self._in_bounds(p):\n                    return p\n        return self._sample_uniform()\n\n    def _sample_tube(self, path):\n        if not path or len(path) < 2:\n            return self._sample_uniform()\n        i = int(self._uniform(0, len(path) - 1))\n        if i >= len(path) - 1:\n            i = len(path) - 2\n        a = path[i]\n        b = path[i + 1]\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[d] + t * (b[d] - a[d]) for d in range(self.dim))\n        r = 0.6 * self.step_size\n        p = tuple(self._clip(base[d] + self._uniform(-r, r), 0.0, self.bounds[d]) for d in range(self.dim))\n        return p\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _is_direct_better(self, node, goal, best_cost, obstacles, is_3d):\n        if self._is_edge_in_obstacle(node.position, goal, obstacles, is_3d):\n            return False\n        ctot = node.cost + self._dist(node.position, goal)\n        return ctot + 1e-12 < best_cost\n\n    def _extract_path(self, goal_node):\n        path = []\n        cur = goal_node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        path.reverse()\n        return path\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts\n\n    def _elastic_optimize(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = [tuple(p) for p in path]\n        for _ in range(iters):\n            changed = False\n            for i in range(1, len(pts) - 1):\n                a = pts[i - 1]\n                b = pts[i + 1]\n                mid = tuple((a[d] + b[d]) * 0.5 for d in range(self.dim))\n                if not self._in_bounds(mid):\n                    continue\n                if self._is_in_obstacle(mid, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(a, mid, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(mid, b, obstacles, is_3d):\n                    continue\n                old_len = self._dist(a, pts[i]) + self._dist(pts[i], b)\n                new_len = self._dist(a, mid) + self._dist(mid, b)\n                if new_len + 1e-9 < old_len:\n                    pts[i] = mid\n                    changed = True\n            if not changed:\n                break\n        return pts",
                "objective": 365.95447,
                "time_improvement": -1286.0,
                "length_improvement": 24.0,
                "smoothness_improvement": 1089.0,
                "node_improvement": -141.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.595766282081604,
                        "num_nodes_avg": 1541.2,
                        "path_length_avg": 150.55194504405853,
                        "smoothness_avg": 0.03582350918675106,
                        "success_improvement": 0.0,
                        "time_improvement": -2268.4601181753897,
                        "node_improvement": -288.1138252329388,
                        "length_improvement": 17.48009327311766,
                        "smoothness_improvement": 460.7157107679572,
                        "objective_score": -667.7464009349065
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.41977696418762206,
                        "num_nodes_avg": 1344.6,
                        "path_length_avg": 219.94033567557648,
                        "smoothness_avg": 0.08104842963694583,
                        "success_improvement": 0.0,
                        "time_improvement": -162.01559201175405,
                        "node_improvement": 9.655311429147352,
                        "length_improvement": 26.577585319941548,
                        "smoothness_improvement": 1985.4344713828748,
                        "objective_score": -22.730954054646908
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.7419606685638428,
                        "num_nodes_avg": 1917.2,
                        "path_length_avg": 108.64935758727987,
                        "smoothness_avg": 0.07249484234853829,
                        "success_improvement": 0.0,
                        "time_improvement": -1427.3361995347332,
                        "node_improvement": -143.76350921805468,
                        "length_improvement": 27.84027001696807,
                        "smoothness_improvement": 822.1290436607634,
                        "objective_score": -407.3860526319353
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "FLASH-ABiRC: Fast Heuristic Anytime Smooth Hybrid BiRRT-Connect. It alternates growth of two trees with ring-grid nearest lookup, strict mandatory node/edge collision checks, near-duplicate suppression, and on-the-fly line-of-sight compression to reduce bends and depth. After the first feasible bridge, it applies bounded visibility pruning and few shortcuts and returns immediately. If a path exists, informed ellipse/tube sampling with an f-gate refocuses expansions; connection attempts use a direct check plus at most two micro-steps, minimizing collision checks and variance.",
            "planning_mechanism": "Alternate bi-directional expansions: sample (uniform/line; then ellipse/tube after first path), ring-grid nearest, single-step steer, mandatory node/edge checks, optional compression to ancestor if visible, insert. Try direct opposite-tree connect, else extend the other tree a couple of steps with the same checks. On bridge: stitch, prune by visibility, few shortcuts, return. Throughout, use spatial hashes for nodes/obstacles, cached segment-box tests, f-gated pruning when an incumbent cost exists.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        cur = self\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3200,\n                 step_size=7.0,\n                 goal_bias=0.12,\n                 line_bias=0.35,\n                 informed_bias=0.6,\n                 tube_bias=0.35,\n                 cell_factor=1.2,\n                 min_sep_factor=0.55,\n                 ring_max=2,\n                 connect_hops=2,\n                 heur_gate=1.08,\n                 prune_iters=1,\n                 shortcut_trials=28):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.informed_bias = float(informed_bias)\n        self.tube_bias = float(tube_bias)\n        self.cell_factor = float(cell_factor)\n        self.min_sep_factor = float(min_sep_factor)\n        self.ring_max = int(ring_max)\n        self.connect_hops = int(connect_hops)\n        self.heur_gate = float(heur_gate)\n        self.prune_iters = int(prune_iters)\n        self.shortcut_trials = int(shortcut_trials)\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Build obstacle grid and caches\n        self._edge_cache = {}\n        self.obs_cell = max(3.0, self.step_size)\n        self._build_obs_grid()\n\n        # Node checks for start/goal\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            s = Node(self.start, None, 0.0)\n            g = Node(self.goal, s, self._dist(self.start, self.goal))\n            s.add_child(g)\n            nodes.extend([s, g])\n            edges.append((s, g))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Derived params\n        self.cell = max(1.0, self.cell_factor * self.step_size)\n        self.min_sep = max(0.5, self.min_sep_factor * self.step_size)\n        sg = self._dist(self.start, self.goal)\n        self.corridor_w = max(self.step_size, 0.18 * sg)\n\n        # Trees\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, a_root)\n        self._grid_add(Gb, b_root)\n\n        best_path = None\n        c_best = float('inf')\n        informed = False\n\n        for it in range(self.max_iter):\n            grow_a = (it % 2 == 0)\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            root_x = a_root if grow_a else b_root\n            root_y = b_root if grow_a else a_root\n            attractor = self.goal if grow_a else self.start\n\n            # Sample\n            xr = None\n            r = self._rand()\n            if informed and r < self.informed_bias and c_best < float('inf'):\n                xr = self._sample_ellipse(root_x.position, root_y.position, c_best)\n            if xr is None:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    xr = attractor\n                elif r2 < self.goal_bias + self.line_bias:\n                    xr = self._sample_corridor(root_x.position, root_y.position, self.corridor_w)\n                elif informed and self._rand() < self.tube_bias and best_path is not None:\n                    xr = self._sample_tube(best_path)\n                else:\n                    xr = self._sample_uniform()\n            xr = self._clamp(xr)\n            if self._point_blocked(xr):\n                continue\n\n            # Nearest and steer\n            n_near = self._nearest(G, T, xr)\n            if n_near is None:\n                continue\n            x_new_pos = self._steer(n_near.position, xr, self.step_size)\n            if not self._in_bounds(x_new_pos):\n                continue\n            if self._point_blocked(x_new_pos):\n                continue\n            if self._near_duplicate(G, x_new_pos, self.min_sep):\n                continue\n\n            # Heuristic gate\n            if informed and c_best < float('inf'):\n                g_tent = n_near.cost + self._dist(n_near.position, x_new_pos)\n                f = g_tent + self._dist(x_new_pos, root_y.position)\n                if f >= self.heur_gate * c_best:\n                    continue\n\n            # Edge check to nearest; if ok, try one-hop compression to parent\n            if not self._edge_free(n_near.position, x_new_pos):\n                continue\n            parent = n_near\n            if n_near.parent is not None:\n                cand_p = n_near.parent\n                if self._edge_free(cand_p.position, x_new_pos):\n                    parent = cand_p\n\n            # Mandatory checks before insertion (node and edge)\n            if self._point_blocked(x_new_pos):\n                continue\n            if not self._edge_free(parent.position, x_new_pos):\n                continue\n\n            new_cost = parent.cost + self._dist(parent.position, x_new_pos)\n            x_new = Node(x_new_pos, parent, new_cost)\n            parent.add_child(x_new)\n            T.append(x_new)\n            nodes.append(x_new)\n            edges.append((parent, x_new))\n            self._grid_add(G, x_new)\n\n            # Try connect to opposite tree: direct then micro-hops\n            q_opp = self._nearest(Gopp, Topp, x_new.position)\n            bridged = None\n            if q_opp is not None and self._edge_free(x_new.position, q_opp.position):\n                bridged = q_opp\n            else:\n                head = q_opp\n                hops = 0\n                while head is not None and hops < self.connect_hops:\n                    step_pos = self._steer(head.position, x_new.position, self.step_size)\n                    if not self._in_bounds(step_pos) or self._point_blocked(step_pos):\n                        break\n                    if self._near_duplicate(Gopp, step_pos, self.min_sep):\n                        break\n                    # f-gate for opposite step\n                    if informed and c_best < float('inf'):\n                        g_hat = head.cost + self._dist(head.position, step_pos)\n                        f_hat = g_hat + self._dist(step_pos, root_x.position)\n                        if f_hat >= self.heur_gate * c_best:\n                            break\n                    # parent is head, try compression to its parent if visible\n                    par = head\n                    if head.parent is not None and self._edge_free(head.parent.position, step_pos):\n                        par = head.parent\n                    if not self._edge_free(par.position, step_pos):\n                        break\n                    q = Node(step_pos, par, par.cost + self._dist(par.position, step_pos))\n                    par.add_child(q)\n                    Topp.append(q)\n                    nodes.append(q)\n                    edges.append((par, q))\n                    self._grid_add(Gopp, q)\n                    head = q\n                    hops += 1\n                    if self._edge_free(head.position, x_new.position):\n                        bridged = head\n                        break\n\n            if bridged is not None:\n                # Assemble path\n                if grow_a:\n                    pa = x_new.path_from_root()\n                    pb = bridged.path_from_root()\n                    if pa and pb and pa[0] == pb[-1]:\n                        pb = pb[:-1]\n                    path = pa + pb[::-1]\n                else:\n                    pa = x_new.path_from_root()\n                    pb = bridged.path_from_root()\n                    if pb and pa and pb[0] == pa[-1]:\n                        pa = pa[:-1]\n                    path = pb + pa[::-1]\n\n                # Prune and shortcut (bounded)\n                for _ in range(max(1, self.prune_iters)):\n                    path = self._visibility_prune(path)\n                path = self._shortcut(path, self.shortcut_trials)\n\n                L = self._path_len(path)\n                best_path = path\n                c_best = L\n                informed = True\n                return PlannerResult(True, best_path, nodes, edges)\n\n            # Opportunistic incumbent from visible nearest other\n            if q_opp is not None and self._edge_free(x_new.position, q_opp.position):\n                cand = (x_new.path_from_root() + q_opp.path_from_root()[-2::-1]) if (x_new.path_from_root() and q_opp.path_from_root()) else None\n                if cand:\n                    Lc = self._path_len(cand)\n                    if Lc + 1e-9 < c_best:\n                        c_best = Lc\n                        best_path = cand\n                        informed = True\n\n        # No bridge found within budget; return best known (if any)\n        if best_path is not None and len(best_path) >= 2:\n            best_path = self._visibility_prune(best_path)\n            best_path = self._shortcut(best_path, max(12, self.shortcut_trials // 2))\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and basic geometry\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5 if s > 0.0 else 0.0\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        r = step / max(1e-12, d)\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Sampling\n    def _sample_uniform(self):\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _sample_corridor(self, a, b, width):\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n        if self.dim == 2:\n            dx, dy = b[0] - a[0], b[1] - a[1]\n            n = (dx*dx + dy*dy) ** 0.5\n            if n < 1e-12:\n                return self._sample_uniform()\n            vx, vy = dx / n, dy / n\n            px, py = -vy, vx\n            mag = self._uniform(-width, width)\n            return self._clamp((base[0] + px * mag, base[1] + py * mag))\n        else:\n            ab = (b[0]-a[0], b[1]-a[1], b[2]-a[2])\n            n = (ab[0]**2 + ab[1]**2 + ab[2]**2) ** 0.5\n            if n < 1e-12:\n                return self._sample_uniform()\n            v = (ab[0]/n, ab[1]/n, ab[2]/n)\n            r = (self._uniform(-1.0, 1.0), self._uniform(-1.0, 1.0), self._uniform(-1.0, 1.0))\n            dot = r[0]*v[0] + r[1]*v[1] + r[2]*v[2]\n            u = (r[0]-dot*v[0], r[1]-dot*v[1], r[2]-dot*v[2])\n            un = (u[0]**2 + u[1]**2 + u[2]**2) ** 0.5\n            if un < 1e-12:\n                u = (v[1], -v[0], 0.0)\n                un = (u[0]**2 + u[1]**2 + u[2]**2) ** 0.5\n            u = (u[0]/un, u[1]/un, u[2]/un)\n            mag = self._uniform(-width, width)\n            return self._clamp((base[0] + u[0]*mag, base[1] + u[1]*mag, base[2] + u[2]*mag))\n\n    def _sample_ellipse(self, a, b, c_best):\n        if c_best == float('inf'):\n            return None\n        for _ in range(24):\n            p = self._sample_uniform()\n            if self._dist(p, a) + self._dist(p, b) <= c_best + 1e-9 and not self._point_blocked(p):\n                return p\n        return None\n\n    def _sample_tube(self, path):\n        if not path or len(path) < 2:\n            return self._sample_uniform()\n        i = int(self._uniform(0, len(path) - 1))\n        if i >= len(path) - 1:\n            i = len(path) - 2\n        a = path[i]\n        b = path[i + 1]\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[d] + t * (b[d] - a[d]) for d in range(self.dim))\n        rad = 0.7 * self.step_size\n        if self.dim == 2:\n            return self._clamp((base[0] + self._uniform(-rad, rad),\n                                base[1] + self._uniform(-rad, rad)))\n        else:\n            return self._clamp((base[0] + self._uniform(-rad, rad),\n                                base[1] + self._uniform(-rad, rad),\n                                base[2] + self._uniform(-rad, rad)))\n\n    # Node spatial grid\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, self.ring_max + 1):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                found = True\n                break\n        if not found:\n            step = max(1, len(tree) // 64) if tree else 1\n            for i in range(0, len(tree), step):\n                n = tree[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, radius):\n        cand = self._collect_ring(grid, self._grid_key(pos), 1)\n        rr = radius + 1e-9\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # Obstacles grid and collision checks\n    def _build_obs_grid(self):\n        self.obs_grid = {}\n        if self.dim == 3:\n            for idx, o in enumerate(self.obstacles):\n                ox, oy, oz, w, h, d = o\n                ix0 = int(max(0.0, ox) // self.obs_cell)\n                iy0 = int(max(0.0, oy) // self.obs_cell)\n                iz0 = int(max(0.0, oz) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], ox + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], oy + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], oz + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obs_grid.get(key)\n                            if b is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                ox, oy, w, h = o\n                ix0 = int(max(0.0, ox) // self.obs_cell)\n                iy0 = int(max(0.0, oy) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], ox + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], oy + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obs_grid.get(key)\n                        if b is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_blocked(self, p):\n        if self.dim == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_free(self, a, b):\n        k = self._edge_key(a, b)\n        c = self._edge_cache.get(k)\n        if c is not None:\n            return c\n        hit = self._segment_hits(a, b)\n        self._edge_cache[k] = not hit\n        return not hit\n\n    def _segment_hits(self, a, b):\n        if self.dim == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                if self._seg_box_hit3d(a, b, self.obstacles[idx]):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                if self._seg_box_hit2d(a, b, self.obstacles[idx]):\n                    return True\n            return False\n\n    def _seg_box_hit2d(self, a, b, box):\n        x, y, w, h = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        t0, t1 = 0.0, 1.0\n        ax, ay = a\n        bx, by = b\n        dx = bx - ax\n        dy = by - ay\n\n        if abs(dx) < 1e-12:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            tA = (minx - ax) * inv\n            tB = (maxx - ax) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n\n        if abs(dy) < 1e-12:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            tA = (miny - ay) * inv\n            tB = (maxy - ay) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n\n        return t1 >= 0.0 and t0 <= 1.0\n\n    def _seg_box_hit3d(self, a, b, box):\n        x, y, z, w, h, d = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        minz, maxz = z, z + d\n        t0, t1 = 0.0, 1.0\n        ax, ay, az = a\n        bx, by, bz = b\n        dx = bx - ax\n        dy = by - ay\n        dz = bz - az\n\n        if abs(dx) < 1e-12:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            tA = (minx - ax) * inv\n            tB = (maxx - ax) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n\n        if abs(dy) < 1e-12:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            tA = (miny - ay) * inv\n            tB = (maxy - ay) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n\n        if abs(dz) < 1e-12:\n            if az < minz or az > maxz:\n                return False\n        else:\n            inv = 1.0 / dz\n            tA = (minz - az) * inv\n            tB = (maxz - az) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n\n        return t1 >= 0.0 and t0 <= 1.0\n\n    # Path utils\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = list(path)\n        n = len(pts)\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 2, n))\n            a = pts[i]\n            b = pts[j - 1]\n            if self._edge_free(a, b):\n                pts = pts[:i + 1] + pts[j - 1:]\n                n = len(pts)\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L",
            "objective": -38.87335,
            "time_improvement": 75.0,
            "length_improvement": 12.0,
            "smoothness_improvement": 1876.0,
            "node_improvement": 88.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.006264138221740723,
                    "num_nodes_avg": 56.7,
                    "path_length_avg": 171.88502102126137,
                    "smoothness_avg": 0.04966818877179101,
                    "success_improvement": 0.0,
                    "time_improvement": 75.09701035598583,
                    "node_improvement": 85.72148073533116,
                    "length_improvement": 5.78709628579148,
                    "smoothness_improvement": 677.4150104767455,
                    "objective_score": 29.388435930654364
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02297062873840332,
                    "num_nodes_avg": 122.2,
                    "path_length_avg": 242.80866792108137,
                    "smoothness_avg": 0.11993325646889634,
                    "success_improvement": 0.0,
                    "time_improvement": 85.662236374922,
                    "node_improvement": 91.78928979372438,
                    "length_improvement": 18.943477787944797,
                    "smoothness_improvement": 2985.9690733776524,
                    "objective_score": 51.99460295213174
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017574667930603027,
                    "num_nodes_avg": 116.3,
                    "path_length_avg": 134.8321489290259,
                    "smoothness_avg": 0.1622613841577103,
                    "success_improvement": 0.0,
                    "time_improvement": 63.82230532897514,
                    "node_improvement": 85.2129688493325,
                    "length_improvement": 10.450906698324257,
                    "smoothness_improvement": 1963.9528295965463,
                    "objective_score": 35.23699976566982
                }
            ],
            "success_rate": 1.0
        },
        "objective": -8.200000000000003,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Excessive collision checking from multi-step connection attempts and repeated visibility/shortcut passes before returning the first solution\n   - Heavy neighbor processing (wide-radius searches, sorting, or rewiring) that triggers frequent subtree cost updates and redundant edge feasibility tests\n   - Strict heuristic gating and aggressive corridor/goal biases that cause many sampled states to be rejected, wasting iterations\n   - Nearest-neighbor lookups that often fall back to linear scans due to coarse grids or small ring radii\n   - Large post-optimization budgets (smoothing, elastic steps) executed even when a feasible path already exists"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Limited opposite-tree micro-extensions (small hop cap) with a direct-connect first policy, cutting per-iteration expansion and checks\n   - Simplified parent choice (nearest with one-hop compression) eliminating neighbor sorting/beam selection and any rewiring overhead\n   - Larger step size with a tighter NN search window (smaller ring depth) to reduce tree depth and nearest lookups\n   - Early termination on the first bridge with bounded pruning/shortcutting only once\n   - Practical collision-cost caching and obstacle grid reuse with restrained duplicate suppression\n   - Slightly relaxed f-gate to avoid over-pruning stalls and improve acceptance rate\n2. Expected mechanism of impact:\n   - Fewer edge collision queries, NN scans, and node insertions per iteration directly reduce compute time\n   - Shallower trees and minimal opposite-tree growth lower connection and feasibility-check workload\n   - Bounded post-processing prevents long tail optimizations from dominating runtime\n   - Higher acceptance of promising samples reduces wasted iterations from overly strict heuristics"
        }
    },
    {
        "parents": [
            {
                "operator": "m1",
                "algorithm_description": "AURORA-BiRRT*: A*-guided, Unrolled-Rewire, Obstacle-Grid accelerated BiRRT with memoized edges and cell-pair sieve. It couples hashed nearest search, per-cell throttling, duplicate suppression, heuristic parent selection (g+h), bounded rewiring with full cost propagation, multi-step Connect, and quantized edge-collision caching; online LOS compression and cache-aware shortcutting yield smooth, short paths quickly.",
                "planning_mechanism": "Alternate tree growth with k-beam samples. Each beam selects a parent among local candidates minimizing g(parent)+d(parent,qn)+\u03bb\u00b7h(qn,other-tree), enforcing both node and edge validity before insertion. After insertion, LOS-compress to an ancestor, rewire neighbors if cheaper and propagate costs. A limited Connect grows the opposite tree unless a cached blocked cell-pair forbids it; direct edges terminate early. Once an incumbent exists, informed ellipse sampling narrows exploration; final shortcutting and LOS collapse return a concise path.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=9.0,\n        collision_res=1.0,\n        beam_k=2,\n        goal_bias=0.2,\n        informed_bias=0.6,\n        grid_cell_factor=1.2,\n        per_cell_cap=6,\n        dupe_radius_ratio=0.45,\n        rewire_radius_factor=2.5,\n        neighbor_cap=24,\n        compress_depth=2,\n        connect_steps=3,\n        edge_cache_capacity=40000,\n        edge_cache_quant=0.8,\n        smoothing_iters=50,\n        no_improve_stop=12\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_res = collision_res\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.per_cell_cap = per_cell_cap\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.rewire_radius_factor = rewire_radius_factor\n        self.neighbor_cap = neighbor_cap\n        self.compress_depth = compress_depth\n        self.connect_steps = connect_steps\n        self.edge_cache_capacity = edge_cache_capacity\n        self.edge_cache_quant = edge_cache_quant\n        self.smoothing_iters = smoothing_iters\n        self.no_improve_stop = no_improve_stop\n\n        self._rnd_state = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n\n        # Edge cache\n        self._tick = 0\n        self.ecache = {}\n        self._last_prune_size = 0\n        self.eq = max(0.25, self.edge_cache_quant)\n        # Collision stepping resolution for fallback sampling checks\n        self.edge_res = max(0.5, self.collision_res)\n\n        # Build obstacle grid\n        self._build_obstacle_grid()\n\n        # Validate endpoints\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        nodes = []\n        edges = []\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        throttles_a, throttles_b = {}, {}\n        anchors_a, anchors_b = [start_root], [goal_root]\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_path = None\n        best_len = float('inf')\n        sg = self._dist(self.start, self.goal)\n\n        blocked_pairs = set()\n        anchor_stride = 20\n        max_rings = 4\n\n        for it in range(self.max_iter):\n            side_start = (it % 2 == 0)\n            tree1 = tree_a if side_start else tree_b\n            grid1 = grid_a if side_start else grid_b\n            throttles1 = throttles_a if side_start else throttles_b\n            anchors1 = anchors_a if side_start else anchors_b\n\n            tree2 = tree_b if side_start else tree_a\n            grid2 = grid_b if side_start else grid_a\n            throttles2 = throttles_b if side_start else throttles_a\n            anchors2 = anchors_b if side_start else anchors_a\n\n            attractor = self.goal if side_start else self.start\n\n            progressed = False\n            for _ in range(self.beam_k):\n                sample = self._sample(attractor, best_len, sg)\n                if sample is None:\n                    continue\n                near = self._nearest_hashed(grid1, anchors1, sample, max_rings)\n                if near is None:\n                    continue\n                new_pos = self._steer(near.position, sample)\n                if not self._within_bounds(new_pos):\n                    continue\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if self._has_nearby(grid1, new_pos, self.dupe_radius):\n                    continue\n\n                # Parent selection (A*-guided among local candidates)\n                rewire_r = self._rewire_radius(len(nodes))\n                parents = self._candidate_parents(grid1, anchors1, tree1, new_pos, rewire_r, self.neighbor_cap)\n                best_parent, best_new_cost = None, float('inf')\n                best_score = float('inf')\n                other_near = self._nearest_hashed(grid2, anchors2, new_pos, max_rings)\n                h_term = self._dist(new_pos, other_near.position if other_near else attractor)\n                lam = 0.1\n                for p in parents:\n                    if not self._edge_free(p.position, new_pos):\n                        continue\n                    gc = p.cost + self._dist(p.position, new_pos)\n                    f = gc + lam * h_term\n                    if f + 1e-9 < best_score:\n                        best_score = f\n                        best_parent = p\n                        best_new_cost = gc\n                if best_parent is None:\n                    continue\n\n                # Per-cell cap with cost admission\n                ckey = self._cell_of(new_pos)\n                bucket = grid1.get(ckey)\n                if bucket and len(bucket) >= self.per_cell_cap:\n                    best_bucket_cost = min(n.cost for n in bucket)\n                    if best_new_cost >= best_bucket_cost - 1e-9:\n                        continue\n\n                # Final validity before insertion\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if not self._edge_free(best_parent.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos, best_parent, best_new_cost)\n                best_parent.add_child(new_node)\n                tree1.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                self._grid_insert(grid1, new_node)\n                throttles1[ckey] = throttles1.get(ckey, 0) + 1\n                if (len(tree1) % anchor_stride) == 0:\n                    anchors1.append(new_node)\n                progressed = True\n\n                # LOS compression to ancestors\n                self._compress_to_ancestors(new_node, edges, self.compress_depth)\n\n                # Rewiring around new_node\n                self._rewire_neighbors(grid1, new_node, rewire_r, edges)\n\n                # Try connect to the other tree\n                pair_key = self._pair_key(self._cell_of(new_node.position),\n                                          self._cell_of((other_near.position if other_near else attractor)))\n                if pair_key not in blocked_pairs:\n                    connected, path = self._attempt_connect(new_node, tree2, grid2, throttles2, anchors2, nodes, edges)\n                    if connected:\n                        path = self._shortcut(path)\n                        path = self._los_collapse(path)\n                        best_path = path\n                        best_len = self._path_len(path)\n                        return PlannerResult(True, path, nodes, edges)\n                    else:\n                        blocked_pairs.add(pair_key)\n\n            if not progressed:\n                continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= len(self.obstacles) * 2654435761\n        self._rnd_state = (s ^ 0xA5A5A5) & 0xffffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 2463534242\n\n    def _rand(self):\n        self._rnd_state = (1664525 * self._rnd_state + 1013904223) & 0xffffffff\n        return self._rnd_state / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Sampling\n    def _sample(self, attractor, best_len, sg):\n        for _ in range(24):\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p and self._within_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._within_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Node grid (for NN, dupes, neighbors)\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, anchors, pos, max_rings=4):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # fallback scan\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((key[0] + dx, key[1] + dy))\n                    if not bucket:\n                        continue\n                    for n in bucket:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    def _candidate_parents(self, grid, anchors, tree, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        if not cand:\n            cand = anchors[:]\n        if len(cand) > cap:\n            # Reservoir-like random subset\n            out = []\n            take = 0\n            for n in cand:\n                take += 1\n                if len(out) < cap:\n                    out.append(n)\n                else:\n                    j = int(self._rand_range(0, take))\n                    if j < len(out):\n                        out[j] = n\n            cand = out\n        return cand\n\n    # Obstacle spatial grid\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    # Edge checks with cache\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.eq) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.eq) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        if len(self.ecache) - self._last_prune_size > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self.ecache:\n            return\n        cutoff = self._tick - 3000\n        to_del = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            i = 0\n            for k in list(self.ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune_size = len(self.ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Compression and rewiring\n    def _compress_to_ancestors(self, node, edges, depth_limit):\n        depth = 0\n        curp = node.parent\n        while curp is not None and curp.parent is not None and depth < depth_limit:\n            gp = curp.parent\n            if self._edge_free(gp.position, node.position):\n                self._reparent(node, gp, edges)\n                curp = node.parent\n                depth += 1\n            else:\n                break\n\n    def _rewire_radius(self, n_nodes):\n        # simple schedule\n        return max(self.step_size * 1.5, self.rewire_radius_factor * self.step_size)\n\n    def _rewire_neighbors(self, grid, node, radius, edges):\n        key = self._cell_of(node.position)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        neigh = self._grid_ring_nodes(grid, key, r_cells)\n        count = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if d > radius:\n                continue\n            new_cost = node.cost + d\n            if new_cost + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n                count += 1\n                if count >= self.neighbor_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        old_parent = child.parent\n        if old_parent is new_parent:\n            return\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    stack.append(ch)\n\n    # Connect attempt\n    def _attempt_connect(self, new_node, other_tree, other_grid, throttles, anchors, nodes, edges):\n        other_near = self._nearest_hashed(other_grid, anchors, new_node.position, 4)\n        if other_near is None:\n            return False, []\n        # Try direct bridge first\n        if self._edge_free(new_node.position, other_near.position):\n            path = self._extract_path(new_node, other_near)\n            return True, self._ensure_bounds_and_valid(path)\n\n        p = other_near\n        steps = 0\n        last_q = None\n        while steps < self.connect_steps:\n            step_pos = self._steer(p.position, new_node.position)\n            if not self._within_bounds(step_pos):\n                break\n            if self._point_in_obstacles(step_pos):\n                break\n            if self._has_nearby(other_grid, step_pos, self.dupe_radius):\n                break\n            if not self._edge_free(p.position, step_pos):\n                break\n            cell = self._cell_of(step_pos)\n            bucket = other_grid.get(cell)\n            if bucket and len(bucket) >= self.per_cell_cap:\n                best_bucket_cost = min(n.cost for n in bucket)\n                new_c = p.cost + self._dist(p.position, step_pos)\n                if new_c >= best_bucket_cost - 1e-9:\n                    break\n\n            q = Node(step_pos, p, p.cost + self._dist(p.position, step_pos))\n            p.add_child(q)\n            other_tree.append(q)\n            nodes.append(q)\n            edges.append((p, q))\n            self._grid_insert(other_grid, q)\n            throttles[cell] = throttles.get(cell, 0) + 1\n            if (len(other_tree) % 20) == 0:\n                anchors.append(q)\n\n            self._compress_to_ancestors(q, edges, 1)\n            # local light rewiring\n            self._rewire_neighbors(other_grid, q, self._rewire_radius(len(nodes)), edges)\n\n            if self._edge_free(new_node.position, q.position):\n                path = self._extract_path(new_node, q)\n                return True, self._ensure_bounds_and_valid(path)\n\n            p = q\n            last_q = q\n            steps += 1\n        return False, []\n\n    def _pair_key(self, c1, c2):\n        return (c1, c2) if c1 <= c2 else (c2, c1)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return pa + pb[::-1]\n\n    def _ensure_bounds_and_valid(self, path):\n        return [self._clamp(p) for p in path]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # Post smoothing\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_improve = 0\n        best_len = self._path_len(pts)\n        while attempts < self.smoothing_iters:\n            i = int(self._rand_range(0, max(1, len(pts) - 2)))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                attempts += 1\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best_len + 1e-12:\n                    pts = new_pts\n                    best_len = L\n                    no_improve = 0\n                else:\n                    no_improve += 1\n            else:\n                no_improve += 1\n            attempts += 1\n            if no_improve >= self.no_improve_stop:\n                break\n        return pts\n\n    def _los_collapse(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = [path[0]]\n        last = path[0]\n        k = 1\n        while k < len(path) - 1:\n            nxt = path[k + 1]\n            if self._edge_free(last, nxt):\n                k += 1\n                continue\n            pts.append(path[k])\n            last = path[k]\n            k += 1\n        pts.append(path[-1])\n        return pts",
                "objective": -29.84258,
                "time_improvement": 46.0,
                "length_improvement": 12.0,
                "smoothness_improvement": 1759.0,
                "node_improvement": 89.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.013257336616516114,
                        "num_nodes_avg": 49.0,
                        "path_length_avg": 163.59788282479164,
                        "smoothness_avg": 0.10284552152668414,
                        "success_improvement": 0.0,
                        "time_improvement": 48.00798880221262,
                        "node_improvement": 87.6605389070763,
                        "length_improvement": 10.329408049384693,
                        "smoothness_improvement": 1509.7557445171647,
                        "objective_score": 28.148820192880425
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.01610586643218994,
                        "num_nodes_avg": 62.0,
                        "path_length_avg": 241.62656852319907,
                        "smoothness_avg": 0.0921645090196098,
                        "success_improvement": 0.0,
                        "time_improvement": 89.9462328864473,
                        "node_improvement": 95.83417321776524,
                        "length_improvement": 19.338096591802515,
                        "smoothness_improvement": 2271.4592004871693,
                        "objective_score": 49.944023823451545
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.048529839515686034,
                        "num_nodes_avg": 126.0,
                        "path_length_avg": 141.44566627862946,
                        "smoothness_avg": 0.12548275222835503,
                        "success_improvement": 0.0,
                        "time_improvement": 1.0637827328513305,
                        "node_improvement": 83.97965670692943,
                        "length_improvement": 6.058523376571766,
                        "smoothness_improvement": 1496.1313461713685,
                        "objective_score": 11.4349055766553
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m2",
                "algorithm_description": "FLASH-ABiRC: Fast Heuristic Anytime Smooth Hybrid BiRRT-Connect. It alternates growth of two trees with ring-grid nearest lookup, strict mandatory node/edge collision checks, near-duplicate suppression, and on-the-fly line-of-sight compression to reduce bends and depth. After the first feasible bridge, it applies bounded visibility pruning and few shortcuts and returns immediately. If a path exists, informed ellipse/tube sampling with an f-gate refocuses expansions; connection attempts use a direct check plus at most two micro-steps, minimizing collision checks and variance.",
                "planning_mechanism": "Alternate bi-directional expansions: sample (uniform/line; then ellipse/tube after first path), ring-grid nearest, single-step steer, mandatory node/edge checks, optional compression to ancestor if visible, insert. Try direct opposite-tree connect, else extend the other tree a couple of steps with the same checks. On bridge: stitch, prune by visibility, few shortcuts, return. Throughout, use spatial hashes for nodes/obstacles, cached segment-box tests, f-gated pruning when an incumbent cost exists.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        cur = self\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3200,\n                 step_size=7.0,\n                 goal_bias=0.12,\n                 line_bias=0.35,\n                 informed_bias=0.6,\n                 tube_bias=0.35,\n                 cell_factor=1.2,\n                 min_sep_factor=0.55,\n                 ring_max=2,\n                 connect_hops=2,\n                 heur_gate=1.08,\n                 prune_iters=1,\n                 shortcut_trials=28):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.informed_bias = float(informed_bias)\n        self.tube_bias = float(tube_bias)\n        self.cell_factor = float(cell_factor)\n        self.min_sep_factor = float(min_sep_factor)\n        self.ring_max = int(ring_max)\n        self.connect_hops = int(connect_hops)\n        self.heur_gate = float(heur_gate)\n        self.prune_iters = int(prune_iters)\n        self.shortcut_trials = int(shortcut_trials)\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Build obstacle grid and caches\n        self._edge_cache = {}\n        self.obs_cell = max(3.0, self.step_size)\n        self._build_obs_grid()\n\n        # Node checks for start/goal\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            s = Node(self.start, None, 0.0)\n            g = Node(self.goal, s, self._dist(self.start, self.goal))\n            s.add_child(g)\n            nodes.extend([s, g])\n            edges.append((s, g))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Derived params\n        self.cell = max(1.0, self.cell_factor * self.step_size)\n        self.min_sep = max(0.5, self.min_sep_factor * self.step_size)\n        sg = self._dist(self.start, self.goal)\n        self.corridor_w = max(self.step_size, 0.18 * sg)\n\n        # Trees\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, a_root)\n        self._grid_add(Gb, b_root)\n\n        best_path = None\n        c_best = float('inf')\n        informed = False\n\n        for it in range(self.max_iter):\n            grow_a = (it % 2 == 0)\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            root_x = a_root if grow_a else b_root\n            root_y = b_root if grow_a else a_root\n            attractor = self.goal if grow_a else self.start\n\n            # Sample\n            xr = None\n            r = self._rand()\n            if informed and r < self.informed_bias and c_best < float('inf'):\n                xr = self._sample_ellipse(root_x.position, root_y.position, c_best)\n            if xr is None:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    xr = attractor\n                elif r2 < self.goal_bias + self.line_bias:\n                    xr = self._sample_corridor(root_x.position, root_y.position, self.corridor_w)\n                elif informed and self._rand() < self.tube_bias and best_path is not None:\n                    xr = self._sample_tube(best_path)\n                else:\n                    xr = self._sample_uniform()\n            xr = self._clamp(xr)\n            if self._point_blocked(xr):\n                continue\n\n            # Nearest and steer\n            n_near = self._nearest(G, T, xr)\n            if n_near is None:\n                continue\n            x_new_pos = self._steer(n_near.position, xr, self.step_size)\n            if not self._in_bounds(x_new_pos):\n                continue\n            if self._point_blocked(x_new_pos):\n                continue\n            if self._near_duplicate(G, x_new_pos, self.min_sep):\n                continue\n\n            # Heuristic gate\n            if informed and c_best < float('inf'):\n                g_tent = n_near.cost + self._dist(n_near.position, x_new_pos)\n                f = g_tent + self._dist(x_new_pos, root_y.position)\n                if f >= self.heur_gate * c_best:\n                    continue\n\n            # Edge check to nearest; if ok, try one-hop compression to parent\n            if not self._edge_free(n_near.position, x_new_pos):\n                continue\n            parent = n_near\n            if n_near.parent is not None:\n                cand_p = n_near.parent\n                if self._edge_free(cand_p.position, x_new_pos):\n                    parent = cand_p\n\n            # Mandatory checks before insertion (node and edge)\n            if self._point_blocked(x_new_pos):\n                continue\n            if not self._edge_free(parent.position, x_new_pos):\n                continue\n\n            new_cost = parent.cost + self._dist(parent.position, x_new_pos)\n            x_new = Node(x_new_pos, parent, new_cost)\n            parent.add_child(x_new)\n            T.append(x_new)\n            nodes.append(x_new)\n            edges.append((parent, x_new))\n            self._grid_add(G, x_new)\n\n            # Try connect to opposite tree: direct then micro-hops\n            q_opp = self._nearest(Gopp, Topp, x_new.position)\n            bridged = None\n            if q_opp is not None and self._edge_free(x_new.position, q_opp.position):\n                bridged = q_opp\n            else:\n                head = q_opp\n                hops = 0\n                while head is not None and hops < self.connect_hops:\n                    step_pos = self._steer(head.position, x_new.position, self.step_size)\n                    if not self._in_bounds(step_pos) or self._point_blocked(step_pos):\n                        break\n                    if self._near_duplicate(Gopp, step_pos, self.min_sep):\n                        break\n                    # f-gate for opposite step\n                    if informed and c_best < float('inf'):\n                        g_hat = head.cost + self._dist(head.position, step_pos)\n                        f_hat = g_hat + self._dist(step_pos, root_x.position)\n                        if f_hat >= self.heur_gate * c_best:\n                            break\n                    # parent is head, try compression to its parent if visible\n                    par = head\n                    if head.parent is not None and self._edge_free(head.parent.position, step_pos):\n                        par = head.parent\n                    if not self._edge_free(par.position, step_pos):\n                        break\n                    q = Node(step_pos, par, par.cost + self._dist(par.position, step_pos))\n                    par.add_child(q)\n                    Topp.append(q)\n                    nodes.append(q)\n                    edges.append((par, q))\n                    self._grid_add(Gopp, q)\n                    head = q\n                    hops += 1\n                    if self._edge_free(head.position, x_new.position):\n                        bridged = head\n                        break\n\n            if bridged is not None:\n                # Assemble path\n                if grow_a:\n                    pa = x_new.path_from_root()\n                    pb = bridged.path_from_root()\n                    if pa and pb and pa[0] == pb[-1]:\n                        pb = pb[:-1]\n                    path = pa + pb[::-1]\n                else:\n                    pa = x_new.path_from_root()\n                    pb = bridged.path_from_root()\n                    if pb and pa and pb[0] == pa[-1]:\n                        pa = pa[:-1]\n                    path = pb + pa[::-1]\n\n                # Prune and shortcut (bounded)\n                for _ in range(max(1, self.prune_iters)):\n                    path = self._visibility_prune(path)\n                path = self._shortcut(path, self.shortcut_trials)\n\n                L = self._path_len(path)\n                best_path = path\n                c_best = L\n                informed = True\n                return PlannerResult(True, best_path, nodes, edges)\n\n            # Opportunistic incumbent from visible nearest other\n            if q_opp is not None and self._edge_free(x_new.position, q_opp.position):\n                cand = (x_new.path_from_root() + q_opp.path_from_root()[-2::-1]) if (x_new.path_from_root() and q_opp.path_from_root()) else None\n                if cand:\n                    Lc = self._path_len(cand)\n                    if Lc + 1e-9 < c_best:\n                        c_best = Lc\n                        best_path = cand\n                        informed = True\n\n        # No bridge found within budget; return best known (if any)\n        if best_path is not None and len(best_path) >= 2:\n            best_path = self._visibility_prune(best_path)\n            best_path = self._shortcut(best_path, max(12, self.shortcut_trials // 2))\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and basic geometry\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5 if s > 0.0 else 0.0\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        r = step / max(1e-12, d)\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Sampling\n    def _sample_uniform(self):\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _sample_corridor(self, a, b, width):\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n        if self.dim == 2:\n            dx, dy = b[0] - a[0], b[1] - a[1]\n            n = (dx*dx + dy*dy) ** 0.5\n            if n < 1e-12:\n                return self._sample_uniform()\n            vx, vy = dx / n, dy / n\n            px, py = -vy, vx\n            mag = self._uniform(-width, width)\n            return self._clamp((base[0] + px * mag, base[1] + py * mag))\n        else:\n            ab = (b[0]-a[0], b[1]-a[1], b[2]-a[2])\n            n = (ab[0]**2 + ab[1]**2 + ab[2]**2) ** 0.5\n            if n < 1e-12:\n                return self._sample_uniform()\n            v = (ab[0]/n, ab[1]/n, ab[2]/n)\n            r = (self._uniform(-1.0, 1.0), self._uniform(-1.0, 1.0), self._uniform(-1.0, 1.0))\n            dot = r[0]*v[0] + r[1]*v[1] + r[2]*v[2]\n            u = (r[0]-dot*v[0], r[1]-dot*v[1], r[2]-dot*v[2])\n            un = (u[0]**2 + u[1]**2 + u[2]**2) ** 0.5\n            if un < 1e-12:\n                u = (v[1], -v[0], 0.0)\n                un = (u[0]**2 + u[1]**2 + u[2]**2) ** 0.5\n            u = (u[0]/un, u[1]/un, u[2]/un)\n            mag = self._uniform(-width, width)\n            return self._clamp((base[0] + u[0]*mag, base[1] + u[1]*mag, base[2] + u[2]*mag))\n\n    def _sample_ellipse(self, a, b, c_best):\n        if c_best == float('inf'):\n            return None\n        for _ in range(24):\n            p = self._sample_uniform()\n            if self._dist(p, a) + self._dist(p, b) <= c_best + 1e-9 and not self._point_blocked(p):\n                return p\n        return None\n\n    def _sample_tube(self, path):\n        if not path or len(path) < 2:\n            return self._sample_uniform()\n        i = int(self._uniform(0, len(path) - 1))\n        if i >= len(path) - 1:\n            i = len(path) - 2\n        a = path[i]\n        b = path[i + 1]\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[d] + t * (b[d] - a[d]) for d in range(self.dim))\n        rad = 0.7 * self.step_size\n        if self.dim == 2:\n            return self._clamp((base[0] + self._uniform(-rad, rad),\n                                base[1] + self._uniform(-rad, rad)))\n        else:\n            return self._clamp((base[0] + self._uniform(-rad, rad),\n                                base[1] + self._uniform(-rad, rad),\n                                base[2] + self._uniform(-rad, rad)))\n\n    # Node spatial grid\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, self.ring_max + 1):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                found = True\n                break\n        if not found:\n            step = max(1, len(tree) // 64) if tree else 1\n            for i in range(0, len(tree), step):\n                n = tree[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, radius):\n        cand = self._collect_ring(grid, self._grid_key(pos), 1)\n        rr = radius + 1e-9\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # Obstacles grid and collision checks\n    def _build_obs_grid(self):\n        self.obs_grid = {}\n        if self.dim == 3:\n            for idx, o in enumerate(self.obstacles):\n                ox, oy, oz, w, h, d = o\n                ix0 = int(max(0.0, ox) // self.obs_cell)\n                iy0 = int(max(0.0, oy) // self.obs_cell)\n                iz0 = int(max(0.0, oz) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], ox + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], oy + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], oz + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obs_grid.get(key)\n                            if b is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                ox, oy, w, h = o\n                ix0 = int(max(0.0, ox) // self.obs_cell)\n                iy0 = int(max(0.0, oy) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], ox + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], oy + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obs_grid.get(key)\n                        if b is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_blocked(self, p):\n        if self.dim == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_free(self, a, b):\n        k = self._edge_key(a, b)\n        c = self._edge_cache.get(k)\n        if c is not None:\n            return c\n        hit = self._segment_hits(a, b)\n        self._edge_cache[k] = not hit\n        return not hit\n\n    def _segment_hits(self, a, b):\n        if self.dim == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                if self._seg_box_hit3d(a, b, self.obstacles[idx]):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                if self._seg_box_hit2d(a, b, self.obstacles[idx]):\n                    return True\n            return False\n\n    def _seg_box_hit2d(self, a, b, box):\n        x, y, w, h = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        t0, t1 = 0.0, 1.0\n        ax, ay = a\n        bx, by = b\n        dx = bx - ax\n        dy = by - ay\n\n        if abs(dx) < 1e-12:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            tA = (minx - ax) * inv\n            tB = (maxx - ax) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n\n        if abs(dy) < 1e-12:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            tA = (miny - ay) * inv\n            tB = (maxy - ay) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n\n        return t1 >= 0.0 and t0 <= 1.0\n\n    def _seg_box_hit3d(self, a, b, box):\n        x, y, z, w, h, d = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        minz, maxz = z, z + d\n        t0, t1 = 0.0, 1.0\n        ax, ay, az = a\n        bx, by, bz = b\n        dx = bx - ax\n        dy = by - ay\n        dz = bz - az\n\n        if abs(dx) < 1e-12:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            tA = (minx - ax) * inv\n            tB = (maxx - ax) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n\n        if abs(dy) < 1e-12:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            tA = (miny - ay) * inv\n            tB = (maxy - ay) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n\n        if abs(dz) < 1e-12:\n            if az < minz or az > maxz:\n                return False\n        else:\n            inv = 1.0 / dz\n            tA = (minz - az) * inv\n            tB = (maxz - az) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n\n        return t1 >= 0.0 and t0 <= 1.0\n\n    # Path utils\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = list(path)\n        n = len(pts)\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 2, n))\n            a = pts[i]\n            b = pts[j - 1]\n            if self._edge_free(a, b):\n                pts = pts[:i + 1] + pts[j - 1:]\n                n = len(pts)\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L",
                "objective": -38.87335,
                "time_improvement": 75.0,
                "length_improvement": 12.0,
                "smoothness_improvement": 1876.0,
                "node_improvement": 88.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.006264138221740723,
                        "num_nodes_avg": 56.7,
                        "path_length_avg": 171.88502102126137,
                        "smoothness_avg": 0.04966818877179101,
                        "success_improvement": 0.0,
                        "time_improvement": 75.09701035598583,
                        "node_improvement": 85.72148073533116,
                        "length_improvement": 5.78709628579148,
                        "smoothness_improvement": 677.4150104767455,
                        "objective_score": 29.388435930654364
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.02297062873840332,
                        "num_nodes_avg": 122.2,
                        "path_length_avg": 242.80866792108137,
                        "smoothness_avg": 0.11993325646889634,
                        "success_improvement": 0.0,
                        "time_improvement": 85.662236374922,
                        "node_improvement": 91.78928979372438,
                        "length_improvement": 18.943477787944797,
                        "smoothness_improvement": 2985.9690733776524,
                        "objective_score": 51.99460295213174
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.017574667930603027,
                        "num_nodes_avg": 116.3,
                        "path_length_avg": 134.8321489290259,
                        "smoothness_avg": 0.1622613841577103,
                        "success_improvement": 0.0,
                        "time_improvement": 63.82230532897514,
                        "node_improvement": 85.2129688493325,
                        "length_improvement": 10.450906698324257,
                        "smoothness_improvement": 1963.9528295965463,
                        "objective_score": 35.23699976566982
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "GLOW-RRTC*: Guided Lightweight Optimal-Rewire BiRRT-Connect. A simple, general bi-directional planner using ring-grid nearest search, cost-aware parent selection, shrinking local rewiring, and corridor-biased sampling. Each insertion enforces strict node and edge validity, performs short line-of-sight compression, then attempts an adaptive micro-connect to the opposite tree. On bridge, greedy visibility pruning and a few shortcuts yield short, smooth paths quickly while keeping the design compact and robust.",
            "planning_mechanism": "Alternate tree growth. Sample (uniform/goal/corridor), find nearest via ring-grid, steer one step, choose the cheapest feasible parent among local neighbors, validate node and edge, insert, compress to a visible ancestor, and rewire nearby nodes with a decaying radius. Try direct connection to the opposite tree, else extend it a few micro-steps with the same checks. On bridge, stitch, prune by visibility, shortcut, return.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        path = []\n        cur = self\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3500,\n                 step_size=8.0,\n                 goal_bias=0.15,\n                 corridor_bias=0.45,\n                 cell_factor=1.0,\n                 min_sep_factor=0.4,\n                 connect_steps=3,\n                 rewire_gamma=2.0,\n                 neighbor_cap=32,\n                 prune_iters=1,\n                 shortcut_attempts=40,\n                 edge_cache_cap=40000):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.cell_factor = float(cell_factor)\n        self.min_sep_factor = float(min_sep_factor)\n        self.connect_steps = int(connect_steps)\n        self.rewire_gamma = float(rewire_gamma)\n        self.neighbor_cap = int(neighbor_cap)\n        self.prune_iters = int(prune_iters)\n        self.shortcut_attempts = int(shortcut_attempts)\n        self.edge_cache_cap = int(edge_cache_cap)\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Build obstacle grid and edge cache\n        self.obs_cell = max(3.0, self.step_size)\n        self._build_obs_grid()\n        self._edge_cache = {}\n\n        # Validate endpoints\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            s = Node(self.start, None, 0.0)\n            g = Node(self.goal, s, self._dist(self.start, self.goal))\n            s.add_child(g)\n            nodes.extend([s, g])\n            edges.append((s, g))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Spatial node grid\n        self.cell = max(1.0, self.cell_factor * self.step_size)\n        self.min_sep = max(0.5, self.min_sep_factor * self.step_size)\n\n        # Trees A/B\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, a_root)\n        self._grid_add(Gb, b_root)\n        nodes.extend([a_root, b_root])\n\n        best_path = None\n        best_cost = float('inf')\n        sg = self._dist(self.start, self.goal)\n        corridor_w = max(self.step_size, 0.2 * sg)\n\n        for it in range(self.max_iter):\n            grow_a = (it % 2 == 0)\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n            root_y = b_root if grow_a else a_root\n\n            # Sample\n            xr = None\n            r = self._rand()\n            if r < self.goal_bias:\n                xr = attractor\n            elif best_path is not None and self._rand() < self.corridor_bias:\n                xr = self._sample_corridor(self.start, self.goal, corridor_w)\n            else:\n                xr = self._sample_uniform()\n            xr = self._clamp(xr)\n            if not self._in_bounds(xr) or self._point_blocked(xr):\n                continue\n\n            # Nearest and steer\n            n_near = self._nearest(G, T, xr)\n            if n_near is None:\n                continue\n            x_new_pos = self._steer(n_near.position, xr, self.step_size)\n            if not self._in_bounds(x_new_pos) or self._point_blocked(x_new_pos):\n                continue\n            if self._near_duplicate(G, x_new_pos, self.min_sep):\n                continue\n\n            # Cost-aware parent selection among local neighbors\n            radius = self._rewire_radius(len(nodes))\n            cand = self._candidate_parents(G, T, x_new_pos, radius, self.neighbor_cap)\n            best_parent = None\n            best_new_cost = 1e100\n            for p in cand:\n                if not self._edge_free(p.position, x_new_pos):\n                    continue\n                gc = p.cost + self._dist(p.position, x_new_pos)\n                if gc < best_new_cost:\n                    best_new_cost = gc\n                    best_parent = p\n            if best_parent is None:\n                continue\n\n            # Mandatory checks before insertion\n            if self._point_blocked(x_new_pos):\n                continue\n            if not self._edge_free(best_parent.position, x_new_pos):\n                continue\n\n            x_new = Node(x_new_pos, best_parent, best_new_cost)\n            best_parent.add_child(x_new)\n            T.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n            self._grid_add(G, x_new)\n\n            # Short line-of-sight compression to ancestor\n            self._compress_one_step(x_new, edges)\n\n            # Local rewiring\n            self._rewire_neighbors(G, x_new, radius, edges)\n\n            # Try to bridge\n            q_opp = self._nearest(Gopp, Topp, x_new.position)\n            bridged = None\n            if q_opp is not None and self._edge_free(x_new.position, q_opp.position):\n                bridged = q_opp\n            else:\n                head = q_opp\n                hops = 0\n                last = head\n                while head is not None and hops < self.connect_steps:\n                    step_pos = self._steer(head.position, x_new.position, self.step_size)\n                    if not self._in_bounds(step_pos) or self._point_blocked(step_pos):\n                        break\n                    if self._near_duplicate(Gopp, step_pos, self.min_sep):\n                        break\n                    par = head\n                    if par.parent is not None and self._edge_free(par.parent.position, step_pos):\n                        par = par.parent\n                    if not self._edge_free(par.position, step_pos):\n                        break\n                    # Node and edge checks passed, insert\n                    q = Node(step_pos, par, par.cost + self._dist(par.position, step_pos))\n                    par.add_child(q)\n                    Topp.append(q)\n                    nodes.append(q)\n                    edges.append((par, q))\n                    self._grid_add(Gopp, q)\n                    self._compress_one_step(q, edges)\n                    self._rewire_neighbors(Gopp, q, self._rewire_radius(len(nodes)), edges)\n                    if self._edge_free(q.position, x_new.position):\n                        bridged = q\n                        break\n                    head = q\n                    last = q\n                    hops += 1\n\n            if bridged is not None:\n                if grow_a:\n                    pa = x_new.path_from_root()\n                    pb = bridged.path_from_root()\n                    if pa and pb and pa[0] == pb[-1]:\n                        pb = pb[:-1]\n                    path = pa + pb[::-1]\n                else:\n                    pa = x_new.path_from_root()\n                    pb = bridged.path_from_root()\n                    if pb and pa and pb[0] == pa[-1]:\n                        pa = pa[:-1]\n                    path = pb + pa[::-1]\n\n                for _ in range(max(1, self.prune_iters)):\n                    path = self._visibility_prune(path)\n                path = self._shortcut(path, self.shortcut_attempts)\n\n                best_path = path\n                best_cost = self._path_len(path)\n                return PlannerResult(True, best_path, nodes, edges)\n\n        if best_path is not None:\n            for _ in range(max(1, self.prune_iters)):\n                best_path = self._visibility_prune(best_path)\n            best_path = self._shortcut(best_path, max(12, self.shortcut_attempts // 2))\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and geometry\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5 if s > 0.0 else 0.0\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        r = step / max(d, 1e-12)\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Sampling\n    def _sample_uniform(self):\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _sample_corridor(self, s, g, width):\n        t = self._uniform(0.0, 1.0)\n        base = tuple(s[i] + (g[i] - s[i]) * t for i in range(self.dim))\n        if self.dim == 2:\n            dx, dy = g[0] - s[0], g[1] - s[1]\n            n = (dx*dx + dy*dy) ** 0.5\n            if n < 1e-12:\n                return self._sample_uniform()\n            vx, vy = dx / n, dy / n\n            px, py = -vy, vx\n            mag = self._uniform(-width, width)\n            return self._clamp((base[0] + px * mag, base[1] + py * mag))\n        else:\n            ab = (g[0]-s[0], g[1]-s[1], g[2]-s[2])\n            n = (ab[0]**2 + ab[1]**2 + ab[2]**2) ** 0.5\n            if n < 1e-12:\n                return self._sample_uniform()\n            v = (ab[0]/n, ab[1]/n, ab[2]/n)\n            r = (self._uniform(-1.0, 1.0), self._uniform(-1.0, 1.0), self._uniform(-1.0, 1.0))\n            dot = r[0]*v[0] + r[1]*v[1] + r[2]*v[2]\n            u = (r[0]-dot*v[0], r[1]-dot*v[1], r[2]-dot*v[2])\n            un = (u[0]**2 + u[1]**2 + u[2]**2) ** 0.5\n            if un < 1e-12:\n                u = (v[1], -v[0], 0.0)\n                un = (u[0]**2 + u[1]**2 + u[2]**2) ** 0.5\n            u = (u[0]/un, u[1]/un, u[2]/un)\n            mag = self._uniform(-width, width)\n            return self._clamp((base[0] + u[0]*mag, base[1] + u[1]*mag, base[2] + u[2]*mag))\n\n    # Node spatial grid\n    def _gkey(self, pos):\n        if self.dim == 3:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        else:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._gkey(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._gkey(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, 3):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                found = True\n                break\n        if not found:\n            step = max(1, len(tree) // 64) if tree else 1\n            for i in range(0, len(tree), step):\n                n = tree[i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._gkey(pos)\n        cand = self._collect_ring(grid, key, 1)\n        rr = radius + 1e-9\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    def _candidate_parents(self, grid, tree, pos, radius, cap):\n        key = self._gkey(pos)\n        r_cells = max(1, int(radius // self.cell) + 1)\n        cand = self._collect_ring(grid, key, r_cells)\n        if not cand:\n            cand = tree[:min(len(tree), cap)]\n        if len(cand) > cap:\n            # reservoir-like\n            out = []\n            seen = 0\n            for n in cand:\n                seen += 1\n                if len(out) < cap:\n                    out.append(n)\n                else:\n                    j = int(self._uniform(0, seen))\n                    if j < len(out):\n                        out[j] = n\n            cand = out\n        return cand\n\n    # Obstacle grid and collision checks\n    def _build_obs_grid(self):\n        self.obs_grid = {}\n        if self.dim == 3:\n            for idx, o in enumerate(self.obstacles):\n                ox, oy, oz, w, h, d = o\n                ix0 = int(max(0.0, ox) // self.obs_cell)\n                iy0 = int(max(0.0, oy) // self.obs_cell)\n                iz0 = int(max(0.0, oz) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], ox + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], oy + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], oz + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obs_grid.get(key)\n                            if b is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                ox, oy, w, h = o\n                ix0 = int(max(0.0, ox) // self.obs_cell)\n                iy0 = int(max(0.0, oy) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], ox + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], oy + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obs_grid.get(key)\n                        if b is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_blocked(self, p):\n        if self.dim == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_free(self, a, b):\n        k = self._edge_key(a, b)\n        c = self._edge_cache.get(k)\n        if c is not None:\n            return c\n        hit = self._segment_hits(a, b)\n        ok = not hit\n        if len(self._edge_cache) > self.edge_cache_cap:\n            i = 0\n            # prune roughly a third\n            for kk in list(self._edge_cache.keys()):\n                if (i % 3) == 0:\n                    try:\n                        del self._edge_cache[kk]\n                    except:\n                        pass\n                i += 1\n        self._edge_cache[k] = ok\n        return ok\n\n    def _segment_hits(self, a, b):\n        if self.dim == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            iz0 = int(max(0.0, minz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obs_grid.get((i, j, k))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                if self._seg_box_hit3d(a, b, self.obstacles[idx]):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, minx) // self.obs_cell)\n            iy0 = int(max(0.0, miny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obs_grid.get((i, j))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                if self._seg_box_hit2d(a, b, self.obstacles[idx]):\n                    return True\n            return False\n\n    def _seg_box_hit2d(self, a, b, box):\n        x, y, w, h = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        t0, t1 = 0.0, 1.0\n        ax, ay = a\n        bx, by = b\n        dx = bx - ax\n        dy = by - ay\n        if abs(dx) < 1e-12:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            tA = (minx - ax) * inv\n            tB = (maxx - ax) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n        if abs(dy) < 1e-12:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            tA = (miny - ay) * inv\n            tB = (maxy - ay) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n        return t1 >= 0.0 and t0 <= 1.0\n\n    def _seg_box_hit3d(self, a, b, box):\n        x, y, z, w, h, d = box\n        minx, maxx = x, x + w\n        miny, maxy = y, y + h\n        minz, maxz = z, z + d\n        t0, t1 = 0.0, 1.0\n        ax, ay, az = a\n        bx, by, bz = b\n        dx = bx - ax\n        dy = by - ay\n        dz = bz - az\n        if abs(dx) < 1e-12:\n            if ax < minx or ax > maxx:\n                return False\n        else:\n            inv = 1.0 / dx\n            tA = (minx - ax) * inv\n            tB = (maxx - ax) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n        if abs(dy) < 1e-12:\n            if ay < miny or ay > maxy:\n                return False\n        else:\n            inv = 1.0 / dy\n            tA = (miny - ay) * inv\n            tB = (maxy - ay) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n        if abs(dz) < 1e-12:\n            if az < minz or az > maxz:\n                return False\n        else:\n            inv = 1.0 / dz\n            tA = (minz - az) * inv\n            tB = (maxz - az) * inv\n            if tA > tB:\n                tA, tB = tB, tA\n            if tA > t0:\n                t0 = tA\n            if tB < t1:\n                t1 = tB\n            if t0 > t1:\n                return False\n        return t1 >= 0.0 and t0 <= 1.0\n\n    # RRT* utilities\n    def _rewire_radius(self, n_nodes):\n        base = self.rewire_gamma * self.step_size / ((1.0 + 0.05 * max(1, n_nodes)) ** (1.0 / max(1, self.dim)))\n        return max(self.step_size, base)\n\n    def _compress_one_step(self, node, edges):\n        p = node.parent\n        if p is None or p.parent is None:\n            return\n        gp = p.parent\n        if self._edge_free(gp.position, node.position):\n            self._reparent(node, gp, edges)\n\n    def _rewire_neighbors(self, grid, node, radius, edges):\n        key = self._gkey(node.position)\n        r_cells = max(1, int(radius // self.cell) + 1)\n        neigh = self._collect_ring(grid, key, r_cells)\n        count = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if d > radius:\n                continue\n            new_cost = node.cost + d\n            if new_cost + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n                count += 1\n                if count >= self.neighbor_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        old_parent = child.parent\n        if old_parent is new_parent:\n            return\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        edges.append((new_parent, child))\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    stack.append(ch)\n\n    # Path utilities\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and n >= 3:\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 2, n))\n            a = pts[i]\n            b = pts[j - 1]\n            if self._edge_free(a, b):\n                pts = pts[:i + 1] + pts[j - 1:]\n                n = len(pts)\n            tries += 1\n        pts[0] = path[0]\n        pts[-1] = path[-1]\n        return pts\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L",
            "objective": -38.95445,
            "time_improvement": 77.0,
            "length_improvement": 14.0,
            "smoothness_improvement": 1518.0,
            "node_improvement": 90.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007930564880371093,
                    "num_nodes_avg": 51.8,
                    "path_length_avg": 172.28898677930243,
                    "smoothness_avg": 0.04557670744519382,
                    "success_improvement": 0.0,
                    "time_improvement": 68.47215561086668,
                    "node_improvement": 86.95542684462352,
                    "length_improvement": 5.5656762525621,
                    "smoothness_improvement": 613.3744429215927,
                    "objective_score": 26.947924649405227
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021958351135253906,
                    "num_nodes_avg": 107.1,
                    "path_length_avg": 236.32664856425262,
                    "smoothness_avg": 0.1094935709665247,
                    "success_improvement": 0.0,
                    "time_improvement": 86.2940778957704,
                    "node_improvement": 92.80387018746221,
                    "length_improvement": 21.107362423836506,
                    "smoothness_improvement": 2717.348446000099,
                    "objective_score": 52.13938305303352
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010874390602111816,
                    "num_nodes_avg": 74.8,
                    "path_length_avg": 129.54877071499192,
                    "smoothness_avg": 0.10402004857719598,
                    "success_improvement": 0.0,
                    "time_improvement": 77.61491798934009,
                    "node_improvement": 90.4895104895105,
                    "length_improvement": 13.95987494065061,
                    "smoothness_improvement": 1223.127339940617,
                    "objective_score": 37.776037060895476
                }
            ],
            "success_rate": 1.0
        },
        "objective": 45.4,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Large/static neighbor radii and coarse/fallback nearest searches led to many neighbor lookups and collision checks per iteration.\n   - Rejection-prone informed sampling and always-on corridor/tube biases wasted samples, especially in narrow or thin feasible regions.\n   - Connection micro-steps appended nodes even when bridging failed, bloating trees and slowing subsequent queries.\n   - Strict duplicate/min-separation thresholds and per-cell admission caps rejected useful insertions, slowing densification near obstacles.\n   - Edge-cache policies either grew unboundedly or suffered from frequent misses due to keying/quantization, increasing collision-check overhead.\n   - Limited or poorly targeted in-loop compression/rewiring left unnecessary intermediates, inflating future nearest/neighbor queries.\n   - Redundant validity/path computations inside hot loops added constant-factor overhead."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Shrinking, radius-limited rewiring with a capped neighbor set to bound neighbor/collision checks.\n   - Low-rejection sampling mix (goal/corridor/uniform) with corridor bias activated only after an incumbent path exists.\n   - Tighter spatial hashing with small-ring nearest lookup and relaxed min-separation to increase acceptance rate.\n   - One-step line-of-sight compression at insertion to remove redundant waypoints early.\n   - Bounded micro-connect with immediate validation and few hops to avoid unproductive growth on failed bridges.\n   - Capacity-limited edge cache with periodic pruning to control memory and keep lookup times stable.\n2. Expected mechanism of impact:\n   - Fewer and cheaper neighbor/edge evaluations per iteration reduce compute time.\n   - Higher sample acceptance and earlier feasible bridges cut the number of iterations to first solution.\n   - Early path simplification keeps trees compact, accelerating nearest/neighbor queries downstream.\n   - Stable, reusable edge-cache entries lower collision-check frequency and cost.\n   - Local rewiring quickly improves partial costs, guiding sampling/connection toward promising regions and shortening search time."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "SAGE-Connect*: Simple Adaptive Grid Explorer with Informed Bidirectional Growth, Gentle Rewiring, and Fast Smoothing. It builds two trees from start and goal using a compact spatial hash, adaptive neighbor radius, LOS-aware stepping, lightweight k-best parenting, capped local rewiring, and a restrained greedy connect. Once a valid bridge is found, the path is shortcut-pruned and elastically smoothed with collision-aware line search for robust, short, and smooth trajectories.",
                "planning_mechanism": "Alternate expanding start/goal trees. Each iteration: draw a target (goal/segment/uniform; switch to informed-ellipse once a path exists), pick nearest via grid, steer with LOS-adaptive step, enforce node and edge collision checks, suppress duplicates, select a low-cost parent from nearby nodes, add the node, and locally rewire a few neighbors if the new route is cheaper (cycle-safe, edge-checked). Attempt a short greedy connect from the other tree; on success, assemble the bidirectional path, then apply shortcutting and visibility pruning followed by elastic midpoint smoothing before returning.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step=6.0,\n        connect_factor=1.9,\n        goal_bias=0.16,\n        line_bias=0.22,\n        informed_bias=0.45,\n        grid_cell_factor=1.6,\n        neighbor_radius_scale=3.0,\n        dupe_ratio=0.4,\n        rewire_cap=12,\n        connect_steps=12,\n        shortcut_attempts=90,\n        smooth_passes=6\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.connect_step = float(step * connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_radius_scale = float(neighbor_radius_scale)\n        self.dupe_ratio = float(dupe_ratio)\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(1, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 123456789\n        self._eindex = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._eindex = {}\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            self._edges_add(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Trees and grids\n        Ta, Tb = [], []\n        Ga, Gb = {}, {}\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta.append(start_root)\n        Tb.append(goal_root)\n        nodes.extend([start_root, goal_root])\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            # Sample a common target for both directions for coherence\n            sample = self._sample_target(best_len)\n            if sample is None:\n                continue\n\n            # Expand from start side\n            res = self._expand_and_maybe_connect(Ta, Ga, Tb, Gb, sample, nodes, edges)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n            # Expand from goal side\n            res = self._expand_and_maybe_connect(Tb, Gb, Ta, Ga, sample, nodes, edges)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # Core expansion and connection\n    def _expand_and_maybe_connect(self, Ta, Ga, Tb, Gb, target, nodes, edges):\n        na = self._nearest(Ga, target)\n        if na is None:\n            return None\n        q_new = self._steer_dynamic(na.position, target)\n        if (not self._in_bounds(q_new)) or self._point_blocked(q_new):\n            return None\n        if self._too_close(Ga, q_new, self.dupe_radius):\n            return None\n\n        parent = self._select_parent(Ga, q_new, na)\n        if parent is None:\n            return None\n        # Both checks before adding node/edge\n        if self._point_blocked(q_new) or (not self._edge_free(parent.position, q_new)):\n            return None\n\n        cost = parent.cost + self._dist(parent.position, q_new)\n        nn = Node(q_new, parent, cost)\n        parent.add_child(nn)\n        Ta.append(nn)\n        nodes.append(nn)\n        self._grid_add(Ga, nn)\n        self._edges_add(edges, parent, nn)\n\n        # Gentle local rewiring\n        if self.rewire_cap > 0:\n            self._rewire_neighbors(Ga, nn, edges, self.rewire_cap)\n\n        # Try greedy connect from the opposite tree\n        meet, ok = self._greedy_connect(Tb, Gb, nn.position, nodes, edges)\n        if ok:\n            pa = nn.path_to_root()\n            pb = meet.path_to_root()\n            # Determine which root belongs to which\n            if Ta[0].position == self.start:\n                # pa: start->..., pb: goal->...\n                path = pa + pb[-2::-1]\n            else:\n                # pa: goal->..., pb: start->...\n                path = pb + pa[-2::-1]\n            L = self._path_len(path)\n            return (self._dedup(path), L)\n        return None\n\n    # RNG\n    def _seed_rng(self):\n        s = 2166136261\n        for v in self.start + self.goal:\n            s ^= int(v * 10007 + 0.5) & 0xffffffff\n            s = (s * 16777619) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Sampling\n    def _sample_target(self, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._sample_informed_ellipse(self.start, self.goal, best_len * 1.01)\n            if p is not None and self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return self.goal\n        if r2 < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t,\n                     self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t)\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_informed_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and (not self._point_blocked(p)):\n                return p\n        return None\n\n    # Geometry helpers\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(self._lerp(a, b, r))\n\n    def _steer_dynamic(self, a, b):\n        if self._edge_free(a, b):\n            d = self._dist(a, b)\n            step = self.connect_step if d > self.connect_step else d\n            return self._steer(a, b, step)\n        return self._steer(a, b, self.step)\n\n    # Node grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n            if best is not None:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        seen = {}\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            i2 = id(n)\n                            if i2 in seen:\n                                continue\n                            seen[i2] = True\n                            d2 = 0.0\n                            p = n.position\n                            for i in range(self.dim):\n                                di = p[i] - pos[i]\n                                d2 += di * di\n                            if d2 <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        i2 = id(n)\n                        if i2 in seen:\n                            continue\n                        seen[i2] = True\n                        d2 = 0.0\n                        p = n.position\n                        for i in range(self.dim):\n                            di = p[i] - pos[i]\n                            d2 += di * di\n                        if d2 <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _adaptive_radius(self, n_nodes):\n        t = float(max(1, n_nodes))\n        base = 1.2 * self.step\n        extra = self.neighbor_radius_scale * self.step / ((1.0 + t) ** (1.0 / 3.0))\n        r = base + extra\n        if r < 1.05 * self.step:\n            r = 1.05 * self.step\n        return r\n\n    def _too_close(self, grid, pos, radius):\n        nb = self._neighbors_within(grid, pos, radius, 1)\n        return len(nb) > 0\n\n    # Parent selection\n    def _select_parent(self, grid, newp, fallback_near):\n        r = self._adaptive_radius(len(grid))\n        neigh = self._neighbors_within(grid, newp, r, 96)\n        best = fallback_near\n        best_cost = fallback_near.cost + self._dist(fallback_near.position, newp)\n        for n in neigh:\n            if n is fallback_near:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = c\n        return best\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _rewire_neighbors(self, grid, node, edges, cap):\n        r = self._adaptive_radius(len(grid))\n        neigh = self._neighbors_within(grid, node.position, r, 128)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            if self._point_blocked(nb.position) or self._point_blocked(node.position):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            newc = node.cost + self._dist(node.position, nb.position)\n            if newc + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= cap:\n                    break\n\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        if self._point_blocked(child.position) or self._point_blocked(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._edges_remove(edges, old, child)\n        new_parent.add_child(child)\n        self._edges_add(edges, new_parent, child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            for c in n.children:\n                stack.append(c)\n\n    # Greedy connect\n    def _greedy_connect(self, T, G, target_pos, nodes, edges):\n        cur = self._nearest(G, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < self.connect_steps:\n            # Visible? insert exact meeting point\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                    if not self._too_close(G, target_pos, 0.75 * self.dupe_radius):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                            return cur, True\n                        cur.add_child(nn)\n                        T.append(nn)\n                        nodes.append(nn)\n                        self._grid_add(G, nn)\n                        self._edges_add(edges, cur, nn)\n                        return nn, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(G, nxt, 0.75 * self.dupe_radius):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                return cur, False\n            cur.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            self._grid_add(G, nn)\n            self._edges_add(edges, cur, nn)\n            cur = nn\n            steps += 1\n        # Final visibility check\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                if not self._too_close(G, target_pos, 0.75 * self.dupe_radius):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                        return cur, True\n                    cur.add_child(nn)\n                    T.append(nn)\n                    nodes.append(nn)\n                    self._grid_add(G, nn)\n                    self._edges_add(edges, cur, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(3.5, self.step * 1.6)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Edge bookkeeping\n    def _edges_add(self, edges, parent, child):\n        key = (id(parent), id(child))\n        if key in self._eindex:\n            return\n        edges.append((parent, child))\n        self._eindex[key] = len(edges) - 1\n\n    def _edges_remove(self, edges, parent, child):\n        key = (id(parent), id(child))\n        idx = self._eindex.get(key)\n        if idx is None:\n            return\n        last = len(edges) - 1\n        if idx != last:\n            edges[idx] = edges[last]\n            pk, ck = id(edges[idx][0]), id(edges[idx][1])\n            self._eindex[(pk, ck)] = idx\n        edges.pop()\n        self._eindex.pop(key, None)\n\n    # Path utilities and smoothing\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _elastic_smooth(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                target = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                t = 1.0\n                best = b\n                while t > 1e-3:\n                    cand = tuple(b[k] + (target[k] - b[k]) * t for k in range(self.dim))\n                    cand = self._clamp(cand)\n                    if (not self._point_blocked(cand)) and self._edge_free(a, cand) and self._edge_free(cand, c):\n                        best = cand\n                        break\n                    t *= 0.5\n                if best != b:\n                    cur[i] = best\n                    moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._shortcut(path, self.shortcut_attempts)\n        p2 = self._visibility_prune(p1)\n        p3 = self._elastic_smooth(p2, self.smooth_passes)\n        return self._dedup(p3)",
                "objective": -47.53913,
                "time_improvement": 86.0,
                "length_improvement": 21.0,
                "smoothness_improvement": 1812.0,
                "node_improvement": 93.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.004579019546508789,
                        "num_nodes_avg": 30.0,
                        "path_length_avg": 146.96078572191126,
                        "smoothness_avg": 0.03859037591406768,
                        "success_improvement": 0.0,
                        "time_improvement": 81.43988774523116,
                        "node_improvement": 92.44522790229162,
                        "length_improvement": 19.448464603147585,
                        "smoothness_improvement": 504.0231833977275,
                        "objective_score": 38.621161002446534
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.023305273056030272,
                        "num_nodes_avg": 122.0,
                        "path_length_avg": 229.66193713526982,
                        "smoothness_avg": 0.11885248032537557,
                        "success_improvement": 0.0,
                        "time_improvement": 86.065738755588,
                        "node_improvement": 91.80272794463482,
                        "length_improvement": 23.332234931912975,
                        "smoothness_improvement": 2958.1599247532718,
                        "objective_score": 54.609862209590545
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.004154682159423828,
                        "num_nodes_avg": 32.0,
                        "path_length_avg": 120.49632735979439,
                        "smoothness_avg": 0.1630888303105967,
                        "success_improvement": 0.0,
                        "time_improvement": 91.76911192279043,
                        "node_improvement": 95.93134138588684,
                        "length_improvement": 19.972076786142434,
                        "smoothness_improvement": 1974.4778835855395,
                        "objective_score": 49.38636906645029
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "FLASH-Connect: Fast Hash-grid Bidirectional RRT with Direct-Visible Steer and Exact Join. It minimizes planning time via visibility-first stepping, exact meeting insertion, informed sampling after first solution, node-count-based neighbor radii, and zero-cost rewiring (parent selection only). Lightweight shortcutting and visibility pruning finalize paths quickly.",
            "planning_mechanism": "Grow two trees toward common samples using a spatial hash for O(1) neighborhood queries. At each expansion, directly jump to the target if the edge is free; otherwise take a bounded step. Choose the lowest-cost feasible parent from nearby nodes (radius scales with the true node count, not grid cells). After inserting the node (with both node and edge collision checks), greedily connect the opposite tree, requiring insertion of the exact meeting node for a kink-free bridge. Once connected, concatenate the two root-to-meet paths and apply fast shortcutting and visibility pruning.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step=7.0,\n        connect_factor=3.0,\n        goal_bias=0.2,\n        line_bias=0.3,\n        informed_bias=0.5,\n        grid_cell_factor=2.0,\n        neighbor_radius_scale=2.2,\n        dupe_ratio=0.5,\n        connect_steps=28,\n        shortcut_attempts=60,\n        smooth_passes=1\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.connect_step = float(step * connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_radius_scale = float(neighbor_radius_scale)\n        self.dupe_ratio = float(dupe_ratio)\n        self.connect_steps = int(max(1, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 123456789\n        self._eindex = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._eindex = {}\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            self._edges_add(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and grids\n        Ta, Tb = [], []\n        Ga, Gb = {}, {}\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        Ta.append(root_a)\n        Tb.append(root_b)\n        nodes.extend([root_a, root_b])\n        self._grid_add(Ga, root_a)\n        self._grid_add(Gb, root_b)\n\n        best_len = float('inf')\n\n        for _ in range(self.max_iter):\n            target = self._sample_target(best_len)\n            if target is None:\n                continue\n\n            # Expand A then try to connect B\n            na = self._extend_once(Ta, Ga, target, nodes, edges)\n            if na is not None:\n                mb = self._connect_exact(Tb, Gb, na.position, nodes, edges)\n                if mb is not None:\n                    pa = na.path_to_root()\n                    pb = mb.path_to_root()\n                    if root_a.position == self.start:\n                        path = pa + list(reversed(pb[:-1]))\n                    else:\n                        path = pb + list(reversed(pa[:-1]))\n                    best_len = self._path_len(path)\n                    final = self._finalize_path(path)\n                    return PlannerResult(True, final, nodes, edges)\n\n            # Expand B then try to connect A\n            nb = self._extend_once(Tb, Gb, target, nodes, edges)\n            if nb is not None:\n                ma = self._connect_exact(Ta, Ga, nb.position, nodes, edges)\n                if ma is not None:\n                    pa = ma.path_to_root()\n                    pb = nb.path_to_root()\n                    if root_a.position == self.start:\n                        path = pa + list(reversed(pb[:-1]))\n                    else:\n                        path = pb + list(reversed(pa[:-1]))\n                    best_len = self._path_len(path)\n                    final = self._finalize_path(path)\n                    return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # Expansion with visibility-first steer and k-best parent selection\n    def _extend_once(self, T, G, target, nodes, edges):\n        near = self._nearest(G, target)\n        if near is None:\n            return None\n\n        q_new = self._steer_visible(near.position, target)\n        if q_new == near.position:\n            return None\n        if (not self._in_bounds(q_new)) or self._point_blocked(q_new):\n            return None\n        if self._too_close(G, q_new, self.dupe_radius):\n            return None\n\n        parent = self._select_parent(G, T, q_new, near)\n        if parent is None:\n            return None\n\n        # Both checks before adding node/edge\n        if self._point_blocked(q_new) or (not self._edge_free(parent.position, q_new)):\n            return None\n\n        cost = parent.cost + self._dist(parent.position, q_new)\n        nn = Node(q_new, parent, cost)\n        parent.add_child(nn)\n        T.append(nn)\n        nodes.append(nn)\n        self._grid_add(G, nn)\n        self._edges_add(edges, parent, nn)\n        return nn\n\n    # Greedy exact connection to a target position; inserts the meeting node\n    def _connect_exact(self, T, G, target_pos, nodes, edges):\n        # If a node already exists very close to target_pos, return it\n        existing = self._find_node_at(G, target_pos, eps=1e-9)\n        if existing is not None:\n            return existing\n\n        cur = self._nearest(G, target_pos)\n        if cur is None:\n            return None\n\n        # Try direct connection first\n        if self._edge_free(cur.position, target_pos) and (not self._point_blocked(target_pos)) and self._in_bounds(target_pos):\n            new_cost = cur.cost + self._dist(cur.position, target_pos)\n            meet = Node(target_pos, cur, new_cost)\n            # Both checks before adding node/edge\n            if self._point_blocked(meet.position) or (not self._edge_free(cur.position, meet.position)):\n                return None\n            cur.add_child(meet)\n            T.append(meet)\n            nodes.append(meet)\n            self._grid_add(G, meet)\n            self._edges_add(edges, cur, meet)\n            return meet\n\n        # Stepwise attempt\n        steps = 0\n        last = cur\n        while steps < self.connect_steps:\n            nxt = self._steer(last.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return None\n            if not self._edge_free(last.position, nxt):\n                return None\n            if self._too_close(G, nxt, 0.75 * self.dupe_radius):\n                return None\n            new_cost = last.cost + self._dist(last.position, nxt)\n            nn = Node(nxt, last, new_cost)\n            # Both checks before adding node/edge\n            if self._point_blocked(nn.position) or (not self._edge_free(last.position, nn.position)):\n                return None\n            last.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            self._grid_add(G, nn)\n            self._edges_add(edges, last, nn)\n            last = nn\n            steps += 1\n\n            # If final small segment is visible, insert exact meeting node\n            if self._edge_free(last.position, target_pos) and (not self._point_blocked(target_pos)) and self._in_bounds(target_pos):\n                new_cost2 = last.cost + self._dist(last.position, target_pos)\n                meet = Node(target_pos, last, new_cost2)\n                # Both checks before adding node/edge\n                if self._point_blocked(meet.position) or (not self._edge_free(last.position, meet.position)):\n                    return None\n                last.add_child(meet)\n                T.append(meet)\n                nodes.append(meet)\n                self._grid_add(G, meet)\n                self._edges_add(edges, last, meet)\n                return meet\n\n        return None\n\n    # RNG\n    def _seed_rng(self):\n        s = 2166136261\n        for v in self.start + self.goal:\n            s ^= int(v * 10007 + 0.5) & 0xffffffff\n            s = (s * 16777619) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Sampling\n    def _sample_target(self, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._sample_informed_ellipse(self.start, self.goal, best_len * 1.01)\n            if p is not None and self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return self.goal\n        if r2 < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t,\n                     self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t)\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_informed_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and (not self._point_blocked(p)):\n                return p\n        return None\n\n    # Geometry helpers\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(self._lerp(a, b, r))\n\n    def _steer_visible(self, a, b):\n        if self._edge_free(a, b):\n            return self._clamp(b)\n        return self._steer(a, b, self.step)\n\n    # Node grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        # Small expanding ring for speed\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n            if best is not None:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        seen = {}\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            i2 = id(n)\n                            if i2 in seen:\n                                continue\n                            seen[i2] = True\n                            d2 = 0.0\n                            p = n.position\n                            for i in range(self.dim):\n                                di = p[i] - pos[i]\n                                d2 += di * di\n                            if d2 <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        i2 = id(n)\n                        if i2 in seen:\n                            continue\n                        seen[i2] = True\n                        d2 = 0.0\n                        p = n.position\n                        for i in range(self.dim):\n                            di = p[i] - pos[i]\n                            d2 += di * di\n                        if d2 <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _adaptive_radius(self, n_nodes):\n        t = float(max(1, n_nodes))\n        base = 1.2 * self.step\n        decay = (1.0 / (1.0 + t)) ** (1.0 / max(1, self.dim))\n        r = base + self.neighbor_radius_scale * self.step * decay\n        if r < 1.05 * self.step:\n            r = 1.05 * self.step\n        return r\n\n    def _too_close(self, grid, pos, radius):\n        nb = self._neighbors_within(grid, pos, radius, 1)\n        return len(nb) > 0\n\n    # Parent selection using true node count (fast, cap-limited)\n    def _select_parent(self, grid, tree_nodes, newp, fallback):\n        r = self._adaptive_radius(len(tree_nodes))\n        neigh = self._neighbors_within(grid, newp, r, 48)\n        best = fallback\n        best_cost = fallback.cost + self._dist(fallback.position, newp)\n        for n in neigh:\n            if n is fallback:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = c\n        return best\n\n    # Node lookup at position (epsilon)\n    def _find_node_at(self, grid, pos, eps=1e-9):\n        key = self._cell_key(pos)\n        lst = self._grid_collect(grid, key, 0)\n        if not lst:\n            lst = []\n        for n in lst:\n            if self._dist(n.position, pos) <= eps:\n                return n\n        # try neighbor ring\n        lst = self._grid_collect(grid, key, 1)\n        for n in lst:\n            if self._dist(n.position, pos) <= eps:\n                return n\n        return None\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(3.5, self.step * 1.6)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Edge bookkeeping\n    def _edges_add(self, edges, parent, child):\n        key = (id(parent), id(child))\n        if key in self._eindex:\n            return\n        edges.append((parent, child))\n        self._eindex[key] = len(edges) - 1\n\n    def _edges_remove(self, edges, parent, child):\n        key = (id(parent), id(child))\n        idx = self._eindex.get(key)\n        if idx is None:\n            return\n        last = len(edges) - 1\n        if idx != last:\n            edges[idx] = edges[last]\n            pk, ck = id(edges[idx][0]), id(edges[idx][1])\n            self._eindex[(pk, ck)] = idx\n        edges.pop()\n        self._eindex.pop(key, None)\n\n    # Path utilities and smoothing\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _elastic_smooth(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                target = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                t = 1.0\n                best = b\n                while t > 1e-3:\n                    cand = tuple(b[k] + (target[k] - b[k]) * t for k in range(self.dim))\n                    cand = self._clamp(cand)\n                    if (not self._point_blocked(cand)) and self._edge_free(a, cand) and self._edge_free(cand, c):\n                        best = cand\n                        break\n                    t *= 0.5\n                if best != b:\n                    cur[i] = best\n                    moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._shortcut(path, self.shortcut_attempts)\n        p2 = self._visibility_prune(p1)\n        p3 = self._elastic_smooth(p2, self.smooth_passes)\n        out = []\n        last = None\n        for p in p3:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out",
            "objective": -39.25344,
            "time_improvement": 81.0,
            "length_improvement": 12.0,
            "smoothness_improvement": 1553.0,
            "node_improvement": 92.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00945742130279541,
                    "num_nodes_avg": 50.0,
                    "path_length_avg": 167.53693550319753,
                    "smoothness_avg": 0.033726978508844686,
                    "success_improvement": 0.0,
                    "time_improvement": 62.402160293144725,
                    "node_improvement": 87.40871317048602,
                    "length_improvement": 8.170350858066406,
                    "smoothness_improvement": 427.90045296948705,
                    "objective_score": 25.762360867630697
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01689279079437256,
                    "num_nodes_avg": 92.0,
                    "path_length_avg": 258.9566017823895,
                    "smoothness_avg": 0.08894239443432421,
                    "success_improvement": 0.0,
                    "time_improvement": 89.45588977402788,
                    "node_improvement": 93.81845058120003,
                    "length_improvement": 13.552832672535061,
                    "smoothness_improvement": 2188.5518714124423,
                    "objective_score": 45.911225892791606
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.004900145530700684,
                    "num_nodes_avg": 37.0,
                    "path_length_avg": 128.24827679318562,
                    "smoothness_avg": 0.16853365869929307,
                    "success_improvement": 0.0,
                    "time_improvement": 89.91298330339527,
                    "node_improvement": 95.29561347743166,
                    "length_improvement": 14.823601080648544,
                    "smoothness_improvement": 2043.7356987943315,
                    "objective_score": 46.086734133379366
                }
            ],
            "success_rate": 1.0
        },
        "objective": 50.6,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inconsistent neighbor-radius scaling (tied to occupied cells instead of actual node count), reducing good parent candidates and wasting neighbor/edge checks\n   - Visibility-constrained expansion that caps straight-line moves into many short steps, inflating nodes, nearest searches, and collision queries\n   - Non-atomic tree joining that can report a connection without inserting the exact meeting waypoint, causing extra kinks and longer stitched paths\n   - Heavy reattachment logic with redundant collision checks and subtree cost recomputation, increasing per-iteration overhead\n   - Limited post-processing effectiveness due to coarse waypoint placement and weak curvature handling, requiring extra cleanup work"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Visibility-first steering that directly jumps to targets when the line of sight is clear\n   - Exact meeting-node insertion during tree connection, avoiding ambiguous joins\n   - Parent selection using a node-count\u2013based adaptive radius with a tight neighbor cap\n   - Removal of rewiring and subtree cost propagation\n   - More aggressive connection parameters (larger connection step, deeper connect attempts)\n   - Coarser spatial hashing and larger duplicate radius to curb redundant insertions\n   - Stronger goal/line/informed sampling biases\n   - Fewer shortcut and smoothing passes\n2. Expected mechanism of impact:\n   - Fewer nodes and expansions reduce nearest-neighbor queries and collision checks per iteration\n   - Direct visible jumps and guaranteed meet insertion shorten the time to first valid connection\n   - Smaller, capped neighbor sets cut parent-evaluation cost while preserving feasibility\n   - Eliminating rewiring removes costly subtree updates and repeated edge tests\n   - Coarser grids and duplicate filtering lower hash lookups and node additions\n   - Targeted sampling increases the rate of useful expansions toward the goal region\n   - Reduced post-processing iterations directly decrease finishing time"
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "SIMPLEX-GEN BiRRT*: A lean, generalizable bidirectional RRT* with informed sampling, lightweight spatial grids, obstacle bins, and bounded rewiring. It favors early feasible connections, then refines parentage locally and smooths minimally, trading heavy heuristics for robust, portable speed and path quality.",
                "planning_mechanism": "Alternate growth of start/goal trees. For each sample: informed/goal/uniform pick, grid-ring nearest, step, best-parent within an adaptive radius, mandatory point-and-edge checks, insert, bounded local rewiring, then greedy connect from the opposite tree with exact meeting-node insertion when visible. On connection: assemble, prune by visibility, shortcut, relax, and return.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = None\n        self.cost = float(cost)\n        self.children = []\n        if parent is not None:\n            self.attach(parent)\n\n    def attach(self, parent):\n        if self.parent is parent:\n            if parent is not None and self not in parent.children:\n                parent.children.append(self)\n            return\n        if self.parent is not None:\n            old = self.parent\n            for i in range(len(old.children) - 1, -1, -1):\n                if old.children[i] is self:\n                    old.children.pop(i)\n                    break\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=5.0,\n                 goal_bias=0.20,\n                 neighbor_base=3.0,\n                 neighbor_cap=32,\n                 rewire_cap=12,\n                 dup_radius_factor=0.35,\n                 connect_steps=48,\n                 shortcut_attempts=160,\n                 relax_passes=6):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.nb_base = float(neighbor_base)\n        self.nb_cap = int(max(8, neighbor_cap))\n        self.rw_cap = int(max(0, rewire_cap))\n        self.dup_fac = float(dup_radius_factor)\n        self.connect_steps = int(max(8, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.relax_passes = int(max(0, relax_passes))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", [])) if getattr(map, \"obstacles\", None) is not None else []\n\n        nodes = []\n        edges = []\n\n        # Basic validity\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Seed RNG\n        self._seed()\n\n        # Build obstacle bins\n        self._build_bins()\n\n        # Early endpoint checks\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight-line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Spatial grids\n        self.grid_cell = max(1.0, 0.9 * self.step)\n        self.dupe_radius = max(0.3 * self.step, self.dup_fac * self.step)\n        GA, GB = {}, {}\n\n        # Initialize trees\n        ra = Node(self.start, None, 0.0)\n        rb = Node(self.goal, None, 0.0)\n        Ta, Tb = [ra], [rb]\n        nodes.extend([ra, rb])\n        self._grid_add(GA, ra)\n        self._grid_add(GB, rb)\n\n        best_len = None\n        best_path = None\n\n        for it in range(self.max_iter):\n            # Choose which tree to grow (alternate, favor smaller)\n            growA = (it % 2 == 0)\n            if len(Ta) > len(Tb) + 3:\n                growA = False\n            elif len(Tb) > len(Ta) + 3:\n                growA = True\n\n            T = Ta if growA else Tb\n            O = Tb if growA else Ta\n            G = GA if growA else GB\n            GO = GB if growA else GA\n            attract = self.goal if growA else self.start\n\n            # Sample target\n            qrand = self._sample(attractor=attract, c_best=best_len)\n            if qrand is None:\n                continue\n\n            # Nearest and steer\n            qnear = self._nearest(G, qrand)\n            if qnear is None:\n                qnear = T[-1]\n            qnew_pos = self._steer(qnear.position, qrand, self.step)\n            if (not self._in_bounds(qnew_pos)) or self._point_blocked(qnew_pos):\n                continue\n            if self._exists_close(G, qnew_pos, self.dupe_radius):\n                continue\n\n            # Best-parent selection within adaptive radius\n            rad = self._adaptive_radius(len(Ta) + len(Tb))\n            parent, bestc = self._choose_parent(G, qnew_pos, qnear, rad)\n            if parent is None:\n                continue\n\n            # Mandatory checks before insertion\n            if self._point_blocked(qnew_pos):\n                continue\n            if not self._edge_free(parent.position, qnew_pos):\n                continue\n\n            # Insert new node\n            nn = Node(qnew_pos, parent, bestc)\n            nodes.append(nn)\n            T.append(nn)\n            self._grid_add(G, nn)\n            edges.append((parent, nn))\n\n            # Local rewiring around nn\n            if self.rw_cap > 0:\n                self._rewire_local(nn, G, edges, rad, self.rw_cap)\n\n            # Try to connect to opposite tree with greedy steps\n            meet, connected = self._connect_greedy(O, GO, nn.position, nodes, edges)\n            if connected:\n                pa = self._trace(nn)\n                pb = self._trace(meet)\n                if growA:\n                    if pa and pb and pa[0] == pb[0]:\n                        full = pa + pb[-2::-1]\n                    else:\n                        full = pa + pb[-2::-1]\n                else:\n                    if pa and pb and pa[0] == pb[0]:\n                        full = pb + pa[-2::-1]\n                    else:\n                        full = pb + pa[-2::-1]\n                full = self._dedup(full)\n                L = self._path_len(full)\n                if best_len is None or L < best_len - 1e-9:\n                    best_len = L\n                    best_path = self._finalize(full)\n                return PlannerResult(True, best_path, nodes, edges)\n\n        # No connection\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed(self):\n        s = 0x9E3779B97F4A7C15 & 0xffffffffffffffff\n        vals = list(self.start) + list(self.goal) + [len(self.obstacles)]\n        for v in vals:\n            q = int(v * 11400714819323198485) & 0xffffffffffffffff\n            s ^= (q + 0x9E3779B97F4A7C15 + ((s << 6) & 0xffffffffffffffff) + (s >> 2)) & 0xffffffffffffffff\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial grid\n    def _gkey(self, p):\n        if self.is3:\n            return (int(p[0] // self.grid_cell), int(p[1] // self.grid_cell), int(p[2] // self.grid_cell))\n        else:\n            return (int(p[0] // self.grid_cell), int(p[1] // self.grid_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._gkey(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        kk = self._gkey(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, 4):\n            cand = self._collect_ring(grid, kk, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bd:\n                    bd = d2\n                    best = n\n            if best is not None:\n                return best\n        # fallback scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bd:\n                    bd = d2\n                    best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap):\n        kk = self._gkey(pos)\n        rc = int(radius // self.grid_cell) + 1\n        r2 = radius * radius\n        out = []\n        cand = self._collect_ring(grid, kk, rc)\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        nb = self._neighbors(grid, pos, radius, cap=1)\n        return len(nb) > 0\n\n    # Obstacles/binning\n    def _build_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.4)\n        self._obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self._obin.get(key)\n                            if lst is None:\n                                self._obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self._obin.get(key)\n                        if lst is None:\n                            self._obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_bucket(self, p):\n        if self.is3:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell),\n                                   int(p[2] // self.obs_cell)))\n        else:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell)))\n\n    def _point_blocked(self, p):\n        bucket = self._point_bucket(p)\n        if not bucket:\n            return False\n        if self.is3:\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        # Broad-phase: iterate bins covering AABB\n        if self.is3:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1],\n                  a[2] if a[2] < b[2] else b[2])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1],\n                  a[2] if a[2] > b[2] else b[2])\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            iz0 = int(max(0.0, mn[2]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self._obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1])\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self._obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        # Liang-Barsky style clipping\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # RRT* utilities\n    def _adaptive_radius(self, n_total):\n        if n_total < 2:\n            return self.step * 2.0\n        d = float(self.dim)\n        shrink = (max(1.0, n_total) ** (-1.0 / (d + 1.0)))\n        return max(self.step * 1.25, self.nb_base * self.step * shrink)\n\n    def _choose_parent(self, grid, new_pos, fallback, radius):\n        best = None\n        best_cost = 1e100\n        cand = self._neighbors(grid, new_pos, radius, cap=self.nb_cap)\n        if fallback not in cand:\n            cand.append(fallback)\n        # sort by distance to encourage closer, straighter parents\n        cand.sort(key=lambda n: self._dist2(n.position, new_pos))\n        for p in cand:\n            # Both checks on this potential edge (node validity implied)\n            if not self._edge_free(p.position, new_pos):\n                continue\n            c = p.cost + self._dist(p.position, new_pos)\n            if c < best_cost - 1e-12:\n                best_cost = c\n                best = p\n        if best is None:\n            return None, None\n        return best, best_cost\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_delta(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire_local(self, new_node, grid, edges, radius, cap):\n        neigh = self._neighbors(grid, new_node.position, radius, cap=cap * 2)\n        if not neigh:\n            return\n        # Prefer closest for stability\n        neigh.sort(key=lambda n: self._dist2(n.position, new_node.position))\n        count = 0\n        for nb in neigh:\n            if count >= cap:\n                break\n            if nb is new_node or nb is new_node.parent:\n                continue\n            if self._is_ancestor(nb, new_node):\n                continue\n            if self._point_blocked(nb.position):\n                continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n            if cand_cost + 1e-12 < nb.cost:\n                oldp = nb.parent\n                old_cost = nb.cost\n                # detach from oldp\n                if oldp is not None:\n                    for i in range(len(oldp.children) - 1, -1, -1):\n                        if oldp.children[i] is nb:\n                            oldp.children.pop(i)\n                            break\n                    self._remove_edge(edges, oldp, nb)\n                nb.attach(new_node)\n                nb.cost = cand_cost\n                edges.append((new_node, nb))\n                self._propagate_delta(nb, cand_cost - old_cost)\n                count += 1\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                edges.pop(i)\n                return\n\n    # Connect opposite tree greedily toward target\n    def _connect_greedy(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            cur = tree[-1]\n        steps = 0\n        while steps < self.connect_steps:\n            # If full visibility, try to insert exact meeting node\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                    if not self._exists_close(grid, target_pos, self.dupe_radius * 0.75):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        meet = Node(target_pos, cur, new_cost)\n                        # Both checks before committing\n                        if (not self._point_blocked(meet.position)) and self._edge_free(cur.position, meet.position):\n                            nodes.append(meet)\n                            tree.append(meet)\n                            self._grid_add(grid, meet)\n                            edges.append((cur, meet))\n                            return meet, True\n                # Even if not inserted (due to dup/bounds), treat as connected at cur\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.step * 2.0)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return cur, False\n            if self._exists_close(grid, nxt, self.dupe_radius * 0.75):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            # Both checks before adding\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                return cur, False\n            nodes.append(nn)\n            tree.append(nn)\n            self._grid_add(grid, nn)\n            edges.append((cur, nn))\n            cur = nn\n            steps += 1\n        # Final visibility check to exact meeting\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                if not self._exists_close(grid, target_pos, self.dupe_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    meet = Node(target_pos, cur, new_cost)\n                    if (not self._point_blocked(meet.position)) and self._edge_free(cur.position, meet.position):\n                        nodes.append(meet)\n                        tree.append(meet)\n                        self._grid_add(grid, meet)\n                        edges.append((cur, meet))\n                        return meet, True\n            return cur, True\n        return cur, False\n\n    # Sampling\n    def _sample(self, attractor, c_best):\n        r = self._rand()\n        if c_best is not None and r < 0.6:\n            p = self._sample_informed(c_best * 1.01)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        # Uniform rejection\n        if self.is3:\n            for _ in range(24):\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n                if (not self._point_blocked(p)):\n                    return p\n        else:\n            for _ in range(24):\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n                if (not self._point_blocked(p)):\n                    return p\n        return None\n\n    def _sample_informed(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half) for _ in range(self.dim)]\n        tries = 32\n        while tries > 0:\n            tries -= 1\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= max_sum + 1e-9:\n                return p\n        return None\n\n    # Path utilities and smoothing\n    def _trace(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        if len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _vis_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            n = len(cur)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L <= bestL + 1e-12:\n                    cur = cand\n                    bestL = L\n            tries += 1\n        return cur\n\n    def _relax(self, pts, passes):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        alpha = 0.55\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                t = tuple((1.0 - alpha) * cur[i][k] + alpha * 0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if (not self._in_bounds(t)) or self._point_blocked(t):\n                    continue\n                if self._edge_free(a, t) and self._edge_free(t, c):\n                    if t != cur[i]:\n                        cur[i] = t\n                        moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize(self, path):\n        p = self._vis_prune(path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        p = self._relax(p, self.relax_passes)\n        p = self._vis_prune(p)\n        return self._dedup(p)",
                "objective": -22.19598,
                "time_improvement": 21.0,
                "length_improvement": 13.0,
                "smoothness_improvement": 1613.0,
                "node_improvement": 76.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.02215919494628906,
                        "num_nodes_avg": 112.0,
                        "path_length_avg": 186.95537225843663,
                        "smoothness_avg": 0.04185203886535682,
                        "success_improvement": 0.0,
                        "time_improvement": 10.475812526127406,
                        "node_improvement": 71.7955175018887,
                        "length_improvement": -2.473202032301466,
                        "smoothness_improvement": 555.0752913998657,
                        "objective_score": 4.434198995456671
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.047111678123474124,
                        "num_nodes_avg": 215.0,
                        "path_length_avg": 232.99312267983265,
                        "smoothness_avg": 0.11966088381180089,
                        "success_improvement": 0.0,
                        "time_improvement": 71.34794950064989,
                        "node_improvement": 85.55398777128266,
                        "length_improvement": 22.22018931427837,
                        "smoothness_improvement": 2978.960728728491,
                        "objective_score": 49.63130208240444
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.060208463668823244,
                        "num_nodes_avg": 230.0,
                        "path_length_avg": 121.89561168288944,
                        "smoothness_avg": 0.11041329076943165,
                        "success_improvement": 0.0,
                        "time_improvement": -18.084850196556676,
                        "node_improvement": 70.75651621106167,
                        "length_improvement": 19.042738765501902,
                        "smoothness_improvement": 1304.448908725804,
                        "objective_score": 12.522432743963158
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "CORE-Lite BiRRT-Connect*: A simplified, robust bidirectional planner that couples informed sampling with lightweight grids and single-shot best-parent selection. It avoids heavy rewiring, prioritizes early feasible connections, and applies minimal, constraint-aware smoothing to yield short, smooth paths quickly across 2D/3D maps.",
            "planning_mechanism": "Grow two trees from start/goal with biased/informed sampling. For each sample: pick nearest by grid, steer one step, pick the best visible parent among a small local set, validate node and edge, insert, then greedily connect the opposite tree with exact meeting-node insertion when visible. On connection: trace, prune by visibility, shortcut, relax, and return.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = None\n        self.cost = float(cost)\n        self.children = []\n        if parent is not None:\n            self.attach(parent)\n\n    def attach(self, parent):\n        if self.parent is parent:\n            if parent is not None and self not in parent.children:\n                parent.children.append(self)\n            return\n        if self.parent is not None:\n            old = self.parent\n            for i in range(len(old.children) - 1, -1, -1):\n                if old.children[i] is self:\n                    old.children.pop(i)\n                    break\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.25,\n                 connect_steps=48,\n                 dup_radius_factor=0.35,\n                 shortcut_attempts=140,\n                 relax_passes=6,\n                 neighbor_factor=2.5,\n                 neighbor_cap=16):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.connect_steps = int(max(8, connect_steps))\n        self.dup_fac = float(dup_radius_factor)\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.relax_passes = int(max(0, relax_passes))\n        self.nei_factor = float(neighbor_factor)\n        self.nb_cap = int(max(4, neighbor_cap))\n        self._rng = 1\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", [])) if getattr(map, \"obstacles\", None) is not None else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed()\n        self._build_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        self.grid_cell = max(1.0, 0.9 * self.step)\n        self.dupe_radius = max(0.3 * self.step, self.dup_fac * self.step)\n\n        GA, GB = {}, {}\n        Ta, Tb = [], []\n        ra = Node(self.start, None, 0.0)\n        rb = Node(self.goal, None, 0.0)\n        Ta.append(ra)\n        Tb.append(rb)\n        nodes.extend([ra, rb])\n        self._grid_add(GA, ra)\n        self._grid_add(GB, rb)\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            growA = (it % 2 == 0)\n            if len(Ta) > len(Tb) + 3:\n                growA = False\n            elif len(Tb) > len(Ta) + 3:\n                growA = True\n\n            T = Ta if growA else Tb\n            O = Tb if growA else Ta\n            G = GA if growA else GB\n            GO = GB if growA else GA\n            attract = self.goal if growA else self.start\n\n            qrand = self._sample(attractor=attract, c_best=best_len)\n            if qrand is None:\n                continue\n\n            qnear = self._nearest(G, qrand)\n            if qnear is None:\n                qnear = T[-1]\n            qnew_pos = self._steer(qnear.position, qrand, self.step)\n            if (not self._in_bounds(qnew_pos)) or self._point_blocked(qnew_pos):\n                continue\n            if self._exists_close(G, qnew_pos, self.dupe_radius):\n                continue\n\n            parent, bestc = self._choose_parent_simple(G, qnew_pos, qnear)\n            if parent is None:\n                continue\n\n            if self._point_blocked(qnew_pos):\n                continue\n            if not self._edge_free(parent.position, qnew_pos):\n                continue\n\n            nn = Node(qnew_pos, parent, bestc)\n            nodes.append(nn)\n            T.append(nn)\n            self._grid_add(G, nn)\n            edges.append((parent, nn))\n\n            meet, connected = self._connect_greedy(O, GO, nn.position, nodes, edges)\n            if connected:\n                pa = self._trace(nn)\n                pb = self._trace(meet)\n                if growA:\n                    full = pa + pb[-2::-1]\n                else:\n                    full = pb + pa[-2::-1]\n                full = self._dedup(full)\n                L = self._path_len(full)\n                if best_len is None or L < best_len - 1e-9:\n                    best_len = L\n                path = self._finalize(full)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _seed(self):\n        s = 0xA5A5A5A5\n        vals = list(self.start) + list(self.goal) + [len(self.obstacles)]\n        for v in vals:\n            s ^= (int(v * 2654435761) + (s << 6) + (s >> 2)) & 0xffffffff\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _gkey(self, p):\n        if self.is3:\n            return (int(p[0] // self.grid_cell), int(p[1] // self.grid_cell), int(p[2] // self.grid_cell))\n        else:\n            return (int(p[0] // self.grid_cell), int(p[1] // self.grid_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._gkey(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        kk = self._gkey(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, 3):\n            cand = self._collect_ring(grid, kk, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bd:\n                    bd = d2\n                    best = n\n            if best is not None:\n                return best\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bd:\n                    bd = d2\n                    best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap):\n        kk = self._gkey(pos)\n        rc = int(radius // self.grid_cell) + 1\n        r2 = radius * radius\n        out = []\n        cand = self._collect_ring(grid, kk, rc)\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        return len(self._neighbors(grid, pos, radius, 1)) > 0\n\n    def _build_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.4)\n        self._obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self._obin.get(key)\n                            if lst is None:\n                                self._obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self._obin.get(key)\n                        if lst is None:\n                            self._obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_bucket(self, p):\n        if self.is3:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell),\n                                   int(p[2] // self.obs_cell)))\n        else:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell)))\n\n    def _point_blocked(self, p):\n        bucket = self._point_bucket(p)\n        if not bucket:\n            return False\n        if self.is3:\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        if self.is3:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1],\n                  a[2] if a[2] < b[2] else b[2])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1],\n                  a[2] if a[2] > b[2] else b[2])\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            iz0 = int(max(0.0, mn[2]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self._obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1])\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self._obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    def _choose_parent_simple(self, grid, new_pos, fallback):\n        rad = max(self.step * self.nei_factor, self.step * 1.25)\n        cand = self._neighbors(grid, new_pos, rad, cap=self.nb_cap)\n        if fallback not in cand:\n            cand.append(fallback)\n        cand.sort(key=lambda n: self._dist2(n.position, new_pos))\n        best = None\n        best_cost = 1e100\n        for p in cand:\n            if not self._edge_free(p.position, new_pos):\n                continue\n            c = p.cost + self._dist(p.position, new_pos)\n            if c < best_cost:\n                best_cost = c\n                best = p\n        if best is None:\n            return None, None\n        return best, best_cost\n\n    def _connect_greedy(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            cur = tree[-1]\n        steps = 0\n        while steps < self.connect_steps:\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                    if not self._exists_close(grid, target_pos, self.dupe_radius * 0.75):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        meet = Node(target_pos, cur, new_cost)\n                        if (not self._point_blocked(meet.position)) and self._edge_free(cur.position, meet.position):\n                            nodes.append(meet)\n                            tree.append(meet)\n                            self._grid_add(grid, meet)\n                            edges.append((cur, meet))\n                            return meet, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.step * 2.0)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return cur, False\n            if self._exists_close(grid, nxt, self.dupe_radius * 0.75):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                return cur, False\n            nodes.append(nn)\n            tree.append(nn)\n            self._grid_add(grid, nn)\n            edges.append((cur, nn))\n            cur = nn\n            steps += 1\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                if not self._exists_close(grid, target_pos, self.dupe_radius * 0.75):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    meet = Node(target_pos, cur, new_cost)\n                    if (not self._point_blocked(meet.position)) and self._edge_free(cur.position, meet.position):\n                        nodes.append(meet)\n                        tree.append(meet)\n                        self._grid_add(grid, meet)\n                        edges.append((cur, meet))\n                        return meet, True\n            return cur, True\n        return cur, False\n\n    def _sample(self, attractor, c_best):\n        r = self._rand()\n        if c_best is not None and r < 0.6:\n            p = self._sample_informed(c_best * 1.01)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        if self.is3:\n            for _ in range(24):\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n                if (not self._point_blocked(p)):\n                    return p\n        else:\n            for _ in range(24):\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n                if (not self._point_blocked(p)):\n                    return p\n        return None\n\n    def _sample_informed(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half) for _ in range(self.dim)]\n        tries = 28\n        while tries > 0:\n            tries -= 1\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= max_sum + 1e-9:\n                return p\n        return None\n\n    def _trace(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        if len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _vis_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            n = len(cur)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L <= bestL + 1e-12:\n                    cur = cand\n                    bestL = L\n            tries += 1\n        return cur\n\n    def _relax(self, pts, passes):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        alpha = 0.55\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                t = tuple((1.0 - alpha) * cur[i][k] + alpha * 0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if (not self._in_bounds(t)) or self._point_blocked(t):\n                    continue\n                if self._edge_free(a, t) and self._edge_free(t, c):\n                    if t != cur[i]:\n                        cur[i] = t\n                        moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize(self, path):\n        p = self._vis_prune(path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        p = self._relax(p, self.relax_passes)\n        p = self._vis_prune(p)\n        return self._dedup(p)",
            "objective": -35.11252,
            "time_improvement": 74.0,
            "length_improvement": 7.0,
            "smoothness_improvement": 1703.0,
            "node_improvement": 89.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011555314064025879,
                    "num_nodes_avg": 65.0,
                    "path_length_avg": 185.89178931894617,
                    "smoothness_avg": 0.04091393432699476,
                    "success_improvement": 0.0,
                    "time_improvement": 53.31598891138548,
                    "node_improvement": 83.63132712163183,
                    "length_improvement": -1.8902353696165608,
                    "smoothness_improvement": 540.391918247889,
                    "objective_score": 17.562615042885152
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028458261489868165,
                    "num_nodes_avg": 132.0,
                    "path_length_avg": 241.93947538969232,
                    "smoothness_avg": 0.12265164970964178,
                    "success_improvement": 0.0,
                    "time_improvement": 82.69245380743223,
                    "node_improvement": 91.13082039911308,
                    "length_improvement": 19.233639273242296,
                    "smoothness_improvement": 3055.9152894415415,
                    "objective_score": 51.62749615338276
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.006699991226196289,
                    "num_nodes_avg": 55.0,
                    "path_length_avg": 144.23260812272875,
                    "smoothness_avg": 0.12680945220036005,
                    "success_improvement": 0.0,
                    "time_improvement": 86.85953083580657,
                    "node_improvement": 93.00699300699301,
                    "length_improvement": 4.207569303630591,
                    "smoothness_improvement": 1513.0068718884668,
                    "objective_score": 36.14743519236266
                }
            ],
            "success_rate": 1.0
        },
        "objective": 23.199999999999996,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Heavy local rewiring with cycle checks and subtree cost propagation, adding O(degree + depth + subtree) work per insertion\n   - Wide neighbor searches and grid-ring scans with many collision tests and distance evaluations per sample\n   - Redundant parent\u2013child detach/attach bookkeeping and linear-time edge removals\n   - Repeated validity checks (bounds/point/edge) before and during connection that duplicate work"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Removal of local rewiring and subtree cost updates; single-shot parent selection with a small, fixed candidate cap\n   - Tighter nearest lookup (shallower grid-ring) and fixed-radius parent search to limit neighbor evaluations\n   - Larger step size and higher goal bias to reduce expansions to a connection\n   - Fewer informed-sampling retries per draw to cut sampling overhead\n2. Expected mechanism of impact:\n   - Eliminating rewiring avoids cycle detection, edge replacement, and propagation, reducing per-iteration CPU and memory traffic\n   - Smaller candidate sets and shallower spatial queries cut collision checks and distance computations\n   - Longer steps and stronger goal attraction connect trees in fewer iterations, lowering total node insertions and edge tests\n   - Net effect: fewer operations before a feasible join, yielding faster wall-clock planning at some cost to optimal refinement"
        }
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "FLASH-Bridge BiRRT-Lite: An efficiency-first bidirectional planner that uses hash-grid approximate nearest neighbors without global scans, single-pass best-parent selection, and direct bridging with bounded micro-extensions. It returns early on the first valid connection and applies minimal, constraint-aware smoothing to keep planning time low while producing short, smooth paths.",
                "planning_mechanism": "Mechanism: Grow two trees from start and goal. For each informed/biased random sample, pick the nearest by grid-ring search, steer one step, and select the lowest-cost visible parent from a small local set. Insert only after passing both node and edge collision checks. Immediately attempt to bridge to the opposite tree via direct line-of-sight to its nearest node; otherwise make a few safe steps toward the target. On success, trace and stitch paths, run fast visibility pruning plus limited shortcutting and light relaxation, and return. No global rewiring and no all-node scans.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=6.0,\n                 goal_bias=0.2,\n                 connect_steps=10,\n                 neighbor_radius_factor=2.0,\n                 neighbor_cap=8,\n                 dup_radius_factor=0.4,\n                 shortcut_attempts=40,\n                 relax_passes=4):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.connect_steps = int(max(1, connect_steps))\n        self.nei_fac = float(neighbor_radius_factor)\n        self.nb_cap = int(max(2, neighbor_cap))\n        self.dup_fac = float(dup_radius_factor)\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.relax_passes = int(max(0, relax_passes))\n        self._rng = 1\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", [])) if getattr(map, \"obstacles\", None) is not None else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed()\n        self._build_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        diag = 0.0\n        for i in range(self.dim):\n            diag += (self.goal[i] - self.start[i]) * (self.goal[i] - self.start[i])\n        diag = diag ** 0.5\n        if self.step <= 0.0:\n            self.step = max(2.0, 0.02 * sum(self.bounds) / max(1, self.dim))\n        self.grid_cell = max(1.0, 0.9 * self.step)\n        self.dupe_radius = max(0.25 * self.step, self.dup_fac * self.step)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        GA, GB = {}, {}\n        Ta, Tb = [], []\n        ra = Node(self.start, None, 0.0)\n        rb = Node(self.goal, None, 0.0)\n        Ta.append(ra)\n        Tb.append(rb)\n        nodes.extend([ra, rb])\n        self._grid_add(GA, ra)\n        self._grid_add(GB, rb)\n\n        best_len = None\n\n        lastA, lastB = ra, rb\n\n        for it in range(self.max_iter):\n            growA = (len(Ta) <= len(Tb))\n            T = Ta if growA else Tb\n            O = Tb if growA else Ta\n            G = GA if growA else GB\n            GO = GB if growA else GA\n            attract = self.goal if growA else self.start\n            fallback = lastA if growA else lastB\n\n            qrand = self._sample(attractor=attract, c_best=best_len)\n            if qrand is None:\n                continue\n\n            qnear = self._nearest(G, qrand)\n            if qnear is None:\n                qnear = fallback\n\n            qnew_pos = self._steer(qnear.position, qrand, self.step)\n            if (not self._in_bounds(qnew_pos)) or self._point_blocked(qnew_pos):\n                continue\n            if self._exists_close(G, qnew_pos, self.dupe_radius):\n                continue\n\n            parent, bestc = self._choose_parent(G, qnew_pos, qnear)\n            if parent is None:\n                continue\n            if self._point_blocked(qnew_pos):\n                continue\n            if not self._edge_free(parent.position, qnew_pos):\n                continue\n\n            nn = Node(qnew_pos, parent, bestc)\n            nodes.append(nn)\n            T.append(nn)\n            self._grid_add(G, nn)\n            edges.append((parent, nn))\n            if growA:\n                lastA = nn\n            else:\n                lastB = nn\n\n            meet, bridged = self._bridge(O, GO, nn, nodes, edges)\n            if bridged:\n                pa = self._trace(nn)\n                pb = self._trace(meet)\n                if growA:\n                    full = pa + pb[-2::-1]\n                else:\n                    full = pb + pa[-2::-1]\n                full = self._dedup(full)\n                L = self._path_len(full)\n                if best_len is None or L < best_len - 1e-9:\n                    best_len = L\n                path = self._finalize(full)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _seed(self):\n        s = 0xC0FFEE\n        vals = list(self.start) + list(self.goal) + [len(self.obstacles), sum(int(b) for b in self.bounds)]\n        for v in vals:\n            s ^= (int(v * 2654435761) + (s << 6) + (s >> 2)) & 0xffffffff\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            t = b\n        else:\n            d = d2 ** 0.5\n            r = step / d\n            t = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n        return tuple(min(max(t[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _gkey(self, p):\n        if self.is3:\n            return (int(p[0] // self.grid_cell), int(p[1] // self.grid_cell), int(p[2] // self.grid_cell))\n        else:\n            return (int(p[0] // self.grid_cell), int(p[1] // self.grid_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._gkey(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        kk = self._gkey(pos)\n        best = None\n        bd = 1e100\n        for r in range(0, 3):\n            cand = self._collect_ring(grid, kk, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bd:\n                    bd = d2\n                    best = n\n            if best is not None:\n                return best\n        # no global scan; caller will fallback to a recent node\n        return None\n\n    def _neighbors(self, grid, pos, radius, cap):\n        kk = self._gkey(pos)\n        rc = int(max(1, radius // self.grid_cell))\n        r2 = radius * radius\n        out = []\n        cand = self._collect_ring(grid, kk, rc)\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        if not out and cand:\n            # pick closest few from cand if within same ring but radius missed\n            cand2 = sorted(cand, key=lambda n: self._dist2(n.position, pos))[:cap]\n            out.extend(cand2)\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        kk = self._gkey(pos)\n        rc = int(max(1, radius // self.grid_cell))\n        cand = self._collect_ring(grid, kk, rc)\n        r2 = radius * radius\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                return True\n        return False\n\n    def _build_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self._obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self._obin.get(key)\n                            if lst is None:\n                                self._obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self._obin.get(key)\n                        if lst is None:\n                            self._obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_bucket(self, p):\n        if self.is3:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell),\n                                   int(p[2] // self.obs_cell)))\n        else:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell)))\n\n    def _point_blocked(self, p):\n        bucket = self._point_bucket(p)\n        if not bucket:\n            return False\n        if self.is3:\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        if self.is3:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1],\n                  a[2] if a[2] < b[2] else b[2])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1],\n                  a[2] if a[2] > b[2] else b[2])\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            iz0 = int(max(0.0, mn[2]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self._obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1])\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self._obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    def _choose_parent(self, grid, new_pos, fallback):\n        rad = max(self.step * self.nei_fac, self.step * 1.25)\n        cand = self._neighbors(grid, new_pos, rad, cap=self.nb_cap)\n        if fallback not in cand:\n            cand.append(fallback)\n        best = None\n        best_cost = 1e100\n        for p in cand:\n            if not self._edge_free(p.position, new_pos):\n                continue\n            c = p.cost + self._dist(p.position, new_pos)\n            if c < best_cost:\n                best_cost = c\n                best = p\n        if best is None:\n            return None, None\n        return best, best_cost\n\n    def _bridge(self, tree, grid, new_node, nodes, edges):\n        target = new_node.position\n        near = self._nearest(grid, target)\n        if near is None:\n            near = tree[-1]\n        if self._edge_free(near.position, target):\n            edges.append((near, new_node))\n            return near, True\n        cur = near\n        steps = 0\n        while steps < self.connect_steps:\n            nxt_pos = self._steer(cur.position, target, self.step * 1.5)\n            if (not self._in_bounds(nxt_pos)) or self._point_blocked(nxt_pos):\n                break\n            if self._exists_close(grid, nxt_pos, self.dupe_radius * 0.75):\n                break\n            if not self._edge_free(cur.position, nxt_pos):\n                break\n            new_cost = cur.cost + self._dist(cur.position, nxt_pos)\n            nn = Node(nxt_pos, cur, new_cost)\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                break\n            nodes.append(nn)\n            tree.append(nn)\n            self._grid_add(grid, nn)\n            edges.append((cur, nn))\n            cur = nn\n            if self._edge_free(cur.position, target):\n                edges.append((cur, new_node))\n                return cur, True\n            steps += 1\n        return cur, False\n\n    def _sample(self, attractor, c_best):\n        r = self._rand()\n        if c_best is not None and r < 0.6:\n            p = self._sample_informed(c_best * 1.01)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            if (not self._point_blocked(attractor)) and self._in_bounds(attractor):\n                return attractor\n        tries = 16\n        while tries > 0:\n            tries -= 1\n            if self.is3:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        return None\n\n    def _sample_informed(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half) for _ in range(self.dim)]\n        tries = 24\n        while tries > 0:\n            tries -= 1\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= max_sum + 1e-9:\n                return p\n        return None\n\n    def _trace(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        if len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = i + 1\n            far = j\n            while j < n and self._edge_free(out[-1], pts[j]):\n                far = j\n                j += 1\n            out.append(pts[far])\n            i = far\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            n = len(cur)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L <= bestL + 1e-12:\n                    cur = cand\n                    bestL = L\n            tries += 1\n        return cur\n\n    def _relax(self, pts, passes):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        alpha = 0.5\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                t = tuple((1.0 - alpha) * cur[i][k] + alpha * 0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if (not self._in_bounds(t)) or self._point_blocked(t):\n                    continue\n                if self._edge_free(a, t) and self._edge_free(t, c):\n                    if t != cur[i]:\n                        cur[i] = t\n                        moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize(self, path):\n        p = self._prune(path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        p = self._relax(p, self.relax_passes)\n        p = self._prune(p)\n        return self._dedup(p)",
                "objective": -37.20947,
                "time_improvement": 73.0,
                "length_improvement": 14.0,
                "smoothness_improvement": 1368.0,
                "node_improvement": 79.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.005640697479248047,
                        "num_nodes_avg": 61.0,
                        "path_length_avg": 171.97142853307741,
                        "smoothness_avg": 0.04638849463441365,
                        "success_improvement": 0.0,
                        "time_improvement": 77.21131747612652,
                        "node_improvement": 84.63863006799295,
                        "length_improvement": 5.739734959350459,
                        "smoothness_improvement": 626.0806752569794,
                        "objective_score": 29.73763959473313
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.01880669593811035,
                        "num_nodes_avg": 243.0,
                        "path_length_avg": 235.9053856958496,
                        "smoothness_avg": 0.08848357754673088,
                        "success_improvement": 0.0,
                        "time_improvement": 88.56227535914985,
                        "node_improvement": 83.6726466438218,
                        "length_improvement": 21.247992094688797,
                        "smoothness_improvement": 2176.7461824222196,
                        "objective_score": 50.201208776669326
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.0242264986038208,
                        "num_nodes_avg": 239.0,
                        "path_length_avg": 126.88165706959765,
                        "smoothness_avg": 0.11014543996879947,
                        "success_improvement": 0.0,
                        "time_improvement": 52.485376903901624,
                        "node_improvement": 69.61220597584233,
                        "length_improvement": 15.73124482961756,
                        "smoothness_improvement": 1301.0418663124522,
                        "objective_score": 31.689569300503287
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "ZIP-Connect BiRRT: A time-minimal bidirectional RRT-Connect with grid-ANN and two-stage direct shots. It avoids global scans and rewiring, expands via greedy micro-extensions, and attempts immediate cross-tree connection each step. It performs early straight-line tests, maintains compact hash grids per tree, and applies ultra-light post-processing (visibility prune, few shortcuts, light relax) for fast, short, smooth paths.",
            "planning_mechanism": "Mechanism: Build two trees from start and goal. At each iteration, pick the smaller tree to grow; sample using goal/anchor-biased or informed uniform sampling. Find an approximate nearest via grid-ring lookup (fallback to the last node), then greedily extend toward the sample in fixed steps, inserting nodes only after passing point and edge collision checks. After each successful step, immediately try to connect to the opposite tree by extending toward its nearest node; if a collision-free link is found, stitch the two traced paths and finish with quick pruning/shortcutting/relaxation, then return.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=6.0,\n                 goal_bias=0.25,\n                 shot_bias=0.35,\n                 connect_limit=12,\n                 shortcut_attempts=24,\n                 relax_passes=2):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.shot_bias = float(shot_bias)\n        self.connect_limit = int(max(1, connect_limit))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.relax_passes = int(max(0, relax_passes))\n        self._rng = 1\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", [])) if getattr(map, \"obstacles\", None) is not None else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        self.grid_h = max(1.0, 0.9 * (self.step if self.step > 0.0 else 5.0))\n        GA, GB = {}, {}\n        Ta, Tb = [], []\n\n        ra = Node(self.start, None, 0.0)\n        rb = Node(self.goal, None, 0.0)\n        Ta.append(ra)\n        Tb.append(rb)\n        nodes.extend([ra, rb])\n        self._grid_add(GA, ra)\n        self._grid_add(GB, rb)\n        lastA, lastB = ra, rb\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            growA = (len(Ta) <= len(Tb))\n            T = Ta if growA else Tb\n            O = Tb if growA else Ta\n            G = GA if growA else GB\n            GO = GB if growA else GA\n            anchor = self.goal if growA else self.start\n            fallback = lastA if growA else lastB\n\n            qrand = self._pick_sample(anchor, best_len)\n            if qrand is None:\n                continue\n\n            qnear = self._grid_nearest(G, qrand)\n            if qnear is None:\n                qnear = fallback\n\n            new_node, extended = self._greedy_extend(qnear, qrand, T, G, nodes, edges)\n            if extended:\n                if growA:\n                    lastA = new_node\n                else:\n                    lastB = new_node\n\n                meet, connected = self._try_connect(new_node, O, GO, nodes, edges)\n                if connected:\n                    if growA:\n                        pa = self._trace(new_node)\n                        pb = self._trace(meet)\n                    else:\n                        pa = self._trace(meet)\n                        pb = self._trace(new_node)\n                    full = pa + pb[::-1][1:]\n                    L = self._path_len(full)\n                    if best_len is None or L < best_len:\n                        best_len = L\n                    path = self._finalize(full)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # --- Core expansion ---\n\n    def _greedy_extend(self, start_node, target, tree, grid, nodes, edges):\n        cur = start_node\n        limit = self.connect_limit\n        k = 0\n        while k < limit:\n            nxt_pos = self._steer(cur.position, target, self.step)\n            if self._same_point(nxt_pos, cur.position):\n                break\n            if (not self._in_bounds(nxt_pos)) or self._point_blocked(nxt_pos):\n                break\n            if not self._edge_free(cur.position, nxt_pos):\n                break\n            new_cost = cur.cost + self._dist(cur.position, nxt_pos)\n            nn = Node(nxt_pos, cur, new_cost)\n            # Both checks already performed above; still satisfy contract explicitly\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                break\n            nodes.append(nn)\n            tree.append(nn)\n            self._grid_add(grid, nn)\n            edges.append((cur, nn))\n            cur = nn\n            k += 1\n            if self._dist2(nxt_pos, target) <= (self.step * self.step * 0.25):\n                break\n        return cur, (cur is not start_node)\n\n    def _try_connect(self, from_node, other_tree, other_grid, nodes, edges):\n        near = self._grid_nearest(other_grid, from_node.position)\n        if near is None:\n            near = other_tree[-1]\n        # Quick direct attempt\n        if self._edge_free(from_node.position, near.position):\n            edges.append((from_node, near))\n            return near, True\n        # Micro-bridge from the nearest in the other tree\n        cur = near\n        steps = 0\n        while steps < self.connect_limit:\n            nxt = self._steer(cur.position, from_node.position, self.step)\n            if self._same_point(nxt, cur.position):\n                break\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            nn = Node(nxt, cur, cur.cost + self._dist(cur.position, nxt))\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                break\n            nodes.append(nn)\n            other_tree.append(nn)\n            self._grid_add(other_grid, nn)\n            edges.append((cur, nn))\n            cur = nn\n            if self._edge_free(cur.position, from_node.position):\n                edges.append((cur, from_node))\n                return cur, True\n            steps += 1\n        return near, False\n\n    # --- Sampling ---\n\n    def _pick_sample(self, anchor, c_best):\n        r = self._rand()\n        if r < self.goal_bias:\n            if self._in_bounds(anchor) and (not self._point_blocked(anchor)):\n                return anchor\n        if c_best is not None and r < self.goal_bias + self.shot_bias:\n            p = self._informed_sample(c_best * 1.01)\n            if p is not None:\n                return p\n        tries = 12\n        while tries > 0:\n            tries -= 1\n            if self.is3:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        return None\n\n    def _informed_sample(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half) for _ in range(self.dim)]\n        tries = 20\n        while tries > 0:\n            tries -= 1\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= max_sum + 1e-9:\n                return p\n        return None\n\n    # --- Geometry and grids ---\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            t = tuple(b[i] for i in range(self.dim))\n        else:\n            d = d2 ** 0.5\n            r = step / d\n            t = tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim))\n        # clamp\n        return tuple(min(max(t[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _same_point(self, a, b):\n        if self.dim == 2:\n            return abs(a[0] - b[0]) < 1e-9 and abs(a[1] - b[1]) < 1e-9\n        else:\n            return abs(a[0] - b[0]) < 1e-9 and abs(a[1] - b[1]) < 1e-9 and abs(a[2] - b[2]) < 1e-9\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _gkey(self, p):\n        if self.is3:\n            return (int(p[0] // self.grid_h), int(p[1] // self.grid_h), int(p[2] // self.grid_h))\n        else:\n            return (int(p[0] // self.grid_h), int(p[1] // self.grid_h))\n\n    def _grid_add(self, grid, node):\n        k = self._gkey(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _grid_nearest(self, grid, pos):\n        kk = self._gkey(pos)\n        best = None\n        bd = 1e100\n        for r in (0, 1, 2):\n            cand = self._grid_collect(grid, kk, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bd:\n                    bd = d2\n                    best = n\n            if best is not None:\n                return best\n        return None\n\n    # --- Collision ---\n\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self._obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self._obin.get(key)\n                            if lst is None:\n                                self._obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self._obin.get(key)\n                        if lst is None:\n                            self._obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_bucket(self, p):\n        if self.is3:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell),\n                                   int(p[2] // self.obs_cell)))\n        else:\n            return self._obin.get((int(p[0] // self.obs_cell),\n                                   int(p[1] // self.obs_cell)))\n\n    def _point_blocked(self, p):\n        bucket = self._point_bucket(p)\n        if not bucket:\n            return False\n        if self.is3:\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        if self.is3:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1],\n                  a[2] if a[2] < b[2] else b[2])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1],\n                  a[2] if a[2] > b[2] else b[2])\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            iz0 = int(max(0.0, mn[2]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self._obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1])\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self._obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            if not cand:\n                return True\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # --- Path utilities ---\n\n    def _trace(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        out.reverse()\n        return out\n\n    def _path_len(self, pts):\n        if len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _prune_visible(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        res = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            chosen = i + 1\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    chosen = j\n                    break\n                j -= 1\n            res.append(pts[chosen])\n            i = chosen\n        return res\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        best = self._path_len(cur)\n        tries = 0\n        n = len(cur)\n        while tries < attempts and n > 2:\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    cur = cand\n                    n = len(cur)\n                    best = L\n            tries += 1\n        return cur\n\n    def _relax(self, pts, passes):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        alpha = 0.45\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                t = tuple((1.0 - alpha) * cur[i][k] + alpha * 0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if (not self._in_bounds(t)) or self._point_blocked(t):\n                    continue\n                if self._edge_free(a, t) and self._edge_free(t, c):\n                    if t != cur[i]:\n                        cur[i] = t\n                        moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize(self, path):\n        p = self._prune_visible(path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        p = self._relax(p, self.relax_passes)\n        p = self._prune_visible(p)\n        # dedup\n        out = []\n        last = None\n        for q in p:\n            if (last is None) or (q != last):\n                out.append(q)\n                last = q\n        return out\n\n    # --- RNG ---\n\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        vals = list(self.start) + list(self.goal) + [len(self.obstacles)]\n        for v in vals:\n            s ^= (int(v * 1000003) + (s << 6) + (s >> 2)) & 0xffffffff\n        self._rng = s & 0xffffffff or 1\n\n    def _rand(self):\n        # xorshift32\n        x = self._rng & 0xffffffff\n        x ^= (x << 13) & 0xffffffff\n        x ^= (x >> 17) & 0xffffffff\n        x ^= (x << 5) & 0xffffffff\n        self._rng = x & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()",
            "objective": -46.01884,
            "time_improvement": 85.0,
            "length_improvement": 13.0,
            "smoothness_improvement": 2490.0,
            "node_improvement": 73.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0067004203796386715,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 155.2882442089263,
                    "smoothness_avg": 0.08485101195577995,
                    "success_improvement": 0.0,
                    "time_improvement": 72.929987227673,
                    "node_improvement": 66.50717703349282,
                    "length_improvement": 14.8840526493906,
                    "smoothness_improvement": 1228.1025940295524,
                    "objective_score": 36.94994072808402
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.00830092430114746,
                    "num_nodes_avg": 224.0,
                    "path_length_avg": 259.24792604615595,
                    "smoothness_avg": 0.19619608299383323,
                    "success_improvement": 0.0,
                    "time_improvement": 94.95160198614848,
                    "node_improvement": 84.9492709803131,
                    "length_improvement": 13.455580247985823,
                    "smoothness_improvement": 4948.2665297579415,
                    "objective_score": 61.300161393425746
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.006450390815734864,
                    "num_nodes_avg": 244.0,
                    "path_length_avg": 132.66575585273932,
                    "smoothness_avg": 0.10955817419808564,
                    "success_improvement": 0.0,
                    "time_improvement": 87.349063789852,
                    "node_improvement": 68.97647806738716,
                    "length_improvement": 11.88972182704114,
                    "smoothness_improvement": 1293.5718890564224,
                    "objective_score": 39.806411678462396
                }
            ],
            "success_rate": 1.0
        },
        "objective": 46.2,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Redundant collision queries and duplicate-suppression checks during both expansion and bridging, inflating per-step computation.\n   - Expensive local-neighborhood evaluation for parent selection, introducing extra distance sorting and multiple edge validations per insertion.\n   - Frequent sample rejection in constrained spaces due to high trial counts and tight informed-region tests, wasting iterations.\n   - Conservative connection logic with additional gating (e.g., proximity/duplicate filters) that delays or prevents quick cross-tree links.\n   - Heavy post-processing (numerous shortcut and relaxation passes) increasing end-to-end planning time even after a path is found.\n   - Fallback nearest selection that often yields unproductive growth directions, requiring more iterations to succeed."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Greedy micro-extensions that use a single nearest anchor without neighbor scans or multi-parent evaluation.\n   - Streamlined connection attempts (direct shot then short bridge) without duplicate-suppression overhead.\n   - Lighter-weight sampling with fewer retries and a balanced bias toward anchors/informed region to cut rejection cost.\n   - Reduced post-processing effort (fewer shortcut attempts and relaxation passes).\n2. Expected mechanism of impact:\n   - Cuts collision-checks and neighborhood computations per iteration, lowering CPU time per added node.\n   - Increases successful progress per loop via immediate cross-tree linking, reducing total iterations to a solution.\n   - Decreases time lost to failed sampling in clutter by limiting retry counts and simplifying informed draws.\n   - Shortens the tail after a first feasible path by minimizing smoothing work, improving overall planning latency."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "NOVA-Lite: Minimal Informed BiRRT*-Connect with capped local rewiring and elastic post-smoothing. It uses a compact spatial hash for neighbor/nearest queries, obstacle-bin prefiltering for fast collisions, duplicate-suppression, informed-ellipse sampling after the first feasible path, and exact meet-point insertion. A small, bounded RRT*-style parent selection and rewiring improve path length without heavy recomputation. Final paths are visibility-compressed, shortcut, and lightly relaxed for smoothness.",
                "planning_mechanism": "Alternate expansions from start and goal trees. Each iteration samples a target (uniform with goal bias; ellipse-informed after a solution), steers a step, selects a low-cost feasible parent within a shrinking radius, inserts the node (after node and edge checks), then performs capped local rewiring. The opposite tree attempts a greedy RRT-Connect extension toward the new node with exact meeting-point insertion if visible. On connection, assemble and smooth the path, then return.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = parent\n        if parent is not None:\n            if self not in parent.children:\n                parent.children.append(self)\n\n    def path_from_root(self):\n        out = []\n        cur = self\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=6.0,\n        connect_step=14.0,\n        goal_bias=0.15,\n        cell_factor=1.4,\n        obs_cell_factor=1.6,\n        dup_ratio=0.35,\n        rewire_gain=2.2,\n        neighbor_cap=24,\n        smooth_shortcuts=90,\n        smooth_relax=10\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = float(connect_step)\n        self.goal_bias = float(goal_bias)\n        self.cell_factor = float(cell_factor)\n        self.obs_cell_factor = float(obs_cell_factor)\n        self.dup_ratio = float(dup_ratio)\n        self.rewire_gain = float(rewire_gain)\n        self.neighbor_cap = int(neighbor_cap)\n        self.smooth_shortcuts = int(smooth_shortcuts)\n        self.smooth_relax = int(smooth_relax)\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed()\n        self.cell = max(1.0, self.step * self.cell_factor)\n        self.obs_cell = max(3.0, self.step * self.obs_cell_factor)\n        self.dup_base = max(0.3, self.step * self.dup_ratio)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Initialize trees\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        AnchA, AnchB = [a_root], [b_root]\n        self._grid_add(Ga, a_root)\n        self._grid_add(Gb, b_root)\n        nodes.extend([a_root, b_root])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            grow_a = (it % 2 == 0)\n            T1, T2 = (Ta, Tb) if grow_a else (Tb, Ta)\n            G1, G2 = (Ga, Gb) if grow_a else (Gb, Ga)\n            Anch1, Anch2 = (AnchA, AnchB) if grow_a else (AnchB, AnchA)\n            target_bias = self.goal if grow_a else self.start\n\n            qrand = self._sample_target(target_bias, best_len)\n            if qrand is None:\n                continue\n\n            near = self._nearest(G1, Anch1, qrand)\n            if near is None:\n                continue\n\n            newp = self._steer(near.position, qrand, self.step)\n            if not self._in_bounds(newp):\n                continue\n            if self._point_in_obstacles(newp):\n                continue\n            if self._has_nearby(G1, newp, self._dupe_radius(newp)):\n                continue\n\n            parent, new_cost = self._select_parent(G1, T1, near, newp)\n            if parent is None:\n                continue\n\n            # Both checks before add\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, new_cost)\n            nn.attach(parent)\n            T1.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(G1, nn)\n            if (len(T1) % 28) == 0:\n                Anch1.append(nn)\n\n            # Local capped rewiring\n            self._rewire(G1, nn, edges)\n\n            # Try to connect from the other tree\n            meet, connected = self._connect_toward(T2, G2, nn.position, nodes, edges)\n            if connected and meet is not None:\n                # Assemble path and return smoothed\n                if grow_a:\n                    pa = nn.path_from_root()\n                    pb = meet.path_from_root()\n                    path = pa + pb[-2::-1]\n                else:\n                    pa = meet.path_from_root()\n                    pb = nn.path_from_root()\n                    path = pa + pb[-2::-1]\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n                final = self._finalize(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed(self):\n        s = 0x9E3779B97F4A7C15\n        vals = list(self.start) + list(self.goal) + [float(len(self.obstacles))]\n        for v in vals:\n            q = int(v * 11400714819323198485) & 0xffffffffffffffff\n            s ^= q + 0x9E3779B97F4A7C15 + ((s << 6) & 0xffffffffffffffff) + (s >> 2)\n            s &= 0xffffffffffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0x7fffffff\n        return (self._rng % 1000000) / 1000000.0\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, rings):\n        out = []\n        if self.is3:\n            for dx in range(-rings, rings + 1):\n                for dy in range(-rings, rings + 1):\n                    for dz in range(-rings, rings + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-rings, rings + 1):\n                for dy in range(-rings, rings + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, anchors, pos):\n        key = self._cell_key(pos)\n        best, bestd = None, 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n            if best is not None:\n                return best\n        # fallback: scan anchors and first entries\n        for n in anchors:\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        if best is not None:\n            return best\n        for lst in grid.values():\n            if lst:\n                return lst[0]\n        return None\n\n    def _neighbors(self, grid, pos, radius, cap=None):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        cand = self._grid_collect(grid, key, rc)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n        if cap is not None and len(out) > cap:\n            k = cap\n            res = []\n            for i, n in enumerate(out):\n                if len(res) < k:\n                    res.append(n)\n                else:\n                    j = int(self._rand_range(0, i + 1))\n                    if j < k:\n                        res[j] = n\n            return res\n        return out\n\n    def _has_nearby(self, grid, pos, radius):\n        neigh = self._neighbors(grid, pos, radius, cap=8)\n        return len(neigh) > 0\n\n    def _dupe_radius(self, pos):\n        # Modest increase near dense obstacle bins\n        key = self._obs_key(pos)\n        dense = self.ogrid.get(key)\n        if dense and len(dense) > 0:\n            return max(0.25 * self.step, 0.8 * self.dup_base)\n        return self.dup_base\n\n    # Obstacles\n    def _obs_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.obs_cell), int(p[1] // self.obs_cell), int(p[2] // self.obs_cell))\n        return (int(p[0] // self.obs_cell), int(p[1] // self.obs_cell))\n\n    def _build_obs_bins(self):\n        self.ogrid = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                gx0 = int(max(0.0, x) // self.obs_cell)\n                gy0 = int(max(0.0, y) // self.obs_cell)\n                gz0 = int(max(0.0, z) // self.obs_cell)\n                gx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                gy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                gz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(gx0, gx1 + 1):\n                    for j in range(gy0, gy1 + 1):\n                        for k in range(gz0, gz1 + 1):\n                            key = (i, j, k)\n                            b = self.ogrid.get(key)\n                            if b is None:\n                                self.ogrid[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                gx0 = int(max(0.0, x) // self.obs_cell)\n                gy0 = int(max(0.0, y) // self.obs_cell)\n                gx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                gy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(gx0, gx1 + 1):\n                    for j in range(gy0, gy1 + 1):\n                        key = (i, j)\n                        b = self.ogrid.get(key)\n                        if b is None:\n                            self.ogrid[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        key = self._obs_key(p)\n        lst = self.ogrid.get(key)\n        if not lst:\n            return False\n        if self.is3:\n            x, y, z = p\n            for idx in lst:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            x, y = p\n            for idx in lst:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    # Collision\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        mins = tuple(min(a[i], b[i]) for i in range(self.dim))\n        maxs = tuple(max(a[i], b[i]) for i in range(self.dim))\n        if self.is3:\n            gx0 = int(max(0.0, mins[0]) // self.obs_cell)\n            gy0 = int(max(0.0, mins[1]) // self.obs_cell)\n            gz0 = int(max(0.0, mins[2]) // self.obs_cell)\n            gx1 = int(min(self.bounds[0], maxs[0]) // self.obs_cell)\n            gy1 = int(min(self.bounds[1], maxs[1]) // self.obs_cell)\n            gz1 = int(min(self.bounds[2], maxs[2]) // self.obs_cell)\n            uniq = {}\n            for i in range(gx0, gx1 + 1):\n                for j in range(gy0, gy1 + 1):\n                    for k in range(gz0, gz1 + 1):\n                        lst = self.ogrid.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                uniq[idx] = True\n            if not uniq:\n                return False\n            for idx in uniq.keys():\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            gx0 = int(max(0.0, mins[0]) // self.obs_cell)\n            gy0 = int(max(0.0, mins[1]) // self.obs_cell)\n            gx1 = int(min(self.bounds[0], maxs[0]) // self.obs_cell)\n            gy1 = int(min(self.bounds[1], maxs[1]) // self.obs_cell)\n            uniq = {}\n            for i in range(gx0, gx1 + 1):\n                for j in range(gy0, gy1 + 1):\n                    lst = self.ogrid.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            uniq[idx] = True\n            if not uniq:\n                return False\n            for idx in uniq.keys():\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parenting and rewiring\n    def _rr_radius(self, n_nodes):\n        n = max(2, n_nodes)\n        # Simple shrink with tree growth (no logs/imports)\n        return max(1.1 * self.step, self.rewire_gain * self.step / (n ** (1.0 / max(1.0, float(self.dim)))))\n\n    def _select_parent(self, grid, tree, fallback, newp):\n        radius = self._rr_radius(len(tree) + 1)\n        neigh = self._neighbors(grid, newp, radius, cap=self.neighbor_cap)\n        best_p = None\n        best_c = 1e100\n        for p in neigh if neigh else [fallback]:\n            d = self._dist(p.position, newp)\n            if d > 1.6 * self.step + 1e-9:\n                continue\n            if not self._edge_free(p.position, newp):\n                continue\n            cand = p.cost + d\n            if cand + 1e-12 < best_c:\n                best_c = cand\n                best_p = p\n        if best_p is None:\n            if self._edge_free(fallback.position, newp):\n                return fallback, fallback.cost + self._dist(fallback.position, newp)\n            return None, None\n        return best_p, best_c\n\n    def _rewire(self, grid, node, edges):\n        radius = self._rr_radius(64 + len(edges))\n        neigh = self._neighbors(grid, node.position, radius, cap=self.neighbor_cap)\n        changed = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if d > 1.6 * self.step + 1e-9:\n                continue\n            newc = node.cost + d\n            if newc + 1e-9 < nb.cost:\n                # Both checks before reparent edge\n                if (not self._point_in_obstacles(nb.position)) and (not self._point_in_obstacles(node.position)) and self._edge_free(node.position, nb.position):\n                    oldp = nb.parent\n                    nb.attach(node)\n                    nb.cost = newc\n                    # edges coherence\n                    if oldp is not None:\n                        self._remove_edge(edges, (oldp, nb))\n                    edges.append((node, nb))\n                    self._propagate_costs(nb)\n                    changed += 1\n                    if changed >= max(4, self.neighbor_cap // 2):\n                        break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            base = 0.0 if cur.parent is None else cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            if abs(base - cur.cost) > 1e-12:\n                cur.cost = base\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        for i in range(len(edges)):\n            if edges[i][0] is e[0] and edges[i][1] is e[1]:\n                edges.pop(i)\n                return\n\n    # Connect attempt\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        head = self._nearest(grid, tree, target_pos)\n        if head is None:\n            return None, False\n        # Direct attempt\n        if self._edge_free(head.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._has_nearby(grid, target_pos, 0.75 * self._dupe_radius(target_pos)):\n                    meet = Node(target_pos, head, head.cost + self._dist(head.position, target_pos))\n                    # Both checks\n                    if (not self._point_in_obstacles(meet.position)) and self._edge_free(head.position, meet.position):\n                        meet.attach(head)\n                        tree.append(meet)\n                        nodes.append(meet)\n                        edges.append((head, meet))\n                        self._grid_add(grid, meet)\n                        return meet, True\n            return head, True\n        # Greedy few steps toward target\n        cur = head\n        steps = 0\n        max_steps = 3\n        while steps < max_steps:\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if self._has_nearby(grid, nxt, 0.75 * self._dupe_radius(nxt)):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            nn = Node(nxt, cur, cur.cost + self._dist(cur.position, nxt))\n            # Both checks\n            if self._point_in_obstacles(nn.position) or not self._edge_free(cur.position, nn.position):\n                return cur, False\n            nn.attach(cur)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                    if not self._has_nearby(grid, target_pos, 0.75 * self._dupe_radius(target_pos)):\n                        meet = Node(target_pos, cur, cur.cost + self._dist(cur.position, target_pos))\n                        if (not self._point_in_obstacles(meet.position)) and self._edge_free(cur.position, meet.position):\n                            meet.attach(cur)\n                            tree.append(meet)\n                            nodes.append(meet)\n                            edges.append((cur, meet))\n                            self._grid_add(grid, meet)\n                            return meet, True\n                return cur, True\n        return cur, False\n\n    # Sampling\n    def _sample_target(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.6:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            if not self._point_in_obstacles(attractor):\n                return attractor\n        # uniform free\n        for _ in range(12):\n            if self.is3:\n                q = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                q = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(q) and not self._point_in_obstacles(q):\n                return q\n        return None\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                    return p\n        return None\n\n    # Path utilities\n    def _path_len(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _vis_prune(self, pts):\n        if len(pts) < 3:\n            return list(pts)\n        out = [pts[0]]\n        anchor = pts[0]\n        i = 1\n        while i < len(pts):\n            far = i\n            j = i\n            while j < len(pts):\n                if self._edge_free(anchor, pts[j]):\n                    far = j\n                    j += 1\n                else:\n                    break\n            out.append(pts[far])\n            anchor = pts[far]\n            i = far + 1\n        out[0] = pts[0]\n        out[-1] = pts[-1]\n        return out\n\n    def _shortcut(self, pts, attempts):\n        cur = list(pts)\n        if len(cur) < 3:\n            return cur\n        tries = 0\n        best = self._path_len(cur)\n        while tries < attempts and len(cur) >= 3:\n            i = int(self._rand_range(0, len(cur) - 2))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j > len(cur):\n                j = len(cur)\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j - 1]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j - 1:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    cur = cand\n                    best = L\n            tries += 1\n        return cur\n\n    def _relax(self, pts, iters):\n        if len(pts) < 3 or iters <= 0:\n            return list(pts)\n        cur = list(pts)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if self._in_bounds(mid) and (not self._point_in_obstacles(mid)):\n                    if self._edge_free(a, mid) and self._edge_free(mid, c):\n                        if mid != cur[i]:\n                            cur[i] = mid\n                            moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize(self, path):\n        p = self._vis_prune(path)\n        p = self._shortcut(p, self.smooth_shortcuts)\n        p = self._relax(p, self.smooth_relax)\n        return self._dedup(p)",
                "objective": -29.15764,
                "time_improvement": 54.0,
                "length_improvement": 13.0,
                "smoothness_improvement": 1060.0,
                "node_improvement": 77.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.018969154357910155,
                        "num_nodes_avg": 116.0,
                        "path_length_avg": 187.68651371774737,
                        "smoothness_avg": 0.040289006378163676,
                        "success_improvement": 0.0,
                        "time_improvement": 23.36372620600242,
                        "node_improvement": 70.78821455552757,
                        "length_improvement": -2.873952251827512,
                        "smoothness_improvement": 530.6104387959213,
                        "objective_score": 7.937798704683825
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.023628926277160643,
                        "num_nodes_avg": 185.0,
                        "path_length_avg": 234.15262414140247,
                        "smoothness_avg": 0.07023308716778658,
                        "success_improvement": 0.0,
                        "time_improvement": 85.62952507944536,
                        "node_improvement": 87.56971040784788,
                        "length_improvement": 21.83311435200729,
                        "smoothness_improvement": 1707.1479196750995,
                        "objective_score": 47.32446573341348
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.024606847763061525,
                        "num_nodes_avg": 209.0,
                        "path_length_avg": 120.49313139242103,
                        "smoothness_avg": 0.08182935539974406,
                        "success_improvement": 0.0,
                        "time_improvement": 51.739410792918065,
                        "node_improvement": 73.42657342657343,
                        "length_improvement": 19.974199395496207,
                        "smoothness_improvement": 940.8633606700182,
                        "objective_score": 32.210659678523236
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "AURORA-Simple: A compact BiRRT*-Connect with informed sampling and elastic smoothing. It alternates bidirectional growth with light RRT* parent selection and capped local rewiring, uses an ellipse-informed sampler after the first solution, and applies visibility pruning, shortcutting, and collision-aware Laplacian relaxation for smooth, short paths. A simple spatial hash accelerates nearest/neighbor queries and obstacle binning speeds collision checks.",
            "planning_mechanism": "Alternate expansions from start and goal trees. Each iteration samples a target (uniform with goal bias; ellipse-informed once a solution exists), steers a step, picks the cheapest feasible parent within a shrinking radius, inserts the node after node and edge checks, and rewires nearby neighbors if cost improves. The opposite tree greedily connects toward the new node with safe increments; upon meeting, paths are merged and post-processed (visibility prune, shortcuts, relaxation), then returned.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = parent\n        if parent is not None:\n            if self not in parent.children:\n                parent.children.append(self)\n\n    def path_from_root(self):\n        out = []\n        cur = self\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=5.0,\n        connect_step=10.0,\n        goal_bias=0.2,\n        grid_factor=1.25,\n        obs_grid_factor=1.8,\n        rewire_factor=1.6,\n        neighbor_cap=20,\n        min_separation_ratio=0.35,\n        shortcut_attempts=80,\n        relax_iters=12\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = float(connect_step)\n        self.goal_bias = float(goal_bias)\n        self.grid_factor = float(grid_factor)\n        self.obs_grid_factor = float(obs_grid_factor)\n        self.rewire_factor = float(rewire_factor)\n        self.neighbor_cap = int(neighbor_cap)\n        self.min_sep_ratio = float(min_separation_ratio)\n        self.shortcut_attempts = int(shortcut_attempts)\n        self.relax_iters = int(relax_iters)\n        self._rng = 1234567\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        # Bounds checks\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Seed RNG\n        self._seed()\n\n        # Grid parameters\n        self.cell = max(1.0, self.step * self.grid_factor)\n        self.obs_cell = max(3.0, self.step * self.obs_grid_factor)\n        self.min_sep = max(0.2, self.step * self.min_sep_ratio)\n\n        # Build obstacle bins\n        self._build_obs_bins()\n\n        # Start/goal collision\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Trivial straight-line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n1.attach(n0)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Initialize trees, grids\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        Ta, Tb = [a_root], [b_root]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, a_root)\n        self._grid_add(Gb, b_root)\n        nodes.extend([a_root, b_root])\n\n        best_len = None\n\n        for it in range(self.max_iter):\n            grow_a = (it % 2 == 0)\n            T1, T2 = (Ta, Tb) if grow_a else (Tb, Ta)\n            G1, G2 = (Ga, Gb) if grow_a else (Gb, Ga)\n            attractor = self.goal if grow_a else self.start\n\n            # Sample target\n            qrand = self._sample_target(attractor, best_len)\n            if qrand is None:\n                continue\n\n            # Nearest and steer\n            near = self._nearest(G1, T1, qrand)\n            if near is None:\n                continue\n            newp = self._steer(near.position, qrand, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n            if self._has_nearby(G1, newp, self.min_sep):\n                continue\n\n            # Select parent (light RRT*)\n            parent, new_cost = self._select_parent(G1, T1, near, newp)\n            if parent is None:\n                continue\n\n            # Both checks before add\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, new_cost)\n            nn.attach(parent)\n            T1.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(G1, nn)\n\n            # Local rewiring\n            self._rewire(G1, nn, edges)\n\n            # Attempt to connect from the other tree\n            meet, connected = self._connect_toward(T2, G2, nn.position, nodes, edges)\n            if connected and meet is not None:\n                # Build full path\n                if grow_a:\n                    pa = nn.path_from_root()\n                    pb = meet.path_from_root()\n                    path = pa + pb[-2::-1]\n                else:\n                    pa = meet.path_from_root()\n                    pb = nn.path_from_root()\n                    path = pa + pb[-2::-1]\n                path = self._dedup(path)\n                best_len = self._path_len(path)\n                final = self._finalize(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed(self):\n        h = 2166136261\n        vals = list(self.start) + list(self.goal) + [float(len(self.obstacles))]\n        for v in vals:\n            x = int(v * 2654435761) & 0xffffffff\n            h ^= x\n            h = (h * 16777619) & 0xffffffff\n        if h == 0:\n            h = 1234567\n        self._rng = h & 0x7fffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0x7fffffff\n        return (self._rng % 1000000) / 1000000.0\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash for nodes\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, rings):\n        out = []\n        if self.is3:\n            for dx in range(-rings, rings + 1):\n                for dy in range(-rings, rings + 1):\n                    for dz in range(-rings, rings + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-rings, rings + 1):\n                for dy in range(-rings, rings + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, nodes, pos):\n        key = self._cell_key(pos)\n        best, bestd = None, 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n            if best is not None:\n                return best\n        # fallback full scan\n        for n in nodes:\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, cap=None):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        cand = self._grid_collect(grid, key, rc)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n        if cap is not None and len(out) > cap:\n            k = cap\n            res = []\n            for i, n in enumerate(out):\n                if len(res) < k:\n                    res.append(n)\n                else:\n                    j = int(self._rand_range(0, i + 1))\n                    if j < k:\n                        res[j] = n\n            return res\n        return out\n\n    def _has_nearby(self, grid, pos, radius):\n        neigh = self._neighbors(grid, pos, radius, cap=8)\n        return len(neigh) > 0\n\n    # Obstacles and collision\n    def _obs_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.obs_cell), int(p[1] // self.obs_cell), int(p[2] // self.obs_cell))\n        return (int(p[0] // self.obs_cell), int(p[1] // self.obs_cell))\n\n    def _build_obs_bins(self):\n        self.ogrid = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                gx0 = int(max(0.0, x) // self.obs_cell)\n                gy0 = int(max(0.0, y) // self.obs_cell)\n                gz0 = int(max(0.0, z) // self.obs_cell)\n                gx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                gy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                gz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(gx0, gx1 + 1):\n                    for j in range(gy0, gy1 + 1):\n                        for k in range(gz0, gz1 + 1):\n                            key = (i, j, k)\n                            lst = self.ogrid.get(key)\n                            if lst is None:\n                                self.ogrid[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                gx0 = int(max(0.0, x) // self.obs_cell)\n                gy0 = int(max(0.0, y) // self.obs_cell)\n                gx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                gy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(gx0, gx1 + 1):\n                    for j in range(gy0, gy1 + 1):\n                        key = (i, j)\n                        lst = self.ogrid.get(key)\n                        if lst is None:\n                            self.ogrid[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_in_obstacles(self, p):\n        key = self._obs_key(p)\n        lst = self.ogrid.get(key)\n        if not lst:\n            return False\n        if self.is3:\n            x, y, z = p\n            for idx in lst:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            x, y = p\n            for idx in lst:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        mins = tuple(min(a[i], b[i]) for i in range(self.dim))\n        maxs = tuple(max(a[i], b[i]) for i in range(self.dim))\n        if self.is3:\n            gx0 = int(max(0.0, mins[0]) // self.obs_cell)\n            gy0 = int(max(0.0, mins[1]) // self.obs_cell)\n            gz0 = int(max(0.0, mins[2]) // self.obs_cell)\n            gx1 = int(min(self.bounds[0], maxs[0]) // self.obs_cell)\n            gy1 = int(min(self.bounds[1], maxs[1]) // self.obs_cell)\n            gz1 = int(min(self.bounds[2], maxs[2]) // self.obs_cell)\n            uniq = {}\n            for i in range(gx0, gx1 + 1):\n                for j in range(gy0, gy1 + 1):\n                    for k in range(gz0, gz1 + 1):\n                        lst = self.ogrid.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                uniq[idx] = True\n            if not uniq:\n                return False\n            for idx in uniq.keys():\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            gx0 = int(max(0.0, mins[0]) // self.obs_cell)\n            gy0 = int(max(0.0, mins[1]) // self.obs_cell)\n            gx1 = int(min(self.bounds[0], maxs[0]) // self.obs_cell)\n            gy1 = int(min(self.bounds[1], maxs[1]) // self.obs_cell)\n            uniq = {}\n            for i in range(gx0, gx1 + 1):\n                for j in range(gy0, gy1 + 1):\n                    lst = self.ogrid.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            uniq[idx] = True\n            if not uniq:\n                return False\n            for idx in uniq.keys():\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parent selection and rewiring\n    def _rr_radius(self, n_nodes):\n        n = max(2, n_nodes)\n        return max(1.05 * self.step, self.rewire_factor * self.step / (n ** (1.0 / max(1.0, float(self.dim)))))\n\n    def _select_parent(self, grid, tree, fallback, newp):\n        radius = self._rr_radius(len(tree) + 1)\n        neigh = self._neighbors(grid, newp, radius, cap=self.neighbor_cap)\n        best_p = None\n        best_c = 1e100\n        if neigh:\n            for p in neigh:\n                d = self._dist(p.position, newp)\n                if d > 1.75 * self.step + 1e-9:\n                    continue\n                if not self._edge_free(p.position, newp):\n                    continue\n                cand = p.cost + d\n                if cand + 1e-12 < best_c:\n                    best_c = cand\n                    best_p = p\n        if best_p is None:\n            if self._edge_free(fallback.position, newp):\n                return fallback, fallback.cost + self._dist(fallback.position, newp)\n            return None, None\n        return best_p, best_c\n\n    def _rewire(self, grid, node, edges):\n        radius = self._rr_radius(len(edges) + 32)\n        neigh = self._neighbors(grid, node.position, radius, cap=self.neighbor_cap)\n        count = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if d > 1.75 * self.step + 1e-9:\n                continue\n            newc = node.cost + d\n            if newc + 1e-9 < nb.cost:\n                # Checks before reparenting\n                if (not self._point_in_obstacles(nb.position)) and (not self._point_in_obstacles(node.position)) and self._edge_free(node.position, nb.position):\n                    oldp = nb.parent\n                    nb.attach(node)\n                    nb.cost = newc\n                    if oldp is not None:\n                        self._remove_edge(edges, (oldp, nb))\n                    edges.append((node, nb))\n                    self._propagate_costs(nb)\n                    count += 1\n                    if count >= max(3, self.neighbor_cap // 2):\n                        break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            base = 0.0 if cur.parent is None else cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            if abs(base - cur.cost) > 1e-12:\n                cur.cost = base\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        for i in range(len(edges)):\n            if edges[i][0] is e[0] and edges[i][1] is e[1]:\n                edges.pop(i)\n                return\n\n    # Connect other tree toward target position\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        head = self._nearest(grid, tree, target_pos)\n        if head is None:\n            return None, False\n\n        # Direct connect attempt\n        if self._edge_free(head.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)) and (not self._has_nearby(grid, target_pos, self.min_sep * 0.8)):\n                meet = Node(target_pos, head, head.cost + self._dist(head.position, target_pos))\n                # Both checks\n                if (not self._point_in_obstacles(meet.position)) and self._edge_free(head.position, meet.position):\n                    meet.attach(head)\n                    tree.append(meet)\n                    nodes.append(meet)\n                    edges.append((head, meet))\n                    self._grid_add(grid, meet)\n                    return meet, True\n            return None, False\n\n        # Greedy incremental connect\n        cur = head\n        max_steps = 4\n        steps = 0\n        while steps < max_steps:\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return None, False\n            if self._has_nearby(grid, nxt, self.min_sep * 0.8):\n                return None, False\n            if not self._edge_free(cur.position, nxt):\n                return None, False\n            nn = Node(nxt, cur, cur.cost + self._dist(cur.position, nxt))\n            # Both checks\n            if self._point_in_obstacles(nn.position) or not self._edge_free(cur.position, nn.position):\n                return None, False\n            nn.attach(cur)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            steps += 1\n            # Final link if possible\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)) and (not self._has_nearby(grid, target_pos, self.min_sep * 0.8)):\n                    meet = Node(target_pos, cur, cur.cost + self._dist(cur.position, target_pos))\n                    if (not self._point_in_obstacles(meet.position)) and self._edge_free(cur.position, meet.position):\n                        meet.attach(cur)\n                        tree.append(meet)\n                        nodes.append(meet)\n                        edges.append((cur, meet))\n                        self._grid_add(grid, meet)\n                        return meet, True\n                return None, False\n        return None, False\n\n    # Sampling\n    def _sample_target(self, attractor, best_len):\n        r = self._rand()\n        if best_len is not None and r < 0.6:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias and (not self._point_in_obstacles(attractor)):\n            return attractor\n        # Uniform random in free\n        for _ in range(16):\n            if self.is3:\n                q = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                q = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(q) and (not self._point_in_obstacles(q)):\n                return q\n        return None\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum:\n                    return p\n        return None\n\n    # Path utilities\n    def _path_len(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _vis_prune(self, pts):\n        if len(pts) < 3:\n            return list(pts)\n        out = [pts[0]]\n        anchor = pts[0]\n        i = 1\n        while i < len(pts):\n            far = i\n            j = i\n            while j < len(pts):\n                if self._edge_free(anchor, pts[j]):\n                    far = j\n                    j += 1\n                else:\n                    break\n            out.append(pts[far])\n            anchor = pts[far]\n            i = far + 1\n        out[0] = pts[0]\n        out[-1] = pts[-1]\n        return out\n\n    def _shortcut(self, pts, attempts):\n        cur = list(pts)\n        if len(cur) < 3:\n            return cur\n        best = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) >= 3:\n            i = int(self._rand_range(0, len(cur) - 2))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j > len(cur):\n                j = len(cur)\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j - 1]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j - 1:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    cur = cand\n                    best = L\n            tries += 1\n        return cur\n\n    def _relax(self, pts, iters):\n        if len(pts) < 3 or iters <= 0:\n            return list(pts)\n        cur = list(pts)\n        for _ in range(iters):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                if self._in_bounds(mid) and (not self._point_in_obstacles(mid)):\n                    if self._edge_free(a, mid) and self._edge_free(mid, c):\n                        if mid != cur[i]:\n                            cur[i] = mid\n                            moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize(self, path):\n        p = self._vis_prune(path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        p = self._relax(p, self.relax_iters)\n        return self._dedup(p)",
            "objective": -41.08777,
            "time_improvement": 77.0,
            "length_improvement": 14.0,
            "smoothness_improvement": 1963.0,
            "node_improvement": 87.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0053506135940551754,
                    "num_nodes_avg": 49.0,
                    "path_length_avg": 164.16540194185723,
                    "smoothness_avg": 0.0604680221490293,
                    "success_improvement": 0.0,
                    "time_improvement": 78.38326998541683,
                    "node_improvement": 87.6605389070763,
                    "length_improvement": 10.018341828405152,
                    "smoothness_improvement": 846.455855044069,
                    "objective_score": 33.758265367888484
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0371267557144165,
                    "num_nodes_avg": 205.0,
                    "path_length_avg": 244.75937964787263,
                    "smoothness_avg": 0.12042929944393894,
                    "success_improvement": 0.0,
                    "time_improvement": 77.42050969149274,
                    "node_improvement": 86.2258953168044,
                    "length_improvement": 18.29227406541803,
                    "smoothness_improvement": 2998.7326164108117,
                    "objective_score": 49.19518042875269
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.012696647644042968,
                    "num_nodes_avg": 108.0,
                    "path_length_avg": 131.57971906355084,
                    "smoothness_avg": 0.1684555037540335,
                    "success_improvement": 0.0,
                    "time_improvement": 75.09848875579885,
                    "node_improvement": 86.26827717736809,
                    "length_improvement": 12.61101575090558,
                    "smoothness_improvement": 2042.7415736594278,
                    "objective_score": 40.30986394558014
                }
            ],
            "success_rate": 1.0
        },
        "objective": 36.99999999999999,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Greedy connection routine sometimes reports success without inserting a meet node, wasting iterations without real progress\n   - Nearest-neighbor fallback relies on sparse anchors, often selecting suboptimal nodes and inflating collision checks\n   - Coarse connect steps with aggressive duplicate suppression throttle growth in narrow passages\n   - Heavy local rewiring (large radius floor, high neighbor cap) adds per-iteration overhead with limited cost improvement\n   - Redundant feasibility checks (point/edge) before and after insertions increase CPU time\n   - Spatial hashing with larger cells leads to frequent empty-ring scans and costly fallbacks\n   - Limited incremental connect attempts reduce the chance of bridging between trees"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Connection logic tightened to only succeed when a meet node is actually inserted; failures return early and cleanly\n   - Finer, slightly longer incremental connect (smaller step, more steps) increases successful bridging progress\n   - Nearest-neighbor fallback upgraded to full-tree scan, improving candidate quality when bins are sparse\n   - Leaner rewiring (smaller radius floor/factor, lower neighbor cap) reduces local optimization overhead\n   - Denser node grid (smaller cell size) improves neighbor/nearest hits and reduces ring expansions\n   - Higher goal bias and robust uniform sampling attempts focus exploration and reduce resampling stalls\n   - Slightly relaxed duplicate suppression near connect targets increases successful node insertions\n2. Expected mechanism of impact:\n   - Eliminating spurious \u201csuccessful\u201d connects and improving incremental bridging lowers the number of futile iterations\n   - Better nearest candidates and finer connect steps reduce collision rejections, cutting expensive edge checks\n   - Reduced rewiring scope and neighbor counts lower per-iteration computational cost\n   - Denser spatial hashing decreases empty-neighborhood scans, accelerating nearest/neighbor queries\n   - Focused sampling (goal-biased and ellipse-informed) shortens time to first feasible path and reduces overall work"
        }
    },
    {
        "parents": [
            {
                "operator": "m2",
                "algorithm_description": "ECLAIR-IRRT*-Connect: Efficient Cached Lattice-Accelerated Informed RRT*-Connect with adaptive RRT* radius, grid-accelerated neighbors, edge-collision caching, dual-stage visibility reparenting, selective rewiring, and layered smoothing. It auto-tunes step, radius, and connect distance online from tree growth and incumbent path, reducing time while improving length and smoothness.",
                "planning_mechanism": "Grow two trees with informed/corridor/goal/uniform sampling. For each iteration: find a near node via spatial grid, steer with an adaptive step, reject duplicates, choose the least-cost feasible parent within a Karaman-style shrinking radius, insert only after both node and edge collision checks, then visibility-reparent to the best visible ancestor and selectively rewire cheaper neighbors. Greedily connect the opposite tree toward the new point with cached collision checks; on a bridge, assemble, visibility-prune, shortcut, and elastic-relax the path. Maintain an incumbent best path to focus informed sampling and adapt radii.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        return pts[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.12,\n                 corridor_bias=0.35,\n                 informed_bias=0.55,\n                 neighbor_scale=2.6,\n                 neighbor_cap=28,\n                 dupe_ratio=0.35,\n                 connect_mult=3.0,\n                 shortcut_attempts=220,\n                 relax_passes=12):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.neighbor_scale = float(neighbor_scale)\n        self.neighbor_cap = int(neighbor_cap)\n        self.dupe_ratio = float(dupe_ratio)\n        self.connect_mult = float(connect_mult)\n        self.shortcut_attempts = int(shortcut_attempts)\n        self.relax_passes = int(relax_passes)\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        # Obstacle bins and edge caches\n        self._build_obs_bins()\n        self._edge_free_cache = {}\n        self._edge_block_cache = {}\n\n        # Endpoint checks\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Spatial grid\n        self.grid_cell = max(1.0, 0.95 * self.step)\n        self.dupe_radius = max(0.5, self.dupe_ratio * self.step)\n        self.connect_step = max(self.step, self.connect_mult * self.step)\n\n        # Trees and grids\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        Ta, Tb = [root_a], [root_b]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, root_a)\n        self._grid_add(Gb, root_b)\n        nodes.extend([root_a, root_b])\n\n        best_path = None\n        best_len = None\n        corridor_w = max(self.step, 0.18 * self._dist(self.start, self.goal))\n\n        for it in range(self.max_iter):\n            # Alternate sides\n            side_a = (it % 2 == 0)\n            T = Ta if side_a else Tb\n            G = Ga if side_a else Gb\n            T_opp = Tb if side_a else Ta\n            G_opp = Gb if side_a else Ga\n            attractor = self.goal if side_a else self.start\n\n            # Sample target\n            target = self._sample_target(attractor, best_len, corridor_w)\n            if target is None:\n                continue\n\n            # Nearest and steer\n            near = self._nearest(G, target)\n            if near is None:\n                continue\n            q_new = self._steer(near.position, target, self.step)\n            if (not self._in_bounds(q_new)) or self._point_in_obstacles(q_new):\n                continue\n            if self._exists_close(G, q_new, self.dupe_radius):\n                continue\n\n            # Best-parent within adaptive radius\n            rad = self._rrtstar_radius(len(T))\n            parent, new_cost = self._choose_parent(G, q_new, near, rad)\n            if parent is None:\n                continue\n\n            # BOTH checks before adding\n            if self._point_in_obstacles(q_new):\n                continue\n            if not self._edge_free(parent.position, q_new):\n                continue\n\n            # Insert node\n            nn = Node(q_new, parent, new_cost)\n            parent.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(G, nn)\n\n            # Dual-stage visibility reparenting (scan ancestors; choose best visible)\n            self._visibility_reparent(nn, edges)\n\n            # Selective local rewiring\n            self._local_rewire(G, nn, rad, edges)\n\n            # Try to connect opposite tree greedily toward nn\n            meet, connected = self._greedy_connect(T_opp, G_opp, nn.position, nodes, edges)\n            if connected:\n                path = self._assemble_full_path(nn, meet, side_a)\n                path = self._finalize_path(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Maintain incumbent best to guide informed sampling\n            other = self._nearest(G_opp, nn.position)\n            if other is not None and self._edge_free(nn.position, other.position):\n                tmp = self._assemble_full_path(nn, other, side_a)\n                L = self._path_len(tmp)\n                if (best_len is None) or (L + 1e-12 < best_len):\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._finalize_path(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0x9E3779B97F4A7C15 & 0xffffffffffffffff\n        for v in self.start + self.goal:\n            q = int(abs(v) * 1000003) & 0xffffffff\n            s ^= (q + 0x9E3779B97F4A7C15 + ((s << 6) & 0xffffffffffffffff) + (s >> 2)) & 0xffffffffffffffff\n        s ^= ((len(self.obstacles) + 1) * 0xBF58476D1CE4E5B9) & 0xffffffffffffffff\n        self._rng = s & 0xffffffff or 123456789\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial grid\n    def _grid_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell), int(pos[2] // self.grid_cell))\n        else:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = 1e100\n        # Try few rings, then fall back\n        for r in range(0, 4):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n            if best is not None:\n                return best\n        # Fallback: scan buckets\n        for b in grid.values():\n            for n in b:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, cap):\n        key = self._grid_key(pos)\n        rc = max(1, int(radius // self.grid_cell) + 1)\n        cand = self._grid_collect_ring(grid, key, rc)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n                if len(out) >= cap:\n                    break\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        nb = self._neighbors_in_radius(grid, pos, radius, cap=1)\n        return len(nb) > 0\n\n    # Obstacles and collisions\n    def _build_obs_bins(self):\n        self.obs_cell = max(3.0, self.step * 1.3)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obin.get(key)\n                            if b is None:\n                                self.obin[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obin.get(key)\n                        if b is None:\n                            self.obin[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _canon_seg(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_free(self, a, b):\n        key = self._canon_seg(a, b)\n        v = self._edge_free_cache.get(key)\n        if v is not None:\n            return v\n        hit = self._edge_hits_any(a, b)\n        res = not hit\n        self._edge_free_cache[key] = res\n        self._edge_block_cache[key] = hit\n        return res\n\n    def _edge_hits_any(self, a, b):\n        key = self._canon_seg(a, b)\n        v = self._edge_block_cache.get(key)\n        if v is not None:\n            return v\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obin.get((i, j, k))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                self._edge_block_cache[key] = False\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    self._edge_block_cache[key] = True\n                    return True\n            self._edge_block_cache[key] = False\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obin.get((i, j))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                self._edge_block_cache[key] = False\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    self._edge_block_cache[key] = True\n                    return True\n            self._edge_block_cache[key] = False\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0 = 0.0\n        t1 = 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Parent selection / radius\n    def _rrtstar_radius(self, n_nodes):\n        n = max(2, n_nodes)\n        from_log = (max(1.0, self._log(n + 1.0)) / float(n)) ** (1.0 / max(1, self.dim))\n        base = self.neighbor_scale * self.step * from_log\n        return max(1.1 * self.step, base)\n\n    def _log(self, x):\n        # Simple ln approximation via change-of-base on built-in float operations\n        # Using Newton step on ln around 1 for stability (one iteration)\n        # Fallback: use natural series for small ranges\n        y = (x - 1.0) / (x + 1.0)\n        y2 = y * y\n        s = 0.0\n        num = y\n        for k in range(1, 8, 2):\n            s += num / k\n            num *= y2\n        return 2.0 * s\n\n    def _choose_parent(self, grid, newp, fallback, radius):\n        parent = None\n        best_cost = 1e100\n        neigh = self._neighbors_in_radius(grid, newp, radius, cap=self.neighbor_cap * 2)\n        if not neigh:\n            neigh = [fallback]\n        for n in neigh:\n            if not self._edge_free(n.position, newp):\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost:\n                parent = n\n                best_cost = c\n        if parent is None:\n            return None, None\n        return parent, best_cost\n\n    def _visibility_reparent(self, node, edges):\n        # Scan visible ancestors to choose best feasible ancestor\n        best_p = node.parent\n        best_c = node.cost\n        anc = node.parent.parent if node.parent else None\n        steps = 0\n        while anc is not None and steps < 24:\n            if self._edge_free(anc.position, node.position):\n                c = anc.cost + self._dist(anc.position, node.position)\n                if c + 1e-12 < best_c:\n                    best_c = c\n                    best_p = anc\n            anc = anc.parent\n            steps += 1\n        if best_p is not node.parent:\n            # BOTH checks before edge update\n            if (not self._point_in_obstacles(node.position)) and self._edge_free(best_p.position, node.position):\n                oldp = node.parent\n                if oldp is not None:\n                    oldp.remove_child(node)\n                    self._remove_edge(edges, (oldp, node))\n                best_p.add_child(node)\n                node.cost = best_c\n                edges.append((best_p, node))\n                self._propagate_cost(node)\n\n    def _local_rewire(self, grid, node, radius, edges):\n        neigh = self._neighbors_in_radius(grid, node.position, radius, cap=self.neighbor_cap)\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            # Avoid cycles by skipping ancestors\n            cur = node\n            cyc = False\n            while cur is not None:\n                if cur is nb:\n                    cyc = True\n                    break\n                cur = cur.parent\n            if cyc:\n                continue\n            cand = node.cost + self._dist(node.position, nb.position)\n            if cand + 1e-12 < nb.cost:\n                # BOTH checks before reparenting\n                if (not self._point_in_obstacles(nb.position)) and self._edge_free(node.position, nb.position):\n                    oldp = nb.parent\n                    if oldp is not None:\n                        oldp.remove_child(nb)\n                        self._remove_edge(edges, (oldp, nb))\n                    node.add_child(nb)\n                    nb.cost = cand\n                    edges.append((node, nb))\n                    self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if abs(newc - ch.cost) > 1e-12:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is e[0] and edges[i][1] is e[1]:\n                edges.pop(i)\n                return\n\n    # Greedy connect from opposite tree\n    def _greedy_connect(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        for _ in range(48):\n            # If direct line of sight, try exact meeting insert\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                    if not self._exists_close(grid, target_pos, 0.75 * self.dupe_radius):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        # BOTH checks\n                        if (not self._point_in_obstacles(nn.position)) and self._edge_free(cur.position, nn.position):\n                            cur.add_child(nn)\n                            tree.append(nn)\n                            nodes.append(nn)\n                            edges.append((cur, nn))\n                            self._grid_add(grid, nn)\n                            return nn, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if self._exists_close(grid, nxt, 0.75 * self.dupe_radius):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            # BOTH checks\n            if self._point_in_obstacles(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                return cur, False\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._exists_close(grid, target_pos, 0.75 * self.dupe_radius):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    if (not self._point_in_obstacles(nn.position)) and self._edge_free(cur.position, nn.position):\n                        cur.add_child(nn)\n                        tree.append(nn)\n                        nodes.append(nn)\n                        edges.append((cur, nn))\n                        self._grid_add(grid, nn)\n                        return nn, True\n            return cur, True\n        return cur, False\n\n    # Sampling\n    def _sample_target(self, attractor, best_len, corridor_w):\n        r = self._rand()\n        if best_len is not None and r < self.informed_bias:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        r = self._rand()\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        elif r < self.goal_bias + self.corridor_bias:\n            t = self._rand()\n            base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n            if self.is3:\n                p = (self._rand_range(base[0] - corridor_w, base[0] + corridor_w),\n                     self._rand_range(base[1] - corridor_w, base[1] + corridor_w),\n                     self._rand_range(base[2] - corridor_w, base[2] + corridor_w))\n            else:\n                p = (self._rand_range(base[0] - corridor_w, base[0] + corridor_w),\n                     self._rand_range(base[1] - corridor_w, base[1] + corridor_w))\n            p = self._clamp(p)\n            if not self._point_in_obstacles(p):\n                return p\n        # Uniform fallback\n        if self.is3:\n            for _ in range(24):\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n                if not self._point_in_obstacles(p):\n                    return p\n        else:\n            for _ in range(24):\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n                if not self._point_in_obstacles(p):\n                    return p\n        return None\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(28):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                if self._dist(p, f1) + self._dist(p, f2) <= max_sum:\n                    return p\n        return None\n\n    # Path utilities\n    def _assemble_full_path(self, u, v, side_a):\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if side_a:\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        best = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            n = len(cur)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            a = cur[i]; b = cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    cur = cand\n                    best = L\n            tries += 1\n        return cur\n\n    def _elastic_relax(self, pts, passes):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        alpha = 0.6\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                tgt = tuple((1.0 - alpha) * cur[i][k] + alpha * mid[k] for k in range(self.dim))\n                if (not self._in_bounds(tgt)) or self._point_in_obstacles(tgt):\n                    continue\n                if self._edge_free(a, tgt) and self._edge_free(tgt, c):\n                    if tgt != cur[i]:\n                        cur[i] = tgt\n                        moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        p = self._elastic_relax(p, self.relax_passes)\n        p = self._visibility_prune(p)\n        return p",
                "objective": -14.55953,
                "time_improvement": 10.0,
                "length_improvement": 4.0,
                "smoothness_improvement": 1806.0,
                "node_improvement": 70.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.03979227542877197,
                        "num_nodes_avg": 188.0,
                        "path_length_avg": 209.958611629612,
                        "smoothness_avg": 0.050535624301780914,
                        "success_improvement": 0.0,
                        "time_improvement": -60.762660111618196,
                        "node_improvement": 52.65676152102745,
                        "length_improvement": -15.081642041296567,
                        "smoothness_improvement": 690.99226018749,
                        "objective_score": -23.822821957325946
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.04477396011352539,
                        "num_nodes_avg": 207.0,
                        "path_length_avg": 255.02280767262,
                        "smoothness_avg": 0.13686610249016795,
                        "success_improvement": 0.0,
                        "time_improvement": 72.76968646995809,
                        "node_improvement": 86.09151380770005,
                        "length_improvement": 14.866046374361478,
                        "smoothness_improvement": 3421.6633977409842,
                        "objective_score": 47.85885075430923
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.04195327758789062,
                        "num_nodes_avg": 233.0,
                        "path_length_avg": 131.01062206651403,
                        "smoothness_avg": 0.11059261037184218,
                        "success_improvement": 0.0,
                        "time_improvement": 17.71843695480483,
                        "node_improvement": 70.37507946598855,
                        "length_improvement": 12.988982878850553,
                        "smoothness_improvement": 1306.7298408324696,
                        "objective_score": 19.642570017914128
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "FLASH-BiConnect: a fast heuristic-aware BiRRT-Connect with informed ellipse sampling, micro-bridge connection, collision-caching, grid-accelerated nearest search, and light post-smoothing. It emphasizes early feasible paths and minimal per-iteration work to cut planning time while delivering short, smooth trajectories.",
            "planning_mechanism": "Mechanism: Grow two trees from start and goal. Each iteration samples toward the goal/corridor or an informed ellipse once an incumbent exists, extends one step from the nearest node (grid lookup), validates node and edge, inserts, and immediately micro-bridges the opposite tree with bounded steps using cached collision checks. On a bridge, assemble and lightly smooth via visibility pruning, few shortcuts, and brief elastic relaxation. Maintain an incumbent to focus informed sampling and terminate early.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\n\n    def path_from_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        return pts[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=7.5,\n                 connect_multiplier=2.4,\n                 connect_steps=12,\n                 goal_bias=0.22,\n                 corridor_bias=0.28,\n                 informed_bias=0.62,\n                 dupe_ratio=0.18,\n                 shortcut_attempts=80,\n                 relax_passes=6):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_mult = float(connect_multiplier)\n        self.connect_steps = int(connect_steps)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.dupe_ratio = float(dupe_ratio)\n        self.shortcut_attempts = int(shortcut_attempts)\n        self.relax_passes = int(relax_passes)\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Build obstacle bins and seed RNG\n        self._build_obs_bins()\n        self._seed_from_scene()\n\n        # Endpoint collision checks\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early direct path\n        self._edge_free_cache = {}\n        self._edge_block_cache = {}\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Spatial grid and duplicate control\n        self.grid_cell = max(1.0, 0.95 * self.step)\n        self.dupe_radius = max(0.25, self.dupe_ratio * self.step)\n        self.connect_step = max(self.step, self.connect_mult * self.step)\n\n        # Trees and grids\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        Ta, Tb = [root_a], [root_b]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, root_a)\n        self._grid_add(Gb, root_b)\n        nodes.extend([root_a, root_b])\n\n        best_path = None\n        best_len = None\n        corridor_w = max(self.step, 0.15 * self._dist(self.start, self.goal))\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            T = Ta if side_a else Tb\n            G = Ga if side_a else Gb\n            T_opp = Tb if side_a else Ta\n            G_opp = Gb if side_a else Ga\n            attractor = self.goal if side_a else self.start\n\n            tgt = self._sample_target(attractor, best_len, corridor_w)\n            if tgt is None:\n                continue\n\n            near = self._nearest(G, tgt)\n            if near is None:\n                continue\n\n            q_new = self._steer(near.position, tgt, self.step)\n            if (not self._in_bounds(q_new)) or self._point_in_obstacles(q_new):\n                continue\n            if self._exists_close(G, q_new, self.dupe_radius):\n                continue\n            if not self._edge_free(near.position, q_new):\n                continue\n\n            # BOTH checks before adding node/edge\n            if self._point_in_obstacles(q_new):\n                continue\n            if not self._edge_free(near.position, q_new):\n                continue\n\n            nn = Node(q_new, near, near.cost + self._dist(near.position, q_new))\n            near.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            edges.append((near, nn))\n            self._grid_add(G, nn)\n\n            # Greedy micro-bridge to the opposite tree\n            meet, bridged = self._micro_bridge(T_opp, G_opp, nn.position, nodes, edges)\n            if bridged:\n                path = self._assemble_full_path(nn, meet, side_a)\n                path = self._finalize_path(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Maintain incumbent to guide informed sampling\n            other = self._nearest(G_opp, nn.position)\n            if other is not None and self._edge_free(nn.position, other.position):\n                tmp = self._assemble_full_path(nn, other, side_a)\n                L = self._path_len(tmp)\n                if (best_len is None) or (L + 1e-12 < best_len):\n                    best_len = L\n                    best_path = tmp\n\n        if best_path is not None:\n            best_path = self._finalize_path(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0x9E3779B97F4A7C15 & 0xffffffffffffffff\n        for v in self.start + self.goal:\n            q = int(abs(v) * 1000003) & 0xffffffff\n            s ^= (q + 0x9E3779B97F4A7C15 + ((s << 6) & 0xffffffffffffffff) + (s >> 2)) & 0xffffffffffffffff\n        s ^= ((len(self.obstacles) + 3) * 0xBF58476D1CE4E5B9) & 0xffffffffffffffff\n        self._rng = s & 0xffffffff or 123456789\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial grid\n    def _grid_key(self, pos):\n        if self.is3:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell), int(pos[2] // self.grid_cell))\n        else:\n            return (int(pos[0] // self.grid_cell), int(pos[1] // self.grid_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n            if best is not None:\n                return best\n        # Fallback scan\n        for b in grid.values():\n            for n in b:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        rc = max(1, int(radius // self.grid_cell) + 1)\n        cand = self._grid_collect_ring(grid, key, rc)\n        r2 = radius * radius\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                return True\n        return False\n\n    # Obstacles and collisions\n    def _build_obs_bins(self):\n        self.obs_cell = max(3.0, self.step * 1.3)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obin.get(key)\n                            if b is None:\n                                self.obin[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obin.get(key)\n                        if b is None:\n                            self.obin[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _canon_seg(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_free(self, a, b):\n        key = self._canon_seg(a, b)\n        v = self._edge_free_cache.get(key)\n        if v is not None:\n            return v\n        hit = self._edge_hits_any(a, b)\n        res = not hit\n        self._edge_free_cache[key] = res\n        self._edge_block_cache[key] = hit\n        return res\n\n    def _edge_hits_any(self, a, b):\n        key = self._canon_seg(a, b)\n        v = self._edge_block_cache.get(key)\n        if v is not None:\n            return v\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obin.get((i, j, k))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                self._edge_block_cache[key] = False\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    self._edge_block_cache[key] = True\n                    return True\n            self._edge_block_cache[key] = False\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obin.get((i, j))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                self._edge_block_cache[key] = False\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    self._edge_block_cache[key] = True\n                    return True\n            self._edge_block_cache[key] = False\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0 = 0.0\n        t1 = 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Micro-bridge connect\n    def _micro_bridge(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n        # Direct attempt\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                if not self._exists_close(grid, target_pos, 0.75 * self.dupe_radius):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    if (not self._point_in_obstacles(nn.position)) and self._edge_free(cur.position, nn.position):\n                        cur.add_child(nn)\n                        tree.append(nn)\n                        nodes.append(nn)\n                        edges.append((cur, nn))\n                        self._grid_add(grid, nn)\n                        return nn, True\n            return cur, True\n        # Short progressive bridge\n        steps = self.connect_steps\n        for _ in range(steps):\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                return cur, False\n            if self._exists_close(grid, nxt, 0.75 * self.dupe_radius):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            if self._point_in_obstacles(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                return cur, False\n            cur.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((cur, nn))\n            self._grid_add(grid, nn)\n            cur = nn\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                    if not self._exists_close(grid, target_pos, 0.75 * self.dupe_radius):\n                        final_cost = cur.cost + self._dist(cur.position, target_pos)\n                        meet = Node(target_pos, cur, final_cost)\n                        if (not self._point_in_obstacles(meet.position)) and self._edge_free(cur.position, meet.position):\n                            cur.add_child(meet)\n                            tree.append(meet)\n                            nodes.append(meet)\n                            edges.append((cur, meet))\n                            self._grid_add(grid, meet)\n                            return meet, True\n                return cur, True\n        return cur, False\n\n    # Sampling\n    def _sample_target(self, attractor, best_len, corridor_w):\n        r = self._rand()\n        if best_len is not None and r < self.informed_bias:\n            p = self._sample_in_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        r = self._rand()\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n        elif r < self.goal_bias + self.corridor_bias:\n            t = self._rand()\n            base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n            if self.is3:\n                p = (self._rand_range(base[0] - corridor_w, base[0] + corridor_w),\n                     self._rand_range(base[1] - corridor_w, base[1] + corridor_w),\n                     self._rand_range(base[2] - corridor_w, base[2] + corridor_w))\n            else:\n                p = (self._rand_range(base[0] - corridor_w, base[0] + corridor_w),\n                     self._rand_range(base[1] - corridor_w, base[1] + corridor_w))\n            p = self._clamp(p)\n            if not self._point_in_obstacles(p):\n                return p\n        # Uniform fallback limited retries\n        if self.is3:\n            for _ in range(12):\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n                if not self._point_in_obstacles(p):\n                    return p\n        else:\n            for _ in range(12):\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n                if not self._point_in_obstacles(p):\n                    return p\n        return None\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(20):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                if self._dist(p, f1) + self._dist(p, f2) <= max_sum:\n                    return p\n        return None\n\n    # Path utilities\n    def _assemble_full_path(self, u, v, side_a):\n        pu = u.path_from_root()\n        pv = v.path_from_root()\n        if side_a:\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        best = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            n = len(cur)\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            a = cur[i]; b = cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    cur = cand\n                    best = L\n            tries += 1\n        return cur\n\n    def _elastic_relax(self, pts, passes):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        alpha = 0.6\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                mid = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                tgt = tuple((1.0 - alpha) * cur[i][k] + alpha * mid[k] for k in range(self.dim))\n                if (not self._in_bounds(tgt)) or self._point_in_obstacles(tgt):\n                    continue\n                if self._edge_free(a, tgt) and self._edge_free(tgt, c):\n                    if tgt != cur[i]:\n                        cur[i] = tgt\n                        moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        p = self._visibility_prune(path)\n        p = self._shortcut(p, self.shortcut_attempts)\n        p = self._elastic_relax(p, self.relax_passes)\n        p = self._visibility_prune(p)\n        return p",
            "objective": -41.5137,
            "time_improvement": 76.0,
            "length_improvement": 12.0,
            "smoothness_improvement": 2280.0,
            "node_improvement": 86.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011682534217834472,
                    "num_nodes_avg": 90.0,
                    "path_length_avg": 174.69654519251782,
                    "smoothness_avg": 0.05500932206075824,
                    "success_improvement": 0.0,
                    "time_improvement": 52.80201351978747,
                    "node_improvement": 77.33568370687485,
                    "length_improvement": 4.246055336074347,
                    "smoothness_improvement": 761.0153449056593,
                    "objective_score": 22.193313982109146
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0223921537399292,
                    "num_nodes_avg": 151.0,
                    "path_length_avg": 243.39260845590448,
                    "smoothness_avg": 0.18946894378939338,
                    "success_improvement": 0.0,
                    "time_improvement": 86.3816967405798,
                    "node_improvement": 89.85419606262178,
                    "length_improvement": 18.74854162962448,
                    "smoothness_improvement": 4775.172392665187,
                    "objective_score": 61.03949596327456
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.006050515174865723,
                    "num_nodes_avg": 64.0,
                    "path_length_avg": 129.6031745448857,
                    "smoothness_avg": 0.11028457328976785,
                    "success_improvement": 0.0,
                    "time_improvement": 88.13332653751176,
                    "node_improvement": 91.86268277177369,
                    "length_improvement": 13.923742507267159,
                    "smoothness_improvement": 1302.8116318854163,
                    "objective_score": 41.308301625040905
                }
            ],
            "success_rate": 1.0
        },
        "objective": 19.2,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Excessive per-iteration overhead from neighbor-radius parent selection, ancestor visibility scans, local rewiring, and subtree cost propagation\n   - Greedy connection performs many progressive steps and opposite-tree insertions, inflating work before a bridge is found\n   - Nearest-neighbor lookup often falls back to broad scans, growing toward O(N) per query\n   - Aggressive duplicate suppression rejects many candidates, increasing failed expansions and iterations\n   - Heavy post-processing (many shortcuts and relaxation passes) adds substantial finalize-time latency\n   - Sampling uses many retries and broad corridors, causing more rejected or low-value targets\n   - Coarse obstacle binning yields large candidate sets for long edges and repeated collision checks across stages"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Removed neighbor-radius parent optimization, visibility-based reparenting, and local rewiring, keeping only nearest-parent insertion\n   - Replaced long greedy connection with a bounded micro-bridge limited to few steps\n   - Increased goal/informed sampling bias and narrowed sampling effort, with fewer uniform/ellipse retries\n   - Larger step size and smaller duplicate radius to reduce node count and raise insertion success\n   - Lighter smoothing (fewer shortcuts, fewer relaxation passes) and slightly tighter nearest search rings\n2. Expected mechanism of impact:\n   - Cuts per-iteration complexity and memory updates, reducing collision checks and neighbor scans\n   - Limits opposite-tree growth per attempt, shrinking connection overhead\n   - Focused sampling accelerates discovery of feasible bridges and reduces wasted expansions\n   - Fewer nodes and edges evaluated lead to faster convergence to a first solution\n   - Reduced post-processing work lowers end-to-end latency once a path is found"
        }
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "ZIP-Connect: a zero-idle, proximity-gated bi-directional RRT-Connect that accelerates planning by accept-on-Halton sampling, micro-grid nearest queries, and intermittent meeting attempts. It reduces collision checks by only trying goal/opposite-tree connections when geometrically near, avoids greedy multi-step linking, enforces duplicate spacing, and performs a single-pass visibility prune with a tiny shortcut budget.",
                "planning_mechanism": "Alternate expanding start/goal trees. Per iteration: draw a free sample via goal bias then Halton scanning; find the nearest via a 0\u20131 ring micro-grid; steer one step; if node and edge are free and not too-close, insert. Attempt an exact meeting to the attractor or the opposite tree only when within a small distance window, then stitch through the meeting node. Finalize with a greedy line-of-sight prune and a couple of shortcuts.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=2500,\n        step_size=8.0,\n        goal_bias=0.07,\n        grid_cell_factor=1.0,\n        min_separation_mult=0.5,\n        connect_window_mult=2.5,\n        smooth_shortcuts=2\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.min_sep_mult = float(min_separation_mult)\n        self.conn_mult = float(connect_window_mult)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self._rng = 1\n        self._hidx = 1\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step * self.min_sep_mult)\n        self.conn_win = max(self.step * 1.5, self.step * self.conn_mult)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Quick straight-line test\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and grids\n        root_s = Node(self.start, None, 0.0)\n        root_g = Node(self.goal, None, 0.0)\n        Ta = [root_s]\n        Tb = [root_g]\n        Ga = {}\n        Gb = {}\n        self._grid_add(Ga, root_s)\n        self._grid_add(Gb, root_g)\n        nodes.extend([root_s, root_g])\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            T_src = Ta if active_start else Tb\n            T_dst = Tb if active_start else Ta\n            G_src = Ga if active_start else Gb\n            G_dst = Gb if active_start else Ga\n            attractor = self.goal if active_start else self.start\n            other_root = root_g if active_start else root_s\n\n            q_rand = self._sample_free(attractor)\n            if q_rand is None:\n                continue\n\n            n_near = self._nearest(G_src, q_rand, T_src)\n            if n_near is None:\n                continue\n\n            q_new = self._steer(n_near.position, q_rand, self.step)\n            if (not self._in_bounds(q_new)) or self._point_in_obstacles(q_new):\n                continue\n            if self._too_close(G_src, q_new, self.min_sep):\n                continue\n            if not self._edge_free(n_near.position, q_new):\n                continue\n\n            nn = self._insert_node(T_src, G_src, n_near, q_new, nodes, edges)\n            if nn is None:\n                continue\n\n            # Opportunistic direct connect to attractor (goal/start) only when near\n            d_att = self._dist(nn.position, attractor)\n            if d_att <= self.conn_win and self._edge_free(nn.position, attractor):\n                meet = self._insert_node(T_src, G_src, nn, attractor, nodes, edges)\n                if meet is not None:\n                    if active_start:\n                        pa = self._trace_to_root(meet)\n                        pb = self._trace_to_root(root_g)\n                    else:\n                        pa = self._trace_to_root(root_s)\n                        pb = self._trace_to_root(meet)\n                    # Stitch via exact meeting at attractor\n                    path = pa if active_start else pb\n                    path = self._finalize_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n            # Intermittent opposite-tree meeting when close\n            n_other = self._nearest(G_dst, nn.position, T_dst)\n            if n_other is not None:\n                d_opp = self._dist(nn.position, n_other.position)\n                if d_opp <= self.conn_win and self._edge_free(n_other.position, nn.position):\n                    # Prefer inserting an exact meeting into the opposite tree if allowable\n                    if (not self._too_close(G_dst, nn.position, self.min_sep)) and (not self._point_in_obstacles(nn.position)):\n                        meetB = self._insert_node(T_dst, G_dst, n_other, nn.position, nodes, edges)\n                    else:\n                        meetB = n_other\n                    if meetB is not None:\n                        if active_start:\n                            pa = self._trace_to_root(nn)\n                            pb = self._trace_to_root(meetB)\n                            path = pa + pb[-2::-1]\n                        else:\n                            pa = self._trace_to_root(meetB)\n                            pb = self._trace_to_root(nn)\n                            path = pa + pb[-2::-1]\n                        path = self._finalize_path(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and Halton\n    def _seed_rng(self):\n        s = 0xA17E5EED\n        for v in self.start + self.goal:\n            iv = int(v * 1315423911) & 0xffffffff\n            s ^= (iv * 1103515245 + 12345) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 1\n        self._rng = s & 0xffffffff\n        self._hidx = 1\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _radical_inverse(self, base, i):\n        inv = 1.0 / base\n        f = inv\n        x = 0.0\n        n = i\n        while n > 0:\n            x += (n % base) * f\n            n //= base\n            f *= inv\n        return x\n\n    def _halton_point(self, idx):\n        if self.is3:\n            return (\n                self._radical_inverse(2, idx) * self.bounds[0],\n                self._radical_inverse(3, idx) * self.bounds[1],\n                self._radical_inverse(5, idx) * self.bounds[2],\n            )\n        else:\n            return (\n                self._radical_inverse(2, idx) * self.bounds[0],\n                self._radical_inverse(3, idx) * self.bounds[1],\n            )\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        out = []\n        for i in range(self.dim):\n            out.append(a[i] + (b[i] - a[i]) * r)\n        return self._clamp(tuple(out))\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Spatial hash\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        else:\n            return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos, T_list):\n        key = self._cell_key(pos)\n        # Micro-ring search for speed; small random fallback\n        for r in (0, 1):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                best = None\n                bestd = 1e100\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                return best\n        if not T_list:\n            return None\n        m = min(16, len(T_list))\n        best = None\n        bestd = 1e100\n        for _ in range(m):\n            j = int(self._rand_range(0, len(T_list)))\n            if j >= len(T_list):\n                j = len(T_list) - 1\n            n = T_list[j]\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, limit=None):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if limit is not None and len(out) >= limit:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if limit is not None and len(out) >= limit:\n                                return out\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius, limit=1)) > 0\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            bucket = self.obin.get(key)\n                            if bucket is None:\n                                self.obin[key] = [idx]\n                            else:\n                                bucket.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        bucket = self.obin.get(key)\n                        if bucket is None:\n                            self.obin[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Sampling\n    def _sample_free(self, attractor):\n        r = self._rand()\n        if r < self.goal_bias:\n            return attractor\n        # Try a short Halton scan to find a free sample\n        trials = 0\n        idx = self._hidx\n        while trials < 6:\n            p = self._halton_point(idx)\n            idx += 1\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                self._hidx = idx\n                return p\n            trials += 1\n        # Fallback to uniform random attempts\n        tries = 0\n        while tries < 6:\n            if self.is3:\n                p = (\n                    self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]),\n                )\n            else:\n                p = (\n                    self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                )\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n            tries += 1\n        return None\n\n    # Insert node (assumes checks done)\n    def _insert_node(self, tree, grid, parent, pos, nodes, edges):\n        if (not self._in_bounds(pos)) or self._point_in_obstacles(pos):\n            return None\n        if self._too_close(grid, pos, self.min_sep):\n            return None\n        if not self._edge_free(parent.position, pos):\n            return None\n        new_cost = parent.cost + self._dist(parent.position, pos)\n        nn = Node(pos, parent, new_cost)\n        parent.add_child(nn)\n        tree.append(nn)\n        nodes.append(nn)\n        edges.append((parent, nn))\n        self._grid_add(grid, nn)\n        return nn\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _prune_visibility(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3 or attempts <= 0:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._prune_visibility(path)\n        p2 = self._shortcut(p1, self.smooth_shortcuts)\n        out = []\n        last = None\n        for p in p2:\n            if (last is None) or (p != last):\n                out.append(p)\n                last = p\n        return out",
                "objective": -42.25413,
                "time_improvement": 82.0,
                "length_improvement": 13.0,
                "smoothness_improvement": 1949.0,
                "node_improvement": 88.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.006530570983886719,
                        "num_nodes_avg": 51.0,
                        "path_length_avg": 165.30934267335007,
                        "smoothness_avg": 0.06354030894209622,
                        "success_improvement": 0.0,
                        "time_improvement": 73.52967609821906,
                        "node_improvement": 87.15688743389575,
                        "length_improvement": 9.391329786573037,
                        "smoothness_improvement": 894.54381493312,
                        "objective_score": 32.16641977607514
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.012840461730957032,
                        "num_nodes_avg": 115.0,
                        "path_length_avg": 229.6388777300784,
                        "smoothness_avg": 0.11761146977996584,
                        "success_improvement": 0.0,
                        "time_improvement": 92.32266672748835,
                        "node_improvement": 92.27306322650003,
                        "length_improvement": 23.33993282509405,
                        "smoothness_improvement": 2926.2278295561136,
                        "objective_score": 56.3318988610835
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.010579800605773926,
                        "num_nodes_avg": 124.0,
                        "path_length_avg": 139.48550177732233,
                        "smoothness_avg": 0.1672303632461557,
                        "success_improvement": 0.0,
                        "time_improvement": 79.0402366958931,
                        "node_improvement": 84.23394787031151,
                        "length_improvement": 7.360371305336757,
                        "smoothness_improvement": 2027.1578768296877,
                        "objective_score": 38.26408317611842
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "time_expert",
                "algorithm_description": "ZIP-Connect: a zero-idle, proximity-gated bi-directional RRT-Connect that accelerates planning by accept-on-Halton sampling, micro-grid nearest queries, and intermittent meeting attempts. It reduces collision checks by only trying goal/opposite-tree connections when geometrically near, avoids greedy multi-step linking, enforces duplicate spacing, and performs a single-pass visibility prune with a tiny shortcut budget.",
                "planning_mechanism": "Alternate expanding start/goal trees. Per iteration: draw a free sample via goal bias then Halton scanning; find the nearest via a 0\u20131 ring micro-grid; steer one step; if node and edge are free and not too-close, insert. Attempt an exact meeting to the attractor or the opposite tree only when within a small distance window, then stitch through the meeting node. Finalize with a greedy line-of-sight prune and a couple of shortcuts.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=2500,\n        step_size=8.0,\n        goal_bias=0.07,\n        grid_cell_factor=1.0,\n        min_separation_mult=0.5,\n        connect_window_mult=2.5,\n        smooth_shortcuts=2\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.min_sep_mult = float(min_separation_mult)\n        self.conn_mult = float(connect_window_mult)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self._rng = 1\n        self._hidx = 1\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step * self.min_sep_mult)\n        self.conn_win = max(self.step * 1.5, self.step * self.conn_mult)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Quick straight-line test\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and grids\n        root_s = Node(self.start, None, 0.0)\n        root_g = Node(self.goal, None, 0.0)\n        Ta = [root_s]\n        Tb = [root_g]\n        Ga = {}\n        Gb = {}\n        self._grid_add(Ga, root_s)\n        self._grid_add(Gb, root_g)\n        nodes.extend([root_s, root_g])\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            T_src = Ta if active_start else Tb\n            T_dst = Tb if active_start else Ta\n            G_src = Ga if active_start else Gb\n            G_dst = Gb if active_start else Ga\n            attractor = self.goal if active_start else self.start\n            other_root = root_g if active_start else root_s\n\n            q_rand = self._sample_free(attractor)\n            if q_rand is None:\n                continue\n\n            n_near = self._nearest(G_src, q_rand, T_src)\n            if n_near is None:\n                continue\n\n            q_new = self._steer(n_near.position, q_rand, self.step)\n            if (not self._in_bounds(q_new)) or self._point_in_obstacles(q_new):\n                continue\n            if self._too_close(G_src, q_new, self.min_sep):\n                continue\n            if not self._edge_free(n_near.position, q_new):\n                continue\n\n            nn = self._insert_node(T_src, G_src, n_near, q_new, nodes, edges)\n            if nn is None:\n                continue\n\n            # Opportunistic direct connect to attractor (goal/start) only when near\n            d_att = self._dist(nn.position, attractor)\n            if d_att <= self.conn_win and self._edge_free(nn.position, attractor):\n                meet = self._insert_node(T_src, G_src, nn, attractor, nodes, edges)\n                if meet is not None:\n                    if active_start:\n                        pa = self._trace_to_root(meet)\n                        pb = self._trace_to_root(root_g)\n                    else:\n                        pa = self._trace_to_root(root_s)\n                        pb = self._trace_to_root(meet)\n                    # Stitch via exact meeting at attractor\n                    path = pa if active_start else pb\n                    path = self._finalize_path(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n            # Intermittent opposite-tree meeting when close\n            n_other = self._nearest(G_dst, nn.position, T_dst)\n            if n_other is not None:\n                d_opp = self._dist(nn.position, n_other.position)\n                if d_opp <= self.conn_win and self._edge_free(n_other.position, nn.position):\n                    # Prefer inserting an exact meeting into the opposite tree if allowable\n                    if (not self._too_close(G_dst, nn.position, self.min_sep)) and (not self._point_in_obstacles(nn.position)):\n                        meetB = self._insert_node(T_dst, G_dst, n_other, nn.position, nodes, edges)\n                    else:\n                        meetB = n_other\n                    if meetB is not None:\n                        if active_start:\n                            pa = self._trace_to_root(nn)\n                            pb = self._trace_to_root(meetB)\n                            path = pa + pb[-2::-1]\n                        else:\n                            pa = self._trace_to_root(meetB)\n                            pb = self._trace_to_root(nn)\n                            path = pa + pb[-2::-1]\n                        path = self._finalize_path(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and Halton\n    def _seed_rng(self):\n        s = 0xA17E5EED\n        for v in self.start + self.goal:\n            iv = int(v * 1315423911) & 0xffffffff\n            s ^= (iv * 1103515245 + 12345) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 1\n        self._rng = s & 0xffffffff\n        self._hidx = 1\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _radical_inverse(self, base, i):\n        inv = 1.0 / base\n        f = inv\n        x = 0.0\n        n = i\n        while n > 0:\n            x += (n % base) * f\n            n //= base\n            f *= inv\n        return x\n\n    def _halton_point(self, idx):\n        if self.is3:\n            return (\n                self._radical_inverse(2, idx) * self.bounds[0],\n                self._radical_inverse(3, idx) * self.bounds[1],\n                self._radical_inverse(5, idx) * self.bounds[2],\n            )\n        else:\n            return (\n                self._radical_inverse(2, idx) * self.bounds[0],\n                self._radical_inverse(3, idx) * self.bounds[1],\n            )\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        out = []\n        for i in range(self.dim):\n            out.append(a[i] + (b[i] - a[i]) * r)\n        return self._clamp(tuple(out))\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # Spatial hash\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        else:\n            return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos, T_list):\n        key = self._cell_key(pos)\n        # Micro-ring search for speed; small random fallback\n        for r in (0, 1):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                best = None\n                bestd = 1e100\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                return best\n        if not T_list:\n            return None\n        m = min(16, len(T_list))\n        best = None\n        bestd = 1e100\n        for _ in range(m):\n            j = int(self._rand_range(0, len(T_list)))\n            if j >= len(T_list):\n                j = len(T_list) - 1\n            n = T_list[j]\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, limit=None):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if limit is not None and len(out) >= limit:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if limit is not None and len(out) >= limit:\n                                return out\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_in_radius(grid, pos, radius, limit=1)) > 0\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            bucket = self.obin.get(key)\n                            if bucket is None:\n                                self.obin[key] = [idx]\n                            else:\n                                bucket.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        bucket = self.obin.get(key)\n                        if bucket is None:\n                            self.obin[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Sampling\n    def _sample_free(self, attractor):\n        r = self._rand()\n        if r < self.goal_bias:\n            return attractor\n        # Try a short Halton scan to find a free sample\n        trials = 0\n        idx = self._hidx\n        while trials < 6:\n            p = self._halton_point(idx)\n            idx += 1\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                self._hidx = idx\n                return p\n            trials += 1\n        # Fallback to uniform random attempts\n        tries = 0\n        while tries < 6:\n            if self.is3:\n                p = (\n                    self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]),\n                )\n            else:\n                p = (\n                    self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                )\n            if self._in_bounds(p) and (not self._point_in_obstacles(p)):\n                return p\n            tries += 1\n        return None\n\n    # Insert node (assumes checks done)\n    def _insert_node(self, tree, grid, parent, pos, nodes, edges):\n        if (not self._in_bounds(pos)) or self._point_in_obstacles(pos):\n            return None\n        if self._too_close(grid, pos, self.min_sep):\n            return None\n        if not self._edge_free(parent.position, pos):\n            return None\n        new_cost = parent.cost + self._dist(parent.position, pos)\n        nn = Node(pos, parent, new_cost)\n        parent.add_child(nn)\n        tree.append(nn)\n        nodes.append(nn)\n        edges.append((parent, nn))\n        self._grid_add(grid, nn)\n        return nn\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _prune_visibility(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3 or attempts <= 0:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._prune_visibility(path)\n        p2 = self._shortcut(p1, self.smooth_shortcuts)\n        out = []\n        last = None\n        for p in p2:\n            if (last is None) or (p != last):\n                out.append(p)\n                last = p\n        return out",
                "objective": -42.25413,
                "time_improvement": 82.0,
                "length_improvement": 13.0,
                "smoothness_improvement": 1949.0,
                "node_improvement": 88.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.006530570983886719,
                        "num_nodes_avg": 51.0,
                        "path_length_avg": 165.30934267335007,
                        "smoothness_avg": 0.06354030894209622,
                        "success_improvement": 0.0,
                        "time_improvement": 73.52967609821906,
                        "node_improvement": 87.15688743389575,
                        "length_improvement": 9.391329786573037,
                        "smoothness_improvement": 894.54381493312,
                        "objective_score": 32.16641977607514
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.012840461730957032,
                        "num_nodes_avg": 115.0,
                        "path_length_avg": 229.6388777300784,
                        "smoothness_avg": 0.11761146977996584,
                        "success_improvement": 0.0,
                        "time_improvement": 92.32266672748835,
                        "node_improvement": 92.27306322650003,
                        "length_improvement": 23.33993282509405,
                        "smoothness_improvement": 2926.2278295561136,
                        "objective_score": 56.3318988610835
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.010579800605773926,
                        "num_nodes_avg": 124.0,
                        "path_length_avg": 139.48550177732233,
                        "smoothness_avg": 0.1672303632461557,
                        "success_improvement": 0.0,
                        "time_improvement": 79.0402366958931,
                        "node_improvement": 84.23394787031151,
                        "length_improvement": 7.360371305336757,
                        "smoothness_improvement": 2027.1578768296877,
                        "objective_score": 38.26408317611842
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "ZIDC*: Informed Dual-Connect with Local Rewire \u2014 a bi-directional RRT*-Connect variant that grows greedily toward low-discrepancy samples, selects parents by local cost, performs radius-limited rewiring, and switches to informed (start\u2013goal ellipse) sampling after the first solution. A compact spatial hash accelerates near/nearest queries; obstacle-binned collision checks reduce segment tests; spacing is permissive to densify corridors; and a two-stage LOS+shortcut smoother improves curvature with minimal overhead.",
            "planning_mechanism": "Alternate expansions of start/goal trees. Each iteration: draw a goal-biased Halton sample; if a best cost exists, reject samples outside the start\u2013goal ellipse. From the nearest node, extend multiple steps toward the sample; at the first step, choose the best-cost visible parent among nearby nodes, insert, then locally rewire neighbors that benefit. After each insertion, greedily connect the opposite tree toward the new node; if it reaches (or can insert an exact meeting), stitch the trees and finalize with visibility pruning and shortcut smoothing.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=8.0,\n        goal_bias=0.1,\n        grid_cell_factor=1.0,\n        min_separation_mult=0.25,\n        connect_greedy_steps=64,\n        rewire_radius_mult=3.0,\n        smooth_shortcuts=32\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.sep_mult = float(min_separation_mult)\n        self.conn_steps = int(connect_greedy_steps)\n        self.rewire_mult = float(rewire_radius_mult)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self._rng = 1\n        self._h = 1\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if (not self._inside(self.start)) or (not self._inside(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.sep = max(0.25, self.step * self.sep_mult)\n        self.rewire_radius = max(self.step * 1.5, self.step * self.rewire_mult)\n\n        self._build_obstacle_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Direct path quick check\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and spatial hashes\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        Ta, Tb = [root_a], [root_b]\n        Ga, Gb = {}, {}\n        self._grid_put(Ga, root_a)\n        self._grid_put(Gb, root_b)\n        nodes.extend([root_a, root_b])\n\n        best_cost = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            from_start_side = (it % 2 == 0)\n            T_src, T_dst = (Ta, Tb) if from_start_side else (Tb, Ta)\n            G_src, G_dst = (Ga, Gb) if from_start_side else (Gb, Ga)\n            attractor = self.goal if from_start_side else self.start\n\n            q = self._sample(attractor, best_cost)\n            if q is None:\n                continue\n\n            new_node = self._extend_greedy(T_src, G_src, q, nodes, edges, choose_parent=True, do_rewire=True)\n            if new_node is None:\n                continue\n\n            meet = self._connect_toward(T_dst, G_dst, new_node.position, nodes, edges)\n            if meet is not None:\n                # Stitch and finalize\n                if from_start_side:\n                    path_a = self._path_to_root(new_node)\n                    path_b = self._path_to_root(meet)\n                    path = path_a + path_b[-2::-1]\n                else:\n                    path_a = self._path_to_root(meet)\n                    path_b = self._path_to_root(new_node)\n                    path = path_a + path_b[-2::-1]\n                path = self._finalize(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Opportunistic goal/start direct bridging when close and visible\n            tgt = attractor\n            if self._dist(new_node.position, tgt) <= self.conn_steps * self.step:\n                if self._edge_free(new_node.position, tgt):\n                    # Insert exact meeting into the same tree (ignoring spacing for solution stitching)\n                    meet_node = self._attach_node(T_src, G_src, new_node, tgt, nodes, edges, ignore_spacing=True)\n                    if meet_node is not None:\n                        if from_start_side:\n                            path = self._path_to_root(meet_node)\n                        else:\n                            path = self._path_to_root(meet_node)\n                        path = self._finalize(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n            # Maintain an incremental best path via nearest opposite if visible\n            near_dst = self._nearest(G_dst, new_node.position, T_dst)\n            if near_dst and self._edge_free(new_node.position, near_dst.position):\n                tentative = self._path_to_root(new_node) + self._path_to_root(near_dst)[-2::-1]\n                cost = self._polyline_len(tentative)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_path = tentative\n\n        if best_path is not None:\n            best_path = self._finalize(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and sampling\n    def _seed(self):\n        s = 0x9E3779B1\n        for v in self.start + self.goal:\n            s ^= (int(v * 2654435761) & 0xffffffff)\n            s = (s * 1664525 + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 1\n        self._rng = s\n        self._h = 1\n\n    def _rand(self):\n        self._rng = (self._rng * 1103515245 + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _halton(self, i, base):\n        f = 1.0 / base\n        r = 0.0\n        while i > 0:\n            r += (i % base) * f\n            i //= base\n            f /= base\n        return r\n\n    def _halton_point(self, idx):\n        if self.is3:\n            return (\n                self._halton(idx, 2) * self.bounds[0],\n                self._halton(idx, 3) * self.bounds[1],\n                self._halton(idx, 5) * self.bounds[2],\n            )\n        else:\n            return (\n                self._halton(idx, 2) * self.bounds[0],\n                self._halton(idx, 3) * self.bounds[1],\n            )\n\n    def _sample(self, attractor, c_best):\n        r = self._rand()\n        if r < self.goal_bias:\n            return attractor\n\n        # Try a few Halton candidates (filtered by informed set if available)\n        tries = 0\n        idx = self._h\n        while tries < 8:\n            p = self._halton_point(idx)\n            idx += 1\n            tries += 1\n            if (not self._inside(p)) or self._point_blocked(p):\n                continue\n            if c_best < float('inf'):\n                if (self._dist(self.start, p) + self._dist(p, self.goal)) > (c_best + 1e-9):\n                    continue\n            self._h = idx\n            return p\n\n        # Fallback uniform attempts\n        for _ in range(16):\n            if self.is3:\n                p = (\n                    self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]),\n                )\n            else:\n                p = (\n                    self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                )\n            if (not self._inside(p)) or self._point_blocked(p):\n                continue\n            if c_best < float('inf'):\n                if (self._dist(self.start, p) + self._dist(p, self.goal)) > (c_best + 1e-9):\n                    continue\n            return p\n        return None\n\n    # Geometry\n    def _inside(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        out = []\n        for i in range(self.dim):\n            out.append(a[i] + (b[i] - a[i]) * r)\n        return tuple(out)\n\n    # Spatial hash for nodes\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        else:\n            return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_put(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos, T_list):\n        key = self._cell_key(pos)\n        # Expand search rings up to 2 then fallback\n        for r in (0, 1, 2):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                best = None\n                bestd = float('inf')\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                return best\n        # Fallback to partial linear scan (sample up to 64)\n        if not T_list:\n            return None\n        m = min(len(T_list), 64)\n        best = None\n        bestd = float('inf')\n        step = max(1, len(T_list) // m)\n        for i in range(0, len(T_list), step):\n            n = T_list[i]\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, limit=None):\n        key = self._cell_key(pos)\n        rc = int(max(1, radius // self.cell)) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if limit is not None and len(out) >= limit:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if limit is not None and len(out) >= limit:\n                                return out\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        nbr = self._neighbors(grid, pos, radius, limit=1)\n        return len(nbr) > 0\n\n    # Obstacles and collision\n    def _build_obstacle_bins(self):\n        self.ob_cell = max(4.0, self.step * 2.0)\n        self.ob_grid = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.ob_cell)\n                iy0 = int(max(0.0, y) // self.ob_cell)\n                iz0 = int(max(0.0, z) // self.ob_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.ob_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.ob_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.ob_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            bucket = self.ob_grid.get(key)\n                            if bucket is None:\n                                self.ob_grid[key] = [idx]\n                            else:\n                                bucket.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.ob_cell)\n                iy0 = int(max(0.0, y) // self.ob_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.ob_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.ob_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        bucket = self.ob_grid.get(key)\n                        if bucket is None:\n                            self.ob_grid[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.ob_cell)\n            iy = int(p[1] // self.ob_cell)\n            iz = int(p[2] // self.ob_cell)\n            bucket = self.ob_grid.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.ob_cell)\n            iy = int(p[1] // self.ob_cell)\n            bucket = self.ob_grid.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits(a, b)\n\n    def _segment_hits(self, a, b):\n        # Collect candidate bins intersecting bounding box of segment\n        if self.is3:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1],\n                  a[2] if a[2] < b[2] else b[2])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1],\n                  a[2] if a[2] > b[2] else b[2])\n            ix0 = int(max(0.0, mn[0]) // self.ob_cell)\n            iy0 = int(max(0.0, mn[1]) // self.ob_cell)\n            iz0 = int(max(0.0, mn[2]) // self.ob_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.ob_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.ob_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.ob_cell)\n            cand = []\n            seen = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.ob_grid.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                if idx not in seen:\n                                    seen.add(idx)\n                                    cand.append(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1])\n            ix0 = int(max(0.0, mn[0]) // self.ob_cell)\n            iy0 = int(max(0.0, mn[1]) // self.ob_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.ob_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.ob_cell)\n            cand = []\n            seen = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.ob_grid.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            if idx not in seen:\n                                seen.add(idx)\n                                cand.append(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box(self, p0, p1, bmin, bmax):\n        # Slab intersection test\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Tree operations\n    def _attach_node(self, tree, grid, parent, pos, nodes, edges, ignore_spacing=False):\n        if (not self._inside(pos)) or self._point_blocked(pos):\n            return None\n        if (not ignore_spacing) and self._too_close(grid, pos, self.sep):\n            return None\n        if not self._edge_free(parent.position, pos):\n            return None\n        ncost = parent.cost + self._dist(parent.position, pos)\n        nd = Node(pos, parent, ncost)\n        parent.add_child(nd)\n        tree.append(nd)\n        nodes.append(nd)\n        edges.append((parent, nd))\n        self._grid_put(grid, nd)\n        return nd\n\n    def _choose_parent_and_attach(self, tree, grid, near, pos, nodes, edges):\n        # Evaluate possible parents among neighbors for minimal cost\n        best_parent = near\n        best_cost = near.cost + self._dist(near.position, pos)\n        nbrs = self._neighbors(grid, pos, self.rewire_radius)\n        for n in nbrs:\n            if self._edge_free(n.position, pos):\n                c = n.cost + self._dist(n.position, pos)\n                if c < best_cost:\n                    best_cost = c\n                    best_parent = n\n        return self._attach_node(tree, grid, best_parent, pos, nodes, edges)\n\n    def _propagate_cost(self, node):\n        # Update costs down the subtree from this node\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                base = 0.0\n            else:\n                base = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            cur.cost = base\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _rewire_neighbors(self, tree, grid, new_node, edges):\n        nbrs = self._neighbors(grid, new_node.position, self.rewire_radius)\n        for nb in nbrs:\n            if nb is new_node or nb.parent is None:\n                continue\n            alt = new_node.cost + self._dist(new_node.position, nb.position)\n            if alt + 1e-9 < nb.cost and self._edge_free(new_node.position, nb.position):\n                # Rewire nb to new_node\n                oldp = nb.parent\n                # Remove edge (oldp, nb)\n                for i in range(len(edges) - 1, -1, -1):\n                    if edges[i][0] is oldp and edges[i][1] is nb:\n                        edges.pop(i)\n                        break\n                # Update parent-child lists\n                if nb in oldp.children:\n                    oldp.children.remove(nb)\n                new_node.add_child(nb)\n                # Add new edge\n                edges.append((new_node, nb))\n                # Propagate new costs\n                self._propagate_cost(nb)\n\n    def _extend_greedy(self, tree, grid, target, nodes, edges, choose_parent=True, do_rewire=True):\n        near = self._nearest(grid, target, tree)\n        if near is None:\n            return None\n        cur = near\n        created_any = None\n        steps = 0\n        first = True\n        while steps < max(2, int(self.conn_steps // 4)):\n            nxt = self._steer(cur.position, target, self.step)\n            if (not self._inside(nxt)) or self._point_blocked(nxt):\n                break\n            if self._too_close(grid, nxt, self.sep):\n                # If too dense around, stop this branch\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            if first and choose_parent:\n                ins = self._choose_parent_and_attach(tree, grid, cur, nxt, nodes, edges)\n            else:\n                ins = self._attach_node(tree, grid, cur, nxt, nodes, edges)\n            if ins is None:\n                break\n            created_any = ins\n            if do_rewire:\n                self._rewire_neighbors(tree, grid, ins, edges)\n            cur = ins\n            steps += 1\n            if self._dist2(nxt, target) <= (self.step * self.step * 0.25):\n                break\n        return created_any\n\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        near = self._nearest(grid, target_pos, tree)\n        if near is None:\n            return None\n        cur = near\n        steps = 0\n        last_new = None\n        while steps < self.conn_steps:\n            nxt = self._steer(cur.position, target_pos, self.step)\n            if (not self._inside(nxt)) or self._point_blocked(nxt):\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            ins = self._attach_node(tree, grid, cur, nxt, nodes, edges)\n            if ins is None:\n                break\n            last_new = ins\n            cur = ins\n            steps += 1\n            if self._dist2(nxt, target_pos) <= (self.step * self.step * 0.25):\n                break\n        # Try to insert exact meeting node at target (ignore spacing but respect collisions)\n        if last_new is not None:\n            if self._edge_free(last_new.position, target_pos) and (not self._point_blocked(target_pos)) and self._inside(target_pos):\n                meet = self._attach_node(tree, grid, last_new, target_pos, nodes, edges, ignore_spacing=True)\n                if meet is not None:\n                    return meet\n        return None\n\n    # Path utilities\n    def _path_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _polyline_len(self, pts):\n        if len(pts) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(pts)):\n            s += self._dist(pts[i - 1], pts[i])\n        return s\n\n    def _prune_los(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3 or attempts <= 0:\n            return pts[:]\n        cur = pts[:]\n        t = 0\n        while t < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                t += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cur = cur[:i + 1] + cur[j:]\n            t += 1\n        # remove consecutive duplicates\n        out = []\n        last = None\n        for p in cur:\n            if (last is None) or (p != last):\n                out.append(p)\n                last = p\n        return out\n\n    def _finalize(self, pts):\n        if not pts or len(pts) < 2:\n            return pts\n        p1 = self._prune_los(pts)\n        p2 = self._shortcut(p1, self.smooth_shortcuts)\n        return p2",
            "objective": -40.853,
            "time_improvement": 81.0,
            "length_improvement": 13.0,
            "smoothness_improvement": 1732.0,
            "node_improvement": 90.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009050464630126953,
                    "num_nodes_avg": 62.0,
                    "path_length_avg": 167.25184196372624,
                    "smoothness_avg": 0.05773376057210564,
                    "success_improvement": 0.0,
                    "time_improvement": 63.4356981723821,
                    "node_improvement": 84.38680433140266,
                    "length_improvement": 8.326615144646848,
                    "smoothness_improvement": 803.658723821166,
                    "objective_score": 28.044972157608566
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.007950639724731446,
                    "num_nodes_avg": 70.0,
                    "path_length_avg": 251.14175674494882,
                    "smoothness_avg": 0.12433013000291153,
                    "success_improvement": 0.0,
                    "time_improvement": 95.16463560694861,
                    "node_improvement": 95.29664718134785,
                    "length_improvement": 16.161652883875146,
                    "smoothness_improvement": 3099.103796347861,
                    "objective_score": 53.74190139414897
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.007700490951538086,
                    "num_nodes_avg": 72.0,
                    "path_length_avg": 128.38035355103494,
                    "smoothness_avg": 0.1094566942751672,
                    "success_improvement": 0.0,
                    "time_improvement": 84.89728411849231,
                    "node_improvement": 90.8455181182454,
                    "length_improvement": 14.735881986904387,
                    "smoothness_improvement": 1292.2810719273684,
                    "objective_score": 40.77211978732716
                }
            ],
            "success_rate": 1.0
        },
        "objective": 49.0,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient nearest selection (tiny local search with random fallback) leading to poor parent choices and extra collision checks.\n   - Single-step edge growth and narrow connection attempts, requiring many iterations to bridge trees.\n   - Overly strict node-spacing that rejects many valid inserts in narrow passages, slowing progress.\n   - Uninformed sampling with few retries, yielding many invalid samples and wasted iterations in clutter.\n   - Redundant validity checks during insertion that duplicate bounds/obstacle/edge tests.\n   - Minimal post-processing that leaves kinked polylines, limiting opportunities for early informed focusing."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Greedy multi-step extension and aggressive opposite-tree connection with exact-meet insertion.\n   - Informed, low-discrepancy sampling gated by the current best path length (early focus once a tentative path exists).\n   - Cost-aware parent selection with radius-limited local rewiring to improve local connectivity.\n   - Relaxed spacing to increase acceptance in tight corridors and reduce sample waste.\n   - More robust nearest lookup (larger neighborhood and partial scan) plus lean obstacle-bin candidate de-duplication.\n2. Expected mechanism of impact:\n   - Fewer iterations to first connection by extending multiple steps and opportunistically stitching trees.\n   - Earlier discovery of a feasible path triggers focused sampling, shrinking the explored volume and cutting failed expansions.\n   - Better parent/rewire choices create straighter, lower-resistance frontiers, reducing collision checks and retries in subsequent growth.\n   - Higher insertion acceptance and improved nearest accuracy decrease wasted samples and invalid edges, lowering overall compute time."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "BIRCH-Connect: a simplified balanced bi-tree planner with light cost-aware parenting, on-the-fly micro-rewiring, and lazy direct bridging. It uses compact grids for fast proximity/collision, small unbiased sampling mix, bounded single-step growth, and greedy connect to rapidly join trees. A lean two-pass shortcut and LOS collapse improve smoothness/length with minimal overhead.",
                "planning_mechanism": "Alternate expansion of the smaller tree. Sample from a uniform/line/goal mixture; steer one bounded step; validate node and edge; pick the cheapest feasible parent among a few nearest; insert and lightly rewire nearby nodes to reduce cost. Immediately try a direct bridge to the opposite tree, else greedily connect it toward the new node. On success, assemble start\u2192goal path, run two-stage smoothing, and return.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            # detach from old parent\n            i = 0\n            while i < len(self.parent.children):\n                if self.parent.children[i] is self:\n                    self.parent.children.pop(i)\n                    break\n                i += 1\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=2500,\n        step_size=5.5,\n        goal_bias=0.12,\n        corridor_bias=0.28,\n        grid_cell_factor=1.0,\n        neighbor_radius_factor=2.2,\n        neighbor_cap=8,\n        rewire_cap=6,\n        connect_steps=28,\n        shortcut_attempts=60\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_radius_factor = float(neighbor_radius_factor)\n        self.neighbor_cap = int(max(1, neighbor_cap))\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(0, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n\n        self._rng = 123456789\n\n    def plan(self, map):\n        # Scene setup\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n\n        self._seed_rng()\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Build obstacle grid and early invalid checks\n        self._build_obstacle_grid()\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight-line success\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.children.append(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Planner structures\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.neighbor_radius = max(self.step * 1.2, self.step * self.neighbor_radius_factor)\n        self.dupe_eps = max(1e-3, 0.05 * self.step)\n\n        rootA = Node(self.start, None, 0.0)\n        rootB = Node(self.goal, None, 0.0)\n        nodes.extend([rootA, rootB])\n\n        treeA = [rootA]\n        treeB = [rootB]\n        gridA, gridB = {}, {}\n        seenA, seenB = set(), set()\n\n        self._grid_insert(gridA, rootA)\n        self._grid_insert(gridB, rootB)\n        seenA.add(self._dupe_key(rootA.position))\n        seenB.add(self._dupe_key(rootB.position))\n\n        # Main loop\n        for it in range(self.max_iter):\n            useA = (len(treeA) <= len(treeB))\n            active_tree = treeA if useA else treeB\n            passive_tree = treeB if useA else treeA\n            active_grid = gridA if useA else gridB\n            passive_grid = gridB if useA else gridA\n            seen_active = seenA if useA else seenB\n            seen_passive = seenB if useA else seenA\n            attractor = self.goal if useA else self.start\n\n            s = self._sample(attractor)\n            if s is None:\n                continue\n\n            qnear = self._nearest(active_grid, s)\n            if qnear is None:\n                continue\n\n            qpos = self._steer(qnear.position, s, self.step)\n            if not self._in_bounds(qpos):\n                continue\n            if self._point_blocked(qpos):\n                continue\n            pk = self._dupe_key(qpos)\n            if pk in seen_active:\n                continue\n\n            parent, new_cost = self._choose_parent(active_grid, qnear, qpos)\n            if parent is None:\n                continue\n\n            # Both checks required before adding any node/edge\n            if self._point_blocked(qpos):\n                continue\n            if not self._edge_free(parent.position, qpos):\n                continue\n\n            qnew = Node(qpos, parent, new_cost)\n            parent.children.append(qnew)\n            active_tree.append(qnew)\n            nodes.append(qnew)\n            edges.append((parent, qnew))\n            self._grid_insert(active_grid, qnew)\n            seen_active.add(pk)\n\n            # Light rewiring to improve path length locally\n            if self.rewire_cap > 0:\n                self._rewire_neighbors(active_grid, qnew, edges)\n\n            # Try lazy direct bridge to opposite tree\n            opp_near = self._nearest(passive_grid, qnew.position)\n            bridged = False\n            bridge_meet = None\n            if opp_near is not None and self._edge_free(opp_near.position, qnew.position):\n                bridged = True\n                bridge_meet = opp_near\n            else:\n                # Greedy connect opposite tree toward new node\n                bridge_meet = self._connect_toward(passive_tree, passive_grid, qnew.position, nodes, edges, seen_passive)\n                if bridge_meet is not None and self._edge_free(bridge_meet.position, qnew.position):\n                    bridged = True\n\n            if bridged and bridge_meet is not None:\n                path = self._assemble_path(qnew, bridge_meet, useA, rootA, rootB)\n                path = self._postprocess(path)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG utilities\n    def _seed_rng(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        self._rng = (s ^ 0x9E3779B9) & 0xffffffff\n        if self._rng == 0:\n            self._rng = 123456789\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            q = [self._clamp(b[i], 0.0, self.bounds[i]) for i in range(self.dims)]\n            return tuple(q)\n        d = d2 ** 0.5\n        r = step / d\n        q = [self._clamp(a[i] + (b[i] - a[i]) * r, 0.0, self.bounds[i]) for i in range(self.dims)]\n        return tuple(q)\n\n    # Obstacle grid\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step * 2.0)\n        self._ogrid = {}\n        if self.is3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self._ogrid.get(k)\n                            if b is None:\n                                self._ogrid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self._ogrid.get(k)\n                        if b is None:\n                            self._ogrid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self._ogrid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x0, y0, z0 = p\n            i = 0\n            while i < len(bucket):\n                x, y, z, w, h, d = self.obstacles[bucket[i]]\n                if x <= x0 <= x + w and y <= y0 <= y + h and z <= z0 <= z + d:\n                    return True\n                i += 1\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self._ogrid.get((cx, cy))\n            if not bucket:\n                return False\n            x0, y0 = p\n            i = 0\n            while i < len(bucket):\n                x, y, w, h = self.obstacles[bucket[i]]\n                if x <= x0 <= x + w and y <= y0 <= y + h:\n                    return True\n                i += 1\n            return False\n\n    def _seg_aabb_hit(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(self.dims):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        # Collect obstacle candidates overlapping segment AABB\n        if self.is3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            seen = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        lst = self._ogrid.get((cx, cy, cz))\n                        if lst:\n                            i = 0\n                            while i < len(lst):\n                                idx = lst[i]\n                                if idx not in seen:\n                                    seen.add(idx)\n                                i += 1\n            if not seen:\n                return True\n            for idx in seen:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_hit(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return False\n            return True\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            seen = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    lst = self._ogrid.get((cx, cy))\n                    if lst:\n                        i = 0\n                        while i < len(lst):\n                            idx = lst[i]\n                            if idx not in seen:\n                                seen.add(idx)\n                            i += 1\n            if not seen:\n                return True\n            for idx in seen:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_hit(a, b, (x, y), (x + w, y + h)):\n                    return False\n            return True\n\n    # Tree grid\n    def _cell_of(self, pos):\n        if self.is3d:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_insert(self, grid, node):\n        k = self._cell_of(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.is3d:\n            dx = -r\n            while dx <= r:\n                dy = -r\n                while dy <= r:\n                    dz = -r\n                    while dz <= r:\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n                        dz += 1\n                    dy += 1\n                dx += 1\n        else:\n            dx = -r\n            while dx <= r:\n                dy = -r\n                while dy <= r:\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n                    dy += 1\n                dx += 1\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_of(pos)\n        best = None\n        bestd2 = 1e100\n        r = 0\n        while r <= 3:\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                i = 0\n                while i < len(cand):\n                    n = cand[i]\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd2:\n                        bestd2 = d2\n                        best = n\n                    i += 1\n                if best is not None:\n                    return best\n            r += 1\n        # Rare fallback: light random probing\n        buckets = list(grid.values())\n        if not buckets:\n            return None\n        trials = 0\n        while trials < 24:\n            b = buckets[int(self._rand() * len(buckets)) % max(1, len(buckets))]\n            if b:\n                n = b[int(self._rand() * len(b)) % max(1, len(b))]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            trials += 1\n        return best\n\n    def _dupe_key(self, pos):\n        if self.is3d:\n            return (int(pos[0] / self.dupe_eps), int(pos[1] / self.dupe_eps), int(pos[2] / self.dupe_eps))\n        return (int(pos[0] / self.dupe_eps), int(pos[1] / self.dupe_eps))\n\n    # Neighbor selection and parenting\n    def _k_nearest_within(self, grid, pos, radius, kcap):\n        key = self._cell_of(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        # Maintain a small pool of top-k by distance\n        pool_d2 = []\n        pool_n = []\n        ring_nodes = self._ring_collect(grid, key, rc)\n        i = 0\n        while i < len(ring_nodes):\n            n = ring_nodes[i]\n            d2 = self._dist2(n.position, pos)\n            if d2 <= r2:\n                if len(pool_n) < kcap:\n                    pool_n.append(n)\n                    pool_d2.append(d2)\n                else:\n                    # Replace worst if better\n                    worst_idx = 0\n                    worst_val = pool_d2[0]\n                    j = 1\n                    while j < len(pool_d2):\n                        if pool_d2[j] > worst_val:\n                            worst_val = pool_d2[j]\n                            worst_idx = j\n                        j += 1\n                    if d2 < worst_val:\n                        pool_d2[worst_idx] = d2\n                        pool_n[worst_idx] = n\n            i += 1\n        # Bubble small ordering by distance for stability\n        m = len(pool_n)\n        if m > 1:\n            swapped = True\n            while swapped:\n                swapped = False\n                j = 1\n                while j < m:\n                    if pool_d2[j] < pool_d2[j - 1]:\n                        pool_d2[j], pool_d2[j - 1] = pool_d2[j - 1], pool_d2[j]\n                        pool_n[j], pool_n[j - 1] = pool_n[j - 1], pool_n[j]\n                        swapped = True\n                    j += 1\n        return pool_n\n\n    def _choose_parent(self, grid, nearest, new_pos):\n        candidates = self._k_nearest_within(grid, new_pos, self.neighbor_radius, self.neighbor_cap)\n        if nearest is not None and nearest not in candidates:\n            candidates.append(nearest)\n        if not candidates:\n            return None, None\n        best_parent = None\n        best_cost = 1e100\n        i = 0\n        while i < len(candidates):\n            n = candidates[i]\n            if self._edge_free(n.position, new_pos):\n                c = n.cost + self._dist(n.position, new_pos)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best_parent = n\n            i += 1\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    def _rewire_neighbors(self, grid, new_node, edges):\n        neigh = self._k_nearest_within(grid, new_node.position, self.neighbor_radius, max(2, self.rewire_cap * 2))\n        count = 0\n        i = 0\n        while i < len(neigh) and count < self.rewire_cap:\n            n = neigh[i]\n            if n is new_node or n.parent is None:\n                i += 1\n                continue\n            via_cost = new_node.cost + self._dist(new_node.position, n.position)\n            if via_cost + 1e-9 < n.cost and self._edge_free(new_node.position, n.position):\n                old_parent = n.parent\n                # Update edges list: remove old edge\n                ei = 0\n                while ei < len(edges):\n                    if edges[ei][0] is old_parent and edges[ei][1] is n:\n                        edges.pop(ei)\n                        break\n                    ei += 1\n                # Reparent\n                n.attach(new_node)\n                n.cost = via_cost\n                edges.append((new_node, n))\n                # Propagate cost delta to descendants (light BFS)\n                dq = [n]\n                while dq:\n                    cur = dq.pop()\n                    cj = 0\n                    while cj < len(cur.children):\n                        ch = cur.children[cj]\n                        newc = cur.cost + self._dist(cur.position, ch.position)\n                        if newc + 1e-12 < ch.cost:\n                            ch.cost = newc\n                            dq.append(ch)\n                        else:\n                            # Even if not strictly better, align to parent-based cost for coherence\n                            ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                            dq.append(ch)\n                        cj += 1\n                count += 1\n            i += 1\n\n    # Passive connect\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges, seen_set):\n        near = self._nearest(grid, target_pos)\n        if near is None:\n            return None\n        cur = near\n        steps = 0\n        while steps < self.connect_steps:\n            nxt_pos = self._steer(cur.position, target_pos, self.step)\n            if not self._in_bounds(nxt_pos):\n                break\n            if self._point_blocked(nxt_pos):\n                break\n            if not self._edge_free(cur.position, nxt_pos):\n                break\n            pk = self._dupe_key(nxt_pos)\n            if pk in seen_set:\n                break\n            new_cost = cur.cost + self._dist(cur.position, nxt_pos)\n            q = Node(nxt_pos, cur, new_cost)\n            cur.children.append(q)\n            tree.append(q)\n            nodes.append(q)\n            edges.append((cur, q))\n            self._grid_insert(grid, q)\n            seen_set.add(pk)\n            cur = q\n            steps += 1\n            # If close enough, let outer check do the final direct edge test\n            if self._dist2(cur.position, target_pos) <= (self.step * self.step):\n                return cur\n        return cur if steps > 0 else None\n\n    # Sampling\n    def _sample(self, attractor):\n        tries = 16\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            elif r < self.goal_bias + self.corridor_bias:\n                p = self._corridor_sample()\n            else:\n                if self.is3d:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._point_blocked(p):\n                return p\n        # Fallback to attractor if valid\n        if self._in_bounds(attractor) and not self._point_blocked(attractor):\n            return attractor\n        return None\n\n    def _corridor_sample(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        width = max(self.step, 0.1 * self._dist(self.start, self.goal))\n        if self.is3d:\n            return (self._clamp(base[0] + self._rand_range(-width, width), 0.0, self.bounds[0]),\n                    self._clamp(base[1] + self._rand_range(-width, width), 0.0, self.bounds[1]),\n                    self._clamp(base[2] + self._rand_range(-width, width), 0.0, self.bounds[2]))\n        else:\n            return (self._clamp(base[0] + self._rand_range(-width, width), 0.0, self.bounds[0]),\n                    self._clamp(base[1] + self._rand_range(-width, width), 0.0, self.bounds[1]))\n\n    # Path assembly\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _assemble_path(self, new_node, meet_node, used_A, rootA, rootB):\n        # Build full path start->...->new_node + meet_node->...->goal\n        pa = self._path_to_root(new_node)\n        pb = self._path_to_root(meet_node)\n        # Determine tree sides to maintain start->goal ordering\n        if used_A:\n            # active was A (start side)\n            if pa and pb and pa[-1] == pb[-1]:\n                # Shared root; connect directly\n                pb = pb[:-1]\n            pb.reverse()\n            return pa + pb\n        else:\n            # active was B (goal side)\n            if pa and pb and pa[-1] == pb[-1]:\n                pb = pb[:-1]\n            pa.reverse()\n            return pb + pa\n\n    # Postprocess smoothing\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        i = 1\n        while i < len(path):\n            L += self._dist(path[i - 1], path[i])\n            i += 1\n        return L\n\n    def _los_pass(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        while i < len(path) - 1:\n            if self._edge_free(anchor, path[i + 1]):\n                i += 1\n                continue\n            out.append(path[i])\n            anchor = path[i]\n            i += 1\n        out.append(path[-1])\n        return out\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        # Deterministic forward collapse\n        i = 0\n        while i < len(pts) - 2:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n        # Random attempts\n        attempts = 0\n        nmax = self.shortcut_attempts\n        while attempts < nmax and len(pts) > 2:\n            a = int(self._rand_range(0, len(pts) - 2))\n            b = int(self._rand_range(a + 2, len(pts)))\n            if b <= a + 1 or b > len(pts) - 1:\n                attempts += 1\n                continue\n            if self._edge_free(pts[a], pts[b]):\n                pts = pts[:a + 1] + pts[b:]\n            attempts += 1\n        return pts\n\n    def _postprocess(self, path):\n        p = self._los_pass(path)\n        p = self._shortcut(p)\n        p = self._los_pass(p)\n        return p",
                "objective": -31.52876,
                "time_improvement": 42.0,
                "length_improvement": 18.0,
                "smoothness_improvement": 1623.0,
                "node_improvement": 81.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.007032966613769532,
                        "num_nodes_avg": 39.0,
                        "path_length_avg": 154.24577587029222,
                        "smoothness_avg": 0.04478997382096041,
                        "success_improvement": 0.0,
                        "time_improvement": 71.58648483599214,
                        "node_improvement": 90.1787962729791,
                        "length_improvement": 15.455446064763862,
                        "smoothness_improvement": 601.0603532829306,
                        "objective_score": 33.754514856070614
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.06168980598449707,
                        "num_nodes_avg": 233.0,
                        "path_length_avg": 231.80862249800347,
                        "smoothness_avg": 0.11963903302084064,
                        "success_improvement": 0.0,
                        "time_improvement": 62.48192578217211,
                        "node_improvement": 84.34455418934354,
                        "length_improvement": 22.615609568920295,
                        "smoothness_improvement": 2978.3984921385954,
                        "objective_score": 47.20593593669678
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.05515027046203613,
                        "num_nodes_avg": 246.0,
                        "path_length_avg": 126.40017126941231,
                        "smoothness_avg": 0.10919114293538686,
                        "success_improvement": 0.0,
                        "time_improvement": -8.164384689014012,
                        "node_improvement": 68.72218690400508,
                        "length_improvement": 16.051024772210663,
                        "smoothness_improvement": 1288.9032784863234,
                        "objective_score": 13.625815849053811
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "FROND-Connect Lite: a simplified bi-directional planner that blends uniform sampling with tiny goal bias, bounded single-step growth, dynamic neighbor radius, and light local rewiring. It maintains compact spatial hashes per tree for fast proximity, performs lazy one-step greedy bridging, and exits on the first valid connection. A two-pass collision-aware line-of-sight and shortcut post-smoother improves length and smoothness with minimal overhead.",
            "planning_mechanism": "Alternate expansion of the smaller tree. Sample uniformly (with small goal bias); if a path has been found, restrict samples to the prolate ellipsoid defined by start, goal, and current best length (informed sampling). Steer one step from the nearest node; validate node and edge; select a parent among a few nearest to minimize cost; insert and lightly rewire nearby nodes. Attempt a direct bridge to the opposite tree; otherwise, greedily grow it one step toward the new node and check for a clean join. On connection, assemble the start-to-goal path, apply two-stage LOS+shortcut smoothing, and return.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def attach(self, parent):\n        if self.parent is parent:\n            return\n        if self.parent is not None:\n            i = 0\n            while i < len(self.parent.children):\n                if self.parent.children[i] is self:\n                    self.parent.children.pop(i)\n                    break\n                i += 1\n        self.parent = parent\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=5.0,\n        goal_bias=0.08,\n        neighbor_cap=10,\n        rewire_cap=4,\n        shortcut_attempts=48\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.neighbor_cap = int(max(1, neighbor_cap))\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self._rng = 123456789\n\n    def plan(self, map):\n        # Setup\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self._build_obstacle_grid()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight-line success\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.children.append(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Trees and spatial hashes\n        self.cell = max(1.0, 1.25 * self.step)\n        self.dupe_eps = max(1e-3, 0.05 * self.step)\n\n        rootA = Node(self.start, None, 0.0)\n        rootB = Node(self.goal, None, 0.0)\n        nodes.extend([rootA, rootB])\n\n        treeA = [rootA]\n        treeB = [rootB]\n        gridA, gridB = {}, {}\n        seenA, seenB = set(), set()\n        self._grid_insert(gridA, rootA)\n        self._grid_insert(gridB, rootB)\n        seenA.add(self._dupe_key(rootA.position))\n        seenB.add(self._dupe_key(rootB.position))\n\n        # Informed sampling state\n        have_path = False\n        best_len = 1e100\n        direct_dist = self._dist(self.start, self.goal)\n\n        # Main loop\n        for it in range(self.max_iter):\n            # Alternate growth from the smaller tree\n            useA = (len(treeA) <= len(treeB))\n            active_tree = treeA if useA else treeB\n            passive_tree = treeB if useA else treeA\n            active_grid = gridA if useA else gridB\n            passive_grid = gridB if useA else gridA\n            seen_active = seenA if useA else seenB\n            seen_passive = seenB if useA else seenA\n            attractor = self.goal if useA else self.start\n\n            # Sample\n            s = self._sample(attractor, have_path, best_len, direct_dist)\n            if s is None:\n                continue\n\n            qnear = self._nearest(active_grid, s)\n            if qnear is None:\n                continue\n\n            qpos = self._steer(qnear.position, s, self.step)\n            if not self._in_bounds(qpos):\n                continue\n\n            # Both checks required before adding any node/edge\n            if self._point_blocked(qpos):\n                continue\n\n            # Choose parent among few nearest within dynamic radius\n            parent, new_cost = self._choose_parent(active_grid, qpos, active_tree)\n            if parent is None:\n                continue\n            if not self._edge_free(parent.position, qpos):\n                continue\n\n            # Deduplicate spatially\n            pk = self._dupe_key(qpos)\n            if pk in seen_active:\n                continue\n\n            # Add node\n            qnew = Node(qpos, parent, new_cost)\n            parent.children.append(qnew)\n            active_tree.append(qnew)\n            nodes.append(qnew)\n            edges.append((parent, qnew))\n            self._grid_insert(active_grid, qnew)\n            seen_active.add(pk)\n\n            # Light local rewiring\n            if self.rewire_cap > 0:\n                self._rewire_neighbors(active_grid, qnew, edges)\n\n            # Try to directly bridge\n            meet = self._nearest(passive_grid, qnew.position)\n            bridged = False\n            meet_node = None\n            if meet is not None and self._edge_free(meet.position, qnew.position):\n                bridged = True\n                meet_node = meet\n            else:\n                # Greedy one-step connect toward qnew\n                if meet is not None:\n                    nxt = self._steer(meet.position, qnew.position, self.step)\n                    if self._in_bounds(nxt) and (not self._point_blocked(nxt)) and self._edge_free(meet.position, nxt):\n                        k = self._dupe_key(nxt)\n                        if k not in seen_passive:\n                            nc = Node(nxt, meet, meet.cost + self._dist(meet.position, nxt))\n                            meet.children.append(nc)\n                            passive_tree.append(nc)\n                            nodes.append(nc)\n                            edges.append((meet, nc))\n                            self._grid_insert(passive_grid, nc)\n                            seen_passive.add(k)\n                            meet = nc\n                            if self._edge_free(meet.position, qnew.position):\n                                bridged = True\n                                meet_node = meet\n\n            if bridged and meet_node is not None:\n                # Assemble path\n                path = self._assemble_path(qnew, meet_node, useA)\n                # Smooth\n                path = self._postprocess(path)\n                L = self._path_len(path)\n                have_path = True\n                best_len = L if L < best_len else best_len\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        self._rng = (s ^ 0x9E3779B9) & 0xffffffff\n        if self._rng == 0:\n            self._rng = 123456789\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            q = [self._clamp(b[i], 0.0, self.bounds[i]) for i in range(self.dims)]\n            return tuple(q)\n        d = d2 ** 0.5\n        r = step / d\n        q = [self._clamp(a[i] + (b[i] - a[i]) * r, 0.0, self.bounds[i]) for i in range(self.dims)]\n        return tuple(q)\n\n    # Obstacles and collision\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, 2.0 * self.step)\n        self._ogrid = {}\n        if self.is3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                cx = cx0\n                while cx <= cx1:\n                    cy = cy0\n                    while cy <= cy1:\n                        cz = cz0\n                        while cz <= cz1:\n                            k = (cx, cy, cz)\n                            b = self._ogrid.get(k)\n                            if b is None:\n                                self._ogrid[k] = [idx]\n                            else:\n                                b.append(idx)\n                            cz += 1\n                        cy += 1\n                    cx += 1\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cx = cx0\n                while cx <= cx1:\n                    cy = cy0\n                    while cy <= cy1:\n                        k = (cx, cy)\n                        b = self._ogrid.get(k)\n                        if b is None:\n                            self._ogrid[k] = [idx]\n                        else:\n                            b.append(idx)\n                        cy += 1\n                    cx += 1\n\n    def _point_blocked(self, p):\n        if self.is3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self._ogrid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            x0, y0, z0 = p\n            i = 0\n            while i < len(bucket):\n                x, y, z, w, h, d = self.obstacles[bucket[i]]\n                if x <= x0 <= x + w and y <= y0 <= y + h and z <= z0 <= z + d:\n                    return True\n                i += 1\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self._ogrid.get((cx, cy))\n            if not bucket:\n                return False\n            x0, y0 = p\n            i = 0\n            while i < len(bucket):\n                x, y, w, h = self.obstacles[bucket[i]]\n                if x <= x0 <= x + w and y <= y0 <= y + h:\n                    return True\n                i += 1\n            return False\n\n    def _seg_aabb_hit(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(self.dims):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        if self.is3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            seen = set()\n            cx = cx0\n            while cx <= cx1:\n                cy = cy0\n                while cy <= cy1:\n                    cz = cz0\n                    while cz <= cz1:\n                        lst = self._ogrid.get((cx, cy, cz))\n                        if lst:\n                            j = 0\n                            while j < len(lst):\n                                seen.add(lst[j])\n                                j += 1\n                        cz += 1\n                    cy += 1\n                cx += 1\n            if not seen:\n                return True\n            for idx in seen:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_hit(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return False\n            return True\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            seen = set()\n            cx = cx0\n            while cx <= cx1:\n                cy = cy0\n                while cy <= cy1:\n                    lst = self._ogrid.get((cx, cy))\n                    if lst:\n                        j = 0\n                        while j < len(lst):\n                            seen.add(lst[j])\n                            j += 1\n                    cy += 1\n                cx += 1\n            if not seen:\n                return True\n            for idx in seen:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_hit(a, b, (x, y), (x + w, y + h)):\n                    return False\n            return True\n\n    # Spatial hashing for trees\n    def _cell_of(self, pos):\n        if self.is3d:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_insert(self, grid, node):\n        k = self._cell_of(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.is3d:\n            dx = -r\n            while dx <= r:\n                dy = -r\n                while dy <= r:\n                    dz = -r\n                    while dz <= r:\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n                        dz += 1\n                    dy += 1\n                dx += 1\n        else:\n            dx = -r\n            while dx <= r:\n                dy = -r\n                while dy <= r:\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n                    dy += 1\n                dx += 1\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_of(pos)\n        best = None\n        bestd2 = 1e100\n        r = 0\n        # Try a few expanding rings\n        while r <= 3:\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                i = 0\n                while i < len(cand):\n                    n = cand[i]\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd2:\n                        bestd2 = d2\n                        best = n\n                    i += 1\n                if best is not None:\n                    return best\n            r += 1\n        # Fallback: scan all buckets shallowly\n        for lst in grid.values():\n            i = 0\n            while i < len(lst):\n                n = lst[i]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n                i += 1\n        return best\n\n    def _dupe_key(self, pos):\n        if self.is3d:\n            return (int(pos[0] / self.dupe_eps), int(pos[1] / self.dupe_eps), int(pos[2] / self.dupe_eps))\n        return (int(pos[0] / self.dupe_eps), int(pos[1] / self.dupe_eps))\n\n    # Parent selection and rewiring\n    def _dynamic_radius(self, ncount):\n        # RRT* inspired radius: base on density, clamped to a few steps\n        from_density = (max(1.0, (self._logf(ncount + 1) / (ncount + 1.0))) ** (1.0 / max(2.0, float(self.dims))))\n        r = max(1.2 * self.step, 3.0 * self.step * from_density)\n        hi = 6.0 * self.step\n        if r > hi:\n            r = hi\n        return r\n\n    def _k_near_within(self, grid, pos, radius, kcap):\n        key = self._cell_of(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        keep = []\n        keepd = []\n        cand = self._ring_collect(grid, key, rc)\n        i = 0\n        while i < len(cand):\n            n = cand[i]\n            d2 = self._dist2(n.position, pos)\n            if d2 <= r2:\n                if len(keep) < kcap:\n                    keep.append(n)\n                    keepd.append(d2)\n                else:\n                    # Replace worst\n                    wj = 0\n                    wv = keepd[0]\n                    j = 1\n                    while j < len(keepd):\n                        if keepd[j] > wv:\n                            wv = keepd[j]\n                            wj = j\n                        j += 1\n                    if d2 < keepd[wj]:\n                        keepd[wj] = d2\n                        keep[wj] = n\n            i += 1\n        # Light ordering\n        m = len(keep)\n        j = 1\n        while j < m:\n            k = j\n            while k > 0 and keepd[k] < keepd[k - 1]:\n                keepd[k], keepd[k - 1] = keepd[k - 1], keepd[k]\n                keep[k], keep[k - 1] = keep[k - 1], keep[k]\n                k -= 1\n            j += 1\n        return keep\n\n    def _choose_parent(self, grid, new_pos, tree):\n        r = self._dynamic_radius(len(tree))\n        cand = self._k_near_within(grid, new_pos, r, self.neighbor_cap)\n        if not cand:\n            # fallback to nearest\n            n = self._nearest(grid, new_pos)\n            cand = [n] if n is not None else []\n        best_parent = None\n        best_cost = 1e100\n        i = 0\n        while i < len(cand):\n            n = cand[i]\n            if n is not None and self._edge_free(n.position, new_pos):\n                c = n.cost + self._dist(n.position, new_pos)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best_parent = n\n            i += 1\n        if best_parent is None:\n            return None, None\n        return best_parent, best_cost\n\n    def _rewire_neighbors(self, grid, new_node, edges):\n        r = self._dynamic_radius(1) + 2.0 * self.step\n        neigh = self._k_near_within(grid, new_node.position, r, max(2, self.rewire_cap * 2))\n        changed = 0\n        i = 0\n        while i < len(neigh) and changed < self.rewire_cap:\n            n = neigh[i]\n            if n is new_node or n.parent is None:\n                i += 1\n                continue\n            via_cost = new_node.cost + self._dist(new_node.position, n.position)\n            if via_cost + 1e-9 < n.cost and self._edge_free(new_node.position, n.position):\n                # Update edges list: remove old edge\n                oldp = n.parent\n                ei = 0\n                while ei < len(edges):\n                    if edges[ei][0] is oldp and edges[ei][1] is n:\n                        edges.pop(ei)\n                        break\n                    ei += 1\n                n.attach(new_node)\n                n.cost = via_cost\n                edges.append((new_node, n))\n                # Propagate to descendants (bounded)\n                q = [n]\n                budget = 128\n                while q and budget > 0:\n                    cur = q.pop()\n                    cj = 0\n                    while cj < len(cur.children) and budget > 0:\n                        ch = cur.children[cj]\n                        ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                        q.append(ch)\n                        cj += 1\n                        budget -= 1\n                changed += 1\n            i += 1\n\n    # Sampling\n    def _sample(self, attractor, have_path, c_best, c_min):\n        tries = 24\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            if r < self.goal_bias:\n                p = attractor\n            else:\n                if self.is3d:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            if have_path:\n                if not self._informed_accept(p, c_best, c_min):\n                    continue\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        # fallback: attractor if valid\n        if self._in_bounds(attractor) and (not self._point_blocked(attractor)):\n            return attractor\n        return None\n\n    def _informed_accept(self, p, c_best, c_min):\n        # Accept if within prolate ellipsoid with foci at start and goal with major axis c_best\n        if c_best >= 1e99:\n            return True\n        if c_best <= c_min + 1e-9:\n            return True\n        dsum = self._dist(self.start, p) + self._dist(p, self.goal)\n        return dsum <= c_best + 1e-9\n\n    # Path assembly and postprocess\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _assemble_path(self, a_side_node, b_side_node, active_was_A):\n        pa = self._path_to_root(a_side_node)\n        pb = self._path_to_root(b_side_node)\n        if active_was_A:\n            # active tree grew from start\n            pb.reverse()\n            # remove duplicate join if any\n            if pa[-1] == pb[0]:\n                pb = pb[1:]\n            return pa + pb\n        else:\n            # active tree grew from goal\n            pa.reverse()\n            if pb[-1] == pa[0]:\n                pa = pa[1:]\n            return pb + pa\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        i = 1\n        while i < len(path):\n            L += self._dist(path[i - 1], path[i])\n            i += 1\n        return L\n\n    def _los_pass(self, path):\n        if len(path) < 3:\n            return path[:]\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        while i < len(path) - 1:\n            if self._edge_free(anchor, path[i + 1]):\n                i += 1\n            else:\n                out.append(path[i])\n                anchor = path[i]\n                i += 1\n        out.append(path[-1])\n        return out\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        # Deterministic forward collapse\n        i = 0\n        while i < len(pts) - 2:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n        # Random shortcuts\n        attempts = 0\n        nmax = self.shortcut_attempts\n        while attempts < nmax and len(pts) > 2:\n            a = int(self._rand_range(0, len(pts) - 2))\n            b = int(self._rand_range(a + 2, len(pts)))\n            if b <= a + 1 or b > len(pts) - 1:\n                attempts += 1\n                continue\n            if self._edge_free(pts[a], pts[b]):\n                pts = pts[:a + 1] + pts[b:]\n            attempts += 1\n        return pts\n\n    def _postprocess(self, path):\n        p = self._los_pass(path)\n        p = self._shortcut(p)\n        p = self._los_pass(p)\n        return p\n\n    # Math helpers\n    def _logf(self, x):\n        # Natural log via simple series approximation around x in reasonable range; fallback to binary log ratio\n        # For planning, roughness is fine; keep deterministic and import-free\n        # ln(x) ~ 2 * atanh((x-1)/(x+1)) series truncated\n        if x <= 0.0:\n            return -1e9\n        y = (x - 1.0) / (x + 1.0)\n        y2 = y * y\n        s = y\n        num = y\n        k = 1\n        # few terms for stability\n        while k < 7:\n            num *= y2\n            s += num / (2 * k + 1)\n            k += 1\n        return 2.0 * s",
            "objective": -39.06424,
            "time_improvement": 76.0,
            "length_improvement": 18.0,
            "smoothness_improvement": 1059.0,
            "node_improvement": 89.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007495331764221192,
                    "num_nodes_avg": 44.0,
                    "path_length_avg": 151.6380154090941,
                    "smoothness_avg": 0.0381690487238861,
                    "success_improvement": 0.0,
                    "time_improvement": 69.71850793020877,
                    "node_improvement": 88.9196675900277,
                    "length_improvement": 16.88480089615542,
                    "smoothness_improvement": 497.4284979447484,
                    "objective_score": 33.53357540647963
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03869636058807373,
                    "num_nodes_avg": 171.0,
                    "path_length_avg": 230.88339478788347,
                    "smoothness_avg": 0.06923517006476078,
                    "success_improvement": 0.0,
                    "time_improvement": 76.46591839066528,
                    "node_improvement": 88.5103809715783,
                    "length_improvement": 22.924477209761378,
                    "smoothness_improvement": 1681.4707938436097,
                    "objective_score": 45.10181581227446
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009676718711853027,
                    "num_nodes_avg": 84.0,
                    "path_length_avg": 127.32231777309157,
                    "smoothness_avg": 0.08628620718970545,
                    "success_improvement": 0.0,
                    "time_improvement": 81.02137457337125,
                    "node_improvement": 89.31977113795296,
                    "length_improvement": 15.438578972364697,
                    "smoothness_improvement": 997.5541864677477,
                    "objective_score": 38.55733068776893
                }
            ],
            "success_rate": 1.0
        },
        "objective": 32.0,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Excessive directional bias toward the goal/corridor led to many samples in blocked corridors and repeated failed edge checks.\n   - Multi-step greedy connection spawned numerous intermediate nodes per attempt, bloating trees and inflating collision/proximity queries.\n   - Fixed, relatively wide neighbor radii with larger candidate sets increased parent selection and collision-testing cost per expansion.\n   - Rewiring propagated costs deeply through subtrees, adding substantial per-iteration overhead.\n   - Nearest-neighbor fallbacks and dense post-smoothing passes incurred additional time without proportional gains."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Reduced sampling bias and removal of corridor-focused sampling.\n   - One-step greedy bridging instead of multi-step connection.\n   - Dynamic, tighter neighbor radius with a small candidate cap for parent choice.\n   - Bounded, lightweight rewiring with limited descendant updates.\n   - Coarser spatial hashing and simplified nearest-neighbor fallback.\n   - Smaller post-smoothing budget.\n2. Expected mechanism of impact:\n   - Fewer doomed samples in cluttered lines-of-sight lowers rejection and collision-check rates.\n   - Limiting connect growth prevents tree bloat, reducing future nearest/collision costs and accelerating joins.\n   - Smaller neighborhoods cut edge-free tests per expand while preserving feasible parenting, speeding iterations.\n   - Capped cost propagation avoids O(subtree) updates, stabilizing per-iteration complexity.\n   - Coarser grids reduce bucket lookups; a straightforward fallback avoids repeated random probing.\n   - Less aggressive smoothing reduces post-processing time while retaining most length gains."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "SAGE-Connect Lite: A simplified, robust bi-directional RRT*-Connect with adaptive neighbor radius, grid-accelerated nearest/neighbor queries, lightweight cost-based rewiring, and opportunistic greedy cross-tree connection. It maintains strict node/edge collision checks, modest duplicate suppression, and finishes with visibility pruning and bounded shortcutting for smooth, short paths.",
                "planning_mechanism": "Alternate growth from start/goal trees. Each iteration: goal/informed/uniform sample, steer one step, pick a parent among nearby neighbors minimizing cost with collision-free edge, insert after validating point and edge, then locally rewire a few neighbors. Attempt a fast cross-tree link via line-of-sight or a short greedy connect. On success, assemble and refine the path and return; else continue until budget or incumbent available.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        return pts[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step=6.0,\n        goal_bias=0.2,\n        informed_bias=0.45,\n        node_grid_factor=1.5,\n        dup_factor=0.35,\n        rewire_cap=24,\n        connect_cap=64,\n        smooth_iters=80\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.node_grid_factor = float(node_grid_factor)\n        self.dup_factor = float(dup_factor)\n        self.rewire_cap = int(rewire_cap)\n        self.connect_cap = int(connect_cap)\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if getattr(map, \"obstacles\", None) else []\n\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self._build_obstacle_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight path\n        if self._edge_free(self.start, self.goal):\n            a = Node(self.start, None, 0.0)\n            b = Node(self.goal, a, self._dist(self.start, self.goal))\n            a.add_child(b)\n            nodes.extend([a, b])\n            edges.append((a, b))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Node grid params\n        self.node_cell = max(1.0, self.step * self.node_grid_factor)\n        self.dup_radius = max(0.4, self.step * self.dup_factor)\n\n        # Trees and grids\n        ra = Node(self.start, None, 0.0)\n        rb = Node(self.goal, None, 0.0)\n        Ta, Tb = [ra], [rb]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, ra)\n        self._grid_add(Gb, rb)\n        nodes.extend([ra, rb])\n\n        best_len = float('inf')\n        incumbent = None\n\n        for it in range(self.max_iter):\n            grow_a = (it & 1) == 0\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n\n            target = self._sample(attractor, best_len)\n            if target is None:\n                continue\n\n            base = self._nearest(G, target, T)\n            if base is None:\n                continue\n\n            newp = self._steer(base.position, target, self.step)\n            if not self._in_bounds(newp):\n                continue\n            if self._point_blocked(newp):\n                continue\n\n            # Choose parent among nearby neighbors (cost-minimizing with collision check)\n            radius = self._neighbor_radius(len(T))\n            parent = self._choose_parent(G, newp, base, radius)\n            if parent is None:\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            # Duplicate suppression near existing nodes\n            if self._too_close(G, newp, self.dup_radius):\n                # try direct cross-tree LOS even if not inserting this node\n                near_opp = self._nearest(Gopp, newp, Topp)\n                if near_opp is not None and self._edge_free(newp, near_opp.position):\n                    path = self._assemble_virtual(newp, parent, near_opp, grow_a)\n                    path = self._refine(path)\n                    return PlannerResult(True, path, Ta + Tb, edges)\n                continue\n\n            # Insert node (both checks done above)\n            new_cost = parent.cost + self._dist(parent.position, newp)\n            q = Node(newp, parent, new_cost)\n            parent.add_child(q)\n            T.append(q)\n            nodes.append(q)\n            edges.append((parent, q))\n            self._grid_add(G, q)\n\n            # Local rewiring (bounded)\n            self._rewire_local(G, q, radius, edges)\n\n            # Cross-tree direct visibility\n            opp_near = self._nearest(Gopp, q.position, Topp)\n            if opp_near is not None and self._edge_free(q.position, opp_near.position):\n                raw = self._assemble(q, opp_near, grow_a)\n                L = self._path_len(raw)\n                if L < best_len:\n                    best_len = L\n                    incumbent = raw\n                path = self._refine(raw)\n                return PlannerResult(True, path, Ta + Tb, edges)\n\n            # Greedy connect from opposite tree toward q\n            meet = self._connect_towards(Topp, Gopp, q.position, nodes, edges)\n            if meet is not None and self._edge_free(q.position, meet.position):\n                raw = self._assemble(q, meet, grow_a)\n                L = self._path_len(raw)\n                if L < best_len:\n                    best_len = L\n                    incumbent = raw\n                path = self._refine(raw)\n                return PlannerResult(True, path, Ta + Tb, edges)\n\n            # Update incumbent if a near-visible other exists (no extra edges)\n            if opp_near is not None and self._edge_free(q.position, opp_near.position):\n                cand = self._assemble(q, opp_near, grow_a)\n                L = self._path_len(cand)\n                if L < best_len:\n                    best_len = L\n                    incumbent = cand\n\n        if incumbent is not None:\n            path = self._refine(incumbent)\n            return PlannerResult(True, path, Ta + Tb, edges)\n\n        return PlannerResult(False, [], Ta + Tb, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 0x9E3779B9\n        vals = self.start + self.goal\n        for v in vals:\n            x = int((v + 0.5) * 2654435761) & 0xffffffff\n            s ^= (x ^ (x >> 13) ^ ((x << 7) & 0xffffffff)) & 0xffffffff\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= ((len(self.obstacles) + 17) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Node grid\n    def _cell_key(self, p):\n        return tuple(int(p[i] // self.node_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect_ring(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos, tree):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect_ring(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n            if best is not None:\n                return best\n        # fallback sparse scan\n        if not tree:\n            return None\n        step = max(1, len(tree) // 64)\n        for i in range(0, len(tree), step):\n            n = tree[i]\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, cap):\n        out = []\n        key = self._cell_key(pos)\n        span = int(radius // self.node_cell) + 1\n        r2 = radius * radius\n        if self.dim == 3:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        res = self._neighbors_in_radius(grid, pos, radius, 1)\n        return len(res) > 0\n\n    def _neighbor_radius(self, ncount):\n        r_min = 1.25 * self.step\n        r_max = 3.0 * self.step\n        t = ncount / (ncount + 200.0)\n        return r_max * (1.0 - t) + r_min * t\n\n    # Obstacles and collision\n    def _build_obstacle_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self.dim == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if self.dim == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            lst = self.obin.get((ix, iy, iz))\n            if not lst:\n                return False\n            x, y, z = p\n            for idx in lst:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            lst = self.obin.get((ix, iy))\n            if not lst:\n                return False\n            x, y = p\n            for idx in lst:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _bucket_candidates(self, a, b):\n        if self.dim == 3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            return cand\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            return cand\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        cand = self._bucket_candidates(a, b)\n        if not cand:\n            return True\n        if self.dim == 3:\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    # Parent choice and rewiring\n    def _choose_parent(self, grid, new_pos, fallback, radius):\n        cand = self._neighbors_in_radius(grid, new_pos, radius, 96)\n        if fallback not in cand:\n            cand.append(fallback)\n        best = None\n        bestc = 1e100\n        for n in cand:\n            if not self._edge_free(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c < bestc:\n                bestc = c\n                best = n\n        return best\n\n    def _rewire_local(self, grid, pivot, radius, edges):\n        neigh = self._neighbors_in_radius(grid, pivot.position, radius, 96)\n        # Order neighbors by potential new cost via pivot\n        order = []\n        for nb in neigh:\n            if nb is pivot:\n                continue\n            tc = pivot.cost + self._dist(pivot.position, nb.position)\n            order.append((tc, nb))\n        order.sort(key=lambda x: x[0])\n        changed = 0\n        for tc, nb in order:\n            if nb is pivot or nb.parent is pivot:\n                continue\n            # Avoid cycles\n            if self._is_ancestor(nb, pivot):\n                continue\n            if not self._edge_free(pivot.position, nb.position):\n                continue\n            newc = pivot.cost + self._dist(pivot.position, nb.position)\n            if newc + 1e-9 < nb.cost:\n                self._reparent(nb, pivot, edges)\n                changed += 1\n                if changed >= self.rewire_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        old = child.parent\n        if old is new_parent:\n            return\n        if old is not None:\n            old.remove_child(child)\n            self._remove_edge(edges, old, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        # propagate to subtree\n        stack = [child]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                stack.append(ch)\n\n    def _remove_edge(self, edges, parent, child):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is parent and e[1] is child:\n                edges.pop(i)\n                return\n\n    # Connecting\n    def _connect_towards(self, tree, grid, target_point, nodes, edges):\n        base = self._nearest(grid, target_point, tree)\n        if base is None:\n            return None\n        last = None\n        cap = self.connect_cap\n        while cap > 0:\n            cap -= 1\n            nxtp = self._steer(base.position, target_point, self.step)\n            if nxtp == base.position:\n                break\n            if not self._in_bounds(nxtp):\n                break\n            if self._point_blocked(nxtp):\n                break\n            if not self._edge_free(base.position, nxtp):\n                break\n            if self._too_close(grid, nxtp, self.dup_radius):\n                break\n            nn = Node(nxtp, base, base.cost + self._dist(base.position, nxtp))\n            base.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((base, nn))\n            self._grid_add(grid, nn)\n            last = nn\n            base = nn\n            if nxtp == target_point:\n                return nn\n            if self._dist(nxtp, target_point) <= self.step and self._edge_free(nxtp, target_point):\n                # try snapping to target point as a final node in the opposite tree\n                if (self._in_bounds(target_point)) and (not self._point_blocked(target_point)) and (not self._too_close(grid, target_point, self.dup_radius)):\n                    snap = Node(target_point, nn, nn.cost + self._dist(nxtp, target_point))\n                    nn.add_child(snap)\n                    tree.append(snap)\n                    nodes.append(snap)\n                    edges.append((nn, snap))\n                    self._grid_add(grid, snap)\n                    return snap\n                break\n        return last\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._sample_informed(best_len * 1.02)\n            if p is not None:\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            if (self._in_bounds(p)) and (not self._point_blocked(p)):\n                return p\n        # uniform\n        if self.dim == 3:\n            p = (self._rand_range(0.0, self.bounds[0]),\n                 self._rand_range(0.0, self.bounds[1]),\n                 self._rand_range(0.0, self.bounds[2]))\n        else:\n            p = (self._rand_range(0.0, self.bounds[0]),\n                 self._rand_range(0.0, self.bounds[1]))\n        if (self._in_bounds(p)) and (not self._point_blocked(p)):\n            return p\n        return None\n\n    def _sample_informed(self, max_sum):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        tries = 24\n        while tries > 0:\n            tries -= 1\n            if self.dim == 3:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half),\n                     self._rand_range(c[2] - half, c[2] + half))\n            else:\n                p = (self._rand_range(c[0] - half, c[0] + half),\n                     self._rand_range(c[1] - half, c[1] + half))\n            if (not self._in_bounds(p)) or self._point_blocked(p):\n                continue\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= max_sum + 1e-9:\n                return p\n        return None\n\n    # Path assembly and refinement\n    def _assemble(self, u, v, u_from_start):\n        pu = u.path_to_root()\n        pv = v.path_to_root()\n        if u_from_start:\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _assemble_virtual(self, meet_pos, parent_u, v, u_from_start):\n        # Assemble path when meet_pos is not a node in the opposite tree\n        if u_from_start:\n            pu = parent_u.path_to_root() + [meet_pos]\n            pv = v.path_to_root()\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            pv = v.path_to_root() + [meet_pos]\n            pu = parent_u.path_to_root()\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _vis_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcuts(self, pts, attempts):\n        if len(pts) < 3 or attempts <= 0:\n            return pts[:]\n        cur = list(pts)\n        best = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, len(cur) - 2))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    cur = cand\n                    best = L\n            tries += 1\n        return cur\n\n    def _refine(self, path):\n        if len(path) < 2:\n            return path[:]\n        p0 = self._vis_prune(path)\n        p1 = self._shortcuts(p0, self.smooth_iters)\n        return p1",
                "objective": -36.44988,
                "time_improvement": 58.0,
                "length_improvement": 16.0,
                "smoothness_improvement": 1918.0,
                "node_improvement": 84.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.01591479778289795,
                        "num_nodes_avg": 87.0,
                        "path_length_avg": 162.15752426088426,
                        "smoothness_avg": 0.055772758302103265,
                        "success_improvement": 0.0,
                        "time_improvement": 35.70347010447109,
                        "node_improvement": 78.09116091664569,
                        "length_improvement": 11.118891402204344,
                        "smoothness_improvement": 772.9647799110415,
                        "objective_score": 21.24719977221914
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.05859699249267578,
                        "num_nodes_avg": 219.0,
                        "path_length_avg": 229.27287283708333,
                        "smoothness_avg": 0.11927879881055772,
                        "success_improvement": 0.0,
                        "time_improvement": 64.36289143405325,
                        "node_improvement": 85.28522475307398,
                        "length_improvement": 23.46211579324253,
                        "smoothness_improvement": 2969.129406441802,
                        "objective_score": 48.231783938370505
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.012634086608886718,
                        "num_nodes_avg": 84.0,
                        "path_length_avg": 132.37835239759787,
                        "smoothness_avg": 0.16597492953239534,
                        "success_improvement": 0.0,
                        "time_improvement": 75.22118762593118,
                        "node_improvement": 89.31977113795296,
                        "length_improvement": 12.080601517264231,
                        "smoothness_improvement": 2011.188852657133,
                        "objective_score": 39.87066146142356
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "SPARK-BiRRT*: A compact, robust bidirectional RRT* variant with simple grid-accelerated proximity, fixed-radius cost-aware parent selection, bounded local rewiring, and an RRT-Connect style greedy meet. It enforces strict node/edge collision checks, uses minimal duplicate suppression, and finishes with visibility pruning and short-cutting for smooth, short paths.",
            "planning_mechanism": "Alternate growth from start and goal trees. Each step: sample (goal-biased), steer one step, select the best-cost parent among nearby neighbors with collision-free edge, insert, and locally rewire a few neighbors if it reduces cost. Attempt a greedy extend from the opposite tree toward the new node; if the trees meet with a collision-free link, assemble and refine the path and return. Early straight-line and bounds/obstacle checks provide fast exits; a simple grid boosts nearest/neighbor queries.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        return pts[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step=6.0,\n        goal_bias=0.15,\n        neighbor_radius_factor=2.0,\n        rewire_cap=16,\n        dup_ratio=0.2,\n        smooth_attempts=60\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.goal_bias = float(goal_bias)\n        self.neighbor_radius_factor = float(neighbor_radius_factor)\n        self.rewire_cap = int(rewire_cap)\n        self.dup_ratio = float(dup_ratio)\n        self.smooth_attempts = int(max(0, smooth_attempts))\n        self._rng = 1234567\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(getattr(map, \"obstacles\", []))\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self._build_obstacle_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            a = Node(self.start, None, 0.0)\n            b = Node(self.goal, a, self._dist(self.start, self.goal))\n            a.add_child(b)\n            nodes.extend([a, b])\n            edges.append((a, b))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        self.node_cell = max(1.0, self.step)\n        self.dup_radius = max(0.2, self.step * self.dup_ratio)\n\n        ra = Node(self.start, None, 0.0)\n        rb = Node(self.goal, None, 0.0)\n        Ta, Tb = [ra], [rb]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, ra)\n        self._grid_add(Gb, rb)\n        nodes.extend([ra, rb])\n\n        for it in range(self.max_iter):\n            grow_a = (it & 1) == 0\n            T = Ta if grow_a else Tb\n            G = Ga if grow_a else Gb\n            Topp = Tb if grow_a else Ta\n            Gopp = Gb if grow_a else Ga\n            attractor = self.goal if grow_a else self.start\n\n            s = self._sample(attractor)\n            if s is None:\n                continue\n\n            base = self._nearest(G, s, T)\n            if base is None:\n                continue\n\n            newp = self._steer(base.position, s, self.step)\n            if not self._in_bounds(newp):\n                continue\n            if self._point_blocked(newp):\n                continue\n\n            radius = self.neighbor_radius_factor * self.step\n            parent = self._choose_parent(G, newp, base, radius)\n            if parent is None:\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            if self._too_close(G, newp, self.dup_radius):\n                # attempt direct cross-tree visibility even if skipping insert\n                opp = self._nearest(Gopp, newp, Topp)\n                if opp is not None and self._edge_free(newp, opp.position):\n                    raw = self._assemble_virtual(newp, parent, opp, grow_a)\n                    path = self._refine(raw)\n                    return PlannerResult(True, path, Ta + Tb, edges)\n                continue\n\n            new_cost = parent.cost + self._dist(parent.position, newp)\n            q = Node(newp, parent, new_cost)\n            parent.add_child(q)\n            T.append(q)\n            nodes.append(q)\n            edges.append((parent, q))\n            self._grid_add(G, q)\n\n            self._rewire_local(G, q, radius, edges)\n\n            meet = self._connect_extend(Topp, Gopp, q.position, nodes, edges)\n            if meet is not None and self._edge_free(q.position, meet.position):\n                raw = self._assemble(q, meet, grow_a)\n                path = self._refine(raw)\n                return PlannerResult(True, path, Ta + Tb, edges)\n\n        return PlannerResult(False, [], Ta + Tb, edges)\n\n    # RNG\n    def _seed_rng(self):\n        s = 2166136261\n        for v in self.start + self.goal:\n            x = int((v + 0.5) * 2654435761) & 0xffffffff\n            s ^= x\n            s = (s * 16777619) & 0xffffffff\n        s ^= (len(self.obstacles) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 1234567\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Grid for nodes\n    def _cell_key(self, p):\n        return tuple(int(p[i] // self.node_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_neighbors_cells(self, key, span):\n        if self.dim == 3:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        yield (key[0] + dx, key[1] + dy, key[2] + dz)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    yield (key[0] + dx, key[1] + dy)\n\n    def _nearest(self, grid, pos, tree):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for span in range(0, 2):\n            found = False\n            for ck in self._grid_neighbors_cells(key, span):\n                lst = grid.get(ck)\n                if not lst:\n                    continue\n                for n in lst:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                        found = True\n            if found:\n                return best\n        # fallback sparse scan\n        if not tree:\n            return None\n        step = max(1, len(tree) // 64)\n        for i in range(0, len(tree), step):\n            n = tree[i]\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius, cap):\n        out = []\n        key = self._cell_key(pos)\n        span = int(radius // self.node_cell) + 1\n        r2 = radius * radius\n        for ck in self._grid_neighbors_cells(key, span):\n            lst = grid.get(ck)\n            if not lst:\n                continue\n            for n in lst:\n                if self._dist2(n.position, pos) <= r2:\n                    out.append(n)\n                    if len(out) >= cap:\n                        return out\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        res = self._neighbors_in_radius(grid, pos, radius, 1)\n        return len(res) > 0\n\n    # Obstacles\n    def _build_obstacle_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.5)\n        self.obin = {}\n        if self.dim == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if not self.obstacles:\n            return False\n        if self.dim == 3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            lst = self.obin.get((ix, iy, iz))\n            if not lst:\n                return False\n            x, y, z = p\n            for idx in lst:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            lst = self.obin.get((ix, iy))\n            if not lst:\n                return False\n            x, y = p\n            for idx in lst:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _bucket_candidates(self, a, b):\n        if not self.obstacles:\n            return []\n        if self.dim == 3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.obin.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            return list(cand)\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.obin.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            return list(cand)\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    def _edge_free(self, a, b):\n        cand = self._bucket_candidates(a, b)\n        if not cand:\n            return True\n        if self.dim == 3:\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return False\n            return True\n        else:\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return False\n            return True\n\n    # Parent selection and rewiring\n    def _choose_parent(self, grid, new_pos, fallback, radius):\n        cand = self._neighbors_in_radius(grid, new_pos, radius, 64)\n        if fallback not in cand:\n            cand.append(fallback)\n        best = None\n        bestc = 1e100\n        for n in cand:\n            if not self._edge_free(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c < bestc:\n                bestc = c\n                best = n\n        return best\n\n    def _rewire_local(self, grid, pivot, radius, edges):\n        neigh = self._neighbors_in_radius(grid, pivot.position, radius, 64)\n        options = []\n        for nb in neigh:\n            if nb is pivot:\n                continue\n            newc = pivot.cost + self._dist(pivot.position, nb.position)\n            options.append((newc, nb))\n        options.sort(key=lambda x: x[0])\n        changed = 0\n        for newc, nb in options:\n            if changed >= self.rewire_cap:\n                break\n            if nb is pivot or nb.parent is pivot:\n                continue\n            if self._is_ancestor(nb, pivot):\n                continue\n            if newc + 1e-9 < nb.cost and self._edge_free(pivot.position, nb.position):\n                self._reparent(nb, pivot, edges)\n                changed += 1\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        old = child.parent\n        if old is new_parent:\n            return\n        if old is not None:\n            old.remove_child(child)\n            self._remove_edge(edges, old, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        stack = [child]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                stack.append(ch)\n\n    def _remove_edge(self, edges, parent, child):\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is parent and e[1] is child:\n                edges.pop(i)\n                return\n\n    # Connect\n    def _connect_extend(self, tree, grid, target_point, nodes, edges):\n        base = self._nearest(grid, target_point, tree)\n        if base is None:\n            return None\n        last = base\n        for _ in range(64):\n            nxt = self._steer(last.position, target_point, self.step)\n            if nxt == last.position:\n                break\n            if not self._in_bounds(nxt):\n                break\n            if self._point_blocked(nxt):\n                break\n            if not self._edge_free(last.position, nxt):\n                break\n            if self._too_close(grid, nxt, self.dup_radius):\n                break\n            nn = Node(nxt, last, last.cost + self._dist(last.position, nxt))\n            last.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((last, nn))\n            self._grid_add(grid, nn)\n            last = nn\n            if nxt == target_point:\n                return nn\n        return last if last is not base else None\n\n    # Sampling\n    def _sample(self, attractor):\n        r = self._rand()\n        if r < self.goal_bias:\n            p = attractor\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        if self.dim == 3:\n            p = (self._rand_range(0.0, self.bounds[0]),\n                 self._rand_range(0.0, self.bounds[1]),\n                 self._rand_range(0.0, self.bounds[2]))\n        else:\n            p = (self._rand_range(0.0, self.bounds[0]),\n                 self._rand_range(0.0, self.bounds[1]))\n        if self._in_bounds(p) and (not self._point_blocked(p)):\n            return p\n        return None\n\n    # Path assembly and refinement\n    def _assemble(self, u, v, u_from_start):\n        pu = u.path_to_root()\n        pv = v.path_to_root()\n        if u_from_start:\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _assemble_virtual(self, meet_pos, parent_u, v, u_from_start):\n        if u_from_start:\n            pu = parent_u.path_to_root() + [meet_pos]\n            pv = v.path_to_root()\n            if pu and pv and pu[0] == pv[-1]:\n                pv = pv[:-1]\n            return pu + pv[::-1]\n        else:\n            pv = v.path_to_root() + [meet_pos]\n            pu = parent_u.path_to_root()\n            if pv and pu and pv[0] == pu[-1]:\n                pu = pu[:-1]\n            return pv + pu[::-1]\n\n    def _path_len(self, pts):\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _vis_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcuts(self, pts, attempts):\n        if len(pts) < 3 or attempts <= 0:\n            return pts[:]\n        cur = list(pts)\n        best = self._path_len(cur)\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, len(cur) - 2))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L <= best + 1e-12:\n                    cur = cand\n                    best = L\n            tries += 1\n        return cur\n\n    def _refine(self, path):\n        if len(path) < 2:\n            return path[:]\n        p0 = self._vis_prune(path)\n        p1 = self._shortcuts(p0, self.smooth_attempts)\n        return p1",
            "objective": -38.56957,
            "time_improvement": 79.0,
            "length_improvement": 14.0,
            "smoothness_improvement": 1314.0,
            "node_improvement": 89.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009466433525085449,
                    "num_nodes_avg": 64.0,
                    "path_length_avg": 165.10553855497093,
                    "smoothness_avg": 0.03536083821899584,
                    "success_improvement": 0.0,
                    "time_improvement": 61.75516431608331,
                    "node_improvement": 83.8831528582221,
                    "length_improvement": 9.503038053339562,
                    "smoothness_improvement": 453.47390541650066,
                    "objective_score": 26.495741653911235
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020602655410766602,
                    "num_nodes_avg": 139.0,
                    "path_length_avg": 237.1292833035105,
                    "smoothness_avg": 0.0881421654330121,
                    "success_improvement": 0.0,
                    "time_improvement": 87.47002130336207,
                    "node_improvement": 90.66048511724787,
                    "length_improvement": 20.839419845312214,
                    "smoothness_improvement": 2167.9614028270303,
                    "objective_score": 49.584465312331105
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0067710399627685545,
                    "num_nodes_avg": 71.0,
                    "path_length_avg": 132.9628532997944,
                    "smoothness_avg": 0.11158882198085847,
                    "success_improvement": 0.0,
                    "time_improvement": 86.72018532018375,
                    "node_improvement": 90.97266369993643,
                    "length_improvement": 11.692403848967308,
                    "smoothness_improvement": 1319.4015789664647,
                    "objective_score": 39.62850580026783
                }
            ],
            "success_rate": 1.0
        },
        "objective": 39.0,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Expensive proximity searches from wide grid-ring scans and large neighbor sets, combined with adaptive large radii that trigger many collision checks per expansion\n   - Aggressive duplicate suppression that rejects many proposed nodes, wasting iterations and slowing progress in narrow passages\n   - Rejection-heavy informed sampling and complex sampling logic that often yield no usable sample and burn iterations\n   - Broad, high-cap local rewiring with subtree cost propagation, increasing per-iteration overhead\n   - Lengthy post-processing (visibility pruning + many shortcut attempts) adding substantial collision checks\n   - Generous iteration budgets and opportunistic connect steps that can perform many edge and grid operations per attempt"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Shallower nearest lookup (limited grid-span with early exit) and smaller, fixed-radius neighbor sets with lower caps\n   - Reduced rewiring workload via lower rewire cap and tighter local neighborhood\n   - Less aggressive duplicate suppression to increase successful insertions and reduce skipped expansions\n   - Simpler sampling (no rejection-based informed stage) and fewer smoothing attempts\n   - Lower maximum iteration budget\n   - Finer node-grid resolution to keep bucket lists small during proximity queries\n2. Expected mechanism of impact:\n   - Cuts per-iteration computation in nearest/neighbor queries and collision checking, lowering constant factors\n   - Raises node-acceptance rate, reducing wasted iterations and enabling earlier tree connection\n   - Bounds expensive rewiring and post-processing, shrinking tail latency\n   - Limits worst-case runtime through a smaller iteration cap\n   - Improves cache/locality in grid buckets, accelerating lookups and updates"
        }
    },
    {
        "parents": [
            {
                "operator": "e2",
                "algorithm_description": "ZIDC*: Informed Dual-Connect with Local Rewire \u2014 a bi-directional RRT*-Connect variant that grows greedily toward low-discrepancy samples, selects parents by local cost, performs radius-limited rewiring, and switches to informed (start\u2013goal ellipse) sampling after the first solution. A compact spatial hash accelerates near/nearest queries; obstacle-binned collision checks reduce segment tests; spacing is permissive to densify corridors; and a two-stage LOS+shortcut smoother improves curvature with minimal overhead.",
                "planning_mechanism": "Alternate expansions of start/goal trees. Each iteration: draw a goal-biased Halton sample; if a best cost exists, reject samples outside the start\u2013goal ellipse. From the nearest node, extend multiple steps toward the sample; at the first step, choose the best-cost visible parent among nearby nodes, insert, then locally rewire neighbors that benefit. After each insertion, greedily connect the opposite tree toward the new node; if it reaches (or can insert an exact meeting), stitch the trees and finalize with visibility pruning and shortcut smoothing.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=3000,\n        step_size=8.0,\n        goal_bias=0.1,\n        grid_cell_factor=1.0,\n        min_separation_mult=0.25,\n        connect_greedy_steps=64,\n        rewire_radius_mult=3.0,\n        smooth_shortcuts=32\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.sep_mult = float(min_separation_mult)\n        self.conn_steps = int(connect_greedy_steps)\n        self.rewire_mult = float(rewire_radius_mult)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self._rng = 1\n        self._h = 1\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if (not self._inside(self.start)) or (not self._inside(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.sep = max(0.25, self.step * self.sep_mult)\n        self.rewire_radius = max(self.step * 1.5, self.step * self.rewire_mult)\n\n        self._build_obstacle_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Direct path quick check\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Initialize trees and spatial hashes\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        Ta, Tb = [root_a], [root_b]\n        Ga, Gb = {}, {}\n        self._grid_put(Ga, root_a)\n        self._grid_put(Gb, root_b)\n        nodes.extend([root_a, root_b])\n\n        best_cost = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            from_start_side = (it % 2 == 0)\n            T_src, T_dst = (Ta, Tb) if from_start_side else (Tb, Ta)\n            G_src, G_dst = (Ga, Gb) if from_start_side else (Gb, Ga)\n            attractor = self.goal if from_start_side else self.start\n\n            q = self._sample(attractor, best_cost)\n            if q is None:\n                continue\n\n            new_node = self._extend_greedy(T_src, G_src, q, nodes, edges, choose_parent=True, do_rewire=True)\n            if new_node is None:\n                continue\n\n            meet = self._connect_toward(T_dst, G_dst, new_node.position, nodes, edges)\n            if meet is not None:\n                # Stitch and finalize\n                if from_start_side:\n                    path_a = self._path_to_root(new_node)\n                    path_b = self._path_to_root(meet)\n                    path = path_a + path_b[-2::-1]\n                else:\n                    path_a = self._path_to_root(meet)\n                    path_b = self._path_to_root(new_node)\n                    path = path_a + path_b[-2::-1]\n                path = self._finalize(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Opportunistic goal/start direct bridging when close and visible\n            tgt = attractor\n            if self._dist(new_node.position, tgt) <= self.conn_steps * self.step:\n                if self._edge_free(new_node.position, tgt):\n                    # Insert exact meeting into the same tree (ignoring spacing for solution stitching)\n                    meet_node = self._attach_node(T_src, G_src, new_node, tgt, nodes, edges, ignore_spacing=True)\n                    if meet_node is not None:\n                        if from_start_side:\n                            path = self._path_to_root(meet_node)\n                        else:\n                            path = self._path_to_root(meet_node)\n                        path = self._finalize(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n            # Maintain an incremental best path via nearest opposite if visible\n            near_dst = self._nearest(G_dst, new_node.position, T_dst)\n            if near_dst and self._edge_free(new_node.position, near_dst.position):\n                tentative = self._path_to_root(new_node) + self._path_to_root(near_dst)[-2::-1]\n                cost = self._polyline_len(tentative)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_path = tentative\n\n        if best_path is not None:\n            best_path = self._finalize(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and sampling\n    def _seed(self):\n        s = 0x9E3779B1\n        for v in self.start + self.goal:\n            s ^= (int(v * 2654435761) & 0xffffffff)\n            s = (s * 1664525 + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 1\n        self._rng = s\n        self._h = 1\n\n    def _rand(self):\n        self._rng = (self._rng * 1103515245 + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _halton(self, i, base):\n        f = 1.0 / base\n        r = 0.0\n        while i > 0:\n            r += (i % base) * f\n            i //= base\n            f /= base\n        return r\n\n    def _halton_point(self, idx):\n        if self.is3:\n            return (\n                self._halton(idx, 2) * self.bounds[0],\n                self._halton(idx, 3) * self.bounds[1],\n                self._halton(idx, 5) * self.bounds[2],\n            )\n        else:\n            return (\n                self._halton(idx, 2) * self.bounds[0],\n                self._halton(idx, 3) * self.bounds[1],\n            )\n\n    def _sample(self, attractor, c_best):\n        r = self._rand()\n        if r < self.goal_bias:\n            return attractor\n\n        # Try a few Halton candidates (filtered by informed set if available)\n        tries = 0\n        idx = self._h\n        while tries < 8:\n            p = self._halton_point(idx)\n            idx += 1\n            tries += 1\n            if (not self._inside(p)) or self._point_blocked(p):\n                continue\n            if c_best < float('inf'):\n                if (self._dist(self.start, p) + self._dist(p, self.goal)) > (c_best + 1e-9):\n                    continue\n            self._h = idx\n            return p\n\n        # Fallback uniform attempts\n        for _ in range(16):\n            if self.is3:\n                p = (\n                    self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]),\n                )\n            else:\n                p = (\n                    self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                )\n            if (not self._inside(p)) or self._point_blocked(p):\n                continue\n            if c_best < float('inf'):\n                if (self._dist(self.start, p) + self._dist(p, self.goal)) > (c_best + 1e-9):\n                    continue\n            return p\n        return None\n\n    # Geometry\n    def _inside(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        out = []\n        for i in range(self.dim):\n            out.append(a[i] + (b[i] - a[i]) * r)\n        return tuple(out)\n\n    # Spatial hash for nodes\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        else:\n            return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_put(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos, T_list):\n        key = self._cell_key(pos)\n        # Expand search rings up to 2 then fallback\n        for r in (0, 1, 2):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                best = None\n                bestd = float('inf')\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                return best\n        # Fallback to partial linear scan (sample up to 64)\n        if not T_list:\n            return None\n        m = min(len(T_list), 64)\n        best = None\n        bestd = float('inf')\n        step = max(1, len(T_list) // m)\n        for i in range(0, len(T_list), step):\n            n = T_list[i]\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _neighbors(self, grid, pos, radius, limit=None):\n        key = self._cell_key(pos)\n        rc = int(max(1, radius // self.cell)) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n                                if limit is not None and len(out) >= limit:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n                            if limit is not None and len(out) >= limit:\n                                return out\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        nbr = self._neighbors(grid, pos, radius, limit=1)\n        return len(nbr) > 0\n\n    # Obstacles and collision\n    def _build_obstacle_bins(self):\n        self.ob_cell = max(4.0, self.step * 2.0)\n        self.ob_grid = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.ob_cell)\n                iy0 = int(max(0.0, y) // self.ob_cell)\n                iz0 = int(max(0.0, z) // self.ob_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.ob_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.ob_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.ob_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            bucket = self.ob_grid.get(key)\n                            if bucket is None:\n                                self.ob_grid[key] = [idx]\n                            else:\n                                bucket.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.ob_cell)\n                iy0 = int(max(0.0, y) // self.ob_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.ob_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.ob_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        bucket = self.ob_grid.get(key)\n                        if bucket is None:\n                            self.ob_grid[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.ob_cell)\n            iy = int(p[1] // self.ob_cell)\n            iz = int(p[2] // self.ob_cell)\n            bucket = self.ob_grid.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.ob_cell)\n            iy = int(p[1] // self.ob_cell)\n            bucket = self.ob_grid.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits(a, b)\n\n    def _segment_hits(self, a, b):\n        # Collect candidate bins intersecting bounding box of segment\n        if self.is3:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1],\n                  a[2] if a[2] < b[2] else b[2])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1],\n                  a[2] if a[2] > b[2] else b[2])\n            ix0 = int(max(0.0, mn[0]) // self.ob_cell)\n            iy0 = int(max(0.0, mn[1]) // self.ob_cell)\n            iz0 = int(max(0.0, mn[2]) // self.ob_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.ob_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.ob_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.ob_cell)\n            cand = []\n            seen = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.ob_grid.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                if idx not in seen:\n                                    seen.add(idx)\n                                    cand.append(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1])\n            ix0 = int(max(0.0, mn[0]) // self.ob_cell)\n            iy0 = int(max(0.0, mn[1]) // self.ob_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.ob_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.ob_cell)\n            cand = []\n            seen = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.ob_grid.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            if idx not in seen:\n                                seen.add(idx)\n                                cand.append(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box(self, p0, p1, bmin, bmax):\n        # Slab intersection test\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Tree operations\n    def _attach_node(self, tree, grid, parent, pos, nodes, edges, ignore_spacing=False):\n        if (not self._inside(pos)) or self._point_blocked(pos):\n            return None\n        if (not ignore_spacing) and self._too_close(grid, pos, self.sep):\n            return None\n        if not self._edge_free(parent.position, pos):\n            return None\n        ncost = parent.cost + self._dist(parent.position, pos)\n        nd = Node(pos, parent, ncost)\n        parent.add_child(nd)\n        tree.append(nd)\n        nodes.append(nd)\n        edges.append((parent, nd))\n        self._grid_put(grid, nd)\n        return nd\n\n    def _choose_parent_and_attach(self, tree, grid, near, pos, nodes, edges):\n        # Evaluate possible parents among neighbors for minimal cost\n        best_parent = near\n        best_cost = near.cost + self._dist(near.position, pos)\n        nbrs = self._neighbors(grid, pos, self.rewire_radius)\n        for n in nbrs:\n            if self._edge_free(n.position, pos):\n                c = n.cost + self._dist(n.position, pos)\n                if c < best_cost:\n                    best_cost = c\n                    best_parent = n\n        return self._attach_node(tree, grid, best_parent, pos, nodes, edges)\n\n    def _propagate_cost(self, node):\n        # Update costs down the subtree from this node\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                base = 0.0\n            else:\n                base = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            cur.cost = base\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _rewire_neighbors(self, tree, grid, new_node, edges):\n        nbrs = self._neighbors(grid, new_node.position, self.rewire_radius)\n        for nb in nbrs:\n            if nb is new_node or nb.parent is None:\n                continue\n            alt = new_node.cost + self._dist(new_node.position, nb.position)\n            if alt + 1e-9 < nb.cost and self._edge_free(new_node.position, nb.position):\n                # Rewire nb to new_node\n                oldp = nb.parent\n                # Remove edge (oldp, nb)\n                for i in range(len(edges) - 1, -1, -1):\n                    if edges[i][0] is oldp and edges[i][1] is nb:\n                        edges.pop(i)\n                        break\n                # Update parent-child lists\n                if nb in oldp.children:\n                    oldp.children.remove(nb)\n                new_node.add_child(nb)\n                # Add new edge\n                edges.append((new_node, nb))\n                # Propagate new costs\n                self._propagate_cost(nb)\n\n    def _extend_greedy(self, tree, grid, target, nodes, edges, choose_parent=True, do_rewire=True):\n        near = self._nearest(grid, target, tree)\n        if near is None:\n            return None\n        cur = near\n        created_any = None\n        steps = 0\n        first = True\n        while steps < max(2, int(self.conn_steps // 4)):\n            nxt = self._steer(cur.position, target, self.step)\n            if (not self._inside(nxt)) or self._point_blocked(nxt):\n                break\n            if self._too_close(grid, nxt, self.sep):\n                # If too dense around, stop this branch\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            if first and choose_parent:\n                ins = self._choose_parent_and_attach(tree, grid, cur, nxt, nodes, edges)\n            else:\n                ins = self._attach_node(tree, grid, cur, nxt, nodes, edges)\n            if ins is None:\n                break\n            created_any = ins\n            if do_rewire:\n                self._rewire_neighbors(tree, grid, ins, edges)\n            cur = ins\n            steps += 1\n            if self._dist2(nxt, target) <= (self.step * self.step * 0.25):\n                break\n        return created_any\n\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        near = self._nearest(grid, target_pos, tree)\n        if near is None:\n            return None\n        cur = near\n        steps = 0\n        last_new = None\n        while steps < self.conn_steps:\n            nxt = self._steer(cur.position, target_pos, self.step)\n            if (not self._inside(nxt)) or self._point_blocked(nxt):\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            ins = self._attach_node(tree, grid, cur, nxt, nodes, edges)\n            if ins is None:\n                break\n            last_new = ins\n            cur = ins\n            steps += 1\n            if self._dist2(nxt, target_pos) <= (self.step * self.step * 0.25):\n                break\n        # Try to insert exact meeting node at target (ignore spacing but respect collisions)\n        if last_new is not None:\n            if self._edge_free(last_new.position, target_pos) and (not self._point_blocked(target_pos)) and self._inside(target_pos):\n                meet = self._attach_node(tree, grid, last_new, target_pos, nodes, edges, ignore_spacing=True)\n                if meet is not None:\n                    return meet\n        return None\n\n    # Path utilities\n    def _path_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _polyline_len(self, pts):\n        if len(pts) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(pts)):\n            s += self._dist(pts[i - 1], pts[i])\n        return s\n\n    def _prune_los(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3 or attempts <= 0:\n            return pts[:]\n        cur = pts[:]\n        t = 0\n        while t < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                t += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cur = cur[:i + 1] + cur[j:]\n            t += 1\n        # remove consecutive duplicates\n        out = []\n        last = None\n        for p in cur:\n            if (last is None) or (p != last):\n                out.append(p)\n                last = p\n        return out\n\n    def _finalize(self, pts):\n        if not pts or len(pts) < 2:\n            return pts\n        p1 = self._prune_los(pts)\n        p2 = self._shortcut(p1, self.smooth_shortcuts)\n        return p2",
                "objective": -40.853,
                "time_improvement": 81.0,
                "length_improvement": 13.0,
                "smoothness_improvement": 1732.0,
                "node_improvement": 90.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.009050464630126953,
                        "num_nodes_avg": 62.0,
                        "path_length_avg": 167.25184196372624,
                        "smoothness_avg": 0.05773376057210564,
                        "success_improvement": 0.0,
                        "time_improvement": 63.4356981723821,
                        "node_improvement": 84.38680433140266,
                        "length_improvement": 8.326615144646848,
                        "smoothness_improvement": 803.658723821166,
                        "objective_score": 28.044972157608566
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.007950639724731446,
                        "num_nodes_avg": 70.0,
                        "path_length_avg": 251.14175674494882,
                        "smoothness_avg": 0.12433013000291153,
                        "success_improvement": 0.0,
                        "time_improvement": 95.16463560694861,
                        "node_improvement": 95.29664718134785,
                        "length_improvement": 16.161652883875146,
                        "smoothness_improvement": 3099.103796347861,
                        "objective_score": 53.74190139414897
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.007700490951538086,
                        "num_nodes_avg": 72.0,
                        "path_length_avg": 128.38035355103494,
                        "smoothness_avg": 0.1094566942751672,
                        "success_improvement": 0.0,
                        "time_improvement": 84.89728411849231,
                        "node_improvement": 90.8455181182454,
                        "length_improvement": 14.735881986904387,
                        "smoothness_improvement": 1292.2810719273684,
                        "objective_score": 40.77211978732716
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "Swift-BiRRT*: Informed Sparse Bidirectional RRT-Connect with k-Rewire and Elastic Smoothing \u2014 a fast planner that prioritizes low collision checks, compact trees, and early solutions. It alternates growth of two trees with goal-biased, informed (elliptical) low-discrepancy sampling, performs single-step greedy extension with k-limited, shrinking-radius rewiring, and uses a tight spatial hash for near/nearest queries. After a first solution, it finalizes quickly via LOS pruning, randomized shortcuts, and a light collision-safe Laplacian smoothing, delivering short, smooth paths with markedly reduced planning time.",
            "planning_mechanism": "Each iteration picks the sparser tree, samples a feasible point (goal-biased, filtered by the current best-cost ellipse), finds a near node via a small-ring grid search, and takes one bounded step. The first step selects the cheapest visible parent among up to k nearby nodes; a localized, k-limited rewire improves costs. The opposite tree attempts a short connect toward the new node. If the trees meet or a direct bridge is visible, the path is stitched and smoothed. Tight spacing, capped connect steps, and shrinking rewire radii keep the tree sparse and collision checks low for faster planning.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=2000,\n        step_size=10.0,\n        goal_bias=0.25,\n        grid_cell_factor=1.6,\n        min_separation_mult=0.6,\n        connect_steps=20,\n        k_rewire=8,\n        base_rewire_radius_mult=2.5,\n        smooth_shortcuts=24,\n        laplacian_iters=6\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.sep_mult = float(min_separation_mult)\n        self.connect_steps = int(connect_steps)\n        self.k_rewire = int(k_rewire)\n        self.base_rewire_mult = float(base_rewire_radius_mult)\n        self.smooth_shortcuts = int(max(0, smooth_shortcuts))\n        self.laplacian_iters = int(max(0, laplacian_iters))\n        self._rng = 1\n        self._h = 1\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if (not self._inside(self.start)) or (not self._inside(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.sep = max(0.25, self.step * self.sep_mult)\n        self.rewire_base = max(self.step * 1.5, self.step * self.base_rewire_mult)\n\n        self._build_obstacle_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Quick direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._finalize(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Init trees and grids\n        root_a = Node(self.start, None, 0.0)\n        root_b = Node(self.goal, None, 0.0)\n        Ta, Tb = [root_a], [root_b]\n        Ga, Gb = {}, {}\n        self._grid_put(Ga, root_a)\n        self._grid_put(Gb, root_b)\n        nodes.extend([root_a, root_b])\n\n        best_cost = float('inf')\n        best_path = None\n\n        for it in range(self.max_iter):\n            # Grow the smaller tree to balance exploration cheaply\n            from_start_side = (len(Ta) <= len(Tb))\n            T_src, T_dst = (Ta, Tb) if from_start_side else (Tb, Ta)\n            G_src, G_dst = (Ga, Gb) if from_start_side else (Gb, Ga)\n            attractor = self.goal if from_start_side else self.start\n\n            q = self._sample(attractor, best_cost)\n            if q is None:\n                continue\n\n            new_node = self._extend_once(T_src, G_src, q, nodes, edges, choose_parent=True, do_rewire=True)\n            if new_node is None:\n                continue\n\n            # Opportunistic short connect from the other tree\n            meet = self._connect_toward(T_dst, G_dst, new_node.position, nodes, edges)\n            if meet is not None:\n                if from_start_side:\n                    path_a = self._path_to_root(new_node)\n                    path_b = self._path_to_root(meet)\n                    path = path_a + path_b[-2::-1]\n                else:\n                    path_a = self._path_to_root(meet)\n                    path_b = self._path_to_root(new_node)\n                    path = path_a + path_b[-2::-1]\n                path = self._finalize(path)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Try a direct bridge to the opposite root when close\n            if self._dist(new_node.position, attractor) <= self.connect_steps * self.step:\n                if self._edge_free(new_node.position, attractor):\n                    meet_node = self._attach_node(T_src, G_src, new_node, attractor, nodes, edges, ignore_spacing=True)\n                    if meet_node is not None:\n                        path = self._path_to_root(meet_node)\n                        path = self._finalize(path)\n                        return PlannerResult(True, path, nodes, edges)\n\n            # Maintain an incremental best path cheaply via nearest opposite if visible\n            near_dst = self._nearest(G_dst, new_node.position, T_dst)\n            if near_dst and self._edge_free(new_node.position, near_dst.position):\n                tentative = self._path_to_root(new_node) + self._path_to_root(near_dst)[-2::-1]\n                cost = self._polyline_len(tentative)\n                if cost < best_cost:\n                    best_cost = cost\n                    best_path = tentative\n\n        if best_path is not None:\n            best_path = self._finalize(best_path)\n            return PlannerResult(True, best_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG, low-discrepancy sampler\n    def _seed(self):\n        s = 0x9E3779B1\n        for v in self.start + self.goal:\n            s ^= (int(v * 2654435761) & 0xffffffff)\n            s = (s * 1664525 + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 1\n        self._rng = s\n        self._h = 1\n\n    def _rand(self):\n        self._rng = (self._rng * 1103515245 + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _halton(self, i, base):\n        f = 1.0 / base\n        r = 0.0\n        while i > 0:\n            r += (i % base) * f\n            i //= base\n            f /= base\n        return r\n\n    def _halton_point(self, idx):\n        if self.is3:\n            return (\n                self._halton(idx, 2) * self.bounds[0],\n                self._halton(idx, 3) * self.bounds[1],\n                self._halton(idx, 5) * self.bounds[2],\n            )\n        else:\n            return (\n                self._halton(idx, 2) * self.bounds[0],\n                self._halton(idx, 3) * self.bounds[1],\n            )\n\n    def _sample(self, attractor, c_best):\n        # goal-biased informed sampling\n        if self._rand() < self.goal_bias:\n            return attractor\n        tries = 0\n        idx = self._h\n        while tries < 6:\n            p = self._halton_point(idx)\n            idx += 1\n            tries += 1\n            if (not self._inside(p)) or self._point_blocked(p):\n                continue\n            if c_best < float('inf'):\n                if (self._dist(self.start, p) + self._dist(p, self.goal)) > (c_best + 1e-9):\n                    continue\n            self._h = idx\n            return p\n        # fallback uniform attempts\n        for _ in range(12):\n            if self.is3:\n                p = (\n                    self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]),\n                )\n            else:\n                p = (\n                    self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                )\n            if (not self._inside(p)) or self._point_blocked(p):\n                continue\n            if c_best < float('inf'):\n                if (self._dist(self.start, p) + self._dist(p, self.goal)) > (c_best + 1e-9):\n                    continue\n            return p\n        return None\n\n    # Geometry\n    def _inside(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        out = []\n        for i in range(self.dim):\n            out.append(a[i] + (b[i] - a[i]) * r)\n        return tuple(out)\n\n    # Spatial hash\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        else:\n            return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_put(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos, T_list):\n        key = self._cell_key(pos)\n        for r in (0, 1):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                best = None\n                bestd = float('inf')\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if d2 < bestd:\n                        bestd = d2\n                        best = n\n                return best\n        # Fallback small scan\n        if not T_list:\n            return None\n        m = min(len(T_list), 32)\n        best = None\n        bestd = float('inf')\n        step = max(1, len(T_list) // m)\n        for i in range(0, len(T_list), step):\n            n = T_list[i]\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd:\n                bestd = d2\n                best = n\n        return best\n\n    def _neighbors_k(self, grid, pos, radius, k):\n        key = self._cell_key(pos)\n        rc = int(radius / self.cell) + 1  # ceil(radius/cell)\n        r2 = radius * radius\n        cand = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            d2 = self._dist2(n.position, pos)\n                            if d2 <= r2:\n                                cand.append((d2, n))\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        d2 = self._dist2(n.position, pos)\n                        if d2 <= r2:\n                            cand.append((d2, n))\n        if not cand:\n            return []\n        # Partial selection of k nearest\n        cand.sort(key=lambda t: t[0])\n        out = []\n        for i in range(min(k, len(cand))):\n            out.append(cand[i][1])\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        nbrs = self._neighbors_k(grid, pos, radius, 1)\n        return len(nbrs) > 0\n\n    # Obstacles and collision\n    def _build_obstacle_bins(self):\n        self.ob_cell = max(6.0, self.step * 2.5)\n        self.ob_grid = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.ob_cell)\n                iy0 = int(max(0.0, y) // self.ob_cell)\n                iz0 = int(max(0.0, z) // self.ob_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.ob_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.ob_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.ob_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            bucket = self.ob_grid.get(key)\n                            if bucket is None:\n                                self.ob_grid[key] = [idx]\n                            else:\n                                bucket.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.ob_cell)\n                iy0 = int(max(0.0, y) // self.ob_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.ob_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.ob_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        bucket = self.ob_grid.get(key)\n                        if bucket is None:\n                            self.ob_grid[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.ob_cell)\n            iy = int(p[1] // self.ob_cell)\n            iz = int(p[2] // self.ob_cell)\n            bucket = self.ob_grid.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.ob_cell)\n            iy = int(p[1] // self.ob_cell)\n            bucket = self.ob_grid.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits(a, b)\n\n    def _segment_hits(self, a, b):\n        if self.is3:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1],\n                  a[2] if a[2] < b[2] else b[2])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1],\n                  a[2] if a[2] > b[2] else b[2])\n            ix0 = int(max(0.0, mn[0]) // self.ob_cell)\n            iy0 = int(max(0.0, mn[1]) // self.ob_cell)\n            iz0 = int(max(0.0, mn[2]) // self.ob_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.ob_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.ob_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.ob_cell)\n            cand = []\n            seen = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        lst = self.ob_grid.get((i, j, k))\n                        if lst:\n                            for idx in lst:\n                                if idx not in seen:\n                                    seen.add(idx)\n                                    cand.append(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mn = (a[0] if a[0] < b[0] else b[0],\n                  a[1] if a[1] < b[1] else b[1])\n            mx = (a[0] if a[0] > b[0] else b[0],\n                  a[1] if a[1] > b[1] else b[1])\n            ix0 = int(max(0.0, mn[0]) // self.ob_cell)\n            iy0 = int(max(0.0, mn[1]) // self.ob_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.ob_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.ob_cell)\n            cand = []\n            seen = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    lst = self.ob_grid.get((i, j))\n                    if lst:\n                        for idx in lst:\n                            if idx not in seen:\n                                seen.add(idx)\n                                cand.append(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Tree ops\n    def _attach_node(self, tree, grid, parent, pos, nodes, edges, ignore_spacing=False):\n        if (not self._inside(pos)) or self._point_blocked(pos):\n            return None\n        if (not ignore_spacing) and self._too_close(grid, pos, self.sep):\n            return None\n        if not self._edge_free(parent.position, pos):\n            return None\n        ncost = parent.cost + self._dist(parent.position, pos)\n        nd = Node(pos, parent, ncost)\n        parent.add_child(nd)\n        tree.append(nd)\n        nodes.append(nd)\n        edges.append((parent, nd))\n        self._grid_put(grid, nd)\n        return nd\n\n    def _dynamic_rewire_radius(self, ncount):\n        # Shrinking radius to cut neighbor scans over time\n        scale = (ncount + 1.0) ** (1.0 / max(2, self.dim))\n        r = self.rewire_base / scale\n        if r < self.step * 1.25:\n            r = self.step * 1.25\n        return r\n\n    def _choose_parent_and_attach(self, tree, grid, near, pos, nodes, edges):\n        best_parent = near\n        best_cost = near.cost + self._dist(near.position, pos)\n        radius = self._dynamic_rewire_radius(len(tree))\n        nbrs = self._neighbors_k(grid, pos, radius, self.k_rewire)\n        for n in nbrs:\n            if self._edge_free(n.position, pos):\n                c = n.cost + self._dist(n.position, pos)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best_parent = n\n        return self._attach_node(tree, grid, best_parent, pos, nodes, edges)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _rewire_neighbors(self, tree, grid, new_node, edges):\n        radius = self._dynamic_rewire_radius(len(tree))\n        nbrs = self._neighbors_k(grid, new_node.position, radius, self.k_rewire)\n        for nb in nbrs:\n            if nb is new_node or nb.parent is None:\n                continue\n            alt = new_node.cost + self._dist(new_node.position, nb.position)\n            if alt + 1e-9 < nb.cost and self._edge_free(new_node.position, nb.position):\n                oldp = nb.parent\n                # remove old edge\n                for i in range(len(edges) - 1, -1, -1):\n                    if edges[i][0] is oldp and edges[i][1] is nb:\n                        edges.pop(i)\n                        break\n                if nb in oldp.children:\n                    oldp.children.remove(nb)\n                new_node.add_child(nb)\n                edges.append((new_node, nb))\n                self._propagate_cost(nb)\n\n    def _extend_once(self, tree, grid, target, nodes, edges, choose_parent=True, do_rewire=True):\n        near = self._nearest(grid, target, tree)\n        if near is None:\n            return None\n        nxt = self._steer(near.position, target, self.step)\n        if (not self._inside(nxt)) or self._point_blocked(nxt):\n            return None\n        if self._too_close(grid, nxt, self.sep):\n            return None\n        if not self._edge_free(near.position, nxt):\n            return None\n        if choose_parent:\n            ins = self._choose_parent_and_attach(tree, grid, near, nxt, nodes, edges)\n        else:\n            ins = self._attach_node(tree, grid, near, nxt, nodes, edges)\n        if ins is None:\n            return None\n        if do_rewire:\n            self._rewire_neighbors(tree, grid, ins, edges)\n        return ins\n\n    def _connect_toward(self, tree, grid, target_pos, nodes, edges):\n        near = self._nearest(grid, target_pos, tree)\n        if near is None:\n            return None\n        cur = near\n        last_new = None\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(cur.position, target_pos, self.step)\n            if (not self._inside(nxt)) or self._point_blocked(nxt):\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            ins = self._attach_node(tree, grid, cur, nxt, nodes, edges)\n            if ins is None:\n                break\n            last_new = ins\n            cur = ins\n            steps += 1\n            if self._dist2(nxt, target_pos) <= (self.step * self.step * 0.25):\n                break\n        if last_new is not None:\n            if self._edge_free(last_new.position, target_pos) and (not self._point_blocked(target_pos)) and self._inside(target_pos):\n                meet = self._attach_node(tree, grid, last_new, target_pos, nodes, edges, ignore_spacing=True)\n                if meet is not None:\n                    return meet\n        return None\n\n    # Path utilities\n    def _path_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _polyline_len(self, pts):\n        if len(pts) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(pts)):\n            s += self._dist(pts[i - 1], pts[i])\n        return s\n\n    def _prune_los(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3 or attempts <= 0:\n            return pts[:]\n        cur = pts[:]\n        t = 0\n        while t < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                t += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cur = cur[:i + 1] + cur[j:]\n            t += 1\n        # dedup\n        out = []\n        last = None\n        for p in cur:\n            if (last is None) or (p != last):\n                out.append(p)\n                last = p\n        return out\n\n    def _laplacian_smooth(self, pts, iters):\n        if len(pts) < 3 or iters <= 0:\n            return pts[:]\n        cur = [tuple(p) for p in pts]\n        alpha = 0.5\n        for _ in range(iters):\n            changed = False\n            for i in range(1, len(cur) - 1):\n                p_prev = cur[i - 1]\n                p = cur[i]\n                p_next = cur[i + 1]\n                # candidate: midpoint blend\n                cand = []\n                for d in range(self.dim):\n                    cand.append((p_prev[d] + p_next[d]) * 0.5 * alpha + p[d] * (1.0 - alpha))\n                cand = tuple(cand)\n                if (not self._inside(cand)) or self._point_blocked(cand):\n                    continue\n                if self._edge_free(p_prev, cand) and self._edge_free(cand, p_next):\n                    cur[i] = cand\n                    changed = True\n            if not changed:\n                break\n        return cur\n\n    def _finalize(self, pts):\n        if not pts or len(pts) < 2:\n            return pts\n        p1 = self._prune_los(pts)\n        p2 = self._shortcut(p1, self.smooth_shortcuts)\n        p3 = self._laplacian_smooth(p2, self.laplacian_iters)\n        return p3",
            "objective": -46.3131,
            "time_improvement": 90.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 1866.0,
            "node_improvement": 95.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0031968116760253905,
                    "num_nodes_avg": 19.0,
                    "path_length_avg": 151.3156555185092,
                    "smoothness_avg": 0.04250503411011958,
                    "success_improvement": 0.0,
                    "time_improvement": 87.08473080827832,
                    "node_improvement": 95.21531100478468,
                    "length_improvement": 17.06149146030435,
                    "smoothness_improvement": 565.2960849822728,
                    "objective_score": 39.18879454357747
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01100008487701416,
                    "num_nodes_avg": 68.0,
                    "path_length_avg": 238.7363522100142,
                    "smoothness_avg": 0.12047369196284599,
                    "success_improvement": 0.0,
                    "time_improvement": 93.31004540811918,
                    "node_improvement": 95.4310286904522,
                    "length_improvement": 20.30293398740759,
                    "smoothness_improvement": 2999.874867896929,
                    "objective_score": 55.17414835436495
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.00599064826965332,
                    "num_nodes_avg": 46.0,
                    "path_length_avg": 130.63225469658005,
                    "smoothness_avg": 0.1675633775014901,
                    "success_improvement": 0.0,
                    "time_improvement": 88.25074150050804,
                    "node_improvement": 94.15130324221234,
                    "length_improvement": 13.240276470042689,
                    "smoothness_improvement": 2031.3937935769857,
                    "objective_score": 44.57635730006295
                }
            ],
            "success_rate": 1.0
        },
        "objective": 50.4,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Multi-step greedy extension per iteration causing many collision checks and frequent insertions\n   - Heavy, wide-radius rewiring with full neighbor scans and subtree cost propagation each step\n   - Inefficient nearest/neighbor queries with broad grid-ring expansion and large fallback scans\n   - Long connect phases that attempt many consecutive collision checks\n   - Dense tree growth due to low minimum separation, inflating nodes and query costs\n   - Alternating tree growth regardless of balance, leading to wasted expansions before meeting\n   - Fixed, nonshrinking rewire radius that does not scale down as the tree grows\n   - Smoothing pipeline focused on shortcuts only, offering limited cost-time tradeoff"
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Single-step extension per sample instead of multi-step greedy growth\n   - k-limited, shrinking-radius rewiring and parenting\n   - Higher minimum separation and larger spatial hashing cells\n   - Shorter connect phases with capped steps\n   - More aggressive goal-biased, informed sampling with fewer fallback attempts\n   - Tighter nearest/neighbor queries (smaller ring expansion, smaller fallback scans)\n   - Balanced tree growth by expanding the smaller tree\n   - Coarser obstacle binning and a lighter-weight smoothing pipeline\n2. Expected mechanism of impact:\n   - Fewer edge collision checks and insertions per iteration reduce compute per step\n   - Limiting and shrinking rewiring neighborhoods cuts neighbor scans and cost propagation\n   - Sparser trees and larger bins lower nearest/neighbor and collision query counts\n   - Short connects avoid long, repeated collision-check streaks\n   - Goal-focused sampling accelerates meeting/bridging, reducing iterations to first solution\n   - Restricting NN search breadth reduces memory traffic and distance computations\n   - Growing the smaller tree increases the chance of fast connections with fewer expansions\n   - Lighter smoothing minimizes post-processing time while preserving feasibility"
        }
    }
]