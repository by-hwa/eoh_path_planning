[
    {
        "operator": "cross_over",
        "algorithm_description": "AIR-Connect*: Adaptive Informed Rewire BiRRT-Connect with cached edges and ring-hash neighbors. It alternates tree growth from start/goal, uses ellipse-gated sampling after first solution, cost-gated admission before expensive checks, LOS-cost parent selection with local RRT* rewiring, cached edge validity, and a short validated connect toward the opposite tree. On bridge, it visibility-prunes and applies bounded shortcuts for shorter, smoother paths.",
        "planning_mechanism": "Alternate expanding the two trees. For each sample: find a near node via ring-hash, steer one step, bounds+node-collision check, early cost-gate, then edge-collision. Select the best-cost parent among nearby LOS neighbors; insert and locally rewire cheaper neighbors under edge checks. Attempt a short validated connect to the other tree; if a direct or stepwise bridge succeeds, extract, prune, and shortcut the path. Use informed ellipse sampling after first path to focus and reduce time.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=5.0,\n        goal_bias=0.25,\n        line_bias=0.25,\n        grid_cell_factor=1.5,\n        min_sep_factor=0.4,\n        ring_max=3,\n        neighbor_factor=3.0,\n        connect_steps=6,\n        occ_relax=1.05,\n        smoothing_iters=120\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.min_sep_factor = min_sep_factor\n        self.ring_max = ring_max\n        self.neighbor_factor = neighbor_factor\n        self.connect_steps = connect_steps\n        self.occ_relax = occ_relax\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Derived parameters\n        self.edge_res = max(0.5, min(1.0, 0.5 * self.step_size))\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.3, self.step_size * self.min_sep_factor)\n        self.occ_cell = max(0.5, 0.6 * self.step_size)\n\n        # Reset caches\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # Initialize bi-trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n\n        start_nodes = [start_root]\n        goal_nodes = [goal_root]\n        all_nodes = [start_root, goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root, self.cell_size)\n        self._grid_add(grid_goal, goal_root, self.cell_size)\n\n        occ_start = {self._grid_key(start, self.occ_cell): 0.0}\n        occ_goal = {self._grid_key(goal, self.occ_cell): 0.0}\n\n        success = False\n        best_path = None\n        c_best = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n\n            if active_start:\n                nodes_a, nodes_b = start_nodes, goal_nodes\n                grid_a, grid_b = grid_start, grid_goal\n                occ_a, occ_b = occ_start, occ_goal\n                attractor = goal\n                root_a = start_root\n                root_b = goal_root\n            else:\n                nodes_a, nodes_b = goal_nodes, start_nodes\n                grid_a, grid_b = grid_goal, grid_start\n                occ_a, occ_b = occ_goal, occ_start\n                attractor = start\n                root_a = goal_root\n                root_b = start_root\n\n            # Sample\n            if self._rand() < self.goal_bias:\n                x_rand = attractor\n            else:\n                if c_best < float('inf') and self._rand() < 0.6:\n                    x_rand = self._ellipse_sample(root_a.position, root_b.position, c_best)\n                elif self._rand() < self.line_bias:\n                    t = self._uniform(0.0, 1.0)\n                    base = tuple(root_a.position[i] + t * (root_b.position[i] - root_a.position[i]) for i in range(self.dim))\n                    jitter = 0.5 * self.step_size\n                    x_rand = tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n                else:\n                    x_rand = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n            # Nearest in active tree\n            n_near = self._nearest_hashed(grid_a, nodes_a, x_rand)\n            if n_near is None:\n                continue\n\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n            if not self._in_bounds(x_new_pos):\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                continue\n            if self._near_duplicate(grid_a, x_new_pos, self.min_sep):\n                continue\n\n            # Early cost-gated admission (cheap)\n            tentative_cost = n_near.cost + self._dist(n_near.position, x_new_pos)\n            if not self._occ_accept(occ_a, x_new_pos, tentative_cost, self.occ_cell, self.occ_relax):\n                continue\n\n            # Edge collision with nearest\n            if self._edge_blocked(n_near.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            # Choose best parent among neighbors with LOS\n            neigh_r = self._neighbor_radius(len(nodes_a))\n            neigh = self._neighbors_in_radius(grid_a, x_new_pos, neigh_r)\n            parent, new_cost = self._choose_best_parent(x_new_pos, n_near, neigh, obstacles, is_3d)\n            if parent is None:\n                continue\n            if self._edge_blocked(parent.position, x_new_pos, obstacles, is_3d):\n                continue  # safety\n\n            # Insert new node\n            x_new = Node(x_new_pos, None, new_cost)\n            x_new.attach(parent)\n            nodes_a.append(x_new)\n            all_nodes.append(x_new)\n            self._grid_add(grid_a, x_new, self.cell_size)\n            self._occ_update(occ_a, x_new_pos, new_cost, self.occ_cell)\n\n            # Local RRT* rewiring around new node\n            self._rewire_neighbors(x_new, neigh, obstacles, is_3d)\n\n            # Try to connect to the other tree (direct, else short validated steps)\n            other_near = self._nearest_hashed(grid_b, nodes_b, x_new.position)\n            bridged_node_b = None\n\n            # Direct attempt\n            if (other_near is not None) and (not self._edge_blocked(x_new.position, other_near.position, obstacles, is_3d)):\n                bridged_node_b = other_near\n            else:\n                # Short validated connect from other tree toward x_new\n                cur = other_near\n                steps = 0\n                while cur is not None and steps < self.connect_steps:\n                    step_pos = self._steer(cur.position, x_new.position, self.step_size)\n                    if not self._in_bounds(step_pos):\n                        break\n                    if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                        break\n                    if self._near_duplicate(grid_b, step_pos, self.min_sep):\n                        break\n                    connect_cost = cur.cost + self._dist(cur.position, step_pos)\n                    if not self._occ_accept(occ_b, step_pos, connect_cost, self.occ_cell, self.occ_relax):\n                        break\n                    if self._edge_blocked(cur.position, step_pos, obstacles, is_3d):\n                        break\n\n                    # Parent selection for connect step\n                    neigh_b = self._neighbors_in_radius(grid_b, step_pos, neigh_r)\n                    p_b, c_b = self._choose_best_parent(step_pos, cur, neigh_b, obstacles, is_3d)\n                    if p_b is None:\n                        break\n                    if self._edge_blocked(p_b.position, step_pos, obstacles, is_3d):\n                        break\n\n                    nxt = Node(step_pos, None, c_b)\n                    nxt.attach(p_b)\n                    nodes_b.append(nxt)\n                    all_nodes.append(nxt)\n                    self._grid_add(grid_b, nxt, self.cell_size)\n                    self._occ_update(occ_b, step_pos, c_b, self.occ_cell)\n\n                    # light rewire on B-side (cheap subset)\n                    self._rewire_neighbors(nxt, neigh_b, obstacles, is_3d)\n\n                    cur = nxt\n                    steps += 1\n\n                    # Check final bridge\n                    if not self._edge_blocked(cur.position, x_new.position, obstacles, is_3d):\n                        bridged_node_b = cur\n                        break\n\n            if bridged_node_b is not None:\n                # Extract full path\n                if active_start:\n                    path = self._path_to_root(x_new)\n                    path_b = self._path_to_root(bridged_node_b)\n                    path_full = path + list(reversed(path_b))\n                else:\n                    path = self._path_to_root(x_new)\n                    path_b = self._path_to_root(bridged_node_b)\n                    path_full = path_b + list(reversed(path))\n\n                # Prune and smooth\n                path_full = self._visibility_prune(path_full, obstacles, is_3d)\n                path_full = self._shortcut_smooth(path_full, obstacles, is_3d, self.smoothing_iters)\n\n                L = self._path_length(path_full)\n                if L < c_best:\n                    c_best = L\n                    best_path = path_full\n                    success = True\n                    # Early stop on first good bridge to reduce time\n                    edges = []\n                    for n in all_nodes:\n                        if n.parent is not None:\n                            edges.append((n.parent, n))\n                    return PlannerResult(True, best_path, all_nodes, edges)\n\n        edges = []\n        for n in all_nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return PlannerResult(success, best_path if best_path is not None else [], all_nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    def _clamp(self, p):\n        return tuple(self._clip(p[i], 0.0, self.bounds[i]) for i in range(self.dim))\n\n    # Collision and caching\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        cached = self._edge_cache.get(k)\n        if cached is not None:\n            return cached\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Spatial hashing and neighbors\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        seen = set()\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            for n in b:\n                                if n not in seen:\n                                    seen.add(n)\n                                    cand.append(n)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        for n in b:\n                            if n not in seen:\n                                seen.add(n)\n                                cand.append(n)\n        return cand\n\n    def _nearest_hashed(self, grid, nodes, pos):\n        key = self._grid_key(pos, self.cell_size)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.ring_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback scan limited\n        limit = min(64, len(nodes))\n        if limit == 0:\n            return None\n        step = max(1, len(nodes) // limit)\n        for i in range(0, len(nodes), step):\n            n = nodes[i]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors_in_radius(self, grid, pos, radius):\n        r = int(radius // self.cell_size) + 1\n        key = self._grid_key(pos, self.cell_size)\n        cand = self._grid_ring_collect(grid, key, r)\n        res = []\n        rr = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr + 1e-9:\n                res.append(n)\n        return res\n\n    def _neighbor_radius(self, ncount):\n        base = self.neighbor_factor * self.step_size\n        if ncount < 200:\n            return base * 2.5\n        if ncount < 1000:\n            return base * 2.0\n        return base * 1.5\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos, self.cell_size)\n        cand = self._grid_ring_collect(grid, key, 1)\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                return True\n        return False\n\n    # Admission ledger\n    def _occ_accept(self, occ_best, pos, cost, cell, relax):\n        k = self._grid_key(pos, cell)\n        prev = occ_best.get(k, float('inf'))\n        return cost < prev * relax\n\n    def _occ_update(self, occ_best, pos, cost, cell):\n        k = self._grid_key(pos, cell)\n        prev = occ_best.get(k, float('inf'))\n        if cost < prev:\n            occ_best[k] = cost\n\n    # Parent selection and rewiring\n    def _choose_best_parent(self, new_pos, fallback_nearest, neighbors, obstacles, is_3d):\n        best_parent = fallback_nearest\n        best_cost = fallback_nearest.cost + self._dist(fallback_nearest.position, new_pos)\n        # Evaluate neighbors with LOS\n        for n in neighbors:\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-12 < best_cost:\n                if not self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                    best_cost = c\n                    best_parent = n\n        if best_parent is None:\n            return None, float('inf')\n        return best_parent, best_cost\n\n    def _rewire_neighbors(self, new_node, neighbors, obstacles, is_3d):\n        for m in neighbors:\n            if m is new_node or m is new_node.parent:\n                continue\n            alt = new_node.cost + self._dist(new_node.position, m.position)\n            if alt + 1e-12 < m.cost:\n                if not self._edge_blocked(new_node.position, m.position, obstacles, is_3d):\n                    old_cost = m.cost\n                    m.attach(new_node)\n                    m.cost = alt\n                    # Propagate cost change to descendants\n                    delta = alt - old_cost\n                    if abs(delta) > 0.0:\n                        self._propagate_cost(m, delta)\n\n    def _propagate_cost(self, node, delta):\n        q = [node]\n        while q:\n            cur = q.pop()\n            for ch in cur.children:\n                ch.cost += delta\n                q.append(ch)\n\n    # Sampling helpers\n    def _ellipse_sample(self, a, b, c_best):\n        # Sample uniformly in bounding box with quick rejection to keep it cheap\n        tries = 20\n        for _ in range(tries):\n            p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n            if self._dist(p, a) + self._dist(p, b) <= c_best + 1e-9:\n                return p\n        # Fallback to line jitter\n        t = self._uniform(0.0, 1.0)\n        base = tuple(a[i] + t * (b[i] - a[i]) for i in range(self.dim))\n        jitter = 0.5 * self.step_size\n        return tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n\n    # Path utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(out[-1], path[j], obstacles, is_3d):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        return out\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
        "objective": -29.76423,
        "time_improvement": 24.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 2154.0,
        "node_improvement": 82.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.022998476028442384,
                "num_nodes_avg": 61.0,
                "path_length_avg": 156.6750662963223,
                "smoothness_avg": 0.034451471616090565,
                "success_improvement": 0.0,
                "time_improvement": 16.617381254716395,
                "node_improvement": 84.63863006799295,
                "length_improvement": 14.123913487686588,
                "smoothness_improvement": 439.24034335984834,
                "objective_score": 15.655764185826111
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03999502658843994,
                "num_nodes_avg": 145.0,
                "path_length_avg": 236.64219232090036,
                "smoothness_avg": 0.18735486162713155,
                "success_improvement": 0.0,
                "time_improvement": 75.83074593448201,
                "node_improvement": 90.25734058993481,
                "length_improvement": 21.002024835444043,
                "smoothness_improvement": 4720.775535918357,
                "objective_score": 58.954316361202814
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.062010884284973145,
                "num_nodes_avg": 228.0,
                "path_length_avg": 115.36831063996797,
                "smoothness_avg": 0.11025750170008067,
                "success_improvement": 0.0,
                "time_improvement": -19.521486686135614,
                "node_improvement": 71.01080737444374,
                "length_improvement": 23.377861321535487,
                "smoothness_improvement": 1302.4672832628123,
                "objective_score": 14.682607203394669
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "FIBER-Connect*: Fast Informed Bi-directional Edge-Refining RRT* with priority-balanced growth, adaptive neighbor/rewire radii, short validated bridges, and online visibility-prune/shortcutting for smooth, compact paths with low search cost.",
        "planning_mechanism": "Per iteration, expand the smaller tree: sample (uniform/goal; informed ellipse after first path), steer one step, validate node and parent edge, pick the lowest-cost parent among nearby neighbors, insert, then locally rewire to reduce cost. Attempt a short, validated bridge to the opposite tree; if blocked, allow at most one assisted hop on the passive tree before retrying. On a bridge, extract the bi-tree path, apply visibility pruning and length-nonincreasing shortcuts, and return.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=5.5,\n        goal_bias=0.25,\n        informed_bias=0.6,\n        grid_cell_factor=1.0,\n        neighbor_base=3.2,\n        rewire_base=2.6,\n        connect_factor=3.0,\n        dupe_ratio=0.45,\n        ring_cap=4,\n        bridge_hops=1,\n        smooth_iters=80\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_base = float(neighbor_base)\n        self.rewire_base = float(rewire_base)\n        self.connect_factor = float(connect_factor)\n        self.dupe_ratio = float(dupe_ratio)\n        self.ring_cap = int(ring_cap)\n        self.bridge_hops = int(bridge_hops)\n        self.smooth_iters = int(smooth_iters)\n        self._rng = 123456789\n\n    def plan(self, map):\n        # Scene\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_rng()\n        # Build obstacle index and ensure start/goal free\n        self._build_obs_index()\n        if self._in_obs(self.start) or self._in_obs(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Straight line early exit\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            edges = [(n0, n1)]\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], edges)\n\n        # Parameters\n        self.space_extent = max(1.0, max(self.bounds))\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius_base = max(0.3, self.dupe_ratio * self.step_size)\n        self.connect_radius = max(self.step_size, self.connect_factor * self.step_size)\n\n        # Trees and spatial hashes\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes = [start_root, goal_root]\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        # Informed sampling bookkeeping\n        have_solution = False\n        best_path = []\n        best_len = 1e100\n        c_min = self._dist(self.start, self.goal)\n\n        for it in range(self.max_iter):\n            # Choose the tree with fewer nodes to keep balance\n            expand_a = (len(tree_a) <= len(tree_b))\n            active_tree = tree_a if expand_a else tree_b\n            passive_tree = tree_b if expand_a else tree_a\n            active_grid = grid_a if expand_a else grid_b\n            passive_grid = grid_b if expand_a else grid_a\n            attractor = self.goal if expand_a else self.start\n\n            # Radii adapt to tree size\n            n_active = max(2, len(active_tree))\n            parent_radius = self._adaptive_radius(n_active, self.neighbor_base)\n            rewire_radius = self._adaptive_radius(n_active, self.rewire_base)\n            dupe_radius = self.dupe_radius_base * (0.35 if have_solution else 1.0)\n\n            # Sample\n            x_rand = self._sample(attractor, have_solution, best_len, c_min)\n            if x_rand is None:\n                continue\n\n            # Nearest and steer\n            nearest = self._nearest(active_grid, x_rand)\n            if nearest is None:\n                continue\n            x_new = self._steer(nearest.position, x_rand, self.step_size)\n            if self._dist2(nearest.position, x_new) < 1e-10:\n                continue\n            if not self._in_bounds(x_new):\n                continue\n            if self._in_obs(x_new):\n                continue\n            if self._has_nearby(active_grid, x_new, dupe_radius):\n                continue\n\n            # Choose lowest-cost parent among neighbors (ties broken by smoother turn)\n            parent, new_cost = self._choose_parent(active_grid, x_new, nearest, parent_radius)\n            if parent is None:\n                continue\n\n            # Validate both checks before adding\n            if self._in_obs(x_new):\n                continue\n            if not self._edge_free(parent.position, x_new):\n                continue\n\n            # Insert node\n            new_node = Node(x_new, parent, new_cost)\n            parent.add_child(new_node)\n            active_tree.append(new_node)\n            nodes.append(new_node)\n            self._grid_insert(active_grid, new_node)\n\n            # Local rewiring\n            self._rewire(new_node, active_grid, rewire_radius)\n\n            # Try a short, validated bridge\n            bnode = self._best_bridge_candidate(passive_grid, new_node.position, self.connect_radius)\n            bridged = None\n            if bnode is not None and self._edge_free(bnode.position, new_node.position):\n                bridged = bnode\n            else:\n                # One assisted hop on passive tree if allowed\n                hops = 0\n                while bridged is None and hops < self.bridge_hops:\n                    hops += 1\n                    near_p = self._nearest(passive_grid, new_node.position)\n                    if near_p is None:\n                        break\n                    x_step = self._steer(near_p.position, new_node.position, self.step_size)\n                    if not self._in_bounds(x_step) or self._in_obs(x_step):\n                        break\n                    if self._has_nearby(passive_grid, x_step, dupe_radius):\n                        break\n                    # Select parent for the hop\n                    hop_parent, hop_cost = self._choose_parent(passive_grid, x_step, near_p, parent_radius)\n                    if hop_parent is None:\n                        break\n                    if not self._edge_free(hop_parent.position, x_step):\n                        break\n                    # Insert hop node in passive tree\n                    hop_node = Node(x_step, hop_parent, hop_cost)\n                    hop_parent.add_child(hop_node)\n                    passive_tree.append(hop_node)\n                    nodes.append(hop_node)\n                    self._grid_insert(passive_grid, hop_node)\n                    # Light rewiring on passive tree\n                    self._rewire(hop_node, passive_grid, rewire_radius)\n                    # Retry direct bridge\n                    if self._edge_free(hop_node.position, new_node.position):\n                        bridged = hop_node\n                        break\n\n            if bridged is not None:\n                path = self._extract_path(new_node, bridged, expand_a)\n                # Visibility prune then length-nonincreasing shortcuts\n                path = self._visibility_prune(path)\n                path = self._shortcut_nonincreasing(path, self.smooth_iters)\n                best_path = path\n                best_len = self._path_len(path)\n                edges = self._collect_edges(nodes)\n                return PlannerResult(True, best_path, nodes, edges)\n\n            # Optional online smoothing of incumbent (if already found, keep improving lightly)\n            if have_solution and best_path:\n                best_path = self._shortcut_nonincreasing(best_path, 4)\n                best_len = self._path_len(best_path)\n\n        # Finalize\n        edges = self._collect_edges(nodes)\n        if best_path:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # -------------------- RNG --------------------\n    def _seed_rng(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= (len(self.obstacles) + 17) * 2654435761\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # -------------------- Geometry --------------------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        d = d2 ** 0.5\n        if d <= step:\n            q = []\n            for i in range(self.dim):\n                v = b[i]\n                if v < 0.0:\n                    v = 0.0\n                if v > self.bounds[i]:\n                    v = self.bounds[i]\n                q.append(v)\n            return tuple(q)\n        r = step / d\n        q = []\n        for i in range(self.dim):\n            v = a[i] + (b[i] - a[i]) * r\n            if v < 0.0:\n                v = 0.0\n            if v > self.bounds[i]:\n                v = self.bounds[i]\n            q.append(v)\n        return tuple(q)\n\n    # -------------------- Obstacles --------------------\n    def _build_obs_index(self):\n        self.obs_cell = max(3.0, self.step_size * 1.3)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, ob in enumerate(self.obstacles):\n                x, y, z, w, h, d = ob\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, ob in enumerate(self.obstacles):\n                x, y, w, h = ob\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _in_obs(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy, cz))\n            if not b:\n                return False\n            px, py, pz = p\n            for idx in b:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            b = self.obs_grid.get((cx, cy))\n            if not b:\n                return False\n            px, py = p\n            for idx in b:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        arr = self.obs_grid.get((cx, cy, cz))\n                        if arr:\n                            for idx in arr:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    arr = self.obs_grid.get((cx, cy))\n                    if arr:\n                        for idx in arr:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # -------------------- Spatial hashing --------------------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _neighbors_within(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        out = []\n        r2 = radius * radius\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_of(pos)\n        best = None\n        bestd2 = 1e100\n        got = False\n        for r in range(0, self.ring_cap + 1):\n            cand = []\n            if self.is_3d:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if b:\n                                cand.extend(b)\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy))\n                        if b:\n                            cand.extend(b)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n                    got = True\n            if got:\n                return best\n        # Fallback random probe\n        buckets = list(grid.values())\n        tries = 0\n        while tries < 32 and buckets:\n            b = buckets[int(self._rand_range(0, len(buckets)))]\n            if b:\n                n = b[int(self._rand_range(0, len(b)))]\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            tries += 1\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        ns = self._neighbors_within(grid, pos, radius)\n        return len(ns) > 0\n\n    # -------------------- Parent selection and rewiring --------------------\n    def _choose_parent(self, grid, new_pos, fallback, radius):\n        cand = self._neighbors_within(grid, new_pos, radius)\n        if fallback not in cand:\n            cand.append(fallback)\n        best = None\n        best_cost = 1e100\n        best_smooth = -1.0\n        for n in cand:\n            if not self._edge_free(n.position, new_pos):\n                continue\n            c = n.cost + self._dist(n.position, new_pos)\n            if c + 1e-12 < best_cost:\n                best_cost = c\n                best = n\n                best_smooth = self._smooth_score(n, new_pos)\n            elif abs(c - best_cost) <= 1e-12:\n                sc = self._smooth_score(n, new_pos)\n                if sc > best_smooth:\n                    best_smooth = sc\n                    best = n\n        if best is None:\n            return None, None\n        return best, best_cost\n\n    def _smooth_score(self, parent, new_pos):\n        # Cosine of turn angle; higher is smoother. If no grandparent, neutral.\n        if parent.parent is None:\n            return 0.0\n        a = parent.parent.position\n        b = parent.position\n        c = new_pos\n        ab = tuple(b[i] - a[i] for i in range(self.dim))\n        bc = tuple(c[i] - b[i] for i in range(self.dim))\n        nab = self._dist(a, b)\n        nbc = self._dist(b, c)\n        if nab <= 1e-12 or nbc <= 1e-12:\n            return 0.0\n        dot = 0.0\n        for i in range(self.dim):\n            dot += ab[i] * bc[i]\n        cosang = dot / (nab * nbc)\n        if cosang < -1.0:\n            cosang = -1.0\n        if cosang > 1.0:\n            cosang = 1.0\n        return cosang\n\n    def _rewire(self, pivot, grid, radius):\n        neighbors = self._neighbors_within(grid, pivot.position, radius)\n        for nb in neighbors:\n            if nb is pivot or nb.parent is pivot:\n                continue\n            # prevent cycles: if nb is ancestor of pivot, skip\n            if self._is_ancestor(nb, pivot):\n                continue\n            if not self._edge_free(pivot.position, nb.position):\n                continue\n            new_c = pivot.cost + self._dist(pivot.position, nb.position)\n            if new_c + 1e-12 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    try:\n                        oldp.children.remove(nb)\n                    except:\n                        pass\n                pivot.add_child(nb)\n                nb.cost = new_c\n                self._propagate_cost(nb)\n\n    def _is_ancestor(self, node, potential_child):\n        cur = potential_child\n        while cur is not None:\n            if cur is node:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_cost(self, node):\n        # Update subtree costs after rewiring\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if newc + 1e-12 < ch.cost:\n                    ch.cost = newc\n                stack.append(ch)\n\n    # -------------------- Bridging and paths --------------------\n    def _best_bridge_candidate(self, grid_other, pos, radius):\n        cand = self._neighbors_within(grid_other, pos, radius)\n        if not cand:\n            return None\n        best = None\n        bestd2 = 1e100\n        for n in cand:\n            d2 = self._dist2(n.position, pos)\n            if d2 < bestd2:\n                bestd2 = d2\n                best = n\n        return best\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node, a_from_start):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if a_from_start:\n            return pa + list(reversed(pb))\n        else:\n            return pb + list(reversed(pa))\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(pruned[-1], path[j]):\n                    # Accept only if not longer than original subpath\n                    seg = self._dist(pruned[-1], path[j])\n                    walk = 0.0\n                    for k in range(i + 1, j + 1):\n                        walk += self._dist(path[k - 1], path[k])\n                    if seg + 1e-9 <= walk:\n                        pruned.append(path[j])\n                        i = j\n                        advanced = True\n                        break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _shortcut_nonincreasing(self, path, iters):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        bestL = self._path_len(pts)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                newL = self._path_len(new_pts)\n                if newL <= bestL + 1e-12:\n                    pts = new_pts\n                    bestL = newL\n        return pts\n\n    def _collect_edges(self, nodes):\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return edges\n\n    # -------------------- Sampling --------------------\n    def _sample(self, attractor, informed, best_len, c_min):\n        r = self._rand()\n        if informed and best_len < 1e99 and r < self.informed_bias:\n            p = self._informed_sample(self.start, self.goal, best_len * 1.01, c_min)\n            if p is not None and self._in_bounds(p) and not self._in_obs(p):\n                return p\n        if r < self.goal_bias:\n            p = attractor\n            return p if self._in_bounds(p) and not self._in_obs(p) else None\n        # Uniform\n        p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dim))\n        if self._in_bounds(p) and not self._in_obs(p):\n            return p\n        return None\n\n    def _informed_sample(self, f1, f2, c_best, c_min):\n        if not (c_best > c_min + 1e-9):\n            return None\n        center = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        a_vec = tuple(f2[i] - f1[i] for i in range(self.dim))\n        a_len = self._dist((0.0,) * self.dim, a_vec)\n        if a_len <= 1e-12:\n            return None\n        a_hat = tuple(a_vec[i] / a_len for i in range(self.dim))\n        r1 = 0.5 * c_best\n        r2_sq = max(0.0, 0.25 * (c_best * c_best - c_min * c_min))\n        if self.is_3d:\n            # Build orthonormal basis [a_hat, v, w]\n            # Simple fixed aux and cross to form basis\n            u = (1.0, 0.0, 0.0) if abs(a_hat[0]) < 0.9 else (0.0, 1.0, 0.0)\n            v = self._normalize(self._cross(a_hat, u))\n            w = self._cross(a_hat, v)\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                z = self._rand_range(-1.0, 1.0)\n                if x * x + y * y + z * z > 1.0:\n                    continue\n                px = r1 * x\n                r2 = (r2_sq ** 0.5)\n                py = r2 * y\n                pz = r2 * z\n                ex = center[0] + px * a_hat[0] + py * v[0] + pz * w[0]\n                ey = center[1] + px * a_hat[1] + py * v[1] + pz * w[1]\n                ez = center[2] + px * a_hat[2] + py * v[2] + pz * w[2]\n                p = (ex, ey, ez)\n                if self._in_bounds(p) and not self._in_obs(p):\n                    return p\n            return None\n        else:\n            # 2D ellipse with axes r1, r2\n            perp = (-a_hat[1], a_hat[0])\n            for _ in range(32):\n                x = self._rand_range(-1.0, 1.0)\n                y = self._rand_range(-1.0, 1.0)\n                if x * x + y * y > 1.0:\n                    continue\n                r2 = (r2_sq ** 0.5)\n                px = r1 * x\n                py = r2 * y\n                ex = center[0] + px * a_hat[0] + py * perp[0]\n                ey = center[1] + px * a_hat[1] + py * perp[1]\n                p = (ex, ey)\n                if self._in_bounds(p) and not self._in_obs(p):\n                    return p\n            return None\n\n    def _normalize(self, v):\n        n = self._dist((0.0,) * len(v), v)\n        if n <= 1e-12:\n            return v\n        return tuple(v[i] / n for i in range(len(v)))\n\n    def _cross(self, a, b):\n        return (a[1] * b[2] - a[2] * b[1],\n                a[2] * b[0] - a[0] * b[2],\n                a[0] * b[1] - a[1] * b[0])\n\n    # -------------------- Radii --------------------\n    def _adaptive_radius(self, n, base_mult):\n        # Decays with n; lower-bounded by 1.5*step_size\n        decay = (1.0 / (n ** (1.0 / max(2, self.dim))))\n        r = base_mult * self.step_size * 0.5 + self.space_extent * 0.05 * decay\n        return max(1.5 * self.step_size, r)",
        "objective": -40.1344,
        "time_improvement": 63.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1814.0,
        "node_improvement": 90.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.012674951553344726,
                "num_nodes_avg": 45.0,
                "path_length_avg": 153.35894992834636,
                "smoothness_avg": 0.03846541732582647,
                "success_improvement": 0.0,
                "time_improvement": 48.6246954693179,
                "node_improvement": 88.66784185343742,
                "length_improvement": 15.941529416200709,
                "smoothness_improvement": 502.0673101398352,
                "objective_score": 26.66266284121497
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.05657989978790283,
                "num_nodes_avg": 140.0,
                "path_length_avg": 233.83827885399037,
                "smoothness_avg": 0.11832797178444796,
                "success_improvement": 0.0,
                "time_improvement": 66.17078448590458,
                "node_improvement": 90.5932943626957,
                "length_improvement": 21.93805185687287,
                "smoothness_improvement": 2944.6639422069725,
                "objective_score": 47.73738617092995
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.013706851005554199,
                "num_nodes_avg": 79.0,
                "path_length_avg": 115.01768024557694,
                "smoothness_avg": 0.16483033391240323,
                "success_improvement": 0.0,
                "time_improvement": 72.84520158496316,
                "node_improvement": 89.95549904640814,
                "length_improvement": 23.61073333426484,
                "smoothness_improvement": 1996.6296808560942,
                "objective_score": 46.003148880328325
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "SAGE-Connect*: Simple Adaptive Grid Explorer with Informed Bidirectional Growth, Gentle Rewiring, and Fast Smoothing. It builds two trees from start and goal using a compact spatial hash, adaptive neighbor radius, LOS-aware stepping, lightweight k-best parenting, capped local rewiring, and a restrained greedy connect. Once a valid bridge is found, the path is shortcut-pruned and elastically smoothed with collision-aware line search for robust, short, and smooth trajectories.",
        "planning_mechanism": "Alternate expanding start/goal trees. Each iteration: draw a target (goal/segment/uniform; switch to informed-ellipse once a path exists), pick nearest via grid, steer with LOS-adaptive step, enforce node and edge collision checks, suppress duplicates, select a low-cost parent from nearby nodes, add the node, and locally rewire a few neighbors if the new route is cheaper (cycle-safe, edge-checked). Attempt a short greedy connect from the other tree; on success, assemble the bidirectional path, then apply shortcutting and visibility pruning followed by elastic midpoint smoothing before returning.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                self.children.pop(i)\n                break\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step=6.0,\n        connect_factor=1.9,\n        goal_bias=0.16,\n        line_bias=0.22,\n        informed_bias=0.45,\n        grid_cell_factor=1.6,\n        neighbor_radius_scale=3.0,\n        dupe_ratio=0.4,\n        rewire_cap=12,\n        connect_steps=12,\n        shortcut_attempts=90,\n        smooth_passes=6\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step)\n        self.connect_step = float(step * connect_factor)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.neighbor_radius_scale = float(neighbor_radius_scale)\n        self.dupe_ratio = float(dupe_ratio)\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(1, connect_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.smooth_passes = int(max(0, smooth_passes))\n        self._rng = 123456789\n        self._eindex = {}\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n        self._eindex = {}\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_rng()\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_ratio)\n\n        self._build_obs_bins()\n\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            self._edges_add(edges, n0, n1)\n            path = [self.start, self.goal]\n            path = self._finalize_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Trees and grids\n        Ta, Tb = [], []\n        Ga, Gb = {}, {}\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        Ta.append(start_root)\n        Tb.append(goal_root)\n        nodes.extend([start_root, goal_root])\n        self._grid_add(Ga, start_root)\n        self._grid_add(Gb, goal_root)\n\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            # Sample a common target for both directions for coherence\n            sample = self._sample_target(best_len)\n            if sample is None:\n                continue\n\n            # Expand from start side\n            res = self._expand_and_maybe_connect(Ta, Ga, Tb, Gb, sample, nodes, edges)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n            # Expand from goal side\n            res = self._expand_and_maybe_connect(Tb, Gb, Ta, Ga, sample, nodes, edges)\n            if res is not None:\n                path, L = res\n                best_len = L\n                final = self._finalize_path(path)\n                return PlannerResult(True, final, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # Core expansion and connection\n    def _expand_and_maybe_connect(self, Ta, Ga, Tb, Gb, target, nodes, edges):\n        na = self._nearest(Ga, target)\n        if na is None:\n            return None\n        q_new = self._steer_dynamic(na.position, target)\n        if (not self._in_bounds(q_new)) or self._point_blocked(q_new):\n            return None\n        if self._too_close(Ga, q_new, self.dupe_radius):\n            return None\n\n        parent = self._select_parent(Ga, q_new, na)\n        if parent is None:\n            return None\n        # Both checks before adding node/edge\n        if self._point_blocked(q_new) or (not self._edge_free(parent.position, q_new)):\n            return None\n\n        cost = parent.cost + self._dist(parent.position, q_new)\n        nn = Node(q_new, parent, cost)\n        parent.add_child(nn)\n        Ta.append(nn)\n        nodes.append(nn)\n        self._grid_add(Ga, nn)\n        self._edges_add(edges, parent, nn)\n\n        # Gentle local rewiring\n        if self.rewire_cap > 0:\n            self._rewire_neighbors(Ga, nn, edges, self.rewire_cap)\n\n        # Try greedy connect from the opposite tree\n        meet, ok = self._greedy_connect(Tb, Gb, nn.position, nodes, edges)\n        if ok:\n            pa = nn.path_to_root()\n            pb = meet.path_to_root()\n            # Determine which root belongs to which\n            if Ta[0].position == self.start:\n                # pa: start->..., pb: goal->...\n                path = pa + pb[-2::-1]\n            else:\n                # pa: goal->..., pb: start->...\n                path = pb + pa[-2::-1]\n            L = self._path_len(path)\n            return (self._dedup(path), L)\n        return None\n\n    # RNG\n    def _seed_rng(self):\n        s = 2166136261\n        for v in self.start + self.goal:\n            s ^= int(v * 10007 + 0.5) & 0xffffffff\n            s = (s * 16777619) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Sampling\n    def _sample_target(self, best_len):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            p = self._sample_informed_ellipse(self.start, self.goal, best_len * 1.01)\n            if p is not None and self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return self.goal\n        if r2 < self.goal_bias + self.line_bias:\n            t = self._rand()\n            if self.is3:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t,\n                     self.start[2] + (self.goal[2] - self.start[2]) * t)\n            else:\n                p = (self.start[0] + (self.goal[0] - self.start[0]) * t,\n                     self.start[1] + (self.goal[1] - self.start[1]) * t)\n            if self._in_bounds(p) and (not self._point_blocked(p)):\n                return p\n        # Uniform\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_informed_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(24):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if self._in_bounds(p) and (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and (not self._point_blocked(p)):\n                return p\n        return None\n\n    # Geometry helpers\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _lerp(self, a, b, t):\n        return tuple(a[i] + (b[i] - a[i]) * t for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= step:\n            return self._clamp(b)\n        r = step / d\n        return self._clamp(self._lerp(a, b, r))\n\n    def _steer_dynamic(self, a, b):\n        if self._edge_free(a, b):\n            d = self._dist(a, b)\n            step = self.connect_step if d > self.connect_step else d\n            return self._steer(a, b, step)\n        return self._steer(a, b, self.step)\n\n    # Node grid\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 3):\n            cand = self._grid_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n            if best is not None:\n                return best\n        # fallback\n        for lst in grid.values():\n            for n in lst:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    best = n\n                    bestd = d\n        return best\n\n    def _neighbors_within(self, grid, pos, radius, cap):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        seen = {}\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            i2 = id(n)\n                            if i2 in seen:\n                                continue\n                            seen[i2] = True\n                            d2 = 0.0\n                            p = n.position\n                            for i in range(self.dim):\n                                di = p[i] - pos[i]\n                                d2 += di * di\n                            if d2 <= r2:\n                                out.append(n)\n                                if len(out) >= cap:\n                                    return out\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        i2 = id(n)\n                        if i2 in seen:\n                            continue\n                        seen[i2] = True\n                        d2 = 0.0\n                        p = n.position\n                        for i in range(self.dim):\n                            di = p[i] - pos[i]\n                            d2 += di * di\n                        if d2 <= r2:\n                            out.append(n)\n                            if len(out) >= cap:\n                                return out\n        return out\n\n    def _adaptive_radius(self, n_nodes):\n        t = float(max(1, n_nodes))\n        base = 1.2 * self.step\n        extra = self.neighbor_radius_scale * self.step / ((1.0 + t) ** (1.0 / 3.0))\n        r = base + extra\n        if r < 1.05 * self.step:\n            r = 1.05 * self.step\n        return r\n\n    def _too_close(self, grid, pos, radius):\n        nb = self._neighbors_within(grid, pos, radius, 1)\n        return len(nb) > 0\n\n    # Parent selection\n    def _select_parent(self, grid, newp, fallback_near):\n        r = self._adaptive_radius(len(grid))\n        neigh = self._neighbors_within(grid, newp, r, 96)\n        best = fallback_near\n        best_cost = fallback_near.cost + self._dist(fallback_near.position, newp)\n        for n in neigh:\n            if n is fallback_near:\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost and self._edge_free(n.position, newp):\n                best = n\n                best_cost = c\n        return best\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _rewire_neighbors(self, grid, node, edges, cap):\n        r = self._adaptive_radius(len(grid))\n        neigh = self._neighbors_within(grid, node.position, r, 128)\n        cnt = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            if self._point_blocked(nb.position) or self._point_blocked(node.position):\n                continue\n            if not self._edge_free(node.position, nb.position):\n                continue\n            newc = node.cost + self._dist(node.position, nb.position)\n            if newc + 1e-12 < nb.cost:\n                self._reparent(nb, node, edges)\n                cnt += 1\n                if cnt >= cap:\n                    break\n\n    def _reparent(self, child, new_parent, edges):\n        if child is new_parent or child.parent is new_parent:\n            return\n        if self._point_blocked(child.position) or self._point_blocked(new_parent.position):\n            return\n        if not self._edge_free(new_parent.position, child.position):\n            return\n        old = child.parent\n        if old is not None:\n            old.remove_child(child)\n            self._edges_remove(edges, old, child)\n        new_parent.add_child(child)\n        self._edges_add(edges, new_parent, child)\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        stack = list(child.children)\n        while stack:\n            n = stack.pop()\n            n.cost = n.parent.cost + self._dist(n.parent.position, n.position)\n            for c in n.children:\n                stack.append(c)\n\n    # Greedy connect\n    def _greedy_connect(self, T, G, target_pos, nodes, edges):\n        cur = self._nearest(G, target_pos)\n        if cur is None:\n            return None, False\n        steps = 0\n        while steps < self.connect_steps:\n            # Visible? insert exact meeting point\n            if self._edge_free(cur.position, target_pos):\n                if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                    if not self._too_close(G, target_pos, 0.75 * self.dupe_radius):\n                        new_cost = cur.cost + self._dist(cur.position, target_pos)\n                        nn = Node(target_pos, cur, new_cost)\n                        if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                            return cur, True\n                        cur.add_child(nn)\n                        T.append(nn)\n                        nodes.append(nn)\n                        self._grid_add(G, nn)\n                        self._edges_add(edges, cur, nn)\n                        return nn, True\n                return cur, True\n            nxt = self._steer(cur.position, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_blocked(nxt):\n                return cur, False\n            if not self._edge_free(cur.position, nxt):\n                return cur, False\n            if self._too_close(G, nxt, 0.75 * self.dupe_radius):\n                return cur, False\n            new_cost = cur.cost + self._dist(cur.position, nxt)\n            nn = Node(nxt, cur, new_cost)\n            if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                return cur, False\n            cur.add_child(nn)\n            T.append(nn)\n            nodes.append(nn)\n            self._grid_add(G, nn)\n            self._edges_add(edges, cur, nn)\n            cur = nn\n            steps += 1\n        # Final visibility check\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_blocked(target_pos)):\n                if not self._too_close(G, target_pos, 0.75 * self.dupe_radius):\n                    new_cost = cur.cost + self._dist(cur.position, target_pos)\n                    nn = Node(target_pos, cur, new_cost)\n                    if self._point_blocked(nn.position) or (not self._edge_free(cur.position, nn.position)):\n                        return cur, True\n                    cur.add_child(nn)\n                    T.append(nn)\n                    nodes.append(nn)\n                    self._grid_add(G, nn)\n                    self._edges_add(edges, cur, nn)\n                    return nn, True\n            return cur, True\n        return cur, False\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(3.5, self.step * 1.6)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_intersect(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                ta = (mn - p) * inv\n                tb = (mx - p) * inv\n                if ta > tb:\n                    ta, tb = tb, ta\n                if ta > t0:\n                    t0 = ta\n                if tb < t1:\n                    t1 = tb\n                if t0 > t1:\n                    return False\n        return True\n\n    # Edge bookkeeping\n    def _edges_add(self, edges, parent, child):\n        key = (id(parent), id(child))\n        if key in self._eindex:\n            return\n        edges.append((parent, child))\n        self._eindex[key] = len(edges) - 1\n\n    def _edges_remove(self, edges, parent, child):\n        key = (id(parent), id(child))\n        idx = self._eindex.get(key)\n        if idx is None:\n            return\n        last = len(edges) - 1\n        if idx != last:\n            edges[idx] = edges[last]\n            pk, ck = id(edges[idx][0]), id(edges[idx][1])\n            self._eindex[(pk, ck)] = idx\n        edges.pop()\n        self._eindex.pop(key, None)\n\n    # Path utilities and smoothing\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        tries = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 2, len(cur)))\n            if j >= len(cur):\n                j = len(cur) - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cur = cur[:i + 1] + cur[j:]\n            tries += 1\n        return cur\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        n = len(pts)\n        while i < n - 1:\n            j = n - 1\n            jumped = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    jumped = True\n                    break\n                j -= 1\n            if not jumped:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _elastic_smooth(self, pts, passes):\n        if len(pts) < 3 or passes <= 0:\n            return pts[:]\n        cur = list(pts)\n        for _ in range(passes):\n            moved = False\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                b = cur[i]\n                c = cur[i + 1]\n                target = tuple(0.5 * (a[k] + c[k]) for k in range(self.dim))\n                t = 1.0\n                best = b\n                while t > 1e-3:\n                    cand = tuple(b[k] + (target[k] - b[k]) * t for k in range(self.dim))\n                    cand = self._clamp(cand)\n                    if (not self._point_blocked(cand)) and self._edge_free(a, cand) and self._edge_free(cand, c):\n                        best = cand\n                        break\n                    t *= 0.5\n                if best != b:\n                    cur[i] = best\n                    moved = True\n            if not moved:\n                break\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p1 = self._shortcut(path, self.shortcut_attempts)\n        p2 = self._visibility_prune(p1)\n        p3 = self._elastic_smooth(p2, self.smooth_passes)\n        return self._dedup(p3)",
        "objective": -47.53913,
        "time_improvement": 86.0,
        "length_improvement": 21.0,
        "smoothness_improvement": 1812.0,
        "node_improvement": 93.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.004579019546508789,
                "num_nodes_avg": 30.0,
                "path_length_avg": 146.96078572191126,
                "smoothness_avg": 0.03859037591406768,
                "success_improvement": 0.0,
                "time_improvement": 81.43988774523116,
                "node_improvement": 92.44522790229162,
                "length_improvement": 19.448464603147585,
                "smoothness_improvement": 504.0231833977275,
                "objective_score": 38.621161002446534
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.023305273056030272,
                "num_nodes_avg": 122.0,
                "path_length_avg": 229.66193713526982,
                "smoothness_avg": 0.11885248032537557,
                "success_improvement": 0.0,
                "time_improvement": 86.065738755588,
                "node_improvement": 91.80272794463482,
                "length_improvement": 23.332234931912975,
                "smoothness_improvement": 2958.1599247532718,
                "objective_score": 54.609862209590545
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.004154682159423828,
                "num_nodes_avg": 32.0,
                "path_length_avg": 120.49632735979439,
                "smoothness_avg": 0.1630888303105967,
                "success_improvement": 0.0,
                "time_improvement": 91.76911192279043,
                "node_improvement": 95.93134138588684,
                "length_improvement": 19.972076786142434,
                "smoothness_improvement": 1974.4778835855395,
                "objective_score": 49.38636906645029
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e1",
        "algorithm_description": "LITE-Bridge*: Lazy-Informed Two-Tree Expansion with Branch-and-Bound Bridge. This planner couples hashed-nearest queries and obstacle-bucket collision gating with adaptive corridor/informed sampling, duplicate suppression, local RRT* rewiring, and an anytime cost bound for pruning. A transactional bridge attempts to connect the trees with validated steps and commits only on success. A light three-stage refiner (visibility, bounded shortcut, elastic relax) returns short, smooth, collision-free paths quickly.",
        "planning_mechanism": "Alternate growing two sparse trees in mini-batches. For each sample, steer from the best local parent, enforce node and edge collision, and rewire cheaper neighbors. Maintain an incumbent path-length bound to prune expansions whose g+h exceeds the best. After each insertion, attempt a transactional multi-step bridge toward the opposite tree; commit only if a full, validated link is found. On first connection, extract and lightly smooth the path and return.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        batch=3,\n        step_size=6.0,\n        connect_step_factor=2.0,\n        goal_bias=0.18,\n        tube_bias=0.32,\n        informed_bias=0.50,\n        neighbor_factor=3.0,\n        k_parent=8,\n        k_rewire=8,\n        connect_hops=5,\n        dupe_factor=0.5,\n        shortcut_attempts=60,\n        relax_passes=1,\n        bnb_margin=1.02\n    ):\n        self.max_iter = int(max_iter)\n        self.batch = int(max(1, batch))\n        self.step = float(step_size)\n        self.connect_step_factor = float(connect_step_factor)\n        self.goal_bias = float(goal_bias)\n        self.tube_bias = float(tube_bias)\n        self.informed_bias = float(informed_bias)\n        self.neighbor_factor = float(neighbor_factor)\n        self.k_parent = int(max(1, k_parent))\n        self.k_rewire = int(max(0, k_rewire))\n        self.connect_hops = int(max(1, connect_hops))\n        self.dupe_factor = float(dupe_factor)\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.relax_passes = int(max(0, relax_passes))\n        self.bnb_margin = float(max(1.0, bnb_margin))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # Basic validation\n        if not self._inside(self.start) or not self._inside(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed()\n\n        # Build obstacle buckets for filtered collision checks\n        self._build_obstacle_buckets()\n\n        if self._in_obstacle(self.start) or self._in_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Direct path early exit\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            path = [self.start, self.goal]\n            path = self._refine(path)\n            return PlannerResult(True, path, [n0, n1], [(n0, n1)])\n\n        # Planner parameters\n        self.grid_cell = max(1.0, self.step * 1.6)\n        self.neigh_radius = max(self.step * 1.25, self.step * self.neighbor_factor)\n        self.dupe_radius = max(0.5, self.step * self.dupe_factor)\n        self.connect_step = max(self.step, self.step * self.connect_step_factor)\n\n        # Trees and spatial hashes\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [a_root], [b_root]\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, a_root)\n        self._grid_add(grid_b, b_root)\n\n        nodes = [a_root, b_root]\n        edges = []\n        incumbent_len = None  # anytime bound\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            tree = tree_a if side_a else tree_b\n            other_tree = tree_b if side_a else tree_a\n            grid = grid_a if side_a else grid_b\n            other_grid = grid_b if side_a else grid_a\n            attractor = self.goal if side_a else self.start\n            to_goal = side_a\n\n            for _ in range(self.batch):\n                qrand = self._sample(attractor, incumbent_len)\n                if qrand is None:\n                    continue\n\n                anchor = self._nearest_exact(grid, qrand)\n                if anchor is None:\n                    continue\n\n                qnew = self._steer(anchor.position, qrand, self.step)\n                if not self._inside(qnew):\n                    continue\n                if self._in_obstacle(qnew):\n                    continue\n                if not self._edge_free(anchor.position, qnew):\n                    continue\n                if self._has_nearby(grid, qnew, self.dupe_radius):\n                    continue\n\n                # Branch-and-bound pruning with heuristic to target root\n                g_anchor = anchor.cost + self._dist(anchor.position, qnew)\n                h = self._dist(qnew, self.goal if to_goal else self.start)\n                if incumbent_len is not None and (g_anchor + h) >= incumbent_len * self.bnb_margin:\n                    continue\n\n                # RRT* local best parent among neighbors\n                parent = anchor\n                best_cost = g_anchor\n                neigh = self._neighbors_within(grid, qnew, self.neigh_radius)\n                if neigh:\n                    # choose up to k nearest by Euclidean\n                    neigh = sorted(neigh, key=lambda n: self._dist2(n.position, qnew))[:self.k_parent]\n                    for nb in neigh:\n                        cand_cost = nb.cost + self._dist(nb.position, qnew)\n                        if cand_cost + 1e-12 < best_cost and self._edge_free(nb.position, qnew):\n                            parent = nb\n                            best_cost = cand_cost\n\n                # Final checks before insertion\n                if self._in_obstacle(qnew):\n                    continue\n                if not self._edge_free(parent.position, qnew):\n                    continue\n\n                nn = Node(qnew, parent, best_cost)\n                parent.add_child(nn)\n                tree.append(nn)\n                nodes.append(nn)\n                edges.append((parent, nn))\n                self._grid_add(grid, nn)\n\n                # Local rewiring\n                if self.k_rewire > 0:\n                    self._rewire(nn, grid, edges)\n\n                # Bridge transaction toward opposite tree\n                meet = self._try_bridge(other_tree, other_grid, nn, incumbent_len)\n                if meet is not None:\n                    # Extract path via meeting nodes\n                    path = self._assemble_path(nn, meet, to_goal)\n                    L = self._path_len(path)\n                    if incumbent_len is None or L + 1e-9 < incumbent_len:\n                        incumbent_len = L\n                    # Refine and return\n                    path = self._refine(path)\n                    return PlannerResult(True, path, tree_a + tree_b, edges)\n\n        return PlannerResult(False, [], tree_a + tree_b, edges)\n\n    # ---------------- RNG ----------------\n    def _seed(self):\n        s = 2166136261\n        for v in self.start + self.goal:\n            s ^= int(v * 1315423911) & 0xffffffff\n            s = (s * 16777619) & 0xffffffff\n        s ^= (len(self.obstacles) + 31) * 2654435761 & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------------- Geometry ----------------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _inside(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        d = d2 ** 0.5\n        if d <= step:\n            return tuple(min(max(b[i], 0.0), self.bounds[i]) for i in range(self.dim))\n        r = step / d\n        return tuple(min(max(a[i] + (b[i] - a[i]) * r, 0.0), self.bounds[i]) for i in range(self.dim))\n\n    # ---------------- Spatial hashing ----------------\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.grid_cell), int(p[1] // self.grid_cell), int(p[2] // self.grid_cell))\n        else:\n            return (int(p[0] // self.grid_cell), int(p[1] // self.grid_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_all_nodes(self, grid):\n        out = []\n        for b in grid.values():\n            out.extend(b)\n        return out\n\n    def _ring_nodes(self, grid, key, r):\n        out = []\n        if self.is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_exact(self, grid, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        count = 0\n        r = 0\n        # Expand rings until enough candidates gathered\n        while count < 12 and r < 6:\n            cand = self._ring_nodes(grid, key, r)\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n            count = len(cand)\n            r += 1\n        if best is not None:\n            return best\n        # fallback: scan all nodes\n        for bucket in grid.values():\n            for n in bucket:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_within(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.grid_cell) + 1\n        r2 = radius * radius\n        out = []\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.grid_cell) + 1\n        r2 = radius * radius\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._dist2(n.position, pos) <= r2:\n                                return True\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._dist2(n.position, pos) <= r2:\n                            return True\n        return False\n\n    # ---------------- Obstacles and collision ----------------\n    def _build_obstacle_buckets(self):\n        self.obs_cell = max(4.0, self.step * 1.8)\n        self.obuckets = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obuckets.get(key)\n                            if b is None:\n                                self.obuckets[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obuckets.get(key)\n                        if b is None:\n                            self.obuckets[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _in_obstacle(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obuckets.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obuckets.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mn = (min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            iz0 = int(max(0.0, mn[2]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mx[2]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bkt = self.obuckets.get((i, j, k))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mn = (min(a[0], b[0]), min(a[1], b[1]))\n            mx = (max(a[0], b[0]), max(a[1], b[1]))\n            ix0 = int(max(0.0, mn[0]) // self.obs_cell)\n            iy0 = int(max(0.0, mn[1]) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mx[0]) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mx[1]) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bkt = self.obuckets.get((i, j))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_aabb_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_aabb_hit(self, p0, p1, bmin, bmax):\n        t0 = 0.0\n        t1 = 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # ---------------- Rewiring ----------------\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _remove_edge(self, edges, p, c):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is p and edges[i][1] is c:\n                del edges[i]\n                break\n\n    def _propagate_cost_delta(self, node, delta):\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            for ch in u.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    def _rewire(self, nn, grid, edges):\n        neigh = self._neighbors_within(grid, nn.position, self.neigh_radius)\n        if not neigh:\n            return\n        neigh = sorted(neigh, key=lambda n: self._dist2(n.position, nn.position))[:self.k_rewire]\n        for nb in neigh:\n            if nb is nn or nb is nn.parent:\n                continue\n            if self._is_ancestor(nb, nn):\n                continue\n            if not self._edge_free(nn.position, nb.position):\n                continue\n            cand = nn.cost + self._dist(nn.position, nb.position)\n            if cand + 1e-9 < nb.cost:\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, oldp, nb)\n                nn.add_child(nb)\n                edges.append((nn, nb))\n                delta = cand - nb.cost\n                nb.cost = cand\n                self._propagate_cost_delta(nb, delta)\n\n    # ---------------- Sampling ----------------\n    def _sample(self, attractor, incumbent_len):\n        r = self._rand()\n        # Informed ellipse sampling when we have an incumbent\n        if incumbent_len is not None and r < self.informed_bias:\n            p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.01)\n            if p is not None and self._inside(p) and not self._in_obstacle(p):\n                return p\n\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            p = attractor\n        elif r2 < self.goal_bias + self.tube_bias:\n            t = self._rand()\n            base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n            span = max(self.step, 0.05 * self._dist(self.start, self.goal))\n            if self.is3:\n                jx = self._rand_range(-span, span)\n                jy = self._rand_range(-span, span)\n                jz = self._rand_range(-span, span)\n                p = (base[0] + jx, base[1] + jy, base[2] + jz)\n            else:\n                jx = self._rand_range(-span, span)\n                jy = self._rand_range(-span, span)\n                p = (base[0] + jx, base[1] + jy)\n        else:\n            if self.is3:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n        if self._inside(p) and not self._in_obstacle(p):\n            return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        d = tuple(f2[i] - f1[i] for i in range(self.dim))\n        dist_fg = self._dist(f1, f2)\n        if dist_fg < 1e-12:\n            # small box around c\n            ext = [max(self.step, 0.5 * max_sum)] * self.dim\n            for _ in range(24):\n                p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dim))\n                if self._inside(p) and not self._in_obstacle(p):\n                    return p\n            return None\n        a = 0.5 * max_sum\n        b = max(self.step, (a * a - (0.5 * dist_fg) ** 2) ** 0.5)\n        u = tuple(d[i] / dist_fg for i in range(self.dim))\n        if self.is3:\n            # Build orthonormal basis u, v, w\n            ax = (1.0, 0.0, 0.0)\n            if abs(u[0]) > 0.9:\n                ax = (0.0, 1.0, 0.0)\n            v = self._normalize(self._cross(u, ax))\n            if self._norm(v) < 1e-12:\n                ax = (0.0, 0.0, 1.0)\n                v = self._normalize(self._cross(u, ax))\n            w = self._cross(u, v)\n            for _ in range(32):\n                rx = self._rand_range(-1.0, 1.0)\n                ry = self._rand_range(-1.0, 1.0)\n                rz = self._rand_range(-1.0, 1.0)\n                if rx * rx + ry * ry + rz * rz > 1.0:\n                    continue\n                off = (\n                    a * rx * u[0] + b * ry * v[0] + b * rz * w[0],\n                    a * rx * u[1] + b * ry * v[1] + b * rz * w[1],\n                    a * rx * u[2] + b * ry * v[2] + b * rz * w[2],\n                )\n                p = (c[0] + off[0], c[1] + off[1], c[2] + off[2])\n                if self._inside(p) and not self._in_obstacle(p):\n                    return p\n        else:\n            v = (-u[1], u[0])\n            for _ in range(32):\n                rx = self._rand_range(-1.0, 1.0)\n                ry = self._rand_range(-1.0, 1.0)\n                if rx * rx + ry * ry > 1.0:\n                    continue\n                off = (a * rx * u[0] + b * ry * v[0], a * rx * u[1] + b * ry * v[1])\n                p = (c[0] + off[0], c[1] + off[1])\n                if self._inside(p) and not self._in_obstacle(p):\n                    return p\n        return None\n\n    def _cross(self, a, b):\n        return (\n            a[1] * b[2] - a[2] * b[1],\n            a[2] * b[0] - a[0] * b[2],\n            a[0] * b[1] - a[1] * b[0],\n        )\n\n    def _norm(self, v):\n        s = 0.0\n        for i in range(len(v)):\n            s += v[i] * v[i]\n        return s ** 0.5\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return tuple(0.0 for _ in v)\n        return tuple(v[i] / n for i in range(len(v)))\n\n    # ---------------- Bridge and path assembly ----------------\n    def _try_bridge(self, other_tree, other_grid, new_node, incumbent_len):\n        # nearest on other tree\n        near = self._nearest_exact(other_grid, new_node.position)\n        if near is None:\n            return None\n        # Direct link\n        if not self._has_nearby(other_grid, new_node.position, self.dupe_radius):\n            if self._edge_free(near.position, new_node.position):\n                return near\n        # Transactional multi-step attempt\n        cur = near\n        chain_pos = []\n        hops = 0\n        while hops < self.connect_hops:\n            if self._dist(cur.position, new_node.position) <= self.connect_step and self._edge_free(cur.position, new_node.position):\n                # commit chain onto other tree\n                meet = cur\n                for p in chain_pos:\n                    nn = Node(p, meet, meet.cost + self._dist(meet.position, p))\n                    meet.add_child(nn)\n                    other_tree.append(nn)\n                    self._grid_add(other_grid, nn)\n                    meet = nn\n                return meet\n            nxt = self._steer(cur.position, new_node.position, self.connect_step)\n            if not self._inside(nxt):\n                break\n            if self._in_obstacle(nxt):\n                break\n            if not self._edge_free(cur.position, nxt):\n                break\n            if self._has_nearby(other_grid, nxt, self.dupe_radius):\n                break\n            # optional loose bound: if we have incumbent, prune hopeless chains\n            if incumbent_len is not None:\n                # optimistic total via new_node\n                optimistic = cur.cost + self._dist(cur.position, nxt) + self._dist(nxt, new_node.position)\n                # plus remaining to the opposite root heuristic\n                optimistic += new_node.cost + self._dist(new_node.position, self.goal if new_node is not None else self.goal)\n                if optimistic >= incumbent_len * self.bnb_margin:\n                    break\n            chain_pos.append(nxt)\n            # advance virtual cur\n            tmp_cost = cur.cost + self._dist(cur.position, nxt)\n            cur = type(\"Tmp\", (), {\"position\": nxt, \"cost\": tmp_cost})\n            hops += 1\n        return None\n\n    def _path_to_root(self, node):\n        out = []\n        cur = node\n        while cur is not None:\n            out.append(cur.position)\n            cur = cur.parent\n        return out[::-1]\n\n    def _assemble_path(self, a_node, b_node, a_forward=True):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return (pa + pb[::-1]) if a_forward else (pb + pa[::-1])\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # ---------------- Path refinement ----------------\n    def _visibility(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            progressed = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    progressed = True\n                    break\n                j -= 1\n            if not progressed:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        stall = 0\n        while tries < attempts and len(cur) > 2:\n            n = len(cur)\n            i = int(self._rand_range(0, n - 2))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a, b = cur[i], cur[j]\n            if self._edge_free(a, b):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-9 <= bestL:\n                    cur = cand\n                    bestL = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            tries += 1\n            if stall > 24:\n                break\n        return cur\n\n    def _elastic(self, pts, lam=0.2, passes=1):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        for _ in range(passes):\n            for i in range(1, len(cur) - 1):\n                a = cur[i - 1]\n                c = cur[i + 1]\n                mid = tuple((a[j] + c[j]) * 0.5 for j in range(self.dim))\n                prop = tuple(cur[i][j] + lam * (mid[j] - cur[i][j]) for j in range(self.dim))\n                if not self._inside(prop):\n                    continue\n                if self._in_obstacle(prop):\n                    continue\n                if self._edge_free(a, prop) and self._edge_free(prop, c):\n                    cur[i] = prop\n        return cur\n\n    def _refine(self, path):\n        if not path:\n            return []\n        p0 = self._visibility(path)\n        p1 = self._shortcut(p0, self.shortcut_attempts)\n        p2 = self._elastic(p1, lam=0.22, passes=self.relax_passes)\n        return p2",
        "objective": -28.6108,
        "time_improvement": 27.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1687.0,
        "node_improvement": 84.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.02648768424987793,
                "num_nodes_avg": 68.0,
                "path_length_avg": 154.10282715542505,
                "smoothness_avg": 0.06309786517191299,
                "success_improvement": 0.0,
                "time_improvement": -7.362370492921746,
                "node_improvement": 82.87584991186098,
                "length_improvement": 15.533798520549901,
                "smoothness_improvement": 887.6186091477274,
                "objective_score": 11.549661010192054
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.048912215232849124,
                "num_nodes_avg": 137.0,
                "path_length_avg": 227.8835338892221,
                "smoothness_avg": 0.08674519443864058,
                "success_improvement": 0.0,
                "time_improvement": 70.75530574308914,
                "node_improvement": 90.79486662635222,
                "length_improvement": 23.925917123942924,
                "smoothness_improvement": 2132.016332944314,
                "objective_score": 46.24222366201407
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.04112732410430908,
                "num_nodes_avg": 176.0,
                "path_length_avg": 119.74291228670313,
                "smoothness_avg": 0.16824591411689338,
                "success_improvement": 0.0,
                "time_improvement": 18.522190476145497,
                "node_improvement": 77.62237762237763,
                "length_improvement": 20.472459203919165,
                "smoothness_improvement": 2040.075608945303,
                "objective_score": 28.040510709921662
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "CIRR3-Connect: Adaptive-Angle Informed RRT*-Connect with k-nearest parenting, dynamic rewiring radius, order-preserving LRU edge cache, adaptive step-and-connect commit, and prioritized long-span shortcutting. It reduces redundant checks and tree bloat, avoids over-pruning near the meeting area, prefers low-cost/low-turn parents, and accelerates bridging while preserving robustness.",
        "planning_mechanism": "Mechanism: Grow the smaller of two trees each iteration. Draw a goal/corridor/informed-ellipse sample, steer with an adaptive step, and choose the best-cost parent among k-nearest LOS neighbors plus ancestor-LOS candidates with an angle penalty. Insert once after a single edge check, then boundedly rewire nearby nodes with correct cost propagation and a dynamic radius. Try a connect-style extension from the opposite tree that only commits successful steps; when a collision-free bridge exists, extract and aggressively shortcut the path using the same cached edge tests and return.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4500,\n        step_size=7.0,\n        goal_bias=0.2,\n        corridor_bias=0.3,\n        informed_bias=0.4,\n        beam_k=3,\n        neighbor_cap=32,\n        k_nearest=24,\n        min_sep_ratio=0.22,\n        grid_cell_factor=0.9,\n        base_rewire_factor=2.0,\n        connect_steps=50,\n        edge_cache_capacity=60000,\n        edge_cache_quant_factor=0.08,\n        shortcut_attempts=140\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.beam_k = beam_k\n        self.neighbor_cap = neighbor_cap\n        self.k_nearest = k_nearest\n        self.min_sep_ratio = min_sep_ratio\n        self.grid_cell_factor = grid_cell_factor\n        self.base_rewire_factor = base_rewire_factor\n        self.connect_steps = connect_steps\n        self.edge_cache_capacity = edge_cache_capacity\n        self.edge_cache_quant_factor = edge_cache_quant_factor\n        self.shortcut_attempts = shortcut_attempts\n        self._rnd_state = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n\n        # Spatial parameters\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_ratio)\n        self.ecache_quant = max(0.1, self.step_size * self.edge_cache_quant_factor)\n\n        # Build obstacle grid once\n        self._build_obstacle_grid()\n\n        nodes = []\n        edges = []\n\n        # Start/goal collision checks\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Edge cache: order-preserving LRU (dict reinsertion), simple prune on overflow\n        self.ecache = {}\n\n        # Trivial connection\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # Roots\n        ra = Node(self.start, None, 0.0)\n        rb = Node(self.goal, None, 0.0)\n        nodes.extend([ra, rb])\n\n        tree_a = [ra]\n        tree_b = [rb]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, ra)\n        self._grid_insert(grid_b, rb)\n\n        best_len = None\n        stagnation = 0\n\n        for it in range(self.max_iter):\n            # Balance: grow smaller tree\n            if len(tree_a) <= len(tree_b):\n                active_tree, active_grid, passive_tree, passive_grid, attractor = tree_a, grid_a, tree_b, grid_b, self.goal\n            else:\n                active_tree, active_grid, passive_tree, passive_grid, attractor = tree_b, grid_b, tree_a, grid_a, self.start\n\n            made_progress = False\n            local_beam = self.beam_k if stagnation < 20 else min(self.beam_k + 1, 5)\n\n            for _ in range(local_beam):\n                s = self._guided_sample(attractor, best_len)\n                if s is None:\n                    continue\n\n                nnear = self._nearest_in_grid(active_grid, s, max_ring=10)\n                if nnear is None:\n                    continue\n\n                # Adaptive step trials (larger to smaller)\n                step_try = self.step_size\n                q_new = None\n                for _t in range(3):\n                    q_cand = self._steer(nnear.position, s, step_try)\n                    if not self._within_bounds(q_cand):\n                        step_try *= 0.7\n                        continue\n                    if self._point_in_obstacles(q_cand):\n                        step_try *= 0.7\n                        continue\n                    # Enforce spacing only within the active tree to not block meeting regions\n                    if self._has_nearby(active_grid, q_cand, self.min_sep):\n                        step_try *= 0.7\n                        continue\n                    q_new = q_cand\n                    break\n                if q_new is None:\n                    continue\n\n                # Best parent: k-nearest within dynamic radius + ancestor-LOS lookback with angle penalty\n                rewire_radius = self._dynamic_rewire_radius(len(active_tree))\n                parent = self._best_parent_knearest(active_grid, q_new, k=self.k_nearest, radius=rewire_radius)\n                if parent is None:\n                    continue\n\n                # Single edge check before insertion\n                if not self._edge_free(parent.position, q_new):\n                    continue\n\n                new_cost = parent.cost + self._dist(parent.position, q_new)\n                new_node = Node(q_new, parent, new_cost)\n                if self._point_in_obstacles(new_node.position):\n                    continue\n                parent.add_child(new_node)\n                active_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((parent, new_node))\n                self._grid_insert(active_grid, new_node)\n                made_progress = True\n\n                # Local bounded rewiring with correct cost propagation\n                neigh = self._nearby_nodes(active_grid, new_node.position, rewire_radius)\n                # Prefer nearest neighbors\n                if len(neigh) > self.neighbor_cap:\n                    neigh = self._k_nearest_nodes(neigh, new_node.position, self.neighbor_cap)\n                for nb in neigh:\n                    if nb is parent or nb is new_node:\n                        continue\n                    if self._is_ancestor(new_node, nb):\n                        continue\n                    # Candidate through new_node\n                    d = self._dist(new_node.position, nb.position)\n                    cand_cost = new_node.cost + d\n                    if cand_cost + 1e-9 < nb.cost and self._edge_free(new_node.position, nb.position):\n                        old_parent = nb.parent\n                        if old_parent is not None:\n                            try:\n                                old_parent.children.remove(nb)\n                            except:\n                                pass\n                            self._remove_edge(edges, (old_parent, nb))\n                        new_node.add_child(nb)\n                        delta = cand_cost - nb.cost\n                        nb.cost = cand_cost\n                        edges.append((new_node, nb))\n                        self._propagate_children_cost(nb, delta)\n\n                # Try connect from passive tree, committing only successful steps\n                meet = self._connect_commit(passive_tree, passive_grid, new_node.position, nodes, edges)\n                if meet is not None and self._edge_free(meet.position, new_node.position):\n                    # Found a bridge\n                    path = self._extract_path(new_node, meet)\n                    best_len = self._path_len(path)\n                    path = self._shortcut(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n            stagnation = 0 if made_progress else (stagnation + 1)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # PRNG utilities\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 977 + 0.5)) & 0x7fffffff\n        s ^= (len(self.obstacles) + 17) * 2654435761\n        self._rnd_state = (s ^ 0x9E3779B9) & 0x7fffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 123456789\n\n    def _rand(self):\n        self._rnd_state = (1664525 * self._rnd_state + 1013904223) & 0x7fffffff\n        return self._rnd_state / 2147483647.0\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        q = []\n        for i in range(self.dims):\n            v = p[i]\n            if v < 0.0:\n                v = 0.0\n            elif v > self.bounds[i]:\n                v = self.bounds[i]\n            q.append(v)\n        return tuple(q)\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return tuple(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Node grid\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        cand = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        return cand\n\n    def _nearest_in_grid(self, grid, pos, max_ring=10):\n        key = self._cell_of(pos)\n        best = None\n        bestd2 = 1e100\n        for r in range(0, max_ring + 1):\n            cand = self._ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd2:\n                    bestd2 = d2\n                    best = n\n            if best is not None:\n                return best\n        # Fallback: random bucket\n        buckets = list(grid.values())\n        if not buckets:\n            return None\n        bucket = buckets[int(self._rand() * len(buckets)) % len(buckets)]\n        if not bucket:\n            return None\n        return bucket[int(self._rand() * len(bucket)) % len(bucket)]\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        rc = int(radius // self.cell_size) + 1\n        r2 = radius * radius\n        cand = self._ring_collect(grid, key, rc)\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                return True\n        return False\n\n    def _nearby_nodes(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        rc = int(radius // self.cell_size) + 1\n        r2 = radius * radius\n        cand = self._ring_collect(grid, key, rc)\n        out = []\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _k_nearest_nodes(self, nodes, pos, k):\n        # Return up to k nearest nodes by squared distance\n        pairs = []\n        for n in nodes:\n            pairs.append((self._dist2(n.position, pos), n))\n        # Partial sort by picking smallest k\n        if len(pairs) <= k:\n            pairs.sort(key=lambda x: x[0])\n            return [n for _, n in pairs]\n        # Simple selection for k smallest\n        for i in range(k):\n            min_j = i\n            for j in range(i + 1, len(pairs)):\n                if pairs[j][0] < pairs[min_j][0]:\n                    min_j = j\n            pairs[i], pairs[min_j] = pairs[min_j], pairs[i]\n        pairs = pairs[:k]\n        pairs.sort(key=lambda x: x[0])\n        return [n for _, n in pairs]\n\n    # Obstacles\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            key = (cx, cy, cz)\n                            bucket = self.obs_grid.get(key)\n                            if bucket is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                bucket.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        key = (cx, cy)\n                        bucket = self.obs_grid.get(key)\n                        if bucket is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    # Edge cache + collision\n    def _edge_key(self, a, b):\n        # Light rounding to reduce false sharing\n        qa = tuple(int(a[i] / self.ecache_quant) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.ecache_quant) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        if key in self.ecache:\n            val = self.ecache[key]\n            # Reinsertion to approximate LRU\n            del self.ecache[key]\n            self.ecache[key] = val\n            return val\n        free = not self._segment_hits_obstacle(a, b)\n        self.ecache[key] = free\n        if len(self.ecache) > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        # Remove oldest entries to ~90% capacity\n        target = int(self.edge_cache_capacity * 0.9)\n        to_remove = len(self.ecache) - target\n        if to_remove <= 0:\n            return\n        keys = list(self.ecache.keys())\n        # Oldest first\n        for i in range(to_remove):\n            k = keys[i]\n            if k in self.ecache:\n                del self.ecache[k]\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bucket = self.obs_grid.get((cx, cy, cz))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bucket = self.obs_grid.get((cx, cy))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        dims = len(bmin)\n        for i in range(dims):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Parenting with angle-aware scoring\n    def _best_parent_knearest(self, grid, new_pos, k, radius):\n        candidates = self._nearby_nodes(grid, new_pos, radius)\n        if not candidates:\n            # fallback to nearest in grid\n            nn = self._nearest_in_grid(grid, new_pos, max_ring=12)\n            if nn is None:\n                return None\n            candidates = [nn]\n        if len(candidates) > k:\n            candidates = self._k_nearest_nodes(candidates, new_pos, k)\n        best = None\n        best_score = 1e100\n        for n in candidates:\n            if not self._edge_free(n.position, new_pos):\n                continue\n            base_cost = n.cost + self._dist(n.position, new_pos)\n            # Angle penalty to prefer smoother joins\n            penalty = self._angle_penalty(n, new_pos)\n            score = base_cost + penalty\n            if score < best_score:\n                best_score = score\n                best = n\n        if best is None:\n            # Try ancestor LOS lookback on nearest candidate to allow long hops\n            nn = self._nearest_in_grid(grid, new_pos, max_ring=12)\n            if nn is None:\n                return None\n            look = self._ancestor_los_best(nn, new_pos)\n            return look\n        return best\n\n    def _angle_penalty(self, parent_node, new_pos):\n        if parent_node is None or parent_node.parent is None:\n            return 0.0\n        px, py = parent_node.position[0], parent_node.position[1]\n        ppx, ppy = parent_node.parent.position[0], parent_node.parent.position[1]\n        vx0 = px - ppx\n        vy0 = py - ppy\n        vx1 = new_pos[0] - px\n        vy1 = new_pos[1] - py\n        d0 = vx0 * vx0 + vy0 * vy0\n        d1 = vx1 * vx1 + vy1 * vy1\n        if d0 <= 1e-12 or d1 <= 1e-12:\n            return 0.0\n        dot = vx0 * vx1 + vy0 * vy1\n        cos = dot / ((d0 ** 0.5) * (d1 ** 0.5))\n        if cos > 1.0:\n            cos = 1.0\n        if cos < -1.0:\n            cos = -1.0\n        # penalty grows as turn becomes sharper (cos -> -1)\n        return 0.2 * (1.0 - cos) * self.step_size\n\n    def _ancestor_los_best(self, node, new_pos, depth=5):\n        best = None\n        best_cost = 1e100\n        cur = node\n        dnew = None\n        while cur is not None and depth > 0:\n            depth -= 1\n            if self._edge_free(cur.position, new_pos):\n                c = cur.cost + (self._dist(cur.position, new_pos) if dnew is None else dnew)\n                if c < best_cost:\n                    best_cost = c\n                    best = cur\n            cur = cur.parent\n        return best\n\n    def _is_ancestor(self, node, candidate_ancestor):\n        cur = node.parent\n        while cur is not None:\n            if cur is candidate_ancestor:\n                return True\n            cur = cur.parent\n        return False\n\n    def _propagate_children_cost(self, node, delta):\n        stack = list(node.children)\n        while stack:\n            n = stack.pop()\n            n.cost += delta\n            for c in n.children:\n                stack.append(c)\n\n    def _remove_edge(self, edges, pair):\n        for i in range(len(edges) - 1, -1, -1):\n            if edges[i][0] is pair[0] and edges[i][1] is pair[1]:\n                del edges[i]\n                break\n\n    # Dynamic rewiring radius\n    def _dynamic_rewire_radius(self, n_nodes):\n        # Increase slowly with tree size, lower bounded by base factor\n        return max(self.step_size * self.base_rewire_factor, self.step_size * (1.0 + 0.35 * (n_nodes ** 0.5) / 20.0))\n\n    # Connect with commit-on-successive-steps\n    def _connect_commit(self, tree, grid, target_pos, nodes, edges):\n        near = self._nearest_in_grid(grid, target_pos, max_ring=10)\n        if near is None:\n            return None\n        cur = near\n        last_added = None\n        for _ in range(self.connect_steps):\n            nxt_pos = self._steer(cur.position, target_pos, self.step_size)\n            if self._dist2(cur.position, nxt_pos) < (0.25 * self.min_sep * self.min_sep):\n                break\n            if not self._within_bounds(nxt_pos):\n                break\n            if self._point_in_obstacles(nxt_pos):\n                break\n            if self._has_nearby(grid, nxt_pos, self.min_sep):\n                break\n            if not self._edge_free(cur.position, nxt_pos):\n                break\n            new_cost = cur.cost + self._dist(cur.position, nxt_pos)\n            q = Node(nxt_pos, cur, new_cost)\n            if self._point_in_obstacles(q.position):\n                break\n            cur.add_child(q)\n            tree.append(q)\n            nodes.append(q)\n            edges.append((cur, q))\n            self._grid_insert(grid, q)\n            last_added = q\n            cur = q\n            if self._dist2(cur.position, target_pos) <= (self.step_size * self.step_size):\n                return cur\n        return last_added\n\n    # Sampling\n    def _guided_sample(self, attractor, incumbent_len):\n        for _ in range(24):\n            r = self._rand()\n            if incumbent_len is not None and r < self.informed_bias and self._dist(self.start, self.goal) > 1e-9:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.5)\n                if p is None:\n                    continue\n            else:\n                if r < self.goal_bias:\n                    p = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_sample()\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if p is not None and self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _corridor_sample(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        dsg = self._dist(self.start, self.goal)\n        width = max(self.step_size * 0.9, 0.05 * dsg)\n        if self.is_3d:\n            return (self._clamp_val(base[0] + self._rand_range(-width, width), 0.0, self.bounds[0]),\n                    self._clamp_val(base[1] + self._rand_range(-width, width), 0.0, self.bounds[1]),\n                    self._clamp_val(base[2] + self._rand_range(-width, width), 0.0, self.bounds[2]))\n        else:\n            return (self._clamp_val(base[0] + self._rand_range(-width, width), 0.0, self.bounds[0]),\n                    self._clamp_val(base[1] + self._rand_range(-width, width), 0.0, self.bounds[1]))\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        ext = [max(self.step_size, half)] * self.dims\n        for _ in range(18):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum_dist and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # Path helpers\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        pb_rev = pb[::-1]\n        if pa and pb_rev and pa[-1] == pb_rev[0]:\n            pb_rev = pb_rev[1:]\n        return pa + pb_rev\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        # Long-span greedy collapse\n        i = 0\n        while i < len(pts) - 2:\n            j = len(pts) - 1\n            collapsed = False\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    collapsed = True\n                    break\n                j -= 1\n            if not collapsed:\n                i += 1\n        # Angle-based local smoothing\n        k = 0\n        while k < len(pts) - 2:\n            a, b, c = pts[k], pts[k + 1], pts[k + 2]\n            if self._edge_free(a, c):\n                del pts[k + 1]\n                continue\n            k += 1\n        # Randomized prioritized shortcuts\n        attempts = 0\n        while attempts < self.shortcut_attempts and len(pts) > 2:\n            # bias to long spans\n            i = int(self._rand_range(0, max(1, len(pts) - 3)))\n            jmin = i + 2\n            j = int(self._rand_range(jmin, len(pts) - 0.001))\n            if j <= i + 1:\n                attempts += 1\n                continue\n            if self._edge_free(pts[i], pts[j]):\n                pts = pts[:i + 1] + pts[j:]\n            attempts += 1\n        return pts",
        "objective": -25.09679,
        "time_improvement": 19.0,
        "length_improvement": 19.0,
        "smoothness_improvement": 1668.0,
        "node_improvement": 83.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.02205691337585449,
                "num_nodes_avg": 67.0,
                "path_length_avg": 159.29540647815344,
                "smoothness_avg": 0.0554420868271142,
                "success_improvement": 0.0,
                "time_improvement": 10.596846313596298,
                "node_improvement": 83.12767564845127,
                "length_improvement": 12.687663512077654,
                "smoothness_improvement": 767.7890532628618,
                "objective_score": 14.63059726763979
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.07386713027954102,
                "num_nodes_avg": 146.0,
                "path_length_avg": 232.36066507917275,
                "smoothness_avg": 0.1186149616045165,
                "success_improvement": 0.0,
                "time_improvement": 55.83472082839157,
                "node_improvement": 90.19014983538266,
                "length_improvement": 22.431321865661317,
                "smoothness_improvement": 2952.0483969877487,
                "objective_score": 44.96945135285301
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.0559368371963501,
                "num_nodes_avg": 181.0,
                "path_length_avg": 119.1642002369634,
                "smoothness_avg": 0.10882735847256027,
                "success_improvement": 0.0,
                "time_improvement": -10.817104338999602,
                "node_improvement": 76.98664971392245,
                "length_improvement": 20.856812192049812,
                "smoothness_improvement": 1284.275966970945,
                "objective_score": 15.690335848384732
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "Adaptive Beam BiRRT-Connect (AB-Connect): a lean, time-focused bidirectional planner that alternates single-step tree growth with a tiny beam of candidate samples. It uses a fine spatial hash for fast nearest queries, corridor-guided sampling around the start\u2013goal line to reduce rejection, and on-the-fly path compression to limit node bloat. A short greedy connect attempts to bridge trees early; upon success, a bounded shortcut pass cleans the path and returns immediately. By avoiding rewiring and heavy optimization while enforcing strict node/edge collision checks, AB-Connect minimizes per-iteration cost and achieves fast solutions.",
        "planning_mechanism": "Mechanism: Initialize two trees at start/goal. Each iteration (alternating trees), generate a small beam of candidate samples (goal/corridor/uniform), steer once from the nearest node, validate node and edge, discard near-duplicates, and keep the candidate that best reduces distance to the opposite tree. Insert it, attempt on-the-fly grandparent line-of-sight compression, then try a direct or short greedy connect toward the other tree. If bridged, extract the path and run bounded shortcut smoothing; else continue until the iteration budget is reached.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=8.0,\n                 goal_bias=0.18,\n                 corridor_bias=0.5,\n                 beam_k=2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=28,\n                 connect_steps=6,\n                 min_sep_ratio=0.25,\n                 dupe_radius_ratio=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.connect_steps = connect_steps\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n\n    # ---------------- Planning ----------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Setup grid resolution and collision sampling\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.6 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.4)))\n\n        # Validate start/goal and early LOS\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        if not self._is_edge_in_obstacle(self.start, self.goal, obstacles, is_3d, self.edge_res):\n            path = [self.start, self.goal]\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, path, nodes, [])\n\n        # Initialize structures\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Corridor parameters\n        dsg = self._dist(self.start, self.goal)\n        c_best = float('inf')\n        base_corridor = max(self.step_size, 0.15 * dsg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = self.goal if active_start else self.start\n\n            # Beam of candidates; keep the one that best reduces distance to the other tree\n            best_cand = None\n            best_score = float('inf')\n            other_near_hint = None\n\n            for _ in range(self.beam_k):\n                # Sampling policy: goal-biased, corridor-guided, or uniform\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = base_corridor\n                    if c_best < float('inf'):\n                        width = max(self.step_size, 0.25 * (c_best - dsg) + base_corridor)\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                    continue\n\n                # Score: distance to nearest node in the other tree after this move\n                if other_near_hint is None:\n                    other_near_hint = self._nearest_grid(grid_b, tree_b, new_pos)\n                else:\n                    # refresh if new_pos is far from hint\n                    if self._dist(other_near_hint.position, new_pos) > 2.5 * self.step_size:\n                        other_near_hint = self._nearest_grid(grid_b, tree_b, new_pos)\n                if other_near_hint is None:\n                    score = self._dist(new_pos, root_other)\n                else:\n                    score = self._dist(new_pos, other_near_hint.position)\n                if score < best_score:\n                    best_score = score\n                    best_cand = (nearest, new_pos)\n\n            if best_cand is None:\n                continue\n\n            parent_node, new_pos = best_cand\n\n            # Insert node and edge (validated already)\n            new_cost = parent_node.cost + self._dist(parent_node.position, new_pos)\n            new_node = Node(new_pos, parent=parent_node, cost=new_cost)\n            parent_node.add_child(new_node)\n            tree_a.append(new_node)\n            self._edges_add(edges, parent_node, new_node)\n            self._grid_add(grid_a, new_node)\n\n            # On-the-fly grandparent compression\n            gp = parent_node.parent\n            if gp is not None:\n                # If LOS from grandparent to new_node, bypass parent to reduce nodes and cost\n                if not self._is_edge_in_obstacle(gp.position, new_node.position, obstacles, is_3d, self.edge_res):\n                    # Update edges/children coherently\n                    parent_node.remove_child(new_node)\n                    self._edges_remove(edges, parent_node, new_node)\n                    gp.add_child(new_node)\n                    self._edges_add(edges, gp, new_node)\n                    # Update cost\n                    new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n\n            # Try direct bridge to the nearest node in the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None and not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                path = self._extract_path(new_node, other_near)\n                c_best = self._path_length(path)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Short greedy connect toward new_node from the other tree\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if self._dist(p.position, to_pos) < self.step_size * self.min_sep_ratio:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(p.position, to_pos, obstacles, is_3d, self.edge_res):\n                    break\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                self._edges_add(edges, p, q)\n                self._grid_add(grid_b, q)\n                p = q\n                steps += 1\n\n                # Check bridge now\n                if not self._is_edge_in_obstacle(new_node.position, p.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, p)\n                    c_best = self._path_length(path)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------------- RNG ----------------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------------- Geometry ----------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------------- Collision ----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------------- Sampling ----------------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        # Sample around the start-goal line with axis-aligned jitter (cheap \"corridor\")\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        # Fallback to uniform if corridor sample is invalid\n        return self._sample_free(obstacles, is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---------------- Grid and neighbors ----------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Expand rings up to modest radius; fallback linear scan if needed\n        for r in range(0, 5):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan (rare with fine grid)\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # ---------------- Edges and costs ----------------\n    def _edges_add(self, edges, parent, child):\n        edges.append((parent, child))\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # ---------------- Paths ----------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        # Path A: root_A -> meet_a\n        path_a = self._path_to_root(meet_a)\n        # Path B: meet_b -> root_B (following parent links)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # Concatenate, implying a straight edge between meet_a and meet_b (validated before)\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        # Final LOS collapse forward\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            for k in range(1, len(pts) - 1):\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d, self.edge_res):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
        "objective": -20.0019,
        "time_improvement": 15.0,
        "length_improvement": 12.0,
        "smoothness_improvement": 1665.0,
        "node_improvement": 85.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.022508907318115234,
                "num_nodes_avg": 61.9,
                "path_length_avg": 173.37195960178056,
                "smoothness_avg": 0.04856882636983518,
                "success_improvement": 0.0,
                "time_improvement": 11.725605588421473,
                "node_improvement": 84.41198690506171,
                "length_improvement": 4.972081687759297,
                "smoothness_improvement": 660.2076015824708,
                "objective_score": 9.801968697094374
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04350669384002685,
                "num_nodes_avg": 122.6,
                "path_length_avg": 245.93388702328062,
                "smoothness_avg": 0.11098748565610625,
                "success_improvement": 0.0,
                "time_improvement": 72.84181080292292,
                "node_improvement": 91.76241349190352,
                "length_improvement": 17.900189697186487,
                "smoothness_improvement": 2755.78794698629,
                "objective_score": 46.371596794120215
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06773929595947266,
                "num_nodes_avg": 163.7,
                "path_length_avg": 132.06627662911285,
                "smoothness_avg": 0.13189994478614067,
                "success_improvement": 0.0,
                "time_improvement": -38.09791603378091,
                "node_improvement": 79.18626827717736,
                "length_improvement": 12.287867383240805,
                "smoothness_improvement": 1577.7575618385185,
                "objective_score": 3.832133429002802
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "AURORA-Fuse: An anytime, lazy-connect BiRRT* with informed/bridge sampling, cycle-safe rewiring, and corner-rounding smoothing. It fuses adaptive cost-aware parenting with a log-based rewire radius, dynamic duplicate suppression, and batched connection to curb transient node growth. On the first solution, it continues brief post-refinement under an informed ellipse, then visibility-prunes, rounds corners, and shortcuts for short, smooth polylines at low planning time.",
        "planning_mechanism": "Alternate expanding start/goal trees: sample (goal-biased + bridge + informed after first path), steer, select lowest-cost parent in an adaptive radius, insert only if node/edge are collision-free, locally rewire neighbors avoiding cycles, then attempt a lazy batched connect of the opposite tree toward the new node with exact seam insertion when visible. Keep the best path found and perform limited anytime refinement; finally apply visibility pruning, angle-based corner rounding, and randomized shortcutting before returning.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=6.0,\n        connect_mult=2.0,\n        goal_bias=0.13,\n        ellipse_bias=0.55,\n        bridge_bias=0.08,\n        grid_cell_factor=1.7,\n        dup_radius_factor=0.38,\n        rewire_gamma=2.8,\n        polish_after=400,\n        smooth_iters=160\n    ):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.connect_step = float(step_size * connect_mult)\n        self.goal_bias = float(goal_bias)\n        self.ellipse_bias = float(ellipse_bias)\n        self.bridge_bias = float(bridge_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dup_factor = float(dup_radius_factor)\n        self.rewire_gamma = float(rewire_gamma)\n        self.polish_after = int(max(0, polish_after))\n        self.smooth_iters = int(max(0, smooth_iters))\n        self._rng = 881726454\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], nodes, edges)\n\n        self._seed_from_scene()\n\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.base_dup = max(0.5, self.dup_factor * self.step)\n\n        self._build_obs_bins()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            final = self._finalize_path(path)\n            return PlannerResult(True, final, nodes, edges)\n\n        # Initialize trees\n        sa = Node(self.start, None, 0.0)\n        sb = Node(self.goal, None, 0.0)\n        Ta, Tb = [sa], [sb]\n        Ga, Gb = {}, {}\n        self._grid_add(Ga, sa)\n        self._grid_add(Gb, sb)\n        nodes.extend([sa, sb])\n\n        best_len = None\n        best_path = None\n        solved_iter = None\n\n        for it in range(self.max_iter):\n            # Anytime refinement stopping rule\n            if best_path is not None and solved_iter is not None:\n                if it - solved_iter >= self.polish_after:\n                    final = self._finalize_path(best_path)\n                    return PlannerResult(True, final, nodes, edges)\n\n            active_from_start = (it % 2 == 0)\n            tree = Ta if active_from_start else Tb\n            other_tree = Tb if active_from_start else Ta\n            grid = Ga if active_from_start else Gb\n            other_grid = Gb if active_from_start else Ga\n            attractor = self.goal if active_from_start else self.start\n\n            s = self._sample(attractor, best_len)\n            if s is None:\n                continue\n\n            near = self._nearest(grid, s)\n            if near is None:\n                continue\n\n            newp = self._steer(near.position, s, self.step)\n            if (not self._in_bounds(newp)) or self._point_in_obstacles(newp):\n                continue\n\n            dup_r = self._dup_radius(len(tree))\n            if self._too_close(grid, newp, dup_r):\n                continue\n\n            # Candidate parent selection within adaptive radius\n            radius = self._rewire_radius(len(tree))\n            parent, new_cost = self._choose_parent(grid, newp, near, radius)\n            if parent is None:\n                continue\n\n            # Strict node and edge checks before insertion\n            if self._point_in_obstacles(newp):\n                continue\n            if not self._edge_free(parent.position, newp):\n                continue\n\n            nn = Node(newp, parent, new_cost)\n            parent.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid, nn)\n\n            # Local rewiring with cycle protection\n            self._local_rewire(grid, nn, radius, edges)\n\n            # Lazy batched connect of opposite tree\n            meet, reached = self._lazy_connect_batch(other_tree, other_grid, nn.position, nodes, edges)\n            if reached:\n                if active_from_start:\n                    pa = self._trace_to_root(nn)\n                    pb = self._trace_to_root(meet)\n                    path = pa + pb[-2::-1]\n                else:\n                    pa = self._trace_to_root(meet)\n                    pb = self._trace_to_root(nn)\n                    path = pa + pb[-2::-1]\n                path = self._dedup(path)\n                L = self._path_len(path)\n                if best_len is None or L + 1e-9 < best_len:\n                    best_len = L\n                    best_path = path[:]\n                    if solved_iter is None:\n                        solved_iter = it\n                # continue to refine; do not early return\n\n        if best_path is not None:\n            final = self._finalize_path(best_path)\n            return PlannerResult(True, final, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and helpers\n    def _seed_from_scene(self):\n        s = 2166136261 & 0xffffffff\n        for v in self.start + self.goal:\n            q = int(v * 2654435761) & 0xffffffff\n            s ^= q\n            s = (s * 16777619) & 0xffffffff\n        s ^= ((len(self.obstacles) + 131) * 2246822519) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s & 0xffffffff\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Spatial hash (nodes)\n    def _cell_key(self, p):\n        if self.is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_collect(self, grid, key, ring):\n        out = []\n        if self.is3:\n            for dx in range(-ring, ring + 1):\n                for dy in range(-ring, ring + 1):\n                    for dz in range(-ring, ring + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-ring, ring + 1):\n                for dy in range(-ring, ring + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, pos):\n        k = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        found = False\n        for r in range(0, 4):\n            cand = self._grid_collect(grid, k, r)\n            if not cand:\n                continue\n            for n in cand:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n                    found = True\n            if found:\n                return best\n        # fallback global scan\n        for lst in grid.values():\n            for n in lst:\n                d2 = self._dist2(n.position, pos)\n                if d2 < bestd:\n                    bestd = d2\n                    best = n\n        return best\n\n    def _neighbors_radius(self, grid, pos, radius):\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        k = self._cell_key(pos)\n        if self.is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((k[0] + dx, k[1] + dy, k[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((k[0] + dx, k[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_radius(grid, pos, radius)) > 0\n\n    def _dup_radius(self, n_nodes):\n        # Mild decay to reduce sample rejection near frontiers as trees grow\n        return max(0.3 * self.step, self.base_dup / (1.0 + 0.0015 * n_nodes) ** 0.5)\n\n    # Obstacles and collision\n    def _build_obs_bins(self):\n        self.obs_cell = max(4.0, self.step * 1.25)\n        self.obin = {}\n        if self.is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            lst = self.obin.get(key)\n                            if lst is None:\n                                self.obin[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        lst = self.obin.get(key)\n                        if lst is None:\n                            self.obin[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self.is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_overlap(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_overlap(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_overlap(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            q = p1[i]\n            d = q - p\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t0 = (mn - p) * inv\n                t1 = (mx - p) * inv\n                if t0 > t1:\n                    t0, t1 = t1, t0\n                if t0 > tmin:\n                    tmin = t0\n                if t1 < tmax:\n                    tmax = t1\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Parenting and rewiring\n    def _rewire_radius(self, n_nodes):\n        # RRT* inspired: gamma * (log(n)/n)^(1/d)\n        n = max(2, n_nodes)\n        from_log = (1.0 + self._log1p(n)) / float(n)\n        exponent = 1.0 / float(self.dim if self.dim > 0 else 1)\n        r = self.step * max(1.2, self.rewire_gamma) * (from_log ** exponent)\n        return max(self.step * 1.25, min(r, self.step * 6.0))\n\n    def _log1p(self, x):\n        # simple approximation adequate for algorithmic scaling\n        # ln(1+x) via series for small x and change-of-base otherwise\n        if x < 1e-6:\n            return x - 0.5 * x * x\n        # change-of-base using natural log approximated via Newton for ln\n        y = x + 1.0\n        # 3 Newton steps to refine ln(y)\n        t = y - 1.0\n        ln = t - t * t / (2.0 * y) + t * t * t / (3.0 * y * y)\n        return ln\n\n    def _choose_parent(self, grid, newp, fallback, radius):\n        parent = None\n        best_cost = 1e100\n        neigh = self._neighbors_radius(grid, newp, radius)\n        if not neigh:\n            neigh = [fallback]\n        for n in neigh:\n            if not self._edge_free(n.position, newp):\n                continue\n            c = n.cost + self._dist(n.position, newp)\n            if c + 1e-12 < best_cost:\n                parent = n\n                best_cost = c\n        if parent is None:\n            return None, None\n        return parent, best_cost\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _local_rewire(self, grid, pivot, radius, edges):\n        neigh = self._neighbors_radius(grid, pivot.position, radius)\n        for nb in neigh:\n            if nb is pivot or nb.parent is None or nb is pivot.parent:\n                continue\n            # avoid cycles\n            if self._is_ancestor(nb, pivot):\n                continue\n            cand = pivot.cost + self._dist(pivot.position, nb.position)\n            if cand + 1e-12 < nb.cost and self._edge_free(pivot.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                    self._remove_edge(edges, (oldp, nb))\n                pivot.add_child(nb)\n                nb.cost = cand\n                edges.append((pivot, nb))\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            if cur.parent is None:\n                cur.cost = 0.0\n            else:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n\n    def _remove_edge(self, edges, e):\n        for i in range(len(edges)):\n            if edges[i][0] is e[0] and edges[i][1] is e[1]:\n                edges.pop(i)\n                return\n\n    # Lazy batched connect (limits transient nodes)\n    def _lazy_connect_batch(self, tree, grid, target_pos, nodes, edges):\n        cur = self._nearest(grid, target_pos)\n        if cur is None:\n            return None, False\n\n        # Direct connect with exact seam when visible\n        if self._edge_free(cur.position, target_pos):\n            if self._in_bounds(target_pos) and (not self._point_in_obstacles(target_pos)):\n                # Only avoid true duplicates; allow exact seam even if close\n                if self._dist2(cur.position, target_pos) > 1e-18:\n                    nn = Node(target_pos, cur, cur.cost + self._dist(cur.position, target_pos))\n                    cur.add_child(nn)\n                    tree.append(nn)\n                    nodes.append(nn)\n                    edges.append((cur, nn))\n                    self._grid_add(grid, nn)\n                    return nn, True\n            return cur, True\n\n        # Simulate a few steps without creating nodes\n        sim_pts = []\n        here = cur.position\n        steps = 0\n        max_steps = 10  # small cap to control growth\n        ok = True\n        while steps < max_steps:\n            nxt = self._steer(here, target_pos, self.connect_step)\n            if (not self._in_bounds(nxt)) or self._point_in_obstacles(nxt):\n                ok = False\n                break\n            if not self._edge_free(here, nxt):\n                ok = False\n                break\n            if self._too_close(grid, nxt, self._dup_radius(len(tree)) * 0.75):\n                ok = False\n                break\n            sim_pts.append(nxt)\n            here = nxt\n            steps += 1\n            if self._edge_free(here, target_pos):\n                # complete with meeting point\n                sim_pts.append(target_pos)\n                break\n\n        if not sim_pts:\n            return cur, False\n\n        # Commit simulated steps as nodes (bounded), ensuring checks before add\n        last = cur\n        created = 0\n        for i, p in enumerate(sim_pts):\n            if self._point_in_obstacles(p):\n                return last, False\n            if not self._edge_free(last.position, p):\n                return last, False\n            # Avoid near-duplicates\n            if self._too_close(grid, p, self._dup_radius(len(tree)) * 0.6):\n                return last, False\n            nn = Node(p, last, last.cost + self._dist(last.position, p))\n            last.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((last, nn))\n            self._grid_add(grid, nn)\n            last = nn\n            created += 1\n\n        reached = (self._dist2(sim_pts[-1], target_pos) <= 1e-18)\n        return last, reached\n\n    # Sampling\n    def _sample(self, attractor, best_len):\n        r = self._rand()\n        # Informed ellipse after first solution\n        if best_len is not None and r < self.ellipse_bias:\n            p = self._sample_ellipse(self.start, self.goal, best_len * 1.02)\n            if p is not None:\n                return p\n        # Bridge sampling for narrow passages\n        if r < self.bridge_bias:\n            p = self._bridge_sample()\n            if p is not None:\n                return p\n        # Goal attractor bias\n        if r < self.goal_bias:\n            if self._in_bounds(attractor) and (not self._point_in_obstacles(attractor)):\n                return attractor\n        # Uniform sample\n        if self.is3:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]),\n                    self._rand_range(0.0, self.bounds[2]))\n        else:\n            return (self._rand_range(0.0, self.bounds[0]),\n                    self._rand_range(0.0, self.bounds[1]))\n\n    def _sample_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(28):\n            if self.is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (not self._in_bounds(p)) or self._point_in_obstacles(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum + 1e-9:\n                return p\n        return None\n\n    def _bridge_sample(self):\n        # pick two random points; if one in obstacle and the other free, use midpoint of the two free-to-obstacle pair\n        if self.is3:\n            a = (self._rand_range(0.0, self.bounds[0]),\n                 self._rand_range(0.0, self.bounds[1]),\n                 self._rand_range(0.0, self.bounds[2]))\n            b = (self._rand_range(0.0, self.bounds[0]),\n                 self._rand_range(0.0, self.bounds[1]),\n                 self._rand_range(0.0, self.bounds[2]))\n        else:\n            a = (self._rand_range(0.0, self.bounds[0]),\n                 self._rand_range(0.0, self.bounds[1]))\n            b = (self._rand_range(0.0, self.bounds[0]),\n                 self._rand_range(0.0, self.bounds[1]))\n        ina = self._point_in_obstacles(a)\n        inb = self._point_in_obstacles(b)\n        if ina and (not inb):\n            mid = tuple(0.5 * (a[i] + b[i]) for i in range(self.dim))\n            if self._in_bounds(mid) and (not self._point_in_obstacles(mid)):\n                return mid\n        if inb and (not ina):\n            mid = tuple(0.5 * (a[i] + b[i]) for i in range(self.dim))\n            if self._in_bounds(mid) and (not self._point_in_obstacles(mid)):\n                return mid\n        return None\n\n    # Path utilities\n    def _trace_to_root(self, node):\n        cur = node\n        pts = []\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _dedup(self, pts):\n        out = []\n        last = None\n        for p in pts:\n            if last is None or p != last:\n                out.append(p)\n                last = p\n        return out\n\n    def _visibility_prune(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        i = 0\n        while i < len(pts) - 1:\n            j = len(pts) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], pts[j]):\n                    out.append(pts[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(pts[i + 1])\n                i += 1\n        return out\n\n    def _corner_round(self, pts, alpha=0.35):\n        # Insert two points around sharp corners to approximate curvature with straight segments\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts) - 1):\n            a = out[-1]\n            b = pts[i]\n            c = pts[i + 1]\n            ab = self._dist(a, b)\n            bc = self._dist(b, c)\n            if ab < 1e-9 or bc < 1e-9:\n                continue\n            # attempt direct skip first\n            if self._edge_free(a, c):\n                # straight skip\n                continue\n            # generate two offset points along ab and bc\n            ta = max(0.0, min(1.0, alpha))\n            tb = max(0.0, min(1.0, alpha))\n            pa = tuple(a[k] + (b[k] - a[k]) * (1.0 - ta) for k in range(self.dim))\n            pb = tuple(b[k] + (c[k] - b[k]) * tb for k in range(self.dim))\n            ok = True\n            if self._in_bounds(pa) and (not self._point_in_obstacles(pa)) and self._edge_free(out[-1], pa):\n                out.append(pa)\n            else:\n                ok = False\n            if ok and self._in_bounds(pb) and (not self._point_in_obstacles(pb)) and self._edge_free(out[-1], pb):\n                out.append(pb)\n            else:\n                # fallback: keep the original corner if rounding fails\n                if ok and out[-1] != b and self._edge_free(out[-1], b):\n                    out.append(b)\n                elif out[-1] != b:\n                    out.append(b)\n            # ensure we can reach c later\n        out.append(pts[-1])\n        # prune any redundant points introduced by rounding\n        return self._visibility_prune(out)\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        n = len(cur)\n        tries = 0\n        while tries < attempts and n > 2:\n            i = int(self._rand_range(0, max(1, n - 2)))\n            j = int(self._rand_range(i + 2, n))\n            if j >= n:\n                j = n - 1\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = cur[i]\n            b = cur[j]\n            if self._edge_free(a, b):\n                cur = cur[:i + 1] + cur[j:]\n                n = len(cur)\n            tries += 1\n        return cur\n\n    def _finalize_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._visibility_prune(path)\n        p1 = self._corner_round(p0, alpha=0.33)\n        p2 = self._shortcut(p1, max(40, self.smooth_iters))\n        p3 = self._visibility_prune(p2)\n        return self._dedup(p3)",
        "objective": -20.21704,
        "time_improvement": 1.0,
        "length_improvement": 19.0,
        "smoothness_improvement": 1661.0,
        "node_improvement": 41.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.034449219703674316,
                "num_nodes_avg": 304.0,
                "path_length_avg": 157.893114234518,
                "smoothness_avg": 0.055575961784582996,
                "success_improvement": 0.0,
                "time_improvement": -39.632814032619216,
                "node_improvement": 23.44497607655503,
                "length_improvement": 13.456282111556806,
                "smoothness_improvement": 769.8844870613716,
                "objective_score": 0.03334749245517843
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.07639155387878419,
                "num_nodes_avg": 471.0,
                "path_length_avg": 226.44511380530776,
                "smoothness_avg": 0.11756795140044089,
                "success_improvement": 0.0,
                "time_improvement": 54.32536378980019,
                "node_improvement": 68.35315460592622,
                "length_improvement": 24.406103150580012,
                "smoothness_improvement": 2925.108070305915,
                "objective_score": 45.56681137881764
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.05640125274658203,
                "num_nodes_avg": 543.0,
                "path_length_avg": 120.12918874650252,
                "smoothness_avg": 0.10916035476332828,
                "success_improvement": 0.0,
                "time_improvement": -11.737163267359323,
                "node_improvement": 30.959949141767325,
                "length_improvement": 20.215912771828812,
                "smoothness_improvement": 1288.511655210285,
                "objective_score": 15.050956958940915
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "Flash-IBiRRT-DC: A fast Bidirectional RRT with Informed Biasing, Direct-Connect, and sparse grids. It minimizes planning time by (1) aggressive informed sampling once an incumbent appears, (2) single-step expansion with min-separation to cap node count, (3) direct cross-tree connection without growing the opposite tree, (4) lightweight neighbor search via sparse spatial hash, and (5) minimal, collision-aware smoothing.",
        "planning_mechanism": "Mechanism: Alternate expanding start/goal trees. Each iteration: draw an informed/corridor/goal-biased sample, find k-nearest anchors from a few grid rings, steer one step, validate node+edge, choose the cheapest feasible parent, and insert. Then try a direct edge to the nearest node of the opposite tree within a connect radius; on success, extract and lightly smooth the path and return. No multi-step connect and no heavy rewiring to reduce time.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=7.5,\n                 goal_bias=0.35,\n                 corridor_bias=0.30,\n                 ellipse_bias=0.70,\n                 grid_cell_factor=2.2,\n                 min_sep_ratio=0.6,\n                 k_parent=4,\n                 k_anchor=6,\n                 connect_radius_mult=2.6,\n                 smoothing_attempts=60):\n        self.max_iter = int(max_iter)\n        self.step = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.ellipse_bias = float(ellipse_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.min_sep_ratio = float(min_sep_ratio)\n        self.k_parent = int(max(1, k_parent))\n        self.k_anchor = int(max(1, k_anchor))\n        self.connect_radius_mult = float(connect_radius_mult)\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self._rng = 123456789\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self._is3 = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Spatial params\n        self.cell = max(1.0, self.step * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step * self.min_sep_ratio)\n        self.connect_radius = max(self.step * 1.2, self.step * self.connect_radius_mult)\n\n        # RNG seed\n        self._seed()\n\n        # Build obstacle bins\n        self._build_obs_bins()\n\n        # Validate start/goal occupancy\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Trivial straight-line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            path = [self.start, self.goal]\n            path = self._smooth_path(path)\n            return PlannerResult(True, path, nodes, edges)\n\n        # Trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        incumbent_len = None\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            target_root = self.goal if active_start else self.start\n\n            # Guided sample\n            sp = self._guided_sample(target_root, incumbent_len)\n            if sp is None:\n                continue\n\n            # k-nearest anchors in active tree\n            anchors = self._grid_k_nearest(grid_a, sp, self.k_anchor)\n            if not anchors:\n                anchors = [tree_a[-1]]\n\n            # Try steering from the best anchor\n            parent = None\n            newp = None\n            bestc = None\n            # Evaluate a few anchors, pick cheapest feasible\n            for anc in anchors:\n                cand = self._steer(anc.position, sp, self.step)\n                if not self._in_bounds(cand):\n                    continue\n                # Both checks required before adding node/edge\n                if self._point_in_obstacles(cand):\n                    continue\n                if self._too_close(grid_a, cand, self.min_sep):\n                    continue\n                if not self._edge_free(anc.position, cand):\n                    continue\n                gc = anc.cost + self._dist(anc.position, cand)\n                if (parent is None) or (gc + 1e-12 < bestc):\n                    parent = anc\n                    newp = cand\n                    bestc = gc\n\n            if parent is None or newp is None:\n                continue\n\n            nn = Node(newp, parent, bestc)\n            parent.add_child(nn)\n            tree_a.append(nn)\n            nodes.append(nn)\n            edges.append((parent, nn))\n            self._grid_add(grid_a, nn)\n\n            # Direct-Connect: try connecting to nearest in the opposite tree\n            nb = self._grid_k_nearest(grid_b, nn.position, 1)\n            meet_b = nb[0] if nb else None\n            if meet_b is not None:\n                if self._dist(nn.position, meet_b.position) <= self.connect_radius:\n                    if self._edge_free(nn.position, meet_b.position):\n                        path = self._extract_path(nn, meet_b)\n                        L = self._path_len(path)\n                        if incumbent_len is None or L + 1e-9 < incumbent_len:\n                            incumbent_len = L\n                        path = self._smooth_path(path)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- RNG ----------\n    def _seed(self):\n        s = 0xA5A5A5A5\n        for v in self.start + self.goal:\n            s ^= (int(v * 2654435761) & 0xffffffff)\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 374761393) & 0xffffffff\n        if s == 0:\n            s = 123456789\n        self._rng = s\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d2 = self._dist2(a, b)\n        if d2 <= 1e-18:\n            return self._clamp(a)\n        if d2 <= step * step:\n            return self._clamp(b)\n        d = d2 ** 0.5\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # ---------- Spatial hash ----------\n    def _cell_key(self, p):\n        if self._is3:\n            return (int(p[0] // self.cell), int(p[1] // self.cell), int(p[2] // self.cell))\n        return (int(p[0] // self.cell), int(p[1] // self.cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self._is3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            cand.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        cand.extend(lst)\n        return cand\n\n    def _grid_k_nearest(self, grid, pos, k, max_rings=4):\n        key = self._cell_key(pos)\n        best = []\n        bestd = []\n        found_any = False\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                found_any = True\n                for n in cand:\n                    d2 = self._dist2(n.position, pos)\n                    if len(best) < k:\n                        best.append(n)\n                        bestd.append(d2)\n                    else:\n                        # replace worst if better\n                        wi = 0\n                        wd = -1.0\n                        for i in range(len(best)):\n                            if bestd[i] > wd:\n                                wd = bestd[i]\n                                wi = i\n                        if d2 < bestd[wi]:\n                            best[wi] = n\n                            bestd[wi] = d2\n                # Early exit if we have k candidates from small rings\n                if len(best) >= k and r >= 1:\n                    break\n        if not found_any:\n            # Fallback: return last node if grid empty (shouldn't happen)\n            return []\n        # Sort by distance\n        idx = list(range(len(best)))\n        for i in range(len(idx)):\n            for j in range(i + 1, len(idx)):\n                if bestd[idx[j]] < bestd[idx[i]]:\n                    idx[i], idx[j] = idx[j], idx[i]\n        return [best[i] for i in idx]\n\n    def _neighbors_within(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        rc = int(radius // self.cell) + 1\n        r2 = radius * radius\n        out = []\n        if self._is3:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not lst:\n                            continue\n                        for n in lst:\n                            if self._dist2(n.position, pos) <= r2:\n                                out.append(n)\n        else:\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if not lst:\n                        continue\n                    for n in lst:\n                        if self._dist2(n.position, pos) <= r2:\n                            out.append(n)\n        return out\n\n    def _too_close(self, grid, pos, radius):\n        return len(self._neighbors_within(grid, pos, radius)) > 0\n\n    # ---------- Obstacles & collision ----------\n    def _build_obs_bins(self):\n        # cell slightly larger than step keeps buckets small and focused\n        self.obs_cell = max(3.0, self.step * 1.1)\n        self.obin = {}\n        if self._is3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                iz0 = int(max(0.0, z) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                iz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        for k in range(iz0, iz1 + 1):\n                            key = (i, j, k)\n                            b = self.obin.get(key)\n                            if b is None:\n                                self.obin[key] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                ix0 = int(max(0.0, x) // self.obs_cell)\n                iy0 = int(max(0.0, y) // self.obs_cell)\n                ix1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                iy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for i in range(ix0, ix1 + 1):\n                    for j in range(iy0, iy1 + 1):\n                        key = (i, j)\n                        b = self.obin.get(key)\n                        if b is None:\n                            self.obin[key] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self._is3:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            iz = int(p[2] // self.obs_cell)\n            bucket = self.obin.get((ix, iy, iz))\n            if not bucket:\n                return False\n            x, y, z = p\n            for idx in bucket:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n            return False\n        else:\n            ix = int(p[0] // self.obs_cell)\n            iy = int(p[1] // self.obs_cell)\n            bucket = self.obin.get((ix, iy))\n            if not bucket:\n                return False\n            x, y = p\n            for idx in bucket:\n                ox, oy, w, h = self.obstacles[idx]\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_any(a, b)\n\n    def _segment_hits_any(self, a, b):\n        if self._is3:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            mnz = a[2] if a[2] < b[2] else b[2]\n            mxz = a[2] if a[2] > b[2] else b[2]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            iz0 = int(max(0.0, mnz) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            iz1 = int(min(self.bounds[2], mxz) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    for k in range(iz0, iz1 + 1):\n                        bucket = self.obin.get((i, j, k))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, oz, w, h, d = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy, oz), (ox + w, oy + h, oz + d)):\n                    return True\n            return False\n        else:\n            mnx = a[0] if a[0] < b[0] else b[0]\n            mxx = a[0] if a[0] > b[0] else b[0]\n            mny = a[1] if a[1] < b[1] else b[1]\n            mxy = a[1] if a[1] > b[1] else b[1]\n            ix0 = int(max(0.0, mnx) // self.obs_cell)\n            iy0 = int(max(0.0, mny) // self.obs_cell)\n            ix1 = int(min(self.bounds[0], mxx) // self.obs_cell)\n            iy1 = int(min(self.bounds[1], mxy) // self.obs_cell)\n            cand = set()\n            for i in range(ix0, ix1 + 1):\n                for j in range(iy0, iy1 + 1):\n                    bucket = self.obin.get((i, j))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                ox, oy, w, h = self.obstacles[idx]\n                if self._seg_box_hit(a, b, (ox, oy), (ox + w, oy + h)):\n                    return True\n            return False\n\n    def _seg_box_hit(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(len(bmin)):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, target_root, incumbent_len):\n        tries = 12\n        while tries > 0:\n            tries -= 1\n            r = self._rand()\n            if incumbent_len is not None and r < self.ellipse_bias:\n                p = self._sample_in_ellipse(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    continue\n            else:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    p = target_root\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    p = self._corridor_point()\n                else:\n                    if self._is3:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _corridor_point(self):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        sg = self._dist(self.start, self.goal)\n        w = max(self.step * 0.8, 0.05 * sg)\n        if self._is3:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            oz = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n        else:\n            ox = self._rand_range(-w, w)\n            oy = self._rand_range(-w, w)\n            return self._clamp((base[0] + ox, base[1] + oy))\n\n    def _sample_in_ellipse(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [max(self.step, half)] * self.dim\n        for _ in range(10):\n            if self._is3:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if not self._in_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # ---------- Paths and smoothing ----------\n    def _trace_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._trace_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_len(self, path):\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _prune_collinear(self, pts, cos_eps=0.995):\n        if len(pts) < 3:\n            return pts[:]\n        out = [pts[0]]\n        for i in range(1, len(pts) - 1):\n            a = out[-1]\n            b = pts[i]\n            c = pts[i + 1]\n            v1 = tuple(b[j] - a[j] for j in range(self.dim))\n            v2 = tuple(c[j] - b[j] for j in range(self.dim))\n            n1 = sum(v1[j] * v1[j] for j in range(self.dim)) ** 0.5\n            n2 = sum(v2[j] * v2[j] for j in range(self.dim)) ** 0.5\n            if n1 < 1e-9 or n2 < 1e-9:\n                continue\n            cosang = sum(v1[j] * v2[j] for j in range(self.dim)) / (n1 * n2)\n            if cosang < cos_eps:\n                out.append(b)\n        out.append(pts[-1])\n        return out\n\n    def _vis_collapse(self, pts):\n        if len(pts) < 3:\n            return pts[:]\n        out = pts[:]\n        i = 0\n        while i < len(out) - 2:\n            j = len(out) - 1\n            collapsed = False\n            while j > i + 1:\n                if self._edge_free(out[i], out[j]):\n                    del out[i + 1:j]\n                    collapsed = True\n                    break\n                j -= 1\n            if not collapsed:\n                i += 1\n        return out\n\n    def _shortcut(self, pts, attempts):\n        if len(pts) < 3:\n            return pts[:]\n        cur = pts[:]\n        bestL = self._path_len(cur)\n        tries = 0\n        stall = 0\n        while tries < attempts and len(cur) > 2:\n            i = int(self._rand_range(0, max(1, len(cur) - 2)))\n            j = int(self._rand_range(i + 1, len(cur) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(cur[i], cur[j]):\n                cand = cur[:i + 1] + cur[j:]\n                L = self._path_len(cand)\n                if L + 1e-9 <= bestL:\n                    cur = cand\n                    bestL = L\n                    stall = 0\n                else:\n                    stall += 1\n            else:\n                stall += 1\n            tries += 1\n            if stall > 20:\n                break\n        return cur\n\n    def _smooth_path(self, path):\n        if not path or len(path) < 2:\n            return path\n        p0 = self._prune_collinear(path)\n        p1 = self._vis_collapse(p0)\n        p2 = self._shortcut(p1, self.smoothing_attempts)\n        return p2",
        "objective": -32.29794,
        "time_improvement": 42.0,
        "length_improvement": 19.0,
        "smoothness_improvement": 1657.0,
        "node_improvement": 89.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.011611437797546387,
                "num_nodes_avg": 45.0,
                "path_length_avg": 147.65257627327262,
                "smoothness_avg": 0.04617885414768348,
                "success_improvement": 0.0,
                "time_improvement": 52.93542934839856,
                "node_improvement": 88.66784185343742,
                "length_improvement": 19.069283239823644,
                "smoothness_improvement": 622.7993463980489,
                "objective_score": 30.436195480404
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.05334858894348145,
                "num_nodes_avg": 129.0,
                "path_length_avg": 238.3184995191058,
                "smoothness_avg": 0.08995418290254918,
                "success_improvement": 0.0,
                "time_improvement": 68.1027905756774,
                "node_improvement": 91.3323926627696,
                "length_improvement": 20.44242524285565,
                "smoothness_improvement": 2214.585917461648,
                "objective_score": 43.76922190572485
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.047772574424743655,
                "num_nodes_avg": 100.0,
                "path_length_avg": 124.42974925219728,
                "smoothness_avg": 0.1755580483910071,
                "success_improvement": 0.0,
                "time_improvement": 5.357209489940944,
                "node_improvement": 87.28544183089637,
                "length_improvement": 17.359685254631263,
                "smoothness_improvement": 2133.0854171864203,
                "objective_score": 22.68840108569314
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "BCI-BiRRT: Beam-Compressed Informed BiRRT \u2014 a bidirectional planner that uses small-beam guided sampling, per-cell duplicate suppression, line-of-sight ancestor compression, grid-accelerated nearest/near queries, and k-near minimal-cost bridging with post-connection informed shortcuts to deliver fast, short, and smooth paths.",
        "planning_mechanism": "Mechanism: adaptively choose a tree to expand; sample a small beam (goal/line/informed-biased), steer and validate candidates, select the one that most reduces distance to the opposite tree, compress the parent via line-of-sight to an ancestor, commit the node (after node+edge checks and duplicate pruning), then attempt a k-near bridge to the opposite tree minimizing total start-to-goal cost; upon success, extract [start\u2192\u2026\u2192meetA, meetB\u2192\u2026\u2192goal], compress and shortcut, and return.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=6.0,\n                 beam_k=3,\n                 goal_bias=0.18,\n                 line_bias=0.35,\n                 connect_radius_factor=3.0,\n                 k_bridge=6,\n                 occ_gain_ratio=0.99,\n                 compress_depth=3,\n                 smoothing_iters=100,\n                 ellipse_tries=90,\n                 switch_fail_thresh=6,\n                 grid_cell=None):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_radius_factor = connect_radius_factor\n        self.k_bridge = k_bridge\n        self.occ_gain_ratio = occ_gain_ratio\n        self.compress_depth = compress_depth\n        self.smoothing_iters = smoothing_iters\n        self.ellipse_tries = ellipse_tries\n        self.switch_fail_thresh = switch_fail_thresh\n        self.grid_cell = grid_cell\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Basic parameters\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.edge_res = max(0.5, min(1.0, 0.5 * self.step_size))\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line check\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # Initialize trees (start-rooted, goal-rooted)\n        s_root = Node(start, None, 0.0)\n        g_root = Node(goal, None, 0.0)\n        start_tree = [s_root]\n        goal_tree = [g_root]\n        edges = []\n\n        grid_s = {}\n        grid_g = {}\n        self._grid_add(grid_s, s_root, self.grid_cell)\n        self._grid_add(grid_g, g_root, self.grid_cell)\n\n        # Per-cell best cost to suppress near-duplicates\n        occ_cell = max(0.5, 0.7 * self.step_size)\n        occ_s = {self._occ_key(start, occ_cell): 0.0}\n        occ_g = {self._occ_key(goal, occ_cell): 0.0}\n\n        # Bookkeeping\n        failed_s = 0\n        failed_g = 0\n\n        best_path = None\n        best_len = float('inf')\n\n        for it in range(self.max_iter):\n            # Choose which tree to grow (adaptive alternation)\n            active_start = (it % 2 == 0)\n            if (active_start and failed_s >= self.switch_fail_thresh) or ((not active_start) and failed_g >= self.switch_fail_thresh):\n                active_start = not active_start\n\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_s if active_start else grid_g\n            grid_b = grid_g if active_start else grid_s\n            occ_a = occ_s if active_start else occ_g\n            root_other = goal if active_start else start\n            root_self = start if active_start else goal\n\n            # Beam sampling\n            candidates = []\n            for _ in range(self.beam_k):\n                x_rand = None\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                else:\n                    # informed ellipsoid after first solution\n                    if best_len < float('inf'):\n                        got = False\n                        for _t in range(self.ellipse_tries):\n                            p = self._uniform_point()\n                            if self._in_bounds(p):\n                                if self._dist(p, start) + self._dist(p, goal) <= best_len:\n                                    x_rand = p\n                                    got = True\n                                    break\n                        if not got:\n                            x_rand = self._uniform_point()\n                    else:\n                        if self._rand() < self.line_bias:\n                            # line-biased with jitter\n                            t = self._uniform(0.0, 1.0)\n                            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n                            jit = 0.5 * self.step_size\n                            x_rand = tuple(self._clip(base[i] + self._uniform(-jit, jit), 0.0, self.bounds[i]) for i in range(self.dim))\n                        else:\n                            x_rand = self._uniform_point()\n\n                # Nearest and steer\n                n_near = self._nearest(grid_a, tree_a, x_rand, self.grid_cell)\n                x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n                if not self._in_bounds(x_new_pos):\n                    continue\n                if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(n_near.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                    continue\n\n                # Line-of-sight ancestor compression (limited depth)\n                best_parent = n_near\n                best_cost = n_near.cost + self._dist(n_near.position, x_new_pos)\n                anc = n_near.parent\n                depth = 0\n                while anc is not None and depth < self.compress_depth:\n                    if not self._is_edge_in_obstacle(anc.position, x_new_pos, obstacles, is_3d, self.edge_res):\n                        alt = anc.cost + self._dist(anc.position, x_new_pos)\n                        if alt + 1e-12 < best_cost:\n                            best_cost = alt\n                            best_parent = anc\n                    anc = anc.parent\n                    depth += 1\n\n                # Duplicate suppression in occupancy grid\n                k_occ = self._occ_key(x_new_pos, occ_cell)\n                prev_best = occ_a.get(k_occ, float('inf'))\n                if best_cost >= prev_best * self.occ_gain_ratio:\n                    continue\n\n                # Progress score: distance to other tree after extension\n                other_near = self._nearest(grid_b, tree_b, x_new_pos, self.grid_cell)\n                score = self._dist(x_new_pos, other_near.position) if other_near is not None else self._dist(x_new_pos, root_other)\n                candidates.append((score, x_new_pos, best_parent, best_cost))\n\n            if not candidates:\n                if active_start:\n                    failed_s += 1\n                else:\n                    failed_g += 1\n                continue\n\n            # Commit the best candidate\n            candidates.sort(key=lambda t: t[0])\n            _, new_pos, parent, new_cost = candidates[0]\n\n            new_node = Node(new_pos, None, new_cost)\n            new_node.attach(parent)\n            tree_a.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid_a, new_node, self.grid_cell)\n            k_occ_new = self._occ_key(new_pos, occ_cell)\n            if new_cost < occ_a.get(k_occ_new, float('inf')):\n                occ_a[k_occ_new] = new_cost\n\n            if active_start:\n                failed_s = 0\n            else:\n                failed_g = 0\n\n            # Attempt k-near best-cost bridge to the other tree\n            r_conn = max(self.connect_radius_factor * self.step_size, self.step_size)\n            near_b = self._near(grid_b, new_pos, r_conn, self.grid_cell)\n            if not near_b:\n                nn_b = self._nearest(grid_b, tree_b, new_pos, self.grid_cell)\n                if nn_b is not None:\n                    near_b = [nn_b]\n\n            # Select up to k closest in Euclidean distance to new_pos\n            if len(near_b) > self.k_bridge:\n                # partial selection\n                dist_idx = [(self._dist(n.position, new_pos), i) for i, n in enumerate(near_b)]\n                dist_idx.sort(key=lambda t: t[0])\n                near_b = [near_b[i] for (_, i) in dist_idx[:self.k_bridge]]\n\n            best_bridge = None\n            best_total = best_len\n            for nb in near_b:\n                if not self._is_edge_in_obstacle(new_pos, nb.position, obstacles, is_3d, self.edge_res):\n                    total = new_node.cost + self._dist(new_pos, nb.position) + nb.cost\n                    if total + 1e-12 < best_total:\n                        best_total = total\n                        best_bridge = nb\n\n            if best_bridge is not None:\n                # Extract path\n                if active_start:\n                    meet_a = new_node\n                    meet_b = best_bridge\n                else:\n                    meet_a = best_bridge\n                    meet_b = new_node\n\n                path = self._extract_path(meet_a, meet_b)\n                path = self._compress(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n                plen = self._path_length(path)\n                if plen < best_len:\n                    best_len = plen\n                    best_path = path\n                return PlannerResult(True, best_path, start_tree + goal_tree, edges)\n\n        # If loop ends without connection\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _uniform_point(self):\n        if self.dim == 3:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]),\n                    self._uniform(0.0, self.bounds[2]))\n        else:\n            return (self._uniform(0.0, self.bounds[0]),\n                    self._uniform(0.0, self.bounds[1]))\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return tuple(self._clip(to_pos[i], 0.0, self.bounds[i]) for i in range(self.dim))\n        r = step / d\n        return tuple(self._clip(from_pos[i] + (to_pos[i] - from_pos[i]) * r, 0.0, self.bounds[i]) for i in range(self.dim))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Spatial hash ----------\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        # Expand radius until found, then fallback to scan\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        limit = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > limit:\n                limit = self.bounds[i]\n        limit = limit * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # Fallback\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        r2 = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= r2:\n                out.append(n)\n        return out\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    # ---------- Path utilities ----------\n    def _path_to_root(self, node):\n        seq = []\n        cur = node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _extract_path(self, meet_a, meet_b):\n        # meet_a is in start-tree side, meet_b is in goal-tree side\n        path_a = self._path_to_root(meet_a)\n        # ascend from meet_b to goal root\n        tail = []\n        cur = meet_b\n        while cur is not None:\n            tail.append(cur.position)\n            cur = cur.parent\n        # path: start ... meet_a, then straight to meet_b (implied), then ... goal\n        return path_a + tail\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, self.edge_res):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
        "objective": -4.32865,
        "time_improvement": -45.0,
        "length_improvement": 16.0,
        "smoothness_improvement": 1649.0,
        "node_improvement": 81.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.05528700351715088,
                "num_nodes_avg": 52.7,
                "path_length_avg": 159.23267345792033,
                "smoothness_avg": 0.04720018064341601,
                "success_improvement": 0.0,
                "time_improvement": -116.82202007111755,
                "node_improvement": 86.72878368169226,
                "length_improvement": 12.722048474535743,
                "smoothness_improvement": 638.7853239022464,
                "objective_score": -24.219450317102588
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.128195858001709,
                "num_nodes_avg": 251.0,
                "path_length_avg": 244.97426414775782,
                "smoothness_avg": 0.11245472368962676,
                "success_improvement": 0.0,
                "time_improvement": 19.976282760218798,
                "node_improvement": 83.13512060740442,
                "length_improvement": 18.22053943424897,
                "smoothness_improvement": 2793.541038397612,
                "objective_score": 30.89291368060308
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06766645908355713,
                "num_nodes_avg": 219.1,
                "path_length_avg": 125.15812725071248,
                "smoothness_avg": 0.12691495233302894,
                "success_improvement": 0.0,
                "time_improvement": -37.949425846041684,
                "node_improvement": 72.14240305149396,
                "length_improvement": 16.875931269650575,
                "smoothness_improvement": 1514.3488257888052,
                "objective_score": 6.312475136921865
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "C3-IRRT#-Beam: Cached, Cell-Capped Informed RRT# with Beamed Rewiring and LOS Bridging \u2014 a single-tree, cost-optimal planner that combines quantized collision caching across all phases, tuned spatial hashing, per-cell admission with best-cost ledgers, admissible heuristic pruning, correct-cost rewiring with on-node propagation, and early-terminating cached smoothing to deliver faster solves and shorter, smoother paths.",
        "planning_mechanism": "At each iteration, sample with goal/line bias and informed-ellipse gating after the first solution; steer a bounded step from the hashed-nearest node; validate node and edge (with cache); select the lowest-cost valid parent within an adaptive neighborhood under heuristic pruning and per-cell cost admission; commit the node, then rewire a small beam of cheaper neighbors with cost-correct subtree updates. Opportunistically perform direct line-of-sight goal bridging from nearby nodes. After improvements, run a few cached shortcuts to contract c_best and focus the informed set. Stop on post-optimization budgets and return a compressed, smoothed path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n        self.parent = new_parent\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=3800,\n                 step_size=5.0,\n                 goal_bias=0.22,\n                 line_bias=0.40,\n                 gamma_radius=70.0,\n                 min_radius_factor=1.0,\n                 near_cap=56,\n                 cell_cap=3,\n                 admit_gain_ratio=0.99,\n                 prune_margin=1.001,\n                 rewire_cap=14,\n                 post_opt_iters=360,\n                 no_improve_limit=160,\n                 smoothing_iters=160,\n                 ellipse_tries=64,\n                 online_shortcuts_per_improve=32):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.gamma_radius = gamma_radius\n        self.min_radius_factor = min_radius_factor\n        self.near_cap = near_cap\n        self.cell_cap = cell_cap\n        self.admit_gain_ratio = admit_gain_ratio\n        self.prune_margin = prune_margin\n        self.rewire_cap = rewire_cap\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.smoothing_iters = smoothing_iters\n        self.ellipse_tries = ellipse_tries\n        self.online_shortcuts_per_improve = online_shortcuts_per_improve\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Endpoint validation\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(success=False, path=[], nodes=[], edges=[])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(success=False, path=[], nodes=[], edges=[])\n\n        # RNG and caches\n        self._init_rng()\n        self._edge_cache = {}\n        self._seg_qres = max(0.25, 0.5 * self.step_size)\n\n        # Early straight-line solution\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            path = [start, goal]\n            return PlannerResult(success=True, path=path, nodes=nodes, edges=edges)\n\n        # Initialize structures\n        root = Node(start, None, 0.0)\n        nodes = [root]\n\n        cell = max(1.0, 1.25 * self.step_size)\n        grid = {}\n        self._grid_add(grid, root, cell)\n\n        # Per-cell throttling and cost-ledger\n        occ = {}\n        self._occ_inc(occ, self._grid_key(start, cell))\n        dup_cell = max(0.5, 0.6 * self.step_size)\n        occ_best_cost = {self._occ_key(start, dup_cell): 0.0}\n\n        best_cost = float('inf')\n        goal_node = None\n        success = False\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n        best_path_pts = None\n\n        for it in range(self.max_iter):\n            # Sampling\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                x_rand = self._sample(start, goal, best_cost)\n\n            # Nearest\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n            # Bounds and node collision\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Cell throttling\n            kcell = self._grid_key(x_new_pos, cell)\n            if occ.get(kcell, 0) >= max(1, self.cell_cap):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Edge collision from nearest (cached)\n            if self._edge_blocked(n_near.position, x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Parent selection within adaptive radius, heuristic-pruned\n            r_near = self._rrtstar_radius(max(2, len(nodes)))\n            near_nodes = self._near(grid, x_new_pos, r_near, cell)\n            if n_near not in near_nodes:\n                near_nodes.append(n_near)\n            if near_nodes:\n                near_nodes = self._k_nearest_limit(near_nodes, x_new_pos, self.near_cap)\n\n            best_parent = None\n            best_pc = float('inf')\n\n            for p in near_nodes:\n                # Heuristic pruning against current best solution\n                base = p.cost + self._dist(p.position, x_new_pos)\n                if best_cost < float('inf'):\n                    h = self._dist(x_new_pos, goal)\n                    if base + h >= best_cost * self.prune_margin:\n                        continue\n                if base + 1e-12 < best_pc:\n                    if not self._edge_blocked(p.position, x_new_pos, obstacles, is_3d):\n                        best_pc = base\n                        best_parent = p\n\n            if best_parent is None:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Per-cell best-cost duplicate suppression\n            kdup = self._occ_key(x_new_pos, dup_cell)\n            prev_best = occ_best_cost.get(kdup, float('inf'))\n            if best_pc >= prev_best * self.admit_gain_ratio:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Commit node (node and edge checks satisfied)\n            x_new = Node(x_new_pos, None, best_pc)\n            x_new.attach(best_parent)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            self._occ_inc(occ, kcell)\n            if best_pc < prev_best:\n                occ_best_cost[kdup] = best_pc\n\n            # Rewire a small beam of neighbors for efficiency\n            # Select promising neighbors by potential gain\n            rewire_cands = []\n            for q in near_nodes:\n                if q is x_new or q is best_parent:\n                    continue\n                alt = x_new.cost + self._dist(x_new.position, q.position)\n                if alt + 1e-12 < q.cost:\n                    if best_cost < float('inf'):\n                        # prune rewires unlikely to improve final cost\n                        h = self._dist(q.position, goal)\n                        if alt + h >= best_cost * self.prune_margin:\n                            continue\n                    rewire_cands.append((q.cost - alt, q, alt))\n            # Process up to rewire_cap best gains\n            if rewire_cands:\n                rewire_cands.sort(key=lambda t: t[0], reverse=True)\n                for _, q, alt in rewire_cands[:max(1, self.rewire_cap)]:\n                    if not self._edge_blocked(x_new.position, q.position, obstacles, is_3d):\n                        q.attach(x_new)\n                        q.cost = alt\n                        self._propagate_costs_from(q)\n\n            # Goal bridging via best nearby parent\n            improved = False\n            r_conn = max(r_near, 2.0 * self.step_size)\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                cand_goal = self._near(grid, goal, r_conn, cell)\n                if x_new not in cand_goal:\n                    cand_goal.append(x_new)\n                best_goal_parent = None\n                best_goal_cost = best_cost\n                for p in cand_goal:\n                    gcost = p.cost + self._dist(p.position, goal)\n                    if gcost + 1e-12 < best_goal_cost:\n                        if not self._edge_blocked(p.position, goal, obstacles, is_3d):\n                            best_goal_cost = gcost\n                            best_goal_parent = p\n                if best_goal_parent is not None:\n                    if goal_node is None:\n                        goal_node = Node(goal, best_goal_parent, best_goal_cost)\n                        best_goal_parent.children.append(goal_node)\n                        nodes.append(goal_node)\n                    else:\n                        goal_node.attach(best_goal_parent)\n                        goal_node.cost = best_goal_cost\n                    best_cost = best_goal_cost\n                    success = True\n                    found_first = True\n                    improved = True\n\n            # Online smoothing after improvement\n            if improved and goal_node is not None:\n                cur_path = self._extract_path(goal_node)\n                cur_path = self._compress_visibility(cur_path, obstacles, is_3d)\n                cur_path = self._shortcuts(cur_path, obstacles, is_3d, self.online_shortcuts_per_improve)\n                plen = self._path_length(cur_path)\n                if plen + 1e-12 < best_cost:\n                    best_cost = plen\n                best_path_pts = cur_path\n                post_iters = 0\n                no_improve = 0\n            else:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                    if post_iters >= self.post_opt_iters or no_improve >= self.no_improve_limit:\n                        break\n\n        # Build final path\n        path = []\n        if success and goal_node is not None:\n            if best_path_pts is None:\n                path = self._extract_path(goal_node)\n                path = self._compress_visibility(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n            else:\n                path = self._shortcuts(best_path_pts, obstacles, is_3d, self.smoothing_iters)\n\n        # Build edges\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---------- Utilities ----------\n    def _init_rng(self):\n        self._lcg_state = 2862933555777941757 % (1 << 32)\n\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / max(1e-12, d)\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Cached edge query\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._seg_key(a, b, self._seg_qres)\n        if k in self._edge_cache:\n            return self._edge_cache[k]\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, resolution=min(1.0, 0.5 * self.step_size))\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _seg_key(self, a, b, q):\n        ka = tuple(int(x // q) for x in a)\n        kb = tuple(int(x // q) for x in b)\n        return (ka, kb) if ka <= kb else (kb, ka)\n\n    # Spatial hashing\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _occ_inc(self, occ, key):\n        occ[key] = occ.get(key, 0) + 1\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        base = self._grid_key(center_pos, cell)\n        out = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (base[0] + dx, base[1] + dy)\n                    if k in grid:\n                        out.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (base[0] + dx, base[1] + dy, base[2] + dz)\n                        if k in grid:\n                            out.extend(grid[k])\n        return out\n\n    def _nearest(self, grid, nodes, pos, cell):\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        span = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > span:\n                span = self.bounds[i]\n        limit = span * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # fallback\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _k_nearest_limit(self, nodes, center, k):\n        if len(nodes) <= k:\n            return nodes\n        dist_idx = []\n        for n in nodes:\n            dist_idx.append((self._dist(n.position, center), n))\n        dist_idx.sort(key=lambda t: t[0])\n        return [t[1] for t in dist_idx[:k]]\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _heuristic(self, a, b):\n        return self._dist(a, b)\n\n    def _sample(self, start, goal, c_best):\n        # Informed ellipsoidal gate after first solution\n        if c_best < float('inf'):\n            for _ in range(self.ellipse_tries):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p):\n                    if self._dist(p, start) + self._dist(p, goal) <= c_best:\n                        return p\n        # Line-biased sample with jitter\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jit = 0.5 * self.step_size\n            return tuple(self._clip(base[i] + self._uniform(-jit, jit), 0.0, self.bounds[i]) for i in range(self.dim))\n        # Uniform\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    def _rrtstar_radius(self, n):\n        r = self.gamma_radius\n        if n > 2:\n            expo = 1.0 / float(max(2, self.dim))\n            r = self.gamma_radius * ((self._log_approx(n) / float(n)) ** expo)\n        rmin = max(self.min_radius_factor * self.step_size, 1e-6)\n        if r < rmin:\n            r = rmin\n        return r\n\n    def _propagate_costs_from(self, node):\n        # Update node and all descendants to maintain consistent costs\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                stack.append(c)\n\n    def _extract_path(self, goal_node):\n        seq = []\n        cur = goal_node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _compress_visibility(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._edge_blocked(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        no_gain = 0\n        for _ in range(iters):\n            if n < 3 or no_gain > max(8, iters // 10):\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                before = self._dist(pts[i], pts[i + 1]) + self._dist(pts[j - 1], pts[j])\n                after = self._dist(pts[i], pts[j])\n                if after + 1e-12 < before:\n                    pts = pts[:i + 1] + pts[j:]\n                    n = len(pts)\n                    no_gain = 0\n                else:\n                    no_gain += 1\n            else:\n                no_gain += 1\n        return pts",
        "objective": -11.31791,
        "time_improvement": -29.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1637.0,
        "node_improvement": 66.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.04869384765625,
                "num_nodes_avg": 142.0,
                "path_length_avg": 156.94171771174342,
                "smoothness_avg": 0.05000575517450624,
                "success_improvement": 0.0,
                "time_improvement": -90.96528555012308,
                "node_improvement": 64.24074540418032,
                "length_improvement": 13.977757621532207,
                "smoothness_improvement": 682.698657716415,
                "objective_score": -15.489437803535523
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.11519887447357177,
                "num_nodes_avg": 403.0,
                "path_length_avg": 229.3729522589852,
                "smoothness_avg": 0.11782822378241282,
                "success_improvement": 0.0,
                "time_improvement": 28.089391491172343,
                "node_improvement": 72.92212591547404,
                "length_improvement": 23.42870640158524,
                "smoothness_improvement": 2931.805066160672,
                "objective_score": 37.14306661910621
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.060450196266174316,
                "num_nodes_avg": 306.0,
                "path_length_avg": 118.47542861631464,
                "smoothness_avg": 0.10979481191774568,
                "success_improvement": 0.0,
                "time_improvement": -23.237863782732852,
                "node_improvement": 61.09345200254291,
                "length_improvement": 21.314261506704646,
                "smoothness_improvement": 1296.5819033837186,
                "objective_score": 12.300107286121523
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "BG-BiRRT-LC: Beam-Guided Bidirectional RRT-Connect with Line-of-Sight Compression, Duplicate Suppression, Spatial Hashing, and Informed Sampling. It prioritizes time efficiency by limiting neighbor/rewire costs, pruning near-duplicates, compressing parents via direct line-of-sight, and using a beam of goal-directed samples with a lightweight grid for fast nearest/near queries.",
        "planning_mechanism": "Alternate expanding start/goal trees: for each side, beam-sample k candidates (goal-biased and informed after first path), pick the most promising, steer one step, validate node and edge, suppress near-duplicates, pick a best parent from a tiny local set, then compress to an ancestor if line-of-sight holds. Attempt a bounded greedy connect from the other tree to the new node. Upon a connection, merge paths and optionally continue a few refinement iterations; finally apply capped shortcut smoothing.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def detach_from_parent(self):\n        if self.parent is not None and self in self.parent.children:\n            self.parent.children.remove(self)\n        self.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 9.0,\n        goal_bias: float = 0.12,\n        beam_k: int = 3,\n        parent_k: int = 5,\n        connect_steps: int = 6,\n        time_limit_sec: float = 15.0,\n        smooth_attempts: int = 80,\n        post_opt_iters: int = 120,\n        no_improve_limit: int = 80,\n        compress_ancestors: int = 3\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.beam_k = max(1, beam_k)\n        self.parent_k = max(1, parent_k)\n        self.connect_steps = connect_steps\n        self.time_limit_sec = time_limit_sec\n        self.smooth_attempts = smooth_attempts\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.compress_ancestors = compress_ancestors\n\n        # Spatial hash cell size and duplicate suppression radii\n        self.cell_size = max(6.0, step_size * 1.5)\n        self.dup_radius = step_size * 1.25\n        self.dup_thresh = step_size * 0.6\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n        success_state = False\n        best_path = []\n        best_cost = float('inf')\n\n        # Roots\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Spatial hashes\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        c_min = self._dist(start_position, goal_position)\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        t0 = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - t0 > self.time_limit_sec:\n                break\n\n            # Alternate expansion\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n                grid_a, grid_b = grid_start, grid_goal\n                root_a, root_b = start_root, goal_root\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n                grid_a, grid_b = grid_goal, grid_start\n                root_a, root_b = goal_root, start_root\n\n            # Beam-guided sampling\n            x_rand = self._beam_sample(bounds, obstacles, is_3d, root_a.position, root_b.position, best_cost, c_min, grid_a, tree_a)\n\n            # Nearest and steer\n            a_near = self._nearest(grid_a, tree_a, x_rand, bounds)\n            a_new_pos = self._steer(a_near.position, x_rand, self.step_size)\n\n            # Bounds and collision checks before adding\n            if not self._in_bounds(a_new_pos, bounds):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n            if self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n            if self._hit_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Duplicate/near-duplicate suppression\n            near_dups = self._grid_neighbors(grid_a, a_new_pos, self.dup_radius)\n            skip = False\n            for nb in near_dups:\n                if self._dist(nb.position, a_new_pos) <= self.dup_thresh:\n                    skip = True\n                    break\n            if skip:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Parent selection among a tiny local set\n            parent_radius = max(self.step_size * 2.0, 12.0)\n            neighbors = self._grid_neighbors(grid_a, a_new_pos, parent_radius)\n            if not neighbors:\n                neighbors = [a_near]\n            # Choose up to parent_k closest neighbors\n            neighbors.sort(key=lambda n: self._dist(n.position, a_new_pos))\n            candidates = neighbors[:self.parent_k]\n\n            best_parent = None\n            best_g = float('inf')\n            for cand in candidates:\n                if self._hit_obstacle(cand.position, a_new_pos, obstacles, is_3d):\n                    continue\n                g = cand.cost + self._dist(cand.position, a_new_pos)\n                if g < best_g:\n                    best_g = g\n                    best_parent = cand\n\n            if best_parent is None:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Line-of-sight compression to ancestors\n            best_parent, best_g = self._compress_parent(best_parent, a_new_pos, best_g, obstacles, is_3d)\n\n            # Add node to tree_a\n            a_new = Node(a_new_pos, parent=None, cost=best_g)\n            best_parent.add_child(a_new)\n            tree_a.append(a_new)\n            nodes.append(a_new)\n            edges.append((best_parent, a_new))\n            self._grid_add(grid_a, a_new)\n\n            # Attempt to connect other tree to this new node\n            b_meet = self._try_connect(tree_b, grid_b, a_new, obstacles, is_3d, bounds, nodes, edges)\n            if b_meet is not None:\n                # Merge path start->goal\n                pathA = a_new.path_from_root()\n                pathB = b_meet.path_from_root()\n                if root_a is start_root:\n                    merged = pathA + pathB[-2::-1]\n                else:\n                    merged = pathB + pathA[-2::-1]\n\n                cost = self._path_cost(merged)\n                if cost < best_cost - 1e-9:\n                    best_cost = cost\n                    best_path = merged\n                    success_state = True\n                    no_improve = 0\n                else:\n                    no_improve += 1\n\n                if not found_first:\n                    found_first = True\n                    post_iters = 0\n                else:\n                    post_iters += 1\n\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n            else:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n\n        # Final smoothing\n        if success_state and best_path:\n            best_path = self._shortcut_smooth(best_path, obstacles, is_3d, attempts=self.smooth_attempts)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------- Spatial Hash ----------------\n    def _key(self, pos):\n        return tuple(int(pos[d] // self.cell_size) for d in range(len(pos)))\n\n    def _grid_add(self, grid, node):\n        k = self._key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_neighbors(self, grid, pos, radius):\n        dim = len(pos)\n        span = int(max(1, math.ceil(radius / self.cell_size)))\n        kc = self._key(pos)\n        result = []\n        if dim == 2:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    k = (kc[0] + dx, kc[1] + dy)\n                    if k in grid:\n                        for n in grid[k]:\n                            if self._dist(n.position, pos) <= radius:\n                                result.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        k = (kc[0] + dx, kc[1] + dy, kc[2] + dz)\n                        if k in grid:\n                            for n in grid[k]:\n                                if self._dist(n.position, pos) <= radius:\n                                    result.append(n)\n        return result\n\n    def _nearest(self, grid, tree, pos, bounds):\n        radius = self.cell_size\n        for _ in range(4):\n            cands = self._grid_neighbors(grid, pos, radius)\n            if cands:\n                return min(cands, key=lambda n: self._dist(n.position, pos))\n            radius *= 2.0\n        return min(tree, key=lambda n: self._dist(n.position, pos))\n\n    # --------------- Beam-Guided Sampling ---------------\n    def _beam_sample(self, bounds, obstacles, is_3d, root_a, root_b, c_best, c_min, grid_a, tree_a):\n        # Goal bias\n        if random.random() < self.goal_bias:\n            goal_tgt = root_b\n            if not self._is_in_obstacle(goal_tgt, obstacles, is_3d):\n                return goal_tgt\n\n        best = None\n        best_score = float('inf')\n        for _ in range(self.beam_k):\n            if c_best < float('inf') and c_min > 1e-12:\n                x = self._sample_informed_ellipsoid(root_a, root_b, c_best, c_min, bounds)\n            else:\n                x = self._sample_uniform_free(bounds, obstacles, is_3d)\n            # Score: favor closeness to opposite root and ease of reaching from current tree\n            near = self._nearest(grid_a, tree_a, x, bounds)\n            score = self._dist(x, root_b) + 0.3 * self._dist(near.position, x)\n            if score < best_score:\n                best_score = score\n                best = x\n        return best\n\n    def _sample_uniform_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]), random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_informed_ellipsoid(self, start, goal, c_best, c_min, bounds):\n        dim = len(bounds)\n        # Prolate ellipsoid with foci at start and goal\n        r1 = c_best / 2.0\n        r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n        center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n        a1 = self._unit(self._vec(goal, start))\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r2)\n        else:\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._unit(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._unit(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r2, r2)\n\n        u = self._sample_unit_ball(dim)\n        x = [center[d] for d in range(dim)]\n        for i in range(dim):\n            for d in range(dim):\n                x[d] += basis[i][d] * radii[i] * u[i]\n        x = tuple(min(max(x[d], 0.0), bounds[d]) for d in range(dim))\n        return x\n\n    def _sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(vi * vi for vi in v))\n            if n > 1e-12:\n                v = [vi / n for vi in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    # --------------- Parent Compression ---------------\n    def _compress_parent(self, parent, new_pos, current_g, obstacles, is_3d):\n        # Try a few ancestors for direct line-of-sight to reduce chain depth\n        anc = parent\n        best_parent = parent\n        best_g = current_g\n        steps = 0\n        while anc is not None and anc.parent is not None and steps < self.compress_ancestors:\n            grand = anc.parent\n            if not self._hit_obstacle(grand.position, new_pos, obstacles, is_3d):\n                g = grand.cost + self._dist(grand.position, new_pos)\n                if g + 1e-12 < best_g:\n                    best_g = g\n                    best_parent = grand\n            anc = grand\n            steps += 1\n        return best_parent, best_g\n\n    # --------------- Connect Attempt ---------------\n    def _try_connect(self, tree, grid, target_node, obstacles, is_3d, bounds, nodes, edges):\n        target_pos = target_node.position\n        connect_thresh = self.step_size * 1.2\n\n        # Try direct connect via best local parent\n        rad = max(self.step_size * 2.0, 12.0)\n        neigh = self._grid_neighbors(grid, target_pos, rad)\n        if not neigh:\n            neigh = [self._nearest(grid, tree, target_pos, bounds)]\n        neigh.sort(key=lambda n: self._dist(n.position, target_pos))\n        candidates = neigh[:self.parent_k]\n        best_parent = None\n        best_g = float('inf')\n        for cand in candidates:\n            if self._hit_obstacle(cand.position, target_pos, obstacles, is_3d):\n                continue\n            g = cand.cost + self._dist(cand.position, target_pos)\n            if g < best_g:\n                best_g = g\n                best_parent = cand\n        if best_parent is not None:\n            if (not self._is_in_obstacle(target_pos, obstacles, is_3d)):\n                meet = Node(target_pos, parent=None, cost=best_g)\n                best_parent.add_child(meet)\n                tree.append(meet)\n                nodes.append(meet)\n                edges.append((best_parent, meet))\n                self._grid_add(grid, meet)\n                return meet\n\n        # Greedy bounded stepping toward target\n        current = self._nearest(grid, tree, target_pos, bounds)\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(current.position, target_pos, self.step_size)\n            if not self._in_bounds(nxt, bounds):\n                return None\n            if self._is_in_obstacle(nxt, obstacles, is_3d):\n                return None\n            if self._hit_obstacle(current.position, nxt, obstacles, is_3d):\n                return None\n\n            # Duplicate suppression in other tree\n            near_dups = self._grid_neighbors(grid, nxt, self.dup_radius)\n            dup = False\n            for nb in near_dups:\n                if self._dist(nb.position, nxt) <= self.dup_thresh:\n                    dup = True\n                    break\n            if dup:\n                return None\n\n            # Choose local parent\n            neigh2 = self._grid_neighbors(grid, nxt, rad)\n            if not neigh2:\n                neigh2 = [current]\n            neigh2.sort(key=lambda n: self._dist(n.position, nxt))\n            cand2 = neigh2[:self.parent_k]\n\n            best_p = None\n            best_g2 = float('inf')\n            for cand in cand2:\n                if self._hit_obstacle(cand.position, nxt, obstacles, is_3d):\n                    continue\n                g2 = cand.cost + self._dist(cand.position, nxt)\n                if g2 < best_g2:\n                    best_g2 = g2\n                    best_p = cand\n            if best_p is None:\n                return None\n\n            new_b = Node(nxt, parent=None, cost=best_g2)\n            best_p.add_child(new_b)\n            tree.append(new_b)\n            nodes.append(new_b)\n            edges.append((best_p, new_b))\n            self._grid_add(grid, new_b)\n\n            # Close enough for final snap\n            if self._dist(new_b.position, target_pos) <= connect_thresh:\n                if (not self._is_in_obstacle(target_pos, obstacles, is_3d)) and (not self._hit_obstacle(new_b.position, target_pos, obstacles, is_3d)):\n                    final_b = Node(target_pos, parent=None, cost=new_b.cost + self._dist(new_b.position, target_pos))\n                    new_b.add_child(final_b)\n                    tree.append(final_b)\n                    nodes.append(final_b)\n                    edges.append((new_b, final_b))\n                    self._grid_add(grid, final_b)\n                    return final_b\n                return None\n\n            current = new_b\n            steps += 1\n\n        return None\n\n    # --------------- Utilities ---------------\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _vec(self, a, b):\n        return tuple(a[i] - b[i] for i in range(len(a)))\n\n    def _norm(self, v):\n        return math.sqrt(sum(vi * vi for vi in v))\n\n    def _unit(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return tuple(0.0 for _ in v)\n        return tuple(vi / n for vi in v)\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0.0 <= pos[i] <= bounds[i] for i in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _hit_obstacle(self, a, b, obstacles, is_3d, res=1.0):\n        L = self._dist(a, b)\n        steps = max(1, int(L / res))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(len(a)))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _path_cost(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(len(path) - 1):\n            s += self._dist(path[i], path[i + 1])\n        return s\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, attempts=80):\n        if len(path) < 3:\n            return path[:]\n        best = path[:]\n        best_cost = self._path_cost(best)\n        n = len(best)\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = best[i]\n            b = best[j]\n            if not self._hit_obstacle(a, b, obstacles, is_3d):\n                new_path = best[:i + 1] + best[j:]\n                new_cost = self._path_cost(new_path)\n                if new_cost < best_cost - 1e-9:\n                    best = new_path\n                    best_cost = new_cost\n                    n = len(best)\n        # Greedy corner culling\n        changed = True\n        while changed and len(best) > 2:\n            changed = False\n            k = 1\n            while k < len(best) - 1:\n                if not self._hit_obstacle(best[k - 1], best[k + 1], obstacles, is_3d):\n                    best.pop(k)\n                    changed = True\n                else:\n                    k += 1\n        return best\n\n    # --------------- Controls ---------------\n    def _post_update(self, found_first, post_iters, no_improve):\n        if found_first:\n            post_iters += 1\n            no_improve += 1\n        return post_iters, no_improve\n\n    def _should_stop(self, found_first, post_iters, no_improve):\n        if not found_first:\n            return False\n        if post_iters >= self.post_opt_iters:\n            return True\n        if no_improve >= self.no_improve_limit:\n            return True\n        return False",
        "objective": -12.24798,
        "time_improvement": -23.0,
        "length_improvement": 19.0,
        "smoothness_improvement": 1613.0,
        "node_improvement": 89.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.044426774978637694,
                "num_nodes_avg": 56.4,
                "path_length_avg": 157.31603480322116,
                "smoothness_avg": 0.04606013663224119,
                "success_improvement": 0.0,
                "time_improvement": -74.23087675795257,
                "node_improvement": 85.79702845630824,
                "length_improvement": 13.772588492259377,
                "smoothness_improvement": 620.9411594821662,
                "objective_score": -10.901004134619315
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.16415343284606934,
                "num_nodes_avg": 126.7,
                "path_length_avg": 235.87995732976475,
                "smoothness_avg": 0.12420346154518477,
                "success_improvement": 0.0,
                "time_improvement": -2.469518896922128,
                "node_improvement": 91.4869313982396,
                "length_improvement": 21.256480815202853,
                "smoothness_improvement": 3095.8445256949494,
                "objective_score": 27.49225544851982
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.045468711853027345,
                "num_nodes_avg": 87.9,
                "path_length_avg": 119.57596595535551,
                "smoothness_avg": 0.09609107280574067,
                "success_improvement": 0.0,
                "time_improvement": 7.30440488486542,
                "node_improvement": 88.82390336935792,
                "length_improvement": 20.583337008070234,
                "smoothness_improvement": 1122.2713533838182,
                "objective_score": 20.152680437220855
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "GH-Connect-Lite: Guided Hash RRT-Connect Lite \u2014 a single-tree, grid-accelerated planner that combines fast goal/line-biased informed sampling, lightweight duplicate suppression, short greedy goal-connection, and bounded smoothing. It commits only validated nodes/edges, uses an occupancy-cost ledger to avoid redundant expansions, and performs micro local shortcuts and post-improvement polishing for shorter, smoother paths while keeping per-iteration work small.",
        "planning_mechanism": "Initialize with early straight-line check. Maintain a hash-grid for fast nearest queries and a per-cell best-cost ledger. Each iteration: sample (goal/line/uniform; switch to ellipsoid gating after first solution), steer one step, validate node and edge, apply duplicate-cost filter, then commit the node. Perform a tiny greedy connect toward the goal (few steps) with the same validations and a local grandparent shortcut if it lowers cost. When near the goal, attempt a direct validated bridge; on improvement, run bounded compression/shortcuts to tighten c_best and focus sampling. Use post-optimization and no-improvement budgets to terminate early and return the best path found.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=4.0,\n        goal_bias=0.2,\n        line_bias=0.35,\n        connect_steps=2,\n        connect_radius_factor=3.0,\n        occ_relax=1.02,\n        post_opt_iters=500,\n        max_no_improve=220,\n        smoothing_iters=220,\n        online_shortcuts_per_improve=40\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_steps = connect_steps\n        self.connect_radius_factor = connect_radius_factor\n        self.occ_relax = occ_relax\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.online_shortcuts_per_improve = online_shortcuts_per_improve\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Early straight-line feasibility\n        if self._in_bounds(start) and self._in_bounds(goal):\n            if (not self._is_in_obstacle(start, obstacles, is_3d)) and (not self._is_in_obstacle(goal, obstacles, is_3d)):\n                if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d):\n                    s = Node(start, None, 0.0)\n                    g = Node(goal, None, self._dist(start, goal))\n                    g.attach(s)\n                    nodes = [s, g]\n                    edges = [(s, g)]\n                    path = [start, goal]\n                    return PlannerResult(success=True, path=path, nodes=nodes, edges=edges)\n\n        root = Node(start, None, 0.0)\n        nodes = [root]\n\n        cell = max(1.0, 0.8 * self.step_size)\n        grid = {}\n        self._grid_add(grid, root, cell)\n\n        occ_cell = max(0.5, 0.6 * self.step_size)\n        occ_best = {self._grid_key(start, occ_cell): 0.0}\n\n        success = False\n        goal_node = None\n        best_cost = float('inf')\n        best_path_pts = None\n\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            # Sampling\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                x_rand = self._sample(start, goal, best_cost)\n\n            # Nearest\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n            # Bounds and node collision\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Edge collision for candidate parent\n            if self._is_edge_in_obstacle(n_near.position, x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            base_cost = n_near.cost + self._dist(n_near.position, x_new_pos)\n\n            # Duplicate suppression\n            ok = self._occ_accept(occ_best, x_new_pos, base_cost, occ_cell, self.occ_relax)\n            if not ok:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Commit new node\n            x_new = Node(x_new_pos, None, base_cost)\n            x_new.attach(n_near)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            self._occ_update(occ_best, x_new_pos, base_cost, occ_cell)\n\n            # Local grandparent shortcut\n            gp = n_near.parent\n            if gp is not None:\n                alt = gp.cost + self._dist(gp.position, x_new.position)\n                if alt + 1e-12 < x_new.cost:\n                    if not self._is_edge_in_obstacle(gp.position, x_new.position, obstacles, is_3d):\n                        x_new.attach(gp)\n                        x_new.cost = alt\n                        self._occ_update(occ_best, x_new_pos, alt, occ_cell)\n\n            # Tiny greedy connect toward goal (few validated steps)\n            cur = x_new\n            for _ in range(self.connect_steps):\n                if self._dist(cur.position, goal) <= self.connect_radius_factor * self.step_size:\n                    break\n                step_pos = self._steer(cur.position, goal, self.step_size)\n                if not self._in_bounds(step_pos) or self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(cur.position, step_pos, obstacles, is_3d):\n                    break\n                c_cost = cur.cost + self._dist(cur.position, step_pos)\n                if not self._occ_accept(occ_best, step_pos, c_cost, occ_cell, self.occ_relax):\n                    break\n                nxt = Node(step_pos, None, c_cost)\n                nxt.attach(cur)\n                nodes.append(nxt)\n                self._grid_add(grid, nxt, cell)\n                self._occ_update(occ_best, step_pos, c_cost, occ_cell)\n                # Local grandparent shortcut for connect step\n                gp2 = cur.parent\n                if gp2 is not None:\n                    alt2 = gp2.cost + self._dist(gp2.position, nxt.position)\n                    if alt2 + 1e-12 < nxt.cost:\n                        if not self._is_edge_in_obstacle(gp2.position, nxt.position, obstacles, is_3d):\n                            nxt.attach(gp2)\n                            nxt.cost = alt2\n                            self._occ_update(occ_best, step_pos, alt2, occ_cell)\n                cur = nxt\n\n            # Try direct goal connection when near\n            improved = False\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                r_conn = self.connect_radius_factor * self.step_size\n                tip = cur\n                if self._dist(tip.position, goal) <= r_conn:\n                    if not self._is_edge_in_obstacle(tip.position, goal, obstacles, is_3d):\n                        g_cost = tip.cost + self._dist(tip.position, goal)\n                        if g_cost + 1e-12 < best_cost:\n                            if goal_node is None:\n                                goal_node = Node(goal, None, g_cost)\n                                goal_node.attach(tip)\n                                nodes.append(goal_node)\n                            else:\n                                goal_node.attach(tip)\n                                goal_node.cost = g_cost\n                            best_cost = g_cost\n                            success = True\n                            found_first = True\n                            improved = True\n\n            # Post-improvement polishing\n            if improved and goal_node is not None:\n                cur_path = self._extract_path(goal_node)\n                cur_path = self._compress(cur_path, obstacles, is_3d)\n                cur_path = self._shortcuts(cur_path, obstacles, is_3d, self.online_shortcuts_per_improve)\n                L = self._path_length(cur_path)\n                if L + 1e-12 < best_cost:\n                    best_cost = L\n                best_path_pts = cur_path\n                post_iters = 0\n                no_improve = 0\n            else:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        # Final path\n        path = []\n        if success and goal_node is not None:\n            if best_path_pts is None:\n                path = self._extract_path(goal_node)\n                path = self._compress(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n            else:\n                path = self._shortcuts(best_path_pts, obstacles, is_3d, self.smoothing_iters)\n\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # --------- Utilities ---------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 390451501\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Spatial hashing\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        limit = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > limit:\n                limit = self.bounds[i]\n        limit = limit * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # Sampling with informed gating after first solution\n    def _sample(self, start, goal, c_best):\n        if c_best < float('inf'):\n            for _ in range(120):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p):\n                    if self._dist(p, start) + self._dist(p, goal) <= c_best:\n                        return p\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jitter = 0.5 * self.step_size\n            return tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    # Occupancy cost ledger\n    def _occ_accept(self, occ_best, pos, cost, cell, relax):\n        k = self._grid_key(pos, cell)\n        prev = occ_best.get(k, float('inf'))\n        return cost < prev * relax\n\n    def _occ_update(self, occ_best, pos, cost, cell):\n        k = self._grid_key(pos, cell)\n        prev = occ_best.get(k, float('inf'))\n        if cost < prev:\n            occ_best[k] = cost\n\n    # Path utilities\n    def _extract_path(self, goal_node):\n        seq = []\n        cur = goal_node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
        "objective": 2.59026,
        "time_improvement": -73.0,
        "length_improvement": 19.0,
        "smoothness_improvement": 1563.0,
        "node_improvement": 9.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.06812853813171386,
                "num_nodes_avg": 406.1,
                "path_length_avg": 156.52382632264067,
                "smoothness_avg": 0.05238387996289982,
                "success_improvement": 0.0,
                "time_improvement": -167.18335815808737,
                "node_improvement": -2.2664316293125157,
                "length_improvement": 14.20681051381224,
                "smoothness_improvement": 719.921474835408,
                "objective_score": -38.03131376496182
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.16287810802459718,
                "num_nodes_avg": 1172.8,
                "path_length_avg": 229.408680422303,
                "smoothness_avg": 0.09093924935533,
                "success_improvement": 0.0,
                "time_improvement": -1.673422716490134,
                "node_improvement": 21.198683061210776,
                "length_improvement": 23.4167793122916,
                "smoothness_improvement": 2239.9323868063857,
                "objective_score": 24.747702706459847
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.0729496955871582,
                "num_nodes_avg": 734.6,
                "path_length_avg": 121.75542214035515,
                "smoothness_avg": 0.1438275075521862,
                "success_improvement": 0.0,
                "time_improvement": -48.7201895619418,
                "node_improvement": 6.598855689764778,
                "length_improvement": 19.135845984544524,
                "smoothness_improvement": 1729.4752798215147,
                "objective_score": 5.512827121251748
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "HF-IRRT#-OS: Heuristic-Filtered Informed RRT# with Online Shortcuts \u2014 a single-tree, cost-optimal planner that uses grid-accelerated neighbors, admissible cost+heuristic pruning, correct-cost rewiring with queued propagation, per-cell best-cost duplicate suppression, aggressive informed sampling after the first solution, and incremental shortcutting to continuously reduce path length.",
        "planning_mechanism": "At each iteration, sample (goal/line/ellipse-biased), steer a bounded step, validate node and edge, select the lowest-cost valid parent within an adaptive radius, commit the node, and rewire cheaper neighbors with proper subtree cost updates. When near the goal, connect via the best valid parent to update the incumbent path. After any improvement, perform bounded shortcuts on the current best path to tighten c_best and focus the informed set. Terminate on post-optimization or no-improvement budgets and return a compressed, smoothed path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=4.0,\n                 gamma_radius=60.0,\n                 min_radius_factor=1.0,\n                 goal_bias=0.15,\n                 line_bias=0.35,\n                 connect_radius_factor=2.5,\n                 near_cap=72,\n                 post_opt_iters=600,\n                 max_no_improve=240,\n                 smoothing_iters=220,\n                 ellipse_tries=220,\n                 occ_gain_ratio=0.985,\n                 prune_margin=1.0005,\n                 online_shortcuts_per_improve=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_radius = gamma_radius\n        self.min_radius_factor = min_radius_factor\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_radius_factor = connect_radius_factor\n        self.near_cap = near_cap\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.ellipse_tries = ellipse_tries\n        self.occ_gain_ratio = occ_gain_ratio\n        self.prune_margin = prune_margin\n        self.online_shortcuts_per_improve = online_shortcuts_per_improve\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Early feasibility: straight line\n        if self._in_bounds(start) and self._in_bounds(goal):\n            if (not self._is_in_obstacle(start, obstacles, is_3d)) and (not self._is_in_obstacle(goal, obstacles, is_3d)):\n                if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d):\n                    s = Node(start, None, 0.0)\n                    g = Node(goal, None, self._dist(start, goal))\n                    g.attach(s)\n                    nodes = [s, g]\n                    edges = [(s, g)]\n                    path = [start, goal]\n                    return PlannerResult(success=True, path=path, nodes=nodes, edges=edges)\n\n        # Initialize\n        root = Node(start, None, 0.0)\n        nodes = [root]\n\n        # Spatial hash grid for NN queries\n        cell = max(1.0, 0.8 * self.step_size)\n        grid = {}\n        self._grid_add(grid, root, cell)\n\n        # Per-cell best-cost ledger to suppress duplicates\n        occ_cell = max(0.5, 0.6 * self.step_size)\n        occ_best_cost = {self._occ_key(start, occ_cell): 0.0}\n\n        success = False\n        goal_node = None\n        best_cost = float('inf')\n        best_path_pts = None\n\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            # Sampling\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                x_rand = self._sample(start, goal, best_cost)\n\n            # Nearest\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n            # Bounds and node collision\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Parent selection within adaptive radius\n            r_near = self._rrtstar_radius(max(2, len(nodes)))\n            near_nodes = self._near(grid, x_new_pos, r_near, cell)\n            if near_nodes:\n                near_nodes = self._k_nearest_limit(near_nodes, x_new_pos, self.near_cap)\n            # Ensure nearest is considered\n            if n_near not in near_nodes:\n                near_nodes.append(n_near)\n\n            best_parent = None\n            best_pc = float('inf')\n\n            for nn in near_nodes:\n                base_cost = nn.cost + self._dist(nn.position, x_new_pos)\n                if base_cost + 1e-12 < best_pc:\n                    # Edge collision check for candidate parent\n                    if not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d):\n                        best_parent = nn\n                        best_pc = base_cost\n\n            if best_parent is None:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Duplicate suppression using per-cell best cost\n            k_occ = self._occ_key(x_new_pos, occ_cell)\n            prev_best = occ_best_cost.get(k_occ, float('inf'))\n            if best_pc >= prev_best * self.occ_gain_ratio:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Commit new node (both checks already validated for chosen parent)\n            x_new = Node(x_new_pos, None, best_pc)\n            x_new.attach(best_parent)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            if best_pc < prev_best:\n                occ_best_cost[k_occ] = best_pc\n\n            # Rewire neighbors with admissible pruning toward path-length improvement\n            for nn in near_nodes:\n                if nn is x_new or nn is best_parent:\n                    continue\n                alt = x_new.cost + self._dist(x_new.position, nn.position)\n                if alt + 1e-12 < nn.cost:\n                    # If we already have a solution, skip rewires that cannot possibly lead to improving it\n                    if best_cost < float('inf'):\n                        h = self._dist(nn.position, goal)\n                        if alt + h >= best_cost * self.prune_margin:\n                            continue\n                    if not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d):\n                        nn.attach(x_new)\n                        nn.cost = alt\n                        self._propagate_costs_from(nn)\n\n            # Try connecting to the goal using best available parent within connection range\n            improved = False\n            r_conn = max(r_near, self.connect_radius_factor * self.step_size)\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                cand = self._near(grid, goal, r_conn, cell)\n                if x_new not in cand:\n                    cand.append(x_new)\n                best_parent_goal = None\n                best_goal_cost = best_cost\n                for p in cand:\n                    ctot = p.cost + self._dist(p.position, goal)\n                    if ctot + 1e-12 < best_goal_cost:\n                        if not self._is_edge_in_obstacle(p.position, goal, obstacles, is_3d):\n                            best_goal_cost = ctot\n                            best_parent_goal = p\n                if best_parent_goal is not None:\n                    if goal_node is None:\n                        goal_node = Node(goal, None, best_goal_cost)\n                        goal_node.attach(best_parent_goal)\n                        nodes.append(goal_node)\n                    else:\n                        goal_node.attach(best_parent_goal)\n                        goal_node.cost = best_goal_cost\n                    best_cost = best_goal_cost\n                    success = True\n                    found_first = True\n                    improved = True\n\n            # After improvement, do bounded online shortcuts to tighten c_best and focus sampling\n            if improved and goal_node is not None:\n                cur_path = self._extract_path(goal_node)\n                cur_path = self._compress(cur_path, obstacles, is_3d)\n                cur_path = self._shortcuts(cur_path, obstacles, is_3d, self.online_shortcuts_per_improve)\n                path_len = self._path_length(cur_path)\n                if path_len + 1e-12 < best_cost:\n                    best_cost = path_len\n                best_path_pts = cur_path\n                post_iters = 0\n                no_improve = 0\n            else:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        # Build final path\n        path = []\n        if success and goal_node is not None:\n            if best_path_pts is None:\n                path = self._extract_path(goal_node)\n                path = self._compress(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n            else:\n                # Final polishing\n                path = self._shortcuts(best_path_pts, obstacles, is_3d, self.smoothing_iters)\n\n        # Build edges from parent pointers\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---------- Utilities ----------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        # 32-bit LCG (Numerical Recipes variant)\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _rrtstar_radius(self, n):\n        r = self.gamma_radius\n        if n > 2:\n            expo = 1.0 / float(max(2, self.dim))\n            r = self.gamma_radius * ((self._log_approx(n) / float(n)) ** expo)\n        rmin = max(self.min_radius_factor * self.step_size, 1e-6)\n        if r < rmin:\n            r = rmin\n        return r\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        # rough ln via bit_length\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    # Spatial hashing\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        # limit expansion\n        max_span = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > max_span:\n                max_span = self.bounds[i]\n        limit = max_span * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # fallback\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _k_nearest_limit(self, nodes, center, k):\n        if len(nodes) <= k:\n            return nodes\n        # partial selection without full sort when large\n        idx = []\n        for i, n in enumerate(nodes):\n            idx.append((self._dist(n.position, center), i))\n        if len(nodes) <= 4 * k:\n            idx.sort(key=lambda t: t[0])\n            return [nodes[t[1]] for t in idx[:k]]\n        # approximate selection\n        sel = []\n        used = [False] * len(nodes)\n        for _ in range(k):\n            best = -1\n            bestd = float('inf')\n            for j, (d, i) in enumerate(idx):\n                if not used[j] and d < bestd:\n                    bestd = d\n                    best = j\n            if best == -1:\n                break\n            used[best] = True\n            sel.append(nodes[idx[best][1]])\n        return sel\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _heuristic(self, a, b):\n        return self._dist(a, b)\n\n    def _sample(self, start, goal, c_best):\n        # Informed ellipsoidal rejection after first solution; else line/uniform mix\n        if c_best < float('inf'):\n            # accept points satisfying triangle inequality gate; try more to avoid fallback\n            tries = self.ellipse_tries\n            for _ in range(tries):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p):\n                    if self._dist(p, start) + self._dist(p, goal) <= c_best:\n                        return p\n        # Line-biased sampling with jitter\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jitter = 0.5 * self.step_size\n            p = tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n            return p\n        # Uniform\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _propagate_costs_from(self, node):\n        # node.cost already set correctly by caller\n        stack = []\n        for c in node.children:\n            stack.append(c)\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                newc = u.parent.cost + self._dist(u.parent.position, u.position)\n                if abs(newc - u.cost) > 1e-12:\n                    u.cost = newc\n            for c in u.children:\n                stack.append(c)\n\n    def _extract_path(self, goal_node):\n        seq = []\n        cur = goal_node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
        "objective": 26.9043,
        "time_improvement": -154.0,
        "length_improvement": 19.0,
        "smoothness_improvement": 1520.0,
        "node_improvement": 44.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.10562500953674317,
                "num_nodes_avg": 293.8,
                "path_length_avg": 154.45237735825782,
                "smoothness_avg": 0.04984145985356507,
                "success_improvement": 0.0,
                "time_improvement": -314.23529004756443,
                "node_improvement": 26.013598589775878,
                "length_improvement": 15.34220451539984,
                "smoothness_improvement": 680.1270791706859,
                "objective_score": -81.66462890917599
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.2455054998397827,
                "num_nodes_avg": 623.2,
                "path_length_avg": 228.05708400641493,
                "smoothness_avg": 0.10153044277454511,
                "success_improvement": 0.0,
                "time_improvement": -53.25193033715656,
                "node_improvement": 58.1267217630854,
                "length_improvement": 23.867981099460806,
                "smoothness_improvement": 2512.4514220110627,
                "objective_score": 10.90746666858483
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.09506032466888428,
                "num_nodes_avg": 407.5,
                "path_length_avg": 122.10575352004132,
                "smoothness_avg": 0.1154296410531563,
                "success_improvement": 0.0,
                "time_improvement": -93.79641533507504,
                "node_improvement": 48.188175460902734,
                "length_improvement": 18.903172563144594,
                "smoothness_improvement": 1368.2565140663191,
                "objective_score": -9.95573849230416
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "UniGrid Informed RRT*-Fast (UG-IRRT*-F): a single-tree, cost-optimal planner that uses a uniform spatial hash for O(1)-average neighbor queries, \u03b3(log n/n)^(1/d) adaptive neighborhoods, informed ellipsoidal sampling after the first solution, duplicate-node suppression, lazy rewires with incremental cost push, and goal-side best-parent connection; it continues optimizing under a focused post-optimization budget and returns a compressed, shortcut-smoothed path.",
        "planning_mechanism": "At each iteration, sample (goal/line/ellipse-biased), steer one step from the nearest node, validate node and edge, choose the lowest-cost valid parent within an adaptive radius, add the node, and lazily rewire cheaper neighbors. If close to the goal, select the best-cost valid parent for the goal among nearby nodes and update the incumbent path. After finding a solution, restrict sampling to the informed set and terminate on a time/no-improvement budget, then compress and shortcut the path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=4200,\n                 step_size=5.0,\n                 gamma_radius=55.0,\n                 min_radius_factor=1.0,\n                 goal_bias=0.12,\n                 line_bias=0.38,\n                 connect_factor=2.0,\n                 near_cap=64,\n                 post_opt_iters=450,\n                 max_no_improve=180,\n                 smoothing_iters=160):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_radius = gamma_radius\n        self.min_radius_factor = min_radius_factor\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.connect_factor = connect_factor\n        self.near_cap = near_cap\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        root = Node(start, None, 0.0)\n        nodes = [root]\n\n        # spatial hash grid\n        cell = max(1.0, 0.8 * self.step_size)\n        grid = {}\n        self._grid_add(grid, root, cell)\n\n        # coarse occupancy to suppress duplicates\n        occ_cell = max(0.5, 0.6 * self.step_size)\n        occ = {self._occ_key(start, occ_cell): True}\n\n        success = False\n        best_cost = float('inf')\n        goal_node = None\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            # sample\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                x_rand = self._sample_biased(start, goal, best_cost)\n\n            # nearest\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n            # bounds and node collision\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # duplicate suppression\n            k_occ = self._occ_key(x_new_pos, occ_cell)\n            if k_occ in occ:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # incoming edge collision\n            if self._is_edge_in_obstacle(n_near.position, x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # choose best parent within adaptive radius\n            r_near = self._rrtstar_radius(max(2, len(nodes)))\n            near_nodes = self._near(grid, x_new_pos, r_near, cell)\n            if near_nodes:\n                near_nodes = self._limit_by_distance(near_nodes, x_new_pos, self.near_cap)\n            best_parent = n_near\n            best_pc = n_near.cost + self._dist(n_near.position, x_new_pos)\n            for nn in near_nodes:\n                if nn is n_near:\n                    continue\n                c = nn.cost + self._dist(nn.position, x_new_pos)\n                if c + 1e-12 < best_pc:\n                    if not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d):\n                        best_pc = c\n                        best_parent = nn\n\n            # commit new node (both checks were done above for chosen parent)\n            x_new = Node(x_new_pos, None, best_pc)\n            x_new.attach(best_parent)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            occ[k_occ] = True\n\n            # rewire nearby nodes\n            for nn in near_nodes:\n                if nn is best_parent or nn is x_new:\n                    continue\n                alt = x_new.cost + self._dist(x_new.position, nn.position)\n                if alt + 1e-12 < nn.cost:\n                    if not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d):\n                        nn.attach(x_new)\n                        self._propagate_costs_from(nn)\n\n            # goal-side best-parent connection when close\n            improved = False\n            r_conn = max(r_near, self.connect_factor * self.step_size)\n            if self._dist(x_new.position, goal) <= r_conn:\n                if not self._is_in_obstacle(goal, obstacles, is_3d):\n                    # consider best parent among nodes near goal (including x_new)\n                    cand = self._near(grid, goal, r_conn, cell)\n                    if x_new not in cand:\n                        cand.append(x_new)\n                    best_parent_goal = None\n                    best_goal_cost = best_cost\n                    for p in cand:\n                        if not self._is_edge_in_obstacle(p.position, goal, obstacles, is_3d):\n                            ctot = p.cost + self._dist(p.position, goal)\n                            if ctot + 1e-12 < best_goal_cost:\n                                best_goal_cost = ctot\n                                best_parent_goal = p\n                    if best_parent_goal is not None:\n                        if goal_node is None:\n                            goal_node = Node(goal, None, best_goal_cost)\n                            goal_node.attach(best_parent_goal)\n                            nodes.append(goal_node)\n                        else:\n                            goal_node.cost = best_goal_cost\n                            goal_node.attach(best_parent_goal)\n                        best_cost = best_goal_cost\n                        success = True\n                        found_first = True\n                        improved = True\n                        post_iters = 0\n                        no_improve = 0\n\n            if found_first and not improved:\n                post_iters += 1\n                no_improve += 1\n\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        path = []\n        if success and goal_node is not None:\n            # extract\n            cur = goal_node\n            while cur is not None:\n                path.append(cur.position)\n                cur = cur.parent\n            path.reverse()\n            # postprocess\n            path = self._compress(path, obstacles, is_3d)\n            path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n\n        # build edges from parent pointers\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---------- Utilities ----------\n    def _rand(self):\n        try:\n            return self._lcg_next()\n        except:\n            return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 1103515245\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    def _rrtstar_radius(self, n):\n        r = self.gamma_radius\n        if n > 2:\n            expo = 1.0 / float(max(2, self.dim))\n            r = self.gamma_radius * ((self._log_approx(n) / float(n)) ** expo)\n        rmin = max(self.min_radius_factor * self.step_size, 1e-6)\n        if r < rmin:\n            r = rmin\n        return r\n\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest(self, grid, nodes, pos, cell):\n        # exponential expansion until candidates appear\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        max_span = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > max_span:\n                max_span = self.bounds[i]\n        limit = max_span * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # fallback linear scan\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _limit_by_distance(self, nodes, center, k):\n        # partial selection of up to k nearest without full sort when large\n        if len(nodes) <= k:\n            return nodes\n        # simple reservoir based on distance threshold\n        # compute distances\n        idx = []\n        for i, n in enumerate(nodes):\n            idx.append((self._dist(n.position, center), i))\n        # partial selection: nth-element by repeated scanning (k small)\n        # choose k smallest by single pass selection\n        # fallback: simple sort when moderate\n        if len(nodes) <= 4 * k:\n            idx.sort(key=lambda t: t[0])\n            sel = [nodes[t[1]] for t in idx[:k]]\n            return sel\n        # approximate: pick k minima by iterative pass\n        sel = []\n        used = [False] * len(nodes)\n        for _ in range(k):\n            best = -1\n            bestd = float('inf')\n            for j, (d, i) in enumerate(idx):\n                if not used[j] and d < bestd:\n                    bestd = d\n                    best = j\n            if best == -1:\n                break\n            used[best] = True\n            sel.append(nodes[idx[best][1]])\n        return sel\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _sample_biased(self, start, goal, c_best):\n        # informed ellipsoidal rejection after first solution; else line/uniform mix\n        if c_best < float('inf'):\n            for _ in range(20):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._dist(p, start) + self._dist(p, goal) <= c_best and self._in_bounds(p):\n                    return p\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jitter = 0.5 * self.step_size\n            p = tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n            return p\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _propagate_costs_from(self, node):\n        stack = []\n        for c in node.children:\n            stack.append(c)\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                stack.append(c)\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
        "objective": -3.65664,
        "time_improvement": -50.0,
        "length_improvement": 19.0,
        "smoothness_improvement": 1436.0,
        "node_improvement": 46.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.06231374740600586,
                "num_nodes_avg": 244.5,
                "path_length_avg": 159.99708988452147,
                "smoothness_avg": 0.04079917273665813,
                "success_improvement": 0.0,
                "time_improvement": -144.3791801192523,
                "node_improvement": 38.42860740367666,
                "length_improvement": 12.303059718162231,
                "smoothness_improvement": 538.5956501503387,
                "objective_score": -33.238939954126664
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.11423308849334717,
                "num_nodes_avg": 663.4,
                "path_length_avg": 229.07326285952672,
                "smoothness_avg": 0.10084089211799352,
                "success_improvement": 0.0,
                "time_improvement": 28.69226420016899,
                "node_improvement": 55.42565343008802,
                "length_improvement": 23.528751349205564,
                "smoothness_improvement": 2494.7087869547277,
                "objective_score": 35.19847400434767
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06615550518035888,
                "num_nodes_avg": 438.5,
                "path_length_avg": 117.70760748606574,
                "smoothness_avg": 0.108123212990666,
                "success_improvement": 0.0,
                "time_improvement": -34.86909289750288,
                "node_improvement": 44.24666242848061,
                "length_improvement": 21.824211741702758,
                "smoothness_improvement": 1275.3192884158632,
                "objective_score": 9.010395617850108
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "Bi-Guide ARC: A bidirectional, goal-aware RRT*-Connect with Adaptive Radius, spatial hashing, subtree cost propagation, and post-planning shortcut smoothing. It balances fast greedy connections with cost-optimal rewiring, focuses samples within an informed ellipsoid after the first solution, and uses a lightweight grid index for efficient nearest/near queries to improve path length and smoothness with lower planning time.",
        "planning_mechanism": "Alternate growing start/goal trees: sample (goal-biased; informed after first path), steer one step, select best parent within an adaptive radius, add if both node and edge are collision-free, locally rewire with subtree cost updates, then attempt a bounded greedy connect of the opposite tree to the new node. Maintain best path and stop upon time/iteration/no-improvement limits; finally apply randomized shortcut smoothing to the best path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def detach_from_parent(self):\n        if self.parent is not None and self in self.parent.children:\n            self.parent.children.remove(self)\n        self.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 6000,\n        step_size: float = 5.0,\n        goal_bias: float = 0.15,\n        base_radius: float = 35.0,\n        max_radius: float = 60.0,\n        connect_steps: int = 20,\n        post_opt_iters: int = 300,\n        no_improve_limit: int = 180,\n        time_limit_sec: float = 20.0,\n        smooth_attempts: int = 120\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.base_radius = base_radius\n        self.max_radius = max_radius\n        self.connect_steps = connect_steps\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.time_limit_sec = time_limit_sec\n        self.smooth_attempts = smooth_attempts\n\n        # Spatial hash cell size\n        self.cell_size = max(8.0, step_size * 2.0)\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Core containers\n        nodes = []\n        edges = []\n        success_state = False\n        best_path = []\n        best_cost = float('inf')\n\n        # Initialize trees and spatial hashes\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Dist between start and goal\n        c_min = self._dist(start_position, goal_position)\n\n        # States\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            # Alternate expansion direction\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n                grid_a, grid_b = grid_start, grid_goal\n                root_a, root_b = start_root, goal_root\n                sample_goal = goal_position\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n                grid_a, grid_b = grid_goal, grid_start\n                root_a, root_b = goal_root, start_root\n                sample_goal = start_position\n\n            # Sampling with goal bias and informed focus\n            x_rand = self._sample(bounds, obstacles, is_3d, start_position, goal_position, best_cost, c_min, sample_goal)\n\n            # Nearest in tree_a\n            a_near = self._nearest(grid_a, tree_a, x_rand, bounds)\n            a_new_pos = self._steer(a_near.position, x_rand, self.step_size)\n\n            # Bound check\n            if not self._in_bounds(a_new_pos, bounds):\n                self._advance_counters(found_first, True)\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Node and edge collision checks before adding\n            if self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n            if self._hit_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Best parent selection within adaptive radius\n            rad = self._adaptive_radius(len(tree_a), dim)\n            neighbors = self._grid_neighbors(grid_a, a_new_pos, rad)\n            if not neighbors:\n                neighbors = [a_near]\n\n            best_parent = None\n            best_g = float('inf')\n            for cand in neighbors:\n                if self._hit_obstacle(cand.position, a_new_pos, obstacles, is_3d):\n                    continue\n                g = cand.cost + self._dist(cand.position, a_new_pos)\n                if g < best_g:\n                    best_g = g\n                    best_parent = cand\n\n            if best_parent is None:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Add new node to tree_a\n            a_new = Node(a_new_pos, parent=None, cost=best_g)\n            best_parent.add_child(a_new)\n            tree_a.append(a_new)\n            nodes.append(a_new)\n            edges.append((best_parent, a_new))\n            self._grid_add(grid_a, a_new)\n\n            # Local rewiring from a_new\n            self._rewire_from(a_new, neighbors, obstacles, is_3d, edges)\n\n            # Attempt to connect tree_b to a_new (bounded)\n            b_meet = self._attempt_connect(tree_b, grid_b, a_new, obstacles, is_3d, bounds, nodes, edges, dim)\n\n            if b_meet is not None:\n                # Merge full path\n                if root_a is start_root:\n                    path_a = a_new.path_from_root()\n                    path_b = b_meet.path_from_root()\n                else:\n                    path_a = b_meet.path_from_root()\n                    path_b = a_new.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged = path_a + path_b[-2::-1]\n                else:\n                    merged = path_a + path_b[::-1]\n\n                cost = self._path_cost(merged)\n                if cost < best_cost - 1e-9:\n                    best_cost = cost\n                    best_path = merged\n                    success_state = True\n                    no_improve = 0\n                else:\n                    no_improve += 1\n\n                if not found_first:\n                    found_first = True\n                    post_iters = 0\n                else:\n                    post_iters += 1\n\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n            else:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n\n        # Final smoothing of best path\n        if success_state and best_path:\n            best_path = self._shortcut_smooth(best_path, obstacles, is_3d, attempts=self.smooth_attempts)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ------------------ Spatial Hash ------------------\n    def _key(self, pos):\n        return tuple(int(pos[d] // self.cell_size) for d in range(len(pos)))\n\n    def _grid_add(self, grid, node):\n        k = self._key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_neighbors(self, grid, pos, radius):\n        # Collect nodes in cells within radius\n        dim = len(pos)\n        span = int(max(1, math.ceil(radius / self.cell_size)))\n        key_center = self._key(pos)\n        result = []\n        if dim == 2:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    k = (key_center[0] + dx, key_center[1] + dy)\n                    if k in grid:\n                        for n in grid[k]:\n                            if self._dist(n.position, pos) <= radius:\n                                result.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        k = (key_center[0] + dx, key_center[1] + dy, key_center[2] + dz)\n                        if k in grid:\n                            for n in grid[k]:\n                                if self._dist(n.position, pos) <= radius:\n                                    result.append(n)\n        return result\n\n    def _nearest(self, grid, tree, pos, bounds):\n        # Try increasing radii using grid; fallback to full scan\n        radius = self.cell_size\n        for _ in range(4):\n            cands = self._grid_neighbors(grid, pos, radius)\n            if cands:\n                return min(cands, key=lambda n: self._dist(n.position, pos))\n            radius *= 2.0\n        return min(tree, key=lambda n: self._dist(n.position, pos))\n\n    # ------------------ Connect Attempt ------------------\n    def _attempt_connect(self, tree, grid, target_node, obstacles, is_3d, bounds, nodes, edges, dim):\n        target_pos = target_node.position\n\n        # Direct connect via best parent in radius\n        rad = self._adaptive_radius(len(tree), dim)\n        neigh = self._grid_neighbors(grid, target_pos, rad)\n        if not neigh:\n            # include nearest if none\n            neigh = [self._nearest(grid, tree, target_pos, bounds)]\n        best_parent = None\n        best_cost = float('inf')\n        for cand in neigh:\n            if self._hit_obstacle(cand.position, target_pos, obstacles, is_3d):\n                continue\n            g = cand.cost + self._dist(cand.position, target_pos)\n            if g < best_cost:\n                best_cost = g\n                best_parent = cand\n        if best_parent is not None and not self._is_in_obstacle(target_pos, obstacles, is_3d):\n            meet = Node(target_pos, parent=None, cost=best_cost)\n            best_parent.add_child(meet)\n            tree.append(meet)\n            nodes.append(meet)\n            edges.append((best_parent, meet))\n            self._grid_add(grid, meet)\n            # Local rewiring at seam improves junction quality\n            seam_neighbors = self._grid_neighbors(grid, target_pos, rad)\n            self._rewire_from(meet, seam_neighbors, obstacles, is_3d, edges)\n            return meet\n\n        # Greedy bounded stepping toward target\n        current = self._nearest(grid, tree, target_pos, bounds)\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(current.position, target_pos, self.step_size)\n            if not self._in_bounds(nxt, bounds):\n                return None\n            if self._is_in_obstacle(nxt, obstacles, is_3d):\n                return None\n            if self._hit_obstacle(current.position, nxt, obstacles, is_3d):\n                return None\n\n            # Insert with best parent among neighbors around nxt\n            neigh2 = self._grid_neighbors(grid, nxt, rad)\n            if not neigh2:\n                neigh2 = [current]\n            best_p = None\n            best_g2 = float('inf')\n            for cand in neigh2:\n                if self._hit_obstacle(cand.position, nxt, obstacles, is_3d):\n                    continue\n                g2 = cand.cost + self._dist(cand.position, nxt)\n                if g2 < best_g2:\n                    best_g2 = g2\n                    best_p = cand\n            if best_p is None:\n                return None\n\n            new_b = Node(nxt, parent=None, cost=best_g2)\n            best_p.add_child(new_b)\n            tree.append(new_b)\n            nodes.append(new_b)\n            edges.append((best_p, new_b))\n            self._grid_add(grid, new_b)\n\n            self._rewire_from(new_b, neigh2, obstacles, is_3d, edges)\n\n            if self._dist(new_b.position, target_pos) <= self.step_size:\n                if (not self._is_in_obstacle(target_pos, obstacles, is_3d)) and (not self._hit_obstacle(new_b.position, target_pos, obstacles, is_3d)):\n                    final_b = Node(target_pos, parent=None, cost=new_b.cost + self._dist(new_b.position, target_pos))\n                    new_b.add_child(final_b)\n                    tree.append(final_b)\n                    nodes.append(final_b)\n                    edges.append((new_b, final_b))\n                    self._grid_add(grid, final_b)\n                    return final_b\n                return None\n\n            current = new_b\n            steps += 1\n\n        return None\n\n    # ------------------ Rewiring ------------------\n    def _rewire_from(self, pivot, neighbors, obstacles, is_3d, edges):\n        for nb in neighbors:\n            if nb is pivot or nb.parent is None:\n                continue\n            if self._hit_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                continue\n            new_cost = pivot.cost + self._dist(pivot.position, nb.position)\n            if new_cost + 1e-12 < nb.cost:\n                old_parent = nb.parent\n                nb.detach_from_parent()\n                pivot.add_child(nb)\n                try:\n                    edges.remove((old_parent, nb))\n                except Exception:\n                    pass\n                edges.append((pivot, nb))\n                delta = new_cost - nb.cost\n                nb.cost = new_cost\n                self._propagate_cost(nb)\n\n    def _propagate_cost(self, node):\n        # BFS update costs down the subtree to maintain coherence\n        queue = [node]\n        while queue:\n            cur = queue.pop(0)\n            for ch in cur.children:\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                queue.append(ch)\n\n    # ------------------ Sampling ------------------\n    def _sample(self, bounds, obstacles, is_3d, start, goal, c_best, c_min, biased_goal):\n        dim = len(bounds)\n        # Goal bias\n        if random.random() < self.goal_bias:\n            target = goal if biased_goal == goal else start\n            if not self._is_in_obstacle(target, obstacles, is_3d):\n                return target\n\n        # Informed sampling after first solution\n        if c_best < float('inf') and c_min > 1e-12:\n            for _ in range(50):\n                x = self._sample_informed_ellipsoid(start, goal, c_best, c_min, bounds)\n                if not self._is_in_obstacle(x, obstacles, is_3d):\n                    return x\n\n        # Uniform fallback\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]), random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_informed_ellipsoid(self, start, goal, c_best, c_min, bounds):\n        # Prolate ellipsoid with foci at start and goal\n        dim = len(bounds)\n        r1 = c_best / 2.0\n        r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n        center = tuple((s + g) * 0.5 for s, g in zip(start, goal))\n        a1 = self._unit(self._vec(goal, start))\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r2)\n        else:\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._unit(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._unit(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r2, r2)\n\n        u = self._sample_unit_ball(dim)\n        x = [center[d] for d in range(dim)]\n        for i in range(dim):\n            for d in range(dim):\n                x[d] += basis[i][d] * radii[i] * u[i]\n        # Clamp to bounds\n        x = tuple(min(max(x[d], 0.0), bounds[d]) for d in range(dim))\n        return x\n\n    def _sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(vi * vi for vi in v))\n            if n > 1e-12:\n                v = [vi / n for vi in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    # ------------------ Geometry/Collision ------------------\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _vec(self, a, b):\n        return tuple(a[i] - b[i] for i in range(len(a)))\n\n    def _norm(self, v):\n        return math.sqrt(sum(vi * vi for vi in v))\n\n    def _unit(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return tuple(0.0 for _ in v)\n        return tuple(vi / n for vi in v)\n\n    def _cross(self, a, b):\n        # Only used in 3D informed sampling\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0.0 <= pos[i] <= bounds[i] for i in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _hit_obstacle(self, a, b, obstacles, is_3d, res=1.0):\n        L = self._dist(a, b)\n        steps = max(1, int(L / res))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(len(a)))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _path_cost(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(len(path) - 1):\n            s += self._dist(path[i], path[i + 1])\n        return s\n\n    # ------------------ Controls ------------------\n    def _adaptive_radius(self, n, dim):\n        if n <= 1:\n            return self.base_radius\n        # RRT* style shrinkage\n        r = self.base_radius * (math.log(n + 1) / (n + 1)) ** (1.0 / dim)\n        r = max(self.step_size * 1.5, min(self.max_radius, r))\n        return r\n\n    def _post_update(self, found_first, post_iters, no_improve):\n        if found_first:\n            post_iters += 1\n            no_improve += 1\n        return post_iters, no_improve\n\n    def _should_stop(self, found_first, post_iters, no_improve):\n        if not found_first:\n            return False\n        if post_iters >= self.post_opt_iters:\n            return True\n        if no_improve >= self.no_improve_limit:\n            return True\n        return False\n\n    # ------------------ Smoothing ------------------\n    def _shortcut_smooth(self, path, obstacles, is_3d, attempts=100):\n        if len(path) < 3:\n            return path[:]\n        best = path[:]\n        best_cost = self._path_cost(best)\n        n = len(best)\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = best[i]\n            b = best[j]\n            if not self._hit_obstacle(a, b, obstacles, is_3d):\n                # shortcut\n                new_path = best[:i + 1] + best[j:]\n                new_cost = self._path_cost(new_path)\n                if new_cost < best_cost - 1e-9:\n                    best = new_path\n                    best_cost = new_cost\n                    n = len(best)\n        # Greedy corner culling\n        changed = True\n        while changed and len(best) > 2:\n            changed = False\n            k = 1\n            while k < len(best) - 1:\n                if not self._hit_obstacle(best[k - 1], best[k + 1], obstacles, is_3d):\n                    best.pop(k)\n                    changed = True\n                else:\n                    k += 1\n        return best",
        "objective": 14.38104,
        "time_improvement": -107.0,
        "length_improvement": 18.0,
        "smoothness_improvement": 1417.0,
        "node_improvement": 44.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.11155118942260742,
                "num_nodes_avg": 362.3,
                "path_length_avg": 155.15168551902272,
                "smoothness_avg": 0.04619305292125599,
                "success_improvement": 0.0,
                "time_improvement": -337.47630895645335,
                "node_improvement": 8.76353563334173,
                "length_improvement": 14.95890263123767,
                "smoothness_improvement": 623.021588037589,
                "objective_score": -89.15244316800546
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.08458755016326905,
                "num_nodes_avg": 414.7,
                "path_length_avg": 238.39539805931153,
                "smoothness_avg": 0.09691449918612544,
                "success_improvement": 0.0,
                "time_improvement": 47.197902476841236,
                "node_improvement": 72.13599408721359,
                "length_improvement": 20.416754296733227,
                "smoothness_improvement": 2393.679868751244,
                "objective_score": 38.37782266484852
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.06439132690429687,
                "num_nodes_avg": 395.9,
                "path_length_avg": 123.34270106287966,
                "smoothness_avg": 0.1047845601402689,
                "success_improvement": 0.0,
                "time_improvement": -31.272519594143017,
                "node_improvement": 49.66306420851876,
                "length_improvement": 18.081650902303785,
                "smoothness_improvement": 1232.8518705925312,
                "objective_score": 7.631494016102023
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "Beam-guided BiRRT with ancestor line-of-sight compression and spatial hashing (BG-Connect-LOS). The planner alternates tree growth from start and goal using a small beam of guided samples, accelerates nearest lookups with a grid hash, suppresses near-duplicate nodes, and selects a parent among recent ancestors that maintains direct line-of-sight to the new point to compress chains. A short, capped greedy connect links the two trees. Upon success, a bounded shortcut pass refines the path. This reduces expansions and collision checks while improving path quality and smoothness.",
        "planning_mechanism": "At each iteration, pick the active tree and generate a small beam of guided samples biased toward the opposite root. For each sample: find a nearby node via spatial hashing, steer by a fixed step, enforce node and edge collision checks, reject near-duplicates, and pick an ancestor parent with clear line-of-sight to minimize added cost. Insert the node and attempt a capped greedy connect from the opposite tree toward it; if the two trees meet, extract and lightly shortcut the path. Alternate trees and stop early on success.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        beam_width=3,\n        goal_bias=0.15,\n        connect_steps_limit=20,\n        min_separation_factor=0.6,\n        grid_cell_factor=1.0,\n        los_lookback_depth=8,\n        shortcut_attempts=40\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.connect_steps_limit = connect_steps_limit\n        self.min_separation_factor = min_separation_factor\n        self.grid_cell_factor = grid_cell_factor\n        self.los_lookback_depth = los_lookback_depth\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dims = len(bounds)\n        is_3d = dims == 3\n\n        # Parameters derived from step_size\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root = Node(goal_position, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root, is_3d)\n        self._grid_insert(grid_b, goal_root, is_3d)\n\n        success_state = False\n        extracted_path = []\n\n        for _ in range(self.max_iter):\n            # Alternate trees by swapping references each loop\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, goal_position),\n                (tree_b, grid_b, tree_a, grid_a, start_position),\n            ]:\n                made_progress = False\n\n                for _beam in range(self.beam_width):\n                    sample = self._sample_guided(bounds, obstacles, is_3d, attractor)\n\n                    nearest = self._nearest_by_grid(active_tree, active_grid, sample, is_3d)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos, bounds):\n                        continue\n                    if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                        continue\n                    if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                        continue\n                    if self._has_near_duplicate(active_grid, new_pos, self.min_separation, is_3d):\n                        continue\n\n                    # Choose parent among LOS-capable ancestors to compress path\n                    parent = self._choose_ancestor_parent(nearest, new_pos, obstacles, is_3d)\n                    new_cost = parent.cost + self._distance(parent.position, new_pos)\n\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node, is_3d)\n                    made_progress = True\n\n                    # Try capped greedy connect from the opposite tree toward new_node\n                    connect_node = self._attempt_connect(\n                        other_tree, other_grid, new_node.position, obstacles, is_3d, nodes, edges, bounds\n                    )\n                    if connect_node is not None:\n                        # Trees meet at new_node.position; extract path\n                        path_a = self._path_from_root(new_node)\n                        path_b = self._path_from_root(connect_node)\n                        # Remove duplicate joint if equal\n                        if path_a and path_b and path_a[-1] == path_b[-1]:\n                            path_b = path_b[:-1]\n                        raw_path = path_a + path_b[::-1]\n                        # Light shortcut smoothing\n                        smoothed = self._shortcut_path(raw_path, obstacles, is_3d, attempts=self.shortcut_attempts)\n                        extracted_path = smoothed if smoothed else raw_path\n                        success_state = True\n                        return PlannerResult(True, extracted_path, nodes, edges)\n\n                # If neither beam sample made progress for this tree, continue with the other\n                if not made_progress:\n                    continue\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # --------- Core Geometry / Utilities ---------\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _within_bounds(self, pos, bounds):\n        for i in range(len(bounds)):\n            if pos[i] < 0.0 or pos[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= 1e-9:\n            return from_pos\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * r for d in range(len(from_pos)))\n\n    def _sample_guided(self, bounds, obstacles, is_3d, target):\n        # Mild guidance: with some probability sample exactly target, else blend toward target\n        while True:\n            if random.random() < self.goal_bias:\n                p = target\n            else:\n                rand = tuple(random.uniform(0.0, bounds[d]) for d in range(len(bounds)))\n                alpha = 0.2\n                p = tuple(alpha * target[d] + (1.0 - alpha) * rand[d] for d in range(len(bounds)))\n            if self._within_bounds(p, bounds) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _path_from_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\n\n    # --------- Spatial Hash (Grid) ---------\n\n    def _cell_of(self, pos):\n        # integer grid cell indices\n        if len(pos) == 3:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        else:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node, is_3d):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _has_near_duplicate(self, grid, pos, radius, is_3d):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    def _nearest_by_grid(self, tree, grid, pos, is_3d, ring_limit=3):\n        # Search neighborhood rings; fallback to linear scan if not found\n        cell = self._cell_of(pos)\n        best = None\n        best_d = float(\"inf\")\n\n        if is_3d:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best_d = d\n                                        best = n\n                                        found = True\n                if found and best is not None:\n                    return best\n        else:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                                    found = True\n                if found and best is not None:\n                    return best\n\n        # Fallback\n        if not tree:\n            return None\n        return min(tree, key=lambda n: self._distance(n.position, pos))\n\n    # --------- Parent selection via LOS to ancestors ---------\n\n    def _choose_ancestor_parent(self, nearest, new_pos, obstacles, is_3d):\n        best_parent = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        steps = 0\n        cur = nearest\n        while cur is not None and steps < self.los_lookback_depth:\n            if not self._is_edge_in_obstacle(cur.position, new_pos, obstacles, is_3d):\n                cand_cost = cur.cost + self._distance(cur.position, new_pos)\n                if cand_cost < best_cost:\n                    best_cost = cand_cost\n                    best_parent = cur\n            cur = cur.parent\n            steps += 1\n        return best_parent\n\n    # --------- Connect attempt ---------\n\n    def _attempt_connect(self, tree, grid, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest_by_grid(tree, grid, target_pos, is_3d)\n        if nearest is None:\n            return None\n\n        current = nearest\n        for _ in range(self.connect_steps_limit):\n            step_pos = self._steer(current.position, target_pos)\n            if not self._within_bounds(step_pos, bounds):\n                return None\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                return None\n\n            # If close enough to target and direct edge exists, finalize with exact target node\n            if self._distance(step_pos, target_pos) <= 1e-6 or (\n                self._distance(step_pos, target_pos) <= self.step_size and\n                not self._is_edge_in_obstacle(step_pos, target_pos, obstacles, is_3d) and\n                not self._is_in_obstacle(target_pos, obstacles, is_3d)\n            ):\n                # Add intermediate step node if it is not exactly current\n                if self._distance(current.position, step_pos) > 1e-9:\n                    if not self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                        new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n                        current.add_child(new_node)\n                        tree.append(new_node)\n                        nodes.append(new_node)\n                        edges.append((current, new_node))\n                        self._grid_insert(grid, new_node, is_3d)\n                        current = new_node\n                    else:\n                        # If duplicate exists, try using current as is\n                        pass\n                # Add final node at the exact target position to guarantee path merge\n                final_node = Node(target_pos, parent=current, cost=current.cost + self._distance(current.position, target_pos))\n                current.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((current, final_node))\n                self._grid_insert(grid, final_node, is_3d)\n                return final_node\n\n            # Regular step addition with duplicate suppression\n            if self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                # Progress is negligible; stop trying to avoid loops\n                return None\n\n            new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node, is_3d)\n            current = new_node\n\n        return None\n\n    # --------- Collision Checking ---------\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d):\n        distance = self._distance(from_pos, to_pos)\n        resolution = max(0.5, min(1.0, self.step_size * 0.5))\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    # --------- Shortcut Smoothing (bounded) ---------\n\n    def _shortcut_path(self, path, obstacles, is_3d, attempts=40):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        n = len(pts)\n        tries = 0\n        i = 0\n        # Greedy forward skipping with bounded iterations\n        while i < len(pts) - 2 and tries < attempts:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                    # Remove intermediates\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n            tries += 1\n        return pts",
        "objective": -28.86257,
        "time_improvement": 43.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 1410.0,
        "node_improvement": 90.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.03400664329528809,
                "num_nodes_avg": 52.1,
                "path_length_avg": 171.51876006638196,
                "smoothness_avg": 0.050501544373221775,
                "success_improvement": 0.0,
                "time_improvement": -33.36568499023374,
                "node_improvement": 86.87987912364643,
                "length_improvement": 5.987849718937115,
                "smoothness_improvement": 690.45883529979,
                "objective_score": -2.964701489208901
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.030187082290649415,
                "num_nodes_avg": 92.2,
                "path_length_avg": 234.31486940525366,
                "smoothness_avg": 0.08620583217892899,
                "success_improvement": 0.0,
                "time_improvement": 81.1563136658539,
                "node_improvement": 93.8050124302896,
                "length_improvement": 21.77895221296278,
                "smoothness_improvement": 2118.138153515002,
                "objective_score": 48.004956195108846
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.009754443168640136,
                "num_nodes_avg": 73.2,
                "path_length_avg": 124.45355479806292,
                "smoothness_avg": 0.11960663519260235,
                "success_improvement": 0.0,
                "time_improvement": 80.11393158758125,
                "node_improvement": 90.69294342021614,
                "length_improvement": 17.343874744565582,
                "smoothness_improvement": 1421.3875712064366,
                "objective_score": 41.54744217904591
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "GB-RRT* Connect with bounded rewiring and informed goal bias: a bidirectional, RRT*-style planner that alternates growing start/goal trees using k-nearest best-parent selection and local rewiring, uses goal/informed sampling for fast convergence, caches edge checks, and applies shortcut smoothing; it lazily bridges trees without duplicating meeting nodes and limits post-solution optimization for efficiency.",
        "planning_mechanism": "Alternate expanding the two trees toward informed/goal-biased samples; for each new node, pick the lowest-cost collision-free parent among k nearest neighbors, rewire locally with cost propagation, and attempt a short greedy connection to the opposite tree. Upon first connection, switch to ellipsoidal informed sampling and continue for a bounded number of iterations or until no improvement. Edge checks are cached; final path is shortcut-smoothed before returning.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        neighbor_k: int = 18,\n        time_limit_sec: float = 30.0,\n        goal_bias: float = 0.10,\n        post_opt_iters: int = 300,\n        no_improve_limit: int = 120,\n        smooth_iters: int = 120\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_k = neighbor_k\n        self.time_limit_sec = time_limit_sec\n        self.goal_bias = goal_bias\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.smooth_iters = smooth_iters\n\n        self._edge_cache = {}\n        self._edge_cache_limit = 50000\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n        success = False\n        best_path = []\n        best_cost = float(\"inf\")\n\n        # Early infeasible start/goal\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early direct connection\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d):\n            return PlannerResult(True, [start, goal], [Node(start), Node(goal)], [(Node(start), Node(goal))])\n\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        c_min = self._dist(start, goal)\n        start_time = self._now()\n\n        # RRT* neighborhood parameters\n        gamma_rrt = 60.0\n        max_radius = max(bounds) * 0.20\n        min_radius = max(self.step_size * 1.5, 5.0)\n\n        # Post-optimization bookkeeping\n        found_solution = False\n        post_iter = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            if self._now() - start_time > self.time_limit_sec:\n                break\n\n            # Alternate growing sides\n            if it % 2 == 0:\n                grow_tree, other_tree = tree_a, tree_b\n                a_is_start_side = True\n            else:\n                grow_tree, other_tree = tree_b, tree_a\n                a_is_start_side = False\n\n            # Sample with goal/informed bias\n            sample = self._sample_informed(start, goal, best_cost, c_min, bounds, obstacles, is_3d, found_solution)\n\n            # Extend grow_tree\n            a_near = self._nearest(grow_tree, sample)\n            a_new_pos = self._steer(a_near.position, sample, self.step_size)\n            if (not self._in_bounds(a_new_pos, bounds)) or self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                if found_solution:\n                    post_iter += 1\n                    no_improve += 1\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve >= self.no_improve_limit):\n                    break\n                continue\n            if self._is_edge_in_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                if found_solution:\n                    post_iter += 1\n                    no_improve += 1\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve >= self.no_improve_limit):\n                    break\n                continue\n\n            # Insert with best-parent among k-nearest inside adaptive radius\n            r_n = self._neighbor_radius(len(grow_tree), dim, gamma_rrt, min_radius, max_radius)\n            a_new, a_neigh = self._add_with_best_parent(grow_tree, nodes, edges, a_new_pos, obstacles, is_3d, r_n)\n            if a_new is None:\n                if found_solution:\n                    post_iter += 1\n                    no_improve += 1\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve >= self.no_improve_limit):\n                    break\n                continue\n\n            # Local rewiring around the inserted node with cost propagation\n            self._rewire_from(a_new, a_neigh, edges, obstacles, is_3d)\n\n            # Try short greedy connection from other_tree to a_new\n            connected_b = self._greedy_connect(other_tree, a_new.position, nodes, edges, obstacles, is_3d, dim, gamma_rrt, min_radius, max_radius, max_steps=3)\n\n            # Attempt final bridge if close\n            candidate_path = None\n            if connected_b is not None:\n                if self._dist(connected_b.position, a_new.position) <= self.step_size and not self._is_edge_in_obstacle(connected_b.position, a_new.position, obstacles, is_3d):\n                    # Add a visual bridge edge without altering parents (lazy bridge)\n                    edges.append((connected_b, a_new))\n                    # Stitch paths for evaluation\n                    path_a = a_new.path_from_root()\n                    path_b = connected_b.path_from_root()\n                    merged = path_a + path_b[-2::-1] if (path_a and path_b and path_a[-1] == path_b[-1]) else path_a + path_b[::-1]\n                    candidate_path = merged if a_is_start_side else merged[::-1]\n\n            if candidate_path:\n                cand_cost = self._path_cost(candidate_path)\n                if cand_cost + 1e-9 < best_cost:\n                    best_cost = cand_cost\n                    best_path = candidate_path\n                    success = True\n                    found_solution = True\n                    post_iter = 0\n                    no_improve = 0\n                else:\n                    if found_solution:\n                        post_iter += 1\n                        no_improve += 1\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve >= self.no_improve_limit):\n                    break\n            else:\n                if found_solution:\n                    post_iter += 1\n                    no_improve += 1\n                if found_solution and (post_iter >= self.post_opt_iters or no_improve >= self.no_improve_limit):\n                    break\n\n        # Final smoothing\n        if success and len(best_path) >= 2:\n            best_path = self._shortcut_smooth(best_path, obstacles, is_3d, self.smooth_iters)\n\n        return PlannerResult(success, best_path if success else [], nodes, edges)\n\n    # ---------- Geometry / Utility ----------\n    def _now(self):\n        return time.time()\n\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _in_bounds(self, p, bounds):\n        for d in range(len(bounds)):\n            if p[d] < 0.0 or p[d] > bounds[d]:\n                return False\n        return True\n\n    def _nearest(self, tree, pt):\n        return min(tree, key=lambda n: self._dist(n.position, pt))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _neighbor_radius(self, n_nodes, dim, gamma, rmin, rmax):\n        if n_nodes < 2:\n            return rmin\n        val = gamma * ((math.log(n_nodes) / n_nodes) ** (1.0 / dim))\n        return max(rmin, min(rmax, val))\n\n    def _k_nearest_within(self, tree, pos, k, radius):\n        # Filter by radius then choose up to k nearest\n        pairs = []\n        for nd in tree:\n            d = self._dist(nd.position, pos)\n            if d <= radius:\n                pairs.append((d, nd))\n        if not pairs:\n            return []\n        pairs.sort(key=lambda x: x[0])\n        return [nd for _, nd in pairs[:min(k, len(pairs))]]\n\n    def _add_with_best_parent(self, tree, nodes, edges, new_pos, obstacles, is_3d, radius):\n        # Parent candidates among k-nearest inside radius; ensure edge collision free\n        neigh = self._k_nearest_within(tree, new_pos, self.neighbor_k, radius)\n        if not neigh:\n            # fallback to nearest\n            neigh = [self._nearest(tree, new_pos)]\n        parent_candidates = [nb for nb in neigh if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d)]\n        if not parent_candidates:\n            return None, []\n        best_parent = min(parent_candidates, key=lambda nb: nb.cost + self._dist(nb.position, new_pos))\n        new_node = Node(new_pos, parent=None, cost=best_parent.cost + self._dist(best_parent.position, new_pos))\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neigh\n\n    def _rewire_from(self, pivot, neigh, edges, obstacles, is_3d):\n        for nb in neigh:\n            if nb is pivot:\n                continue\n            if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                continue\n            new_cost = pivot.cost + self._dist(pivot.position, nb.position)\n            if new_cost + 1e-12 < nb.cost:\n                old_parent = nb.parent\n                if old_parent is not None:\n                    # Remove old edge if present\n                    try:\n                        edges.remove((old_parent, nb))\n                    except ValueError:\n                        pass\n                    try:\n                        old_parent.children.remove(nb)\n                    except ValueError:\n                        pass\n                pivot.add_child(nb)\n                nb.cost = new_cost\n                edges.append((pivot, nb))\n                self._propagate_cost_from(nb, edges)\n\n    def _propagate_cost_from(self, node, edges):\n        # Update costs in subtree after rewiring\n        queue = [node]\n        while queue:\n            cur = queue.pop(0)\n            for ch in cur.children:\n                new_c = cur.cost + self._dist(cur.position, ch.position)\n                if abs(new_c - ch.cost) > 1e-12:\n                    ch.cost = new_c\n                    queue.append(ch)\n\n    def _greedy_connect(self, tree, target_pos, nodes, edges, obstacles, is_3d, dim, gamma_rrt, rmin, rmax, max_steps=3):\n        current = self._nearest(tree, target_pos)\n        steps = 0\n        last_new = None\n        while steps < max_steps:\n            steps += 1\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                break\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                break\n            radius = self._neighbor_radius(len(tree), dim, gamma_rrt, rmin, rmax)\n            new_node, neigh = self._add_with_best_parent(tree, nodes, edges, step_pos, obstacles, is_3d, radius)\n            if new_node is None:\n                break\n            self._rewire_from(new_node, neigh, edges, obstacles, is_3d)\n            current = new_node\n            last_new = new_node\n            if self._dist(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    def _path_cost(self, path):\n        total = 0.0\n        for i in range(len(path) - 1):\n            total += self._dist(path[i], path[i + 1])\n        return total\n\n    # ---------- Sampling ----------\n    def _sample_informed(self, start, goal, c_best, c_min, bounds, obstacles, is_3d, have_solution):\n        dim = len(bounds)\n        # Try a few times to avoid sampling inside obstacles\n        for _ in range(50):\n            if not have_solution or c_best == float(\"inf\") or c_min <= 1e-12:\n                # Pre-solution: goal bias\n                if random.random() < self.goal_bias:\n                    sample = goal\n                else:\n                    sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            else:\n                # Post-solution: informed ellipsoidal sampling with some uniform escape\n                if random.random() < 0.80:\n                    sample = self._sample_ellipsoid(start, goal, c_best, c_min, bounds)\n                else:\n                    sample = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            if self._in_bounds(sample, bounds) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                return sample\n        # Fallback uniform\n        return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n    def _sample_ellipsoid(self, start, goal, c_best, c_min, bounds):\n        dim = len(bounds)\n        center = tuple((s + g) / 2.0 for s, g in zip(start, goal))\n        a1 = tuple((goal[d] - start[d]) / (c_min if c_min > 1e-12 else 1.0) for d in range(dim))\n        r1 = c_best / 2.0\n        r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n        r_other = math.sqrt(r_other_sq) / 2.0\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r_other)\n        else:\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._normalize(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._normalize(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r_other, r_other)\n        u = self._sample_unit_ball(dim)\n        mapped = []\n        for d in range(dim):\n            val = center[d]\n            for i in range(dim):\n                val += basis[i][d] * radii[i] * u[i]\n            # Clamp to bounds\n            val = min(max(val, 0.0), bounds[d])\n            mapped.append(val)\n        return tuple(mapped)\n\n    def _sample_unit_ball(self, dim):\n        # Gaussian direction + radius^(1/d)\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(x * x for x in v))\n            if n > 1e-12:\n                v = [x / n for x in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for x, y, z, w, h, d in obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for x, y, w, h in obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        # Direction-agnostic key with rounding to reduce duplicates\n        ra = tuple(round(c, 2) for c in a)\n        rb = tuple(round(c, 2) for c in b)\n        return (ra, rb) if ra <= rb else (rb, ra)\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        key = self._edge_key(from_pos, to_pos)\n        hit = self._edge_cache.get(key, None)\n        if hit is not None:\n            return hit\n        distance = self._dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                self._edge_cache[key] = True\n                if len(self._edge_cache) > self._edge_cache_limit:\n                    self._edge_cache.clear()\n                return True\n        self._edge_cache[key] = False\n        if len(self._edge_cache) > self._edge_cache_limit:\n            self._edge_cache.clear()\n        return False\n\n    # ---------- Smoothing ----------\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d):\n                # Shortcut\n                new_pts = pts[:i + 1] + pts[j:]\n                pts = new_pts\n                n = len(pts)\n        return pts",
        "objective": 23.10764,
        "time_improvement": -139.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1239.0,
        "node_improvement": 31.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.13042638301849366,
                "num_nodes_avg": 488.2,
                "path_length_avg": 150.21700760008898,
                "smoothness_avg": 0.03945954965394641,
                "success_improvement": 0.0,
                "time_improvement": -411.50017251100286,
                "node_improvement": -22.941324603374454,
                "length_improvement": 17.663677793580806,
                "smoothness_improvement": 517.6276398678153,
                "objective_score": -110.2637068778133
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.08705599308013916,
                "num_nodes_avg": 504.4,
                "path_length_avg": 233.63485048296306,
                "smoothness_avg": 0.08420769273445602,
                "success_improvement": 0.0,
                "time_improvement": 45.6570260313673,
                "node_improvement": 66.10898340388363,
                "length_improvement": 22.005962102482787,
                "smoothness_improvement": 2066.7245864070437,
                "objective_score": 37.23430800293508
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.07347123622894287,
                "num_nodes_avg": 396.5,
                "path_length_avg": 117.99846302312123,
                "smoothness_avg": 0.09690125523828255,
                "success_improvement": 0.0,
                "time_improvement": -49.783437632906015,
                "node_improvement": 49.586776859504134,
                "length_improvement": 21.63103934304284,
                "smoothness_improvement": 1132.5768141243043,
                "objective_score": 3.7064763865754218
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "Adaptive Goal-Biased Grid BiRRT (AG-GBiRRT): a simplified, robust bidirectional RRT with commit-only connection, grid-accelerated nearest search, and light post-connection shortcut smoothing. It alternates growing two trees, uses uniform-with-goal-bias sampling, single-step steering with strict node/edge collision checks, and an early straight-line test. Upon any successful bridge between trees, it extracts the path and performs a few inexpensive shortcuts for smoothness, returning quickly without extra rewiring or bloat.",
        "planning_mechanism": "Mechanism: alternate start/goal tree expansion; sample (goal-biased), find nearest via grid, steer one step, validate node and edge, add node and edge, attempt a direct, collision-free bridge to the opposite tree (commit-only); on success, extract [start\u2192\u2026\u2192meetA, meetB\u2192\u2026\u2192goal] and run brief shortcut smoothing; terminate on success or iteration budget.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.0)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                continue\n\n            # Insert node (both node and edge validated)\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Try commit-only direct connection to the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None:\n                if not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, other_near)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        try:\n            return self._lcg_next()\n        except:\n            return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Sampling ----------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ---------- Grid nearest ----------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # ---------- Path ----------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # path_a ends at meet_a; we then go straight to meet_b and up to other root\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            # pick two indices i < j with at least one point between\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
        "objective": -32.96764,
        "time_improvement": 69.0,
        "length_improvement": 11.0,
        "smoothness_improvement": 1142.0,
        "node_improvement": 82.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.01299290657043457,
                "num_nodes_avg": 78.8,
                "path_length_avg": 167.86786188508313,
                "smoothness_avg": 0.03825680999831742,
                "success_improvement": 0.0,
                "time_improvement": 49.04501835909778,
                "node_improvement": 80.15613195668597,
                "length_improvement": 7.988964864290817,
                "smoothness_improvement": 498.8021524662562,
                "objective_score": 22.000895188635106
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.02625594139099121,
                "num_nodes_avg": 208.9,
                "path_length_avg": 244.3021244779086,
                "smoothness_avg": 0.07331771296729457,
                "success_improvement": 0.0,
                "time_improvement": 83.61025026480232,
                "node_improvement": 85.96385137405093,
                "length_improvement": 18.444919002512343,
                "smoothness_improvement": 1786.5175632625994,
                "objective_score": 45.082614297261095
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.01305999755859375,
                "num_nodes_avg": 163.0,
                "path_length_avg": 140.27860161008172,
                "smoothness_avg": 0.09759083301298958,
                "success_improvement": 0.0,
                "time_improvement": 73.37500455677744,
                "node_improvement": 79.27527018436109,
                "length_improvement": 6.833632159773637,
                "smoothness_improvement": 1141.348192519241,
                "objective_score": 31.819421625493614
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "Bi-Informed Dual-Tree RRT*-Connect with Adaptive Neighborhoods and Shortcut Smoothing: a bidirectional planner that alternates growing optimized trees from start and goal, uses adaptive near-radius rewiring, informed rejection sampling after the first solution, and a connection step akin to RRT-Connect, followed by fast shortcut smoothing.",
        "planning_mechanism": "Mechanism: alternate tree expansion with goal-biased, bounds-respecting sampling; steer a step, validate node and edge, choose the lowest-cost parent among adaptive-radius neighbors, rewire and propagate costs; attempt to connect to the opposite tree via progressive extensions; upon any feasible join, update the incumbent cost and restrict future samples to the prolate hyperspheroid defined by start, goal, and best cost; terminate after a post-optimization budget or stagnation and return a smoothed path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=5.0,\n                 base_radius=25.0,\n                 min_radius=6.0,\n                 goal_bias=0.12,\n                 post_opt_iters=800,\n                 max_no_improve=200,\n                 smoothing_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.goal_bias = goal_bias\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_cell = max(self.step_size, self.base_radius * 0.5)\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root, grid_cell)\n        self._grid_add(grid_goal, goal_root, grid_cell)\n\n        success = False\n        best_cost = float('inf')\n        best_join = (None, None)\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        for it in range(self.max_iter):\n            active_first = (it % 2 == 0)\n            for which in (0, 1):\n                tree_a = start_tree if (active_first ^ (which == 1)) else goal_tree\n                tree_b = goal_tree if (tree_a is start_tree) else start_tree\n                grid_a = grid_start if (tree_a is start_tree) else grid_goal\n                grid_b = grid_goal if (tree_b is goal_tree) else grid_start\n\n                x_rand = self._sample(start, goal, best_cost, is_3d)\n                if self._rand() < self.goal_bias:\n                    x_rand = goal if (tree_a is start_tree) else start\n\n                x_nearest = self._nearest_grid(grid_a, tree_a, x_rand, grid_cell)\n                x_new_pos = self._steer(x_nearest.position, x_rand, self.step_size)\n\n                if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n                    continue\n                if self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n                    continue\n\n                x_new = Node(x_new_pos)\n                n_nodes = len(tree_a) + 1\n                r_near = self._adaptive_radius(n_nodes)\n                near_nodes = self._near_grid(grid_a, x_new_pos, r_near, grid_cell)\n\n                best_parent = x_nearest\n                best_pc = x_nearest.cost + self._dist(x_nearest.position, x_new_pos)\n                for nn in near_nodes:\n                    cand_cost = nn.cost + self._dist(nn.position, x_new_pos)\n                    if cand_cost < best_pc and not self._is_edge_in_obstacle(nn.position, x_new_pos, obstacles, is_3d):\n                        best_parent = nn\n                        best_pc = cand_cost\n\n                best_parent.add_child(x_new)\n                x_new.cost = best_pc\n                tree_a.append(x_new)\n                nodes.append(x_new)\n                edges.append((best_parent, x_new))\n                self._grid_add(grid_a, x_new, grid_cell)\n\n                for nn in near_nodes:\n                    alt = x_new.cost + self._dist(x_new.position, nn.position)\n                    if alt + 1e-12 < nn.cost and not self._is_edge_in_obstacle(x_new.position, nn.position, obstacles, is_3d):\n                        op = nn.parent\n                        if op is not None:\n                            try:\n                                edges.remove((op, nn))\n                            except:\n                                pass\n                            try:\n                                op.children.remove(nn)\n                            except:\n                                pass\n                        x_new.add_child(nn)\n                        nn.cost = alt\n                        edges.append((x_new, nn))\n                        self._propagate_costs_from(nn, edges)\n\n                connect_success, meet_a, meet_b = self._connect_trees(x_new, tree_b, grid_b, obstacles, is_3d, grid_cell, nodes, edges)\n                if connect_success:\n                    path_cost = meet_a.cost + self._dist(meet_a.position, meet_b.position) + meet_b.cost\n                    if path_cost + 1e-12 < best_cost:\n                        best_cost = path_cost\n                        best_join = (meet_a, meet_b)\n                        success = True\n                        found_first = True\n                        post_iters = 0\n                        no_improve = 0\n                    else:\n                        if found_first:\n                            post_iters += 1\n                            no_improve += 1\n                else:\n                    if found_first:\n                        post_iters += 1\n                        no_improve += 1\n\n                if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                    break\n            if found_first and (post_iters >= self.post_opt_iters or no_improve >= self.max_no_improve):\n                break\n\n        path = []\n        if success and best_join[0] is not None:\n            path = self._extract_path(best_join[0], best_join[1])\n            path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _rand(self):\n        try:\n            return random.random()\n        except:\n            # fallback LCG if random unavailable\n            if not hasattr(self, \"_lcg_state\"):\n                self._lcg_state = 1234567\n            self._lcg_state = (1103515245 * self._lcg_state + 12345) % (1 << 31)\n            return (self._lcg_state / float(1 << 31))\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = (a[i] - b[i])\n            s += d * d\n        return s ** 0.5\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        ratio = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(self.dim))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=1.0):\n        d = self._dist(a, b)\n        steps = int(d / resolution)\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _sample(self, start, goal, c_best, is_3d):\n        for _ in range(50):\n            p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n            if c_best < float('inf'):\n                if self._dist(p, start) + self._dist(p, goal) <= c_best and self._in_bounds(p):\n                    return p\n            else:\n                if self._in_bounds(p):\n                    return p\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _adaptive_radius(self, n):\n        if n <= 1:\n            return max(self.min_radius, self.base_radius)\n        r = self.base_radius * (n ** (-1.0 / max(2, self.dim)))\n        if r < self.min_radius:\n            r = self.min_radius\n        return r\n\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        key = self._grid_key(node.position, cell)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_gather(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos, cell):\n        # Expand rings until any candidates are found; fallback to linear scan\n        rng = 0\n        best = None\n        bestd = float('inf')\n        while rng < 6:\n            radius = (rng + 1) * cell\n            cand = self._grid_gather(grid, pos, radius, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                return best\n            rng += 1\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_grid(self, grid, pos, radius, cell):\n        cand = self._grid_gather(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _connect_trees(self, node_a, tree_b, grid_b, obstacles, is_3d, cell, nodes, edges):\n        target = node_a.position\n        nnear = self._nearest_grid(grid_b, tree_b, target, cell)\n        current = nnear\n        last_new = None\n        max_steps = int((self._dist(current.position, target) / self.step_size)) + 2\n        for _ in range(max_steps):\n            new_pos = self._steer(current.position, target, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False, None, None\n            if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                return False, None, None\n            new_node = Node(new_pos)\n            new_node.cost = current.cost + self._dist(current.position, new_pos)\n            current.add_child(new_node)\n            tree_b.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_add(grid_b, new_node, cell)\n            last_new = new_node\n            current = new_node\n            if self._dist(current.position, target) <= self.step_size and not self._is_edge_in_obstacle(current.position, target, obstacles, is_3d):\n                meet_b = current\n                meet_a = node_a\n                return True, meet_a, meet_b\n        if last_new is not None and self._dist(last_new.position, target) <= self.step_size and not self._is_edge_in_obstacle(last_new.position, target, obstacles, is_3d):\n            return True, node_a, last_new\n        return False, None, None\n\n    def _path_to_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        path.reverse()\n        return path\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        # meet_b is on the tree rooted at goal; follow parents to goal\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # path_a ends at meet_a; path_b starts at meet_b; edge between them is implicit\n        return path_a + path_b\n\n    def _propagate_costs_from(self, node, edges):\n        q = []\n        for c in node.children:\n            q.append(c)\n        while q:\n            u = q.pop(0)\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                q.append(c)\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                new_pts = pts[:i + 1] + pts[j:]\n                pts = new_pts\n                n = len(pts)\n        return pts",
        "objective": 13.17506,
        "time_improvement": -100.0,
        "length_improvement": 18.0,
        "smoothness_improvement": 1141.0,
        "node_improvement": -19.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.04533350467681885,
                "num_nodes_avg": 475.2,
                "path_length_avg": 160.00839630243624,
                "smoothness_avg": 0.03538840033717765,
                "success_improvement": 0.0,
                "time_improvement": -77.78684746193773,
                "node_improvement": -19.66759002770082,
                "length_improvement": 12.296862491341491,
                "smoothness_improvement": 453.90531241814347,
                "objective_score": -13.688410181685704
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.14875941276550292,
                "num_nodes_avg": 1244.7,
                "path_length_avg": 229.2684850165445,
                "smoothness_avg": 0.07592744364942347,
                "success_improvement": 0.0,
                "time_improvement": 7.13989227527299,
                "node_improvement": 16.367667808909488,
                "length_improvement": 23.463580574034797,
                "smoothness_improvement": 1853.6678134268077,
                "objective_score": 25.48845509413681
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.1614241361618042,
                "num_nodes_avg": 1203.4,
                "path_length_avg": 120.8833554675142,
                "smoothness_avg": 0.09548517805346257,
                "success_improvement": 0.0,
                "time_improvement": -229.0901755878243,
                "node_improvement": -53.00699300699302,
                "length_improvement": 19.715031145292965,
                "smoothness_improvement": 1114.5644168573392,
                "objective_score": -51.32521190488481
            }
        ],
        "success_rate": 1.0
    }
]