[
    {
        "operator": "path_expert",
        "algorithm_description": "IB-PRM*A: Informed Batch PRM* with Lazy A* and path-corridor densification. The planner builds a progressively densified PRM focused in an informed ellipsoid after the first solution and near the current path corridor, while searching the implicit graph with a lazy A* that validates only edges actually needed. All node/edge additions are collision-checked, edges are cached without lossy quantization, and the final path is shortcut-smoothed for minimal length.",
        "planning_mechanism": "Mechanism: iterate over batches; sample collision-free points (uniform pre-solution, then mostly inside the ellipsoid and near the best path), connect each new point to many k-nearest neighbors within an adaptive radius as candidate edges, and run Euclidean-heuristic A* that lazily tests and commits edges on relaxation. Keep the shortest found path, shrink the ellipsoid, densify around that path, and return a smoothed minimum-length path discovered within limits.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=float(\"inf\")):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        time_limit_sec: float = 15.0,\n        batch_size: int = 250,\n        max_batches: int = 40,\n        neighbor_k_max: int = 48,\n        goal_bias: float = 0.10,\n        corridor_bias: float = 0.30,\n        informed_bias: float = 0.60,\n        smooth_iters: int = 200,\n        min_radius: float = 4.0,\n        max_radius_factor: float = 0.25,\n        edge_resolution: float = 0.5,\n        no_improve_batches: int = 8\n    ):\n        self.time_limit_sec = time_limit_sec\n        self.batch_size = batch_size\n        self.max_batches = max_batches\n        self.neighbor_k_max = neighbor_k_max\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.smooth_iters = smooth_iters\n        self.min_radius = min_radius\n        self.max_radius_factor = max_radius_factor\n        self.edge_resolution = edge_resolution\n        self.no_improve_batches = no_improve_batches\n\n        self._edge_cache = {}\n        self._edge_cache_limit = 200000\n\n    def plan(self, map):\n        start_time = self._now()\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n\n        # Early invalid start/goal\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight connection\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_resolution):\n            n0 = Node(start, parent=None, cost=0.0)\n            n1 = Node(goal, parent=n0, cost=self._dist(start, goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # Initialize sample set and nodes\n        positions = [start, goal]\n        nodes = [Node(start, parent=None, cost=0.0), Node(goal)]\n        start_idx, goal_idx = 0, 1\n\n        # Candidate adjacency (index -> set of neighbor indices)\n        cand_adj = {0: set(), 1: set()}\n        # Validated edge cache at index level: (min(i,j), max(i,j)) -> True/False\n        validated_edges = {}\n\n        # Best solution tracking\n        best_path = []\n        best_cost = float(\"inf\")\n        success = False\n        c_min = self._dist(start, goal)\n        no_improve_count = 0\n\n        # Radius parameters\n        max_radius = max(bounds) * self.max_radius_factor\n        gamma_rrg = max(bounds) * 0.75  # broad initial connection envelope\n\n        batch_id = 0\n        while batch_id < self.max_batches:\n            if self._now() - start_time > self.time_limit_sec:\n                break\n            batch_id += 1\n\n            # Generate a batch of collision-free samples\n            new_indices = []\n            attempts = 0\n            target_new = self.batch_size\n            while len(new_indices) < target_new and attempts < target_new * 20:\n                attempts += 1\n                sample = self._sample(positions, start, goal, best_cost, c_min, bounds, obstacles, is_3d, bool(success))\n                if (not self._in_bounds(sample, bounds)) or self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n                positions.append(sample)\n                nodes.append(Node(sample))\n                idx = len(positions) - 1\n                cand_adj[idx] = set()\n                new_indices.append(idx)\n\n                # Connect to k-nearest within adaptive radius (candidate only; validate lazily)\n                r_n = self._neighbor_radius(len(positions), dim, gamma_rrg, self.min_radius, max_radius)\n                neigh = self._k_nearest_within(positions, idx, self.neighbor_k_max, r_n)\n                for j in neigh:\n                    if j == idx:\n                        continue\n                    cand_adj[idx].add(j)\n                    cand_adj[j].add(idx)\n\n            # Run Lazy A* over candidate graph\n            path_idx = self._lazy_a_star(start_idx, goal_idx, positions, cand_adj, validated_edges, nodes, edges, obstacles, is_3d)\n            if path_idx:\n                path_positions = [positions[i] for i in path_idx]\n                cost = self._path_cost(path_positions)\n                if cost + 1e-9 < best_cost:\n                    best_cost = cost\n                    best_path = path_positions\n                    success = True\n                    no_improve_count = 0\n                    # Update tree parents along best path\n                    self._assign_chain_parents(nodes, path_idx)\n                else:\n                    no_improve_count += 1\n            else:\n                no_improve_count += 1\n\n            if success and no_improve_count >= self.no_improve_batches:\n                break\n            if self._now() - start_time > self.time_limit_sec:\n                break\n\n        # Final smoothing\n        if success and len(best_path) >= 2:\n            best_path = self._shortcut_smooth(best_path, obstacles, is_3d, self.smooth_iters)\n\n        return PlannerResult(success, best_path if success else [], nodes, edges)\n\n    # ---------- Core search ----------\n    def _lazy_a_star(self, start_idx, goal_idx, positions, cand_adj, validated_edges, nodes, edges, obstacles, is_3d):\n        n = len(positions)\n        g = [float(\"inf\")] * n\n        parent = [-1] * n\n        open_set = set([start_idx])\n        g[start_idx] = 0.0\n\n        def h(i):\n            return self._dist(positions[i], positions[goal_idx])\n\n        # Use list for priority; select min f each iteration\n        frontier = [start_idx]\n        in_frontier = {start_idx}\n\n        while frontier:\n            # pick node with min f = g + h\n            u = min(frontier, key=lambda i: g[i] + h(i))\n            frontier.remove(u)\n            in_frontier.discard(u)\n\n            if u == goal_idx:\n                # reconstruct\n                return self._reconstruct(parent, goal_idx)\n\n            for v in list(cand_adj[u]):\n                if g[u] == float(\"inf\"):\n                    continue\n                key = (u, v) if u < v else (v, u)\n                valid = validated_edges.get(key, None)\n                if valid is None:\n                    # Validate lazily now\n                    pu = positions[u]\n                    pv = positions[v]\n                    if self._is_edge_in_obstacle(pu, pv, obstacles, is_3d, self.edge_resolution):\n                        validated_edges[key] = False\n                        # prune candidate to save time later\n                        cand_adj[u].discard(v)\n                        cand_adj[v].discard(u)\n                        continue\n                    else:\n                        validated_edges[key] = True\n                        # record coherent edge only once\n                        if not self._edge_exists(nodes[u], nodes[v], edges):\n                            edges.append((nodes[u], nodes[v]))\n                elif not valid:\n                    continue\n\n                tentative = g[u] + self._dist(positions[u], positions[v])\n                if tentative + 1e-12 < g[v]:\n                    g[v] = tentative\n                    parent[v] = u\n                    if v not in in_frontier:\n                        frontier.append(v)\n                        in_frontier.add(v)\n        return None\n\n    def _reconstruct(self, parent, goal_idx):\n        path_idx = []\n        cur = goal_idx\n        while cur != -1:\n            path_idx.append(cur)\n            cur = parent[cur]\n        path_idx.reverse()\n        return path_idx\n\n    def _assign_chain_parents(self, nodes, path_idx):\n        # Reset parents/children along best path\n        for nd in nodes:\n            nd.children = []\n        for i in range(len(path_idx)):\n            idx = path_idx[i]\n            nd = nodes[idx]\n            if i == 0:\n                nd.parent = None\n                nd.cost = 0.0\n            else:\n                prev = nodes[path_idx[i - 1]]\n                nd.parent = prev\n                prev.children.append(nd)\n                nd.cost = prev.cost + self._dist(prev.position, nd.position)\n\n    # ---------- Sampling ----------\n    def _sample(self, positions, start, goal, c_best, c_min, bounds, obstacles, is_3d, have_solution):\n        dim = len(bounds)\n        # goal bias pre-solution\n        if not have_solution:\n            if self._rand() < self.goal_bias:\n                return goal\n            return tuple(self._rand_uniform(0.0, bounds[d]) for d in range(dim))\n        # Post-solution mixture: informed ellipsoid, path-corridor, and uniform escape\n        r = self._rand()\n        if r < self.informed_bias:\n            return self._sample_ellipsoid(start, goal, c_best, c_min, bounds)\n        elif r < self.informed_bias + self.corridor_bias and len(positions) >= 2:\n            # sample near the current best path endpoints start-goal line as a proxy for corridor\n            # pick a point along the line segment start->goal, then add small orthogonal jitter\n            t = self._rand()\n            base = tuple(start[d] + t * (goal[d] - start[d]) for d in range(dim))\n            # jitter magnitude proportional to (c_best - c_min)\n            slack = max(c_best - c_min, 0.0)\n            sigma = (0.1 + 0.15 * self._sigmoid(min(slack / (c_min + 1e-9), 3.0))) * max(bounds)\n            if dim == 2:\n                # orthogonal vector\n                dx = goal[0] - start[0]\n                dy = goal[1] - start[1]\n                nrm = (dx * dx + dy * dy) ** 0.5\n                if nrm < 1e-12:\n                    jitter = (self._rand_gauss(0.0, sigma), self._rand_gauss(0.0, sigma))\n                else:\n                    ox, oy = -dy / (nrm + 1e-12), dx / (nrm + 1e-12)\n                    jitter = (ox * self._rand_gauss(0.0, sigma), oy * self._rand_gauss(0.0, sigma))\n                p = (base[0] + jitter[0], base[1] + jitter[1])\n                return tuple(min(max(p[d], 0.0), bounds[d]) for d in range(2))\n            else:\n                # random orthogonal jitter in 3D\n                dirv = self._normalize(tuple(goal[d] - start[d] for d in range(3)))\n                ref = (1.0, 0.0, 0.0) if abs(dirv[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(dirv, ref))\n                b3 = self._cross(dirv, b2)\n                j = self._rand_gauss(0.0, sigma)\n                k = self._rand_gauss(0.0, sigma)\n                p = (base[0] + b2[0] * j + b3[0] * k,\n                     base[1] + b2[1] * j + b3[1] * k,\n                     base[2] + b2[2] * j + b3[2] * k)\n                return tuple(min(max(p[d], 0.0), bounds[d]) for d in range(3))\n        else:\n            return tuple(self._rand_uniform(0.0, bounds[d]) for d in range(dim))\n\n    def _sample_ellipsoid(self, start, goal, c_best, c_min, bounds):\n        dim = len(bounds)\n        if c_best == float(\"inf\") or c_min < 1e-12:\n            return tuple(self._rand_uniform(0.0, bounds[d]) for d in range(dim))\n        center = tuple((s + g) / 2.0 for s, g in zip(start, goal))\n        a1 = self._normalize(tuple((goal[d] - start[d]) for d in range(dim)))\n        r1 = c_best / 2.0\n        r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n        r_other = (r_other_sq ** 0.5) / 2.0\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r_other)\n        else:\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._normalize(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._normalize(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r_other, r_other)\n\n        u = self._sample_unit_ball(dim)\n        mapped = []\n        for d in range(dim):\n            val = center[d]\n            for i in range(dim):\n                val += basis[i][d] * radii[i] * u[i]\n            val = min(max(val, 0.0), bounds[d])\n            mapped.append(val)\n        return tuple(mapped)\n\n    def _sample_unit_ball(self, dim):\n        # Gaussian direction + radius^(1/d)\n        while True:\n            v = [self._rand_gauss(0.0, 1.0) for _ in range(dim)]\n            n = (sum(x * x for x in v)) ** 0.5\n            if n > 1e-12:\n                v = [x / n for x in v]\n                r = self._rand() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    # ---------- Geometry / Neighbor selection ----------\n    def _neighbor_radius(self, n_nodes, dim, gamma, rmin, rmax):\n        if n_nodes < 2:\n            return rmin\n        val = gamma * ((self._log(max(n_nodes, 2)) / max(n_nodes, 2)) ** (1.0 / dim))\n        return max(rmin, min(rmax, val))\n\n    def _k_nearest_within(self, positions, idx, k, radius):\n        pt = positions[idx]\n        pairs = []\n        for j in range(len(positions) - 1):  # only previous nodes\n            d = self._dist(pt, positions[j])\n            if d <= radius:\n                pairs.append((d, j))\n        pairs.sort(key=lambda x: x[0])\n        return [j for _, j in pairs[:min(k, len(pairs))]]\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for x, y, z, w, h, d in obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for x, y, w, h in obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution):\n        key = self._edge_key(from_pos, to_pos)\n        hit = self._edge_cache.get(key, None)\n        if hit is not None:\n            return hit\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / max(resolution, 1e-6)))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                self._edge_cache[key] = True\n                if len(self._edge_cache) > self._edge_cache_limit:\n                    self._edge_cache.clear()\n                return True\n        self._edge_cache[key] = False\n        if len(self._edge_cache) > self._edge_cache_limit:\n            self._edge_cache.clear()\n        return False\n\n    # ---------- Utilities ----------\n    def _edge_exists(self, na, nb, edges):\n        for e in edges:\n            if (e[0] is na and e[1] is nb) or (e[0] is nb and e[1] is na):\n                return True\n        return False\n\n    def _path_cost(self, path):\n        total = 0.0\n        for i in range(len(path) - 1):\n            total += self._dist(path[i], path[i + 1])\n        return total\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._rand_uniform(0, n - 2))\n            j = int(self._rand_uniform(i + 2, n))\n            a = pts[i]\n            b = pts[j - 1]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_resolution):\n                pts = pts[:i + 1] + pts[j - 1:]\n                n = len(pts)\n        return pts\n\n    def _dist(self, a, b):\n        return (sum((a[d] - b[d]) * (a[d] - b[d]) for d in range(len(a)))) ** 0.5\n\n    def _in_bounds(self, p, bounds):\n        for d in range(len(bounds)):\n            if p[d] < 0.0 or p[d] > bounds[d]:\n                return False\n        return True\n\n    def _now(self):\n        return time.time()\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return tuple(0.0 for _ in v)\n        return tuple(x / n for x in v)\n\n    def _norm(self, v):\n        return (sum(x * x for x in v)) ** 0.5\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _sigmoid(self, x):\n        # smooth 0..1 mapping\n        return 1.0 / (1.0 + self._exp(-x))\n\n    def _exp(self, x):\n        # simple exp approximation using built-in pow\n        # pow with base e: e**x; approximate e as 2.718281828\n        return (2.718281828) ** x\n\n    def _log(self, x):\n        # natural log via change of base using built-in math.log if available\n        try:\n            return math.log(x)\n        except:\n            # fallback: series approximation for x near 1 not reliable; keep constant\n            return 1.0\n\n    def _rand(self):\n        return random.random()\n\n    def _rand_uniform(self, a, b):\n        return random.uniform(a, b)\n\n    def _rand_gauss(self, mu, sigma):\n        return random.gauss(mu, sigma)",
        "objective": null,
        "time_improvement": null,
        "length_improvement": null,
        "smoothness_improvement": null,
        "node_improvement": null,
        "other_inf": {
            "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: Planner.__init__() got an unexpected keyword argument 'max_iter'\n"
        }
    },
    {
        "operator": "path_expert",
        "algorithm_description": "IBP-LazyPRM*: Informed Batch PRM with Lazy A* and Structured Shortcutting. It builds a sparse roadmap with goal/informed-biased batches, searches it using lazy A* that validates edges only when necessary, and stitches a cross-tree, collision-validated path. Deterministic and random shortcut passes minimize path length without costly rewiring.",
        "planning_mechanism": "Plan in batches: sample obstacle-free nodes (uniform with goal bias pre-solution, ellipsoidal informed post-solution), index them in a spatial grid, and connect implicitly via k-nearest within an adaptive radius. Run lazy A*: expand by heuristic cost, validating a parent edge only when a node is popped; invalid edges are banned and search continues. Upon the first valid goal path, switch to informed sampling and iterate briefly to improve. Finally, apply deterministic and random shortcut smoothing to minimize path length.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except ValueError:\n            pass\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        time_limit_sec=10.0,\n        max_batches=40,\n        batch_size=200,\n        k_neighbors=16,\n        r_max_ratio=0.15,\n        goal_bias=0.15,\n        no_improve_limit=6,\n        smooth_deterministic=True,\n        smooth_random_iters=150\n    ):\n        self.time_limit_sec = time_limit_sec\n        self.max_batches = max_batches\n        self.batch_size = batch_size\n        self.k_neighbors = k_neighbors\n        self.r_max_ratio = r_max_ratio\n        self.goal_bias = goal_bias\n        self.no_improve_limit = no_improve_limit\n        self.smooth_deterministic = smooth_deterministic\n        self.smooth_random_iters = smooth_random_iters\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        nodes = []\n        edges = []\n        edges_seen = set()\n\n        # Early validation of endpoints\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight-line solution\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d):\n            n0 = Node(start, cost=0.0)\n            n1 = Node(goal, parent=n0, cost=self._dist(start, goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # Initialize roadmap with endpoints\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        nodes.extend([start_node, goal_node])\n\n        # Spatial grid (fixed cell size for stable indexing)\n        longest = max(bounds)\n        cell_size = max(1.0, longest / 40.0)\n        grid = {}\n        self._grid_insert(grid, self._cell_index(start, cell_size), start_node)\n        self._grid_insert(grid, self._cell_index(goal, cell_size), goal_node)\n\n        start_time = self._now()\n        c_min = self._dist(start, goal)\n        c_best = float(\"inf\")\n        best_path = []\n        success = False\n        no_improve = 0\n\n        for b in range(self.max_batches):\n            if self._now() - start_time > self.time_limit_sec:\n                break\n\n            # Adaptive connection radius\n            r_conn = self._connection_radius(len(nodes), dim, bounds)\n            r_conn = min(r_conn, max(bounds) * self.r_max_ratio)\n            r_conn = max(r_conn, cell_size * 1.5)\n\n            # Sampling batch (goal-bias before solution; informed after)\n            have_solution = success and c_best < float(\"inf\")\n            n_added = 0\n            attempts = 0\n            max_attempts = self.batch_size * 8\n            while n_added < self.batch_size and attempts < max_attempts:\n                attempts += 1\n                sample = self._sample(bounds, start, goal, c_best, c_min, have_solution, obstacles, is_3d)\n                if (not self._in_bounds(sample, bounds)) or self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n                node = Node(sample)\n                nodes.append(node)\n                self._grid_insert(grid, self._cell_index(sample, cell_size), node)\n                n_added += 1\n\n            # Lazy A* over the current batch roadmap\n            path, cost = self._lazy_astar(start_node, goal_node, nodes, r_conn, self.k_neighbors,\n                                          grid, cell_size, obstacles, is_3d, edges, edges_seen,\n                                          start_time)\n            if path:\n                # Deterministic shortcut pass to aggressively minimize length\n                if self.smooth_deterministic and len(path) > 2:\n                    path = self._deterministic_shortcut(path, obstacles, is_3d)\n\n                # Random shortcut refinement\n                if len(path) > 2 and self.smooth_random_iters > 0:\n                    path = self._random_shortcut(path, obstacles, is_3d, self.smooth_random_iters)\n\n                new_cost = self._path_cost(path)\n                if new_cost + 1e-9 < c_best:\n                    c_best = new_cost\n                    best_path = path\n                    success = True\n                    no_improve = 0\n                else:\n                    no_improve += 1\n            else:\n                no_improve += 1\n\n            if success and no_improve >= self.no_improve_limit:\n                break\n\n            if self._now() - start_time > self.time_limit_sec:\n                break\n\n        # Reconstruct parent/children along final path for coherence\n        if success and best_path:\n            # Clear old tree links to avoid inconsistency\n            for nd in nodes:\n                nd.children = []\n                nd.parent = None\n                nd.cost = float(\"inf\")\n            # Ensure nodes exist at path points or create transient nodes for path clarity\n            # Map from position to nearest node at same coords (exact match if sampled endpoints included)\n            pos_to_node = {}\n            for nd in nodes:\n                pos_to_node.setdefault(nd.position, nd)\n            # Build path nodes\n            path_nodes = []\n            for p in best_path:\n                nd = pos_to_node.get(p, None)\n                if nd is None:\n                    nd = Node(p)\n                    nodes.append(nd)\n                    self._grid_insert(grid, self._cell_index(p, cell_size), nd)\n                    pos_to_node[p] = nd\n                path_nodes.append(nd)\n            # Set parents/children and edges\n            path_nodes[0].cost = 0.0\n            for i in range(len(path_nodes) - 1):\n                a = path_nodes[i]\n                b = path_nodes[i + 1]\n                if b.parent is not a:\n                    if b.parent is not None and b.parent is not a:\n                        b.parent.remove_child(b)\n                    a.add_child(b)\n                b.cost = a.cost + self._dist(a.position, b.position)\n            # Rebuild edges list to contain at least the final path\n            edges = []\n            edges_seen = set()\n            for i in range(len(path_nodes) - 1):\n                a = path_nodes[i]\n                b = path_nodes[i + 1]\n                if not self._is_edge_in_obstacle(a.position, b.position, obstacles, is_3d):\n                    key = (id(a), id(b))\n                    if key not in edges_seen:\n                        edges.append((a, b))\n                        edges_seen.add(key)\n\n        return PlannerResult(success, best_path if success else [], nodes, edges)\n\n    # ---------- Lazy A* on implicit PRM ----------\n    def _lazy_astar(self, start_node, goal_node, nodes, r_conn, k_neighbors,\n                    grid, cell_size, obstacles, is_3d, edges, edges_seen, start_time):\n        # Per-search state\n        g = {}\n        parent = {}\n        edge_valid = {}\n        closed = set()\n        blocked = set()  # undirected blocked edges\n\n        def h_fun(n):\n            return self._dist(n.position, goal_node.position)\n\n        # Initialize\n        for nd in nodes:\n            g[nd] = float(\"inf\")\n            parent[nd] = None\n            edge_valid[nd] = False\n        g[start_node] = 0.0\n        edge_valid[start_node] = True\n\n        open_list = []\n        open_list.append((g[start_node] + h_fun(start_node), start_node))\n\n        # Helper to add validated edge coherently\n        def commit_edge(child, par):\n            # Avoid duplicates in edges list\n            key = (id(par), id(child))\n            if key not in edges_seen:\n                edges.append((par, child))\n                edges_seen.add(key)\n            # Update tree pointers and costs coherently\n            if child.parent is not par:\n                if child.parent is not None:\n                    child.parent.remove_child(child)\n                par.add_child(child)\n            child.cost = g[child]\n\n        # Main loop\n        while open_list:\n            # Time guard\n            if self._now() - start_time > self.time_limit_sec:\n                break\n\n            # Pop best f\n            best_i = 0\n            best_f = open_list[0][0]\n            for i in range(1, len(open_list)):\n                if open_list[i][0] < best_f:\n                    best_f = open_list[i][0]\n                    best_i = i\n            f_u, u = open_list.pop(best_i)\n\n            # Skip stale entry\n            if f_u > g[u] + h_fun(u) + 1e-12:\n                continue\n\n            # Validate incoming edge lazily (except for start)\n            if u is not start_node and not edge_valid[u]:\n                par = parent[u]\n                if par is None:\n                    continue\n                # Undirected edge key\n                bkey = (min(id(par), id(u)), max(id(par), id(u)))\n                if bkey in blocked:\n                    # Already known blocked\n                    continue\n                if self._is_edge_in_obstacle(par.position, u.position, obstacles, is_3d):\n                    blocked.add(bkey)\n                    # Invalidate this path; continue search\n                    edge_valid[u] = False\n                    # Do not add to closed; allow re-discovery via different parent\n                    continue\n                else:\n                    edge_valid[u] = True\n                    commit_edge(u, par)\n\n            if u in closed:\n                continue\n            closed.add(u)\n\n            # Goal reached with validated incoming edges\n            if u is goal_node:\n                # Reconstruct path\n                path = []\n                cur = u\n                while cur is not None:\n                    path.append(cur.position)\n                    cur = parent[cur]\n                path.reverse()\n                return path, g[u]\n\n            # Expand neighbors (implicit graph via spatial grid)\n            neighs = self._k_nearest_within_grid(u.position, k_neighbors, r_conn, grid, cell_size)\n            for v in neighs:\n                if v is u:\n                    continue\n                # Skip if undirected edge has been proven blocked\n                bkey = (min(id(u), id(v)), max(id(u), id(v)))\n                if bkey in blocked:\n                    continue\n                # Tentative cost\n                d = self._dist(u.position, v.position)\n                tentative = g[u] + d\n                if tentative + 1e-12 < g.get(v, float(\"inf\")):\n                    g[v] = tentative\n                    parent[v] = u\n                    edge_valid[v] = False if v is not start_node else True\n                    open_list.append((tentative + self._dist(v.position, goal_node.position), v))\n\n        return None, float(\"inf\")\n\n    # ---------- Sampling ----------\n    def _sample(self, bounds, start, goal, c_best, c_min, have_solution, obstacles, is_3d):\n        dim = len(bounds)\n        for _ in range(40):\n            if not have_solution or c_best == float(\"inf\") or c_min <= 1e-12:\n                # Pre-solution: goal bias\n                if random.random() < self.goal_bias:\n                    s = goal\n                else:\n                    s = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            else:\n                # Post-solution: 80% informed ellipsoid, 20% uniform escape\n                if random.random() < 0.80:\n                    s = self._sample_ellipsoid(start, goal, c_best, c_min, bounds)\n                else:\n                    s = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            if self._in_bounds(s, bounds) and not self._is_in_obstacle(s, obstacles, is_3d):\n                return s\n        # Fallback uniform\n        return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n    def _sample_ellipsoid(self, start, goal, c_best, c_min, bounds):\n        dim = len(bounds)\n        center = tuple((start[i] + goal[i]) / 2.0 for i in range(dim))\n        if c_min < 1e-12:\n            return center\n        # Basis aligned with (goal - start)\n        a1 = tuple((goal[i] - start[i]) / c_min for i in range(dim))\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (self._normalize(a1), self._normalize(a2))\n            radii = (c_best / 2.0, (max(c_best * c_best - c_min * c_min, 0.0) ** 0.5) / 2.0)\n        else:\n            # 3D orthonormal basis\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._normalize(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._normalize(self._cross(a1, ref))\n            b3 = self._normalize(self._cross(a1, b2))\n            basis = (self._normalize(a1), b2, b3)\n            r_other = (max(c_best * c_best - c_min * c_min, 0.0) ** 0.5) / 2.0\n            radii = (c_best / 2.0, r_other, r_other)\n        # Sample unit ball\n        u = self._sample_unit_ball(dim)\n        # Map to ellipsoid and clamp to bounds\n        p = [center[i] for i in range(dim)]\n        for i in range(dim):\n            for j in range(dim):\n                p[j] += basis[i][j] * radii[i] * u[i]\n        for j in range(dim):\n            p[j] = min(max(p[j], 0.0), bounds[j])\n        return tuple(p)\n\n    def _sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = (sum(x * x for x in v)) ** 0.5\n            if n > 1e-12:\n                v = [x / n for x in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    # ---------- Spatial grid and neighbors ----------\n    def _cell_index(self, pos, cell_size):\n        if len(pos) == 3:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size), int(pos[2] // cell_size))\n        else:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size))\n\n    def _grid_insert(self, grid, idx, node):\n        if idx not in grid:\n            grid[idx] = []\n        grid[idx].append(node)\n\n    def _k_nearest_within_grid(self, pos, k, radius, grid, cell_size):\n        dim = len(pos)\n        r_cells = max(1, int(radius // cell_size) + 1)\n        idx = self._cell_index(pos, cell_size)\n        candidates = []\n        if dim == 2:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    key = (idx[0] + dx, idx[1] + dy)\n                    if key in grid:\n                        candidates.extend(grid[key])\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        key = (idx[0] + dx, idx[1] + dy, idx[2] + dz)\n                        if key in grid:\n                            candidates.extend(grid[key])\n        # Filter by true radius and take k nearest\n        scored = []\n        for nd in candidates:\n            d = self._dist(pos, nd.position)\n            if d <= radius and d > 0.0:\n                scored.append((d, nd))\n        if not scored:\n            return []\n        scored.sort(key=lambda x: x[0])\n        return [nd for _, nd in scored[:min(k, len(scored))]]\n\n    # ---------- Geometry / Utility ----------\n    def _connection_radius(self, n_nodes, dim, bounds):\n        if n_nodes < 3:\n            return max(2.0, max(bounds) * 0.05)\n        # PRM* style radius (scaled) with clamping\n        gamma = 2.0 * (max(bounds) ** (1.0 / dim))\n        r = gamma * ((max(1.0, math.log(n_nodes)) / n_nodes) ** (1.0 / dim))\n        r = max(r, max(bounds) * 0.02)\n        r = min(r, max(bounds) * self.r_max_ratio)\n        return r\n\n    def _path_cost(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(len(path) - 1):\n            total += self._dist(path[i], path[i + 1])\n        return total\n\n    def _deterministic_shortcut(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return path\n        pts = list(path)\n        i = 0\n        while i < len(pts) - 2:\n            # Try to connect farthest possible j to reduce nodes aggressively\n            improved = False\n            j = len(pts) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                    # Shortcut: keep i..j\n                    new_pts = pts[:i + 1] + pts[j:]\n                    pts = new_pts\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n        return pts\n\n    def _random_shortcut(self, path, obstacles, is_3d, iters):\n        if len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            if len(pts) < 3:\n                break\n            i = random.randint(0, len(pts) - 3)\n            j = random.randint(i + 2, len(pts) - 1)\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts\n\n    def _now(self):\n        return time.time()\n\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _in_bounds(self, p, bounds):\n        for d in range(len(bounds)):\n            if p[d] < 0.0 or p[d] > bounds[d]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for x, y, z, w, h, d in obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for x, y, w, h in obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=0.75):\n        # Sample along the segment from a to b\n        dist = self._dist(a, b)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(len(a)))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)",
        "objective": null,
        "time_improvement": null,
        "length_improvement": null,
        "smoothness_improvement": null,
        "node_improvement": null,
        "other_inf": {
            "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: Planner.__init__() got an unexpected keyword argument 'max_iter'\n"
        }
    },
    {
        "operator": "e1",
        "algorithm_description": "PA-BIRRTMap*: Progressive Anytime Batch Informed Roadmap with Lazy-A* Search and Visibility Refinement \u2014 a hybrid PRM*/BIT*-lite planner that incrementally builds a low-dispersion roadmap (Halton-guided, ellipse/corridor-focused), performs lazy edge validation during a heuristic A* over the implicit k-NN graph, and repeatedly densifies and shortens the best path via visibility-based collapse and random shortcuts. It memoizes edge collision checks, adapts neighbor radius with batch growth, and finalizes a coherent node/edge chain with verified segments.",
        "planning_mechanism": "Mechanism: Validate start/goal and fast-check straight-line; otherwise, create start/goal nodes and iteratively sample collision-free points (Halton/uniform with informed ellipse once a solution exists). Maintain a hash-grid for near-constant-time k-NN queries and a lazy edge-state cache. Each batch runs A* over the implicit roadmap using Euclidean heuristics and only collision-checks edges as they are expanded, pruning by the incumbent best cost. On finding a feasible path, apply LOS collapse and shortcutting, then densify sampling near the path and repeat until budget. Finally, rebuild a coherent parent/children chain along the smoothed path, adding only bounds-valid, obstacle-free nodes and edges verified by segment checks.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.edge_index = -1\n\n    def add_child(self, child):\n        for c in self.children:\n            if c is child:\n                child.parent = self\n                return\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_batches=20,\n                 batch_size=300,\n                 k_neighbors=14,\n                 base_radius_ratio=0.08,\n                 collision_step=1.0,\n                 informed_bias=0.6,\n                 corridor_bias=0.3,\n                 smooth_attempts=60,\n                 prune_margin=1.02,\n                 grid_cell_factor=0.9,\n                 edge_cache_capacity=60000,\n                 edge_cache_drain=8000):\n        self.max_batches = max_batches\n        self.batch_size = batch_size\n        self.k_neighbors = k_neighbors\n        self.base_radius_ratio = base_radius_ratio\n        self.collision_step = collision_step\n        self.informed_bias = informed_bias\n        self.corridor_bias = corridor_bias\n        self.smooth_attempts = smooth_attempts\n        self.prune_margin = prune_margin\n        self.grid_cell_factor = grid_cell_factor\n        self.edge_cache_capacity = edge_cache_capacity\n        self.edge_cache_drain = edge_cache_drain\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self.inv_cache_bin = 1.0\n        self.edge_cache = None\n        self.edge_keys = None\n        self.cell_size = 1.0\n        self.diag_len = 1.0\n        self._halton_idx = 1\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        self.diag_len = 0.0\n        for i in range(self.dim):\n            self.diag_len += self.bounds[i] * self.bounds[i]\n        self.diag_len = self.diag_len ** 0.5\n\n        self.edge_res = max(0.75, min(self.collision_step, self.diag_len * 0.02))\n        self.cache_bin = max(0.5, 0.5 * self.edge_res)\n        self.inv_cache_bin = 1.0 / self.cache_bin\n        self.edge_cache = {}\n        self.edge_keys = []\n        self.cell_size = max(1.0, self.diag_len * self.grid_cell_factor * 0.05)\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes = [n0, n1]\n            edges = [(n0, n1)]\n            n1.edge_index = 0\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        positions = []\n        nodes = []\n        edges = []\n\n        start_node = Node(self.start, None, 0.0)\n        goal_node = Node(self.goal, None, 0.0)\n        nodes.extend([start_node, goal_node])\n        positions.append(self.start)\n        positions.append(self.goal)\n\n        grid = {}\n        self._grid_add(grid, 0, self.start)\n        self._grid_add(grid, 1, self.goal)\n\n        best_path = []\n        best_cost = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        base_radius = max(self.diag_len * self.base_radius_ratio, d_sg * 0.1)\n\n        for b in range(self.max_batches):\n            target_n = len(positions) + self.batch_size\n            while len(positions) < target_n:\n                if best_cost < float('inf') and self._rand() < self.informed_bias:\n                    p = self._sample_informed(best_cost, obstacles, is_3d)\n                else:\n                    if self._rand() < self.corridor_bias:\n                        p = self._sample_corridor(max(d_sg * 0.2, self.diag_len * 0.05), obstacles, is_3d)\n                    else:\n                        p = self._sample_halton_free(obstacles, is_3d)\n                if not self._in_bounds(p):\n                    continue\n                if self._is_in_obstacle(p, obstacles, is_3d):\n                    continue\n                idx = len(positions)\n                positions.append(p)\n                nodes.append(Node(p))\n                self._grid_add(grid, idx, p)\n\n            r = self._neighbor_radius(len(positions), base_radius)\n            path_indices = self._lazy_astar(positions, grid, 0, 1, r, obstacles, is_3d, best_cost)\n            if path_indices:\n                path = [positions[i] for i in path_indices]\n                raw_len = self._path_length(path)\n                if raw_len + 1e-9 < best_cost:\n                    best_cost = raw_len\n                    best_path = path\n                    best_path = self._smooth_path(best_path, obstacles, is_3d, self.smooth_attempts)\n                    best_cost = self._path_length(best_path)\n\n            if best_cost < float('inf'):\n                self._densify_along_path(best_path, positions, nodes, grid, obstacles, is_3d, int(self.batch_size * 0.5))\n\n        if not best_path:\n            return PlannerResult(False, [], nodes, edges)\n\n        final_nodes = [start_node]\n        final_edges = []\n        cost_acc = 0.0\n        prev = start_node\n        for i in range(1, len(best_path) - 1):\n            pos = best_path[i]\n            if not self._in_bounds(pos):\n                return PlannerResult(False, [], nodes, edges)\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return PlannerResult(False, [], nodes, edges)\n            if self._edge_blocked_memo(prev.position, pos, obstacles, is_3d):\n                return PlannerResult(False, [], nodes, edges)\n            seg = self._dist(prev.position, pos)\n            cost_acc += seg\n            n = Node(pos, prev, cost_acc)\n            prev.add_child(n)\n            nodes.append(n)\n            final_nodes.append(n)\n            edges.append((prev, n))\n            n.edge_index = len(edges) - 1\n            final_edges.append((prev, n))\n            prev = n\n\n        if self._edge_blocked_memo(prev.position, self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], nodes, edges)\n        seg = self._dist(prev.position, self.goal)\n        cost_acc += seg\n        goal_node.parent = prev\n        goal_node.cost = cost_acc\n        prev.add_child(goal_node)\n        nodes[1] = goal_node\n        edges.append((prev, goal_node))\n        goal_node.edge_index = len(edges) - 1\n        final_edges.append((prev, goal_node))\n\n        return PlannerResult(True, best_path, nodes, edges)\n\n    def _rand(self):\n        if not hasattr(self, \"_rng\"):\n            self._rng = 123456789\n        self._rng = (1103515245 * self._rng + 12345) % (1 << 31)\n        return (self._rng & 0x7fffffff) / float(1 << 31)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _halton(self, index, base):\n        f = 1.0\n        r = 0.0\n        i = index\n        while i > 0:\n            f = f / base\n            r = r + f * (i % base)\n            i = int(i // base)\n        return r\n\n    def _sample_halton_free(self, obstacles, is_3d):\n        for _ in range(80):\n            self._halton_idx += 1\n            if self.dim == 3:\n                x = self._halton(self._halton_idx, 2) * self.bounds[0]\n                y = self._halton(self._halton_idx, 3) * self.bounds[1]\n                z = self._halton(self._halton_idx, 5) * self.bounds[2]\n                p = (x, y, z)\n            else:\n                x = self._halton(self._halton_idx, 2) * self.bounds[0]\n                y = self._halton(self._halton_idx, 3) * self.bounds[1]\n                p = (x, y)\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_free(self, obstacles, is_3d):\n        for _ in range(100):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        if self.dim == 3:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5, self.bounds[2] * 0.5)\n        else:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5)\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        tries = 0\n        while tries < 30:\n            if self.dim == 3:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = (base[0] + ox, base[1] + oy, base[2] + oz)\n                else:\n                    tries += 1\n                    continue\n            else:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = (base[0] + ox, base[1] + oy)\n                else:\n                    tries += 1\n                    continue\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n            tries += 1\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        for _ in range(80):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= best_len and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        return self._sample_corridor(max(self.diag_len * 0.05, best_len * 0.15), obstacles, is_3d)\n\n    def _neighbor_radius(self, n, base_radius):\n        if n < 3:\n            return base_radius\n        import_log = 0.0\n        k = max(3, n)\n        t = 1\n        v = k\n        while v > 0:\n            v = v // 2\n            import_log += 1.0\n        factor = (import_log / max(1.0, float(n))) ** (1.0 / float(self.dim))\n        r = max(base_radius * 0.4, base_radius * factor)\n        return r\n\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, idx, pos):\n        k = self._grid_key(pos)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [idx]\n        else:\n            lst.append(idx)\n\n    def _ring_collect_idx(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _k_nearest_idx(self, positions, pos, cand_idx, k):\n        if len(cand_idx) <= k:\n            return list(cand_idx)\n        best = []\n        bestd = []\n        for idx in cand_idx:\n            p = positions[idx]\n            d = self._dist(p, pos)\n            if len(best) < k:\n                best.append(idx)\n                bestd.append(d)\n            else:\n                wi = 0\n                wv = bestd[0]\n                for i in range(1, k):\n                    if bestd[i] > wv:\n                        wi = i\n                        wv = bestd[i]\n                if d < wv:\n                    best[wi] = idx\n                    bestd[wi] = d\n        return best\n\n    def _nearby_indices(self, positions, grid, pos, radius, k):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.cell_size) + 1\n        cand = self._ring_collect_idx(grid, key, r_cells)\n        if not cand:\n            return []\n        out = []\n        r2 = radius * radius\n        for idx in cand:\n            p = positions[idx]\n            s = 0.0\n            for i in range(self.dim):\n                d = p[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(idx)\n        if k is not None and len(out) > k:\n            out = self._k_nearest_idx(positions, pos, out, k)\n        return out\n\n    def _lazy_astar(self, positions, grid, start_idx, goal_idx, radius, obstacles, is_3d, incumbent):\n        n = len(positions)\n        g = [float('inf')] * n\n        came = [-1] * n\n        closed = [False] * n\n        g[start_idx] = 0.0\n        open_set = [start_idx]\n        edge_state = self.edge_cache\n\n        def heuristic(i):\n            return self._dist(positions[i], positions[goal_idx])\n\n        while open_set:\n            best_i = 0\n            best_f = g[open_set[0]] + heuristic(open_set[0])\n            for ii in range(1, len(open_set)):\n                idx = open_set[ii]\n                f = g[idx] + heuristic(idx)\n                if f < best_f:\n                    best_f = f\n                    best_i = ii\n            cur = open_set.pop(best_i)\n            if closed[cur]:\n                continue\n            closed[cur] = True\n\n            if cur == goal_idx:\n                path = []\n                t = cur\n                while t != -1:\n                    path.append(t)\n                    t = came[t]\n                path.reverse()\n                return path\n\n            neigh = self._nearby_indices(positions, grid, positions[cur], radius, self.k_neighbors)\n            for nb in neigh:\n                if nb == cur:\n                    continue\n                if closed[nb]:\n                    continue\n                trial_g = g[cur] + self._dist(positions[cur], positions[nb])\n                if incumbent < float('inf'):\n                    est_total = trial_g + self._dist(positions[nb], positions[goal_idx])\n                    if est_total >= incumbent * self.prune_margin:\n                        continue\n                ek = self._edge_key_q(positions[cur], positions[nb])\n                st = edge_state.get(ek)\n                blocked = None\n                if st is None:\n                    blocked = self._edge_blocked(positions[cur], positions[nb], obstacles, is_3d)\n                    edge_state[ek] = 1 if blocked else 2\n                    self.edge_keys.append(ek)\n                    if len(self.edge_keys) > self.edge_cache_capacity:\n                        drain = min(self.edge_cache_drain, len(self.edge_keys))\n                        for _ in range(drain):\n                            kx = self.edge_keys.pop(0)\n                            try:\n                                del edge_state[kx]\n                            except:\n                                pass\n                else:\n                    blocked = (st == 1)\n                if blocked:\n                    continue\n                if trial_g + 1e-12 < g[nb]:\n                    g[nb] = trial_g\n                    came[nb] = cur\n                    found = False\n                    for q in open_set:\n                        if q == nb:\n                            found = True\n                            break\n                    if not found:\n                        open_set.append(nb)\n        return None\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] * self.inv_cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] * self.inv_cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        st = self.edge_cache.get(key)\n        if st is not None:\n            return st == 1\n        blocked = self._edge_blocked(a, b, obstacles, is_3d)\n        self.edge_cache[key] = 1 if blocked else 2\n        self.edge_keys.append(key)\n        if len(self.edge_keys) > self.edge_cache_capacity:\n            drain = min(self.edge_cache_drain, len(self.edge_keys))\n            for _ in range(drain):\n                k = self.edge_keys.pop(0)\n                try:\n                    del self.edge_cache[k]\n                except:\n                    pass\n        return blocked\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _smooth_path(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n\n        i = 0\n        while i + 2 < len(pts):\n            if not self._edge_blocked_memo(pts[i], pts[i + 2], obstacles, is_3d):\n                del pts[i + 1]\n            else:\n                i += 1\n\n        tries = 0\n        while tries < attempts and len(pts) >= 3:\n            n = len(pts)\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if not self._edge_blocked_memo(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n            tries += 1\n\n        if len(pts) >= 3:\n            out = [pts[0]]\n            for k in range(1, len(pts) - 1):\n                a = out[-1]\n                b = pts[k]\n                c = pts[k + 1]\n                v1 = tuple(b[d] - a[d] for d in range(self.dim))\n                v2 = tuple(c[d] - b[d] for d in range(self.dim))\n                n1 = 0.0\n                n2 = 0.0\n                for d in range(self.dim):\n                    n1 += v1[d] * v1[d]\n                    n2 += v2[d] * v2[d]\n                if n1 <= 1e-9 or n2 <= 1e-9:\n                    continue\n                dot = 0.0\n                for d in range(self.dim):\n                    dot += v1[d] * v2[d]\n                cosang = dot / ((n1 ** 0.5) * (n2 ** 0.5))\n                if cosang < 0.999:\n                    out.append(b)\n            out.append(pts[-1])\n            pts = out\n\n        return pts\n\n    def _densify_along_path(self, path, positions, nodes, grid, obstacles, is_3d, count):\n        if not path or len(path) < 2:\n            return\n        for _ in range(max(0, count)):\n            t = self._rand()\n            segf = t * (len(path) - 1)\n            i = int(segf)\n            if i >= len(path) - 1:\n                i = len(path) - 2\n            u = segf - i\n            a = path[i]\n            b = path[i + 1]\n            base = tuple(a[d] + (b[d] - a[d]) * u for d in range(self.dim))\n            width = max(self.diag_len * 0.03, self._dist(a, b) * 0.5)\n            if self.dim == 3:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                p = (base[0] + ox, base[1] + oy, base[2] + oz)\n            else:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                p = (base[0] + ox, base[1] + oy)\n            if not self._in_bounds(p) or self._is_in_obstacle(p, obstacles, is_3d):\n                continue\n            idx = len(positions)\n            positions.append(p)\n            nodes.append(Node(p))\n            self._grid_add(grid, idx, p)",
        "objective": null,
        "time_improvement": null,
        "length_improvement": null,
        "smoothness_improvement": null,
        "node_improvement": null,
        "other_inf": {
            "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: Planner.__init__() got an unexpected keyword argument 'max_iter'\n"
        }
    },
    {
        "operator": "path_expert",
        "algorithm_description": "IFMT-Grid*: An informed Fast Marching Tree with grid-accelerated neighbor queries, A*-biased frontier ordering, and goal-corridor sampling. It lazily adds only collision-free, cost-improving edges, then compresses the found path with deterministic visibility-based shortcuts and light random smoothing to minimize length and improve smoothness and time efficiency.",
        "planning_mechanism": "Build a bounded sample set focused around the start\u2013goal corridor; discard samples inside obstacles. Create a spatial hash grid and a connection radius from RRT*/FMT* theory. Initialize the frontier at the start and expand like FMT*, selecting the frontier node with lowest g+h to connect nearby unvisited samples to their best-cost parent among current frontier nodes; accept only when node and edge are collision-free. Stop when the goal is reached or the frontier is exhausted. Finally, compress the path by replacing multi-segment subsequences with single straight, collision-free links and apply brief shortcut smoothing.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        child.parent = self\n        self.children.append(child)\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        n_samples: int = 1200,\n        time_limit_sec: float = 10.0,\n        corridor_bias: float = 0.65,\n        corridor_width_ratio: float = 0.18,\n        alpha_astar: float = 0.15,\n        edge_cache_limit: int = 20000,\n        smooth_random_iters: int = 80\n    ):\n        self.n_samples = n_samples\n        self.time_limit_sec = time_limit_sec\n        self.corridor_bias = corridor_bias\n        self.corridor_width_ratio = corridor_width_ratio\n        self.alpha_astar = alpha_astar\n        self.edge_cache_limit = edge_cache_limit\n        self.smooth_random_iters = smooth_random_iters\n\n        self._edge_cache = {}\n\n    def plan(self, map):\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n\n        # Start/goal validity\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight-line solution\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self._edge_resolution(bounds)):\n            n_start = Node(start, parent=None, cost=0.0)\n            n_goal = Node(goal, parent=n_start, cost=self._dist(start, goal))\n            n_start.add_child(n_goal)\n            nodes.extend([n_start, n_goal])\n            edges.append((n_start, n_goal))\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        start_time = self._now()\n\n        # Build informed sample set\n        samples = [start, goal]\n        target_count = max(200, self.n_samples)\n        tries = 0\n        diag = self._diag(bounds)\n        while len(samples) < target_count + 2 and (self._now() - start_time) < self.time_limit_sec * 0.45 and tries < target_count * 20:\n            tries += 1\n            p = self._biased_sample(start, goal, bounds, is_3d)\n            if self._in_bounds(p, bounds) and (not self._is_in_obstacle(p, obstacles, is_3d)):\n                samples.append(p)\n\n        n_total = len(samples)\n        # Build neighbor radius and grid\n        r_connect = self._connection_radius(n_total, dim, diag, bounds)\n        cell_size = max(r_connect, 1e-6)\n        grid = self._build_grid(samples, cell_size)\n\n        # FMT* sets\n        idx_start = 0\n        idx_goal = 1\n        W = set(range(1, n_total))  # unvisited (includes goal)\n        H = {idx_start}             # frontier\n        parents = [-1] * n_total\n        cost = [float(\"inf\")] * n_total\n        cost[idx_start] = 0.0\n        heuristic = [self._dist(samples[i], goal) for i in range(n_total)]\n\n        # Node objects only for committed tree nodes\n        node_objs = [None] * n_total\n        node_objs[idx_start] = Node(samples[idx_start], None, 0.0)\n        nodes.append(node_objs[idx_start])\n\n        success = False\n        best_goal_idx = -1\n        edge_res = self._edge_resolution(bounds)\n\n        while H and (self._now() - start_time) < self.time_limit_sec:\n            # Select A*-biased best frontier node\n            z = None\n            best_key = float(\"inf\")\n            for i in H:\n                key = cost[i] + self.alpha_astar * heuristic[i]\n                if key < best_key:\n                    best_key = key\n                    z = i\n\n            if z is None:\n                break\n\n            X_near = self._neighbors_in_radius(samples, grid, z, r_connect, cell_size, bounds)\n            # Filter to W\n            X_near = [x for x in X_near if x in W and x != z]\n\n            H_new = set()\n            for x in X_near:\n                # Find best parent in H within radius\n                Y = self._neighbors_in_radius(samples, grid, x, r_connect, cell_size, bounds)\n                # Intersect with H\n                cand = []\n                for y in Y:\n                    if y in H:\n                        c_try = cost[y] + self._dist(samples[y], samples[x])\n                        cand.append((c_try, y))\n                if not cand:\n                    continue\n                cand.sort(key=lambda t: t[0])\n                # Evaluate best parents lazily until one succeeds\n                connected = False\n                for _, y in cand[:8]:  # cap checks for speed\n                    to_pos = samples[x]\n                    from_pos = samples[y]\n                    # Node and edge collision checks\n                    if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                        break\n                    if not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, edge_res):\n                        parents[x] = y\n                        cost[x] = cost[y] + self._dist(from_pos, to_pos)\n                        H_new.add(x)\n                        W.discard(x)\n                        # Materialize nodes and edge\n                        if node_objs[y] is None:\n                            node_objs[y] = Node(samples[y], None, cost[y])\n                            nodes.append(node_objs[y])\n                        node_objs[x] = Node(samples[x], node_objs[y], cost[x])\n                        node_objs[y].add_child(node_objs[x])\n                        edges.append((node_objs[y], node_objs[x]))\n                        connected = True\n                        break\n                # Try fast direct connect to goal if x got added and goal not yet connected and close\n                if connected and idx_goal in W:\n                    if self._dist(samples[x], goal) <= r_connect:\n                        if not self._is_in_obstacle(goal, obstacles, is_3d) and not self._is_edge_in_obstacle(samples[x], goal, obstacles, is_3d, edge_res):\n                            parents[idx_goal] = x\n                            cost[idx_goal] = cost[x] + self._dist(samples[x], goal)\n                            W.discard(idx_goal)\n                            H_new.add(idx_goal)\n                            # Create goal node and edge\n                            if node_objs[x] is None:\n                                node_objs[x] = Node(samples[x], None, cost[x])\n                                nodes.append(node_objs[x])\n                            node_objs[idx_goal] = Node(goal, node_objs[x], cost[idx_goal])\n                            node_objs[x].add_child(node_objs[idx_goal])\n                            edges.append((node_objs[x], node_objs[idx_goal]))\n\n            # Advance frontier\n            H.discard(z)\n            H |= H_new\n\n            if node_objs[idx_goal] is not None:\n                success = True\n                best_goal_idx = idx_goal\n                break\n\n        path = []\n        if success:\n            # Extract path\n            path = node_objs[best_goal_idx].path_from_root()\n            # Deterministic visibility compression\n            path = self._visibility_compress(path, obstacles, is_3d, edge_res)\n            # Light random shortcut smoothing\n            path = self._shortcut_smooth(path, obstacles, is_3d, self.smooth_random_iters, edge_res)\n            # Rebuild nodes/edges to reflect smoothed path (coherent output)\n            nodes, edges = self._rebuild_tree_from_path(path)\n\n        return PlannerResult(success, path if success else [], nodes, edges)\n\n    # ---------- Geometry / Utility ----------\n    def _now(self):\n        return time.time()\n\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _diag(self, bounds):\n        return math.sqrt(sum((b ** 2) for b in bounds))\n\n    def _in_bounds(self, p, bounds):\n        for d in range(len(bounds)):\n            if p[d] < 0.0 or p[d] > bounds[d]:\n                return False\n        return True\n\n    # ---------- Sampling ----------\n    def _biased_sample(self, start, goal, bounds, is_3d):\n        # Corridor-biased sampling around the straight line between start and goal\n        if random.random() < self.corridor_bias:\n            dim = len(bounds)\n            # Direction vector\n            v = tuple(goal[i] - start[i] for i in range(dim))\n            n = math.sqrt(sum(v[i] * v[i] for i in range(dim)))\n            if n < 1e-12:\n                return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n            u = tuple(v[i] / n for i in range(dim))\n            t = random.random()\n            base = tuple(start[i] + t * v[i] for i in range(dim))\n            w = self.corridor_width_ratio * self._diag(bounds)\n            if dim == 2:\n                # Perpendicular\n                perp = (-u[1], u[0])\n                offset_mag = (random.random() * 2.0 - 1.0) * w\n                p = (base[0] + perp[0] * offset_mag, base[1] + perp[1] * offset_mag)\n                # Clamp\n                return tuple(min(max(p[i], 0.0), bounds[i]) for i in range(dim))\n            else:\n                # Two perpendiculars\n                ref = (1.0, 0.0, 0.0) if abs(u[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = self._normalize(self._cross(u, ref))\n                if self._norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = self._normalize(self._cross(u, ref))\n                b3 = self._cross(u, b2)\n                a = (random.random() * 2.0 - 1.0) * w\n                b = (random.random() * 2.0 - 1.0) * w\n                p = (base[0] + b2[0] * a + b3[0] * b,\n                     base[1] + b2[1] * a + b3[1] * b,\n                     base[2] + b2[2] * a + b3[2] * b)\n                return tuple(min(max(p[i], 0.0), bounds[i]) for i in range(dim))\n        else:\n            dim = len(bounds)\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)\n\n    # ---------- Grid / Neighbors ----------\n    def _build_grid(self, samples, cell_size):\n        grid = {}\n        dim = len(samples[0])\n        for i, p in enumerate(samples):\n            key = self._cell_key(p, cell_size, dim)\n            lst = grid.get(key)\n            if lst is None:\n                grid[key] = [i]\n            else:\n                lst.append(i)\n        return grid\n\n    def _cell_key(self, p, cell_size, dim):\n        if dim == 2:\n            return (int(p[0] // cell_size), int(p[1] // cell_size))\n        else:\n            return (int(p[0] // cell_size), int(p[1] // cell_size), int(p[2] // cell_size))\n\n    def _neighbors_in_radius(self, samples, grid, idx, radius, cell_size, bounds):\n        dim = len(samples[0])\n        p = samples[idx]\n        key = self._cell_key(p, cell_size, dim)\n        r_cells = max(1, int(math.ceil(radius / cell_size)))\n        candidates = []\n        if dim == 2:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    lst = grid.get(k)\n                    if lst:\n                        candidates.extend(lst)\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        lst = grid.get(k)\n                        if lst:\n                            candidates.extend(lst)\n        rad2 = radius * radius\n        out = []\n        for j in candidates:\n            if j == idx:\n                continue\n            if self._dist2(samples[idx], samples[j]) <= rad2:\n                out.append(j)\n        return out\n\n    def _dist2(self, a, b):\n        return sum((a[i] - b[i]) * (a[i] - b[i]) for i in range(len(a)))\n\n    def _connection_radius(self, n, dim, diag, bounds):\n        # RRT*/FMT*-style radius with bounds\n        if n < 3:\n            return diag * 0.05\n        gamma = diag * 0.9\n        r = gamma * ((math.log(n) / n) ** (1.0 / dim))\n        rmin = max(2.0, min(bounds) * 0.03)\n        rmax = diag * 0.25\n        if r < rmin:\n            r = rmin\n        if r > rmax:\n            r = rmax\n        return r\n\n    # ---------- Collision ----------\n    def _edge_resolution(self, bounds):\n        # Adaptive resolution: finer on small maps\n        return max(0.5, min(bounds) / 60.0)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for x, y, z, w, h, d in obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for x, y, w, h in obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        ra = tuple(round(c, 3) for c in a)\n        rb = tuple(round(c, 3) for c in b)\n        return (ra, rb) if ra <= rb else (rb, ra)\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution):\n        key = self._edge_key(from_pos, to_pos)\n        cached = self._edge_cache.get(key)\n        if cached is not None:\n            return cached\n        d = self._dist(from_pos, to_pos)\n        steps = max(1, int(d / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            pt = tuple(from_pos[k] + (to_pos[k] - from_pos[k]) * t for k in range(len(from_pos)))\n            if self._is_in_obstacle(pt, obstacles, is_3d):\n                self._edge_cache[key] = True\n                if len(self._edge_cache) > self.edge_cache_limit:\n                    self._edge_cache.clear()\n                return True\n        self._edge_cache[key] = False\n        if len(self._edge_cache) > self.edge_cache_limit:\n            self._edge_cache.clear()\n        return False\n\n    # ---------- Path post-processing ----------\n    def _visibility_compress(self, path, obstacles, is_3d, edge_res):\n        if len(path) < 3:\n            return path\n        compressed = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            # Try to jump as far as possible\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, edge_res):\n                    break\n                j -= 1\n            compressed.append(path[j])\n            i = j\n        return compressed\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters, edge_res):\n        if len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, edge_res):\n                new_pts = pts[:i + 1] + pts[j:]\n                pts = new_pts\n                n = len(pts)\n        return pts\n\n    def _rebuild_tree_from_path(self, path):\n        nodes = []\n        edges = []\n        if not path:\n            return nodes, edges\n        prev = Node(path[0], None, 0.0)\n        nodes.append(prev)\n        for i in range(1, len(path)):\n            cur = Node(path[i], prev, prev.cost + self._dist(prev.position, path[i]))\n            prev.add_child(cur)\n            nodes.append(cur)\n            edges.append((prev, cur))\n            prev = cur\n        return nodes, edges",
        "objective": null,
        "time_improvement": null,
        "length_improvement": null,
        "smoothness_improvement": null,
        "node_improvement": null,
        "other_inf": {
            "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: Planner.__init__() got an unexpected keyword argument 'max_iter'\n"
        }
    },
    {
        "operator": "path_expert",
        "algorithm_description": null,
        "planning_mechanism": null,
        "code": null,
        "objective": null,
        "time_improvement": null,
        "length_improvement": null,
        "smoothness_improvement": null,
        "node_improvement": null,
        "success_rate": null,
        "other_inf": {
            "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
        }
    },
    {
        "operator": "e1",
        "algorithm_description": "QUICKSILVER-IBRRT: Informed, Batch, Radius-Optimal Bi-directional RRT*. Two synchronized trees grow from start and goal using batch targets, adaptive neighbor radius, and incumbent-based f-pruning. Parent selection and bounded rewiring use grid-accelerated near queries. A bridge check opportunistically connects trees; after a solution emerges, limited optimization continues, then a fast three-stage smoother (visibility collapse, shortcuts, arc rubberband) outputs a short, smooth path.",
        "planning_mechanism": "Each iteration samples a small batch of targets from a mixture (uniform, goal/bridge, informed-ellipse if a solution exists). For each target, the planner selects the nearest node via a hashed grid, advances with a multi-step connect (bounded), and inserts the best-cost feasible parent within an adaptive radius after both node and edge collision checks. Local rewiring improves nearby nodes. It then attempts a direct bridge to the opposite tree; successful links update the incumbent and enable f-pruning. After a patience window, the best path is smoothed and returned.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        for c in self.children:\n            if c is child:\n                return\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        i = 0\n        while i < len(self.children):\n            if self.children[i] is child:\n                self.children.pop(i)\n                return\n            i += 1\nclass Planner:\n    def __init__(self,\n                 max_iters=6000,\n                 batch_size=6,\n                 step_size=8.0,\n                 max_connect_mult=2.0,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 goal_bias=0.15,\n                 bridge_bias=0.20,\n                 informed_bias=0.65,\n                 dupe_radius_ratio=0.3,\n                 prune_margin=1.02,\n                 gamma_radius=2.2,\n                 k_rewire_scale=0.8,\n                 opt_patience=250,\n                 shortcut_attempts=48,\n                 smooth_passes=4,\n                 edge_cache_limit=60000):\n        self.max_iters = int(max_iters)\n        self.batch_size = int(batch_size)\n        self.step_size = float(step_size)\n        self.max_connect_mult = float(max_connect_mult)\n        self.collision_step = float(collision_step)\n        self.grid_cell = grid_cell\n        self.goal_bias = float(goal_bias)\n        self.bridge_bias = float(bridge_bias)\n        self.informed_bias = float(informed_bias)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.prune_margin = float(prune_margin)\n        self.gamma_radius = float(gamma_radius)\n        self.k_rewire_scale = float(k_rewire_scale)\n        self.opt_patience = int(opt_patience)\n        self.shortcut_attempts = int(shortcut_attempts)\n        self.smooth_passes = int(smooth_passes)\n        self.edge_cache_limit = int(edge_cache_limit)\n\n        self.dim = 2\n        self.bounds = None\n\n        self._rng = 0x9E3779B9\n        self._edge_cache = {}\n        self._edge_keys = []\n        self._edge_q = 1.0\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._in_obstacle(start, obstacles, is_3d) or self._in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        if self.grid_cell is None:\n            self.grid_cell = max(0.5, 0.8 * self.step_size)\n\n        self._edge_cache = {}\n        self._edge_keys = []\n        self._edge_q = max(0.25, 0.5 * self.collision_step)\n\n        if not self._edge_blocked_cached(start, goal, obstacles, is_3d):\n            a = Node(start, None, 0.0)\n            b = Node(goal, a, self._dist(start, goal))\n            a.add_child(b)\n            return PlannerResult(True, [start, goal], [a, b], [(a, b)])\n\n        a_root = Node(start, None, 0.0)\n        b_root = Node(goal, None, 0.0)\n        tree_a = [a_root]\n        tree_b = [b_root]\n        nodes = [a_root, b_root]\n        edges = []\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, a_root)\n        self._grid_add(grid_b, b_root)\n\n        frontier_a = [a_root]\n        frontier_b = [b_root]\n        frontier_cap = 128\n\n        dupe_radius = max(0.5, self.dupe_radius_ratio * self.step_size)\n\n        best_len = float('inf')\n        best_path = []\n        best_raw = []\n\n        patience_deadline = None\n\n        it = 0\n        while it < self.max_iters:\n            for _ in range(self.batch_size):\n                active_a = ((it + _) % 2 == 0)\n                T = tree_a if active_a else tree_b\n                O = tree_b if active_a else tree_a\n                G = grid_a if active_a else grid_b\n                OG = grid_b if active_a else grid_a\n                frontier_T = frontier_a if active_a else frontier_b\n                frontier_O = frontier_b if active_a else frontier_a\n                other_root = goal if active_a else start\n\n                nT = len(T)\n                rad = self._adaptive_radius(nT)\n                rewire_k = max(6, int(self.k_rewire_scale * (1.0 + (nT ** (1.0 / max(1, self.dim))) * 0.8)))\n\n                tgt = self._sample_target(best_len, start, goal, other_root, OG, frontier_O, obstacles, is_3d)\n\n                near = self._nearest(G, frontier_T, tgt)\n                if near is None:\n                    continue\n\n                new_pos = self._advance(near.position, tgt, obstacles, is_3d)\n                if new_pos is None:\n                    continue\n                if not self._in_bounds(new_pos) or self._in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._exists_close(G, new_pos, dupe_radius):\n                    continue\n\n                g_est = near.cost + self._dist(near.position, new_pos)\n                h_est = self._dist(new_pos, other_root)\n                if best_len < float('inf') and g_est + h_est >= best_len * self.prune_margin:\n                    continue\n\n                parent, new_cost = self._choose_parent(new_pos, G, frontier_T, rad, obstacles, is_3d)\n                if parent is None:\n                    if not self._edge_blocked_cached(near.position, new_pos, obstacles, is_3d):\n                        parent = near\n                        new_cost = near.cost + self._dist(near.position, new_pos)\n                    else:\n                        continue\n\n                if self._in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._edge_blocked_cached(parent.position, new_pos, obstacles, is_3d):\n                    continue\n\n                nn = Node(new_pos, parent, new_cost)\n                parent.add_child(nn)\n                T.append(nn)\n                nodes.append(nn)\n                edges.append((parent, nn))\n                self._grid_add(G, nn)\n                frontier_T.append(nn)\n                if len(frontier_T) > frontier_cap:\n                    del frontier_T[:16]\n\n                near_nodes = self._nearby(G, nn.position, rad)\n                if len(near_nodes) > rewire_k:\n                    near_nodes = self._k_closest(near_nodes, nn.position, rewire_k)\n\n                for q in near_nodes:\n                    if q is nn or q is nn.parent:\n                        continue\n                    alt = nn.cost + self._dist(nn.position, q.position)\n                    if alt + 1e-12 < q.cost:\n                        if not self._edge_blocked_cached(nn.position, q.position, obstacles, is_3d):\n                            oldp = q.parent\n                            if oldp is not None:\n                                oldp.remove_child(q)\n                                self._remove_edge(edges, oldp, q)\n                            nn.add_child(q)\n                            q.cost = alt\n                            edges.append((nn, q))\n                            self._propagate_cost(q)\n\n                connect_rad = max(2.0 * self.step_size, 3.0 * rad)\n                others = self._nearby(OG, nn.position, connect_rad)\n                if others:\n                    cand = self._k_closest(others, nn.position, min(8, len(others)))\n                else:\n                    cand = []\n                best_bridge = None\n                for q in cand:\n                    if not self._edge_blocked_cached(nn.position, q.position, obstacles, is_3d):\n                        tot = nn.cost + self._dist(nn.position, q.position) + q.cost\n                        if best_bridge is None or tot < best_bridge[1]:\n                            best_bridge = (q, tot)\n                if best_bridge is not None:\n                    q = best_bridge[0]\n                    raw = self._merge_path(nn, q, active_a)\n                    plen = self._path_len(raw)\n                    if plen < best_len:\n                        best_len = plen\n                        best_raw = raw\n                        if patience_deadline is None:\n                            patience_deadline = it + self.opt_patience\n\n                if patience_deadline is not None and it >= patience_deadline and best_len < float('inf'):\n                    path = self._post_smooth(best_raw, obstacles, is_3d)\n                    return PlannerResult(True, path, nodes, edges)\n\n            it += 1\n\n        if best_len < float('inf'):\n            path = self._post_smooth(best_raw, obstacles, is_3d)\n            return PlannerResult(True, path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and helpers\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xFFFFFFFF\n        return (self._rng & 0xFFFFFFFF) / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            x, y, z = pos\n            for o in obstacles:\n                ox, oy, oz, w, h, d = o\n                if ox <= x <= ox + w and oy <= y <= oy + h and oz <= z <= oz + d:\n                    return True\n        else:\n            x, y = pos\n            for o in obstacles:\n                ox, oy, w, h = o\n                if ox <= x <= ox + w and oy <= y <= oy + h:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return False\n        steps = int(d / max(1e-9, self.collision_step))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[k] + (b[k] - a[k]) * t for k in range(self.dim))\n            if self._in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _ekey(self, a, b):\n        qa = tuple(int(a[i] / self._edge_q + 0.5) for i in range(self.dim))\n        qb = tuple(int(b[i] / self._edge_q + 0.5) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        return (qb, qa)\n\n    def _edge_blocked_cached(self, a, b, obstacles, is_3d):\n        k = self._ekey(a, b)\n        v = self._edge_cache.get(k)\n        if v is not None:\n            return v == 1\n        blk = self._edge_blocked(a, b, obstacles, is_3d)\n        self._edge_cache[k] = 1 if blk else 2\n        self._edge_keys.append(k)\n        if len(self._edge_keys) > self.edge_cache_limit:\n            cut = int(self.edge_cache_limit * 0.25)\n            for i in range(cut):\n                kk = self._edge_keys[i]\n                if kk in self._edge_cache:\n                    del self._edge_cache[kk]\n            self._edge_keys = self._edge_keys[cut:]\n        return blk\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _advance(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return None\n        lim = min(d, self.step_size * self.max_connect_mult)\n        step = max(0.5 * self.collision_step, min(self.step_size, lim))\n        dirv = tuple((b[i] - a[i]) / d for i in range(self.dim))\n        last = a\n        s = step\n        while s <= lim + 1e-9:\n            p = tuple(a[k] + dirv[k] * s for k in range(self.dim))\n            if (not self._in_bounds(p)) or self._in_obstacle(p, obstacles, is_3d) or self._edge_blocked_cached(last, p, obstacles, is_3d):\n                break\n            last = p\n            s += step\n        if last is a:\n            return None\n        return self._clamp(last)\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        for _ in range(64):\n            if is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._in_obstacle(p, obstacles, is_3d):\n                return p\n        if is_3d:\n            return (0.5 * self.bounds[0], 0.5 * self.bounds[1], 0.5 * self.bounds[2])\n        return (0.5 * self.bounds[0], 0.5 * self.bounds[1])\n\n    def _sample_informed(self, best_len, start, goal, obstacles, is_3d):\n        f = self._dist(start, goal)\n        L = max(best_len, f + 1e-6)\n        for _ in range(64):\n            t = self._rand()\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            if self.dim == 3:\n                w = 0.5 * L\n                while True:\n                    ox = self._uniform(-w, w)\n                    oy = self._uniform(-w, w)\n                    oz = self._uniform(-w, w)\n                    if ox * ox + oy * oy + oz * oz <= w * w:\n                        p = self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n                        break\n            else:\n                w = 0.35 * L\n                while True:\n                    ox = self._uniform(-w, w)\n                    oy = self._uniform(-w, w)\n                    if ox * ox + oy * oy <= w * w:\n                        p = self._clamp((base[0] + ox, base[1] + oy))\n                        break\n            if not self._in_obstacle(p, obstacles, is_3d) and (self._dist(p, start) + self._dist(p, goal) <= L * 1.001):\n                return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_target(self, best_len, start, goal, other_root_pos, other_grid, other_frontier, obstacles, is_3d):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            return self._sample_informed(best_len, start, goal, obstacles, is_3d)\n        rr = self._rand()\n        if rr < self.goal_bias:\n            return other_root_pos\n        if rr < self.goal_bias + self.bridge_bias:\n            seed = self._sample_free(obstacles, is_3d)\n            q = self._nearest(other_grid, other_frontier, seed)\n            return q.position if q is not None else seed\n        return self._sample_free(obstacles, is_3d)\n\n    # Grid indexing\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _collect_cells(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, frontier, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, 3):\n            cand = self._collect_cells(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                        found = True\n                if found:\n                    return best\n        if frontier:\n            m = min(24, len(frontier))\n            for i in range(m):\n                n = frontier[-1 - i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _nearby(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._collect_cells(grid, key, r)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        lst = self._nearby(grid, pos, radius)\n        return len(lst) > 0\n\n    def _k_closest(self, nodes, pos, k):\n        if len(nodes) <= k:\n            return list(nodes)\n        best = []\n        bestd = []\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if len(best) < k:\n                best.append(n)\n                bestd.append(d)\n            else:\n                wi = 0\n                wv = bestd[0]\n                for i in range(1, k):\n                    if bestd[i] > wv:\n                        wv = bestd[i]\n                        wi = i\n                if d < wv:\n                    best[wi] = n\n                    bestd[wi] = d\n        return best\n\n    # Parent choose and rewiring\n    def _adaptive_radius(self, nT):\n        if nT <= 1:\n            return 3.0 * self.step_size\n        scale = (1.0 + self.gamma_radius / (1.0 + (nT ** (1.0 / max(1, self.dim)))))\n        return max(1.1 * self.step_size, self.step_size * scale)\n\n    def _choose_parent(self, new_pos, grid, frontier, radius, obstacles, is_3d):\n        key = self._grid_key(new_pos)\n        r = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._collect_cells(grid, key, r)\n        best = None\n        best_cost = float('inf')\n        for n in cand:\n            d = self._dist(n.position, new_pos)\n            if d <= radius:\n                if not self._edge_blocked_cached(n.position, new_pos, obstacles, is_3d):\n                    c = n.cost + d\n                    if c < best_cost:\n                        best_cost = c\n                        best = n\n        if best is None and frontier:\n            m = min(16, len(frontier))\n            for i in range(m):\n                n = frontier[-1 - i]\n                d = self._dist(n.position, new_pos)\n                if not self._edge_blocked_cached(n.position, new_pos, obstacles, is_3d):\n                    c = n.cost + d\n                    if c < best_cost:\n                        best_cost = c\n                        best = n\n        if best is None:\n            return None, None\n        return best, best_cost\n\n    def _propagate_cost(self, node):\n        q = [node]\n        head = 0\n        while head < len(q):\n            cur = q[head]\n            head += 1\n            for c in cur.children:\n                nc = cur.cost + self._dist(cur.position, c.position)\n                if abs(nc - c.cost) > 1e-12:\n                    c.cost = nc\n                    q.append(c)\n\n    def _remove_edge(self, edges, a, b):\n        i = 0\n        while i < len(edges):\n            e = edges[i]\n            if e[0] is a and e[1] is b:\n                edges.pop(i)\n                return\n            i += 1\n\n    # Path utilities and smoothing\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_path(self, a_node, b_node, a_active):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        pb.reverse()\n        if len(pa) == 0:\n            return pb\n        if len(pb) == 0:\n            return pa\n        if pa[-1] == pb[0]:\n            return pa + pb[1:]\n        return pa + pb\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _vis_collapse(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        while i < len(path) - 1:\n            nxt = path[i + 1]\n            if self._edge_blocked_cached(anchor, nxt, obstacles, is_3d):\n                out.append(path[i])\n                anchor = path[i]\n            i += 1\n        out.append(path[-1])\n        j = 1\n        while j < len(out) - 1:\n            if not self._edge_blocked_cached(out[j - 1], out[j + 1], obstacles, is_3d):\n                out.pop(j)\n            else:\n                j += 1\n        return out\n\n    def _shortcut(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and n >= 3:\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 2, n - 1))\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked_cached(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n            tries += 1\n        return pts\n\n    def _arc_smooth(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        for _ in range(self.smooth_passes):\n            i = 1\n            while i < len(pts) - 1:\n                a = pts[i - 1]\n                c = pts[i + 1]\n                mid = tuple((0.35 * a[k] + 0.30 * pts[i][k] + 0.35 * c[k]) for k in range(self.dim))\n                if (self._in_bounds(mid) and\n                    not self._in_obstacle(mid, obstacles, is_3d) and\n                    not self._edge_blocked_cached(a, mid, obstacles, is_3d) and\n                    not self._edge_blocked_cached(mid, c, obstacles, is_3d)):\n                    pts[i] = mid\n                i += 1\n        return pts\n\n    def _post_smooth(self, raw_path, obstacles, is_3d):\n        p = self._vis_collapse(raw_path, obstacles, is_3d)\n        p = self._shortcut(p, obstacles, is_3d, self.shortcut_attempts)\n        p = self._arc_smooth(p, obstacles, is_3d)\n        return p",
        "objective": null,
        "time_improvement": null,
        "length_improvement": null,
        "smoothness_improvement": null,
        "node_improvement": null,
        "other_inf": {
            "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: Planner.__init__() got an unexpected keyword argument 'max_iter'\n"
        }
    },
    {
        "operator": "m2",
        "algorithm_description": null,
        "planning_mechanism": null,
        "code": null,
        "objective": null,
        "time_improvement": null,
        "length_improvement": null,
        "smoothness_improvement": null,
        "node_improvement": null,
        "success_rate": null,
        "other_inf": {
            "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
        }
    },
    {
        "operator": "e2",
        "algorithm_description": "FUSED-IB-RRT-Lite: A fast, bi-directional, informed RRT with capped RRT*-lite rewiring, adaptive hashed-nearest search, density-aware duplicate suppression, symmetric short bridging, multi-ancestor line-of-sight compression under budgeted cost updates, and LRU-quantized edge caching. It consolidates speed from SWIFT-Connect and quality from XR-IBiRRT* while avoiding cache thrash, oversized neighbor scans, and early suboptimal returns.",
        "planning_mechanism": "Alternate tree growth with mixture sampling (goal/corridor/uniform; ellipse-informed after a provisional path). Each iteration: find nearest via expanding hash-grid rings, steer once, enforce both node and edge collision checks, choose the cheapest parent among k local neighbors plus short ancestor lookback, then insert. Perform short LOS compression with budgeted subtree cost updates and capped rewiring of nearby nodes. Attempt symmetric short bridging from the opposite tree (direct or few bounded extensions). Maintain best path and continue informed refinement for a short stall window. Finalize with visibility pruning and shortcutting.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=6.0,\n                 goal_bias=0.20,\n                 informed_bias=0.55,\n                 corridor_bias=0.25,\n                 grid_cell_factor=1.2,\n                 max_ring=4,\n                 k_near=16,\n                 lookback_depth=3,\n                 rewire_radius_factor=2.5,\n                 rewire_k=12,\n                 rewire_budget=200,\n                 bucket_soft_cap=12,\n                 dupe_radius_factor=0.4,\n                 connect_trials=3,\n                 connect_step_factor=1.25,\n                 connect_direct_radius_factor=6.0,\n                 stall_after=500,\n                 edge_cache_capacity=60000,\n                 edge_cache_quant=0.5,\n                 smoothing_shortcuts=120):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.max_ring = int(max_ring)\n        self.k_near = int(max(4, k_near))\n        self.lookback_depth = int(max(0, lookback_depth))\n        self.rewire_radius_factor = float(max(1.0, rewire_radius_factor))\n        self.rewire_k = int(max(0, rewire_k))\n        self.rewire_budget = int(max(0, rewire_budget))\n        self.bucket_soft_cap = int(max(2, bucket_soft_cap))\n        self.dupe_radius_factor = float(max(0.1, dupe_radius_factor))\n        self.connect_trials = int(max(0, connect_trials))\n        self.connect_step_factor = float(max(1.0, connect_step_factor))\n        self.connect_direct_radius_factor = float(max(1.0, connect_direct_radius_factor))\n        self.stall_after = int(max(100, stall_after))\n        self.edge_cache_capacity = int(max(5000, edge_cache_capacity))\n        self.edge_cache_quant = float(max(0.1, edge_cache_quant))\n        self.smoothing_shortcuts = int(max(0, smoothing_shortcuts))\n        self._rng = 987654321\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Build obstacle grid and initialize caches\n        self._build_obstacle_grid()\n        self.ecache = {}\n        self._tick = 0\n\n        # Validate endpoints\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight solution\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Parameters\n        self.cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.rewire_radius = max(self.step_size, self.rewire_radius_factor * self.step_size)\n        self.connect_direct_radius = max(self.step_size, self.connect_direct_radius_factor * self.step_size)\n        self.dupe_radius_base = max(0.4, self.step_size * self.dupe_radius_factor)\n\n        # Trees and node grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_path = None\n        best_len = 1e100\n        d_sg = self._dist(self.start, self.goal)\n        last_improve_iter = 0\n\n        for it in range(self.max_iter):\n            from_start = (it % 2 == 0)\n            tree1 = tree_a if from_start else tree_b\n            tree2 = tree_b if from_start else tree_a\n            grid1 = grid_a if from_start else grid_b\n            grid2 = grid_b if from_start else grid_a\n            attractor = self.goal if from_start else self.start\n\n            # Sample\n            if best_path is not None and self._rand() < self.informed_bias:\n                x_rand = self._sample_informed(best_len)\n                if x_rand is None:\n                    x_rand = self._sample_corridor(d_sg)\n            else:\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    x_rand = self._sample_corridor(d_sg)\n                else:\n                    x_rand = self._sample_free()\n            if x_rand is None:\n                continue\n\n            # Nearest and steer\n            qnear = self._nearest_in_grid(grid1, x_rand, self.max_ring)\n            if qnear is None:\n                continue\n            x_new = self._steer(qnear.position, x_rand, self.step_size)\n            if not self._in_bounds(x_new):\n                continue\n\n            # Density-aware duplicate suppression\n            dup_r = self._dup_radius_for_cell(grid1, x_new)\n            if self._has_nearby(grid1, x_new, dup_r):\n                continue\n\n            # Mandatory checks before considering insertion\n            if self._point_in_obstacles(x_new):\n                continue\n            if not self._edge_free(qnear.position, x_new):\n                continue\n\n            # Choose best parent among local neighbors and short lookback\n            parent, new_cost = self._choose_parent(grid1, qnear, x_new)\n\n            # Soft bucket admission\n            if not self._bucket_accept(grid1, x_new, new_cost):\n                continue\n\n            # Insert node (both node and edge checks already ensured)\n            new_node = Node(x_new, parent, new_cost)\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(grid1, new_node)\n\n            # Short multi-ancestor LOS compression with budgeted cost update\n            self._compress_ancestors(new_node, edges)\n\n            # Capped rewiring of nearby nodes\n            if self.rewire_k > 0:\n                self._rewire_neighbors(new_node, grid1, edges)\n\n            # Try to connect to the opposite tree (direct or bounded extend)\n            a_end, b_end = self._attempt_connect(new_node, tree2, grid2, nodes, edges)\n            if a_end is not None and b_end is not None:\n                path = self._merge_paths(a_end, b_end, from_start)\n                plen = self._path_len(path)\n                if plen + 1e-9 < best_len:\n                    best_path = path\n                    best_len = plen\n                    last_improve_iter = it\n\n            # Stop after stall window of refinement\n            if best_path is not None and (it - last_improve_iter) >= self.stall_after:\n                final = self._finalize(best_path)\n                return PlannerResult(True, final, nodes, edges)\n\n        if best_path is not None:\n            final = self._finalize(best_path)\n            return PlannerResult(True, final, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xFFFFFFFF\n        return (self._rng / 4294967296.0)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return tuple(a)\n        if d <= step:\n            return self._clamp_tuple(b)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Sampling\n    def _sample_free(self):\n        for _ in range(64):\n            if self.dims == 3:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _sample_corridor(self, dsg):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        width = max(self.step_size, 0.12 * dsg)\n        for _ in range(24):\n            if self.dims == 3:\n                ox = self._rand_range(-width, width)\n                oy = self._rand_range(-width, width)\n                oz = self._rand_range(-width, width)\n                if ox * ox + oy * oy + oz * oz > width * width:\n                    continue\n                p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n            else:\n                ox = self._rand_range(-width, width)\n                oy = self._rand_range(-width, width)\n                if ox * ox + oy * oy > width * width:\n                    continue\n                p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n            if not self._point_in_obstacles(p):\n                return p\n        return self._sample_free()\n\n    def _sample_informed(self, best_len):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dims))\n        a = 0.5 * best_len\n        for _ in range(48):\n            if self.dims == 3:\n                p = (self._rand_range(c[0] - a, c[0] + a),\n                     self._rand_range(c[1] - a, c[1] + a),\n                     self._rand_range(c[2] - a, c[2] + a))\n            else:\n                p = (self._rand_range(c[0] - a, c[0] + a),\n                     self._rand_range(c[1] - a, c[1] + a))\n            if not self._in_bounds(p):\n                continue\n            if self._dist(self.start, p) + self._dist(p, self.goal) <= best_len + 1e-9 and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Node grid\n    def _cell_of(self, pos):\n        if self.dims == 3:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell), int(pos[2] // self.cell))\n        else:\n            return (int(pos[0] // self.cell), int(pos[1] // self.cell))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        b = grid.get(key)\n        if b is None:\n            grid[key] = [node]\n        else:\n            b.append(node)\n\n    def _nearest_in_grid(self, grid, pos, max_ring):\n        cell = self._cell_of(pos)\n        best = None\n        bestd = 1e100\n        # Expand rings\n        if self.dims == 3:\n            for r in range(0, max_ring + 1):\n                found = False\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            b = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if not b:\n                                continue\n                            for n in b:\n                                d = self._dist(n.position, pos)\n                                if d < bestd:\n                                    bestd = d\n                                    best = n\n                                    found = True\n                if found and best is not None:\n                    return best\n        else:\n            for r in range(0, max_ring + 1):\n                found = False\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        b = grid.get((cell[0] + dx, cell[1] + dy))\n                        if not b:\n                            continue\n                        for n in b:\n                            d = self._dist(n.position, pos)\n                            if d < bestd:\n                                bestd = d\n                                best = n\n                                found = True\n                if found and best is not None:\n                    return best\n        # Fallback: sample a few nodes uniformly from buckets to avoid O(N) full scan\n        tried = 0\n        approx = None\n        approx_d = 1e100\n        for key, lst in grid.items():\n            for n in lst:\n                if self._rand() < 0.02:  # 2% sampling\n                    d = self._dist(n.position, pos)\n                    if d < approx_d:\n                        approx_d = d\n                        approx = n\n                tried += 1\n                if tried > 500:\n                    break\n            if tried > 500:\n                break\n        return best if best is not None else approx\n\n    def _collect_neighbors_k(self, grid, pos, radius, kmax):\n        cell = self._cell_of(pos)\n        r_cells = int(max(1, radius // self.cell) + 1)\n        cand = []\n        r2 = radius * radius\n        def try_add(n):\n            d = 0.0\n            for i in range(self.dims):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d > r2:\n                return\n            if len(cand) < kmax:\n                idx = len(cand)\n                while idx > 0 and cand[idx - 1][0] > d:\n                    idx -= 1\n                cand.insert(idx, (d, n))\n            else:\n                if d < cand[-1][0]:\n                    # insert in order and drop worst\n                    idx = len(cand) - 1\n                    while idx > 0 and cand[idx - 1][0] > d:\n                        idx -= 1\n                    cand.insert(idx, (d, n))\n                    cand.pop()\n        if self.dims == 3:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            try_add(n)\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((cell[0] + dx, cell[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        try_add(n)\n        return [p[1] for p in cand]\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        r_cells = int(max(1, radius // self.cell) + 1)\n        r2 = radius * radius\n        if self.dims == 3:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._sqdist(n.position, pos) <= r2:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((cell[0] + dx, cell[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._sqdist(n.position, pos) <= r2:\n                            return True\n        return False\n\n    def _sqdist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dup_radius_for_cell(self, grid, pos):\n        key = self._cell_of(pos)\n        b = grid.get(key)\n        if not b:\n            return self.dupe_radius_base\n        occ = len(b)\n        if occ >= self.bucket_soft_cap:\n            return max(0.5, 0.5 * self.dupe_radius_base)\n        if occ >= self.bucket_soft_cap // 2:\n            return max(0.5, 0.75 * self.dupe_radius_base)\n        return self.dupe_radius_base\n\n    def _bucket_accept(self, grid, pos, new_cost):\n        key = self._cell_of(pos)\n        b = grid.get(key)\n        if not b:\n            return True\n        if len(b) < self.bucket_soft_cap:\n            return True\n        worst = -1e100\n        for n in b:\n            if n.cost > worst:\n                worst = n.cost\n        return new_cost + 1e-9 < worst\n\n    # Parent selection and rewiring\n    def _choose_parent(self, grid, qnear, x_new):\n        best_parent = qnear\n        best_cost = qnear.cost + self._dist(qnear.position, x_new)\n\n        nbrs = self._collect_neighbors_k(grid, x_new, self.rewire_radius, self.k_near)\n        for n in nbrs:\n            if n is qnear:\n                continue\n            if self._edge_free(n.position, x_new):\n                c = n.cost + self._dist(n.position, x_new)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best_parent = n\n\n        # Short ancestor lookback from qnear\n        cur = qnear\n        depth = 0\n        while cur is not None and depth < self.lookback_depth:\n            if self._edge_free(cur.position, x_new):\n                c = cur.cost + self._dist(cur.position, x_new)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best_parent = cur\n            cur = cur.parent\n            depth += 1\n        return best_parent, best_cost\n\n    def _compress_ancestors(self, node, edges):\n        # Attempt to reparent node directly to an ancestor if LOS reduces path notably\n        cur = node.parent\n        best_anc = None\n        best_cost = node.cost\n        depth = 0\n        while cur is not None and depth < (self.lookback_depth + 2):\n            if self._edge_free(cur.position, node.position):\n                c = cur.cost + self._dist(cur.position, node.position)\n                if c + 1e-6 < best_cost * 0.98:\n                    best_cost = c\n                    best_anc = cur\n            cur = cur.parent\n            depth += 1\n        if best_anc is not None and best_anc is not node.parent:\n            oldp = node.parent\n            if oldp is not None:\n                oldp.remove_child(node)\n            self._remove_edge(edges, oldp, node)\n            best_anc.add_child(node)\n            node.cost = best_cost\n            edges.append((best_anc, node))\n            # Budgeted subtree cost update\n            if self.rewire_budget > 0:\n                self._propagate_cost_budget(node, self.rewire_budget)\n\n    def _rewire_neighbors(self, node, grid, edges):\n        nbrs = self._collect_neighbors_k(grid, node.position, self.rewire_radius, self.rewire_k)\n        budget = self.rewire_budget\n        for nb in nbrs:\n            if nb is node or nb is node.parent:\n                continue\n            cand = node.cost + self._dist(node.position, nb.position)\n            if cand + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                oldp = nb.parent\n                if oldp is not None:\n                    oldp.remove_child(nb)\n                self._remove_edge(edges, oldp, nb)\n                node.add_child(nb)\n                nb.cost = cand\n                edges.append((node, nb))\n                if budget > 0:\n                    used = self._propagate_cost_budget(nb, budget)\n                    budget = max(0, budget - used)\n                if budget <= 0:\n                    break\n\n    def _propagate_cost_budget(self, node, budget):\n        # Recompute subtree costs from node downward with a node-visit budget\n        count = 0\n        stack = list(node.children)\n        while stack and count < budget:\n            cur = stack.pop()\n            if cur.parent is not None:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                stack.append(ch)\n            count += 1\n        return count\n\n    def _remove_edge(self, edges, a, b):\n        if a is None or b is None:\n            return\n        for i in range(len(edges)):\n            if edges[i][0] is a and edges[i][1] is b:\n                edges.pop(i)\n                return\n\n    # Connect attempt\n    def _attempt_connect(self, new_node, other_tree, other_grid, nodes, edges):\n        qnear = self._nearest_in_grid(other_grid, new_node.position, self.max_ring)\n        if qnear is None:\n            return (None, None)\n        # If close enough, try direct\n        if self._dist(qnear.position, new_node.position) <= self.connect_direct_radius:\n            if self._edge_free(new_node.position, qnear.position):\n                return (new_node, qnear)\n        # Bounded extend\n        cur = qnear\n        trials = 0\n        while trials < self.connect_trials:\n            step = self.step_size * self.connect_step_factor\n            nxt_pos = self._steer(cur.position, new_node.position, step)\n            if not self._in_bounds(nxt_pos):\n                break\n            if self._point_in_obstacles(nxt_pos):\n                break\n            if self._has_nearby(other_grid, nxt_pos, self._dup_radius_for_cell(other_grid, nxt_pos)):\n                break\n            if not self._edge_free(cur.position, nxt_pos):\n                break\n            nxt = Node(nxt_pos, cur, cur.cost + self._dist(cur.position, nxt_pos))\n            # Both node and edge checks ensured above\n            cur.add_child(nxt)\n            other_tree.append(nxt)\n            nodes.append(nxt)\n            edges.append((cur, nxt))\n            self._grid_insert(other_grid, nxt)\n            # Light compression toward grandparent\n            gp = cur.parent\n            if gp is not None and self._edge_free(gp.position, nxt_pos):\n                cur.remove_child(nxt)\n                self._remove_edge(edges, cur, nxt)\n                gp.add_child(nxt)\n                nxt.cost = gp.cost + self._dist(gp.position, nxt_pos)\n                edges.append((gp, nxt))\n            cur = nxt\n            trials += 1\n            if self._edge_free(cur.position, new_node.position):\n                return (new_node, cur)\n        return (None, None)\n\n    # Path utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_paths(self, a_end, b_end, from_start):\n        pa = self._path_to_root(a_end)\n        pb = self._path_to_root(b_end)\n        if from_start:\n            pb.reverse()\n            return pa + pb\n        else:\n            pa.reverse()\n            return pb + pa\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _finalize(self, path):\n        pruned = self._visibility_prune(path)\n        return self._shortcut(pruned, self.smoothing_shortcuts)\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return list(path)\n        pts = list(path)\n        best = self._path_len(pts)\n        tries = 0\n        while tries < attempts and len(pts) >= 3:\n            i = int(self._rand_range(0, len(pts) - 2))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(pts[i], pts[j]):\n                new_pts = pts[:i + 1] + pts[j:]\n                new_len = self._path_len(new_pts)\n                if new_len + 1e-9 < best:\n                    pts = new_pts\n                    best = new_len\n            tries += 1\n        return pts\n\n    # Obstacle grid and collision\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.dims == 3:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            key = (cx, cy, cz)\n                            lst = self.obs_grid.get(key)\n                            if lst is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        key = (cx, cy)\n                        lst = self.obs_grid.get(key)\n                        if lst is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.dims == 3:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.edge_cache_quant) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.edge_cache_quant) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    @property\n    def edge_cache_quant(self):\n        return self.edge_cache_quant_override if hasattr(self, 'edge_cache_quant_override') else self.edge_cache_quant\n\n    def _edge_free(self, a, b):\n        # LRU-quantized edge cache\n        q = self.edge_cache_quant\n        qa = tuple(int(a[i] / q) for i in range(self.dims))\n        qb = tuple(int(b[i] / q) for i in range(self.dims))\n        key = (qa, qb) if qa <= qb else (qb, qa)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        if len(self.ecache) > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self.ecache:\n            return\n        cutoff = self._tick - 4000\n        to_del = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            i = 0\n            for k in list(self.ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self.ecache:\n                del self.ecache[k]\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(self.dims):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True",
        "objective": null,
        "time_improvement": null,
        "length_improvement": null,
        "smoothness_improvement": null,
        "node_improvement": null,
        "other_inf": {
            "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nAttributeError: can't set attribute 'edge_cache_quant'\n"
        }
    },
    {
        "operator": "time_expert",
        "algorithm_description": null,
        "planning_mechanism": null,
        "code": null,
        "objective": null,
        "time_improvement": null,
        "length_improvement": null,
        "smoothness_improvement": null,
        "node_improvement": null,
        "success_rate": null,
        "other_inf": {
            "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
        }
    },
    {
        "operator": "e2",
        "algorithm_description": null,
        "planning_mechanism": null,
        "code": null,
        "objective": null,
        "time_improvement": null,
        "length_improvement": null,
        "smoothness_improvement": null,
        "node_improvement": null,
        "success_rate": null,
        "other_inf": {
            "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
        }
    },
    {
        "operator": "e1",
        "algorithm_description": null,
        "planning_mechanism": null,
        "code": null,
        "objective": null,
        "time_improvement": null,
        "length_improvement": null,
        "smoothness_improvement": null,
        "node_improvement": null,
        "success_rate": null,
        "other_inf": {
            "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
        }
    },
    {
        "operator": "path_expert",
        "algorithm_description": "E-BIT* LS: Edge-Ordered Batch Informed Trees with Length-Selective rewiring \u2014 an anytime, batch-sampling planner that prioritizes edges by tight cost-to-go lower bounds, connects only length-improving candidates, and continuously contracts the incumbent path via global visibility shortcuts for aggressive path-length minimization.",
        "planning_mechanism": "The planner alternates between informed batch sampling and a best-first expansion of a min-heap of candidate edges scored by f = g(parent) + d(parent, sample) + h(sample, goal). Each accepted edge performs both node and edge collision checks, adds a new node, and triggers bounded local rewiring to reduce nearby costs. After any goal improvement, c_best tightens the informed set, and a global farthest-valid shortcut routine reduces the current path length. The process continues until budgets expire, returning a short, visibility-compressed, shortcut-optimized path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            try:\n                self.parent.children.remove(self)\n            except:\n                pass\n        self.parent = new_parent\n        if new_parent is not None:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_edge_expansions=35000,\n                 batch_size=240,\n                 step_size=3.0,\n                 gamma_radius=70.0,\n                 min_radius_factor=1.0,\n                 near_cap=56,\n                 rewire_cap=48,\n                 goal_bias=0.12,\n                 line_bias=0.35,\n                 no_improve_limit=6000,\n                 post_opt_limit=6000,\n                 smoothing_iters=500):\n        self.max_edge_expansions = max_edge_expansions\n        self.batch_size = batch_size\n        self.step_size = step_size\n        self.gamma_radius = gamma_radius\n        self.min_radius_factor = min_radius_factor\n        self.near_cap = near_cap\n        self.rewire_cap = rewire_cap\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.no_improve_limit = no_improve_limit\n        self.post_opt_limit = post_opt_limit\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Basic validations and trivial solution\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(success=False, path=[], nodes=[], edges=[])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(success=False, path=[], nodes=[], edges=[])\n\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, None, self._dist(start, goal))\n            g.attach(s)\n            nodes = [s, g]\n            edges = [(s, g)]\n            path = [start, goal]\n            return PlannerResult(success=True, path=path, nodes=nodes, edges=edges)\n\n        # Initialize tree\n        root = Node(start, None, 0.0)\n        nodes = [root]\n        node_grid_cell = max(1.0, 0.8 * self.step_size)\n        node_grid = {}\n        self._grid_add_node(node_grid, root, node_grid_cell)\n\n        # Samples storage\n        sample_grid_cell = max(1.0, 0.8 * self.step_size)\n        sample_grid = {}\n        samples = []         # list of positions (tuple)\n        alive = []           # parallel bool list\n        active_count = 0\n\n        # Edge queue (min-heap): (f, eid, parent_node, sample_index)\n        edge_heap = []\n        self._heap = edge_heap\n        self._eid = 0\n\n        # Best solution tracking\n        success = False\n        goal_node = None\n        c_best = float('inf')\n        best_path = None\n        best_path_len = float('inf')\n\n        # Control\n        expansions = 0\n        no_improve = 0\n        post_opt = 0\n        found_first = False\n\n        # Main loop\n        while expansions < self.max_edge_expansions:\n            if not edge_heap:\n                # New batch of informed samples\n                self._sample_batch(samples, alive, sample_grid, sample_grid_cell, start, goal, c_best, obstacles, is_3d)\n                active_count = self._alive_count(alive)\n                # Generate candidate edges from current tree nodes to nearby samples\n                if active_count > 0:\n                    r = self._connect_radius(max(2, len(nodes)))\n                    # For each node produce candidates to close samples\n                    for pn in nodes:\n                        cand_idx = self._samples_near(sample_grid, pn.position, r, sample_grid_cell, samples, alive)\n                        if cand_idx:\n                            if len(cand_idx) > self.near_cap:\n                                cand_idx = self._limit_candidates_by_dist(cand_idx, samples, pn.position, self.near_cap)\n                            for si in cand_idx:\n                                if not alive[si]:\n                                    continue\n                                sp = samples[si]\n                                # Lower bound score\n                                g = pn.cost\n                                d = self._dist(pn.position, sp)\n                                f = g + d + self._dist(sp, goal)\n                                if f + 1e-12 < c_best:\n                                    self._pq_push((f, self._next_eid(), pn, si))\n            if not edge_heap:\n                # No edges to expand; if a solution was found and no new samples can help, stop\n                break\n\n            f, _, parent, si = self._pq_pop()\n            if si >= len(samples) or si < 0:\n                continue\n            if si >= len(alive) or not alive[si]:\n                continue\n\n            sp = samples[si]\n            # Select best parent among nearby tree nodes for this sample (one-shot local RRT* parent selection)\n            r = self._connect_radius(max(2, len(nodes)))\n            near_nodes = self._nodes_near(node_grid, sp, r, node_grid_cell)\n            if not near_nodes:\n                near_nodes = [parent]\n            else:\n                if parent not in near_nodes:\n                    near_nodes.append(parent)\n            if len(near_nodes) > self.near_cap:\n                near_nodes = self._limit_nodes_by_dist(near_nodes, sp, self.near_cap)\n\n            best_parent = None\n            best_cost = float('inf')\n            # Node collision check before any edge attempt\n            if self._is_in_obstacle(sp, obstacles, is_3d):\n                alive[si] = False\n                continue\n\n            for pn in near_nodes:\n                base = pn.cost + self._dist(pn.position, sp)\n                if base + 1e-12 >= best_cost:\n                    continue\n                # Edge collision check\n                if not self._is_edge_in_obstacle(pn.position, sp, obstacles, is_3d):\n                    best_parent = pn\n                    best_cost = base\n\n            if best_parent is None:\n                # Could not connect this sample; discard it\n                alive[si] = False\n                continue\n\n            # Commit new node\n            new_node = Node(sp, None, best_cost)\n            new_node.attach(best_parent)\n            nodes.append(new_node)\n            self._grid_add_node(node_grid, new_node, node_grid_cell)\n            alive[si] = False\n            expansions += 1\n\n            # Length-selective local rewiring around new_node\n            neigh = self._nodes_near(node_grid, new_node.position, r, node_grid_cell)\n            if len(neigh) > self.rewire_cap:\n                neigh = self._limit_nodes_by_dist(neigh, new_node.position, self.rewire_cap)\n            for nn in neigh:\n                if nn is new_node or nn is best_parent:\n                    continue\n                alt = new_node.cost + self._dist(new_node.position, nn.position)\n                if alt + 1e-12 < nn.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nn.position, obstacles, is_3d):\n                        nn.attach(new_node)\n                        nn.cost = alt\n                        self._propagate_costs(nn)\n\n            # Immediate goal connection attempt\n            improved = False\n            to_goal = self._dist(new_node.position, goal)\n            if new_node.cost + to_goal + 1e-12 < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, goal, obstacles, is_3d):\n                    if goal_node is None:\n                        goal_node = Node(goal, None, new_node.cost + to_goal)\n                        goal_node.attach(new_node)\n                        nodes.append(goal_node)\n                    else:\n                        goal_node.attach(new_node)\n                        goal_node.cost = new_node.cost + to_goal\n                    c_best = goal_node.cost\n                    success = True\n                    found_first = True\n                    improved = True\n\n            # Push new candidates from new_node to nearby samples\n            if active_count > 0:\n                cand_idx = self._samples_near(sample_grid, new_node.position, r, sample_grid_cell, samples, alive)\n                if cand_idx:\n                    if len(cand_idx) > self.near_cap:\n                        cand_idx = self._limit_candidates_by_dist(cand_idx, samples, new_node.position, self.near_cap)\n                    for sj in cand_idx:\n                        if not alive[sj]:\n                            continue\n                        spj = samples[sj]\n                        g = new_node.cost\n                        d = self._dist(new_node.position, spj)\n                        fscore = g + d + self._dist(spj, goal)\n                        if fscore + 1e-12 < c_best:\n                            self._pq_push((fscore, self._next_eid(), new_node, sj))\n\n            # Online path tightening to minimize length\n            if improved and goal_node is not None:\n                path = self._extract_path(goal_node)\n                path = self._visibility_compress(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, 120)\n                plen = self._path_length(path)\n                if plen + 1e-12 < c_best:\n                    c_best = plen\n                best_path = path\n                best_path_len = self._path_length(best_path)\n                no_improve = 0\n                post_opt = 0\n            else:\n                if found_first:\n                    no_improve += 1\n                    post_opt += 1\n                    if no_improve >= self.no_improve_limit or post_opt >= self.post_opt_limit:\n                        break\n\n        # Final path construction and polishing\n        path = []\n        if success and goal_node is not None:\n            if best_path is None:\n                path = self._extract_path(goal_node)\n                path = self._visibility_compress(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n            else:\n                # final aggressive length-focused passes\n                path = self._visibility_compress(best_path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters + 200)\n\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---------- Random utilities ----------\n    def _rand(self):\n        return self._lcg()\n    def _lcg(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n    def _randint(self, a, b):\n        # inclusive [a,b]\n        if b <= a:\n            return a\n        u = self._rand()\n        k = int(a + (b - a + 1) * u)\n        if k > b:\n            k = b\n        return k\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = max(0.5, 0.4 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Radii and logs ----------\n    def _connect_radius(self, n):\n        r = self.gamma_radius\n        if n > 2:\n            expo = 1.0 / float(max(2, self.dim))\n            r = self.gamma_radius * ((self._log_approx(n) / float(n)) ** expo)\n        rmin = max(self.min_radius_factor * self.step_size, 1e-6)\n        if r < rmin:\n            r = rmin\n        return r\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    # ---------- Spatial hashing ----------\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add_node(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _nodes_near(self, grid, center_pos, radius, cell):\n        out = []\n        rng = int(radius // cell) + 1\n        base = self._grid_key(center_pos, cell)\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (base[0] + dx, base[1] + dy)\n                    if k in grid:\n                        for n in grid[k]:\n                            if self._dist(n.position, center_pos) <= radius:\n                                out.append(n)\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (base[0] + dx, base[1] + dy, base[2] + dz)\n                        if k in grid:\n                            for n in grid[k]:\n                                if self._dist(n.position, center_pos) <= radius:\n                                    out.append(n)\n        return out\n\n    def _grid_add_sample_idx(self, grid, pos, idx, cell):\n        k = self._grid_key(pos, cell)\n        if k in grid:\n            grid[k].append(idx)\n        else:\n            grid[k] = [idx]\n\n    def _samples_near(self, grid, center_pos, radius, cell, samples, alive):\n        out = []\n        rng = int(radius // cell) + 1\n        base = self._grid_key(center_pos, cell)\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (base[0] + dx, base[1] + dy)\n                    if k in grid:\n                        for idx in grid[k]:\n                            if idx < 0 or idx >= len(samples):\n                                continue\n                            if not alive[idx]:\n                                continue\n                            sp = samples[idx]\n                            if self._dist(sp, center_pos) <= radius:\n                                out.append(idx)\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (base[0] + dx, base[1] + dy, base[2] + dz)\n                        if k in grid:\n                            for idx in grid[k]:\n                                if idx < 0 or idx >= len(samples):\n                                    continue\n                                if not alive[idx]:\n                                    continue\n                                sp = samples[idx]\n                                if self._dist(sp, center_pos) <= radius:\n                                    out.append(idx)\n        return out\n\n    # ---------- Sampling ----------\n    def _sample_batch(self, samples, alive, grid, cell, start, goal, c_best, obstacles, is_3d):\n        # Informed rejection sampling in bounding box; also line/goal bias\n        added = 0\n        tries = 0\n        max_tries = self.batch_size * 20\n        while added < self.batch_size and tries < max_tries:\n            tries += 1\n            r = self._rand()\n            if r < self.goal_bias:\n                p = goal\n            elif r < self.goal_bias + self.line_bias:\n                t = self._uniform(0.0, 1.0)\n                base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n                jitter = 0.5 * self.step_size\n                p = tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n            else:\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n            if not self._in_bounds(p):\n                continue\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                continue\n            if c_best < float('inf'):\n                if self._dist(p, start) + self._dist(p, goal) > c_best:\n                    continue\n            idx = len(samples)\n            samples.append(p)\n            alive.append(True)\n            self._grid_add_sample_idx(grid, p, idx, cell)\n            added += 1\n\n    # ---------- Priority queue ----------\n    def _next_eid(self):\n        self._eid += 1\n        return self._eid\n\n    def _pq_push(self, item):\n        h = self._heap\n        h.append(item)\n        self._sift_up(len(h) - 1)\n\n    def _pq_pop(self):\n        h = self._heap\n        last = h.pop()\n        if not h:\n            return last\n        top = h[0]\n        h[0] = last\n        self._sift_down(0)\n        return top\n\n    def _sift_up(self, i):\n        h = self._heap\n        while i > 0:\n            p = (i - 1) >> 1\n            if h[i][0] < h[p][0] or (h[i][0] == h[p][0] and h[i][1] < h[p][1]):\n                h[i], h[p] = h[p], h[i]\n                i = p\n            else:\n                break\n\n    def _sift_down(self, i):\n        h = self._heap\n        n = len(h)\n        while True:\n            l = (i << 1) + 1\n            r = l + 1\n            smallest = i\n            if l < n and (h[l][0] < h[smallest][0] or (h[l][0] == h[smallest][0] and h[l][1] < h[smallest][1])):\n                smallest = l\n            if r < n and (h[r][0] < h[smallest][0] or (h[r][0] == h[smallest][0] and h[r][1] < h[smallest][1])):\n                smallest = r\n            if smallest != i:\n                h[i], h[smallest] = h[smallest], h[i]\n                i = smallest\n            else:\n                break\n\n    # ---------- Helpers ----------\n    def _limit_candidates_by_dist(self, idx_list, samples, center, k):\n        # partial selection without full sort\n        if len(idx_list) <= k:\n            return idx_list\n        best = []\n        for idx in idx_list:\n            d = self._dist(samples[idx], center)\n            best.append((d, idx))\n        best.sort(key=lambda t: t[0])\n        return [t[1] for t in best[:k]]\n\n    def _limit_nodes_by_dist(self, nodes, center, k):\n        if len(nodes) <= k:\n            return nodes\n        arr = []\n        for n in nodes:\n            arr.append((self._dist(n.position, center), n))\n        arr.sort(key=lambda t: t[0])\n        return [t[1] for t in arr[:k]]\n\n    def _alive_count(self, alive):\n        c = 0\n        for v in alive:\n            if v:\n                c += 1\n        return c\n\n    def _propagate_costs(self, node):\n        stack = []\n        for c in node.children:\n            stack.append(c)\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                newc = u.parent.cost + self._dist(u.parent.position, u.position)\n                if abs(newc - u.cost) > 1e-12:\n                    u.cost = newc\n            for c in u.children:\n                stack.append(c)\n\n    def _extract_path(self, goal_node):\n        seq = []\n        cur = goal_node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _visibility_compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = self._randint(0, n - 3)\n            j = self._randint(i + 2, n - 1)\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        return pts",
        "objective": null,
        "time_improvement": null,
        "length_improvement": null,
        "smoothness_improvement": null,
        "node_improvement": null,
        "other_inf": {
            "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 172, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 131, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: Planner.__init__() got an unexpected keyword argument 'max_iter'\n"
        }
    },
    {
        "operator": "path_expert",
        "algorithm_description": null,
        "planning_mechanism": null,
        "code": null,
        "objective": null,
        "time_improvement": null,
        "length_improvement": null,
        "smoothness_improvement": null,
        "node_improvement": null,
        "success_rate": null,
        "other_inf": {
            "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 161, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 120, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
        }
    },
    {
        "operator": "path_expert",
        "algorithm_description": "Informed Densified Roadmap A* (IDRA*): an anytime, graph-based planner that minimizes path length by building a sparse, collision-checked roadmap with k-nearest connections and running A* with an admissible Euclidean heuristic. After the first solution, it restricts sampling to the informed prolate-ellipsoid and actively densifies around the incumbent path, repeatedly re-solving A* to drive the length down. Collision gating and spatial hashing keep construction efficient, and final compress+shortcut smoothing produces a near-straight, low-length path.",
        "planning_mechanism": "Mechanism: Iteratively sample valid points (goal/line/ellipse-biased), insert if non-duplicate, and connect to up to k nearest neighbors within an adaptive PRM* radius, validating edges on insertion. Periodically run A* over the validated roadmap; upon finding a solution, focus sampling inside the informed set and along the current path to reduce length. Terminate on iteration/no-improvement budget, then compress and shortcut the path; return nodes with parent pointers along the final path and coherent edges from those parents.",
        "code": "class Node:\n    def __init__(self, position):\n        self.position = position\n        self.parent = None\n        self.cost = float('inf')\n        self.children = []\nclass Planner:\n    def __init__(self,\n                 max_samples=3000,\n                 k_neighbors=14,\n                 gamma_radius=0.14,     # as fraction of map diagonal for initial radius\n                 min_radius_factor=0.02, # min radius as fraction of diagonal\n                 goal_bias=0.12,\n                 line_bias=0.35,\n                 run_interval=10,\n                 densify_samples=40,\n                 max_no_improve=160,\n                 smoothing_iters=200):\n        self.max_samples = max_samples\n        self.k_neighbors = k_neighbors\n        self.gamma_radius = gamma_radius\n        self.min_radius_factor = min_radius_factor\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.run_interval = run_interval\n        self.densify_samples = densify_samples\n        self.max_no_improve = max_no_improve\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        # Validate start/goal\n        if (not self._in_bounds(start_pos)) or (not self._in_bounds(goal_pos)):\n            return PlannerResult(success=False, path=[], nodes=[], edges=[])\n        if self._is_in_obstacle(start_pos, obstacles, is_3d) or self._is_in_obstacle(goal_pos, obstacles, is_3d):\n            return PlannerResult(success=False, path=[], nodes=[], edges=[])\n\n        # Nodes and adjacency (separate from Node.children to keep final tree coherent)\n        nodes = []\n        adj = {}  # dict: Node -> list of neighbor Nodes (undirected)\n        start = Node(start_pos)\n        goal = Node(goal_pos)\n        nodes.append(start)\n        nodes.append(goal)\n        adj[start] = []\n        adj[goal] = []\n\n        # Fast straight-line solution\n        if not self._is_edge_in_obstacle(start_pos, goal_pos, obstacles, is_3d):\n            path = [start_pos, goal_pos]\n            path = self._compress(path, obstacles, is_3d)\n            path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n            # set tree parents along path\n            self._assign_path(nodes, path)\n            edges = self._edges_from_parents(nodes)\n            return PlannerResult(success=True, path=path, nodes=nodes, edges=edges)\n\n        # Spatial hashing for neighbor queries\n        diag = self._dist(tuple(0.0 for _ in range(self.dim)), tuple(self.bounds[i] for i in range(self.dim)))\n        base_radius = max(self.min_radius_factor * diag, self.gamma_radius * diag)\n        cell = max(1.0, 0.4 * base_radius)\n        grid = {}\n        self._grid_add(grid, start, cell)\n        self._grid_add(grid, goal, cell)\n\n        # Duplicate suppression\n        occ_cell = max(0.5, 0.5 * base_radius)\n        occ = {self._occ_key(start_pos, occ_cell): True,\n               self._occ_key(goal_pos, occ_cell): True}\n\n        # Sampling / search loop\n        best_cost = float('inf')\n        best_path = []\n        no_improve = 0\n        samples_added = 0\n\n        for it in range(self.max_samples):\n            # Select sampling policy\n            if best_cost < float('inf'):\n                x_rand = self._sample_informed(start_pos, goal_pos, best_cost)\n            else:\n                x_rand = self._sample_mixed(start_pos, goal_pos)\n\n            if not self._in_bounds(x_rand):\n                continue\n            if self._is_in_obstacle(x_rand, obstacles, is_3d):\n                continue\n\n            k_occ = self._occ_key(x_rand, occ_cell)\n            if k_occ in occ:\n                continue\n\n            new_node = Node(x_rand)\n            nodes.append(new_node)\n            adj[new_node] = []\n            self._grid_add(grid, new_node, cell)\n            occ[k_occ] = True\n            samples_added += 1\n\n            # Connect to neighbors (up to k) within adaptive radius\n            radius = self._prm_radius(max(2, len(nodes)), diag, base_radius)\n            neighbors = self._near_radius_k(grid, x_rand, radius, self.k_neighbors, cell)\n            # Ensure start/goal are considered if within radius\n            # Already included by grid gathering\n            # Sort neighbors by distance (ascending)\n            if neighbors:\n                dlist = []\n                for nn in neighbors:\n                    dlist.append((self._dist(nn.position, x_rand), nn))\n                dlist.sort(key=lambda t: t[0])\n                added = 0\n                for _, nb in dlist:\n                    if added >= self.k_neighbors:\n                        break\n                    # Edge collision check\n                    if not self._is_edge_in_obstacle(nb.position, x_rand, obstacles, is_3d):\n                        self._add_edge(adj, new_node, nb)\n                        added += 1\n\n            # Periodically run A*\n            if samples_added % self.run_interval == 0:\n                found, path_nodes, path_cost = self._astar(adj, start, goal)\n                if found and path_cost + 1e-12 < best_cost:\n                    best_cost = path_cost\n                    best_path = [n.position for n in path_nodes]\n                    no_improve = 0\n                    # Densify around current path to further reduce length\n                    self._densify_around_path(best_path, obstacles, is_3d, nodes, adj, grid, occ, cell,\n                                              occ_cell, diag, base_radius)\n                    # Re-solve quickly after densification\n                    dfound, dnodes, dcost = self._astar(adj, start, goal)\n                    if dfound and dcost + 1e-12 < best_cost:\n                        best_cost = dcost\n                        best_path = [n.position for n in dnodes]\n                else:\n                    no_improve += 1\n\n            if best_cost < float('inf') and no_improve >= self.max_no_improve:\n                break\n\n        success = best_cost < float('inf')\n        path = []\n        if success:\n            path = list(best_path)\n            path = self._compress(path, obstacles, is_3d)\n            path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n\n        # Build final coherent tree along path (parents/children/edges)\n        self._assign_path(nodes, path)\n        edges = self._edges_from_parents(nodes)\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---------- Sampling policies ----------\n    def _sample_mixed(self, start, goal):\n        r = self._rand()\n        if r < self.goal_bias:\n            return goal\n        if r < self.goal_bias + self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jitter = 0.02 * self._extent()\n            return tuple(self._clip(base[i] + self._uniform(-jitter, jitter), 0.0, self.bounds[i]) for i in range(self.dim))\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _sample_informed(self, start, goal, c_best):\n        # rejection within prolate ellipsoid: dist(start,p)+dist(p,goal)<=c_best\n        for _ in range(40):\n            p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n            if self._dist(p, start) + self._dist(p, goal) <= c_best and self._in_bounds(p):\n                return p\n        # fallback\n        return self._sample_mixed(start, goal)\n\n    def _densify_around_path(self, path, obstacles, is_3d, nodes, adj, grid, occ, cell, occ_cell, diag, base_radius):\n        if not path or len(path) < 2:\n            return\n        m = len(path)\n        for _ in range(self.densify_samples):\n            i = int(self._uniform(0, m - 1))\n            j = i + 1\n            if j >= m:\n                j = m - 1\n            a = path[i]\n            b = path[j]\n            # Midpoint with lateral jitter\n            mid = tuple((a[d] + b[d]) * 0.5 for d in range(self.dim))\n            # lateral jitter magnitude is small\n            mag = 0.01 * self._extent()\n            jitter = tuple(self._uniform(-mag, mag) for _ in range(self.dim))\n            p = tuple(self._clip(mid[d] + jitter[d], 0.0, self.bounds[d]) for d in range(self.dim))\n            if not self._in_bounds(p):\n                continue\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                continue\n            k = self._occ_key(p, occ_cell)\n            if k in occ:\n                continue\n            new_node = Node(p)\n            nodes.append(new_node)\n            adj[new_node] = []\n            self._grid_add(grid, new_node, cell)\n            occ[k] = True\n            # connect locally\n            radius = self._prm_radius(max(2, len(nodes)), diag, base_radius)\n            nbrs = self._near_radius_k(grid, p, radius, self.k_neighbors, cell)\n            if nbrs:\n                dlist = []\n                for nn in nbrs:\n                    dlist.append((self._dist(nn.position, p), nn))\n                dlist.sort(key=lambda t: t[0])\n                added = 0\n                for _, nb in dlist:\n                    if added >= self.k_neighbors:\n                        break\n                    if not self._is_edge_in_obstacle(nb.position, p, obstacles, is_3d):\n                        self._add_edge(adj, new_node, nb)\n                        added += 1\n\n    # ---------- Graph search (A*) ----------\n    def _astar(self, adj, start, goal):\n        # Map nodes to indices\n        nodes = list(adj.keys())\n        idx = {}\n        for i, n in enumerate(nodes):\n            idx[n] = i\n        nN = len(nodes)\n        s = idx[start]\n        g = idx[goal]\n\n        g_cost = [float('inf')] * nN\n        parent = [-1] * nN\n        in_open = [False] * nN\n        closed = [False] * nN\n\n        g_cost[s] = 0.0\n        open_list = [s]\n        in_open[s] = True\n\n        def h(i):\n            return self._dist(nodes[i].position, nodes[g].position)\n\n        while open_list:\n            # select node with smallest f = g + h\n            best_i = 0\n            best_f = g_cost[open_list[0]] + h(open_list[0])\n            for k in range(1, len(open_list)):\n                f = g_cost[open_list[k]] + h(open_list[k])\n                if f < best_f:\n                    best_f = f\n                    best_i = k\n            u = open_list.pop(best_i)\n            in_open[u] = False\n            if closed[u]:\n                continue\n            closed[u] = True\n\n            if u == g:\n                # reconstruct\n                path_nodes = []\n                cur = g\n                total_cost = g_cost[g]\n                while cur != -1:\n                    path_nodes.append(nodes[cur])\n                    cur = parent[cur]\n                path_nodes.reverse()\n                return True, path_nodes, total_cost\n\n            # relax neighbors\n            u_node = nodes[u]\n            for v_node in adj.get(u_node, []):\n                v = idx.get(v_node, -1)\n                if v == -1 or closed[v]:\n                    continue\n                w = self._dist(u_node.position, v_node.position)\n                alt = g_cost[u] + w\n                if alt + 1e-12 < g_cost[v]:\n                    g_cost[v] = alt\n                    parent[v] = u\n                    if not in_open[v]:\n                        open_list.append(v)\n                        in_open[v] = True\n\n        return False, [], float('inf')\n\n    # ---------- Utilities ----------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 1103515245\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _extent(self):\n        # average bound length\n        s = 0.0\n        for i in range(self.dim):\n            s += self.bounds[i]\n        return s / float(max(1, self.dim))\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            # sample moderately fine relative to map size\n            resolution = max(0.5, 0.005 * self._extent())\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        # ln(n) ~ bit_length * ln(2)\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    def _prm_radius(self, n, diag, base_radius):\n        # adaptive PRM* radius: gamma * (log n / n)^(1/d), lower-bounded\n        expo = 1.0 / float(max(2, self.dim))\n        val = base_radius\n        if n > 2:\n            val = base_radius * ((self._log_approx(n) / float(n)) ** expo)\n        min_r = max(self.min_radius_factor * diag, 1e-6)\n        if val < min_r:\n            val = min_r\n        return val\n\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        key = self._grid_key(center_pos, cell)\n        cand = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (key[0] + dx, key[1] + dy)\n                    if k in grid:\n                        cand.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (key[0] + dx, key[1] + dy, key[2] + dz)\n                        if k in grid:\n                            cand.extend(grid[k])\n        return cand\n\n    def _near_radius_k(self, grid, pos, radius, k, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        dlist = []\n        for n in cand:\n            d = self._dist(n.position, pos)\n            if d <= radius and d > 0.0:\n                dlist.append((d, n))\n        if not dlist:\n            return out\n        dlist.sort(key=lambda t: t[0])\n        for i in range(min(k, len(dlist))):\n            out.append(dlist[i][1])\n        return out\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _add_edge(self, adj, a, b):\n        # undirected, avoid duplicates\n        la = adj.get(a, None)\n        lb = adj.get(b, None)\n        if la is None or lb is None:\n            return\n        # prevent duplicates\n        found = False\n        for n in la:\n            if n is b:\n                found = True\n                break\n        if not found:\n            la.append(b)\n        found = False\n        for n in lb:\n            if n is a:\n                found = True\n                break\n        if not found:\n            lb.append(a)\n\n    def _compress(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts\n\n    def _assign_path(self, nodes, path_positions):\n        # reset\n        for nd in nodes:\n            nd.parent = None\n            nd.children = []\n            nd.cost = float('inf')\n        if not path_positions:\n            return\n        # map path positions to closest existing nodes (since we used node positions to build path)\n        # Build a lookup: position -> node (best exact match); fallback to nearest if needed\n        pos_to_node = {}\n        for nd in nodes:\n            pos_to_node[nd.position] = nd\n        path_nodes = []\n        for p in path_positions:\n            nd = pos_to_node.get(p, None)\n            if nd is None:\n                # pick nearest\n                best = None\n                bestd = float('inf')\n                for q in nodes:\n                    d = self._dist(q.position, p)\n                    if d < bestd:\n                        bestd = d\n                        best = q\n                nd = best\n            path_nodes.append(nd)\n        # set parents/children along path\n        cost = 0.0\n        path_nodes[0].cost = 0.0\n        for i in range(1, len(path_nodes)):\n            child = path_nodes[i]\n            parent = path_nodes[i - 1]\n            child.parent = parent\n            parent.children.append(child)\n            cost += self._dist(parent.position, child.position)\n            child.cost = cost\n\n    def _edges_from_parents(self, nodes):\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n        return edges",
        "objective": null,
        "time_improvement": null,
        "length_improvement": null,
        "smoothness_improvement": null,
        "node_improvement": null,
        "other_inf": {
            "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 161, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 120, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: Planner.__init__() got an unexpected keyword argument 'max_iter'\n"
        }
    },
    {
        "operator": "e1",
        "algorithm_description": "LUMEN-BR*: Layered, Unbiased, Minimal-entropy, Enhanced-Neighborhood BiRRT*. It combines informed sampling with an adaptive RRT* radius schedule, hashed-neighborhood queries, quantized LRU edge-collision caching, obstacle-grid accelerated validity, selective cost-propagating rewiring, and best-first bridging to deliver fast, short, and smooth paths with strong anytime behavior.",
        "planning_mechanism": "Alternate expansion of two trees with informed/corridor/goaled sampling. For each sample, steer once, validate node and edge, and select a parent from an adaptive-radius neighbor set minimizing g+\u03bbh. Insert with per-cell throttling and perform selective rewiring with stack-based cost propagation. Attempt best-first direct bridges to the opposite tree from a ranked nearby set. Maintain and return the best path found; finalize with visibility pruning and cache-aware shortcutting.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        child.parent = self\n        if child not in self.children:\n            self.children.append(child)\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4500,\n        step_size=8.5,\n        collision_res=1.0,\n        goal_bias=0.2,\n        informed_bias=0.55,\n        corridor_bias=0.25,\n        grid_cell_factor=1.0,\n        per_cell_cap=7,\n        dupe_radius_ratio=0.5,\n        r_factor=3.0,\n        neighbor_cap=24,\n        connect_k=10,\n        edge_cache_cap=45000,\n        edge_quant=0.9,\n        smooth_attempts=60,\n        stall_limit=600\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.collision_res = float(collision_res)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.per_cell_cap = int(max(2, per_cell_cap))\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.r_factor = float(r_factor)\n        self.neighbor_cap = int(max(6, neighbor_cap))\n        self.connect_k = int(max(2, connect_k))\n        self.edge_cache_cap = int(max(4000, edge_cache_cap))\n        self.edge_quant = float(max(0.2, edge_quant))\n        self.smooth_attempts = int(max(0, smooth_attempts))\n        self.stall_limit = int(max(100, stall_limit))\n\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        self._seed_scene()\n        self.node_cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.edge_step = max(0.5, min(self.collision_res, 0.5 * self.step_size))\n\n        # Obstacle grid and caches\n        self._build_obs_grid()\n        if self._point_blocked(self.start) or self._point_blocked(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._ecache = {}\n        self._tick = 0\n        self._last_prune = 0\n\n        # Early straight line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Trees and structures\n        nodes = []\n        edges = []\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n        A, B = [a_root], [b_root]\n        gridA, gridB = {}, {}\n        anchorsA, anchorsB = [a_root], [b_root]\n        self._grid_add(gridA, a_root)\n        self._grid_add(gridB, b_root)\n\n        best_path = None\n        best_len = float('inf')\n        base_line = self._dist(self.start, self.goal)\n        last_improve = -1\n\n        for it in range(self.max_iter):\n            sideA = (it % 2 == 0)\n            tree = A if sideA else B\n            ogrd = gridA if sideA else gridB\n            anchors = anchorsA if sideA else anchorsB\n            other_tree = B if sideA else A\n            other_grid = gridB if sideA else gridA\n            other_anchors = anchorsB if sideA else anchorsA\n            attractor = self.goal if sideA else self.start\n\n            # Sample with informed/corridor/goaled bias\n            q_rand = None\n            if best_path is not None and self._rand() < self.informed_bias:\n                q_rand = self._sample_informed(best_len)\n            else:\n                r = self._rand()\n                if r < self.goal_bias:\n                    q_rand = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    q_rand = self._sample_corridor(base_line)\n                else:\n                    q_rand = self._sample_free()\n            if q_rand is None:\n                continue\n\n            # Nearest and steer\n            near = self._nearest(ogrd, anchors, q_rand, 4)\n            if near is None:\n                continue\n            q_new = self._steer(near.position, q_rand)\n            if not self._in_bounds(q_new):\n                continue\n            if self._point_blocked(q_new):\n                continue\n            if self._exists_close(ogrd, q_new, self.dupe_radius):\n                continue\n\n            # Candidate parents within adaptive radius\n            rad = self._neighbor_radius(len(nodes))\n            parents = self._neighbors_within(ogrd, q_new, rad)\n            if not parents:\n                parents = [near]\n            if len(parents) > self.neighbor_cap:\n                parents = self._k_closest(parents, q_new, self.neighbor_cap)\n\n            # Parent selection with small heuristic\n            other_hint = self._nearest(other_grid, other_anchors, q_new, 3)\n            h = self._dist(q_new, other_hint.position if other_hint else attractor)\n            lam = 0.08\n            best_parent = None\n            best_new_cost = 1e100\n            best_score = 1e100\n            for p in parents:\n                if not self._edge_free(p.position, q_new):\n                    continue\n                gc = p.cost + self._dist(p.position, q_new)\n                score = gc + lam * h\n                if score < best_score - 1e-12:\n                    best_score = score\n                    best_new_cost = gc\n                    best_parent = p\n            if best_parent is None:\n                continue\n\n            # Per-cell throttling with admission\n            ckey = self._cell_key(q_new)\n            bucket = ogrd.get(ckey)\n            if bucket and len(bucket) >= self.per_cell_cap:\n                # admit only if strictly better than worst in cell\n                worst = max(bucket, key=lambda n: n.cost)\n                if best_new_cost >= worst.cost - 1e-9:\n                    continue\n\n            # Final validity before insertion\n            if self._point_blocked(q_new):\n                continue\n            if not self._edge_free(best_parent.position, q_new):\n                continue\n\n            # Insert\n            nn = Node(q_new, best_parent, best_new_cost)\n            best_parent.add_child(nn)\n            tree.append(nn)\n            nodes.append(nn)\n            edges.append((best_parent, nn))\n            self._grid_add(ogrd, nn)\n            if (len(tree) % 24) == 0:\n                anchors.append(nn)\n\n            # Selective rewiring\n            self._rewire_local(ogrd, nn, rad, edges)\n\n            # Best-first bridge to other tree\n            cands = self._neighbors_within(other_grid, nn.position, max(rad, self.step_size * 4.0))\n            if not cands and other_tree:\n                cands = [self._nearest(other_grid, other_anchors, nn.position, 4)]\n            ranked = []\n            for q in cands:\n                if q is None:\n                    continue\n                est = nn.cost + self._dist(nn.position, q.position) + q.cost\n                ranked.append((est, q))\n            ranked.sort(key=lambda x: x[0])\n\n            connected = False\n            connect_pair = None\n            for _, q in ranked[:self.connect_k]:\n                if self._edge_free(nn.position, q.position):\n                    connected = True\n                    connect_pair = (nn, q)\n                    break\n\n            if connected:\n                if sideA:\n                    path = self._merge(nn, connect_pair[1])\n                else:\n                    path = self._merge(connect_pair[1], nn)\n                L = self._path_len(path)\n                if L + 1e-9 < best_len:\n                    best_len = L\n                    best_path = path\n                    last_improve = it\n                final = self._finalize(best_path)\n                return PlannerResult(True, final, nodes, edges)\n\n            # Anytime stall guard\n            if best_path is not None and (it - last_improve) >= self.stall_limit:\n                final = self._finalize(best_path)\n                return PlannerResult(True, final, nodes, edges)\n\n        if best_path is not None:\n            final = self._finalize(best_path)\n            return PlannerResult(True, final, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_scene(self):\n        s = 1469598103934665603\n        for v in self.start + self.goal:\n            s ^= int(v * 997 + 0.5) & 0xffffffffffffffff\n            s *= 1099511628211\n            s &= 0xffffffffffffffff\n        s ^= len(self.obstacles) * 1315423911\n        self._rng = (s & 0xffffffff) or 2463534242\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Obstacle grid\n    def _build_obs_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.6)\n        self.obs_grid = {}\n        if self.dim == 3:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            lst = self.obs_grid.get(k)\n                            if lst is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        lst = self.obs_grid.get(k)\n                        if lst is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_blocked(self, p):\n        if self.dim == 3:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    # Edge cache and collision\n    def _e_key(self, a, b):\n        qa = tuple(int(a[i] / self.edge_quant) for i in range(self.dim))\n        qb = tuple(int(b[i] / self.edge_quant) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    @property\n    def edge_quant(self):\n        return self.edge_quant if hasattr(self, 'edge_quant') else 1.0\n\n    def _edge_free(self, a, b):\n        key = self._e_key(a, b)\n        hit = self._ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self._ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._seg_hits_any_aabb(a, b)\n        self._tick += 1\n        self._ecache[key] = (free, self._tick)\n        if len(self._ecache) - self._last_prune > self.edge_cache_cap:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        cutoff = self._tick - 4000\n        to_drop = []\n        for k, v in self._ecache.items():\n            if v[1] < cutoff:\n                to_drop.append(k)\n        if not to_drop:\n            i = 0\n            for k in list(self._ecache.keys()):\n                if (i % 3) == 0:\n                    to_drop.append(k)\n                i += 1\n        for k in to_drop:\n            if k in self._ecache:\n                del self._ecache[k]\n        self._last_prune = len(self._ecache)\n\n    def _seg_hits_any_aabb(self, a, b):\n        if self.dim == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        lst = self.obs_grid.get((cx, cy, cz))\n                        if lst:\n                            for idx in lst:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    lst = self.obs_grid.get((cx, cy))\n                    if lst:\n                        for idx in lst:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        t0 = 0.0\n        t1 = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                a = (mn - p) * inv\n                b = (mx - p) * inv\n                if a > b:\n                    a, b = b, a\n                if a > t0:\n                    t0 = a\n                if b < t1:\n                    t1 = b\n                if t0 > t1:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        t0 = 0.0\n        t1 = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                a = (mn - p) * inv\n                b = (mx - p) * inv\n                if a > b:\n                    a, b = b, a\n                if a > t0:\n                    t0 = a\n                if b < t1:\n                    t1 = b\n                if t0 > t1:\n                    return False\n        return True\n\n    # Node grid\n    def _cell_key(self, p):\n        if self.dim == 3:\n            return (int(p[0] // self.node_cell), int(p[1] // self.node_cell), int(p[2] // self.node_cell))\n        else:\n            return (int(p[0] // self.node_cell), int(p[1] // self.node_cell))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, anchors, pos, max_rings):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # anchor fallback\n        for a in anchors:\n            d = self._dist(a.position, pos)\n            if d < bestd:\n                bestd = d\n                best = a\n        if best is not None:\n            return best\n        # worst-case scan\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_within(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        r_cells = max(1, int(radius // self.node_cell) + 1)\n        cand = self._ring_collect(grid, key, r_cells)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            nn = n.position\n            for i in range(self.dim):\n                d = nn[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n        return out\n\n    def _k_closest(self, nodes, pos, k):\n        if len(nodes) <= k:\n            return list(nodes)\n        best = []\n        dists = []\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if len(best) < k:\n                best.append(n)\n                dists.append(d)\n            else:\n                wi = 0\n                wv = dists[0]\n                for i in range(1, k):\n                    if dists[i] > wv:\n                        wi = i\n                        wv = dists[i]\n                if d < wv:\n                    best[wi] = n\n                    dists[wi] = d\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        r_cells = max(1, int(radius // self.node_cell) + 1)\n        cand = self._ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    def _neighbor_radius(self, n_nodes):\n        # Monotone-decreasing schedule inspired by RRT*; avoids log to keep import-free\n        base = self.step_size * 1.25\n        shrink = self.r_factor * self.step_size / ((n_nodes + 1) ** (1.0 / max(1, self.dim)))\n        return max(base, shrink)\n\n    # Sampling\n    def _sample_free(self):\n        for _ in range(48):\n            if self.dim == 3:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if not self._point_blocked(p):\n                return p\n        # fallback center\n        if self.dim == 3:\n            c = (0.5 * self.bounds[0], 0.5 * self.bounds[1], 0.5 * self.bounds[2])\n        else:\n            c = (0.5 * self.bounds[0], 0.5 * self.bounds[1])\n        return c\n\n    def _sample_corridor(self, baseline):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        width = max(self.step_size, 0.25 * baseline)\n        for _ in range(24):\n            if self.dim == 3:\n                ox = self._rand_range(-width, width)\n                oy = self._rand_range(-width, width)\n                oz = self._rand_range(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n                else:\n                    continue\n            else:\n                ox = self._rand_range(-width, width)\n                oy = self._rand_range(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy))\n                else:\n                    continue\n            if not self._point_blocked(p):\n                return p\n        return self._sample_free()\n\n    def _sample_informed(self, L):\n        c = tuple(0.5 * (self.start[i] + self.goal[i]) for i in range(self.dim))\n        half = 0.5 * (L * 1.02)\n        ext = [half] * self.dim\n        for _ in range(36):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dim))\n            if self._dist(self.start, p) + self._dist(p, self.goal) <= L * 1.02 and self._in_bounds(p) and not self._point_blocked(p):\n                return p\n        return self._sample_corridor(self._dist(self.start, self.goal))\n\n    # Rewiring\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _remove_edge(self, edges, a, b):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is a and edges[i][1] is b:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _reparent(self, child, new_parent, edges):\n        old = child.parent\n        if old is new_parent:\n            return\n        if old is not None:\n            old.remove_child(child)\n            self._remove_edge(edges, old, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        self._propagate_cost(child)\n\n    def _propagate_cost(self, root):\n        stack = [root]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                newc = cur.cost + self._dist(cur.position, ch.position)\n                if abs(newc - ch.cost) > 1e-12:\n                    ch.cost = newc\n                    stack.append(ch)\n\n    def _rewire_local(self, grid, node, radius, edges):\n        neigh = self._neighbors_within(grid, node.position, radius)\n        if len(neigh) > self.neighbor_cap:\n            neigh = self._k_closest(neigh, node.position, self.neighbor_cap)\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            newc = node.cost + d\n            if newc + 1e-12 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n\n    # Path utilities\n    def _to_root(self, n):\n        pts = []\n        cur = n\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge(self, a_end, b_end):\n        pa = self._to_root(a_end)\n        pb = self._to_root(b_end)\n        pb.reverse()\n        return pa + pb\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _vis_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        i = 0\n        while i < len(path) - 2:\n            a = out[-1]\n            c = path[i + 2]\n            if self._edge_free(a, c):\n                i += 1\n            else:\n                out.append(path[i + 1])\n                i += 1\n        out.append(path[-1])\n        return out\n\n    def _shortcut(self, path):\n        if len(path) < 3 or self.smooth_attempts <= 0:\n            return list(path)\n        pts = list(path)\n        best = self._path_len(pts)\n        tries = 0\n        stagnate = 0\n        while tries < self.smooth_attempts and len(pts) >= 3 and stagnate < 12:\n            i = int(self._rand_range(0, max(1, len(pts) - 2)))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L + 1e-12 <= best:\n                    pts = new_pts\n                    best = L\n                    stagnate = 0\n                else:\n                    stagnate += 1\n            else:\n                stagnate += 1\n            tries += 1\n        return pts\n\n    def _finalize(self, path):\n        if not path:\n            return []\n        p1 = self._vis_prune(path)\n        p2 = self._shortcut(p1)\n        return p2",
        "objective": null,
        "time_improvement": null,
        "length_improvement": null,
        "smoothness_improvement": null,
        "node_improvement": null,
        "other_inf": {
            "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 161, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 120, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nAttributeError: can't set attribute 'edge_quant'\n"
        }
    },
    {
        "operator": "cross_over",
        "algorithm_description": "VESTA-IBiRRT*: Velocity-Enhanced Ellipse-Guided Sparse Trees with Truncated Rewiring and Adaptive Connect. The planner accelerates search with orientation-aligned direct ellipse sampling after a first path, hashed-grid nearest with soft bucket caps and de-duplication, and an LRU edge-collision memo. Path length is reduced by curvature-aware parent choice, grandparent LOS compression, bounded local rewiring with limited propagation, and RRT-Connect-style adaptive bridging. Final paths are visibility-pruned and shortcut-refined.",
        "planning_mechanism": "Alternate growth from start/goal trees. Each iteration: sample from goal/corridor/free; once a path exists, switch to oriented prolate-ellipse sampling tied to the start\u2013goal axis. Find a near node via a hashed grid; steer once; ensure point and segment collision-free. Select the cheapest parent among k-near candidates with a small curvature penalty; admit if the destination bucket isn\u2019t saturated. Insert the node, attempt grandparent LOS compression, then rewire cheaper neighbors with bounded propagation. Try to connect to the opposite tree by direct edge or short bounded extensions, inserting only after both point and edge checks. Maintain and improve the best path during a short informed refinement phase. Return a visibility-pruned, shortcut-smoothed path.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=8.0,\n                 goal_bias=0.25,\n                 informed_bias=0.6,\n                 corridor_bias=0.35,\n                 grid_cell_factor=1.2,\n                 dupe_radius_factor=0.6,\n                 bucket_soft_cap=10,\n                 k_near_max=20,\n                 rewire_radius_factor=3.0,\n                 propagate_limit=60,\n                 curvature_lambda=0.05,\n                 connect_max_steps=6,\n                 shortcut_attempts=80,\n                 stall_after=400,\n                 edge_cache_capacity=35000,\n                 edge_cache_quant=0.75):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.informed_bias = float(informed_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.grid_cell_factor = float(max(0.5, grid_cell_factor))\n        self.dupe_radius_factor = float(max(0.1, dupe_radius_factor))\n        self.bucket_soft_cap = int(max(2, bucket_soft_cap))\n        self.k_near_max = int(max(4, k_near_max))\n        self.rewire_radius_factor = float(max(1.0, rewire_radius_factor))\n        self.propagate_limit = int(max(0, propagate_limit))\n        self.curvature_lambda = float(max(0.0, curvature_lambda))\n        self.connect_max_steps = int(max(0, connect_max_steps))\n        self.shortcut_attempts = int(max(0, shortcut_attempts))\n        self.stall_after = int(max(50, stall_after))\n        self.edge_cache_capacity = int(max(5000, edge_cache_capacity))\n        self.edge_cache_quant = float(max(0.1, edge_cache_quant))\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._build_obstacle_grid()\n        if self._point_in_obs(self.start) or self._point_in_obs(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Parameters based on scene\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_factor)\n        self.rewire_radius = max(self.step_size, self.rewire_radius_factor * self.step_size)\n\n        # Edge cache (LRU)\n        self._tick = 0\n        self._ecache = {}\n\n        # Trivial direct edge\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        d_sg = self._dist(self.start, self.goal)\n        best_path = None\n        best_len = float('inf')\n        last_improve_iter = 0\n\n        for it in range(self.max_iter):\n            active_from_start = (it % 2 == 0)\n            tree1 = tree_a if active_from_start else tree_b\n            tree2 = tree_b if active_from_start else tree_a\n            grid1 = grid_a if active_from_start else grid_b\n            grid2 = grid_b if active_from_start else grid_a\n            attractor = self.goal if active_from_start else self.start\n\n            # Sampling\n            if best_path is not None and self._rand() < self.informed_bias:\n                x_rand = self._sample_informed_direct(best_len)\n                if x_rand is None:\n                    x_rand = self._sample_corridor(d_sg)\n            else:\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = attractor\n                elif r < self.goal_bias + self.corridor_bias:\n                    x_rand = self._sample_corridor(d_sg)\n                else:\n                    x_rand = self._sample_free()\n            if x_rand is None:\n                continue\n\n            # Nearest and steer\n            qnear = self._nearest_in_grid(grid1, x_rand)\n            if qnear is None:\n                continue\n            x_new = self._steer(qnear.position, x_rand, self.step_size)\n            if not self._in_bounds(x_new):\n                continue\n            if self._point_in_obs(x_new):\n                continue\n            if self._has_nearby(grid1, x_new, self.dupe_radius):\n                continue\n\n            # Must check edge before insertion\n            if not self._edge_free(qnear.position, x_new):\n                continue\n\n            # Choose parent among neighbors with small curvature penalty\n            parent, new_cost = self._choose_parent(grid1, qnear, x_new)\n\n            # Soft-cap admission by bucket\n            if not self._bucket_accept(grid1, x_new, new_cost):\n                continue\n\n            # Insert node (both checks passed)\n            new_node = Node(x_new, parent, new_cost)\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_insert(grid1, new_node)\n\n            # Grandparent LOS compression\n            gp = parent.parent\n            if gp is not None and self._edge_free(gp.position, new_node.position):\n                try:\n                    parent.children.remove(new_node)\n                except:\n                    pass\n                self._remove_edge(edges, parent, new_node)\n                gp.add_child(new_node)\n                new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n                edges.append((gp, new_node))\n                parent = gp  # for local rewiring proximity\n\n            # Local rewiring with bounded propagation\n            nbrs = self._neighbors_k(grid1, new_node.position, self.rewire_radius, self.k_near_max)\n            for nb in nbrs:\n                if nb is new_node:\n                    continue\n                cand_cost = new_node.cost + self._dist(new_node.position, nb.position)\n                if cand_cost + 1e-9 < nb.cost and self._edge_free(new_node.position, nb.position):\n                    oldp = nb.parent\n                    if oldp is not None:\n                        try:\n                            oldp.children.remove(nb)\n                        except:\n                            pass\n                        self._remove_edge(edges, oldp, nb)\n                    new_node.add_child(nb)\n                    nb.cost = cand_cost\n                    edges.append((new_node, nb))\n                    self._propagate_costs_limited(nb, edges, self.propagate_limit)\n\n            # Try to connect to the other tree\n            a_end, b_end = self._try_connect(new_node, tree2, grid2, nodes, edges)\n            if a_end is not None and b_end is not None:\n                path = self._merge_paths(a_end, b_end, active_from_start)\n                plen = self._path_len(path)\n                if plen + 1e-9 < best_len:\n                    best_path = path\n                    best_len = plen\n                    last_improve_iter = it\n\n            # Stop early after stall, keep some refinement iterations informed\n            if best_path is not None and (it - last_improve_iter) >= self.stall_after:\n                final = self._finalize(best_path)\n                return PlannerResult(True, final, nodes, edges)\n\n            # Periodic cache prune\n            if (it & 255) == 0:\n                self._prune_ecache()\n\n        if best_path is not None:\n            final = self._finalize(best_path)\n            return PlannerResult(True, final, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xFFFFFFFF\n        return (self._rng / 4294967296.0)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _sqdist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _in_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp_tuple(a)\n        if d <= step:\n            return self._clamp_tuple(b)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Node spatial grid\n    def _cell_key(self, pos):\n        if self.dims == 3:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        else:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        k = self._cell_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.dims == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_in_grid(self, grid, pos, max_ring=5):\n        cell = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, max_ring + 1):\n            cand = self._ring_collect(grid, cell, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback\n        for b in grid.values():\n            for n in b:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _neighbors_k(self, grid, pos, radius, kmax):\n        cell = self._cell_key(pos)\n        r_cells = int(max(1, radius // self.cell_size) + 1)\n        cand = []\n        if self.dims == 3:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((cell[0] + dx, cell[1] + dy))\n                    if b:\n                        cand.extend(b)\n        scored = []\n        for n in cand:\n            scored.append((self._dist(n.position, pos), n))\n        scored.sort(key=lambda x: x[0])\n        out = []\n        lim = min(kmax, len(scored))\n        for i in range(lim):\n            out.append(scored[i][1])\n        return out\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_key(pos)\n        r_cells = int(max(1, radius // self.cell_size) + 1)\n        r2 = radius * radius\n        if self.dims == 3:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        b = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            if self._sqdist(n.position, pos) <= r2:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    b = grid.get((cell[0] + dx, cell[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        if self._sqdist(n.position, pos) <= r2:\n                            return True\n        return False\n\n    def _bucket_accept(self, grid, pos, new_cost):\n        key = self._cell_key(pos)\n        b = grid.get(key)\n        if not b:\n            return True\n        if len(b) < self.bucket_soft_cap:\n            return True\n        worst = -1e100\n        for n in b:\n            if n.cost > worst:\n                worst = n.cost\n        return (new_cost + 1e-9) < worst\n\n    # Obstacle spatial grid and collisions\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.dims == 3:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            key = (cx, cy, cz)\n                            lst = self.obs_grid.get(key)\n                            if lst is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                lst.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        key = (cx, cy)\n                        lst = self.obs_grid.get(key)\n                        if lst is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            lst.append(idx)\n\n    def _point_in_obs(self, p):\n        if self.dims == 3:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.edge_cache_quant) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.edge_cache_quant) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    @property\n    def edge_cache_quant(self):\n        return self.edge_cache_quant if hasattr(self, \"edge_cache_quant\") else self.edge_cache_quant\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self._ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self._ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obs(a, b)\n        self._tick += 1\n        self._ecache[key] = (free, self._tick)\n        return free\n\n    def _prune_ecache(self):\n        if len(self._ecache) <= self.edge_cache_capacity:\n            return\n        # Drop the oldest half\n        items = list(self._ecache.items())\n        items.sort(key=lambda kv: kv[1][1])\n        to_drop = len(items) - self.edge_cache_capacity\n        for i in range(to_drop):\n            k = items[i][0]\n            if k in self._ecache:\n                del self._ecache[k]\n\n    def _segment_hits_obs(self, a, b):\n        if self.dims == 3:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(self.dims):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Parent selection with curvature penalty\n    def _choose_parent(self, grid, qnear, x_new):\n        best_parent = qnear\n        best_cost = qnear.cost + self._dist(qnear.position, x_new)\n        nbrs = self._neighbors_k(grid, x_new, self.rewire_radius, self.k_near_max)\n        if not nbrs:\n            return best_parent, best_cost\n        for n in nbrs:\n            if not self._edge_free(n.position, x_new):\n                continue\n            base_cost = n.cost + self._dist(n.position, x_new)\n            penalty = 0.0\n            if self.curvature_lambda > 0.0 and n.parent is not None:\n                v1 = self._vec(n.parent.position, n.position)\n                v2 = self._vec(n.position, x_new)\n                c = self._cos_between(v1, v2)\n                penalty = self.curvature_lambda * (1.0 - c) * self.step_size\n            cand = base_cost + penalty\n            if cand + 1e-9 < best_cost:\n                best_cost = cand\n                best_parent = n\n        return best_parent, best_cost\n\n    def _vec(self, a, b):\n        return tuple(b[i] - a[i] for i in range(self.dims))\n\n    def _cos_between(self, v1, v2):\n        n1 = 0.0\n        n2 = 0.0\n        dot = 0.0\n        for i in range(self.dims):\n            dot += v1[i] * v2[i]\n            n1 += v1[i] * v1[i]\n            n2 += v2[i] * v2[i]\n        if n1 <= 1e-18 or n2 <= 1e-18:\n            return 1.0\n        return max(-1.0, min(1.0, dot / ((n1 ** 0.5) * (n2 ** 0.5))))\n\n    def _propagate_costs_limited(self, node, edges, limit):\n        # BFS-limited propagation\n        count = 0\n        queue = [node]\n        while queue and count < limit:\n            cur = queue.pop(0)\n            count += 1\n            if cur.parent is not None:\n                cur.cost = cur.parent.cost + self._dist(cur.parent.position, cur.position)\n            for ch in cur.children:\n                queue.append(ch)\n\n    # Connect attempt\n    def _try_connect(self, new_node, other_tree, other_grid, nodes, edges):\n        qnear = self._nearest_in_grid(other_grid, new_node.position)\n        if qnear is None:\n            return (None, None)\n        # Direct edge\n        if self._edge_free(new_node.position, qnear.position):\n            return (new_node, qnear)\n        # Bounded extend\n        cur = qnear\n        steps = 0\n        while steps < self.connect_max_steps:\n            nxt_pos = self._steer(cur.position, new_node.position, self.step_size)\n            if not self._in_bounds(nxt_pos):\n                break\n            if self._point_in_obs(nxt_pos):\n                break\n            if not self._edge_free(cur.position, nxt_pos):\n                break\n            if self._has_nearby(other_grid, nxt_pos, self.dupe_radius):\n                break\n            nxt = Node(nxt_pos, cur, cur.cost + self._dist(cur.position, nxt_pos))\n            cur.add_child(nxt)\n            other_tree.append(nxt)\n            nodes.append(nxt)\n            edges.append((cur, nxt))\n            self._grid_insert(other_grid, nxt)\n            # short LOS compression to grandparent\n            gp = cur.parent\n            if gp is not None and self._edge_free(gp.position, nxt_pos):\n                try:\n                    cur.children.remove(nxt)\n                except:\n                    pass\n                self._remove_edge(edges, cur, nxt)\n                gp.add_child(nxt)\n                nxt.parent = gp\n                nxt.cost = gp.cost + self._dist(gp.position, nxt_pos)\n                edges.append((gp, nxt))\n            cur = nxt\n            steps += 1\n            if self._edge_free(cur.position, new_node.position):\n                return (new_node, cur)\n        return (None, None)\n\n    def _remove_edge(self, edges, a, b):\n        if a is None or b is None:\n            return\n        for i in range(len(edges)):\n            e = edges[i]\n            if e[0] is a and e[1] is b:\n                edges.pop(i)\n                return\n\n    # Sampling\n    def _sample_free(self):\n        for _ in range(64):\n            if self.dims == 3:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]),\n                     self._rand_range(0.0, self.bounds[2]))\n            else:\n                p = (self._rand_range(0.0, self.bounds[0]),\n                     self._rand_range(0.0, self.bounds[1]))\n            if not self._point_in_obs(p):\n                return p\n        return None\n\n    def _sample_corridor(self, dsg):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        width = max(self.step_size, 0.15 * dsg)\n        if self.dims == 3:\n            for _ in range(24):\n                ox = self._rand_range(-width, width)\n                oy = self._rand_range(-width, width)\n                oz = self._rand_range(-width, width)\n                if (ox * ox + oy * oy + oz * oz) > (width * width):\n                    continue\n                p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                if not self._point_in_obs(p):\n                    return p\n            return self._sample_free()\n        else:\n            for _ in range(24):\n                ox = self._rand_range(-width, width)\n                oy = self._rand_range(-width, width)\n                if (ox * ox + oy * oy) > (width * width):\n                    continue\n                p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                if not self._point_in_obs(p):\n                    return p\n            return self._sample_free()\n\n    def _sample_informed_direct(self, best_len):\n        d = self._vec(self.start, self.goal)\n        L = self._dist(self.start, self.goal)\n        if L <= 1e-12:\n            return None\n        a = 0.5 * max(best_len, L + 1e-9)\n        c = 0.5 * L\n        if a <= c + 1e-9:\n            a = c + 1e-3\n        b = (a * a - c * c) ** 0.5\n        t = self._rand()\n        center = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dims))\n        scale = (1.0 - (2.0 * t - 1.0) * (2.0 * t - 1.0)) ** 0.5  # varies from 0 at ends to 1 at middle\n        radius = b * scale\n        if self.dims == 2:\n            # Build perpendicular\n            dirx = d[0] / L\n            diry = d[1] / L\n            px = -diry\n            py = dirx\n            offset_mag = self._rand_range(-radius, radius)\n            p = (center[0] + px * offset_mag, center[1] + py * offset_mag)\n            p = self._clamp_tuple(p)\n            if self._in_bounds(p) and not self._point_in_obs(p):\n                return p\n            return None\n        else:\n            # Build two orthonormal vectors orthogonal to d\n            ux, uy, uz = d[0] / L, d[1] / L, d[2] / L\n            if abs(ux) < 0.9:\n                ax, ay, az = 1.0, 0.0, 0.0\n            else:\n                ax, ay, az = 0.0, 1.0, 0.0\n            e1x = uy * az - uz * ay\n            e1y = uz * ax - ux * az\n            e1z = ux * ay - uy * ax\n            n1 = (e1x * e1x + e1y * e1y + e1z * e1z) ** 0.5\n            if n1 <= 1e-12:\n                return None\n            e1x /= n1; e1y /= n1; e1z /= n1\n            # e2 = d x e1\n            e2x = uy * e1z - uz * e1y\n            e2y = uz * e1x - ux * e1z\n            e2z = ux * e1y - uy * e1x\n            for _ in range(10):\n                u = self._rand_range(-1.0, 1.0)\n                v = self._rand_range(-1.0, 1.0)\n                if u * u + v * v > 1.0:\n                    continue\n                ox = radius * (u * e1x + v * e2x)\n                oy = radius * (u * e1y + v * e2y)\n                oz = radius * (u * e1z + v * e2z)\n                p = (center[0] + ox, center[1] + oy, center[2] + oz)\n                p = self._clamp_tuple(p)\n                if self._in_bounds(p) and not self._point_in_obs(p):\n                    return p\n            return None\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_paths(self, a_end, b_end, active_from_start):\n        pa = self._path_to_root(a_end)\n        pb = self._path_to_root(b_end)\n        if active_from_start:\n            pb.reverse()\n            return pa + pb\n        else:\n            pa.reverse()\n            return pb + pa\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _visibility_prune(self, path):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if self._edge_free(out[-1], path[j]):\n                    out.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                out.append(path[i + 1])\n                i += 1\n        return out\n\n    def _shortcut(self, path):\n        if len(path) < 3 or self.shortcut_attempts <= 0:\n            return list(path)\n        pts = list(path)\n        best_len = self._path_len(pts)\n        tries = 0\n        while tries < self.shortcut_attempts and len(pts) >= 3:\n            i = int(self._rand_range(0, len(pts) - 2))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if self._edge_free(pts[i], pts[j]):\n                new_pts = pts[:i + 1] + pts[j:]\n                new_len = self._path_len(new_pts)\n                if new_len + 1e-9 < best_len:\n                    pts = new_pts\n                    best_len = new_len\n            tries += 1\n        return pts\n\n    def _finalize(self, path):\n        pruned = self._visibility_prune(path)\n        return self._shortcut(pruned)",
        "objective": null,
        "time_improvement": null,
        "length_improvement": null,
        "smoothness_improvement": null,
        "node_improvement": null,
        "other_inf": {
            "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 161, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 120, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nAttributeError: can't set attribute 'edge_cache_quant'\n"
        }
    },
    {
        "operator": "m1",
        "algorithm_description": null,
        "planning_mechanism": null,
        "code": null,
        "objective": null,
        "time_improvement": null,
        "length_improvement": null,
        "smoothness_improvement": null,
        "node_improvement": null,
        "success_rate": null,
        "other_inf": {
            "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 161, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 120, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: can only concatenate str (not \"NoneType\") to str\n"
        }
    },
    {
        "operator": "path_expert",
        "algorithm_description": "Informed BFMT*-Densify with Lazy Visibility Shortcuts: a batch informed Fast Marching Tree that builds near-shortest paths using optimal neighbor connections under a radius derived from asymptotic optimality, with lazy collision validation and densification inside an informed ellipse. After the first solution, batches are refined inside the current best-length ellipse and the path is aggressively shortened by global visibility compression and local elastic sliding to minimize length.",
        "planning_mechanism": "Mechanism: Generate a collision-free sample batch biased to the start\u2013goal corridor and (once available) an informed ellipse. Build a spatial index, then expand an FMT*-style open set from the start: for each frontier node, connect unvisited nearby samples to the least-cost nearby frontier parent (g-minimizing) and validate edges lazily. Opportunistically connect nodes to the goal when a straight bridge is free. Repeat with denser batches restricted to the current best ellipse to reduce length. Finally, compress the found polyline with deterministic line-of-sight shortcuts, randomized global shortcuts, and elastic sliding while preserving collision-free visibility.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        n0=900,                  # initial batch size\n        densify=1.7,             # batch growth factor\n        rounds=3,                # densification rounds\n        neighbor_eta=1.6,        # AO radius multiplier\n        goal_connect_gain=1.15,  # extra slack on goal connection radius\n        corridor_bias=0.35,      # fraction of corridor samples\n        informed_bias=0.45,      # fraction of informed samples after first solution\n        shortcut_attempts=400,   # randomized shortcut attempts\n        slide_rounds=24          # elastic sliding sweeps\n    ):\n        self.n0 = int(max(50, n0))\n        self.densify = max(1.05, float(densify))\n        self.rounds = max(1, int(rounds))\n        self.neighbor_eta = max(0.6, float(neighbor_eta))\n        self.goal_connect_gain = max(1.0, float(goal_connect_gain))\n        self.corridor_bias = max(0.0, min(1.0, float(corridor_bias)))\n        self.informed_bias = max(0.0, min(1.0, float(informed_bias)))\n        self.shortcut_attempts = max(0, int(shortcut_attempts))\n        self.slide_rounds = max(0, int(slide_rounds))\n        self._rng = 1357911\n\n    # Entry point\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n        nodes_best = []\n        edges_best = []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], nodes_best, edges_best)\n\n        self._seed_rng()\n        self._build_obstacle_grid()\n\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes_best, edges_best)\n\n        # Quick straight-line attempt\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes_best = [n0, n1]\n            edges_best = [(n0, n1)]\n            path = [self.start, self.goal]\n            path = self._compress_visibility(path)\n            path = self._random_shortcuts(path, self.shortcut_attempts)\n            path = self._elastic_slide(path, self.slide_rounds)\n            return PlannerResult(True, path, nodes_best, edges_best)\n\n        best_path = None\n        best_len = None\n        nodes_best = []\n        edges_best = []\n\n        diag = self._dist(tuple(0.0 for _ in range(self.dims)), self.bounds)\n        step_len = max(1.0, 0.02 * diag)  # for smoothing scale\n\n        for r_idx in range(self.rounds):\n            n_samp = int(self.n0 * (self.densify ** r_idx))\n            ellipse_limit = None\n            if best_len is not None:\n                ellipse_limit = best_len * 1.01  # slight slack\n\n            # Build batch\n            samples = self._batch_samples(n_samp, ellipse_limit)\n            if not samples:\n                continue\n\n            # FMT*-style tree build on this batch\n            radius = self._fmt_radius(len(samples) + 2, diag)\n            goal_radius = radius * self.goal_connect_gain\n            sgrid, cell = self._build_sample_grid(samples, radius)\n\n            # Prepare containers for this run\n            nodes_run = []\n            edges_run = []\n            pos_to_node = {}\n\n            start_node = Node(self.start, None, 0.0)\n            nodes_run.append(start_node)\n            pos_to_node[self.start] = start_node\n            open_set = [start_node]\n            closed = set()\n            visited = [True] * len(samples)  # True means unvisited and eligible\n\n            goal_node = None\n            best_goal_cost = 1e100\n\n            # If a direct connection from start exists within goal_radius, try it first\n            if self._dist(self.start, self.goal) <= goal_radius and self._edge_free(self.start, self.goal):\n                goal_node = Node(self.goal, start_node, self._dist(self.start, self.goal))\n                start_node.add_child(goal_node)\n                nodes_run.append(goal_node)\n                edges_run.append((start_node, goal_node))\n                path = self._extract_path(goal_node)\n                path = self._compress_visibility(path)\n                path = self._random_shortcuts(path, self.shortcut_attempts)\n                path = self._elastic_slide(path, self.slide_rounds)\n                plen = self._path_len(path)\n                if best_len is None or plen + 1e-9 < best_len:\n                    best_len = plen\n                    best_path = path\n                    nodes_best = nodes_run[:]\n                    edges_best = edges_run[:]\n                # continue densification to possibly shorten further\n\n            while open_set:\n                # pop node with smallest cost (linear scan)\n                min_idx = 0\n                best_c = open_set[0].cost\n                for i in range(1, len(open_set)):\n                    if open_set[i].cost < best_c:\n                        best_c = open_set[i].cost\n                        min_idx = i\n                z = open_set[min_idx]\n                del open_set[min_idx]\n                closed.add(z)\n\n                # Gather unvisited samples near z\n                y_indices = self._near_samples(sgrid, cell, samples, z.position, radius)\n                to_add = []\n                for yi in y_indices:\n                    if yi < 0 or yi >= len(samples):\n                        continue\n                    if not visited[yi]:\n                        continue\n                    y = samples[yi]\n                    if self._point_in_obstacles(y):\n                        visited[yi] = False\n                        continue\n\n                    # Choose best parent from current frontier (open_set + z) within radius\n                    best_parent = None\n                    best_cost = 1e100\n\n                    # Check z first (often best)\n                    dz = self._dist(z.position, y)\n                    if dz <= radius:\n                        c = z.cost + dz\n                        if c < best_cost:\n                            best_parent = z\n                            best_cost = c\n\n                    # Consider other frontier nodes\n                    for x in open_set:\n                        dxy = self._dist(x.position, y)\n                        if dxy <= radius:\n                            c = x.cost + dxy\n                            if c < best_cost:\n                                best_parent = x\n                                best_cost = c\n\n                    # Heuristic prune if cannot beat current best length (if any)\n                    if best_len is not None:\n                        h = self._dist(y, self.goal)\n                        if best_cost + h >= best_len * 0.9995:\n                            continue\n\n                    if best_parent is None:\n                        continue\n\n                    # Validate edge lazily\n                    if not self._edge_free(best_parent.position, y):\n                        continue\n\n                    # Passed both checks; create node\n                    q = Node(y, best_parent, best_cost)\n                    best_parent.add_child(q)\n                    nodes_run.append(q)\n                    edges_run.append((best_parent, q))\n                    pos_to_node[y] = q\n                    to_add.append((yi, q))\n                    visited[yi] = False\n\n                # Extend frontier\n                for (yi, q) in to_add:\n                    if q not in open_set:\n                        open_set.append(q)\n\n                    # Opportunistic goal connection\n                    if goal_node is None:\n                        dgoal = self._dist(q.position, self.goal)\n                        if dgoal <= goal_radius and not self._point_in_obstacles(self.goal) and self._edge_free(q.position, self.goal):\n                            g_cost = q.cost + dgoal\n                            if g_cost < best_goal_cost:\n                                best_goal_cost = g_cost\n                                goal_node = Node(self.goal, q, g_cost)\n                                q.add_child(goal_node)\n                                nodes_run.append(goal_node)\n                                edges_run.append((q, goal_node))\n                                # Evaluate and keep best\n                                path = self._extract_path(goal_node)\n                                path = self._compress_visibility(path)\n                                path = self._random_shortcuts(path, self.shortcut_attempts)\n                                path = self._elastic_slide(path, self.slide_rounds)\n                                plen = self._path_len(path)\n                                if best_len is None or plen + 1e-9 < best_len:\n                                    best_len = plen\n                                    best_path = path\n                                    nodes_best = nodes_run[:]\n                                    edges_best = edges_run[:]\n\n                # If no neighbors were added and no open_set growth, continue\n\n            # End of batch run; if we never connected to goal but have a hidden straight connection, try from best frontier\n            if best_path is None:\n                # Try connecting any node to goal with smallest cost\n                best_bridge = None\n                best_total = 1e100\n                for n in nodes_run:\n                    d = self._dist(n.position, self.goal)\n                    if d <= goal_radius and self._edge_free(n.position, self.goal):\n                        total = n.cost + d\n                        if total < best_total:\n                            best_total = total\n                            best_bridge = n\n                if best_bridge is not None:\n                    gnode = Node(self.goal, best_bridge, best_total)\n                    best_bridge.add_child(gnode)\n                    nodes_run.append(gnode)\n                    edges_run.append((best_bridge, gnode))\n                    path = self._extract_path(gnode)\n                    path = self._compress_visibility(path)\n                    path = self._random_shortcuts(path, self.shortcut_attempts)\n                    path = self._elastic_slide(path, self.slide_rounds)\n                    plen = self._path_len(path)\n                    if best_len is None or plen + 1e-9 < best_len:\n                        best_len = plen\n                        best_path = path\n                        nodes_best = nodes_run[:]\n                        edges_best = edges_run[:]\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes_best, edges_best)\n        return PlannerResult(False, [], [], [])\n\n    # ---- Randomness and utilities ----\n    def _seed_rng(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 2654435761 + int(v * 997 + 0.5)) & 0x7fffffff\n        s ^= (len(self.obstacles) * 97531 + self.dims * 13579) & 0x7fffffff\n        self._rng = (s ^ 0x9E3779B9) & 0x7fffffff\n        if self._rng == 0:\n            self._rng = 1357911\n\n    def _rand(self):\n        self._rng = (1103515245 * self._rng + 12345) & 0x7fffffff\n        return self._rng / 2147483647.0\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _vdc(self, n, base):\n        v = 0.0\n        denom = 1.0\n        while n > 0:\n            denom *= base\n            n, rem = divmod(n, base)\n            v += rem / denom\n        return v\n\n    # ---- Geometry ----\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---- Obstacles and collision ----\n    def _build_obstacle_grid(self):\n        # Spatial buckets for obstacles to accelerate queries\n        diag = self._dist(tuple(0.0 for _ in range(self.dims)), self.bounds)\n        self.obs_cell = max(3.0, 0.025 * diag)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            cand = self.obs_grid.get((cx, cy, cz))\n            if not cand:\n                return False\n            x0, y0, z0 = p\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= x0 <= x + w and y <= y0 <= y + h and z <= z0 <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cand = self.obs_grid.get((cx, cy))\n            if not cand:\n                return False\n            x0, y0 = p\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if x <= x0 <= x + w and y <= y0 <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            visited = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                visited.add(idx)\n            if not visited:\n                return False\n            for idx in visited:\n                x0, y0, z0, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x0, y0, z0), (x0 + w, y0 + h, z0 + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            visited = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            visited.add(idx)\n            if not visited:\n                return False\n            for idx in visited:\n                x0, y0, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x0, y0), (x0 + w, y0 + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # ---- Batch sampling ----\n    def _batch_samples(self, n, ellipse_limit):\n        pts = []\n        # Mixed low-discrepancy + corridor jitter + uniform\n        diag = self._dist(tuple(0.0 for _ in range(self.dims)), self.bounds)\n        jitter = 0.03 * diag\n        for i in range(n * 2):  # oversample to account for obstacles and ellipse rejection\n            r = self._rand()\n            if ellipse_limit is not None and r < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, ellipse_limit)\n                if p is None:\n                    continue\n            elif r < self.corridor_bias:\n                t = self._vdc(i + 1, 2)\n                base = tuple(self.start[d] + t * (self.goal[d] - self.start[d]) for d in range(self.dims))\n                if self.is_3d:\n                    p = (\n                        self._clamp(base[0] + self._rand_range(-jitter, jitter), 0.0, self.bounds[0]),\n                        self._clamp(base[1] + self._rand_range(-jitter, jitter), 0.0, self.bounds[1]),\n                        self._clamp(base[2] + self._rand_range(-jitter, jitter), 0.0, self.bounds[2]),\n                    )\n                else:\n                    p = (\n                        self._clamp(base[0] + self._rand_range(-jitter, jitter), 0.0, self.bounds[0]),\n                        self._clamp(base[1] + self._rand_range(-jitter, jitter), 0.0, self.bounds[1]),\n                    )\n            else:\n                if self.is_3d:\n                    u = self._vdc(i + 1, 2)\n                    v = self._vdc(i + 1, 3)\n                    w = self._vdc(i + 1, 5)\n                    p = (u * self.bounds[0], v * self.bounds[1], w * self.bounds[2])\n                else:\n                    u = self._vdc(i + 1, 2)\n                    v = self._vdc(i + 1, 3)\n                    p = (u * self.bounds[0], v * self.bounds[1])\n\n            if not self._within_bounds(p):\n                continue\n            if self._point_in_obstacles(p):\n                continue\n            if ellipse_limit is not None:\n                if self._dist(p, self.start) + self._dist(p, self.goal) > ellipse_limit:\n                    continue\n            pts.append(tuple(p))\n            if len(pts) >= n:\n                break\n        return pts\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        # axis-aligned rejection inside bounding rectangle around foci\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        ext = [max(half, 1.0)] * self.dims\n        for _ in range(24):\n            if self.is_3d:\n                p = (\n                    self._clamp(c[0] + self._rand_range(-ext[0], ext[0]), 0.0, self.bounds[0]),\n                    self._clamp(c[1] + self._rand_range(-ext[1], ext[1]), 0.0, self.bounds[1]),\n                    self._clamp(c[2] + self._rand_range(-ext[2], ext[2]), 0.0, self.bounds[2]),\n                )\n            else:\n                p = (\n                    self._clamp(c[0] + self._rand_range(-ext[0], ext[0]), 0.0, self.bounds[0]),\n                    self._clamp(c[1] + self._rand_range(-ext[1], ext[1]), 0.0, self.bounds[1]),\n                )\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum_dist and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # ---- Sample grid and neighbor queries ----\n    def _fmt_radius(self, n, diag):\n        # AO-inspired radius: eta * (log n / n)^(1/d) * diag\n        if n <= 1:\n            return 0.05 * diag + 1.0\n        # approximate log using successive halving\n        ln = 0.0\n        m = n\n        while m > 1:\n            ln += 1.0\n            m //= 2\n        frac = ln / max(1.0, float(n))\n        p = frac ** (1.0 / float(self.dims))\n        return max(0.01 * diag, self.neighbor_eta * p * diag)\n\n    def _build_sample_grid(self, samples, cell_size):\n        # grid cell size tied to radius for efficient ring queries\n        if cell_size <= 1e-9:\n            cell_size = 1.0\n        if self.is_3d:\n            grid = {}\n            for i, p in enumerate(samples):\n                key = (int(p[0] // cell_size), int(p[1] // cell_size), int(p[2] // cell_size))\n                b = grid.get(key)\n                if b is None:\n                    grid[key] = [i]\n                else:\n                    b.append(i)\n            return grid, cell_size\n        else:\n            grid = {}\n            for i, p in enumerate(samples):\n                key = (int(p[0] // cell_size), int(p[1] // cell_size))\n                b = grid.get(key)\n                if b is None:\n                    grid[key] = [i]\n                else:\n                    b.append(i)\n            return grid, cell_size\n\n    def _near_samples(self, grid, cell, samples, pos, radius):\n        if self.is_3d:\n            k = (int(pos[0] // cell), int(pos[1] // cell), int(pos[2] // cell))\n            rc = int(radius // cell) + 1\n            r2 = radius * radius\n            out = []\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    for dz in range(-rc, rc + 1):\n                        b = grid.get((k[0] + dx, k[1] + dy, k[2] + dz))\n                        if not b:\n                            continue\n                        for idx in b:\n                            if self._dist2(samples[idx], pos) <= r2:\n                                out.append(idx)\n            return out\n        else:\n            k = (int(pos[0] // cell), int(pos[1] // cell))\n            rc = int(radius // cell) + 1\n            r2 = radius * radius\n            out = []\n            for dx in range(-rc, rc + 1):\n                for dy in range(-rc, rc + 1):\n                    b = grid.get((k[0] + dx, k[1] + dy))\n                    if not b:\n                        continue\n                    for idx in b:\n                        if self._dist2(samples[idx], pos) <= r2:\n                            out.append(idx)\n            return out\n\n    # ---- Path utilities ----\n    def _extract_path(self, goal_node):\n        pts = []\n        cur = goal_node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    # Deterministic visibility compression (greedy)\n    def _compress_visibility(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            last_ok = i + 1\n            while j > i + 1:\n                if self._edge_free(path[i], path[j]):\n                    last_ok = j\n                    break\n                j -= 1\n            pts.append(path[last_ok])\n            i = last_ok\n        return pts\n\n    # Randomized global shortcuts\n    def _random_shortcuts(self, path, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return path[:]\n        pts = path[:]\n        bestL = self._path_len(pts)\n        for _ in range(attempts):\n            if len(pts) < 3:\n                break\n            i = int(self._rand_range(0, len(pts) - 2))\n            j = int(self._rand_range(i + 2, len(pts)))\n            if j <= i + 1:\n                continue\n            if self._edge_free(pts[i], pts[j]):\n                cand = pts[:i + 1] + pts[j:]\n                L = self._path_len(cand)\n                if L + 1e-12 < bestL:\n                    pts = cand\n                    bestL = L\n        return pts\n\n    # Elastic sliding of interior points along local chord\n    def _elastic_slide(self, path, rounds):\n        if len(path) < 3 or rounds <= 0:\n            return path[:]\n        pts = list(path)\n        n = len(pts)\n        alphas = [0.8, 0.5, 0.25]\n        for _ in range(rounds):\n            changed = False\n            for i in range(1, n - 1):\n                a = pts[i - 1]\n                b = pts[i]\n                c = pts[i + 1]\n                # project b onto chord a-c\n                ac = tuple(c[k] - a[k] for k in range(self.dims))\n                ac2 = self._dist2(a, c)\n                if ac2 < 1e-12:\n                    continue\n                ab = tuple(b[k] - a[k] for k in range(self.dims))\n                tnum = 0.0\n                for k in range(self.dims):\n                    tnum += ab[k] * ac[k]\n                t = tnum / ac2\n                if t < 0.0:\n                    t = 0.0\n                elif t > 1.0:\n                    t = 1.0\n                proj = tuple(a[k] + t * ac[k] for k in range(self.dims))\n                old_len = self._dist(a, b) + self._dist(b, c)\n                best_b = b\n                best_len = old_len\n                for alpha in alphas:\n                    cand = tuple(self._clamp(b[k] + alpha * (proj[k] - b[k]), 0.0, self.bounds[k]) for k in range(self.dims))\n                    if self._point_in_obstacles(cand):\n                        continue\n                    if self._edge_free(a, cand) and self._edge_free(cand, c):\n                        seg = self._dist(a, cand) + self._dist(cand, c)\n                        if seg + 1e-12 < best_len:\n                            best_len = seg\n                            best_b = cand\n                if best_b != b:\n                    pts[i] = best_b\n                    changed = True\n            if not changed:\n                break\n        return pts",
        "objective": null,
        "time_improvement": null,
        "length_improvement": null,
        "smoothness_improvement": null,
        "node_improvement": null,
        "other_inf": {
            "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 161, in evaluate\n    fitness, results = self.__evaluate_path(code_string=code_string)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 120, in __evaluate_path\n    result, avg_result = evaluate_with_timeout_dynamic(\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 70, in evaluate_with_timeout_dynamic\n    raise payload\nTypeError: Planner.__init__() got an unexpected keyword argument 'max_iter'\n"
        }
    }
]