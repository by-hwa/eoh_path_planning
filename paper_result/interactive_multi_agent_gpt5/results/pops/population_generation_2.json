[
     {
          "operator": "time_expert",
          "algorithm_description": "HASTE-BiRRT: Hashed, Anytime, Saturation\u2011Throttled, Efficient BiRRT-Connect. It accelerates bidirectional RRT with cached collision tests, hashed nearest search with leader fallbacks, per-cell growth throttling, and duplicate-suppressed commit-only connections. A light visibility prune plus brief shortcutting refines the path while keeping postprocessing costs low.",
          "planning_mechanism": "Alternate expanding start/goal trees with goal-biased sampling; find nearest via grid rings, else leader-guided buckets; steer one step and validate with cached edge checks; suppress inserts in saturated/duplicate cells; attempt a single, commit-only direct bridge to the opposite tree, skipping known-blocked cell pairs; upon success, extract start-to-goal path, visibility-prune, then run a few shortcuts; terminate on success or iteration cap.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=7.0,\n                 goal_bias=0.25,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=40,\n                 max_per_cell=6,\n                 search_r_max=2,\n                 leader_stride=25):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.max_per_cell = max_per_cell\n        self.search_r_max = search_r_max\n        self.leader_stride = leader_stride\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # Caches\n        self._edge_blocked_cache = set()   # quantized blocked segments (safe to reuse only for blocked)\n        self._edge_exact_cache = {}        # exact endpoint pairs -> bool\n        self._connect_blocked_cells = set()  # (cellA, cellB) pairs known to fail direct connect\n\n    # ------------- Public API -------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Parameters derived\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.5)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Reset caches\n        self._edge_blocked_cache = set()\n        self._edge_exact_cache = {}\n        self._connect_blocked_cells = set()\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Grids and counts\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        self._grid_add(grid_start, counts_start, start_root)\n        self._grid_add(grid_goal, counts_goal, goal_root)\n\n        # Leaders\n        leaders_start = [start_root]\n        leaders_goal = [goal_root]\n        inserted_since_leader_start = 0\n        inserted_since_leader_goal = 0\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            grid_a = grid_start if active_start else grid_goal\n            counts_a = counts_start if active_start else counts_goal\n            leaders_a = leaders_start if active_start else leaders_goal\n\n            tree_b = goal_tree if active_start else start_tree\n            grid_b = grid_goal if active_start else grid_start\n            counts_b = counts_goal if active_start else counts_start\n            leaders_b = leaders_goal if active_start else leaders_start\n\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest lookup\n            nearest = self._nearest_hashed(grid_a, leaders_a, tree_a, x_rand)\n            if nearest is None:\n                continue\n\n            # Steer\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Per-cell throttling and duplicate suppression\n            key_new = self._grid_key(new_pos)\n            if self._cell_count(counts_a, key_new) >= self.max_per_cell:\n                continue\n            if self._near_duplicate(grid_a, new_pos, dup_radius=0.7 * self.step_size):\n                continue\n\n            # Insert node and edge\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, counts_a, new_node)\n\n            # Leader sampling\n            if active_start:\n                inserted_since_leader_start += 1\n                if inserted_since_leader_start >= self.leader_stride:\n                    leaders_start.append(new_node)\n                    inserted_since_leader_start = 0\n            else:\n                inserted_since_leader_goal += 1\n                if inserted_since_leader_goal >= self.leader_stride:\n                    leaders_goal.append(new_node)\n                    inserted_since_leader_goal = 0\n\n            # Try commit-only direct connection to the other tree (with cell-pair de-dup)\n            other_near = self._nearest_hashed(grid_b, leaders_b, tree_b, new_node.position)\n            if other_near is not None:\n                pair_key = (self._grid_key(new_node.position), self._grid_key(other_near.position))\n                if pair_key not in self._connect_blocked_cells:\n                    if not self._edge_blocked(new_node.position, other_near.position, obstacles, is_3d):\n                        path = self._extract_path(new_node, other_near, a_is_start_tree=active_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        return PlannerResult(True, path, start_tree + goal_tree, edges)\n                    else:\n                        # cache blocked cell pair to avoid repeating futile checks\n                        self._connect_blocked_cells.add(pair_key)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ------------- Random -------------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry -------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ------------- Collision & caches -------------\n    def _quant(self, p, q=1.5):\n        # Quantize for blocked-segment cache; coarse to avoid false frees; safe for blocked reuse only\n        if self.dim == 3:\n            return (int(p[0] // q), int(p[1] // q), int(p[2] // q))\n        else:\n            return (int(p[0] // q), int(p[1] // q))\n\n    def _seg_key_exact(self, a, b):\n        # Canonicalize order for undirected segment\n        if a <= b:\n            return (a, b)\n        else:\n            return (b, a)\n\n    def _seg_key_quant_blocked(self, a, b):\n        qa = self._quant(a)\n        qb = self._quant(b)\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        # Exact cache check\n        k_exact = self._seg_key_exact(a, b)\n        cached = self._edge_exact_cache.get(k_exact)\n        if cached is not None:\n            return cached\n        # Blocked quantized cache\n        kq = self._seg_key_quant_blocked(a, b)\n        if kq in self._edge_blocked_cache:\n            self._edge_exact_cache[k_exact] = True\n            return True\n        # Compute\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n        # Update caches\n        self._edge_exact_cache[k_exact] = blocked\n        if blocked:\n            self._edge_blocked_cache.add(kq)\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ------------- Sampling -------------\n    def _sample_free(self, obstacles, is_3d):\n        # Rejection sampling within bounds until a free point is found\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ------------- Grid / NN -------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n\n    def _cell_count(self, counts, key):\n        return counts.get(key, 0)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, leaders, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Local rings\n        for r in range(0, self.search_r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Leader fallback\n        if leaders:\n            lead_best = None\n            lead_bestd = float('inf')\n            for n in leaders:\n                d = self._dist(n.position, pos)\n                if d < lead_bestd:\n                    lead_bestd = d\n                    lead_best = n\n            if lead_best is not None:\n                # Search around leader cell for neighbors\n                lk = self._grid_key(lead_best.position)\n                for r in range(0, min(2, self.search_r_max) + 1):\n                    cand = self._grid_ring_collect(grid, lk, r)\n                    for n in cand:\n                        d = self._dist(n.position, pos)\n                        if d < bestd:\n                            bestd = d\n                            best = n\n                if best is not None:\n                    return best\n        # Sparse random subset fallback (avoid full scan)\n        if tree:\n            trials = min(64, len(tree))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n            if best is not None:\n                return best\n        return None\n\n    def _near_duplicate(self, grid, pos, dup_radius):\n        key = self._grid_key(pos)\n        r = 1\n        cand = self._grid_ring_collect(grid, key, r)\n        rr = dup_radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # ------------- Path -------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            # start-tree path to meet, then meet->goal via reversed goal-tree path\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -35.78786,
          "time_improvement": 66.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1772.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.016536712646484375,
                    "num_nodes_avg": 67.3,
                    "path_length_avg": 176.25078259592178,
                    "smoothness_avg": 0.05067539409595988,
                    "success_improvement": 0.0,
                    "time_improvement": 35.1470831615236,
                    "node_improvement": 83.05212792747419,
                    "length_improvement": 3.3941531868009323,
                    "smoothness_improvement": 693.1799609813568,
                    "objective_score": 16.046516665444422
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023010659217834472,
                    "num_nodes_avg": 105.2,
                    "path_length_avg": 247.25890321415372,
                    "smoothness_avg": 0.1191098532602342,
                    "success_improvement": 0.0,
                    "time_improvement": 85.63605318102866,
                    "node_improvement": 92.93153262111133,
                    "length_improvement": 17.45786115419664,
                    "smoothness_improvement": 2964.7823157454163,
                    "objective_score": 50.989444225553655
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.011754655838012695,
                    "num_nodes_avg": 94.4,
                    "path_length_avg": 127.41557160345823,
                    "smoothness_avg": 0.13822063405561777,
                    "success_improvement": 0.0,
                    "time_improvement": 76.0361625858193,
                    "node_improvement": 87.99745708836618,
                    "length_improvement": 15.376644218505373,
                    "smoothness_improvement": 1658.156262801516,
                    "objective_score": 40.327616620856595
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Bounded BiRRT-Connect with Grid-Accelerated Nearest and Lightweight Shortcutting: a time-capped, bidirectional RRT-Connect that uses a coarse spatial grid for fast nearest-neighbor queries, commits only validated steps, attempts a single greedy bridge per iteration, and applies a brief shortcut smoother to the first found path for quality without heavy rewiring or anytime overhead.",
          "planning_mechanism": "Mechanism: Alternate growing start/goal trees with one extend loop toward a biased sample; each successful extension triggers a greedy extend from the opposite tree toward the new node. Both node and edge collisions are strictly checked before every insertion and the final bridge. Nearest queries use a bucket grid with limited ring expansion and linear fallback. On success, a bounded-time shortcut pass improves path length/smoothness; the planner enforces a hard time limit and returns the best (first) feasible path promptly.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=6.0,\n        goal_sample_rate=0.15,\n        bridge_bias_rate=0.30,\n        cell_size_factor=2.0,\n        time_limit_sec=12.0,\n        edge_resolution=1.0,\n        smooth_attempts=80,\n        smooth_time_frac=0.2\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.bridge_bias_rate = bridge_bias_rate\n        self.cell_size_factor = cell_size_factor\n        self.time_limit_sec = time_limit_sec\n        self.edge_resolution = edge_resolution\n        self.smooth_attempts = smooth_attempts\n        self.smooth_time_frac = smooth_time_frac\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Validate start/goal feasibility\n        if self._is_in_obstacle(start_position, obstacles, is_3d) or self._is_in_obstacle(goal_position, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Initialize trees and spatial grids\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root = Node(goal_position, parent=None, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        grid_start = {}\n        grid_goal = {}\n        self._grid_insert(grid_start, start_root.position, start_root, cell_size, dim)\n        self._grid_insert(grid_goal, goal_root.position, goal_root, cell_size, dim)\n\n        start_time = time.time()\n\n        # Early straight-line check\n        if not self._is_edge_in_obstacle(start_position, goal_position, obstacles, is_3d, self.edge_resolution):\n            edges.append((start_root, goal_root))\n            direct_path = [start_position, goal_position]\n            return PlannerResult(True, direct_path, start_tree + goal_tree, edges)\n\n        # Main loop\n        for it in range(self.max_iter):\n            if time.time() - start_time >= self.time_limit_sec:\n                return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n            # Alternate tree growth\n            if it % 2 == 0:\n                grow_tree, grow_grid = start_tree, grid_start\n                other_tree, other_grid = goal_tree, grid_goal\n                a_is_start_side = True\n                other_root_pos = goal_root.position\n            else:\n                grow_tree, grow_grid = goal_tree, grid_goal\n                other_tree, other_grid = start_tree, grid_start\n                a_is_start_side = False\n                other_root_pos = start_root.position\n\n            sample = self._sample(bounds, obstacles, is_3d, other_root_pos)\n\n            # Extend grow_tree toward sample\n            a_near = self._nearest_from_grid(grow_tree, grow_grid, sample, cell_size, dim)\n            a_last = self._extend(grow_tree, grow_grid, a_near, sample, nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if a_last is None:\n                continue\n\n            # Greedy connect: extend other_tree toward the new node\n            b_near = self._nearest_from_grid(other_tree, other_grid, a_last.position, cell_size, dim)\n            b_last = self._extend(other_tree, other_grid, b_near, a_last.position, nodes, edges, obstacles, is_3d, bounds, cell_size, dim)\n            if b_last is None:\n                continue\n\n            # Attempt final short bridge\n            if self._distance(b_last.position, a_last.position) <= self.step_size:\n                if not self._is_edge_in_obstacle(b_last.position, a_last.position, obstacles, is_3d, self.edge_resolution):\n                    edges.append((b_last, a_last))\n                    # Extract and smooth path\n                    final_path = self._assemble_path(a_last, b_last, a_is_start_side)\n                    remaining = max(0.0, self.time_limit_sec - (time.time() - start_time))\n                    budget = min(remaining, self.time_limit_sec * self.smooth_time_frac)\n                    final_path = self._shortcut_path(final_path, obstacles, is_3d, bounds, budget, self.smooth_attempts)\n                    return PlannerResult(True, final_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---- Utilities ----\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _within_bounds(self, p, bounds):\n        for i in range(len(bounds)):\n            if p[i] < 0.0 or p[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step_size):\n        d = self._distance(from_pos, to_pos)\n        if d <= step_size:\n            return to_pos\n        r = step_size / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _sample(self, bounds, obstacles, is_3d, other_root_pos):\n        # Bias toward the opposite root\n        if random.random() < self.bridge_bias_rate:\n            return other_root_pos\n        # Mild goal bias to encourage meeting/goal attraction\n        if random.random() < self.goal_sample_rate:\n            return other_root_pos\n        # Uniform rejection sampling in free space\n        dim = len(bounds)\n        for _ in range(30):\n            pt = tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            if not self._is_in_obstacle(pt, obstacles, is_3d):\n                return pt\n        # Fallback: last sample even if occupied (extend will reject)\n        return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n\n    def _extend(self, tree, grid, nearest_node, target_pos, nodes, edges, obstacles, is_3d, bounds, cell_size, dim):\n        current = nearest_node\n        last_new = None\n        while True:\n            step_pos = self._steer(current.position, target_pos, self.step_size)\n            if not self._within_bounds(step_pos, bounds):\n                break\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                break\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d, self.edge_resolution):\n                break\n            # Both node and edge are valid \u2192 commit\n            new_node = Node(step_pos)\n            new_node.cost = current.cost + self._distance(current.position, step_pos)\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node.position, new_node, cell_size, dim)\n            last_new = new_node\n            current = new_node\n            # Stop if reached target (within one step)\n            if self._distance(current.position, target_pos) <= self.step_size:\n                break\n        return last_new\n\n    def _assemble_path(self, a_node, b_node, a_is_start_side):\n        if a_is_start_side:\n            pa = a_node.path_from_root()   # start -> ... -> a\n            pb = b_node.path_from_root()   # goal  -> ... -> b\n            return pa + pb[::-1]           # start ... a, b ... goal\n        else:\n            pa = a_node.path_from_root()   # goal  -> ... -> a\n            pb = b_node.path_from_root()   # start -> ... -> b\n            return pb + pa[::-1]           # start ... b, a ... goal\n\n    # ---- Spatial grid for approximate nearest ----\n    def _cell_index(self, pos, cell_size, dim):\n        if dim == 2:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size))\n        else:\n            return (int(pos[0] // cell_size), int(pos[1] // cell_size), int(pos[2] // cell_size))\n\n    def _grid_insert(self, grid, pos, node, cell_size, dim):\n        idx = self._cell_index(pos, cell_size, dim)\n        if idx in grid:\n            grid[idx].append(node)\n        else:\n            grid[idx] = [node]\n\n    def _nearest_from_grid(self, tree, grid, point, cell_size, dim, max_rings=3):\n        # For small trees, just do linear scan\n        if len(tree) < 32:\n            return min(tree, key=lambda n: self._distance(n.position, point))\n\n        center = self._cell_index(point, cell_size, dim)\n        best = None\n        # Expand rings until some candidates found, then pick nearest among them\n        for r in range(0, max_rings + 1):\n            candidates = []\n            if dim == 2:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        idx = (center[0] + dx, center[1] + dy)\n                        if idx in grid:\n                            candidates.extend(grid[idx])\n            else:\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            idx = (center[0] + dx, center[1] + dy, center[2] + dz)\n                            if idx in grid:\n                                candidates.extend(grid[idx])\n            if candidates:\n                best = min(candidates, key=lambda n: self._distance(n.position, point))\n                break\n\n        if best is None:\n            # Fallback to linear scan if grid empty nearby\n            best = min(tree, key=lambda n: self._distance(n.position, point))\n        return best\n\n    # ---- Collision utilities ----\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution):\n        dist = self._distance(from_pos, to_pos)\n        steps = max(1, int(dist / max(1e-6, resolution)))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    # ---- Path shortcutting ----\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, time_budget, attempts):\n        if len(path) < 3:\n            return path\n        start_t = time.time()\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and (time.time() - start_t) <= time_budget:\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            # Keep within bounds and collision-free\n            if not self._segment_within_bounds(a, b, bounds):\n                tries += 1\n                continue\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_resolution):\n                # Apply shortcut\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n            tries += 1\n        return pts\n\n    def _segment_within_bounds(self, a, b, bounds):\n        # The interpolated segment is within bounds if endpoints are; checks along the way via edge collision\n        for d in range(len(bounds)):\n            if a[d] < 0.0 or a[d] > bounds[d]:\n                return False\n            if b[d] < 0.0 or b[d] > bounds[d]:\n                return False\n        return True",
          "objective": -35.38986,
          "time_improvement": 79.0,
          "length_improvement": 6.0,
          "smoothness_improvement": 1571.0,
          "node_improvement": 81.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009288859367370606,
                    "num_nodes_avg": 87.5,
                    "path_length_avg": 179.7819366813108,
                    "smoothness_avg": 0.041891929272141075,
                    "success_improvement": 0.0,
                    "time_improvement": 63.57137981686718,
                    "node_improvement": 77.96524804835055,
                    "length_improvement": 1.4586716778820132,
                    "smoothness_improvement": 555.6996628894441,
                    "objective_score": 22.725115266236582
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.009074711799621582,
                    "num_nodes_avg": 124.9,
                    "path_length_avg": 251.58839597257443,
                    "smoothness_avg": 0.10077141463831178,
                    "success_improvement": 0.0,
                    "time_improvement": 94.3352914641303,
                    "node_improvement": 91.6078747564335,
                    "length_improvement": 16.01255185389636,
                    "smoothness_improvement": 2492.9210813599107,
                    "objective_score": 50.372723958376454
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01003124713897705,
                    "num_nodes_avg": 215.4,
                    "path_length_avg": 148.33090891427284,
                    "smoothness_avg": 0.13860849885025553,
                    "success_improvement": 0.0,
                    "time_improvement": 79.54962026854608,
                    "node_improvement": 72.6128417037508,
                    "length_improvement": 1.4856730579993105,
                    "smoothness_improvement": 1663.0898743601072,
                    "objective_score": 33.07173928716395
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "ARC-BiRRT: Adaptive Reuse-Cached, Ring-Hashed, Cost-Gated BiRRT-Connect. It accelerates bidirectional planning with exact edge-collision memoization, ring-hash nearest search, local LOS parent selection, per-cell cost-gated admission, and single-shot tree bridging; upon success it applies cache-reused visibility pruning and bounded shortcut smoothing for shorter, smoother paths.",
          "planning_mechanism": "Alternate expanding start/goal trees with small-beam guided sampling (goal/corridor bias); find a near node via ring-hash, steer one step, enforce node+edge checks and near-duplicate rejection; pick a best-cost parent among nearby ring neighbors that see the new point; admit only if per-cell capacity or cost improves; after insertion, attempt a direct LOS bridge to the opposite tree; on success, extract and cache-prune/shortcut the path and stop early.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=7.5,\n        beam_width=2,\n        goal_bias=0.3,\n        grid_cell_factor=1.6,\n        ring_max=3,\n        max_per_cell=6,\n        min_sep_factor=0.5,\n        los_neighbor_rings=1,\n        smoothing_iters=50,\n        corridor_bias=0.5\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.ring_max = ring_max\n        self.max_per_cell = max_per_cell\n        self.min_sep_factor = min_sep_factor\n        self.los_neighbor_rings = los_neighbor_rings\n        self.smoothing_iters = smoothing_iters\n        self.corridor_bias = corridor_bias\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n        # RNG state\n        self._lcg_state = 2463534242\n\n        # Caches\n        self._edge_cache = {}  # exact endpoints (ordered) -> bool blocked\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        # Derived params\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.3, self.step_size * self.min_sep_factor)\n        self.edge_res = max(0.5, min(1.0, self.step_size * 0.5))\n\n        # Reset caches\n        self._edge_cache = {}\n        self._lcg_state = 2463534242\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            path = [start, goal]\n            path = self._visibility_prune(path, obstacles, is_3d)\n            path = self._shortcut_smooth(path, obstacles, is_3d, iters=min(10, self.smoothing_iters))\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Initialize trees\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n\n        grid_start = {}\n        grid_goal = {}\n        counts_start = {}\n        counts_goal = {}\n        bestcost_start = {}\n        bestcost_goal = {}\n\n        self._grid_add(grid_start, counts_start, bestcost_start, start_root)\n        self._grid_add(grid_goal, counts_goal, bestcost_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n\n            tree_a = start_tree if active_start else goal_tree\n            grid_a = grid_start if active_start else grid_goal\n            counts_a = counts_start if active_start else counts_goal\n            bestcost_a = bestcost_start if active_start else bestcost_goal\n\n            tree_b = goal_tree if active_start else start_tree\n            grid_b = grid_goal if active_start else grid_start\n            counts_b = counts_goal if active_start else counts_start\n            bestcost_b = bestcost_goal if active_start else bestcost_start\n\n            attractor = goal if active_start else start\n\n            for _ in range(self.beam_width):\n                x_rand = self._guided_sample(obstacles, is_3d, attractor)\n\n                nearest = self._nearest_hashed(grid_a, tree_a, x_rand)\n                if nearest is None:\n                    continue\n\n                new_pos = self._steer(nearest.position, x_rand)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._edge_blocked(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                if self._near_duplicate(grid_a, new_pos, self.min_sep):\n                    continue\n\n                # Choose a parent among local neighbors with LOS (limited rings) for better path cost\n                parent = self._choose_parent_local(grid_a, new_pos, nearest, obstacles, is_3d)\n                if self._edge_blocked(parent.position, new_pos, obstacles, is_3d):\n                    continue  # safety\n\n                new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n                # Per-cell cost-gated admission\n                key_new = self._grid_key(new_pos)\n                ccount = counts_a.get(key_new, 0)\n                bestc = bestcost_a.get(key_new, float('inf'))\n                if ccount >= self.max_per_cell and not (new_cost + 1e-9 < bestc):\n                    continue\n\n                # Insert node\n                new_node = Node(new_pos, parent=parent, cost=new_cost)\n                parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((parent, new_node))\n                self._grid_add(grid_a, counts_a, bestcost_a, new_node)\n\n                # Try single-shot direct bridge to the other tree\n                other_near = self._nearest_hashed(grid_b, tree_b, new_node.position)\n                if other_near is not None:\n                    if not self._edge_blocked(new_node.position, other_near.position, obstacles, is_3d):\n                        path = self._extract_path(new_node, other_near, a_is_start_tree=active_start)\n                        path = self._visibility_prune(path, obstacles, is_3d)\n                        path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                        return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos):\n        d = self._dist(from_pos, to_pos)\n        if d <= 1e-9:\n            return self._clamp(from_pos)\n        if d <= self.step_size:\n            return self._clamp(to_pos)\n        r = self.step_size / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision and caching\n    def _edge_key(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._edge_key(a, b)\n        if k in self._edge_cache:\n            return self._edge_cache[k]\n        blocked = self._segment_hits(a, b, obstacles, is_3d, self.edge_res)\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_hits(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _guided_sample(self, obstacles, is_3d, attractor):\n        # Goal-biased with optional corridor pull (activated only after success; here kept generic)\n        if self._rand() < self.goal_bias:\n            p = attractor\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Mild blend toward attractor\n        alpha = 0.2\n        if self.dim == 3:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]),\n                   self._uniform(0.0, self.bounds[2]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(3))\n        else:\n            rnd = (self._uniform(0.0, self.bounds[0]),\n                   self._uniform(0.0, self.bounds[1]))\n            p = tuple(alpha * attractor[i] + (1.0 - alpha) * rnd[i] for i in range(2))\n        if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    # Grid / NN\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, counts, bestcost, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n        counts[k] = counts.get(k, 0) + 1\n        bc = bestcost.get(k)\n        if bc is None or node.cost < bc:\n            bestcost[k] = node.cost\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.ring_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback to limited random subset to avoid O(N)\n        if not tree:\n            return None\n        trials = min(64, len(tree))\n        for _ in range(trials):\n            idx = int(self._uniform(0, len(tree)))\n            n = tree[idx]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near_duplicate(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r = 1\n        cand = self._grid_ring_collect(grid, key, r)\n        rr = radius\n        for n in cand:\n            if self._dist(n.position, pos) <= rr:\n                return True\n        return False\n\n    # Parent selection among local neighbors with LOS\n    def _choose_parent_local(self, grid, new_pos, fallback_nearest, obstacles, is_3d):\n        key = self._grid_key(new_pos)\n        best_parent = fallback_nearest\n        best_cost = fallback_nearest.cost + self._dist(fallback_nearest.position, new_pos)\n        max_r = max(1, self.los_neighbor_rings)\n        for r in range(0, max_r + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            for n in cand:\n                if n is fallback_nearest or n is best_parent:\n                    pass\n                # Check LOS\n                if not self._edge_blocked(n.position, new_pos, obstacles, is_3d):\n                    c = n.cost + self._dist(n.position, new_pos)\n                    if c + 1e-9 < best_cost:\n                        best_cost = c\n                        best_parent = n\n        return best_parent\n\n    # Path\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, node_a, node_b, a_is_start_tree):\n        path_a = self._path_to_root(node_a)\n        path_b = self._path_to_root(node_b)\n        if a_is_start_tree:\n            return path_a + list(reversed(path_b))\n        else:\n            return path_b + list(reversed(path_a))\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        res = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked(res[-1], path[j], obstacles, is_3d):\n                    res.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                res.append(path[i + 1])\n                i += 1\n        return res\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked(a, b, obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -33.74569,
          "time_improvement": 58.0,
          "length_improvement": 18.0,
          "smoothness_improvement": 1051.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010497808456420898,
                    "num_nodes_avg": 34.0,
                    "path_length_avg": 154.57051194099205,
                    "smoothness_avg": 0.03958955729868922,
                    "success_improvement": 0.0,
                    "time_improvement": 58.830179046785545,
                    "node_improvement": 91.4379249559305,
                    "length_improvement": 15.277453078640955,
                    "smoothness_improvement": 519.6625418241595,
                    "objective_score": 29.41383827034103
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.049208974838256835,
                    "num_nodes_avg": 116.0,
                    "path_length_avg": 236.11546529476226,
                    "smoothness_avg": 0.06943512420354042,
                    "success_improvement": 0.0,
                    "time_improvement": 69.28227518814471,
                    "node_improvement": 92.20587247194786,
                    "length_improvement": 21.177861477765767,
                    "smoothness_improvement": 1686.6157578555544,
                    "objective_score": 41.92447823238064
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026494455337524415,
                    "num_nodes_avg": 117.0,
                    "path_length_avg": 122.03531483713664,
                    "smoothness_avg": 0.08227711903121854,
                    "success_improvement": 0.0,
                    "time_improvement": 45.98660915000911,
                    "node_improvement": 85.12396694214877,
                    "length_improvement": 18.94995458240024,
                    "smoothness_improvement": 946.5588810119002,
                    "objective_score": 29.898749899502377
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Adaptive Goal-Biased Grid BiRRT (AG-GBiRRT): a simplified, robust bidirectional RRT with commit-only connection, grid-accelerated nearest search, and light post-connection shortcut smoothing. It alternates growing two trees, uses uniform-with-goal-bias sampling, single-step steering with strict node/edge collision checks, and an early straight-line test. Upon any successful bridge between trees, it extracts the path and performs a few inexpensive shortcuts for smoothness, returning quickly without extra rewiring or bloat.",
          "planning_mechanism": "Mechanism: alternate start/goal tree expansion; sample (goal-biased), find nearest via grid, steer one step, validate node and edge, add node and edge, attempt a direct, collision-free bridge to the opposite tree (commit-only); on success, extract [start\u2192\u2026\u2192meetA, meetB\u2192\u2026\u2192goal] and run brief shortcut smoothing; terminate on success or iteration budget.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 goal_bias=0.2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        is_3d = (self.dim == 3)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, self.step_size * 2.0)\n        self.edge_res = max(0.5, self.collision_step)\n\n        # Validate start/goal\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._is_edge_in_obstacle(start, goal, obstacles, is_3d, self.edge_res):\n            path = [start, goal]\n            return PlannerResult(True, path, [Node(start), Node(goal)], [])\n\n        # Trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            # Sample with goal/opposite-root bias\n            if self._rand() < self.goal_bias:\n                x_rand = root_other\n            else:\n                x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                continue\n\n            # Insert node (both node and edge validated)\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._dist(nearest.position, new_pos))\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n            self._grid_add(grid_a, new_node)\n\n            # Try commit-only direct connection to the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None:\n                if not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, other_near)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- Random ----------\n    def _rand(self):\n        try:\n            return self._lcg_next()\n        except:\n            return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Sampling ----------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    # ---------- Grid nearest ----------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    # ---------- Path ----------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # path_a ends at meet_a; we then go straight to meet_b and up to other root\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            # pick two indices i < j with at least one point between\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -32.96764,
          "time_improvement": 69.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1142.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01299290657043457,
                    "num_nodes_avg": 78.8,
                    "path_length_avg": 167.86786188508313,
                    "smoothness_avg": 0.03825680999831742,
                    "success_improvement": 0.0,
                    "time_improvement": 49.04501835909778,
                    "node_improvement": 80.15613195668597,
                    "length_improvement": 7.988964864290817,
                    "smoothness_improvement": 498.8021524662562,
                    "objective_score": 22.000895188635106
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02625594139099121,
                    "num_nodes_avg": 208.9,
                    "path_length_avg": 244.3021244779086,
                    "smoothness_avg": 0.07331771296729457,
                    "success_improvement": 0.0,
                    "time_improvement": 83.61025026480232,
                    "node_improvement": 85.96385137405093,
                    "length_improvement": 18.444919002512343,
                    "smoothness_improvement": 1786.5175632625994,
                    "objective_score": 45.082614297261095
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01305999755859375,
                    "num_nodes_avg": 163.0,
                    "path_length_avg": 140.27860161008172,
                    "smoothness_avg": 0.09759083301298958,
                    "success_improvement": 0.0,
                    "time_improvement": 73.37500455677744,
                    "node_improvement": 79.27527018436109,
                    "length_improvement": 6.833632159773637,
                    "smoothness_improvement": 1141.348192519241,
                    "objective_score": 31.819421625493614
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Algorithm description: SWIFT-BiRRT-LOS \u2014 Simple, Weighted-bias, Informed, Fast Triaged Bi-directional RRT with hashed-near lookup, near-duplicate suppression, on-the-fly line-of-sight grandparent compression, light bounded connect-extend, and capped shortcut smoothing for faster, shorter, and smoother paths.",
          "planning_mechanism": "Planning mechanism: Alternate growing two trees with balanced goal/corridor/informed-biased samples. For each sample, find a hashed-nearest node, steer once, check node and edge collisions, insert if not near-duplicate and the cell is not saturated, then immediately try LOS compression to the grandparent to shorten chains. Attempt to connect to the opposite tree using a costless direct check first, then a few bounded, collision-checked extend steps. On success, merge trees and return a visibility-pruned, lightly-shortcutted path; otherwise stop on budget or stall.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=10.0,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 rings_near=2,\n                 goal_bias=0.2,\n                 corridor_bias=0.4,\n                 informed_bias=0.5,\n                 dupe_radius_ratio=0.6,\n                 cell_cap=10,\n                 connect_radius_factor=4.0,\n                 connect_steps=3,\n                 smoothing_attempts=24,\n                 stall_limit=700,\n                 edge_cache_limit=30000):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.collision_step = float(collision_step)\n        self.grid_cell = grid_cell\n        self.rings_near = int(max(1, rings_near))\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.cell_cap = int(max(2, cell_cap))\n        self.connect_radius_factor = float(max(1.0, connect_radius_factor))\n        self.connect_steps = int(max(0, connect_steps))\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self.stall_limit = int(max(100, stall_limit))\n        self.edge_cache_limit = int(max(2000, edge_cache_limit))\n\n        self.bounds = None\n        self.dim = 2\n        self.start = None\n        self.goal = None\n        self.edge_cache = None\n        self.edge_stamp = 0\n        self.edge_res = 1.0\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.8 * self.step_size)\n        self.edge_res = max(0.5, min(self.collision_step, 0.5 * self.step_size))\n\n        self.edge_cache = {}\n        self.edge_stamp = 0\n\n        # Early direct connection\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            edges = [(n0, n1)]\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], edges)\n\n        # Initialize trees and grids\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n\n        dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n        dsg = self._dist(self.start, self.goal)\n        corridor_base = max(self.step_size, 0.2 * dsg)\n\n        best_path = None\n        best_len = float('inf')\n        last_improve = 0\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            other_root = self.goal if active_start else self.start\n\n            # Sampling strategy\n            if best_path is not None and self._rand() < self.informed_bias:\n                x_rand = self._sample_informed(best_len, obstacles, is_3d)\n            else:\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = other_root\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = max(self.step_size, corridor_base + (0.1 * (best_len - dsg) if best_path is not None else 0.0))\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n            # Nearest and steer\n            nearest = self._nearest(grid1, tree1, x_rand)\n            if nearest is None:\n                continue\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._exists_close(grid1, new_pos, dupe_radius):\n                continue\n            if not self._cell_accept(grid1, new_pos):\n                continue\n            if self._edge_blocked_memo(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_cost = nearest.cost + self._dist(nearest.position, new_pos)\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            self._grid_add(grid1, new_node)\n            edges.append((nearest, new_node))\n\n            # LOS grandparent compression\n            gp = nearest.parent\n            if gp is not None and not self._edge_blocked_memo(gp.position, new_pos, obstacles, is_3d):\n                # reparent new_node to grandparent\n                try:\n                    nearest.children.remove(new_node)\n                except:\n                    pass\n                self._remove_edge(edges, nearest, new_node)\n                gp.add_child(new_node)\n                new_node.cost = gp.cost + self._dist(gp.position, new_pos)\n                edges.append((gp, new_node))\n\n            # Try connect to opposite tree (direct first, then bounded extend)\n            qnear = self._nearest(grid2, tree2, new_node.position)\n            if qnear is not None and self._dist(qnear.position, new_node.position) <= connect_radius:\n                if not self._edge_blocked_memo(new_node.position, qnear.position, obstacles, is_3d):\n                    a_end = new_node\n                    b_end = qnear\n                else:\n                    a_end, b_end = self._bounded_connect_extend(new_node, tree2, grid2, dupe_radius, obstacles, is_3d, edges, nodes)\n                if a_end is not None and b_end is not None:\n                    path = self._merge_paths(a_end, b_end) if active_start else self._merge_paths(b_end, a_end)\n                    plen = self._path_length(path)\n                    if plen < best_len:\n                        best_path = path\n                        best_len = plen\n                        last_improve = it\n                    final = self._finalize_path(best_path, obstacles, is_3d)\n                    return PlannerResult(True, final, nodes, edges)\n\n            if best_path is not None and (it - last_improve) >= self.stall_limit:\n                final = self._finalize_path(best_path, obstacles, is_3d)\n                return PlannerResult(True, final, nodes, edges)\n\n        if best_path is not None:\n            final = self._finalize_path(best_path, obstacles, is_3d)\n            return PlannerResult(True, final, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG (deterministic)\n    def _rand(self):\n        if not hasattr(self, \"_rng\"):\n            self._rng = 987654321\n        self._rng = (1103515245 * self._rng + 12345) % (1 << 31)\n        return (self._rng & 0x7fffffff) / float(1 << 31)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp_tuple(b)\n        if d <= 1e-12:\n            return self._clamp_tuple(a)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_exact(self, a, b):\n        return (a, b) if a <= b else (b, a)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_exact(a, b)\n        st = self.edge_cache.get(key)\n        if st is not None:\n            return st[0] == 1\n        blocked = self._edge_blocked(a, b, obstacles, is_3d)\n        self.edge_stamp += 1\n        self.edge_cache[key] = (1 if blocked else 2, self.edge_stamp)\n        if len(self.edge_cache) > self.edge_cache_limit:\n            cutoff = self.edge_stamp - (self.edge_cache_limit // 2)\n            self.edge_cache = {k: v for k, v in self.edge_cache.items() if v[1] >= cutoff}\n        return blocked\n\n    # Spatial hashing\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.rings_near + 1):\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback random subset\n        if tree:\n            k = min(16, len(tree))\n            for _ in range(k):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx % len(tree)]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius // self.grid_cell) + 1\n        cand = self._ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    def _cell_accept(self, grid, pos):\n        key = self._grid_key(pos)\n        lst = grid.get(key)\n        if lst is None:\n            return True\n        return len(lst) < self.cell_cap\n\n    # Connect helpers\n    def _bounded_connect_extend(self, new_node, other_tree, other_grid, dupe_radius, obstacles, is_3d, edges, nodes):\n        q = self._nearest(other_grid, other_tree, new_node.position)\n        if q is None:\n            return (None, None)\n        cur = q\n        for _ in range(self.connect_steps):\n            nxt_pos = self._steer(cur.position, new_node.position, self.step_size)\n            if not self._in_bounds(nxt_pos):\n                break\n            if self._is_in_obstacle(nxt_pos, obstacles, is_3d):\n                break\n            if self._exists_close(other_grid, nxt_pos, dupe_radius):\n                break\n            if self._edge_blocked_memo(cur.position, nxt_pos, obstacles, is_3d):\n                break\n            nxt = Node(nxt_pos, cur, cur.cost + self._dist(cur.position, nxt_pos))\n            cur.add_child(nxt)\n            other_tree.append(nxt)\n            nodes.append(nxt)\n            self._grid_add(other_grid, nxt)\n            edges.append((cur, nxt))\n            # LOS compression toward grandparent\n            gp = cur.parent\n            if gp is not None and not self._edge_blocked_memo(gp.position, nxt_pos, obstacles, is_3d):\n                try:\n                    cur.children.remove(nxt)\n                except:\n                    pass\n                self._remove_edge(edges, cur, nxt)\n                gp.add_child(nxt)\n                nxt.cost = gp.cost + self._dist(gp.position, nxt_pos)\n                edges.append((gp, nxt))\n            cur = nxt\n            if not self._edge_blocked_memo(cur.position, new_node.position, obstacles, is_3d):\n                return (new_node, cur)\n        return (None, None)\n\n    # Path utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_paths(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        pb.reverse()\n        return pa + pb\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _remove_edge(self, edges, a, b):\n        for i in range(len(edges)):\n            if edges[i][0] is a and edges[i][1] is b:\n                edges.pop(i)\n                return\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            advanced = False\n            while j > i + 1:\n                if not self._edge_blocked_memo(pruned[-1], path[j], obstacles, is_3d):\n                    pruned.append(path[j])\n                    i = j\n                    advanced = True\n                    break\n                j -= 1\n            if not advanced:\n                pruned.append(path[i + 1])\n                i += 1\n        return pruned\n\n    def _smooth_path(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return list(path)\n        pts = list(path)\n        best_len = self._path_length(pts)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and n >= 3:\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked_memo(a, b, obstacles, is_3d):\n                new_pts = pts[:i + 1] + pts[j:]\n                new_len = self._path_length(new_pts)\n                if new_len + 1e-9 < best_len:\n                    pts = new_pts\n                    best_len = new_len\n                    n = len(pts)\n            tries += 1\n        return pts\n\n    def _finalize_path(self, path, obstacles, is_3d):\n        if not path:\n            return []\n        pruned = self._visibility_prune(path, obstacles, is_3d)\n        return self._smooth_path(pruned, obstacles, is_3d, self.smoothing_attempts)\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        for _ in range(64):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        if self.dim == 3:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5, self.bounds[2] * 0.5)\n        else:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5)\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        tries = 0\n        while tries < 24:\n            if self.dim == 3:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                else:\n                    tries += 1\n                    continue\n            else:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                else:\n                    tries += 1\n                    continue\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n            tries += 1\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        for _ in range(48):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if (self._dist(self.start, p) + self._dist(p, self.goal) <= best_len + 1e-9 and\n                not self._is_in_obstacle(p, obstacles, is_3d)):\n                return p\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)",
          "objective": -32.12619,
          "time_improvement": 59.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 1812.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01643836498260498,
                    "num_nodes_avg": 47.5,
                    "path_length_avg": 172.57597716951437,
                    "smoothness_avg": 0.055340882959087935,
                    "success_improvement": 0.0,
                    "time_improvement": 35.532778493067305,
                    "node_improvement": 88.03827751196172,
                    "length_improvement": 5.408372272033185,
                    "smoothness_improvement": 766.2049929605337,
                    "objective_score": 17.73588187594277
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.024622559547424316,
                    "num_nodes_avg": 81.2,
                    "path_length_avg": 250.16418359040821,
                    "smoothness_avg": 0.12448872572717391,
                    "success_improvement": 0.0,
                    "time_improvement": 84.62985642705796,
                    "node_improvement": 94.5441107303635,
                    "length_improvement": 16.487994940743906,
                    "smoothness_improvement": 3103.1845785650153,
                    "objective_score": 50.7976767853888
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020916748046875,
                    "num_nodes_avg": 75.5,
                    "path_length_avg": 143.54340806097915,
                    "smoothness_avg": 0.13110948178151688,
                    "success_improvement": 0.0,
                    "time_improvement": 57.35770095388541,
                    "node_improvement": 90.40050858232676,
                    "length_improvement": 4.665303168464438,
                    "smoothness_improvement": 1567.7029307656137,
                    "objective_score": 27.845006841072355
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "SWIFT-Connect-S: A simplified, fast, and robust bidirectional RRT-Connect with bounded collision memoization, hash-grid nearest search, informed sampling after a provisional path, limited greedy bridging, and shallow multi-ancestor line-of-sight compression. It minimizes redundant checks and data churn for stable, low-latency planning while maintaining high path quality and smoothness.",
          "planning_mechanism": "Alternate expansion of two trees toward sampled targets (goal-biased/uniform; ellipse-informed once a path exists). For each step, pick the nearest by grid, steer once, and add only if both node and edge are free (cached). After insertion, compress up to a few ancestors via LOS to shorten trees, then attempt a short capped greedy connect from the opposite tree; if connected, extract and quickly shortcut-smooth with early stop and return. Bounded caches and light structures keep iterations fast and consistent.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=8.0,\n                 goal_bias=0.15,\n                 informed_bias=0.60,\n                 grid_cell_factor=1.5,\n                 ring_limit=2,\n                 dup_radius_ratio=0.45,\n                 connect_cap=3,\n                 connect_step_factor=1.5,\n                 compress_depth=3,\n                 edge_res=1.0,\n                 edge_cache_max=50000,\n                 point_cache_max=60000,\n                 smoothing_iters=60,\n                 smooth_patience=12):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.ring_limit = ring_limit\n        self.dup_radius_ratio = dup_radius_ratio\n        self.connect_cap = connect_cap\n        self.connect_step_factor = connect_step_factor\n        self.compress_depth = compress_depth\n        self.edge_res = edge_res\n        self.edge_cache_max = max(1000, int(edge_cache_max))\n        self.point_cache_max = max(1000, int(point_cache_max))\n        self.smoothing_iters = smoothing_iters\n        self.smooth_patience = smooth_patience\n\n        self.dim = 2\n        self.bounds = None\n        self.is_3d = False\n\n        self.cell = 1.0\n        self.q_point = 0.5\n        self.q_edge = 1.0\n\n        self._edge_cache = {}\n        self._point_cache = {}\n        self._rng_state = 2463534242\n\n        self.start = None\n        self.goal = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Quantization and grid\n        self.cell = max(1.0, self.step_size * self.grid_cell_factor)\n        self.q_point = max(0.5, self.edge_res * 0.5)\n        self.q_edge = max(1.0, self.edge_res)\n\n        # reset caches\n        self._edge_cache = {}\n        self._point_cache = {}\n\n        # start/goal validity\n        if not self._point_free(self.start, obstacles) or not self._point_free(self.goal, obstacles):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight connection\n        if self._edge_free(self.start, self.goal, obstacles):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        dup_radius = max(0.5, self.step_size * self.dup_radius_ratio)\n\n        for it in range(self.max_iter):\n            grow_from_start = (it % 2 == 0)\n            tree1 = tree_a if grow_from_start else tree_b\n            tree2 = tree_b if grow_from_start else tree_a\n            grid1 = grid_a if grow_from_start else grid_b\n            grid2 = grid_b if grow_from_start else grid_a\n            other_root_pos = self.goal if grow_from_start else self.start\n\n            # Sample a target\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                x_rand = self._sample_informed(best_len, obstacles)\n            else:\n                if self._rand() < self.goal_bias:\n                    x_rand = other_root_pos\n                else:\n                    x_rand = self._sample_free(obstacles)\n\n            # Nearest and steer\n            near = self._nearest_by_grid(tree1, grid1, x_rand)\n            if near is None:\n                continue\n            x_new = self._steer(near.position, x_rand, self.step_size)\n            if not self._in_bounds(x_new):\n                continue\n            if self._has_near_duplicate(grid1, x_new, dup_radius):\n                continue\n\n            # Mandatory checks before insertion\n            if not self._point_free(x_new, obstacles):\n                continue\n            if not self._edge_free(near.position, x_new, obstacles):\n                continue\n\n            # Insert node\n            new_cost = near.cost + self._dist(near.position, x_new)\n            new_node = Node(x_new, near, new_cost)\n            near.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((near, new_node))\n            self._grid_insert(grid1, new_node)\n\n            # Shallow multi-ancestor LOS compression\n            self._compress_chain(new_node, obstacles, edges, self.compress_depth)\n\n            # Attempt to connect the other tree\n            other_near = self._nearest_by_grid(tree2, grid2, new_node.position)\n            connected = False\n            last_other = other_near\n\n            # Direct bridge first\n            if other_near is not None and self._edge_free(new_node.position, other_near.position, obstacles):\n                connected = True\n                last_other = other_near\n            else:\n                # Limited greedy connect from the other tree toward new_node\n                current = other_near\n                for _ in range(self.connect_cap):\n                    if current is None:\n                        break\n                    step = self.step_size * self.connect_step_factor\n                    nxt_pos = self._steer(current.position, new_node.position, step)\n                    if not self._in_bounds(nxt_pos):\n                        break\n                    if self._has_near_duplicate(grid2, nxt_pos, dup_radius):\n                        break\n                    if not self._point_free(nxt_pos, obstacles):\n                        break\n                    if not self._edge_free(current.position, nxt_pos, obstacles):\n                        break\n                    nxt_cost = current.cost + self._dist(current.position, nxt_pos)\n                    nxt_node = Node(nxt_pos, current, nxt_cost)\n                    current.add_child(nxt_node)\n                    tree2.append(nxt_node)\n                    nodes.append(nxt_node)\n                    edges.append((current, nxt_node))\n                    self._grid_insert(grid2, nxt_node)\n                    self._compress_chain(nxt_node, obstacles, edges, self.compress_depth)\n                    last_other = nxt_node\n                    # Try to close the bridge\n                    if self._edge_free(new_node.position, last_other.position, obstacles):\n                        connected = True\n                        break\n                    current = nxt_node\n\n            if connected:\n                path = self._extract_path(new_node, last_other, grow_from_start)\n                best_len = self._path_length(path)\n                path = self._smooth_path(path, obstacles, self.smoothing_iters, self.smooth_patience)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._rng_state = (1664525 * self._rng_state + 1013904223) % (1 << 32)\n        return self._rng_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp_tuple(b)\n        if d <= 1e-12:\n            return self._clamp_tuple(a)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    # Collision and caching\n    def _qpos(self, p, q):\n        return tuple(int(p[i] // q) for i in range(self.dim))\n\n    def _edge_key(self, a, b, q):\n        qa = self._qpos(a, q)\n        qb = self._qpos(b, q)\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _point_key(self, p, q):\n        return self._qpos(p, q)\n\n    def _point_free(self, p, obstacles):\n        key = self._point_key(p, self.q_point)\n        cached = self._point_cache.get(key)\n        if cached is not None:\n            return cached\n        free = True\n        if self.is_3d:\n            px, py, pz = p\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    free = False\n                    break\n        else:\n            px, py = p\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    free = False\n                    break\n        self._point_cache[key] = free\n        if len(self._point_cache) > self.point_cache_max:\n            self._prune_half(self._point_cache)\n        return free\n\n    def _edge_free(self, a, b, obstacles):\n        key = self._edge_key(a, b, self.q_edge)\n        cached = self._edge_cache.get(key)\n        if cached is not None:\n            return cached\n        d = self._dist(a, b)\n        steps = int(d / self.edge_res)\n        if steps < 1:\n            steps = 1\n        free = True\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if not self._point_free(p, obstacles):\n                free = False\n                break\n        self._edge_cache[key] = free\n        if len(self._edge_cache) > self.edge_cache_max:\n            self._prune_half(self._edge_cache)\n        return free\n\n    def _prune_half(self, dct):\n        cnt = 0\n        to_del = []\n        for k in dct:\n            if (cnt % 2) == 0:\n                to_del.append(k)\n            cnt += 1\n            if len(to_del) >= len(dct) // 2:\n                break\n        for k in to_del:\n            try:\n                del dct[k]\n            except:\n                pass\n\n    # Spatial hash\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell) for i in range(self.dim))\n\n    def _grid_insert(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _nearest_by_grid(self, tree, grid, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        if self.dim == 3:\n            for r in range(self.ring_limit + 1):\n                found = False\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if b:\n                                for n in b:\n                                    d = self._dist(n.position, pos)\n                                    if d < bestd:\n                                        bestd = d\n                                        best = n\n                                        found = True\n                if found and best is not None:\n                    return best\n        else:\n            for r in range(self.ring_limit + 1):\n                found = False\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy))\n                        if b:\n                            for n in b:\n                                d = self._dist(n.position, pos)\n                                if d < bestd:\n                                    bestd = d\n                                    best = n\n                                    found = True\n                if found and best is not None:\n                    return best\n        # fallback\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _has_near_duplicate(self, grid, pos, radius):\n        rng = int(max(1, radius // self.cell)) + 1\n        key = self._grid_key(pos)\n        r2 = radius * radius\n        if self.dim == 3:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            s = 0.0\n                            for i in range(self.dim):\n                                d = n.position[i] - pos[i]\n                                s += d * d\n                            if s <= r2:\n                                return True\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        s = 0.0\n                        for i in range(self.dim):\n                            d = n.position[i] - pos[i]\n                            s += d * d\n                        if s <= r2:\n                            return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles):\n        for _ in range(64):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and self._point_free(p, obstacles):\n                return p\n        return self._clamp_tuple(self.start)\n\n    def _sample_informed(self, best_len, obstacles):\n        # Rejection sample within the prolate ellipse defined by start/goal foci and perimeter best_len\n        for _ in range(48):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= best_len + 1e-9 and self._point_free(p, obstacles):\n                return p\n        # Fallback to uniform free if ellipse sampling failed\n        return self._sample_free(obstacles)\n\n    # Compression utilities\n    def _compress_chain(self, node, obstacles, edges, depth_limit):\n        depth = 0\n        cur = node\n        while depth < depth_limit:\n            p = cur.parent\n            if p is None:\n                break\n            gp = p.parent\n            if gp is None:\n                break\n            if not self._edge_free(gp.position, cur.position, obstacles):\n                break\n            # reparent\n            p.remove_child(cur)\n            self._edges_remove(edges, p, cur)\n            gp.add_child(cur)\n            edges.append((gp, cur))\n            old_cost = cur.cost\n            cur.cost = gp.cost + self._dist(gp.position, cur.position)\n            delta = cur.cost - old_cost\n            if abs(delta) > 1e-12:\n                self._propagate_cost(cur, delta)\n            depth += 1\n\n    def _propagate_cost(self, node, delta):\n        # Update subtree costs after reparenting\n        stack = list(node.children)\n        while stack:\n            n = stack.pop()\n            n.cost += delta\n            for c in n.children:\n                stack.append(c)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Paths and smoothing\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a, b, a_from_start):\n        # a is in the active tree (tree1), b in the opposite tree (tree2)\n        pa = self._path_to_root(a)\n        pb = []\n        cur = b\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        # If growing from start, pb goes b..goal; else b..start; concatenation stays correct\n        return pa + pb\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _smooth_path(self, path, obstacles, iters, patience):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        best_len = self._path_length(pts)\n        no_improve = 0\n        for _ in range(iters):\n            if len(pts) < 3:\n                break\n            i = int(self._uniform(0, len(pts) - 2))\n            j = int(self._uniform(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                continue\n            if self._edge_free(pts[i], pts[j], obstacles):\n                new_pts = pts[:i + 1] + pts[j:]\n                new_len = self._path_length(new_pts)\n                if new_len + 1e-9 < best_len:\n                    pts = new_pts\n                    best_len = new_len\n                    no_improve = 0\n                else:\n                    no_improve += 1\n            else:\n                no_improve += 1\n            if no_improve >= patience:\n                break\n        # forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            k = 1\n            while k < len(pts) - 1:\n                nxt = pts[k + 1]\n                if self._edge_free(last, nxt, obstacles):\n                    k += 1\n                else:\n                    collapsed.append(pts[k])\n                    last = pts[k]\n                    k += 1\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
          "objective": -32.04681,
          "time_improvement": 57.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1606.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0160780668258667,
                    "num_nodes_avg": 54.5,
                    "path_length_avg": 178.9081741619695,
                    "smoothness_avg": 0.051583685968640866,
                    "success_improvement": 0.0,
                    "time_improvement": 36.94577918404633,
                    "node_improvement": 86.27549735582977,
                    "length_improvement": 1.9375947603861294,
                    "smoothness_improvement": 707.3967011761849,
                    "objective_score": 15.783274117326503
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.027580070495605468,
                    "num_nodes_avg": 100.1,
                    "path_length_avg": 240.86804814126344,
                    "smoothness_avg": 0.10972615466856887,
                    "success_improvement": 0.0,
                    "time_improvement": 82.78368898030901,
                    "node_improvement": 93.27420546932743,
                    "length_improvement": 19.59131252809127,
                    "smoothness_improvement": 2723.332992176965,
                    "objective_score": 50.20655917183229
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.024082136154174805,
                    "num_nodes_avg": 106.1,
                    "path_length_avg": 130.6210437346923,
                    "smoothness_avg": 0.11683429429214313,
                    "success_improvement": 0.0,
                    "time_improvement": 50.90452639893067,
                    "node_improvement": 86.50985378258105,
                    "length_improvement": 13.24772225711989,
                    "smoothness_improvement": 1386.1235995855145,
                    "objective_score": 30.150609271878707
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "AURORA-BiRRT*: A*-guided, Unrolled-Rewire, Obstacle-Grid accelerated BiRRT with memoized edges and cell-pair sieve. It couples hashed nearest search, per-cell throttling, duplicate suppression, heuristic parent selection (g+h), bounded rewiring with full cost propagation, multi-step Connect, and quantized edge-collision caching; online LOS compression and cache-aware shortcutting yield smooth, short paths quickly.",
          "planning_mechanism": "Alternate tree growth with k-beam samples. Each beam selects a parent among local candidates minimizing g(parent)+d(parent,qn)+\u03bb\u00b7h(qn,other-tree), enforcing both node and edge validity before insertion. After insertion, LOS-compress to an ancestor, rewire neighbors if cheaper and propagate costs. A limited Connect grows the opposite tree unless a cached blocked cell-pair forbids it; direct edges terminate early. Once an incumbent exists, informed ellipse sampling narrows exploration; final shortcutting and LOS collapse return a concise path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=9.0,\n        collision_res=1.0,\n        beam_k=2,\n        goal_bias=0.2,\n        informed_bias=0.6,\n        grid_cell_factor=1.2,\n        per_cell_cap=6,\n        dupe_radius_ratio=0.45,\n        rewire_radius_factor=2.5,\n        neighbor_cap=24,\n        compress_depth=2,\n        connect_steps=3,\n        edge_cache_capacity=40000,\n        edge_cache_quant=0.8,\n        smoothing_iters=50,\n        no_improve_stop=12\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_res = collision_res\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.per_cell_cap = per_cell_cap\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.rewire_radius_factor = rewire_radius_factor\n        self.neighbor_cap = neighbor_cap\n        self.compress_depth = compress_depth\n        self.connect_steps = connect_steps\n        self.edge_cache_capacity = edge_cache_capacity\n        self.edge_cache_quant = edge_cache_quant\n        self.smoothing_iters = smoothing_iters\n        self.no_improve_stop = no_improve_stop\n\n        self._rnd_state = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n\n        # Edge cache\n        self._tick = 0\n        self.ecache = {}\n        self._last_prune_size = 0\n        self.eq = max(0.25, self.edge_cache_quant)\n        # Collision stepping resolution for fallback sampling checks\n        self.edge_res = max(0.5, self.collision_res)\n\n        # Build obstacle grid\n        self._build_obstacle_grid()\n\n        # Validate endpoints\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        nodes = []\n        edges = []\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a, tree_b = [start_root], [goal_root]\n        grid_a, grid_b = {}, {}\n        throttles_a, throttles_b = {}, {}\n        anchors_a, anchors_b = [start_root], [goal_root]\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_path = None\n        best_len = float('inf')\n        sg = self._dist(self.start, self.goal)\n\n        blocked_pairs = set()\n        anchor_stride = 20\n        max_rings = 4\n\n        for it in range(self.max_iter):\n            side_start = (it % 2 == 0)\n            tree1 = tree_a if side_start else tree_b\n            grid1 = grid_a if side_start else grid_b\n            throttles1 = throttles_a if side_start else throttles_b\n            anchors1 = anchors_a if side_start else anchors_b\n\n            tree2 = tree_b if side_start else tree_a\n            grid2 = grid_b if side_start else grid_a\n            throttles2 = throttles_b if side_start else throttles_a\n            anchors2 = anchors_b if side_start else anchors_a\n\n            attractor = self.goal if side_start else self.start\n\n            progressed = False\n            for _ in range(self.beam_k):\n                sample = self._sample(attractor, best_len, sg)\n                if sample is None:\n                    continue\n                near = self._nearest_hashed(grid1, anchors1, sample, max_rings)\n                if near is None:\n                    continue\n                new_pos = self._steer(near.position, sample)\n                if not self._within_bounds(new_pos):\n                    continue\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if self._has_nearby(grid1, new_pos, self.dupe_radius):\n                    continue\n\n                # Parent selection (A*-guided among local candidates)\n                rewire_r = self._rewire_radius(len(nodes))\n                parents = self._candidate_parents(grid1, anchors1, tree1, new_pos, rewire_r, self.neighbor_cap)\n                best_parent, best_new_cost = None, float('inf')\n                best_score = float('inf')\n                other_near = self._nearest_hashed(grid2, anchors2, new_pos, max_rings)\n                h_term = self._dist(new_pos, other_near.position if other_near else attractor)\n                lam = 0.1\n                for p in parents:\n                    if not self._edge_free(p.position, new_pos):\n                        continue\n                    gc = p.cost + self._dist(p.position, new_pos)\n                    f = gc + lam * h_term\n                    if f + 1e-9 < best_score:\n                        best_score = f\n                        best_parent = p\n                        best_new_cost = gc\n                if best_parent is None:\n                    continue\n\n                # Per-cell cap with cost admission\n                ckey = self._cell_of(new_pos)\n                bucket = grid1.get(ckey)\n                if bucket and len(bucket) >= self.per_cell_cap:\n                    best_bucket_cost = min(n.cost for n in bucket)\n                    if best_new_cost >= best_bucket_cost - 1e-9:\n                        continue\n\n                # Final validity before insertion\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if not self._edge_free(best_parent.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos, best_parent, best_new_cost)\n                best_parent.add_child(new_node)\n                tree1.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                self._grid_insert(grid1, new_node)\n                throttles1[ckey] = throttles1.get(ckey, 0) + 1\n                if (len(tree1) % anchor_stride) == 0:\n                    anchors1.append(new_node)\n                progressed = True\n\n                # LOS compression to ancestors\n                self._compress_to_ancestors(new_node, edges, self.compress_depth)\n\n                # Rewiring around new_node\n                self._rewire_neighbors(grid1, new_node, rewire_r, edges)\n\n                # Try connect to the other tree\n                pair_key = self._pair_key(self._cell_of(new_node.position),\n                                          self._cell_of((other_near.position if other_near else attractor)))\n                if pair_key not in blocked_pairs:\n                    connected, path = self._attempt_connect(new_node, tree2, grid2, throttles2, anchors2, nodes, edges)\n                    if connected:\n                        path = self._shortcut(path)\n                        path = self._los_collapse(path)\n                        best_path = path\n                        best_len = self._path_len(path)\n                        return PlannerResult(True, path, nodes, edges)\n                    else:\n                        blocked_pairs.add(pair_key)\n\n            if not progressed:\n                continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 997 + 0.5)) & 0xffffffff\n        s ^= len(self.obstacles) * 2654435761\n        self._rnd_state = (s ^ 0xA5A5A5) & 0xffffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 2463534242\n\n    def _rand(self):\n        self._rnd_state = (1664525 * self._rnd_state + 1013904223) & 0xffffffff\n        return self._rnd_state / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims)))\n\n    # Sampling\n    def _sample(self, attractor, best_len, sg):\n        for _ in range(24):\n            if best_len < float('inf') and self._rand() < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p and self._within_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n                if self._within_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum\n        ext = [half] * self.dims\n        for _ in range(24):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # Node grid (for NN, dupes, neighbors)\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, anchors, pos, max_rings=4):\n        key = self._cell_of(pos)\n        best, bestd = None, 1e100\n        for r in range(0, max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # fallback scan\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((key[0] + dx, key[1] + dy))\n                    if not bucket:\n                        continue\n                    for n in bucket:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    def _candidate_parents(self, grid, anchors, tree, pos, radius, cap):\n        key = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        if not cand:\n            cand = anchors[:]\n        if len(cand) > cap:\n            # Reservoir-like random subset\n            out = []\n            take = 0\n            for n in cand:\n                take += 1\n                if len(out) < cap:\n                    out.append(n)\n                else:\n                    j = int(self._rand_range(0, take))\n                    if j < len(out):\n                        out[j] = n\n            cand = out\n        return cand\n\n    # Obstacle spatial grid\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, obs in enumerate(self.obstacles):\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    # Edge checks with cache\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.eq) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.eq) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        if len(self.ecache) - self._last_prune_size > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self.ecache:\n            return\n        cutoff = self._tick - 3000\n        to_del = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            i = 0\n            for k in list(self.ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune_size = len(self.ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # Compression and rewiring\n    def _compress_to_ancestors(self, node, edges, depth_limit):\n        depth = 0\n        curp = node.parent\n        while curp is not None and curp.parent is not None and depth < depth_limit:\n            gp = curp.parent\n            if self._edge_free(gp.position, node.position):\n                self._reparent(node, gp, edges)\n                curp = node.parent\n                depth += 1\n            else:\n                break\n\n    def _rewire_radius(self, n_nodes):\n        # simple schedule\n        return max(self.step_size * 1.5, self.rewire_radius_factor * self.step_size)\n\n    def _rewire_neighbors(self, grid, node, radius, edges):\n        key = self._cell_of(node.position)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        neigh = self._grid_ring_nodes(grid, key, r_cells)\n        count = 0\n        for nb in neigh:\n            if nb is node or nb is node.parent:\n                continue\n            if self._is_ancestor(nb, node):\n                continue\n            d = self._dist(node.position, nb.position)\n            if d > radius:\n                continue\n            new_cost = node.cost + d\n            if new_cost + 1e-9 < nb.cost and self._edge_free(node.position, nb.position):\n                self._reparent(nb, node, edges)\n                count += 1\n                if count >= self.neighbor_cap:\n                    break\n\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reparent(self, child, new_parent, edges):\n        old_parent = child.parent\n        if old_parent is new_parent:\n            return\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    stack.append(ch)\n\n    # Connect attempt\n    def _attempt_connect(self, new_node, other_tree, other_grid, throttles, anchors, nodes, edges):\n        other_near = self._nearest_hashed(other_grid, anchors, new_node.position, 4)\n        if other_near is None:\n            return False, []\n        # Try direct bridge first\n        if self._edge_free(new_node.position, other_near.position):\n            path = self._extract_path(new_node, other_near)\n            return True, self._ensure_bounds_and_valid(path)\n\n        p = other_near\n        steps = 0\n        last_q = None\n        while steps < self.connect_steps:\n            step_pos = self._steer(p.position, new_node.position)\n            if not self._within_bounds(step_pos):\n                break\n            if self._point_in_obstacles(step_pos):\n                break\n            if self._has_nearby(other_grid, step_pos, self.dupe_radius):\n                break\n            if not self._edge_free(p.position, step_pos):\n                break\n            cell = self._cell_of(step_pos)\n            bucket = other_grid.get(cell)\n            if bucket and len(bucket) >= self.per_cell_cap:\n                best_bucket_cost = min(n.cost for n in bucket)\n                new_c = p.cost + self._dist(p.position, step_pos)\n                if new_c >= best_bucket_cost - 1e-9:\n                    break\n\n            q = Node(step_pos, p, p.cost + self._dist(p.position, step_pos))\n            p.add_child(q)\n            other_tree.append(q)\n            nodes.append(q)\n            edges.append((p, q))\n            self._grid_insert(other_grid, q)\n            throttles[cell] = throttles.get(cell, 0) + 1\n            if (len(other_tree) % 20) == 0:\n                anchors.append(q)\n\n            self._compress_to_ancestors(q, edges, 1)\n            # local light rewiring\n            self._rewire_neighbors(other_grid, q, self._rewire_radius(len(nodes)), edges)\n\n            if self._edge_free(new_node.position, q.position):\n                path = self._extract_path(new_node, q)\n                return True, self._ensure_bounds_and_valid(path)\n\n            p = q\n            last_q = q\n            steps += 1\n        return False, []\n\n    def _pair_key(self, c1, c2):\n        return (c1, c2) if c1 <= c2 else (c2, c1)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return pa + pb[::-1]\n\n    def _ensure_bounds_and_valid(self, path):\n        return [self._clamp(p) for p in path]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # Post smoothing\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_improve = 0\n        best_len = self._path_len(pts)\n        while attempts < self.smoothing_iters:\n            i = int(self._rand_range(0, max(1, len(pts) - 2)))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                attempts += 1\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best_len + 1e-12:\n                    pts = new_pts\n                    best_len = L\n                    no_improve = 0\n                else:\n                    no_improve += 1\n            else:\n                no_improve += 1\n            attempts += 1\n            if no_improve >= self.no_improve_stop:\n                break\n        return pts\n\n    def _los_collapse(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = [path[0]]\n        last = path[0]\n        k = 1\n        while k < len(path) - 1:\n            nxt = path[k + 1]\n            if self._edge_free(last, nxt):\n                k += 1\n                continue\n            pts.append(path[k])\n            last = path[k]\n            k += 1\n        pts.append(path[-1])\n        return pts",
          "objective": -29.84258,
          "time_improvement": 46.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1759.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.013257336616516114,
                    "num_nodes_avg": 49.0,
                    "path_length_avg": 163.59788282479164,
                    "smoothness_avg": 0.10284552152668414,
                    "success_improvement": 0.0,
                    "time_improvement": 48.00798880221262,
                    "node_improvement": 87.6605389070763,
                    "length_improvement": 10.329408049384693,
                    "smoothness_improvement": 1509.7557445171647,
                    "objective_score": 28.148820192880425
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01610586643218994,
                    "num_nodes_avg": 62.0,
                    "path_length_avg": 241.62656852319907,
                    "smoothness_avg": 0.0921645090196098,
                    "success_improvement": 0.0,
                    "time_improvement": 89.9462328864473,
                    "node_improvement": 95.83417321776524,
                    "length_improvement": 19.338096591802515,
                    "smoothness_improvement": 2271.4592004871693,
                    "objective_score": 49.944023823451545
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.048529839515686034,
                    "num_nodes_avg": 126.0,
                    "path_length_avg": 141.44566627862946,
                    "smoothness_avg": 0.12548275222835503,
                    "success_improvement": 0.0,
                    "time_improvement": 1.0637827328513305,
                    "node_improvement": 83.97965670692943,
                    "length_improvement": 6.058523376571766,
                    "smoothness_improvement": 1496.1313461713685,
                    "objective_score": 11.4349055766553
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "EC-Guide BiRRT with Edge-Cached LOS Compression and Elliptic Focus (EC-GBiRRT). This planner grows two trees from start and goal using a small beam of guided samples, compresses each new extension via multi-ancestor line-of-sight (LOS) with a shared edge-collision memo cache, and attempts a zero-step direct connect to the other tree. After a first path, sampling narrows to a prolate ellipse corridor to accelerate convergence. Early-terminating forward LOS shortcutting finalizes the path. These choices cut repeated collision checks, reduce tree depth, and avoid micro-step connects, improving planning time and path quality.",
          "planning_mechanism": "Each iteration alternates trees: generate a few biased samples, pick a nearby node via a grid hash, steer one step, and validate node/edge. Select the cheapest LOS-ancestor parent using cached edge checks, insert the node, then try a direct LOS link to the other tree\u2019s nearest node; if it succeeds, extract and lightly shortcut the path. A shared bounded edge-cache stores free/blocked results, multi-ancestor compression shortens chains, a per-cell cap limits redundant local growth, and corridor-biased sampling activates once a provisional path exists.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        beam_width=2,\n        goal_bias=0.2,\n        los_lookback_depth=10,\n        min_separation_factor=0.6,\n        grid_cell_factor=1.2,\n        per_cell_cap=12,\n        edge_cache_capacity=20000,\n        shortcut_attempts=60,\n        no_improve_stop=12\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.los_lookback_depth = los_lookback_depth\n        self.min_separation_factor = min_separation_factor\n        self.grid_cell_factor = grid_cell_factor\n        self.per_cell_cap = per_cell_cap\n        self.edge_cache_capacity = edge_cache_capacity\n        self.shortcut_attempts = shortcut_attempts\n        self.no_improve_stop = no_improve_stop\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dims = len(self.bounds)\n        self.is_3d = self.dims == 3\n        self.obstacles = map.obstacles\n        self.start = map.start\n        self.goal = map.goal\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n        self.ecache = {}\n        self._tick = 0\n        self._last_prune = 0\n        self.ecache_quant = max(0.5, self.step_size * 0.5)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(self.start, parent=None, cost=0.0)\n        goal_root = Node(self.goal, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        incumbent_len = None\n        best_path = None\n\n        for _ in range(self.max_iter):\n            # Alternate trees each loop\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, self.goal),\n                (tree_b, grid_b, tree_a, grid_a, self.start),\n            ]:\n                progress = False\n                for _b in range(self.beam_width):\n                    sample = self._guided_sample(attractor, incumbent_len)\n                    if sample is None:\n                        continue\n\n                    nearest = self._nearest_in_grid(active_grid, sample)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos):\n                        continue\n                    if self._in_obstacle(new_pos):\n                        continue\n                    # Check edge to nearest; required before any parent selection\n                    if not self._edge_free(nearest.position, new_pos):\n                        continue\n                    # Duplicate suppression\n                    if self._has_nearby(active_grid, new_pos, self.min_separation):\n                        continue\n\n                    # Parent selection via LOS ancestors using cached edge checks\n                    parent = self._select_parent(nearest, new_pos)\n                    if parent is None:\n                        # Safety: though nearest->new_pos was free, parent selection failed; fallback\n                        parent = nearest\n\n                    # Per-cell growth limit; allow insert if bucket light or cost improves the bucket\n                    cell_key = self._cell_of(new_pos)\n                    bucket = active_grid.get(cell_key)\n                    if bucket and len(bucket) >= self.per_cell_cap:\n                        # Allow only if this is significantly cheaper than the best in bucket\n                        best_bucket_cost = min(n.cost for n in bucket)\n                        cand_cost = parent.cost + self._distance(parent.position, new_pos)\n                        if cand_cost >= best_bucket_cost - 1e-6:\n                            continue\n\n                    new_cost = parent.cost + self._distance(parent.position, new_pos)\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node)\n                    progress = True\n\n                    # Attempt direct LOS connect (no micro-steps)\n                    other_near = self._nearest_in_grid(other_grid, new_node.position)\n                    if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                        path_a = self._path_from_root(new_node)\n                        path_b = self._path_from_root(other_near)\n                        # Merge with direct bridge segment ensured free\n                        raw_path = path_a + path_b[::-1]\n                        # Path might duplicate joint if new_node coincides with other_near; dedup\n                        if len(raw_path) >= 2 and self._distance(raw_path[-1], raw_path[-2]) <= 1e-9:\n                            raw_path.pop()  # remove duplicate\n                        smoothed = self._shortcut(raw_path)\n                        final_path = smoothed if smoothed else raw_path\n                        best_path = final_path\n                        incumbent_len = self._path_length(final_path)\n                        return PlannerResult(True, final_path, nodes, edges)\n\n                # If we found no progress from this side in this alternation, continue to the other\n                if not progress:\n                    continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # ---------- Geometry and metrics ----------\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._distance(a, b)\n        if d <= 1e-12:\n            return a\n        if d <= self.step_size:\n            return b\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n\n    def _path_from_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        length = 0.0\n        for i in range(1, len(path)):\n            length += self._distance(path[i - 1], path[i])\n        return length\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, attractor, incumbent_len):\n        # Corridor-biased sampling if incumbent exists; else mild goal bias\n        # Try limited attempts to avoid heavy rejection\n        for _ in range(20):\n            if incumbent_len is not None and self._distance(self.start, self.goal) > 1e-9:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.05)\n                if p is None:\n                    continue\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if self._within_bounds(p) and not self._in_obstacle(p):\n                return p\n        # Fallback hard-attractor\n        return attractor if self._within_bounds(attractor) and not self._in_obstacle(attractor) else None\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        # Rejection sample in the bounding box of the ellipse/spheroid\n        # Limited attempts for speed; returns None on failure\n        cx = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        # Direction vector and its norm\n        v = tuple(f2[i] - f1[i] for i in range(self.dims))\n        vd = self._distance(f1, f2)\n        # Bounding box extents\n        ext = [half, half, half] if self.is_3d else [half, half]\n        # Try a few samples\n        for _ in range(12):\n            p = tuple(cx[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            # ellipse condition: dist(p,f1)+dist(p,f2) <= max_sum_dist\n            if self._distance(p, f1) + self._distance(p, f2) <= max_sum_dist and not self._in_obstacle(p):\n                return p\n        return None\n\n    # ---------- Grid spatial hash ----------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    def _nearest_in_grid(self, grid, pos, max_ring=5):\n        cell = self._cell_of(pos)\n        best = None\n        best_d = 1e100\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best = n\n                                        best_d = d\n                                        found = True\n                if found:\n                    return best\n        else:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best = n\n                                    best_d = d\n                                    found = True\n                if found:\n                    return best\n        # Rare fallback: scan all buckets\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._distance(n.position, pos)\n                if d < best_d:\n                    best = n\n                    best_d = d\n        return best\n\n    # ---------- Obstacles ----------\n    def _in_obstacle(self, pos):\n        if self.is_3d:\n            px, py, pz = pos\n            for obs in self.obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in self.obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.ecache_quant) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.ecache_quant) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]  # True if free, False if blocked\n        # Compute and cache\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        # Bounded pruning\n        if len(self.ecache) - self._last_prune > self.edge_cache_capacity:\n            self._prune_cache()\n        return free\n\n    def _prune_cache(self):\n        # Drop roughly oldest 40%\n        if not self.ecache:\n            return\n        cutoff = self._tick - 2000\n        to_remove = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_remove.append(k)\n        if not to_remove:\n            # If nothing older than cutoff, remove every 3rd entry to bound size\n            i = 0\n            for k in list(self.ecache.keys()):\n                if i % 3 == 0:\n                    to_remove.append(k)\n                i += 1\n        for k in to_remove:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune = len(self.ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        dist = self._distance(a, b)\n        # Resolution tuned for speed while preserving safety\n        resolution = max(0.5, min(1.0, self.step_size * 0.5))\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(self.dims))\n            if self._in_obstacle(p):\n                return True\n        return False\n\n    # ---------- Parent selection ----------\n    def _select_parent(self, nearest, new_pos):\n        best = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        cur = nearest\n        depth = 0\n        while cur is not None and depth < self.los_lookback_depth:\n            if self._edge_free(cur.position, new_pos):\n                cand = cur.cost + self._distance(cur.position, new_pos)\n                if cand + 1e-9 < best_cost:\n                    best_cost = cand\n                    best = cur\n            cur = cur.parent\n            depth += 1\n        return best\n\n    # ---------- Shortcut smoothing ----------\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_improve = 0\n        i = 0\n        while attempts < self.shortcut_attempts and i < len(pts) - 2:\n            improved = False\n            # Try to jump from i to a farther j\n            j = len(pts) - 1\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    # Remove intermediates\n                    del pts[i + 1:j]\n                    improved = True\n                    no_improve = 0\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n                no_improve += 1\n            attempts += 1\n            if no_improve >= self.no_improve_stop:\n                break\n        return pts\n\n    # ---------- Random helpers ----------\n    def _rand(self):\n        # expects 'random' module available\n        return random.random()\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()",
          "objective": -29.11471,
          "time_improvement": 51.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 1571.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02822730541229248,
                    "num_nodes_avg": 65.6,
                    "path_length_avg": 182.96020324956595,
                    "smoothness_avg": 0.05732726413788967,
                    "success_improvement": 0.0,
                    "time_improvement": -10.700544274551492,
                    "node_improvement": 83.48023167967766,
                    "length_improvement": -0.28338659103527,
                    "smoothness_improvement": 797.2961719045505,
                    "objective_score": 0.6062856225361433
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01984243392944336,
                    "num_nodes_avg": 86.6,
                    "path_length_avg": 243.5413235727727,
                    "smoothness_avg": 0.09042567896577892,
                    "success_improvement": 0.0,
                    "time_improvement": 87.61375486797985,
                    "node_improvement": 94.18128065578178,
                    "length_improvement": 18.698896243086562,
                    "smoothness_improvement": 2226.7178507734366,
                    "objective_score": 48.63705346011307
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01169896125793457,
                    "num_nodes_avg": 78.1,
                    "path_length_avg": 133.4682422714018,
                    "smoothness_avg": 0.1405957321950529,
                    "success_improvement": 0.0,
                    "time_improvement": 76.14970532839176,
                    "node_improvement": 90.06993006993007,
                    "length_improvement": 11.356748558062376,
                    "smoothness_improvement": 1688.3673358236224,
                    "objective_score": 38.100797412473064
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "Beam-guided BiRRT with ancestor line-of-sight compression and spatial hashing (BG-Connect-LOS). The planner alternates tree growth from start and goal using a small beam of guided samples, accelerates nearest lookups with a grid hash, suppresses near-duplicate nodes, and selects a parent among recent ancestors that maintains direct line-of-sight to the new point to compress chains. A short, capped greedy connect links the two trees. Upon success, a bounded shortcut pass refines the path. This reduces expansions and collision checks while improving path quality and smoothness.",
          "planning_mechanism": "At each iteration, pick the active tree and generate a small beam of guided samples biased toward the opposite root. For each sample: find a nearby node via spatial hashing, steer by a fixed step, enforce node and edge collision checks, reject near-duplicates, and pick an ancestor parent with clear line-of-sight to minimize added cost. Insert the node and attempt a capped greedy connect from the opposite tree toward it; if the two trees meet, extract and lightly shortcut the path. Alternate trees and stop early on success.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        beam_width=3,\n        goal_bias=0.15,\n        connect_steps_limit=20,\n        min_separation_factor=0.6,\n        grid_cell_factor=1.0,\n        los_lookback_depth=8,\n        shortcut_attempts=40\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.connect_steps_limit = connect_steps_limit\n        self.min_separation_factor = min_separation_factor\n        self.grid_cell_factor = grid_cell_factor\n        self.los_lookback_depth = los_lookback_depth\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dims = len(bounds)\n        is_3d = dims == 3\n\n        # Parameters derived from step_size\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root = Node(goal_position, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root, is_3d)\n        self._grid_insert(grid_b, goal_root, is_3d)\n\n        success_state = False\n        extracted_path = []\n\n        for _ in range(self.max_iter):\n            # Alternate trees by swapping references each loop\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, goal_position),\n                (tree_b, grid_b, tree_a, grid_a, start_position),\n            ]:\n                made_progress = False\n\n                for _beam in range(self.beam_width):\n                    sample = self._sample_guided(bounds, obstacles, is_3d, attractor)\n\n                    nearest = self._nearest_by_grid(active_tree, active_grid, sample, is_3d)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos, bounds):\n                        continue\n                    if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                        continue\n                    if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                        continue\n                    if self._has_near_duplicate(active_grid, new_pos, self.min_separation, is_3d):\n                        continue\n\n                    # Choose parent among LOS-capable ancestors to compress path\n                    parent = self._choose_ancestor_parent(nearest, new_pos, obstacles, is_3d)\n                    new_cost = parent.cost + self._distance(parent.position, new_pos)\n\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node, is_3d)\n                    made_progress = True\n\n                    # Try capped greedy connect from the opposite tree toward new_node\n                    connect_node = self._attempt_connect(\n                        other_tree, other_grid, new_node.position, obstacles, is_3d, nodes, edges, bounds\n                    )\n                    if connect_node is not None:\n                        # Trees meet at new_node.position; extract path\n                        path_a = self._path_from_root(new_node)\n                        path_b = self._path_from_root(connect_node)\n                        # Remove duplicate joint if equal\n                        if path_a and path_b and path_a[-1] == path_b[-1]:\n                            path_b = path_b[:-1]\n                        raw_path = path_a + path_b[::-1]\n                        # Light shortcut smoothing\n                        smoothed = self._shortcut_path(raw_path, obstacles, is_3d, attempts=self.shortcut_attempts)\n                        extracted_path = smoothed if smoothed else raw_path\n                        success_state = True\n                        return PlannerResult(True, extracted_path, nodes, edges)\n\n                # If neither beam sample made progress for this tree, continue with the other\n                if not made_progress:\n                    continue\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # --------- Core Geometry / Utilities ---------\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _within_bounds(self, pos, bounds):\n        for i in range(len(bounds)):\n            if pos[i] < 0.0 or pos[i] > bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= 1e-9:\n            return from_pos\n        if dist <= self.step_size:\n            return to_pos\n        r = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * r for d in range(len(from_pos)))\n\n    def _sample_guided(self, bounds, obstacles, is_3d, target):\n        # Mild guidance: with some probability sample exactly target, else blend toward target\n        while True:\n            if random.random() < self.goal_bias:\n                p = target\n            else:\n                rand = tuple(random.uniform(0.0, bounds[d]) for d in range(len(bounds)))\n                alpha = 0.2\n                p = tuple(alpha * target[d] + (1.0 - alpha) * rand[d] for d in range(len(bounds)))\n            if self._within_bounds(p, bounds) and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _path_from_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\n\n    # --------- Spatial Hash (Grid) ---------\n\n    def _cell_of(self, pos):\n        # integer grid cell indices\n        if len(pos) == 3:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        else:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node, is_3d):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _has_near_duplicate(self, grid, pos, radius, is_3d):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    def _nearest_by_grid(self, tree, grid, pos, is_3d, ring_limit=3):\n        # Search neighborhood rings; fallback to linear scan if not found\n        cell = self._cell_of(pos)\n        best = None\n        best_d = float(\"inf\")\n\n        if is_3d:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best_d = d\n                                        best = n\n                                        found = True\n                if found and best is not None:\n                    return best\n        else:\n            for ring in range(0, ring_limit + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                                    found = True\n                if found and best is not None:\n                    return best\n\n        # Fallback\n        if not tree:\n            return None\n        return min(tree, key=lambda n: self._distance(n.position, pos))\n\n    # --------- Parent selection via LOS to ancestors ---------\n\n    def _choose_ancestor_parent(self, nearest, new_pos, obstacles, is_3d):\n        best_parent = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        steps = 0\n        cur = nearest\n        while cur is not None and steps < self.los_lookback_depth:\n            if not self._is_edge_in_obstacle(cur.position, new_pos, obstacles, is_3d):\n                cand_cost = cur.cost + self._distance(cur.position, new_pos)\n                if cand_cost < best_cost:\n                    best_cost = cand_cost\n                    best_parent = cur\n            cur = cur.parent\n            steps += 1\n        return best_parent\n\n    # --------- Connect attempt ---------\n\n    def _attempt_connect(self, tree, grid, target_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest_by_grid(tree, grid, target_pos, is_3d)\n        if nearest is None:\n            return None\n\n        current = nearest\n        for _ in range(self.connect_steps_limit):\n            step_pos = self._steer(current.position, target_pos)\n            if not self._within_bounds(step_pos, bounds):\n                return None\n            if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, step_pos, obstacles, is_3d):\n                return None\n\n            # If close enough to target and direct edge exists, finalize with exact target node\n            if self._distance(step_pos, target_pos) <= 1e-6 or (\n                self._distance(step_pos, target_pos) <= self.step_size and\n                not self._is_edge_in_obstacle(step_pos, target_pos, obstacles, is_3d) and\n                not self._is_in_obstacle(target_pos, obstacles, is_3d)\n            ):\n                # Add intermediate step node if it is not exactly current\n                if self._distance(current.position, step_pos) > 1e-9:\n                    if not self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                        new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n                        current.add_child(new_node)\n                        tree.append(new_node)\n                        nodes.append(new_node)\n                        edges.append((current, new_node))\n                        self._grid_insert(grid, new_node, is_3d)\n                        current = new_node\n                    else:\n                        # If duplicate exists, try using current as is\n                        pass\n                # Add final node at the exact target position to guarantee path merge\n                final_node = Node(target_pos, parent=current, cost=current.cost + self._distance(current.position, target_pos))\n                current.add_child(final_node)\n                tree.append(final_node)\n                nodes.append(final_node)\n                edges.append((current, final_node))\n                self._grid_insert(grid, final_node, is_3d)\n                return final_node\n\n            # Regular step addition with duplicate suppression\n            if self._has_near_duplicate(grid, step_pos, self.min_separation, is_3d):\n                # Progress is negligible; stop trying to avoid loops\n                return None\n\n            new_node = Node(step_pos, parent=current, cost=current.cost + self._distance(current.position, step_pos))\n            current.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((current, new_node))\n            self._grid_insert(grid, new_node, is_3d)\n            current = new_node\n\n        return None\n\n    # --------- Collision Checking ---------\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d):\n        distance = self._distance(from_pos, to_pos)\n        resolution = max(0.5, min(1.0, self.step_size * 0.5))\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    # --------- Shortcut Smoothing (bounded) ---------\n\n    def _shortcut_path(self, path, obstacles, is_3d, attempts=40):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        n = len(pts)\n        tries = 0\n        i = 0\n        # Greedy forward skipping with bounded iterations\n        while i < len(pts) - 2 and tries < attempts:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d):\n                    # Remove intermediates\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n            tries += 1\n        return pts",
          "objective": -28.86257,
          "time_improvement": 43.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1410.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03400664329528809,
                    "num_nodes_avg": 52.1,
                    "path_length_avg": 171.51876006638196,
                    "smoothness_avg": 0.050501544373221775,
                    "success_improvement": 0.0,
                    "time_improvement": -33.36568499023374,
                    "node_improvement": 86.87987912364643,
                    "length_improvement": 5.987849718937115,
                    "smoothness_improvement": 690.45883529979,
                    "objective_score": -2.964701489208901
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.030187082290649415,
                    "num_nodes_avg": 92.2,
                    "path_length_avg": 234.31486940525366,
                    "smoothness_avg": 0.08620583217892899,
                    "success_improvement": 0.0,
                    "time_improvement": 81.1563136658539,
                    "node_improvement": 93.8050124302896,
                    "length_improvement": 21.77895221296278,
                    "smoothness_improvement": 2118.138153515002,
                    "objective_score": 48.004956195108846
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009754443168640136,
                    "num_nodes_avg": 73.2,
                    "path_length_avg": 124.45355479806292,
                    "smoothness_avg": 0.11960663519260235,
                    "success_improvement": 0.0,
                    "time_improvement": 80.11393158758125,
                    "node_improvement": 90.69294342021614,
                    "length_improvement": 17.343874744565582,
                    "smoothness_improvement": 1421.3875712064366,
                    "objective_score": 41.54744217904591
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "HB-EdgeSieve BiRRT (HB-ESBiRRT): A heuristic-biased, bidirectional RRT that uses an obstacle grid with slab-based segment checks, quantized edge-collision caching, and cost-gated sparse hashing to minimize planning time while preserving robustness and path quality. It grows two trees toward each other with a single, high-yield sample per side, selects a cheap line-of-sight ancestor over a short lookback, and attempts direct bridging to the other tree. After the first solution, informed ellipse sampling narrows exploration and a cache-reusing greedy shortcutting finalizes the path.",
          "planning_mechanism": "Mechanism: Each iteration alternates trees. A guided sample (goal-biased or ellipse-informed) is steered from the nearest grid-bucket node. Before inserting, both node and edge are collision-checked. Edge checks use a memoized cache and fast slab intersections against only nearby obstacles fetched from an obstacle spatial grid. Parent compression considers a few visible ancestors to cut depth and cost. On each insertion, the planner tries a zero-step line-of-sight connect to the other tree's nearest node. A per-cell cap with cost admission curbs local redundancy. If a path appears, shortcutting reuses the same cached edge tests to converge quickly.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        goal_bias=0.35,\n        beam_width=1,\n        lookback_depth=4,\n        grid_cell_factor=1.5,\n        per_cell_cap=10,\n        min_separation_factor=0.6,\n        edge_cache_capacity=30000,\n        edge_cache_quant_factor=0.6,\n        shortcut_attempts=60,\n        no_improve_stop=10\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.beam_width = beam_width\n        self.lookback_depth = lookback_depth\n        self.grid_cell_factor = grid_cell_factor\n        self.per_cell_cap = per_cell_cap\n        self.min_separation_factor = min_separation_factor\n        self.edge_cache_capacity = edge_cache_capacity\n        self.edge_cache_quant_factor = edge_cache_quant_factor\n        self.shortcut_attempts = shortcut_attempts\n        self.no_improve_stop = no_improve_stop\n\n        # PRNG state\n        self._rnd_state = 1234567\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        # Early exit if trivial\n        if self._dist(self.start, self.goal) <= 1e-9:\n            path = [self.start, self.goal]\n            return PlannerResult(True, path, [], [])\n\n        # Initialize parameters\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n\n        # Initialize PRNG with scene-dependent seed\n        self._seed_from_scene()\n\n        # Edge collision cache (LRU-ish via ticks)\n        self._tick = 0\n        self._last_prune_size = 0\n        self.ecache = {}\n        self.ecache_quant = max(0.25, self.step_size * self.edge_cache_quant_factor)\n\n        # Build obstacle spatial grid for fast queries\n        self._build_obstacle_grid()\n\n        nodes = []\n        edges = []\n\n        # Validate start/goal points\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        start_root = Node(self.start, parent=None, cost=0.0)\n        goal_root = Node(self.goal, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        best_path = None\n        incumbent_len = None\n\n        for _ in range(self.max_iter):\n            # Alternate growth between the two trees\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, self.goal),\n                (tree_b, grid_b, tree_a, grid_a, self.start)\n            ]:\n                progressed = False\n                for _b in range(self.beam_width):\n                    sample = self._sample(attractor, incumbent_len)\n                    if sample is None:\n                        continue\n\n                    nearest = self._nearest_in_grid(active_grid, sample)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos):\n                        continue\n                    # Node collision check\n                    if self._point_in_obstacles(new_pos):\n                        continue\n                    # Edge collision check to nearest\n                    if not self._edge_free(nearest.position, new_pos):\n                        continue\n                    # Suppress near-duplicates\n                    if self._has_nearby(active_grid, new_pos, self.min_separation):\n                        continue\n\n                    # Limited lookback LOS parent selection\n                    parent = self._best_parent_los(nearest, new_pos)\n                    new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n                    # Per-cell cap with cost admission\n                    cell_key = self._cell_of(new_pos)\n                    bucket = active_grid.get(cell_key)\n                    if bucket and len(bucket) >= self.per_cell_cap:\n                        best_bucket_cost = min(n.cost for n in bucket)\n                        if new_cost >= best_bucket_cost - 1e-9:\n                            continue\n\n                    # Insert node\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node)\n                    progressed = True\n\n                    # Try direct bridge to the other tree\n                    other_near = self._nearest_in_grid(other_grid, new_node.position)\n                    if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                        # Build raw path\n                        path_a = self._path_to_root(new_node)\n                        path_b = self._path_to_root(other_near)\n                        raw_path = path_a + path_b[::-1]\n                        # Deduplicate meeting point if coincident\n                        if len(raw_path) >= 2 and self._dist(raw_path[-1], raw_path[-2]) <= 1e-12:\n                            raw_path.pop()\n                        # Shortcut with cached collision checks\n                        final_path = self._shortcut(raw_path)\n                        best_path = final_path\n                        incumbent_len = self._path_len(final_path)\n                        return PlannerResult(True, final_path, nodes, edges)\n\n                if not progressed:\n                    continue\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # ---------- PRNG ----------\n    def _seed_from_scene(self):\n        s = 0\n        for v in self.start + self.goal:\n            s = (s * 1315423911 + int(v * 1000 + 0.5)) & 0x7fffffff\n        s ^= len(self.obstacles) * 2654435761\n        self._rnd_state = (s ^ 0xA5A5A5) & 0x7fffffff\n        if self._rnd_state == 0:\n            self._rnd_state = 1234567\n\n    def _rand(self):\n        # LCG: x_{n+1} = (a x_n + c) mod m\n        self._rnd_state = (1103515245 * self._rnd_state + 12345) & 0x7fffffff\n        return (self._rnd_state / 2147483647.0)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return a\n        if d <= self.step_size:\n            return b\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _path_len(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    # ---------- Sampling ----------\n    def _sample(self, attractor, incumbent_len):\n        # Guided: ellipse if incumbent known, else uniform with goal bias\n        for _ in range(20):\n            if incumbent_len is not None and self._dist(self.start, self.goal) > 1e-9:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.03)\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if p is None:\n                continue\n            if self._within_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        # Fallback\n        return attractor if self._within_bounds(attractor) and not self._point_in_obstacles(attractor) else None\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        # Rejection sample around the segment f1-f2\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        ext = [half] * self.dims\n        for _ in range(16):\n            p = tuple(c[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum_dist and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    # ---------- Grid spatial hash for nodes ----------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _nearest_in_grid(self, grid, pos, max_ring=5):\n        cell = self._cell_of(pos)\n        best = None\n        best_d = 1e100\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if not bucket:\n                                continue\n                            for n in bucket:\n                                d = self._dist(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                                    found = True\n                if found:\n                    return best\n        else:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            d = self._dist(n.position, pos)\n                            if d < best_d:\n                                best_d = d\n                                best = n\n                                found = True\n                if found:\n                    return best\n        # Fallback: scan all\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._dist(n.position, pos)\n                if d < best_d:\n                    best_d = d\n                    best = n\n        return best\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if not bucket:\n                            continue\n                        for n in bucket:\n                            if self._dist(n.position, pos) <= radius:\n                                return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if not bucket:\n                        continue\n                    for n in bucket:\n                        if self._dist(n.position, pos) <= radius:\n                            return True\n        return False\n\n    # ---------- Obstacle spatial grid ----------\n    def _build_obstacle_grid(self):\n        # Choose obstacle cell size proportional to step for balanced performance\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}  # cell -> list of obstacle indices\n        self._obs_is_3d = self.is_3d\n        for idx, obs in enumerate(self.obstacles):\n            if self._obs_is_3d:\n                x, y, z, w, h, d = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            key = (cx, cy, cz)\n                            bucket = self.obs_grid.get(key)\n                            if bucket is None:\n                                self.obs_grid[key] = [idx]\n                            else:\n                                bucket.append(idx)\n            else:\n                x, y, w, h = obs\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        key = (cx, cy)\n                        bucket = self.obs_grid.get(key)\n                        if bucket is None:\n                            self.obs_grid[key] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self._obs_is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    # ---------- Edge checks with cache ----------\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.ecache_quant) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.ecache_quant) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        if len(self.ecache) - self._last_prune_size > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self.ecache:\n            return\n        # Drop the oldest ~40%\n        cutoff = self._tick - 2000\n        to_del = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            # Fallback: remove every 3rd entry to bound size\n            i = 0\n            for k in list(self.ecache.keys()):\n                if (i % 3) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune_size = len(self.ecache)\n\n    # ---------- Segment vs obstacle (slab) accelerated by obstacle grid ----------\n    def _segment_hits_obstacle(self, a, b):\n        # Gather obstacles intersecting the bounding box of segment\n        if self._obs_is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bucket = self.obs_grid.get((cx, cy, cz))\n                        if bucket:\n                            for idx in bucket:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_aabb_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bucket = self.obs_grid.get((cx, cy))\n                    if bucket:\n                        for idx in bucket:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_aabb_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_aabb_intersect_2d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    def _seg_aabb_intersect_3d(self, p0, p1, bmin, bmax):\n        tmin = 0.0\n        tmax = 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                t1 = (mn - p) * inv\n                t2 = (mx - p) * inv\n                if t1 > t2:\n                    t1, t2 = t2, t1\n                if t1 > tmin:\n                    tmin = t1\n                if t2 < tmax:\n                    tmax = t2\n                if tmin > tmax:\n                    return False\n        return True\n\n    # ---------- Parent selection (short LOS lookback) ----------\n    def _best_parent_los(self, nearest, new_pos):\n        best = nearest\n        best_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        cur = nearest\n        depth = 0\n        while cur is not None and depth < self.lookback_depth:\n            if self._edge_free(cur.position, new_pos):\n                c = cur.cost + self._dist(cur.position, new_pos)\n                if c + 1e-9 < best_cost:\n                    best_cost = c\n                    best = cur\n            cur = cur.parent\n            depth += 1\n        return best\n\n    # ---------- Shortcut smoothing ----------\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_improve = 0\n        i = 0\n        while attempts < self.shortcut_attempts and i < len(pts) - 2:\n            improved = False\n            j = len(pts) - 1\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    improved = True\n                    no_improve = 0\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n                no_improve += 1\n            attempts += 1\n            if no_improve >= self.no_improve_stop:\n                break\n        return pts",
          "objective": -26.29094,
          "time_improvement": 61.0,
          "length_improvement": -0.0,
          "smoothness_improvement": 1630.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.024515295028686525,
                    "num_nodes_avg": 73.0,
                    "path_length_avg": 235.8280485058371,
                    "smoothness_avg": 0.03800756828685148,
                    "success_improvement": 0.0,
                    "time_improvement": 3.857046817335618,
                    "node_improvement": 81.6167212289096,
                    "length_improvement": -29.261090320615313,
                    "smoothness_improvement": 494.90097844477503,
                    "objective_score": -13.925035254944627
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023125672340393068,
                    "num_nodes_avg": 110.0,
                    "path_length_avg": 245.0393031205978,
                    "smoothness_avg": 0.12370286737465501,
                    "success_improvement": 0.0,
                    "time_improvement": 85.56425852446206,
                    "node_improvement": 92.6090169992609,
                    "length_improvement": 18.19882755307195,
                    "smoothness_improvement": 3082.9638771238115,
                    "objective_score": 52.003393474800845
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0030002355575561523,
                    "num_nodes_avg": 35.0,
                    "path_length_avg": 135.33178973135438,
                    "smoothness_avg": 0.1109750714335361,
                    "success_improvement": 0.0,
                    "time_improvement": 93.88351661704843,
                    "node_improvement": 95.54990464081374,
                    "length_improvement": 10.119069067755975,
                    "smoothness_improvement": 1311.5947173068773,
                    "objective_score": 40.7944700123025
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "HASTE-BiRRT (Heuristically Accelerated Sparse Tree Expansion BiRRT): a bidirectional planner that couples tiny-beam, corridor/informed sampling with dual-anchored hashed nearest search, bounded per-cell growth, and a two-sided edge memo caching both blocked and free checks. It inserts single-parent nodes with multi-ancestor LOS compression to keep trees shallow, uses a short single-step greedy connect to limit overhead, and maintains an early-updating best path to focus informed sampling. A bounded shortcut with forward LOS collapse returns smooth, short paths quickly.",
          "planning_mechanism": "Alternate growth of start/goal trees. Each side samples a small beam (goal/corridor/uniform, switching to informed ellipse after a provisional path). For each sample, find a near node via grid+anchors, steer once, enforce node and edge validity (with memoized edge checks), suppress near-duplicates and throttle per-cell growth; keep the candidate that minimizes a heuristic combining distance to the opposite tree and cost-to-come. Insert the node, apply multi-ancestor LOS compression, then attempt a direct bridge or a single-step greedy connect from the opposite tree. On success, extract and bounded-shortcut the path with LOS collapse; otherwise iterate to a cap.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=10.0,\n                 collision_step=1.0,\n                 beam_k=2,\n                 goal_bias=0.15,\n                 corridor_bias=0.55,\n                 informed_bias=0.65,\n                 grid_cell=None,\n                 max_rings=3,\n                 dupe_radius_ratio=0.45,\n                 min_sep_ratio=0.30,\n                 cell_expand_limit=2,\n                 anchor_stride=20,\n                 connect_attempts=1,\n                 compress_depth=3,\n                 smoothing_iters=24,\n                 edge_cache_max=20000):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_step = collision_step\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.grid_cell = grid_cell\n        self.max_rings = max_rings\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.min_sep_ratio = min_sep_ratio\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.anchor_stride = max(1, int(anchor_stride))\n        self.connect_attempts = max(1, int(connect_attempts))\n        self.compress_depth = max(1, int(compress_depth))\n        self.smoothing_iters = smoothing_iters\n        self.edge_cache_max = max(1000, int(edge_cache_max))\n\n        # runtime\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self.edge_cache = None  # key -> 1(blocked) or 2(free)\n\n        self.start = None\n        self.goal = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # setup discretizations\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.5)))\n        self.cache_bin = max(1.0, self.edge_res)\n        self.edge_cache = {}\n\n        # validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # early straight connection\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # initialize trees and structures\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        edges = []\n        nodes = [start_root, goal_root]\n\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        anchors_a, anchors_b = [start_root], [goal_root]\n        cell_expands_a, cell_expands_b = {}, {}\n\n        best_path_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        base_corridor_w = max(self.step_size, 0.2 * d_sg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            anchors1 = anchors_a if active_start else anchors_b\n            anchors2 = anchors_b if active_start else anchors_a\n            throttles1 = cell_expands_a if active_start else cell_expands_b\n            throttles2 = cell_expands_b if active_start else cell_expands_a\n            other_root = self.goal if active_start else self.start\n\n            best_parent = None\n            best_new = None\n            best_score = float('inf')\n\n            for _ in range(self.beam_k):\n                # sampling strategy\n                r = self._rand()\n                if best_path_len < float('inf') and r < self.informed_bias:\n                    x_rand = self._sample_informed(best_path_len, obstacles, is_3d)\n                else:\n                    r2 = self._rand()\n                    if r2 < self.goal_bias:\n                        x_rand = other_root\n                    elif r2 < self.goal_bias + self.corridor_bias:\n                        width = base_corridor_w\n                        if best_path_len < float('inf'):\n                            slack = max(0.0, best_path_len - d_sg)\n                            width = max(self.step_size, 0.2 * slack + base_corridor_w)\n                        x_rand = self._sample_corridor(width, obstacles, is_3d)\n                    else:\n                        x_rand = self._sample_free(obstacles, is_3d)\n\n                near = self._nearest_hashed(grid1, tree1, anchors1, x_rand)\n                if near is None:\n                    continue\n\n                new_pos = self._steer(near.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                # Node collision check before any insertion\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n\n                # duplicate suppression and throttle\n                if self._dist(near.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid1, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                kcell = self._grid_key(new_pos)\n                if throttles1.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n\n                # Edge collision check before considering\n                if self._edge_blocked_memo(near.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Heuristic score: distance to opposite-tree nearest + mild cost term\n                other_near = self._nearest_hashed(grid2, tree2, anchors2, new_pos)\n                to_other = self._dist(new_pos, other_near.position) if other_near is not None else self._dist(new_pos, other_root)\n                cost_term = (near.cost + self._dist(near.position, new_pos)) * 0.05\n                score = to_other + cost_term\n\n                if score < best_score:\n                    best_score = score\n                    best_parent = near\n                    best_new = new_pos\n\n            if best_parent is None:\n                continue\n\n            # Final validity before insertion (both checks)\n            if self._is_in_obstacle(best_new, obstacles, is_3d):\n                continue\n            if self._edge_blocked_memo(best_parent.position, best_new, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_cost = best_parent.cost + self._dist(best_parent.position, best_new)\n            new_node = Node(best_new, best_parent, new_cost)\n            best_parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            self._grid_add(grid1, new_node)\n            kc = self._grid_key(best_new)\n            throttles1[kc] = throttles1.get(kc, 0) + 1\n            if len(tree1) % self.anchor_stride == 0:\n                anchors1.append(new_node)\n\n            # Multi-ancestor LOS compression (up to compress_depth)\n            self._compress_to_ancestors(new_node, obstacles, is_3d, edges, self.compress_depth)\n\n            # Try direct bridge\n            other_near = self._nearest_hashed(grid2, tree2, anchors2, new_node.position)\n            if other_near is not None and not self._edge_blocked_memo(new_node.position, other_near.position, obstacles, is_3d):\n                path = self._extract_path(new_node, other_near)\n                best_path_len = self._path_length(path)\n                path = self._smooth_path(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Short greedy connect from the other side (single-step attempts)\n            p = other_near\n            attempts = 0\n            while p is not None and attempts < self.connect_attempts:\n                step_pos = self._steer(p.position, new_node.position, self.step_size)\n                if not self._in_bounds(step_pos):\n                    break\n                if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(grid2, step_pos, self.step_size * self.dupe_radius_ratio):\n                    break\n                if self._edge_blocked_memo(p.position, step_pos, obstacles, is_3d):\n                    break\n\n                # Insert micro-step node (both checks passed)\n                q = Node(step_pos, p, p.cost + self._dist(p.position, step_pos))\n                p.add_child(q)\n                tree2.append(q)\n                nodes.append(q)\n                edges.append((p, q))\n                self._grid_add(grid2, q)\n                if len(tree2) % self.anchor_stride == 0:\n                    anchors2.append(q)\n                throttles2[self._grid_key(step_pos)] = throttles2.get(self._grid_key(step_pos), 0) + 1\n\n                # optional small compression on the micro-step\n                self._compress_to_ancestors(q, obstacles, is_3d, edges, 2)\n\n                # Check bridge to new_node\n                if not self._edge_blocked_memo(new_node.position, q.position, obstacles, is_3d):\n                    path = self._extract_path(new_node, q)\n                    best_path_len = self._path_length(path)\n                    path = self._smooth_path(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, nodes, edges)\n\n                p = q\n                attempts += 1\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp_tuple(to_pos)\n        if d <= 1e-12:\n            return self._clamp_tuple(from_pos)\n        r = step / d\n        return self._clamp_tuple(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Edge memo (blocked and free)\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        state = self.edge_cache.get(key)\n        if state is not None:\n            return state == 1\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d)\n        self.edge_cache[key] = 1 if blocked else 2\n        # bounded cache pruning to limit rechecks without frequent full clears\n        if len(self.edge_cache) > self.edge_cache_max:\n            self._prune_edge_cache()\n        return blocked\n\n    def _prune_edge_cache(self):\n        # remove roughly half of items deterministically\n        to_remove = []\n        count = 0\n        for k in self.edge_cache:\n            if (count % 2) == 0:\n                to_remove.append(k)\n            count += 1\n            if len(to_remove) >= self.edge_cache_max // 2:\n                break\n        for k in to_remove:\n            try:\n                del self.edge_cache[k]\n            except:\n                pass\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            # rejection within sphere\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        else:\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        # prolate ellipse: sum of distances to foci <= best_len\n        for _ in range(48):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= best_len and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # fallback\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)\n\n    # Grid hashing\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, tree, anchors, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # anchor fallback\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # rare: full scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(max(1, radius / self.grid_cell)) + 1\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Compression\n    def _compress_to_ancestors(self, node, obstacles, is_3d, edges, depth_limit):\n        cur_parent = node.parent\n        depth = 0\n        while cur_parent is not None and depth < depth_limit:\n            gp = cur_parent.parent\n            if gp is None:\n                break\n            if not self._edge_blocked_memo(gp.position, node.position, obstacles, is_3d):\n                # update parent-child relations\n                cur_parent.remove_child(node)\n                self._edges_remove(edges, cur_parent, node)\n                gp.add_child(node)\n                edges.append((gp, node))\n                node.cost = gp.cost + self._dist(gp.position, node.position)\n                cur_parent = gp\n                depth += 1\n            else:\n                break\n\n    # Edges helpers\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node):\n        path_a = self._path_to_root(a_node)\n        path_b = []\n        cur = b_node\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _smooth_path(self, path, obstacles, is_3d, iters):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        no_improve = 0\n        last_len = self._path_length(pts)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d):\n                new_pts = pts[:i + 1] + pts[j:]\n                new_len = self._path_length(new_pts)\n                if new_len <= last_len:\n                    pts = new_pts\n                    last_len = new_len\n                    no_improve = 0\n                else:\n                    no_improve += 1\n            else:\n                no_improve += 1\n            if no_improve >= 8:\n                break\n        # Forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            k = 1\n            while k < len(pts) - 1:\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n                k += 1\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
          "objective": -26.1688,
          "time_improvement": 35.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1792.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027369928359985352,
                    "num_nodes_avg": 65.0,
                    "path_length_avg": 171.28307479198807,
                    "smoothness_avg": 0.05148806664012615,
                    "success_improvement": 0.0,
                    "time_improvement": -7.338122500577379,
                    "node_improvement": 83.63132712163183,
                    "length_improvement": 6.11703255250457,
                    "smoothness_improvement": 705.9000510442344,
                    "objective_score": 4.9982830365507
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04116971492767334,
                    "num_nodes_avg": 116.3,
                    "path_length_avg": 248.99030586642007,
                    "smoothness_avg": 0.12529040112374196,
                    "success_improvement": 0.0,
                    "time_improvement": 74.30062345562982,
                    "node_improvement": 92.18571524558222,
                    "length_improvement": 16.879869113207995,
                    "smoothness_improvement": 3123.8122639421595,
                    "objective_score": 48.037169824324536
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.030934453010559082,
                    "num_nodes_avg": 94.2,
                    "path_length_avg": 133.85366176833466,
                    "smoothness_avg": 0.12940331913875977,
                    "success_improvement": 0.0,
                    "time_improvement": 36.934929218056986,
                    "node_improvement": 88.02288620470438,
                    "length_improvement": 11.10077127990379,
                    "smoothness_improvement": 1546.0006678855698,
                    "objective_score": 25.470944872787218
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -25.748381214705063,
          "time_improvement": 87.0,
          "length_improvement": -1.0,
          "smoothness_improvement": 66.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0027012348175048826,
                    "num_nodes_avg": 63.9,
                    "path_length_avg": 172.25635822358078,
                    "smoothness_avg": 0.011148465868680943,
                    "success_improvement": 0.0,
                    "time_improvement": 89.40642189739663,
                    "node_improvement": 83.90833543188114,
                    "length_improvement": 5.5835604809856925,
                    "smoothness_improvement": 74.49770012597358,
                    "objective_score": 30.54455135844027
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.010209250450134277,
                    "num_nodes_avg": 240.4,
                    "path_length_avg": 302.26366463445993,
                    "smoothness_avg": 0.006453038743054631,
                    "success_improvement": 0.0,
                    "time_improvement": 93.62707825364559,
                    "node_improvement": 83.84734260565746,
                    "length_improvement": -0.9043114321748058,
                    "smoothness_improvement": 66.04133479473131,
                    "objective_score": 27.87574329076245
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010564541816711426,
                    "num_nodes_avg": 191.9,
                    "path_length_avg": 163.11362081791123,
                    "smoothness_avg": 0.012350799571145165,
                    "success_improvement": 0.0,
                    "time_improvement": 78.46240962391397,
                    "node_improvement": 75.60076287349014,
                    "length_improvement": -8.332300311300978,
                    "smoothness_improvement": 57.10125890377211,
                    "objective_score": 18.824848994912465
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -24.971436625701273,
          "time_improvement": 62.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 168.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009481477737426757,
                    "num_nodes_avg": 112.0,
                    "path_length_avg": 170.25136521926942,
                    "smoothness_avg": 0.017004537999713392,
                    "success_improvement": 0.0,
                    "time_improvement": 62.815977978432855,
                    "node_improvement": 71.7955175018887,
                    "length_improvement": 6.682528917796031,
                    "smoothness_improvement": 166.15794564080122,
                    "objective_score": 23.68510047241148
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0245816707611084,
                    "num_nodes_avg": 299.2,
                    "path_length_avg": 258.5973544494462,
                    "smoothness_avg": 0.010851066788952054,
                    "success_improvement": 0.0,
                    "time_improvement": 84.6553804394982,
                    "node_improvement": 79.89652623798965,
                    "length_improvement": 13.67275977263268,
                    "smoothness_improvement": 179.20576418723118,
                    "objective_score": 34.496298816365226
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.030178475379943847,
                    "num_nodes_avg": 287.8,
                    "path_length_avg": 139.5271231166937,
                    "smoothness_avg": 0.020290033291575655,
                    "success_improvement": 0.0,
                    "time_improvement": 38.47611641047452,
                    "node_improvement": 63.40750158931977,
                    "length_improvement": 7.332728393521491,
                    "smoothness_improvement": 158.08772581437248,
                    "objective_score": 16.732910588327112
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "STRIDE-BF-BiRRT: Score-Tempered, Proxy-Guided, Edge-Cached Best-First Bidirectional RRT. It grows two trees with small best-first beams scored f = g + w*h, where h is distance to a rotating proxy set from the opposite tree. It uses a hashed grid for approximate nearest search, progressive step shrinking for viable extensions, duplicate suppression, and bounded edge-collision memoization. After each insertion it tries a direct bridge and a short greedy connect; on success it returns a lightly shortcutted path for speed and smoothness.",
          "planning_mechanism": "Initialize start/goal roots, two hash-grids, and bounded free/blocked edge caches. Each iteration alternates trees, refreshes a small proxy set from the opposite tree, samples a few targets (goal/corridor/uniform), chooses the candidate with minimum f = (parent.g + \u0394g) + w*min_dist_to_proxies, and extends via progressive step shrinking. Only free nodes/edges are added. It then attempts a direct bridge and a brief guided connect. On first feasible connection it assembles and shortcuttens the path and returns.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=8.0,\n                 min_step=2.0,\n                 beam_k=3,\n                 goal_bias=0.3,\n                 corridor_bias=0.5,\n                 connect_steps=8,\n                 collision_res=1.0,\n                 grid_cell=None,\n                 dupe_radius_ratio=0.45,\n                 r_max=3,\n                 random_nn_samples=16,\n                 cache_capacity=80000,\n                 shortcut_iters=28,\n                 proxy_k=8,\n                 proxy_refresh=12,\n                 score_weight=1.0):\n        self.max_iter = max(1, int(max_iter))\n        self.step_size = float(step_size)\n        self.min_step = max(0.5, float(min_step))\n        self.beam_k = max(1, int(beam_k))\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.connect_steps = max(0, int(connect_steps))\n        self.collision_res = max(0.25, float(collision_res))\n        self.grid_cell = grid_cell\n        self.dupe_radius_ratio = max(0.1, float(dupe_radius_ratio))\n        self.r_max = max(1, int(r_max))\n        self.random_nn_samples = max(4, int(random_nn_samples))\n        self.cache_capacity = max(1000, int(cache_capacity))\n        self.shortcut_iters = max(0, int(shortcut_iters))\n        self.proxy_k = max(1, int(proxy_k))\n        self.proxy_refresh = max(1, int(proxy_refresh))\n        self.score_weight = max(0.5, float(score_weight))\n\n        self.dim = 2\n        self.bounds = None\n\n        self._lcg_state = 88172645463393265\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        start = self._as_tuple(map.start)\n        goal = self._as_tuple(map.goal)\n        obstacles = list(map.obstacles)\n        is_3d = (self.dim == 3)\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.cache_bin = max(0.5, min(self.collision_res, self.step_size * 0.5))\n\n        self._free_edges = {}\n        self._blocked_edges = {}\n        self._cache_keys = []\n\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        if self._is_edge_free_cached(start, goal, obstacles, is_3d):\n            n0 = Node(start, None, 0.0)\n            n1 = Node(goal, n0, self._dist(start, goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [start, goal], [n0, n1], [(n0, n1)])\n\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start, grid_goal = {}, {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        dsg = self._dist(start, goal)\n        corridor_w = max(self.step_size, 0.12 * dsg)\n        best_iter = -1\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = goal if active_start else start\n\n            if it % self.proxy_refresh == 0 or len(tree_b) <= self.proxy_k:\n                proxies = self._select_proxies(tree_b, self.proxy_k)\n            else:\n                proxies = self._select_proxies(tree_b, self.proxy_k)\n\n            winner = None\n            winner_parent = None\n            best_f = float('inf')\n\n            for _ in range(self.beam_k):\n                target = self._sample_biased(start, goal, corridor_w, obstacles, is_3d, root_other)\n                parent = self._nearest_hashed(grid_a, tree_a, target)\n                if parent is None:\n                    continue\n                new_pos = self._progressive_steer(parent.position, target, obstacles, is_3d)\n                if new_pos is None:\n                    continue\n                if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                g_new = parent.cost + self._dist(parent.position, new_pos)\n                h = self._min_dist_to_set(new_pos, proxies) if proxies else self._dist(new_pos, root_other)\n                f = g_new + self.score_weight * h\n                if f < best_f:\n                    best_f = f\n                    winner = new_pos\n                    winner_parent = parent\n\n            if winner is None:\n                continue\n\n            new_node = Node(winner, winner_parent, winner_parent.cost + self._dist(winner_parent.position, winner))\n            winner_parent.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((winner_parent, new_node))\n            self._grid_add(grid_a, new_node)\n\n            other_near = self._nearest_hashed(grid_b, tree_b, new_node.position)\n            if other_near is not None and self._is_edge_free_cached(new_node.position, other_near.position, obstacles, is_3d):\n                path = self._extract_path(new_node, other_near)\n                smooth = self._shortcut(path, obstacles, is_3d, self.shortcut_iters)\n                return PlannerResult(True, smooth, start_tree + goal_tree, edges)\n\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._progressive_steer(p.position, new_node.position, obstacles, is_3d)\n                if to_pos is None:\n                    break\n                if self._exists_close(grid_b, to_pos, self.step_size * self.dupe_radius_ratio):\n                    break\n                q = Node(to_pos, p, p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                edges.append((p, q))\n                self._grid_add(grid_b, q)\n\n                if self._is_edge_free_cached(q.position, new_node.position, obstacles, is_3d):\n                    path = self._extract_path(new_node, q)\n                    smooth = self._shortcut(path, obstacles, is_3d, self.shortcut_iters)\n                    return PlannerResult(True, smooth, start_tree + goal_tree, edges)\n\n                p = q\n                steps += 1\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _rand(self):\n        self._lcg_state = (6364136223846793005 * self._lcg_state + 1442695040888963407) % (1 << 61)\n        return (self._lcg_state & ((1 << 61) - 1)) / float(1 << 61)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _rand_int(self, a, b):\n        if b <= a:\n            return a\n        r = int(self._uniform(0.0, (b - a + 1)))\n        v = a + r\n        if v > b:\n            v = b\n        return v\n\n    def _as_tuple(self, p):\n        if isinstance(p, tuple):\n            return p\n        return tuple(p[i] for i in range(len(p)))\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    def _clamp(self, p):\n        return tuple(self._clamp_val(p[i], 0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / max(1e-9, d)\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _seg_aabb_overlap(self, a, b, obs, is_3d):\n        if is_3d:\n            x, y, z, w, h, d = obs\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            if maxx < x or minx > x + w or maxy < y or miny > y + h or maxz < z or minz > z + d:\n                return False\n            return True\n        else:\n            x, y, w, h = obs\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            if maxx < x or minx > x + w or maxy < y or miny > y + h:\n                return False\n            return True\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(max(1, d / max(1e-9, resolution)))\n        for obs in obstacles:\n            if not self._seg_aabb_overlap(a, b, obs, is_3d):\n                continue\n            for i in range(steps + 1):\n                t = i / float(steps)\n                p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n                if self._is_in_obstacle(p, obstacles, is_3d):\n                    return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _cache_put(self, key, free):\n        self._cache_keys.append(key)\n        if free:\n            self._free_edges[key] = True\n        else:\n            self._blocked_edges[key] = True\n        if len(self._cache_keys) > self.cache_capacity:\n            drop = int(max(1, self.cache_capacity * 0.1))\n            for _ in range(drop):\n                if not self._cache_keys:\n                    break\n                k = self._cache_keys.pop(0)\n                self._free_edges.pop(k, None)\n                self._blocked_edges.pop(k, None)\n\n    def _is_edge_free_cached(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        if key in self._blocked_edges:\n            return False\n        if key in self._free_edges:\n            return True\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_res)\n        if blocked:\n            self._cache_put(key, False)\n            return False\n        else:\n            self._cache_put(key, True)\n            return True\n\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, self.r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n                    found = True\n            if found:\n                return best\n        if len(tree) > 0:\n            trials = min(self.random_nn_samples, len(tree))\n            for _ in range(trials):\n                idx = self._rand_int(0, len(tree) - 1)\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                di = n.position[i] - pos[i]\n                s += di * di\n            if s <= r2:\n                return True\n        return False\n\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, start, goal, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_biased(self, start, goal, corridor_w, obstacles, is_3d, root_other):\n        r = self._rand()\n        if r < self.goal_bias:\n            return root_other\n        elif r < self.goal_bias + self.corridor_bias:\n            return self._sample_corridor(start, goal, corridor_w, obstacles, is_3d)\n        else:\n            return self._sample_free(obstacles, is_3d)\n\n    def _progressive_steer(self, from_pos, to_pos, obstacles, is_3d):\n        step = self.step_size\n        while step >= self.min_step:\n            cand = self._steer(from_pos, to_pos, step)\n            if not self._in_bounds(cand):\n                step *= 0.5\n                continue\n            if self._is_in_obstacle(cand, obstacles, is_3d):\n                step *= 0.5\n                continue\n            if not self._is_edge_free_cached(from_pos, cand, obstacles, is_3d):\n                step *= 0.5\n                continue\n            return cand\n        return None\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _shortcut(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = self._rand_int(0, n - 3)\n            j = self._rand_int(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            if self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_res):\n                continue\n            pts = pts[:i + 1] + pts[j:]\n        out = [pts[0]]\n        last = pts[0]\n        i = 1\n        while i < len(pts):\n            far = i\n            j = i\n            while j < len(pts) and not self._is_edge_in_obstacle(last, pts[j], obstacles, is_3d, self.collision_res):\n                far = j\n                j += 1\n            last = pts[far]\n            out.append(last)\n            i = far + 1\n        out[0] = path[0]\n        out[-1] = path[-1]\n        return out\n\n    def _min_dist_to_set(self, p, pts):\n        best = float('inf')\n        for q in pts:\n            d = self._dist(p, q)\n            if d < best:\n                best = d\n        return best\n\n    def _select_proxies(self, tree, k):\n        if not tree:\n            return []\n        out = []\n        n = len(tree)\n        if n <= k:\n            for node in tree:\n                out.append(node.position)\n            return out\n        stride = max(1, n // k)\n        idx = n - 1\n        cnt = 0\n        while idx >= 0 and cnt < k:\n            out.append(tree[idx].position)\n            idx -= stride\n            cnt += 1\n        return out",
          "objective": -22.67068,
          "time_improvement": 28.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1478.0,
          "node_improvement": 85.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01907973289489746,
                    "num_nodes_avg": 58.6,
                    "path_length_avg": 164.53758766363492,
                    "smoothness_avg": 0.04579305398539159,
                    "success_improvement": 0.0,
                    "time_improvement": 25.17398365773817,
                    "node_improvement": 85.24301183580961,
                    "length_improvement": 9.814340936638626,
                    "smoothness_improvement": 616.7607360797193,
                    "objective_score": 16.524603339703223
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06179916858673096,
                    "num_nodes_avg": 163.2,
                    "path_length_avg": 247.82573249877174,
                    "smoothness_avg": 0.09381710615283037,
                    "success_improvement": 0.0,
                    "time_improvement": 61.42309689465787,
                    "node_improvement": 89.03446885708526,
                    "length_improvement": 17.26863722371481,
                    "smoothness_improvement": 2313.9817150425365,
                    "objective_score": 40.35801997783892
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05005335807800293,
                    "num_nodes_avg": 150.1,
                    "path_length_avg": 139.95745090666273,
                    "smoothness_avg": 0.12600553281359275,
                    "success_improvement": 0.0,
                    "time_improvement": -2.042165380642809,
                    "node_improvement": 80.91544818817546,
                    "length_improvement": 7.046925165431393,
                    "smoothness_improvement": 1502.7810766279433,
                    "objective_score": 11.12941086820571
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "Algorithm description: SPARK-Lite BiRRT \u2014 Sparse, Pruned, Anytime, Reusable-knowledge Bi-directional RRT with hashed-near lookup, per-cell throttling, failed-bridge memoization, mild rewiring, and visibility pruning for fast, smooth, and short paths under a strict iteration budget.",
          "planning_mechanism": "Planning mechanism: Alternate growing two trees with goal/corridor/informed-biased samples. For each sample, steer once, validate node/edge, pick a low-cost parent from a bounded hashed-near set, insert if the cell is not saturated, and rewire a few neighbors. Attempt a cached, cost-ordered direct connect to the opposite tree while skipping known blocked cell-pairs. Maintain the incumbent path anytime and return an early, visibility-pruned and lightly-shortcutted solution or the incumbent on stall.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=8.0,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 rings_near=2,\n                 near_radius_factor=3.0,\n                 near_k=12,\n                 rewire_k=8,\n                 rewire_propagation_limit=200,\n                 goal_bias=0.25,\n                 corridor_bias=0.45,\n                 informed_bias=0.5,\n                 dupe_radius_ratio=0.6,\n                 cell_cap=8,\n                 connect_radius_factor=3.5,\n                 connect_k=8,\n                 smoothing_attempts=32,\n                 stall_limit=500,\n                 edge_cache_limit=30000,\n                 pair_cache_limit=20000):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.collision_step = float(collision_step)\n        self.grid_cell = grid_cell\n        self.rings_near = int(max(1, rings_near))\n        self.near_radius_factor = float(max(1.0, near_radius_factor))\n        self.near_k = int(max(4, near_k))\n        self.rewire_k = int(max(2, rewire_k))\n        self.rewire_propagation_limit = int(max(50, rewire_propagation_limit))\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.cell_cap = int(max(2, cell_cap))\n        self.connect_radius_factor = float(connect_radius_factor)\n        self.connect_k = int(max(2, connect_k))\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self.stall_limit = int(max(100, stall_limit))\n        self.edge_cache_limit = int(max(2000, edge_cache_limit))\n        self.pair_cache_limit = int(max(2000, pair_cache_limit))\n\n        self.bounds = None\n        self.dim = 2\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n        self.edge_cache = None\n        self.edge_stamp = 0\n        self.pair_cache = None\n        self.pair_stamp = 0\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.edge_res = max(0.5, min(self.collision_step, 0.5 * self.step_size))\n\n        self.edge_cache = {}\n        self.edge_stamp = 0\n        self.pair_cache = {}\n        self.pair_stamp = 0\n\n        # Early direct connection\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            edges = [(n0, n1)]\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], edges)\n\n        # Initialize\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n\n        dsg = self._dist(self.start, self.goal)\n        dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        near_radius = max(self.step_size, self.near_radius_factor * self.step_size)\n        connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n        corridor_base = max(self.step_size, 0.2 * dsg)\n\n        best_path = None\n        best_len = float('inf')\n        last_improve = 0\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            other_root = self.goal if active_start else self.start\n\n            # Sample\n            if best_path is not None and self._rand() < self.informed_bias:\n                x_rand = self._sample_informed(best_len, obstacles, is_3d)\n            else:\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = other_root\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = max(self.step_size, corridor_base + 0.1 * (best_len - dsg if best_path is not None else 0.0))\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n            nearest = self._nearest(grid1, tree1, x_rand)\n            if nearest is None:\n                continue\n\n            new_pos = self._steer(nearest.position, x_rand, self.step_size)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._exists_close(grid1, new_pos, dupe_radius):\n                continue\n\n            # Choose best parent from bounded near set\n            near_nodes = self._nearby(grid1, new_pos, near_radius, tree1)\n            if len(near_nodes) > self.near_k:\n                near_nodes = self._k_closest(near_nodes, new_pos, self.near_k)\n            if not near_nodes:\n                near_nodes = [nearest]\n\n            best_parent = None\n            best_cost = float('inf')\n            for p in near_nodes:\n                if self._edge_blocked_memo(p.position, new_pos, obstacles, is_3d):\n                    continue\n                cst = p.cost + self._dist(p.position, new_pos)\n                if cst < best_cost:\n                    best_cost = cst\n                    best_parent = p\n            if best_parent is None:\n                continue\n\n            # Final checks prior to insertion\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked_memo(best_parent.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Per-cell throttling\n            if not self._cell_accept(grid1, new_pos):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, best_parent, best_cost)\n            best_parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            self._grid_add(grid1, new_node)\n            edges.append((best_parent, new_node))\n\n            # Mild local rewiring\n            if near_nodes:\n                if len(near_nodes) > self.rewire_k:\n                    near_nodes = self._k_closest(near_nodes, new_node.position, self.rewire_k)\n                for nb in near_nodes:\n                    if nb is new_node:\n                        continue\n                    if self._edge_blocked_memo(new_node.position, nb.position, obstacles, is_3d):\n                        continue\n                    alt = new_node.cost + self._dist(new_node.position, nb.position)\n                    if alt + 1e-12 < nb.cost:\n                        # avoid cycle\n                        cyc = False\n                        anc = new_node\n                        while anc is not None:\n                            if anc is nb:\n                                cyc = True\n                                break\n                            anc = anc.parent\n                        if cyc:\n                            continue\n                        old_parent = nb.parent\n                        if old_parent is not None:\n                            # remove edge old_parent->nb\n                            self._remove_edge(edges, old_parent, nb)\n                            try:\n                                old_parent.children.remove(nb)\n                            except:\n                                pass\n                        new_node.add_child(nb)\n                        edges.append((new_node, nb))\n                        delta = alt - nb.cost\n                        nb.cost = alt\n                        self._propagate_cost_delta(nb, delta, self.rewire_propagation_limit)\n\n            # Try connecting to the opposite tree (direct only, with failed-pair memo)\n            other_near = self._nearby(grid2, new_node.position, connect_radius, tree2)\n            if len(other_near) > self.connect_k:\n                other_near = self._k_closest(other_near, new_node.position, self.connect_k)\n\n            ranked = []\n            for q in other_near:\n                est = new_node.cost + self._dist(new_node.position, q.position) + q.cost\n                ranked.append((est, q))\n            ranked.sort(key=lambda x: x[0])\n\n            connected = False\n            a_end = None\n            b_end = None\n            for _, q in ranked:\n                pair_key = self._pair_key_cells(new_node.position, q.position)\n                if pair_key in self.pair_cache:\n                    continue\n                if not self._edge_blocked_memo(new_node.position, q.position, obstacles, is_3d):\n                    connected = True\n                    a_end = new_node\n                    b_end = q\n                    break\n                else:\n                    self._mark_pair_failed(pair_key)\n\n            if connected:\n                if active_start:\n                    path = self._merge_paths(a_end, b_end)\n                else:\n                    path = self._merge_paths(b_end, a_end)\n                # Anytime track\n                plen = self._path_length(path)\n                if plen < best_len:\n                    best_path = path\n                    best_len = plen\n                    last_improve = it\n\n                final_path = self._finalize_path(best_path, obstacles, is_3d)\n                return PlannerResult(True, final_path, nodes, edges)\n\n            # Stall guard: return incumbent if no improvement for a while\n            if best_path is not None and (it - last_improve) >= self.stall_limit:\n                final_path = self._finalize_path(best_path, obstacles, is_3d)\n                return PlannerResult(True, final_path, nodes, edges)\n\n        # End iterations\n        if best_path is not None:\n            final_path = self._finalize_path(best_path, obstacles, is_3d)\n            return PlannerResult(True, final_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG (deterministic)\n    def _rand(self):\n        if not hasattr(self, \"_rng\"):\n            self._rng = 2463534242\n        self._rng = (1664525 * self._rng + 1013904223) % (1 << 32)\n        return self._rng / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp_tuple(b)\n        if d <= 1e-12:\n            return self._clamp_tuple(a)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_exact(self, a, b):\n        if a <= b:\n            return (a, b)\n        else:\n            return (b, a)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_exact(a, b)\n        st = self.edge_cache.get(key)\n        if st is not None:\n            return st[0] == 1\n        blocked = self._edge_blocked(a, b, obstacles, is_3d)\n        self.edge_stamp += 1\n        self.edge_cache[key] = (1 if blocked else 2, self.edge_stamp)\n        if len(self.edge_cache) > self.edge_cache_limit:\n            cutoff = self.edge_stamp - (self.edge_cache_limit // 2)\n            self.edge_cache = {k: v for k, v in self.edge_cache.items() if v[1] >= cutoff}\n        return blocked\n\n    # Pair memo (failed direct bridges between cell pairs)\n    def _pair_key_cells(self, a, b):\n        ka = self._grid_key(a)\n        kb = self._grid_key(b)\n        if ka <= kb:\n            return (ka, kb)\n        else:\n            return (kb, ka)\n\n    def _mark_pair_failed(self, key):\n        self.pair_stamp += 1\n        self.pair_cache[key] = self.pair_stamp\n        if len(self.pair_cache) > self.pair_cache_limit:\n            cutoff = self.pair_stamp - (self.pair_cache_limit // 2)\n            self.pair_cache = {k: v for k, v in self.pair_cache.items() if v[1] >= cutoff}\n\n    # Spatial hashing\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.rings_near + 1):\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback small random subset\n        if tree:\n            k = min(16, len(tree))\n            for i in range(k):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx % len(tree)]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _nearby(self, grid, pos, radius, fallback_tree):\n        key = self._grid_key(pos)\n        r_cells = int(radius // self.grid_cell) + 1\n        cand = self._ring_collect(grid, key, r_cells)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n        if out:\n            return out\n        # fallback random subset\n        if fallback_tree:\n            k = min(16, len(fallback_tree))\n            sel = []\n            for _ in range(k):\n                idx = int(self._uniform(0, len(fallback_tree)))\n                sel.append(fallback_tree[idx % len(fallback_tree)])\n            return sel\n        return []\n\n    def _k_closest(self, nodes, pos, k):\n        if len(nodes) <= k:\n            return list(nodes)\n        best = []\n        bestd = []\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if len(best) < k:\n                best.append(n)\n                bestd.append(d)\n            else:\n                wi = 0\n                wv = bestd[0]\n                for i in range(1, k):\n                    if bestd[i] > wv:\n                        wi = i\n                        wv = bestd[i]\n                if d < wv:\n                    best[wi] = n\n                    bestd[wi] = d\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius // self.grid_cell) + 1\n        cand = self._ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    def _cell_accept(self, grid, pos):\n        key = self._grid_key(pos)\n        lst = grid.get(key)\n        if lst is None:\n            return True\n        return len(lst) < self.cell_cap\n\n    def _remove_edge(self, edges, a, b):\n        for i in range(len(edges)):\n            if edges[i][0] is a and edges[i][1] is b:\n                edges.pop(i)\n                return\n\n    def _propagate_cost_delta(self, root, delta, limit):\n        if abs(delta) <= 0.0:\n            return\n        q = [root]\n        cnt = 0\n        while q and cnt < limit:\n            cur = q.pop(0)\n            for ch in cur.children:\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                q.append(ch)\n                cnt += 1\n                if cnt >= limit:\n                    break\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        for _ in range(64):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # fallback center\n        if self.dim == 3:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5, self.bounds[2] * 0.5)\n        else:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5)\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        tries = 0\n        while tries < 24:\n            if self.dim == 3:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                else:\n                    tries += 1\n                    continue\n            else:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                else:\n                    tries += 1\n                    continue\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n            tries += 1\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        # rejection sample inside ellipse: dist(start,p)+dist(p,goal) <= best_len\n        for _ in range(48):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if (self._dist(self.start, p) + self._dist(p, self.goal) <= best_len + 1e-9 and\n                not self._is_in_obstacle(p, obstacles, is_3d)):\n                return p\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)\n\n    # Path operations\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_paths(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        pb.reverse()\n        return pa + pb\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _visibility_prune(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return list(path)\n        pruned = [path[0]]\n        last = 0\n        i = 1\n        while i < len(path) - 1:\n            if not self._edge_blocked_memo(pruned[-1], path[i + 1], obstacles, is_3d):\n                i += 1\n            else:\n                pruned.append(path[i])\n                last = i\n                i += 1\n        pruned.append(path[-1])\n        return pruned\n\n    def _smooth_path(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return list(path)\n        pts = list(path)\n        best_len = self._path_length(pts)\n        n = len(pts)\n        tries = 0\n        no_gain = 0\n        while tries < attempts and n >= 3 and no_gain < 10:\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked_memo(a, b, obstacles, is_3d):\n                new_pts = pts[:i + 1] + pts[j:]\n                new_len = self._path_length(new_pts)\n                if new_len + 1e-9 < best_len:\n                    pts = new_pts\n                    best_len = new_len\n                    n = len(pts)\n                    no_gain = 0\n                else:\n                    no_gain += 1\n            else:\n                no_gain += 1\n            tries += 1\n        return pts\n\n    def _finalize_path(self, path, obstacles, is_3d):\n        if not path:\n            return []\n        pruned = self._visibility_prune(path, obstacles, is_3d)\n        return self._smooth_path(pruned, obstacles, is_3d, self.smoothing_attempts)",
          "objective": -22.03956,
          "time_improvement": 21.0,
          "length_improvement": 14.0,
          "smoothness_improvement": 1480.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02542092800140381,
                    "num_nodes_avg": 45.3,
                    "path_length_avg": 162.80226068820116,
                    "smoothness_avg": 0.047769835700344265,
                    "success_improvement": 0.0,
                    "time_improvement": 0.3053772006840517,
                    "node_improvement": 88.59229413246034,
                    "length_improvement": 10.765501149889475,
                    "smoothness_improvement": 647.701662568929,
                    "objective_score": 9.789422162983547
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07012510299682617,
                    "num_nodes_avg": 97.9,
                    "path_length_avg": 239.9048150152527,
                    "smoothness_avg": 0.09668084892214279,
                    "success_improvement": 0.0,
                    "time_improvement": 56.22579776677542,
                    "node_improvement": 93.4220251293422,
                    "length_improvement": 19.912867470681928,
                    "smoothness_improvement": 2387.667879167488,
                    "objective_score": 40.753799208279226
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04657967090606689,
                    "num_nodes_avg": 67.0,
                    "path_length_avg": 132.90021104573253,
                    "smoothness_avg": 0.11829008475952485,
                    "success_improvement": 0.0,
                    "time_improvement": 5.039528525426824,
                    "node_improvement": 91.48124602670057,
                    "length_improvement": 11.73400785141161,
                    "smoothness_improvement": 1404.6411468753356,
                    "objective_score": 15.57546900285169
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "H-Guide BRIDGE: Heuristic-Guided Bidirectional RRT with Cached Collision and Ancestor Compression \u2014 a fast bi-tree planner that expands via a small heuristic-scored beam per side, prunes by f = g + w\u00b7h and per-cell best-cost gates, suppresses near-duplicates, and inserts only fully validated nodes. Each insertion performs multi-ancestor line-of-sight compression to shorten chains and costs. Edges use memoized collision checks. Bridging tests connect to a few nearest nodes in the opposite tree; on success, bounded shortcutting plus forward/backward LOS collapse produce a short, smooth path.",
          "planning_mechanism": "Alternate sides each iteration. Generate a small beam of samples (goal/corridor/uniform; ellipse after incumbent). For each, find a near node via a hash grid, steer once, reject out-of-bounds/colliding/duplicate, gate by cell best g-cost and incumbent f-prune, then score candidates by f = g + w\u00b7h + \u03b1\u00b7bridge-hint. Insert the best candidate only after both node and edge checks; compress to an earliest visible ancestor before finalizing. Attempt direct bridges to a few nearest nodes from the opposite tree using the collision cache. If bridged, extract and shortcut with cache-backed tests and LOS collapses; otherwise continue up to the iteration budget.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.edge_index = -1\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=10.0,\n                 collision_step=1.0,\n                 beam_k=3,\n                 goal_bias=0.18,\n                 corridor_bias=0.55,\n                 informed_bias=0.65,\n                 grid_cell_factor=0.9,\n                 cell_cost_relax=1.08,\n                 dupe_radius_ratio=0.6,\n                 parent_search_rings=2,\n                 max_rings=3,\n                 connect_k=4,\n                 connect_radius_factor=3.5,\n                 smoothing_attempts=50,\n                 prune_margin=1.02):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_step = collision_step\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.cell_cost_relax = cell_cost_relax\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.parent_search_rings = parent_search_rings\n        self.max_rings = max_rings\n        self.connect_k = max(1, int(connect_k))\n        self.connect_radius_factor = connect_radius_factor\n        self.smoothing_attempts = smoothing_attempts\n        self.prune_margin = prune_margin\n\n        # runtime\n        self.bounds = None\n        self.dim = 2\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self.inv_cache_bin = 1.0\n        self.edge_cache = None\n        self.cell_size = 1.0\n        self.dupe_radius = 1.0\n        self.start = None\n        self.goal = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # discretizations and caches\n        self.edge_res = max(0.75, min(self.collision_step, self.step_size * 0.5))\n        self.cache_bin = max(0.5, 0.5 * self.edge_res)\n        self.inv_cache_bin = 1.0 / self.cache_bin\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.edge_cache = {}\n\n        # quick validations\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n        # trivial straight line\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes = [n0, n1]\n            edges = [(n0, n1)]\n            n1.edge_index = 0\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # initialize trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]  # from start\n        tree_b = [goal_root]   # from goal\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n\n        # per-cell best costs (g gates)\n        best_cost_a, best_cost_b = {}, {}\n\n        best_path_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        base_corridor_w = max(self.step_size, 0.2 * d_sg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            bestcell1 = best_cost_a if active_start else best_cost_b\n            other_root = self.goal if active_start else self.start\n\n            best_cand = None  # (parent, new_pos, new_cost, fscore, other_near)\n\n            for _ in range(self.beam_k):\n                # guided sampling\n                r = self._rand()\n                if best_path_len < float('inf') and r < self.informed_bias:\n                    x_rand = self._sample_informed(best_path_len, obstacles, is_3d)\n                else:\n                    r2 = self._rand()\n                    if r2 < self.goal_bias:\n                        x_rand = other_root\n                    elif r2 < self.goal_bias + self.corridor_bias:\n                        slack = 0.0 if best_path_len == float('inf') else max(0.0, best_path_len - d_sg)\n                        width = max(self.step_size, base_corridor_w + 0.15 * slack)\n                        x_rand = self._sample_corridor(width, obstacles, is_3d)\n                    else:\n                        x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest(grid1, tree1, x_rand)\n                if nearest is None:\n                    continue\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n\n                # bounds and node-collision check\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                # duplicate suppression\n                if self._exists_close(grid1, new_pos, self.dupe_radius):\n                    continue\n\n                # choose parent among nearby LOS-feasible nodes\n                parent = self._choose_parent(nearest, grid1, new_pos, obstacles, is_3d)\n                if parent is None:\n                    continue\n\n                # edge collision (both checks enforced before insertion)\n                if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # cell cost gate\n                new_cost = parent.cost + self._dist(parent.position, new_pos)\n                kcell = self._grid_key(new_pos)\n                prev_best = bestcell1.get(kcell, float('inf'))\n                if new_cost > prev_best * self.cell_cost_relax:\n                    continue\n\n                # heuristic prune against incumbent best\n                if best_path_len < float('inf'):\n                    est_total = new_cost + self._dist(new_pos, other_root)\n                    if est_total >= best_path_len * self.prune_margin:\n                        continue\n\n                # score by f = g + w*h + alpha*bridge\n                other_near = self._nearest(grid2, tree2, new_pos)\n                bridge_hint = self._dist(new_pos, other_near.position) if other_near is not None else self._dist(new_pos, other_root)\n                w_h = 0.9\n                alpha = 0.4\n                fscore = new_cost + w_h * self._dist(new_pos, other_root) + alpha * bridge_hint\n\n                if best_cand is None or fscore < best_cand[3]:\n                    best_cand = (parent, new_pos, new_cost, fscore, other_near)\n\n            if best_cand is None:\n                continue\n\n            parent, new_pos, new_cost, _fs, hint_other = best_cand\n\n            # Final insertion checks (both) before commit\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Multi-ancestor LOS compression (before finalizing)\n            ancestor = parent\n            while ancestor is not None and ancestor.parent is not None:\n                gp = ancestor.parent\n                if not self._edge_blocked_memo(gp.position, new_pos, obstacles, is_3d):\n                    ancestor = gp\n                else:\n                    break\n            if ancestor is not parent:\n                parent = ancestor\n                new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n            # Insert node coherently\n            new_node = Node(new_pos, parent, new_cost)\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            self._grid_add(grid1, new_node)\n            edges.append((parent, new_node))\n            new_node.edge_index = len(edges) - 1\n\n            # update per-cell best g\n            kc = self._grid_key(new_pos)\n            prev = bestcell1.get(kc, float('inf'))\n            if new_cost < prev:\n                bestcell1[kc] = new_cost\n\n            # Attempt direct bridges to a few nearest from other tree\n            connect_radius = self.connect_radius_factor * self.step_size\n            cand2 = self._nearby(grid2, new_node.position, connect_radius, tree2)\n            # pick up to connect_k nearest\n            if len(cand2) > self.connect_k:\n                cand2 = self._k_nearest(cand2, new_node.position, self.connect_k)\n            connected = None\n            for q in cand2:\n                if not self._edge_blocked_memo(new_node.position, q.position, obstacles, is_3d):\n                    connected = q\n                    break\n\n            if connected is not None:\n                # Build full path\n                path = self._merge_paths(new_node, connected, a_from_start=active_start)\n                best_path_len = self._path_length(path)\n                path = self._smooth_path(path, obstacles, is_3d, self.smoothing_attempts)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        if not hasattr(self, \"_rng\"):\n            self._rng = 2862933555777941757 % (1 << 32)\n        self._rng = (1664525 * self._rng + 1013904223) % (1 << 32)\n        return self._rng / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp_tuple(b)\n        if d <= 1e-12:\n            return self._clamp_tuple(a)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] * self.inv_cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] * self.inv_cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        st = self.edge_cache.get(key)\n        if st is not None:\n            return st == 1\n        blocked = self._edge_blocked(a, b, obstacles, is_3d)\n        self.edge_cache[key] = 1 if blocked else 2\n        if len(self.edge_cache) > 20000:\n            self.edge_cache.clear()\n        return blocked\n\n    # Grid hashing\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.max_rings + 1):\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback full scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _nearby(self, grid, pos, radius, fallback_tree):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.cell_size) + 1\n        cand = self._ring_collect(grid, key, r_cells)\n        if not cand:\n            return list(fallback_tree)\n        # filter by true distance\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n        if not out:\n            return list(fallback_tree)\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.cell_size) + 1\n        cand = self._ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    def _k_nearest(self, nodes, pos, k):\n        if len(nodes) <= k:\n            return list(nodes)\n        best = []\n        bestd = []\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if len(best) < k:\n                best.append(n)\n                bestd.append(d)\n            else:\n                wi = 0\n                wv = bestd[0]\n                for i in range(1, k):\n                    if bestd[i] > wv:\n                        wi = i\n                        wv = bestd[i]\n                if d < wv:\n                    best[wi] = n\n                    bestd[wi] = d\n        return best\n\n    # Parent selection with local neighborhood\n    def _nearby_candidates(self, grid, pos, rings):\n        key = self._grid_key(pos)\n        cand = []\n        for r in range(0, rings + 1):\n            cand.extend(self._ring_collect(grid, key, r))\n        return cand\n\n    def _choose_parent(self, nearest, grid, new_pos, obstacles, is_3d):\n        best_parent = nearest\n        best_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        candidates = self._nearby_candidates(grid, new_pos, self.parent_search_rings)\n        if not candidates:\n            candidates = [nearest]\n        for cand in candidates:\n            if cand is None:\n                continue\n            if not self._edge_blocked_memo(cand.position, new_pos, obstacles, is_3d):\n                c = cand.cost + self._dist(cand.position, new_pos)\n                if c + 1e-12 < best_cost:\n                    best_cost = c\n                    best_parent = cand\n        return best_parent\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        # rejection until free\n        for _ in range(80):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # fallback to center\n        if self.dim == 3:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5, self.bounds[2] * 0.5)\n        else:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5)\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        tries = 0\n        while tries < 25:\n            if self.dim == 3:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                else:\n                    tries += 1\n                    continue\n            else:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                else:\n                    tries += 1\n                    continue\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n            tries += 1\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        # rejection inside prolate ellipse sum of distances <= best_len\n        for _ in range(60):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if (self._dist(p, self.start) + self._dist(p, self.goal) <= best_len and\n                not self._is_in_obstacle(p, obstacles, is_3d)):\n                return p\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_paths(self, a_node, b_node, a_from_start=True):\n        # a_node from active tree; b_node from other tree\n        path_a = self._path_to_root(a_node)  # root_a -> a\n        path_b = self._path_to_root(b_node)  # root_b -> b\n        if a_from_start:\n            # start->a + b->...->goal\n            path_b.reverse()\n            return path_a + path_b\n        else:\n            # goal->a + b->...->start, need start->... order\n            path_a.reverse()\n            return path_b + path_a\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _smooth_path(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and n >= 3:\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if not self._edge_blocked_memo(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n            tries += 1\n        # forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            anchor = pts[0]\n            for k in range(1, len(pts) - 1):\n                nxt = pts[k + 1]\n                if self._edge_blocked_memo(anchor, nxt, obstacles, is_3d):\n                    collapsed.append(pts[k])\n                    anchor = pts[k]\n            collapsed.append(pts[-1])\n            pts = collapsed\n        # backward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[-1]]\n            anchor = pts[-1]\n            for k in range(len(pts) - 2, 0, -1):\n                prv = pts[k - 1]\n                if self._edge_blocked_memo(prv, anchor, obstacles, is_3d):\n                    collapsed.append(pts[k])\n                    anchor = pts[k]\n            collapsed.append(pts[0])\n            collapsed.reverse()\n            pts = collapsed\n        return pts",
          "objective": -21.51517,
          "time_improvement": 25.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 1655.0,
          "node_improvement": 93.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022861647605895995,
                    "num_nodes_avg": 34.3,
                    "path_length_avg": 172.98417420446884,
                    "smoothness_avg": 0.050964381866497654,
                    "success_improvement": 0.0,
                    "time_improvement": 10.342244999284711,
                    "node_improvement": 91.36237723495341,
                    "length_improvement": 5.184633008878697,
                    "smoothness_improvement": 697.7032471372609,
                    "objective_score": 9.701969540798936
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05142920017242432,
                    "num_nodes_avg": 64.7,
                    "path_length_avg": 244.6282302185181,
                    "smoothness_avg": 0.09836654462599766,
                    "success_improvement": 0.0,
                    "time_improvement": 67.89634363684883,
                    "node_improvement": 95.65275818047436,
                    "length_improvement": 18.336055519863592,
                    "smoothness_improvement": 2431.0420437852126,
                    "objective_score": 43.52574662189887
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.051129722595214845,
                    "num_nodes_avg": 61.7,
                    "path_length_avg": 142.0101289168521,
                    "smoothness_avg": 0.1521797267134412,
                    "success_improvement": 0.0,
                    "time_improvement": -4.236514976608545,
                    "node_improvement": 92.15511760966307,
                    "length_improvement": 5.683634169086715,
                    "smoothness_improvement": 1835.7148910559886,
                    "objective_score": 11.317800463749409
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "BLAZE-Bridge: Budget-Limited Accelerated Zonal Expansion BiRRT with memoized collision checks, hashed-nearest search, per-cell growth caps, duplicate suppression, blocked-bridge memory, shallow ancestor compression, and early-return smoothing. It targets fast, stable planning with short, smooth paths by pruning redundant expansions and avoiding repeated futile connections.",
          "planning_mechanism": "Alternate tree growth with a tiny beam of candidates per side. For each sample (goal/corridor/uniform; informed after a provisional path), select the nearest by a grid hash, steer once, validate point and edge (both required) using cached collision checks, throttle per-cell growth and near-duplicates, then insert and optionally compress to an ancestor. Attempt a direct line-of-sight bridge to the opposite tree\u2019s nearest unless the cell-pair is known blocked; on success, immediately shortcut-smooth and return. Fixed iteration budget, lightweight structures, and caching keep per-iteration costs low and runtime stable.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=8.0,\n                 beam_k=2,\n                 goal_bias=0.20,\n                 corridor_bias=0.45,\n                 informed_bias=0.60,\n                 grid_cell_factor=1.3,\n                 ring_limit=3,\n                 dup_radius_ratio=0.45,\n                 min_sep_ratio=0.30,\n                 cell_expand_limit=3,\n                 connect_range_factor=2.0,\n                 smoothing_iters=48,\n                 edge_cache_max=30000,\n                 point_cache_max=40000,\n                 blocked_bridge_max=12000):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.ring_limit = ring_limit\n        self.dup_radius_ratio = dup_radius_ratio\n        self.min_sep_ratio = min_sep_ratio\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.connect_range_factor = connect_range_factor\n        self.smoothing_iters = smoothing_iters\n        self.edge_cache_max = max(1000, int(edge_cache_max))\n        self.point_cache_max = max(1000, int(point_cache_max))\n        self.blocked_bridge_max = max(1000, int(blocked_bridge_max))\n\n        self.dim = 2\n        self.bounds = None\n        self.is_3d = False\n        self.cell = 1.0\n        self.edge_res = 1.0\n        self.q_edge = 1.0\n        self.q_point = 0.5\n\n        self._edge_cache = {}\n        self._point_cache = {}\n        self._blocked_bridges = set()\n        self._rng_state = 2463534242\n\n        self.start = None\n        self.goal = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n\n        nodes = []\n        edges = []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # resolution and caching quantization tied to step\n        self.edge_res = max(0.6, min(self.step_size * 0.5, 1.0))\n        self.q_edge = max(1.0, self.edge_res)\n        self.q_point = max(0.5, self.edge_res * 0.5)\n        self.cell = max(1.0, self.step_size * self.grid_cell_factor)\n\n        # reset caches\n        self._edge_cache = {}\n        self._point_cache = {}\n        self._blocked_bridges = set()\n\n        # start/goal validity\n        if not self._point_free(self.start, obstacles) or not self._point_free(self.goal, obstacles):\n            return PlannerResult(False, [], nodes, edges)\n\n        # early straight connection\n        if self._edge_free(self.start, self.goal, obstacles):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            nodes.extend([n0, n1])\n            edges.append((n0, n1))\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n        throttle_a = {}\n        throttle_b = {}\n\n        d_sg = self._dist(self.start, self.goal)\n        base_corridor_w = max(self.step_size, 0.2 * d_sg)\n        best_path_len = float('inf')\n\n        connect_range = max(self.step_size, self.step_size * self.connect_range_factor)\n        dup_radius = max(0.5, self.step_size * self.dup_radius_ratio)\n        min_sep = max(0.25, self.step_size * self.min_sep_ratio)\n\n        for it in range(self.max_iter):\n            grow_from_start = (it % 2 == 0)\n            tree1 = tree_a if grow_from_start else tree_b\n            tree2 = tree_b if grow_from_start else tree_a\n            grid1 = grid_a if grow_from_start else grid_b\n            grid2 = grid_b if grow_from_start else grid_a\n            throttles1 = throttle_a if grow_from_start else throttle_b\n            throttles2 = throttle_b if grow_from_start else throttle_a\n            other_root = self.goal if grow_from_start else self.start\n\n            best_parent = None\n            best_new_pos = None\n            best_score = float('inf')\n\n            for _ in range(self.beam_k):\n                x_rand = None\n                if best_path_len < float('inf') and self._rand() < self.informed_bias:\n                    x_rand = self._sample_informed(best_path_len, obstacles)\n                else:\n                    r = self._rand()\n                    if r < self.goal_bias:\n                        x_rand = other_root\n                    elif r < self.goal_bias + self.corridor_bias:\n                        width = base_corridor_w\n                        if best_path_len < float('inf'):\n                            slack = max(0.0, best_path_len - d_sg)\n                            width = max(self.step_size, 0.2 * slack + base_corridor_w)\n                        x_rand = self._sample_corridor(width, obstacles)\n                    else:\n                        x_rand = self._sample_free(obstacles)\n\n                near = self._nearest_by_grid(tree1, grid1, x_rand)\n                if near is None:\n                    continue\n\n                x_new = self._steer(near.position, x_rand, self.step_size)\n                if not self._in_bounds(x_new):\n                    continue\n                if self._dist(near.position, x_new) < min_sep:\n                    continue\n                if not self._point_free(x_new, obstacles):\n                    continue\n                if self._has_near_duplicate(grid1, x_new, dup_radius):\n                    continue\n                kcell = self._grid_key(x_new)\n                if throttles1.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n                if not self._edge_free(near.position, x_new, obstacles):\n                    continue\n\n                other_near = self._nearest_by_grid(tree2, grid2, x_new)\n                to_other = self._dist(x_new, other_near.position) if other_near is not None else self._dist(x_new, other_root)\n                cost_term = (near.cost + self._dist(near.position, x_new)) * 0.05\n                score = to_other + cost_term\n                if score < best_score:\n                    best_score = score\n                    best_parent = near\n                    best_new_pos = x_new\n\n            if best_parent is None:\n                continue\n\n            if not self._point_free(best_new_pos, obstacles):\n                continue\n            if not self._edge_free(best_parent.position, best_new_pos, obstacles):\n                continue\n\n            new_cost = best_parent.cost + self._dist(best_parent.position, best_new_pos)\n            new_node = Node(best_new_pos, best_parent, new_cost)\n            best_parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            self._grid_insert(grid1, new_node)\n            kc = self._grid_key(best_new_pos)\n            throttles1[kc] = throttles1.get(kc, 0) + 1\n\n            self._compress_one_ancestor(new_node, obstacles, edges)\n\n            other_near = self._nearest_by_grid(tree2, grid2, new_node.position)\n            if other_near is not None:\n                if self._dist(new_node.position, other_near.position) <= connect_range:\n                    pkey = self._pair_key(self._grid_key(new_node.position), self._grid_key(other_near.position))\n                    if pkey not in self._blocked_bridges:\n                        if self._edge_free(new_node.position, other_near.position, obstacles):\n                            path = self._extract_path(new_node, other_near)\n                            best_path_len = self._path_length(path)\n                            path = self._smooth_path(path, obstacles, self.smoothing_iters)\n                            return PlannerResult(True, path, nodes, edges)\n                        else:\n                            self._blocked_add(pkey)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        self._rng_state = (1664525 * self._rng_state + 1013904223) % (1 << 32)\n        return self._rng_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp_tuple(b)\n        if d <= 1e-12:\n            return self._clamp_tuple(a)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    # Collision and caching\n    def _qpos(self, p, q):\n        return tuple(int(p[i] // q) for i in range(self.dim))\n\n    def _edge_key(self, a, b, q):\n        qa = self._qpos(a, q)\n        qb = self._qpos(b, q)\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _point_key(self, p, q):\n        return self._qpos(p, q)\n\n    def _point_free(self, p, obstacles):\n        key = self._point_key(p, self.q_point)\n        cached = self._point_cache.get(key)\n        if cached is not None:\n            return cached\n        free = True\n        if self.is_3d:\n            px, py, pz = p\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    free = False\n                    break\n        else:\n            px, py = p\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    free = False\n                    break\n        self._point_cache[key] = free\n        if len(self._point_cache) > self.point_cache_max:\n            self._prune_half(self._point_cache)\n        return free\n\n    def _edge_free(self, a, b, obstacles):\n        key = self._edge_key(a, b, self.q_edge)\n        cached = self._edge_cache.get(key)\n        if cached is not None:\n            return cached\n        d = self._dist(a, b)\n        steps = int(d / self.edge_res)\n        if steps < 1:\n            steps = 1\n        free = True\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if not self._point_free(p, obstacles):\n                free = False\n                break\n        self._edge_cache[key] = free\n        if len(self._edge_cache) > self.edge_cache_max:\n            self._prune_half(self._edge_cache)\n        return free\n\n    def _prune_half(self, dct):\n        # remove roughly half of items deterministically\n        cnt = 0\n        to_del = []\n        for k in dct:\n            if (cnt % 2) == 0:\n                to_del.append(k)\n            cnt += 1\n            if len(to_del) >= len(dct) // 2:\n                break\n        for k in to_del:\n            try:\n                del dct[k]\n            except:\n                pass\n\n    # Blocked bridge memory\n    def _pair_key(self, ka, kb):\n        return (ka, kb) if ka <= kb else (kb, ka)\n\n    def _blocked_add(self, key):\n        self._blocked_bridges.add(key)\n        if len(self._blocked_bridges) > self.blocked_bridge_max:\n            # prune half\n            cnt = 0\n            to_del = []\n            for k in self._blocked_bridges:\n                if (cnt % 2) == 0:\n                    to_del.append(k)\n                cnt += 1\n                if len(to_del) >= len(self._blocked_bridges) // 2:\n                    break\n            for k in to_del:\n                try:\n                    self._blocked_bridges.remove(k)\n                except:\n                    pass\n\n    # Spatial hash\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell) for i in range(self.dim))\n\n    def _grid_insert(self, grid, node):\n        k = self._grid_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _nearest_by_grid(self, tree, grid, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        if self.dim == 3:\n            for r in range(self.ring_limit + 1):\n                found = False\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        for dz in range(-r, r + 1):\n                            b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                            if b:\n                                for n in b:\n                                    d = self._dist(n.position, pos)\n                                    if d < bestd:\n                                        bestd = d\n                                        best = n\n                                        found = True\n                if found and best is not None:\n                    return best\n        else:\n            for r in range(self.ring_limit + 1):\n                found = False\n                for dx in range(-r, r + 1):\n                    for dy in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy))\n                        if b:\n                            for n in b:\n                                d = self._dist(n.position, pos)\n                                if d < bestd:\n                                    bestd = d\n                                    best = n\n                                    found = True\n                if found and best is not None:\n                    return best\n        # fallback\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _has_near_duplicate(self, grid, pos, radius):\n        rng = int(max(1, radius // self.cell)) + 1\n        key = self._grid_key(pos)\n        r2 = radius * radius\n        if self.dim == 3:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if not b:\n                            continue\n                        for n in b:\n                            s = 0.0\n                            for i in range(self.dim):\n                                d = n.position[i] - pos[i]\n                                s += d * d\n                            if s <= r2:\n                                return True\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if not b:\n                        continue\n                    for n in b:\n                        s = 0.0\n                        for i in range(self.dim):\n                            d = n.position[i] - pos[i]\n                            s += d * d\n                        if s <= r2:\n                            return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles):\n        for _ in range(64):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._in_bounds(p) and self._point_free(p, obstacles):\n                return p\n        return self._clamp_tuple(self.start)\n\n    def _sample_corridor(self, width, obstacles):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        tries = 12\n        if self.dim == 3:\n            for _ in range(tries):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if self._point_free(p, obstacles):\n                        return p\n        else:\n            for _ in range(tries):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                    if self._point_free(p, obstacles):\n                        return p\n        return self._sample_free(obstacles)\n\n    def _sample_informed(self, best_len, obstacles):\n        for _ in range(48):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= best_len + 1e-9 and self._point_free(p, obstacles):\n                return p\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles)\n\n    # Compression (one-level ancestor LOS)\n    def _compress_one_ancestor(self, node, obstacles, edges):\n        p = node.parent\n        if p is None:\n            return\n        gp = p.parent\n        if gp is None:\n            return\n        if self._edge_free(gp.position, node.position, obstacles):\n            p.remove_child(node)\n            self._edges_remove(edges, p, node)\n            gp.add_child(node)\n            edges.append((gp, node))\n            node.cost = gp.cost + self._dist(gp.position, node.position)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Paths and smoothing\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a, b):\n        pa = self._path_to_root(a)\n        pb = []\n        cur = b\n        while cur is not None:\n            pb.append(cur.position)\n            cur = cur.parent\n        return pa + pb\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _smooth_path(self, path, obstacles, iters):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        n = len(pts)\n        for _ in range(iters):\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if self._edge_free(pts[i], pts[j], obstacles):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n        # forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            k = 1\n            while k < len(pts) - 1:\n                nxt = pts[k + 1]\n                if self._edge_free(last, nxt, obstacles):\n                    k += 1\n                else:\n                    collapsed.append(pts[k])\n                    last = pts[k]\n                    k += 1\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
          "objective": -21.17195,
          "time_improvement": 18.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1641.0,
          "node_improvement": 85.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019968414306640626,
                    "num_nodes_avg": 66.2,
                    "path_length_avg": 172.209352259231,
                    "smoothness_avg": 0.04618861809106635,
                    "success_improvement": 0.0,
                    "time_improvement": 21.68879389095995,
                    "node_improvement": 83.3291362377235,
                    "length_improvement": 5.609325194902977,
                    "smoothness_improvement": 622.9521733147333,
                    "objective_score": 12.986994150803438
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04688231945037842,
                    "num_nodes_avg": 138.6,
                    "path_length_avg": 247.35120568813113,
                    "smoothness_avg": 0.11455812785921168,
                    "success_improvement": 0.0,
                    "time_improvement": 70.73464358581568,
                    "node_improvement": 90.68736141906875,
                    "length_improvement": 17.427047931603575,
                    "smoothness_improvement": 2847.663142701818,
                    "objective_score": 45.91493754821594
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06750547885894775,
                    "num_nodes_avg": 155.9,
                    "path_length_avg": 128.89794559402256,
                    "smoothness_avg": 0.12209203383281582,
                    "success_improvement": 0.0,
                    "time_improvement": -37.62124065860623,
                    "node_improvement": 80.17800381436744,
                    "length_improvement": 14.392121997036531,
                    "smoothness_improvement": 1453.0016584569073,
                    "objective_score": 4.613909292924586
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "Cost-Guided Informed BiRRT* (CG-IBRRT*): a bidirectional, cost-aware planner that combines informed sampling, multi-ancestor line-of-sight compression, bounded local rewiring, and lazy rollback connects to minimize path length without inflating the trees. Candidates are scored by g+h to favor low-cost approaches; new nodes undergo recursive ancestor bypassing to shorten chains, neighbors are rewired when cheaper, and greedy connect steps are reverted if no bridge forms. A two-phase shortcut and visibility sweep finalizes a short, smooth path.",
          "planning_mechanism": "Initialize two trees at start/goal. Iteratively expand the active tree with a small beam: samples drawn from an informed ellipsoid (when a path bound exists), goal bias, or uniform. For the best g+h candidate, validate node/edge, insert, then repeatedly bypass to the farthest visible ancestor to reduce cost and depth. Perform bounded rewiring of close neighbors through the new node. Attempt to connect to the opposite tree via direct edge or a capped greedy march; if no bridge, roll back the temporary connect chain. Upon bridging, extract the path and apply shortcut plus visibility sweeps, returning immediately.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=7.0,\n                 goal_bias=0.15,\n                 beam_k=3,\n                 connect_steps=6,\n                 collision_step=1.0,\n                 smoothing_iters=40,\n                 min_sep_ratio=0.25,\n                 dupe_radius_ratio=0.5,\n                 rewire_radius_factor=2.0,\n                 rewire_limit=8,\n                 heuristic_weight=0.8):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.beam_k = beam_k\n        self.connect_steps = connect_steps\n        self.collision_step = collision_step\n        self.smoothing_iters = smoothing_iters\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.rewire_radius_factor = rewire_radius_factor\n        self.rewire_limit = rewire_limit\n        self.heuristic_weight = heuristic_weight\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Configure edge sampling resolution and grid cell\n        self.edge_res = max(0.6, min(self.collision_step, max(0.4, self.step_size * 0.35)))\n        self.grid_cell = max(1.0, 0.7 * self.step_size)\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early LOS\n        if not self._is_edge_in_obstacle(self.start, self.goal, obstacles, is_3d, self.edge_res):\n            path = [self.start, self.goal]\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, path, nodes, [])\n\n        # Initialize trees\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Informed sampling parameters\n        dsg = self._dist(self.start, self.goal)\n        c_best = float('inf')\n\n        # Precompute basis for informed sampling (updated if needed)\n        basis = self._compute_basis(self.start, self.goal, is_3d)\n\n        # Main loop\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other_pos = self.goal if active_start else self.start\n\n            # Beam selection: g+h scoring\n            best_pair = None\n            best_score = float('inf')\n\n            for _ in range(self.beam_k):\n                x_rand = None\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other_pos\n                else:\n                    if c_best < float('inf'):\n                        xr = self._sample_informed(c_best, dsg, basis, obstacles, is_3d)\n                        if xr is not None:\n                            x_rand = xr\n                    if x_rand is None:\n                        # fallback uniform\n                        x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                    continue\n\n                # g + w*h score\n                g = nearest.cost + self._dist(nearest.position, new_pos)\n                other_near = self._nearest_grid(grid_b, tree_b, new_pos)\n                h = self._dist(new_pos, other_near.position) if other_near is not None else self._dist(new_pos, root_other_pos)\n                score = g + self.heuristic_weight * h\n\n                # Prefer candidates that already have direct bridge\n                if other_near is not None and not self._is_edge_in_obstacle(new_pos, other_near.position, obstacles, is_3d, self.edge_res):\n                    score *= 0.25\n\n                if score < best_score:\n                    best_score = score\n                    best_pair = (nearest, new_pos)\n\n            if best_pair is None:\n                continue\n\n            parent_node, new_pos = best_pair\n\n            # Insert node (both checks already done)\n            new_cost = parent_node.cost + self._dist(parent_node.position, new_pos)\n            new_node = Node(new_pos, parent=parent_node, cost=new_cost)\n            parent_node.add_child(new_node)\n            tree_a.append(new_node)\n            self._edges_add(edges, parent_node, new_node)\n            self._grid_add(grid_a, new_node)\n\n            # Multi-ancestor LOS compression\n            self._compress_to_visible_ancestor(new_node, obstacles, is_3d, edges)\n\n            # Local rewiring around new_node (bounded)\n            self._bounded_rewire(new_node, grid_a, obstacles, is_3d, edges)\n\n            # Try direct bridge\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None and not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                path = self._extract_path(new_node, other_near)\n                c_best = self._path_length(path)\n                path = self._smooth_path(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Lazy greedy connect with rollback\n            bridged, meet_b, created = self._lazy_connect(tree_b, grid_b, new_node, obstacles, is_3d, edges)\n            if bridged:\n                # compress connect-side tail for better length\n                if created:\n                    self._compress_chain_tail(created[-1], obstacles, is_3d, edges)\n                path = self._extract_path(new_node, meet_b)\n                c_best = self._path_length(path)\n                path = self._smooth_path(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n            else:\n                # rollback temporary nodes already handled in _lazy_connect\n                pass\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # RNG (xorshift32)\n    def _rand(self):\n        if not hasattr(self, \"_rng_s\"):\n            self._rng_s = 123456789\n        x = self._rng_s\n        x ^= (x << 13) & 0xFFFFFFFF\n        x ^= (x >> 17) & 0xFFFFFFFF\n        x ^= (x << 5) & 0xFFFFFFFF\n        self._rng_s = x & 0xFFFFFFFF\n        return (self._rng_s % 1000000) / 1000000.0\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry helpers\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision checks\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _compute_basis(self, start, goal, is_3d):\n        # Returns center, e1, e2, e3 (e3 None in 2D)\n        c = tuple((start[i] + goal[i]) * 0.5 for i in range(self.dim))\n        v = tuple(goal[i] - start[i] for i in range(self.dim))\n        nv = self._norm(v)\n        if nv == 0.0:\n            if self.dim == 3:\n                return (c, (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0))\n            else:\n                return (c, (1.0, 0.0), (0.0, 1.0), None)\n        e1 = self._scale(v, 1.0 / nv)\n        if self.dim == 2:\n            e2 = (-e1[1], e1[0])\n            return (c, e1, e2, None)\n        else:\n            # 3D: build e2, e3 via Gram-Schmidt using a reference axis\n            ref = (1.0, 0.0, 0.0) if abs(e1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            u = self._cross(e1, ref)\n            nu = self._norm(u)\n            if nu == 0.0:\n                ref = (0.0, 0.0, 1.0)\n                u = self._cross(e1, ref)\n                nu = self._norm(u)\n                if nu == 0.0:\n                    u = (0.0, 1.0, 0.0)\n                    nu = 1.0\n            e2 = self._scale(u, 1.0 / max(1e-9, nu))\n            e3 = self._cross(e1, e2)\n            return (c, e1, e2, e3)\n\n    def _sample_informed(self, c_best, dsg, basis, obstacles, is_3d):\n        # Informed prolate hyper-ellipsoid sampling within bounds, fallback if invalid\n        if not (c_best < float('inf')) or c_best <= dsg:\n            return None\n        c, e1, e2, e3 = basis\n        a = c_best * 0.5\n        f = dsg * 0.5\n        b_sq = a * a - f * f\n        if b_sq <= 0.0:\n            return None\n        b = b_sq ** 0.5\n        # Sample uniformly in unit n-ball by rejection\n        for _ in range(8):\n            if self.dim == 2:\n                rx = self._uniform(-1.0, 1.0)\n                ry = self._uniform(-1.0, 1.0)\n                if rx * rx + ry * ry > 1.0:\n                    continue\n                # Scale and rotate\n                px_e = a * rx\n                py_e = b * ry\n                # Combine basis\n                x = c[0] + px_e * e1[0] + py_e * e2[0]\n                y = c[1] + px_e * e1[1] + py_e * e2[1]\n                p = (self._clamp_val(x, 0.0, self.bounds[0]),\n                     self._clamp_val(y, 0.0, self.bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            else:\n                rx = self._uniform(-1.0, 1.0)\n                ry = self._uniform(-1.0, 1.0)\n                rz = self._uniform(-1.0, 1.0)\n                if rx * rx + ry * ry + rz * rz > 1.0:\n                    continue\n                px_e = a * rx\n                py_e = b * ry\n                pz_e = b * rz\n                x = c[0] + px_e * e1[0] + py_e * e2[0] + pz_e * e3[0]\n                y = c[1] + px_e * e1[1] + py_e * e2[1] + pz_e * e3[1]\n                z = c[2] + px_e * e1[2] + py_e * e2[2] + pz_e * e3[2]\n                p = (self._clamp_val(x, 0.0, self.bounds[0]),\n                     self._clamp_val(y, 0.0, self.bounds[1]),\n                     self._clamp_val(z, 0.0, self.bounds[2]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n        return None\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # Vector helpers\n    def _norm(self, v):\n        s = 0.0\n        for i in range(len(v)):\n            s += v[i] * v[i]\n        return s ** 0.5\n\n    def _scale(self, v, k):\n        return tuple(v[i] * k for i in range(len(v)))\n\n    def _cross(self, a, b):\n        return (a[1]*b[2] - a[2]*b[1],\n                a[2]*b[0] - a[0]*b[2],\n                a[0]*b[1] - a[1]*b[0])\n\n    # Grid hashing for neighbors\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_remove(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket:\n            try:\n                bucket.remove(node)\n                if not bucket:\n                    del grid[k]\n            except:\n                pass\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Expand rings up to modest radius; fallback linear scan\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # Edges\n    def _edges_add(self, edges, parent, child):\n        edges.append((parent, child))\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Compression and rewiring\n    def _compress_to_visible_ancestor(self, node, obstacles, is_3d, edges):\n        # climb ancestors while LOS holds and cost reduces\n        cur_parent = node.parent\n        changed = True\n        attempts = 0\n        while changed and cur_parent is not None and attempts < 16:\n            attempts += 1\n            changed = False\n            anc = cur_parent.parent\n            best_parent = cur_parent\n            best_cost = cur_parent.cost + self._dist(cur_parent.position, node.position)\n            hop = 0\n            # try climbing several ancestors\n            while anc is not None and hop < 6:\n                hop += 1\n                if not self._is_edge_in_obstacle(anc.position, node.position, obstacles, is_3d, self.edge_res):\n                    new_cost = anc.cost + self._dist(anc.position, node.position)\n                    if new_cost + 1e-9 < best_cost:\n                        best_cost = new_cost\n                        best_parent = anc\n                anc = anc.parent\n            if best_parent is not cur_parent:\n                # reattach\n                cur_parent.remove_child(node)\n                self._edges_remove(edges, cur_parent, node)\n                best_parent.add_child(node)\n                self._edges_add(edges, best_parent, node)\n                node.cost = best_parent.cost + self._dist(best_parent.position, node.position)\n                cur_parent = best_parent\n                changed = True\n            else:\n                break\n\n    def _bounded_rewire(self, new_node, grid, obstacles, is_3d, edges):\n        radius = self.rewire_radius_factor * self.step_size\n        key = self._grid_key(new_node.position)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        # sort by distance to limit near ones\n        to_consider = []\n        r2 = radius * radius\n        for n in cand:\n            if n is new_node or n.parent is None:\n                continue\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - new_node.position[i]\n                d += dd * dd\n            if d <= r2:\n                to_consider.append((d, n))\n        to_consider.sort(key=lambda x: x[0])\n        rewired = 0\n        for _, n in to_consider:\n            if rewired >= self.rewire_limit:\n                break\n            # Attempt reparent through new_node\n            if not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d, self.edge_res):\n                new_cost = new_node.cost + self._dist(new_node.position, n.position)\n                if new_cost + 1e-9 < n.cost:\n                    old_parent = n.parent\n                    old_parent.remove_child(n)\n                    self._edges_remove(edges, old_parent, n)\n                    new_node.add_child(n)\n                    self._edges_add(edges, new_node, n)\n                    delta = new_cost - n.cost\n                    n.cost = new_cost\n                    # propagate cost change downwards\n                    self._propagate_cost(n)\n                    rewired += 1\n\n    def _propagate_cost(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                new_cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(new_cost - ch.cost) > 1e-9:\n                    ch.cost = new_cost\n                    stack.append(ch)\n\n    # Connect with rollback\n    def _lazy_connect(self, tree_b, grid_b, target_node, obstacles, is_3d, edges):\n        created = []\n        p = self._nearest_grid(grid_b, tree_b, target_node.position)\n        steps = 0\n        while p is not None and steps < self.connect_steps:\n            to_pos = self._steer(p.position, target_node.position, self.step_size)\n            if self._dist(p.position, to_pos) < self.step_size * self.min_sep_ratio:\n                break\n            if not self._in_bounds(to_pos):\n                break\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                break\n            if self._is_edge_in_obstacle(p.position, to_pos, obstacles, is_3d, self.edge_res):\n                break\n            q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n            # Both checks done; add\n            p.add_child(q)\n            tree_b.append(q)\n            created.append(q)\n            self._edges_add(edges, p, q)\n            self._grid_add(grid_b, q)\n            # Try compress along ancestors to reduce path length on connect-side\n            self._compress_to_visible_ancestor(q, obstacles, is_3d, edges)\n            # Bridge check\n            if not self._is_edge_in_obstacle(target_node.position, q.position, obstacles, is_3d, self.edge_res):\n                return True, q, created\n            p = q\n            steps += 1\n\n        # Rollback created nodes if no bridge\n        for q in reversed(created):\n            par = q.parent\n            if par is not None:\n                par.remove_child(q)\n                self._edges_remove(edges, par, q)\n            self._grid_remove(grid_b, q)\n            try:\n                tree_b.remove(q)\n            except:\n                pass\n        return False, None, []\n\n    def _compress_chain_tail(self, node, obstacles, is_3d, edges):\n        # compress newly created chain tail toward ancestors\n        self._compress_to_visible_ancestor(node, obstacles, is_3d, edges)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        # Path A: root_A -> meet_a\n        path_a = self._path_to_root(meet_a)\n        # Path B: meet_b -> root_B\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _smooth_path(self, path, obstacles, is_3d, iters):\n        if len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        # Random shortcuts\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n\n        # Forward visibility sweep\n        collapsed = [pts[0]]\n        last = pts[0]\n        k = 1\n        while k < len(pts) - 1:\n            nxt = pts[k + 1]\n            if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d, self.edge_res):\n                collapsed.append(pts[k])\n                last = pts[k]\n            k += 1\n        collapsed.append(pts[-1])\n        pts = collapsed\n\n        # Backward visibility sweep\n        collapsed = [pts[-1]]\n        last = pts[-1]\n        k = len(pts) - 2\n        while k > 0:\n            prev = pts[k - 1]\n            if self._is_edge_in_obstacle(prev, last, obstacles, is_3d, self.edge_res):\n                collapsed.append(pts[k])\n                last = pts[k]\n            k -= 1\n        collapsed.append(pts[0])\n        collapsed.reverse()\n        return collapsed",
          "objective": -20.95159,
          "time_improvement": 14.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1703.0,
          "node_improvement": 88.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03530135154724121,
                    "num_nodes_avg": 52.8,
                    "path_length_avg": 169.37118369255276,
                    "smoothness_avg": 0.04903191575180406,
                    "success_improvement": 0.0,
                    "time_improvement": -38.443212089421486,
                    "node_improvement": 86.70360110803324,
                    "length_improvement": 7.164970359958253,
                    "smoothness_improvement": 667.4559560249721,
                    "objective_score": -3.8967016307266333
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05135059356689453,
                    "num_nodes_avg": 119.7,
                    "path_length_avg": 244.32419087015742,
                    "smoothness_avg": 0.1189437644488173,
                    "success_improvement": 0.0,
                    "time_improvement": 67.94541224851965,
                    "node_improvement": 91.95726668010481,
                    "length_improvement": 18.4375526056338,
                    "smoothness_improvement": 2960.508730998724,
                    "objective_score": 46.248698892929795
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.042245674133300784,
                    "num_nodes_avg": 109.8,
                    "path_length_avg": 128.1488134725709,
                    "smoothness_avg": 0.12431590970064972,
                    "success_improvement": 0.0,
                    "time_improvement": 13.875107843732906,
                    "node_improvement": 86.03941513032423,
                    "length_improvement": 14.889659882266473,
                    "smoothness_improvement": 1481.2891953463131,
                    "objective_score": 20.50277425921132
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -20.90414805532173,
          "time_improvement": 74.0,
          "length_improvement": -3.0,
          "smoothness_improvement": 81.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009906005859375,
                    "num_nodes_avg": 119.0,
                    "path_length_avg": 191.04302473496983,
                    "smoothness_avg": 0.011270904212760589,
                    "success_improvement": 0.0,
                    "time_improvement": 61.15108317274382,
                    "node_improvement": 70.03273734575673,
                    "length_improvement": -4.713709127687822,
                    "smoothness_improvement": 76.41412608993974,
                    "objective_score": 15.899170105660149
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.018079090118408202,
                    "num_nodes_avg": 263.8,
                    "path_length_avg": 304.060897710979,
                    "smoothness_avg": 0.007193047909992605,
                    "success_improvement": 0.0,
                    "time_improvement": 88.71448720621899,
                    "node_improvement": 82.2750789491366,
                    "length_improvement": -1.5042795636027118,
                    "smoothness_improvement": 85.08230366710401,
                    "objective_score": 26.13718994203959
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013434433937072754,
                    "num_nodes_avg": 198.2,
                    "path_length_avg": 154.3877135428638,
                    "smoothness_avg": 0.014383244909940574,
                    "success_improvement": 0.0,
                    "time_improvement": 72.61165319885777,
                    "node_improvement": 74.79974570883661,
                    "length_improvement": -2.536968182267624,
                    "smoothness_improvement": 82.95381359374001,
                    "objective_score": 20.676084118265454
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "SwiftBridge-LRU BiRRT*: A bidirectional planner using grid-based nearest lookup, adaptive step sizing, local RRT*-style parent selection with bounded rewiring and cost propagation, and an LRU edge-collision cache reused across growth and shortcutting. It attempts direct line-of-sight bridges to the opposite tree without micro-step connects, focuses sampling within a goal corridor after a provisional path, caps local proliferation via per-cell limits and duplicate suppression, and returns a smoothed path quickly.",
          "planning_mechanism": "Each iteration alternates trees and evaluates a small beam of guided samples. For each sample: steer a bounded step from the nearest grid neighbor; validate node and edge; choose the cheapest parent among nearby nodes and a short ancestor lookback using cached LOS; insert and locally rewire with cost propagation. Then try a direct cached-LOS bridge to several nearest nodes in the other tree; if successful, extract and shortcut the path using the same cache and return. An informed ellipse sampler activates after the first solution; an LRU edge cache and per-cell caps control collision checks and node growth.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        cur = self\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        base_step=9.0,\n        step_shrink=0.6,\n        beam_width=3,\n        goal_bias=0.25,\n        parent_lookback=6,\n        per_cell_cap=10,\n        dup_separation_factor=0.7,\n        grid_cell_factor=1.4,\n        rewire_radius_factor=2.6,\n        edge_cache_capacity=40000,\n        lru_prune_fraction=0.3,\n        k_bridge=3,\n        smooth_attempts=80,\n        no_improve_stop=14,\n        time_limit_sec=25.0\n    ):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.step_shrink = step_shrink\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.parent_lookback = parent_lookback\n        self.per_cell_cap = per_cell_cap\n        self.dup_separation_factor = dup_separation_factor\n        self.grid_cell_factor = grid_cell_factor\n        self.rewire_radius_factor = rewire_radius_factor\n        self.edge_cache_capacity = edge_cache_capacity\n        self.lru_prune_fraction = lru_prune_fraction\n        self.k_bridge = k_bridge\n        self.smooth_attempts = smooth_attempts\n        self.no_improve_stop = no_improve_stop\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.obstacles = map.obstacles\n        self.start = map.start\n        self.goal = map.goal\n\n        # Basic geometry helpers rely on math/random availability\n        def dist(a, b):\n            s = 0.0\n            for i in range(self.dims):\n                d = a[i] - b[i]\n                s += d * d\n            return s ** 0.5\n\n        def clamp_bounds(p):\n            return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dims))\n\n        self._distance = dist\n\n        # Validate start/goal\n        if self._in_obstacle(self.start) or self._in_obstacle(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Edge cache (LRU)\n        self._ecache = {}  # key -> (free_bool, tick)\n        self._tick = 0\n\n        # Spatial hashing\n        self.cell_size = max(1.0, self.base_step * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.base_step * self.dup_separation_factor)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(self.start, parent=None, cost=0.0)\n        goal_root = Node(self.goal, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        incumbent_len = None\n        best_path = None\n\n        start_time = time.time()\n\n        # Early direct path\n        if self._edge_free(self.start, self.goal):\n            path = [self.start, self.goal]\n            return PlannerResult(True, path, nodes, edges)\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                if best_path is not None:\n                    return PlannerResult(True, best_path, nodes, edges)\n                return PlannerResult(False, [], nodes, edges)\n\n            # Alternate active/other sides\n            active_tree, active_grid, other_tree, other_grid, attractor = (\n                (tree_a, grid_a, tree_b, grid_b, self.goal) if (it % 2 == 0)\n                else (tree_b, grid_b, tree_a, grid_a, self.start)\n            )\n\n            bridged = None\n            best_bridge_path = None\n            best_bridge_len = float('inf')\n\n            # Adaptive step sizing\n            step = self.base_step if incumbent_len is None else max(3.0, self.base_step * self.step_shrink)\n            rewire_r = max(step * self.rewire_radius_factor, self.cell_size * 1.2)\n            dup_sep = max(0.5, step * self.dup_separation_factor)\n\n            for _b in range(self.beam_width):\n                sample = self._guided_sample(attractor, incumbent_len)\n                if sample is None:\n                    continue\n\n                nearest = self._nearest_in_grid(active_grid, sample, max_ring=6)\n                if nearest is None:\n                    continue\n\n                new_pos = self._steer(nearest.position, sample, step)\n                new_pos = clamp_bounds(new_pos)\n                if not self._within_bounds(new_pos):\n                    continue\n                if self._in_obstacle(new_pos):\n                    continue\n                if not self._edge_free(nearest.position, new_pos):\n                    continue\n                if self._has_nearby(active_grid, new_pos, dup_sep):\n                    continue\n\n                # Parent selection: neighbors + short ancestor lookback\n                parent = self._best_parent(nearest, new_pos, active_grid, rewire_r, lookback=self.parent_lookback)\n                if parent is None:\n                    parent = nearest  # fallback safety\n\n                # Per-cell cap with cost-admission\n                cell_key = self._cell_of(new_pos)\n                bucket = active_grid.get(cell_key)\n                cand_cost = parent.cost + dist(parent.position, new_pos)\n                if bucket and len(bucket) >= self.per_cell_cap:\n                    if cand_cost >= min(n.cost for n in bucket) - 1e-6:\n                        continue\n\n                # Insert node after node+edge checks\n                new_node = Node(new_pos, parent=parent, cost=cand_cost)\n                parent.add_child(new_node)\n                active_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((parent, new_node))\n                self._grid_insert(active_grid, new_node)\n\n                # Local rewire with cost propagation\n                neighs = self._neighbors_in_grid(active_grid, new_pos, rewire_r)\n                self._rewire_from(new_node, neighs, edges)\n\n                # Try direct LOS bridge to up to k nearest in the other tree\n                others = self._nearest_k_in_grid(other_grid, new_node.position, k=self.k_bridge, max_ring=6)\n                for on in others:\n                    if self._edge_free(new_node.position, on.position):\n                        path_a = new_node.path_from_root()\n                        path_b = on.path_from_root()\n                        raw_path = path_a + path_b[::-1]\n                        # Deduplicate joint if any\n                        if len(raw_path) >= 2 and self._distance(raw_path[-1], raw_path[-2]) <= 1e-12:\n                            raw_path.pop()\n                        # Shortcut using cached edges\n                        smoothed = self._shortcut_cached(raw_path)\n                        plen = self._path_length(smoothed)\n                        if plen < best_bridge_len - 1e-9:\n                            best_bridge_len = plen\n                            best_bridge_path = smoothed\n                            bridged = True\n\n            if bridged:\n                best_path = best_bridge_path\n                incumbent_len = best_bridge_len\n                return PlannerResult(True, best_path, nodes, edges)\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # ---------- Geometry and collision ----------\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _in_obstacle(self, pos):\n        if self.is_3d:\n            px, py, pz = pos\n            for (x, y, z, w, h, d) in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for (x, y, w, h) in self.obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _segment_hits_obstacle(self, a, b):\n        dist = self._distance(a, b)\n        resolution = max(0.4, min(1.0, (self.base_step * 0.5)))\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(self.dims))\n            if self._in_obstacle(p):\n                return True\n        return False\n\n    # ---------- Edge cache (LRU) ----------\n    def _edge_key(self, a, b):\n        # Quantize to make cache robust to tiny changes\n        q = max(0.5, self.base_step * 0.5)\n        qa = tuple(int(a[i] / q) for i in range(self.dims))\n        qb = tuple(int(b[i] / q) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self._ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self._ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self._ecache[key] = (free, self._tick)\n        if len(self._ecache) > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        if not self._ecache:\n            return\n        items = list(self._ecache.items())\n        # Sort by tick ascending; drop oldest fraction\n        items.sort(key=lambda kv: kv[1][1])\n        drop = max(1, int(len(items) * self.lru_prune_fraction))\n        for i in range(drop):\n            k = items[i][0]\n            if k in self._ecache:\n                del self._ecache[k]\n\n    # ---------- Spatial hash ----------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _neighbors_in_grid(self, grid, pos, radius):\n        results = []\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    results.append(n)\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                results.append(n)\n        return results\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    def _nearest_in_grid(self, grid, pos, max_ring=6):\n        cell = self._cell_of(pos)\n        best = None\n        best_d = 1e100\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best = n\n                                        best_d = d\n                                        found = True\n                if found:\n                    return best\n        else:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best = n\n                                    best_d = d\n                                    found = True\n                if found:\n                    return best\n        # Fallback scan\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._distance(n.position, pos)\n                if d < best_d:\n                    best = n\n                    best_d = d\n        return best\n\n    def _nearest_k_in_grid(self, grid, pos, k=3, max_ring=6):\n        cell = self._cell_of(pos)\n        cand = []\n        seen = set()\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                any_found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            key = (cell[0] + dx, cell[1] + dy, cell[2] + dz)\n                            if key in seen:\n                                continue\n                            seen.add(key)\n                            bucket = grid.get(key)\n                            if bucket:\n                                any_found = True\n                                for n in bucket:\n                                    cand.append((self._distance(n.position, pos), n))\n                if any_found and len(cand) >= k:\n                    break\n        else:\n            for ring in range(0, max_ring + 1):\n                any_found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        key = (cell[0] + dx, cell[1] + dy)\n                        if key in seen:\n                            continue\n                        seen.add(key)\n                        bucket = grid.get(key)\n                        if bucket:\n                            any_found = True\n                            for n in bucket:\n                                cand.append((self._distance(n.position, pos), n))\n                if any_found and len(cand) >= k:\n                    break\n        if not cand:\n            for bucket in grid.values():\n                for n in bucket:\n                    cand.append((self._distance(n.position, pos), n))\n        cand.sort(key=lambda x: x[0])\n        return [n for _, n in cand[:k]]\n\n    # ---------- Expansion primitives ----------\n    def _steer(self, a, b, step):\n        d = self._distance(a, b)\n        if d <= 1e-12:\n            return a\n        if d <= step:\n            return b\n        r = step / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n\n    def _best_parent(self, nearest, new_pos, grid, neighbor_radius, lookback=6):\n        best = nearest\n        best_cost = nearest.cost + self._distance(nearest.position, new_pos)\n        # Nearby candidates\n        for nb in self._neighbors_in_grid(grid, new_pos, neighbor_radius):\n            # Must pass edge check\n            if self._edge_free(nb.position, new_pos):\n                cand = nb.cost + self._distance(nb.position, new_pos)\n                if cand + 1e-9 < best_cost:\n                    best_cost = cand\n                    best = nb\n        # Short ancestor lookback from nearest for extra compression\n        cur = nearest\n        depth = 0\n        while cur is not None and depth < lookback:\n            if self._edge_free(cur.position, new_pos):\n                cand = cur.cost + self._distance(cur.position, new_pos)\n                if cand + 1e-9 < best_cost:\n                    best_cost = cand\n                    best = cur\n            cur = cur.parent\n            depth += 1\n        return best\n\n    def _rewire_from(self, pivot, neighbors, edges):\n        for nb in neighbors:\n            if nb is pivot or nb.parent is None:\n                continue\n            # Only consider if pivot offers shorter route and edge is free\n            new_cost = pivot.cost + self._distance(pivot.position, nb.position)\n            if new_cost + 1e-12 < nb.cost and self._edge_free(pivot.position, nb.position):\n                # Update edge list coherence\n                old_parent = nb.parent\n                try:\n                    edges.remove((old_parent, nb))\n                except ValueError:\n                    pass\n                if nb in old_parent.children:\n                    old_parent.children.remove(nb)\n                pivot.add_child(nb)\n                delta = new_cost - nb.cost\n                nb.cost = new_cost\n                edges.append((pivot, nb))\n                # Propagate cost change to descendants\n                if abs(delta) > 0.0:\n                    self._propagate_costs(nb, delta)\n\n    def _propagate_costs(self, node, delta):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                ch.cost += delta\n                stack.append(ch)\n\n    # ---------- Sampling ----------\n    def _guided_sample(self, attractor, incumbent_len):\n        # Mild goal bias before solution; ellipse corridor after\n        for _ in range(20):\n            if incumbent_len is not None and self._distance(self.start, self.goal) > 1e-9:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.03)\n                if p is None:\n                    continue\n            else:\n                if random.random() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = tuple(random.uniform(0.0, self.bounds[i]) for i in range(self.dims))\n            if self._within_bounds(p) and not self._in_obstacle(p):\n                return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        # Rejection sampling inside bounding box of ellipse/ellipsoid\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        ext = [half] * self.dims\n        for _ in range(16):\n            p = tuple(c[i] + random.uniform(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p) or self._in_obstacle(p):\n                continue\n            if self._distance(p, f1) + self._distance(p, f2) <= max_sum_dist:\n                return p\n        return None\n\n    # ---------- Path utilities ----------\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._distance(path[i - 1], path[i])\n        return total\n\n    def _shortcut_cached(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        no_improve = 0\n        i = 0\n        while attempts < self.smooth_attempts and i < len(pts) - 2:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    improved = True\n                    no_improve = 0\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n                no_improve += 1\n            attempts += 1\n            if no_improve >= self.no_improve_stop:\n                break\n        return pts",
          "objective": -20.37373,
          "time_improvement": 20.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1412.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04028286933898926,
                    "num_nodes_avg": 48.9,
                    "path_length_avg": 178.31486070416287,
                    "smoothness_avg": 0.05149151904268262,
                    "success_improvement": 0.0,
                    "time_improvement": -57.97949877372262,
                    "node_improvement": 87.68572148073534,
                    "length_improvement": 2.262799268263322,
                    "smoothness_improvement": 705.9540886412552,
                    "objective_score": -12.506399627952513
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.028925704956054687,
                    "num_nodes_avg": 73.1,
                    "path_length_avg": 244.0824418700917,
                    "smoothness_avg": 0.09700218179747645,
                    "success_improvement": 0.0,
                    "time_improvement": 81.94370340472467,
                    "node_improvement": 95.08835584223611,
                    "length_improvement": 18.518255380214885,
                    "smoothness_improvement": 2395.936005496538,
                    "objective_score": 47.67374427702902
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.030941128730773926,
                    "num_nodes_avg": 77.3,
                    "path_length_avg": 127.48153789197347,
                    "smoothness_avg": 0.0971348902448553,
                    "success_improvement": 0.0,
                    "time_improvement": 36.92131964274864,
                    "node_improvement": 90.1716465352829,
                    "length_improvement": 15.332832550650654,
                    "smoothness_improvement": 1135.5486341627675,
                    "objective_score": 25.95383859402882
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "Adaptive Beam BiRRT-Connect (AB-Connect): a lean, time-focused bidirectional planner that alternates single-step tree growth with a tiny beam of candidate samples. It uses a fine spatial hash for fast nearest queries, corridor-guided sampling around the start\u2013goal line to reduce rejection, and on-the-fly path compression to limit node bloat. A short greedy connect attempts to bridge trees early; upon success, a bounded shortcut pass cleans the path and returns immediately. By avoiding rewiring and heavy optimization while enforcing strict node/edge collision checks, AB-Connect minimizes per-iteration cost and achieves fast solutions.",
          "planning_mechanism": "Mechanism: Initialize two trees at start/goal. Each iteration (alternating trees), generate a small beam of candidate samples (goal/corridor/uniform), steer once from the nearest node, validate node and edge, discard near-duplicates, and keep the candidate that best reduces distance to the opposite tree. Insert it, attempt on-the-fly grandparent line-of-sight compression, then try a direct or short greedy connect toward the other tree. If bridged, extract the path and run bounded shortcut smoothing; else continue until the iteration budget is reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=8.0,\n                 goal_bias=0.18,\n                 corridor_bias=0.5,\n                 beam_k=2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=28,\n                 connect_steps=6,\n                 min_sep_ratio=0.25,\n                 dupe_radius_ratio=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.connect_steps = connect_steps\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n\n    # ---------------- Planning ----------------\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Setup grid resolution and collision sampling\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.6 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.4)))\n\n        # Validate start/goal and early LOS\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        if not self._is_edge_in_obstacle(self.start, self.goal, obstacles, is_3d, self.edge_res):\n            path = [self.start, self.goal]\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, path, nodes, [])\n\n        # Initialize structures\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Corridor parameters\n        dsg = self._dist(self.start, self.goal)\n        c_best = float('inf')\n        base_corridor = max(self.step_size, 0.15 * dsg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = self.goal if active_start else self.start\n\n            # Beam of candidates; keep the one that best reduces distance to the other tree\n            best_cand = None\n            best_score = float('inf')\n            other_near_hint = None\n\n            for _ in range(self.beam_k):\n                # Sampling policy: goal-biased, corridor-guided, or uniform\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = base_corridor\n                    if c_best < float('inf'):\n                        width = max(self.step_size, 0.25 * (c_best - dsg) + base_corridor)\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                    continue\n\n                # Score: distance to nearest node in the other tree after this move\n                if other_near_hint is None:\n                    other_near_hint = self._nearest_grid(grid_b, tree_b, new_pos)\n                else:\n                    # refresh if new_pos is far from hint\n                    if self._dist(other_near_hint.position, new_pos) > 2.5 * self.step_size:\n                        other_near_hint = self._nearest_grid(grid_b, tree_b, new_pos)\n                if other_near_hint is None:\n                    score = self._dist(new_pos, root_other)\n                else:\n                    score = self._dist(new_pos, other_near_hint.position)\n                if score < best_score:\n                    best_score = score\n                    best_cand = (nearest, new_pos)\n\n            if best_cand is None:\n                continue\n\n            parent_node, new_pos = best_cand\n\n            # Insert node and edge (validated already)\n            new_cost = parent_node.cost + self._dist(parent_node.position, new_pos)\n            new_node = Node(new_pos, parent=parent_node, cost=new_cost)\n            parent_node.add_child(new_node)\n            tree_a.append(new_node)\n            self._edges_add(edges, parent_node, new_node)\n            self._grid_add(grid_a, new_node)\n\n            # On-the-fly grandparent compression\n            gp = parent_node.parent\n            if gp is not None:\n                # If LOS from grandparent to new_node, bypass parent to reduce nodes and cost\n                if not self._is_edge_in_obstacle(gp.position, new_node.position, obstacles, is_3d, self.edge_res):\n                    # Update edges/children coherently\n                    parent_node.remove_child(new_node)\n                    self._edges_remove(edges, parent_node, new_node)\n                    gp.add_child(new_node)\n                    self._edges_add(edges, gp, new_node)\n                    # Update cost\n                    new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n\n            # Try direct bridge to the nearest node in the other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None and not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                path = self._extract_path(new_node, other_near)\n                c_best = self._path_length(path)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Short greedy connect toward new_node from the other tree\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if self._dist(p.position, to_pos) < self.step_size * self.min_sep_ratio:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(p.position, to_pos, obstacles, is_3d, self.edge_res):\n                    break\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                self._edges_add(edges, p, q)\n                self._grid_add(grid_b, q)\n                p = q\n                steps += 1\n\n                # Check bridge now\n                if not self._is_edge_in_obstacle(new_node.position, p.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, p)\n                    c_best = self._path_length(path)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------------- RNG ----------------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------------- Geometry ----------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------------- Collision ----------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------------- Sampling ----------------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        # Sample around the start-goal line with axis-aligned jitter (cheap \"corridor\")\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        # Fallback to uniform if corridor sample is invalid\n        return self._sample_free(obstacles, is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---------------- Grid and neighbors ----------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Expand rings up to modest radius; fallback linear scan if needed\n        for r in range(0, 5):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan (rare with fine grid)\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # ---------------- Edges and costs ----------------\n    def _edges_add(self, edges, parent, child):\n        edges.append((parent, child))\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # ---------------- Paths ----------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        # Path A: root_A -> meet_a\n        path_a = self._path_to_root(meet_a)\n        # Path B: meet_b -> root_B (following parent links)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        # Concatenate, implying a straight edge between meet_a and meet_b (validated before)\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        # Final LOS collapse forward\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            for k in range(1, len(pts) - 1):\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d, self.edge_res):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
          "objective": -20.0019,
          "time_improvement": 15.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1665.0,
          "node_improvement": 85.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.022508907318115234,
                    "num_nodes_avg": 61.9,
                    "path_length_avg": 173.37195960178056,
                    "smoothness_avg": 0.04856882636983518,
                    "success_improvement": 0.0,
                    "time_improvement": 11.725605588421473,
                    "node_improvement": 84.41198690506171,
                    "length_improvement": 4.972081687759297,
                    "smoothness_improvement": 660.2076015824708,
                    "objective_score": 9.801968697094374
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04350669384002685,
                    "num_nodes_avg": 122.6,
                    "path_length_avg": 245.93388702328062,
                    "smoothness_avg": 0.11098748565610625,
                    "success_improvement": 0.0,
                    "time_improvement": 72.84181080292292,
                    "node_improvement": 91.76241349190352,
                    "length_improvement": 17.900189697186487,
                    "smoothness_improvement": 2755.78794698629,
                    "objective_score": 46.371596794120215
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06773929595947266,
                    "num_nodes_avg": 163.7,
                    "path_length_avg": 132.06627662911285,
                    "smoothness_avg": 0.13189994478614067,
                    "success_improvement": 0.0,
                    "time_improvement": -38.09791603378091,
                    "node_improvement": 79.18626827717736,
                    "length_improvement": 12.287867383240805,
                    "smoothness_improvement": 1577.7575618385185,
                    "objective_score": 3.832133429002802
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "FLASH-Budget BiRRT: Fast Heuristic-Admission, Semi-LRU Cached, Budget-Gated Bidirectional RRT with short-circuit bridging and bounded smoothing. It uses dual-outcome edge memo with semi-LRU eviction, ring-lite neighbor search with leader/random fallback, per-cell expansion and g/f gates, duplicate suppression, and single-parent LOS insertion to curb checks and stabilize time, while returning a smooth path quickly.",
          "planning_mechanism": "Initialize two trees at start and goal with spatial hashing and leaders. Each iteration alternates sides and draws a tiny beam of guided samples (goal/corridor/uniform; informed if an incumbent exists). From hashed-nearest, steer one step, reject out-of-bounds/obstacle/duplicates, enforce per-cell quotas and incumbent-aware g/f gating, then select a cost-minimizing LOS parent from a small, bounded neighbor set. Insert after node and edge checks, update grids/leaders and caches, then attempt best-of-k cost-ordered bridging to the opposite tree using cached edge outcomes. On success, perform bounded, early-terminating shortcutting and return; otherwise, stall guard returns the best-so-far path within the iteration budget.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=10.0,\n                 collision_step=1.0,\n                 beam_k=2,\n                 goal_bias=0.25,\n                 corridor_bias=0.5,\n                 informed_bias=0.6,\n                 grid_cell=None,\n                 rings_near=2,\n                 parent_rings=2,\n                 parent_candidates=6,\n                 connect_k=6,\n                 connect_radius_factor=3.0,\n                 cell_expand_limit=3,\n                 cell_gate_relax=1.05,\n                 prune_margin=1.01,\n                 dupe_radius_ratio=0.6,\n                 smoothing_attempts=24,\n                 leader_stride=20,\n                 edge_cache_limit=50000,\n                 stall_limit=500):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_step = collision_step\n        self.beam_k = max(1, int(beam_k))\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.grid_cell = grid_cell\n        self.rings_near = max(1, int(rings_near))\n        self.parent_rings = max(1, int(parent_rings))\n        self.parent_candidates = max(1, int(parent_candidates))\n        self.connect_k = max(1, int(connect_k))\n        self.connect_radius_factor = connect_radius_factor\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.cell_gate_relax = cell_gate_relax\n        self.prune_margin = prune_margin\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.smoothing_attempts = max(0, int(smoothing_attempts))\n        self.leader_stride = max(1, int(leader_stride))\n        self.edge_cache_limit = max(2000, int(edge_cache_limit))\n        self.stall_limit = max(100, int(stall_limit))\n\n        self.bounds = None\n        self.dim = 2\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self.inv_cache_bin = 1.0\n        self.start = None\n        self.goal = None\n        self.edge_cache = None\n        self.edge_stamp = 0\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, 0.5 * self.step_size))\n        self.cache_bin = max(0.5, 0.5 * self.edge_res)\n        self.inv_cache_bin = 1.0 / self.cache_bin\n        self.edge_cache = {}\n        self.edge_stamp = 0\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Direct connection early exit\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            edges = [(n0, n1)]\n            nodes = [n0, n1]\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        leaders_a, leaders_b = [start_root], [goal_root]\n\n        expands_a, expands_b = {}, {}\n        bestg_a, bestg_b = {}, {}\n        bestf_a, bestf_b = {}, {}\n\n        dsg = self._dist(self.start, self.goal)\n        base_corridor = max(self.step_size, 0.2 * dsg)\n        dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n\n        best_path = None\n        best_path_len = float('inf')\n        last_improve_iter = 0\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            leaders1 = leaders_a if active_start else leaders_b\n            leaders2 = leaders_b if active_start else leaders_a\n            expands1 = expands_a if active_start else expands_b\n            bestg1 = bestg_a if active_start else bestg_b\n            bestf1 = bestf_a if active_start else bestf_b\n            other_root_pos = self.goal if active_start else self.start\n\n            best_cand = None  # (parent, new_pos, fscore, other_hint)\n\n            for _ in range(self.beam_k):\n                # Guided sampling\n                if best_path is not None and self._rand() < self.informed_bias:\n                    x_rand = self._sample_informed(best_path_len, obstacles, is_3d)\n                else:\n                    r = self._rand()\n                    if r < self.goal_bias:\n                        x_rand = other_root_pos\n                    elif r < self.goal_bias + self.corridor_bias:\n                        slack = 0.0 if best_path is None else max(0.0, best_path_len - dsg)\n                        width = max(self.step_size, base_corridor + 0.15 * slack)\n                        x_rand = self._sample_corridor(width, obstacles, is_3d)\n                    else:\n                        x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest(grid1, leaders1, tree1, x_rand)\n                if nearest is None:\n                    continue\n\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                # Node collision check once early\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                # Suppress near-duplicates\n                if self._exists_close(grid1, new_pos, dupe_radius):\n                    continue\n\n                kcell = self._grid_key(new_pos)\n                if expands1.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n\n                parent = self._choose_parent_lite(nearest, grid1, new_pos, obstacles, is_3d)\n                if parent is None:\n                    continue\n\n                # Edge collision (memoized)\n                if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_cost = parent.cost + self._dist(parent.position, new_pos)\n                # Cell-level g gate\n                prevg = bestg1.get(kcell, float('inf'))\n                if new_cost > prevg * self.cell_gate_relax:\n                    continue\n\n                h = self._dist(new_pos, other_root_pos)\n                # Incumbent-aware pruning\n                if best_path is not None and (new_cost + h) >= best_path_len * self.prune_margin:\n                    continue\n\n                # Bridge hint\n                other_near = self._nearest(grid2, leaders2, tree2, new_pos)\n                bridge_hint = self._dist(new_pos, other_near.position) if other_near is not None else h\n\n                fscore = new_cost + h + 0.25 * bridge_hint\n                prevf = bestf1.get(kcell, float('inf'))\n                if fscore > prevf * self.cell_gate_relax:\n                    continue\n\n                if best_cand is None or fscore < best_cand[2]:\n                    best_cand = (parent, new_pos, fscore, other_near)\n\n            if best_cand is None:\n                if best_path is not None and (it - last_improve_iter) >= self.stall_limit:\n                    path = self._smooth_path(best_path, obstacles, is_3d, self.smoothing_attempts)\n                    return PlannerResult(True, path, nodes, edges)\n                continue\n\n            parent, new_pos, _, _ = best_cand\n\n            # Final checks (cached; minimal redundancy)\n            if not self._in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos, parent, parent.cost + self._dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            self._grid_add(grid1, new_node)\n            edges.append((parent, new_node))\n\n            kc = self._grid_key(new_pos)\n            expands1[kc] = expands1.get(kc, 0) + 1\n            if new_node.cost < bestg1.get(kc, float('inf')):\n                bestg1[kc] = new_node.cost\n            estf = new_node.cost + self._dist(new_pos, other_root_pos)\n            if estf < bestf1.get(kc, float('inf')):\n                bestf1[kc] = estf\n            if len(tree1) % self.leader_stride == 0:\n                leaders1.append(new_node)\n\n            # Bridging: best-of-k by total cost\n            connect_radius = max(self.step_size, self.connect_radius_factor * self.step_size)\n            near_other = self._nearby(grid2, new_node.position, connect_radius, leaders2, tree2)\n            if len(near_other) > self.connect_k:\n                near_other = self._k_nearest(near_other, new_node.position, self.connect_k)\n            if near_other:\n                ranked = [(new_node.cost + self._dist(new_node.position, q.position) + q.cost, q) for q in near_other]\n                ranked.sort(key=lambda x: x[0])\n                connected = None\n                for _, q in ranked:\n                    if not self._edge_blocked_memo(new_node.position, q.position, obstacles, is_3d):\n                        connected = q\n                        break\n                if connected is not None:\n                    if active_start:\n                        raw_path = self._merge_paths(new_node, connected)\n                    else:\n                        raw_path = self._merge_paths(connected, new_node)\n                    cand_len = self._path_length(raw_path)\n                    best_path = raw_path\n                    best_path_len = cand_len\n                    last_improve_iter = it\n                    path = self._smooth_path(best_path, obstacles, is_3d, self.smoothing_attempts)\n                    return PlannerResult(True, path, nodes, edges)\n\n        # If ended without a bridge\n        if best_path is not None:\n            path = self._smooth_path(best_path, obstacles, is_3d, self.smoothing_attempts)\n            return PlannerResult(True, path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        if not hasattr(self, \"_rng\"):\n            self._rng = 2463534242\n        self._rng = (1664525 * self._rng + 1013904223) % (1 << 32)\n        return self._rng / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp_tuple(b)\n        if d <= 1e-12:\n            return self._clamp_tuple(a)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] * self.inv_cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] * self.inv_cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        st = self.edge_cache.get(key)\n        if st is not None:\n            return st[0] == 1\n        blocked = self._edge_blocked(a, b, obstacles, is_3d)\n        self.edge_stamp += 1\n        self.edge_cache[key] = (1 if blocked else 2, self.edge_stamp)\n        if len(self.edge_cache) > self.edge_cache_limit:\n            # Semi-LRU: keep newer half by stamp\n            cutoff = self.edge_stamp - (self.edge_cache_limit // 2)\n            self.edge_cache = {k: v for k, v in self.edge_cache.items() if v[1] >= cutoff}\n        return blocked\n\n    # Spatial hash\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, leaders, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.rings_near + 1):\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Leader fallback\n        for n in leaders:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # Random-sample fallback to avoid O(N) full scan\n        if tree:\n            picks = min(16, len(tree))\n            for _ in range(picks):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx % len(tree)]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius // self.grid_cell) + 1\n        cand = self._ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    def _nearby(self, grid, pos, radius, leaders, fallback_tree):\n        key = self._grid_key(pos)\n        r_cells = int(radius // self.grid_cell) + 1\n        cand = self._ring_collect(grid, key, r_cells)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n        if out:\n            return out\n        if leaders:\n            return list(leaders)\n        # As a last resort, return a small random subset to cap cost\n        if fallback_tree:\n            k = min(16, len(fallback_tree))\n            sel = []\n            for _ in range(k):\n                idx = int(self._uniform(0, len(fallback_tree)))\n                sel.append(fallback_tree[idx % len(fallback_tree)])\n            return sel\n        return []\n\n    def _k_nearest(self, nodes, pos, k):\n        if len(nodes) <= k:\n            return list(nodes)\n        best = []\n        bestd = []\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if len(best) < k:\n                best.append(n)\n                bestd.append(d)\n            else:\n                wi = 0\n                wv = bestd[0]\n                for i in range(1, k):\n                    if bestd[i] > wv:\n                        wi = i\n                        wv = bestd[i]\n                if d < wv:\n                    best[wi] = n\n                    bestd[wi] = d\n        return best\n\n    def _choose_parent_lite(self, nearest, grid, new_pos, obstacles, is_3d):\n        key = self._grid_key(new_pos)\n        cand = []\n        for r in range(0, self.parent_rings + 1):\n            cand.extend(self._ring_collect(grid, key, r))\n        if not cand:\n            cand = [nearest]\n        # keep only closest few to cap edge checks\n        if len(cand) > self.parent_candidates:\n            # partial selection without full sort\n            chosen = []\n            ch_d = []\n            for c in cand:\n                d = self._dist(c.position, new_pos)\n                if len(chosen) < self.parent_candidates:\n                    chosen.append(c)\n                    ch_d.append(d)\n                else:\n                    wi = 0\n                    wv = ch_d[0]\n                    for i in range(1, self.parent_candidates):\n                        if ch_d[i] > wv:\n                            wi = i\n                            wv = ch_d[i]\n                    if d < wv:\n                        chosen[wi] = c\n                        ch_d[wi] = d\n            cand = chosen\n        best_parent = None\n        best_cost = float('inf')\n        for c in cand:\n            if not self._edge_blocked_memo(c.position, new_pos, obstacles, is_3d):\n                cst = c.cost + self._dist(c.position, new_pos)\n                if cst < best_cost:\n                    best_cost = cst\n                    best_parent = c\n        return best_parent\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        for _ in range(60):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        if self.dim == 3:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5, self.bounds[2] * 0.5)\n        else:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5)\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        tries = 0\n        while tries < 24:\n            if self.dim == 3:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                else:\n                    tries += 1\n                    continue\n            else:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                else:\n                    tries += 1\n                    continue\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n            tries += 1\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        for _ in range(40):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if (self._dist(p, self.start) + self._dist(p, self.goal) <= best_len and\n                not self._is_in_obstacle(p, obstacles, is_3d)):\n                return p\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)\n\n    # Path ops\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_paths(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        pb.reverse()\n        return pa + pb\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _smooth_path(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3 or attempts <= 0:\n            return list(path)\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        no_gain = 0\n        best_len = self._path_length(pts)\n        while tries < attempts and n >= 3 and no_gain < 8:\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if not self._edge_blocked_memo(pts[i], pts[j], obstacles, is_3d):\n                new_pts = pts[:i + 1] + pts[j:]\n                new_len = self._path_length(new_pts)\n                if new_len + 1e-9 < best_len:\n                    pts = new_pts\n                    n = len(pts)\n                    best_len = new_len\n                    no_gain = 0\n                else:\n                    no_gain += 1\n            else:\n                no_gain += 1\n            tries += 1\n        return pts",
          "objective": -19.63386,
          "time_improvement": 32.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 870.0,
          "node_improvement": 92.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.026542282104492186,
                    "num_nodes_avg": 48.5,
                    "path_length_avg": 174.78616007895417,
                    "smoothness_avg": 0.038835792051444586,
                    "success_improvement": 0.0,
                    "time_improvement": -4.092297594102646,
                    "node_improvement": 87.78645177537145,
                    "length_improvement": 4.196935996779835,
                    "smoothness_improvement": 507.8644788773483,
                    "objective_score": 3.8297947142238487
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05081429481506348,
                    "num_nodes_avg": 76.3,
                    "path_length_avg": 244.5706503900573,
                    "smoothness_avg": 0.053309937067793,
                    "success_improvement": 0.0,
                    "time_improvement": 68.2801860886542,
                    "node_improvement": 94.87334542766915,
                    "length_improvement": 18.355277323947277,
                    "smoothness_improvement": 1271.7030783499415,
                    "objective_score": 37.855737612714336
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03360474109649658,
                    "num_nodes_avg": 51.3,
                    "path_length_avg": 141.50780854127214,
                    "smoothness_avg": 0.07324539686192114,
                    "success_improvement": 0.0,
                    "time_improvement": 31.491099094720216,
                    "node_improvement": 93.47743165924985,
                    "length_improvement": 6.017251444621056,
                    "smoothness_improvement": 831.6760416708219,
                    "objective_score": 17.21606080354281
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "IBEX-BiRRT (Informed Beam EXploration BiRRT): a bidirectional planner that couples ellipse-informed beam sampling with dual-state edge memoization, anchor-guided hashed nearest search, and local LOS-based parent selection. It throttles per-cell growth, rejects near-duplicates, and performs micro-connect probes with cached collision results. A provisional path immediately activates an informed ellipse to focus sampling; final paths are lightly shortcut and LOS-collapsed for length and smoothness.",
          "planning_mechanism": "Alternate growing start/goal trees. For each side, generate a small beam of samples from goal/corridor/uniform, switching to ellipse-informed sampling once a path exists. For each sample: find a near node via grid+anchors, steer, ensure node and edge collision-free, then choose a best-cost parent among a few nearby LOS-feasible nodes. Insert the node, attempt a direct bridge, else try a few micro connect steps from the opposite tree. Both node and edge checks are enforced before any insertion. On success, extract and shortcut the path; otherwise iterate up to a cap.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=10.0,\n        collision_step=1.0,\n        beam_k=3,\n        goal_bias=0.2,\n        corridor_bias=0.5,\n        informed_bias=0.6,\n        grid_cell_factor=0.9,\n        min_sep_ratio=0.4,\n        dupe_radius_ratio=0.6,\n        cell_expand_limit=3,\n        max_rings=3,\n        parent_search_rings=2,\n        connect_micro_steps=4,\n        smoothing_attempts=40,\n        anchors_stride=24,\n        edge_cache_max=12000,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_step = collision_step\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.max_rings = max_rings\n        self.parent_search_rings = parent_search_rings\n        self.connect_micro_steps = connect_micro_steps\n        self.smoothing_attempts = smoothing_attempts\n        self.anchors_stride = max(1, int(anchors_stride))\n        self.edge_cache_max = edge_cache_max\n\n        # Runtime fields\n        self.bounds = None\n        self.dim = 2\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self.edge_cache = None  # dict[(qa,qb)] = 1(blocked) or 2(free)\n        self.cell_size = 1.0\n        self.min_sep = 1.0\n        self.dupe_radius = 1.0\n        self.start = None\n        self.goal = None\n\n    # ------------- Public entry ----------------\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Parameterize discretizations\n        self.edge_res = max(0.75, min(self.collision_step, self.step_size * 0.5))\n        self.cache_bin = max(1.0, self.edge_res)\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_sep = max(0.5, self.step_size * self.min_sep_ratio)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.edge_cache = {}\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start)\n            n1 = Node(self.goal, parent=n0, cost=self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Init trees, grids, anchors, throttles\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        anchors_a, anchors_b = [start_root], [goal_root]\n        cell_expands_a, cell_expands_b = {}, {}\n\n        best_path_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        base_corridor_w = max(self.step_size, 0.2 * d_sg)\n\n        # Main loop\n        for it in range(self.max_iter):\n            # alternate sides\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            anchors1 = anchors_a if active_start else anchors_b\n            anchors2 = anchors_b if active_start else anchors_a\n            throttles1 = cell_expands_a if active_start else cell_expands_b\n            other_root = self.goal if active_start else self.start\n\n            best_candidate = None  # (parent_node, new_pos, score)\n\n            for _ in range(self.beam_k):\n                # Guided sampling with informed ellipse if available\n                x_rand = None\n                r = self._rand()\n                if best_path_len < float('inf') and r < self.informed_bias:\n                    x_rand = self._sample_informed(best_path_len, obstacles, is_3d)\n                else:\n                    r2 = self._rand()\n                    if r2 < self.goal_bias:\n                        x_rand = other_root\n                    elif r2 < self.goal_bias + self.corridor_bias:\n                        width = base_corridor_w\n                        if best_path_len < float('inf'):\n                            slack = max(0.0, best_path_len - d_sg)\n                            width = max(self.step_size, 0.15 * slack + base_corridor_w)\n                        x_rand = self._sample_corridor(width, obstacles, is_3d)\n                    else:\n                        x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_hashed(grid1, tree1, anchors1, x_rand)\n                if nearest is None:\n                    continue\n\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._exists_close(grid1, new_pos, self.dupe_radius):\n                    continue\n\n                # Throttle expansions per cell\n                kcell = self._grid_key(new_pos)\n                if throttles1.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n\n                # Candidate parent selection: consider a few nearby nodes with LOS and lower cost\n                parent = self._choose_parent(nearest, grid1, new_pos, obstacles, is_3d)\n                if parent is None:\n                    continue\n                # Edge check (both checks enforced before insertion)\n                if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Score: distance to nearest on opposite tree (encourage bridging)\n                near2 = self._nearest_hashed(grid2, tree2, anchors2, new_pos)\n                score = self._dist(new_pos, near2.position) if near2 is not None else self._dist(new_pos, other_root)\n\n                if best_candidate is None or score < best_candidate[2]:\n                    best_candidate = (parent, new_pos, score)\n\n            if best_candidate is None:\n                continue\n\n            parent, new_pos, _score = best_candidate\n\n            # Final checks before adding\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_cost = parent.cost + self._dist(parent.position, new_pos)\n            new_node = Node(new_pos, parent=parent, cost=new_cost)\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid1, new_node)\n            kc = self._grid_key(new_pos)\n            throttles1[kc] = throttles1.get(kc, 0) + 1\n            if len(tree1) % self.anchors_stride == 0:\n                anchors1.append(new_node)\n\n            # Grandparent LOS compression (cheap)\n            gp = parent.parent\n            if gp is not None and not self._edge_blocked_memo(gp.position, new_node.position, obstacles, is_3d):\n                parent.children = [c for c in parent.children if c is not new_node]\n                new_node.parent = gp\n                gp.add_child(new_node)\n                new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n                # edges bookkeeping: replace edge (parent,new_node) by (gp,new_node)\n                try:\n                    idx = -1\n                    for i in range(len(edges)):\n                        if edges[i][0] is parent and edges[i][1] is new_node:\n                            idx = i\n                            break\n                    if idx >= 0:\n                        edges.pop(idx)\n                except:\n                    pass\n                edges.append((gp, new_node))\n\n            # Try direct bridge\n            other_near = self._nearest_hashed(grid2, tree2, anchors2, new_node.position)\n            if other_near is not None and not self._edge_blocked_memo(new_node.position, other_near.position, obstacles, is_3d):\n                path = self._extract_path(new_node, other_near)\n                best_path_len = self._path_length(path)\n                path = self._smooth_path(path, obstacles, is_3d, self.smoothing_attempts)\n                return PlannerResult(True, path, nodes, edges)\n\n            # Micro-connect from the other side\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_micro_steps:\n                step_pos = self._steer(p.position, new_node.position, self.step_size)\n                if not self._in_bounds(step_pos):\n                    break\n                if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(grid2, step_pos, self.dupe_radius):\n                    break\n                if self._edge_blocked_memo(p.position, step_pos, obstacles, is_3d):\n                    break\n\n                # Add micro step node (both checks passed)\n                q = Node(step_pos, parent=p, cost=p.cost + self._dist(p.position, step_pos))\n                p.add_child(q)\n                tree2.append(q)\n                nodes.append(q)\n                edges.append((p, q))\n                self._grid_add(grid2, q)\n                if len(tree2) % self.anchors_stride == 0:\n                    anchors2.append(q)\n                k2 = self._grid_key(step_pos)\n                if active_start:\n                    cell_expands_b[k2] = cell_expands_b.get(k2, 0) + 1\n                else:\n                    cell_expands_a[k2] = cell_expands_a.get(k2, 0) + 1\n\n                p = q\n                steps += 1\n\n                # Check bridge after each micro step\n                if not self._edge_blocked_memo(new_node.position, p.position, obstacles, is_3d):\n                    path = self._extract_path(new_node, p)\n                    best_path_len = self._path_length(path)\n                    path = self._smooth_path(path, obstacles, is_3d, self.smoothing_attempts)\n                    return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # ------------- RNG -------------\n    def _rand(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ------------- Geometry -------------\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp_tuple(to_pos)\n        if d <= 1e-12:\n            return self._clamp_tuple(from_pos)\n        r = step / d\n        return self._clamp_tuple(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ------------- Collision -------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        state = self.edge_cache.get(key)\n        if state is not None:\n            return state == 1\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d)\n        self.edge_cache[key] = 1 if blocked else 2\n        if len(self.edge_cache) > self.edge_cache_max:\n            # Simple aging: clear cache to bound memory\n            self.edge_cache.clear()\n        return blocked\n\n    # ------------- Sampling -------------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        base_t = self._rand()\n        base = tuple(self.start[i] + base_t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            # Random offset in sphere\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        else:\n            for _ in range(10):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        # Rejection sampling in prolate ellipse (sum of distances to foci <= best_len)\n        for _ in range(40):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if self._dist(p, self.start) + self._dist(p, self.goal) <= best_len and not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # Fallback if rejection too strict\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)\n\n    # ------------- Grid Hashing -------------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, tree, anchors, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.max_rings + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback to anchors (sparse subset)\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # Rare: full scan\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.cell_size) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    def _nearby_candidates(self, grid, pos, rings):\n        key = self._grid_key(pos)\n        cand = []\n        for r in range(0, rings + 1):\n            cand.extend(self._grid_ring_collect(grid, key, r))\n        return cand\n\n    # ------------- Parent selection -------------\n    def _choose_parent(self, nearest, grid, new_pos, obstacles, is_3d):\n        best_parent = nearest\n        best_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        # include a few nearby candidates\n        candidates = self._nearby_candidates(grid, new_pos, self.parent_search_rings)\n        if not candidates:\n            candidates = [nearest]\n        for cand in candidates:\n            # Avoid trivial duplicate\n            if cand is None:\n                continue\n            # LOS check to new_pos\n            if not self._edge_blocked_memo(cand.position, new_pos, obstacles, is_3d):\n                c = cand.cost + self._dist(cand.position, new_pos)\n                if c < best_cost:\n                    best_cost = c\n                    best_parent = cand\n        return best_parent\n\n    # ------------- Paths -------------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, a_node, b_node):\n        path_a = self._path_to_root(a_node)\n        path_b = []\n        cur = b_node\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _smooth_path(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and len(pts) >= 3:\n            i = int(self._uniform(0, len(pts) - 2))\n            j = int(self._uniform(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._edge_blocked_memo(a, b, obstacles, is_3d):\n                # remove intermediates\n                pts = pts[:i + 1] + pts[j:]\n            tries += 1\n        # Forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            k = 1\n            while k < len(pts) - 1:\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n                k += 1\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
          "objective": -19.56842,
          "time_improvement": 16.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 1708.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.034371376037597656,
                    "num_nodes_avg": 54.5,
                    "path_length_avg": 176.5532757902085,
                    "smoothness_avg": 0.04933649347201097,
                    "success_improvement": 0.0,
                    "time_improvement": -34.79607703434419,
                    "node_improvement": 86.27549735582977,
                    "length_improvement": 3.2283518737009844,
                    "smoothness_improvement": 672.2232587473158,
                    "objective_score": -5.140695692346085
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.049022126197814944,
                    "num_nodes_avg": 74.3,
                    "path_length_avg": 244.4349083904013,
                    "smoothness_avg": 0.12138388867178254,
                    "success_improvement": 0.0,
                    "time_improvement": 69.39891173945327,
                    "node_improvement": 95.00772693677351,
                    "length_improvement": 18.400591910549277,
                    "smoothness_improvement": 3023.294884806057,
                    "objective_score": 46.976503092195834
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04275155067443848,
                    "num_nodes_avg": 61.0,
                    "path_length_avg": 135.83592104549325,
                    "smoothness_avg": 0.12021718235188508,
                    "success_improvement": 0.0,
                    "time_improvement": 12.8437936691172,
                    "node_improvement": 92.2441195168468,
                    "length_improvement": 9.784249053058426,
                    "smoothness_improvement": 1429.1536860066096,
                    "objective_score": 16.869455962603265
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "HALO-BiRRT-Lite: Heuristically Annealed, Lazy-Optimal bidirectional RRT with hash-NN, cell-cost pruning, duplicate suppression, micro-rewiring, and cached collision tests. It keeps trees sparse via per-cell throttles and near-duplicate filtering, orders parents by g+\u03bbh with lazy feasibility checks, shrinks sampling to an informed region once a bound exists, and bridges with a short micro-connect. Final shortcutting and LOS collapse yield smooth, short paths with low overhead.",
          "planning_mechanism": "Alternate growing start/goal trees. Per side, draw a few biased samples (goal/corridor/ellipse); hash-nearest gives an anchor, gather neighbors, rank by f=g+\u03bbh, and lazily test edges until a feasible parent is found. Insert only if both node and edge are valid; do a tiny local rewire. Try direct bridge to opposite tree; if blocked, take a few micro-steps from the other side toward the new node, each validated. On first connection, extract, shortcut, and collapse the path; informed sampling anneals \u03bb and focuses exploration as the incumbent improves.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=5000,\n        step_size=8.0,\n        grid_cell_factor=1.1,\n        dupe_radius_ratio=0.45,\n        per_cell_expand=3,\n        beam_k=2,\n        goal_bias=0.2,\n        corridor_bias=0.45,\n        informed_bias=0.6,\n        parent_neighbor_factor=2.5,\n        parent_cap=24,\n        rewire_cap=4,\n        connect_steps=3,\n        edge_cache_capacity=32000,\n        edge_cache_quant=0.9,\n        smoothing_attempts=32,\n        no_improve_stop=10\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.grid_cell_factor = float(grid_cell_factor)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.per_cell_expand = int(max(1, per_cell_expand))\n        self.beam_k = int(max(1, beam_k))\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.parent_neighbor_factor = float(parent_neighbor_factor)\n        self.parent_cap = int(max(4, parent_cap))\n        self.rewire_cap = int(max(0, rewire_cap))\n        self.connect_steps = int(max(0, connect_steps))\n        self.edge_cache_capacity = int(max(1024, edge_cache_capacity))\n        self.edge_cache_quant = float(max(0.25, edge_cache_quant))\n        self.smoothing_attempts = int(max(0, smoothing_attempts))\n        self.no_improve_stop = int(max(5, no_improve_stop))\n\n        self._rng = 2463534242\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n\n        # Spatial hashing parameters\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.parent_radius = max(self.step_size * 1.25, self.parent_neighbor_factor * self.step_size)\n\n        # Collision helpers\n        self.eq = self.edge_cache_quant\n        self._tick = 0\n        self.ecache = {}\n        self._last_prune = 0\n\n        # Build obstacle grid and validate endpoints\n        self._build_obstacle_grid()\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight line\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # Initialize trees, grids, throttles, and anchors\n        nodes = []\n        edges = []\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        tree_a, tree_b = [a_root], [b_root]\n        grid_a, grid_b = {}, {}\n        thr_a, thr_b = {}, {}\n        anchors_a, anchors_b = [a_root], [b_root]\n        self._grid_add(grid_a, a_root)\n        self._grid_add(grid_b, b_root)\n        anchors_stride = 20\n\n        # Per-cell best cost pruning\n        cell_best_a, cell_best_b = {}, {}\n\n        best_path = None\n        best_len = float('inf')\n        sg = self._dist(self.start, self.goal)\n\n        # Blocked cell-pair sieve for bridges\n        blocked_pairs = set()\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            tree1 = tree_a if side_a else tree_b\n            tree2 = tree_b if side_a else tree_a\n            grid1 = grid_a if side_a else grid_b\n            grid2 = grid_b if side_a else grid_a\n            thr1 = thr_a if side_a else thr_b\n            cell_best1 = cell_best_a if side_a else cell_best_b\n            anchors1 = anchors_a if side_a else anchors_b\n            anchors2 = anchors_b if side_a else anchors_a\n            target = self.goal if side_a else self.start\n\n            progressed = False\n            lam = 0.3 if best_len == float('inf') else max(0.05, 0.3 * (best_len / (sg + 1e-9) - 1.0))\n\n            # Beam: choose the best feasible candidate, lazily checking edges\n            best_cand = None  # (parent, new_pos, g_cost, score, kcell)\n            for _ in range(self.beam_k):\n                qsample = self._sample(target, best_len, sg)\n                if qsample is None:\n                    continue\n                nearest = self._nearest_hashed(grid1, anchors1, qsample)\n                if nearest is None:\n                    continue\n                new_pos = self._steer(nearest.position, qsample)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if self._has_near(grid1, new_pos, self.dupe_radius):\n                    continue\n                kcell = self._cell_key(new_pos)\n                if thr1.get(kcell, 0) >= self.per_cell_expand:\n                    continue\n\n                # Gather neighbor candidates and order by f = g + lam*h\n                neigh = self._neighbors_within(grid1, new_pos, self.parent_radius)\n                if nearest not in neigh:\n                    neigh.append(nearest)\n\n                # Score ordering\n                h_term = self._dist(new_pos, target)\n                scored = []\n                for p in neigh:\n                    gc = p.cost + self._dist(p.position, new_pos)\n                    f = gc + lam * h_term\n                    scored.append((f, gc, p))\n                scored.sort(key=lambda t: t[0])\n                if len(scored) > self.parent_cap:\n                    scored = scored[:self.parent_cap]\n\n                # Cell best cost pruning (cheap)\n                prev_best = cell_best1.get(kcell)\n                if prev_best is not None:\n                    # Keep only those with promise to beat current cell best\n                    scored = [t for t in scored if t[1] + 1e-9 < prev_best]\n\n                # Lazy feasibility: try in order until a valid edge is found\n                chosen = None\n                for _, gc, p in scored:\n                    if self._point_in_obstacles(new_pos):\n                        chosen = None\n                        break\n                    if self._edge_free(p.position, new_pos):\n                        chosen = (p, new_pos, gc, kcell)\n                        break\n                if chosen is None:\n                    # Try nearest as a fallback if not already in scored\n                    if self._edge_free(nearest.position, new_pos) and not self._point_in_obstacles(new_pos):\n                        gc = nearest.cost + self._dist(nearest.position, new_pos)\n                        chosen = (nearest, new_pos, gc, kcell)\n                if chosen is None:\n                    continue\n\n                parent, np, gc, kc = chosen\n                score = gc + lam * h_term\n                if best_cand is None or score + 1e-9 < best_cand[3]:\n                    best_cand = (parent, np, gc, score, kc)\n\n            if best_cand is None:\n                continue\n\n            parent, new_pos, g_cost, _score, kcell = best_cand\n\n            # Final strict checks before insertion: both node and edge\n            if self._point_in_obstacles(new_pos):\n                continue\n            if not self._edge_free(parent.position, new_pos):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent=parent, cost=g_cost)\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent, new_node))\n            self._grid_add(grid1, new_node)\n            thr1[kcell] = thr1.get(kcell, 0) + 1\n            old_cell_best = cell_best1.get(kcell)\n            cell_best1[kcell] = g_cost if old_cell_best is None else min(old_cell_best, g_cost)\n            if (len(tree1) % anchors_stride) == 0:\n                anchors1.append(new_node)\n            progressed = True\n\n            # Micro rewiring (tiny, cost-improving only)\n            if self.rewire_cap > 0:\n                nbrs = self._neighbors_within(grid1, new_pos, self.parent_radius)\n                # Prefer closer neighbors\n                cand = []\n                for nb in nbrs:\n                    if nb is new_node or nb is parent:\n                        continue\n                    d = self._dist(nb.position, new_pos)\n                    cand.append((d, nb))\n                cand.sort(key=lambda t: t[0])\n                rewired = 0\n                for _, nb in cand:\n                    if rewired >= self.rewire_cap:\n                        break\n                    if self._is_ancestor(nb, new_node):\n                        continue\n                    new_cost = new_node.cost + self._dist(new_node.position, nb.position)\n                    if new_cost + 1e-9 < nb.cost and self._edge_free(new_node.position, nb.position):\n                        self._reconnect(nb, new_node, edges)\n                        rewired += 1\n\n            # Try to bridge to the opposite tree\n            other_near = self._nearest_hashed(grid2, anchors2, new_node.position)\n            if other_near is not None:\n                # Skip repeatedly blocked cell pairs\n                pk = self._pair_key(self._cell_key(new_node.position), self._cell_key(other_near.position))\n                if pk not in blocked_pairs:\n                    if self._edge_free(new_node.position, other_near.position):\n                        path = self._extract_path(new_node, other_near)\n                        path = self._shortcut(path)\n                        path = self._los_collapse(path)\n                        return PlannerResult(True, path, nodes, edges)\n                    # Micro connect from other side\n                    q = other_near\n                    steps = 0\n                    success = False\n                    last_q = None\n                    while steps < self.connect_steps:\n                        nxt = self._steer(q.position, new_node.position)\n                        if not self._in_bounds(nxt):\n                            break\n                        if self._point_in_obstacles(nxt):\n                            break\n                        if self._has_near(grid2, nxt, self.dupe_radius):\n                            break\n                        if not self._edge_free(q.position, nxt):\n                            break\n                        # Insert micro-step node (both checks already satisfied)\n                        qn = Node(nxt, q, q.cost + self._dist(q.position, nxt))\n                        q.add_child(qn)\n                        tree2.append(qn)\n                        nodes.append(qn)\n                        edges.append((q, qn))\n                        self._grid_add(grid2, qn)\n                        if (len(tree2) % anchors_stride) == 0:\n                            anchors2.append(qn)\n                        # Try to bridge\n                        if self._edge_free(new_node.position, qn.position):\n                            path = self._extract_path(new_node, qn)\n                            path = self._shortcut(path)\n                            path = self._los_collapse(path)\n                            return PlannerResult(True, path, nodes, edges)\n                        q = qn\n                        last_q = qn\n                        steps += 1\n                    if last_q is None:\n                        blocked_pairs.add(pk)\n\n            if not progressed:\n                continue\n\n        # If an incumbent was discovered (should return earlier), still return it\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG and basic geometry\n    def _seed_from_scene(self):\n        s = 0x9E3779B1\n        for v in self.start + self.goal:\n            s ^= (int(v * 997 + 0.5) + 0x7FEB352D) & 0xffffffff\n            s = (s * 1664525 + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        self._rng = s if s != 0 else 2463534242\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return self._rng / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    # Sampling\n    def _sample(self, target, best_len, sg):\n        for _ in range(32):\n            r = self._rand()\n            if best_len < float('inf') and r < self.informed_bias:\n                p = self._ellipse_sample(self.start, self.goal, best_len * 1.02)\n                if p and not self._point_in_obstacles(p):\n                    return p\n            else:\n                r2 = self._rand()\n                if r2 < self.goal_bias:\n                    p = target\n                elif r2 < self.goal_bias + self.corridor_bias:\n                    # Corridor sample around the start-goal line\n                    t = self._rand()\n                    base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n                    width = max(self.step_size, 0.2 * sg if best_len == float('inf') else 0.15 * max(0.0, best_len - sg) + 0.2 * sg)\n                    if self.is_3d:\n                        ox = self._rand_range(-width, width)\n                        oy = self._rand_range(-width, width)\n                        oz = self._rand_range(-width, width)\n                        p = self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n                    else:\n                        ox = self._rand_range(-width, width)\n                        oy = self._rand_range(-width, width)\n                        p = self._clamp((base[0] + ox, base[1] + oy))\n                else:\n                    if self.is_3d:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]),\n                             self._rand_range(0.0, self.bounds[2]))\n                    else:\n                        p = (self._rand_range(0.0, self.bounds[0]),\n                             self._rand_range(0.0, self.bounds[1]))\n                if self._in_bounds(p) and not self._point_in_obstacles(p):\n                    return p\n        return None\n\n    def _ellipse_sample(self, f1, f2, max_sum):\n        c = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dim))\n        half = 0.5 * max_sum\n        ext = [half] * self.dim\n        for _ in range(32):\n            if self.is_3d:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]),\n                     c[2] + self._rand_range(-ext[2], ext[2]))\n            else:\n                p = (c[0] + self._rand_range(-ext[0], ext[0]),\n                     c[1] + self._rand_range(-ext[1], ext[1]))\n            if (self._dist(p, f1) + self._dist(p, f2)) <= max_sum and self._in_bounds(p):\n                return p\n        return None\n\n    # Grid hashing for nodes\n    def _cell_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n\n    def _grid_ring(self, key, r, grid):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, anchors, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 5):\n            cand = self._grid_ring(key, r, grid)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback to anchors\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors_within(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        r_cells = int(radius // self.cell_size) + 1\n        cand = self._grid_ring(key, r_cells, grid)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n        return out\n\n    def _has_near(self, grid, pos, radius):\n        arr = self._neighbors_within(grid, pos, radius)\n        return len(arr) > 0\n\n    # Obstacle grid and collision\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            bucket = self.obs_grid.get(k)\n                            if bucket is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                bucket.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        bucket = self.obs_grid.get(k)\n                        if bucket is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            bucket.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.eq) for i in range(self.dim))\n        qb = tuple(int(b[i] / self.eq) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        if len(self.ecache) - self._last_prune > self.edge_cache_capacity:\n            self._prune_ecache()\n        return free\n\n    def _prune_ecache(self):\n        cutoff = self._tick - 3000\n        to_del = []\n        for k, v in self.ecache.items():\n            if v[1] < cutoff:\n                to_del.append(k)\n        if not to_del:\n            i = 0\n            for k in list(self.ecache.keys()):\n                if (i % 4) == 0:\n                    to_del.append(k)\n                i += 1\n        for k in to_del:\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune = len(self.ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            bbmin = [0.0, 0.0, 0.0]\n            bbmax = [0.0, 0.0, 0.0]\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                bbmin[0], bbmin[1], bbmin[2] = x, y, z\n                bbmax[0], bbmax[1], bbmax[2] = x + w, y + h, z + d\n                if self._seg_box_intersect_3d(a, b, tuple(bbmin), tuple(bbmax)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_box_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect_2d(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _seg_box_intersect_3d(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    # Tree ops\n    def _is_ancestor(self, anc, node):\n        cur = node\n        while cur is not None:\n            if cur is anc:\n                return True\n            cur = cur.parent\n        return False\n\n    def _reconnect(self, child, new_parent, edges):\n        old_parent = child.parent\n        if old_parent is new_parent:\n            return\n        if old_parent is not None:\n            old_parent.remove_child(child)\n            self._edges_remove(edges, old_parent, child)\n        new_parent.add_child(child)\n        edges.append((new_parent, child))\n        # update cost and propagate\n        child.cost = new_parent.cost + self._dist(new_parent.position, child.position)\n        self._propagate_costs(child)\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    def _propagate_costs(self, node):\n        stack = [node]\n        while stack:\n            cur = stack.pop()\n            for ch in cur.children:\n                old = ch.cost\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                if abs(ch.cost - old) > 1e-12:\n                    stack.append(ch)\n\n    # Bridging helpers\n    def _pair_key(self, c1, c2):\n        return (c1, c2) if c1 <= c2 else (c2, c1)\n\n    # Paths and smoothing\n    def _to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._to_root(a_node)\n        pb = self._to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return pa + pb[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        best_len = self._path_len(pts)\n        attempts = 0\n        no_imp = 0\n        while attempts < self.smoothing_attempts:\n            i = int(self._rand_range(0, max(1, len(pts) - 2)))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                attempts += 1\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best_len + 1e-12:\n                    pts = new_pts\n                    best_len = L\n                    no_imp = 0\n                else:\n                    no_imp += 1\n            else:\n                no_imp += 1\n            attempts += 1\n            if no_imp >= self.no_improve_stop:\n                break\n        return pts\n\n    def _los_collapse(self, path):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        last = path[0]\n        k = 1\n        while k < len(path) - 1:\n            nxt = path[k + 1]\n            if self._edge_free(last, nxt):\n                k += 1\n                continue\n            out.append(path[k])\n            last = path[k]\n            k += 1\n        out.append(path[-1])\n        return out",
          "objective": -17.48437,
          "time_improvement": 9.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1595.0,
          "node_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02172725200653076,
                    "num_nodes_avg": 74.0,
                    "path_length_avg": 183.9066863954111,
                    "smoothness_avg": 0.05321282174668059,
                    "success_improvement": 0.0,
                    "time_improvement": 14.79106533258158,
                    "node_improvement": 81.3648954923193,
                    "length_improvement": -0.8021690012582078,
                    "smoothness_improvement": 732.8962138274719,
                    "objective_score": 7.620499268156909
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0629072904586792,
                    "num_nodes_avg": 155.0,
                    "path_length_avg": 239.21703731830726,
                    "smoothness_avg": 0.12215873785068969,
                    "success_improvement": 0.0,
                    "time_improvement": 60.73137383331824,
                    "node_improvement": 89.5854330444131,
                    "length_improvement": 20.142467462505667,
                    "smoothness_improvement": 3043.232312280643,
                    "objective_score": 45.521054188902085
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07303009033203126,
                    "num_nodes_avg": 146.0,
                    "path_length_avg": 128.1356940481787,
                    "smoothness_avg": 0.08707201428468397,
                    "success_improvement": 0.0,
                    "time_improvement": -48.88408773315513,
                    "node_improvement": 81.43674507310871,
                    "length_improvement": 14.898373179267926,
                    "smoothness_improvement": 1007.5495947136283,
                    "objective_score": -0.6884544388176401
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
          "objective": -17.205069232007403,
          "time_improvement": 34.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 176.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0216599702835083,
                    "num_nodes_avg": 94.5,
                    "path_length_avg": 179.3326139424124,
                    "smoothness_avg": 0.016628736549943037,
                    "success_improvement": 0.0,
                    "time_improvement": 15.05492769030675,
                    "node_improvement": 76.20246789221858,
                    "length_improvement": 1.7049525910466614,
                    "smoothness_improvement": 160.2758368859854,
                    "objective_score": 6.340829046149949
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02987968921661377,
                    "num_nodes_avg": 216.6,
                    "path_length_avg": 257.061927055405,
                    "smoothness_avg": 0.010384869878880055,
                    "success_improvement": 0.0,
                    "time_improvement": 81.34819768474138,
                    "node_improvement": 85.44648256399921,
                    "length_improvement": 14.185329631590712,
                    "smoothness_improvement": 167.21018190301697,
                    "objective_score": 33.75170799389193
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.046378374099731445,
                    "num_nodes_avg": 257.2,
                    "path_length_avg": 128.26306667164565,
                    "smoothness_avg": 0.023576110070462338,
                    "success_improvement": 0.0,
                    "time_improvement": 5.449905826599429,
                    "node_improvement": 67.29815638906548,
                    "length_improvement": 14.813778347593729,
                    "smoothness_improvement": 199.8863798888539,
                    "objective_score": 11.522670655980336
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "PB-Best BiRRT: a heuristic-priority, dual-cache bidirectional planner with ring-hash nearest search, progressive stepping, micro-rewiring, and short anytime refinement. It grows two trees using best-of-beam expansions scored by f = g + h, memoizes both blocked and free edges, throttles per-cell growth to avoid bloat, attempts bounded guided connects, and returns a two-pass shortcutted path.",
          "planning_mechanism": "Mechanism: Initialize start/goal roots, ring-hash grids, and free/blocked edge caches. Each iteration alternates trees, samples a small beam (goal/corridor/uniform), selects the candidate minimizing f to the opposite root, validates node and edge via cached checks with progressive step shrinking, inserts it and performs local micro-rewiring. Then it tries a direct bridge and a short guided connect. On first bridge it records the best-so-far path and continues a brief refinement window with corridor-biased sampling; finally returns the best path after two-pass shortcutting.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=8.0,\n                 goal_bias=0.25,\n                 corridor_bias=0.5,\n                 beam_k=3,\n                 connect_steps=6,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=24,\n                 min_sep_ratio=0.2,\n                 dupe_radius_ratio=0.5,\n                 cell_expand_limit=4,\n                 leader_stride=20,\n                 rewire_max=6,\n                 improvement_window=120,\n                 h_weight=1.0,\n                 bridge_weight=0.3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.connect_steps = connect_steps\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.leader_stride = max(1, int(leader_stride))\n        self.rewire_max = max(0, int(rewire_max))\n        self.improvement_window = max(0, int(improvement_window))\n        self.h_weight = max(0.0, h_weight)\n        self.bridge_weight = max(0.0, bridge_weight)\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n\n        # RNG\n        self._lcg_state = 2463534242\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Parameterize spatial helpers\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.8 * self.step_size)\n        self.edge_res = max(0.5, min(self.collision_step, self.step_size * 0.5))\n        self.cache_bin = max(1.0, self.edge_res)\n\n        # Edge caches\n        self._blocked_edges = set()\n        self._free_edges = set()\n\n        # Validate endpoints and early LOS\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n        if self._is_edge_free_cached(start, goal, obstacles, is_3d):\n            nodes = [Node(start), Node(goal)]\n            return PlannerResult(True, [start, goal], nodes, [])\n\n        # Initialize trees, grids, leaders, edges\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start, grid_goal = {}, {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n        leaders_start, leaders_goal = [start_root], [goal_root]\n        cell_expands_start, cell_expands_goal = {}, {}\n\n        # Corridor shaping\n        dsg = self._dist(start, goal)\n        base_corridor = max(self.step_size, 0.15 * dsg)\n\n        # Anytime improvement bookkeeping\n        best_path = None\n        best_len = float('inf')\n        best_found_iter = -1\n\n        for it in range(self.max_iter):\n            # If we already found a path and improvement window passed, stop\n            if best_found_iter >= 0 and (it - best_found_iter) > self.improvement_window:\n                break\n\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            leaders_a = leaders_start if active_start else leaders_goal\n            leaders_b = leaders_goal if active_start else leaders_start\n            cell_count_a = cell_expands_start if active_start else cell_expands_goal\n            cell_count_b = cell_expands_goal if active_start else cell_expands_start\n            root_other = goal if active_start else start\n\n            # Beam search: choose the best candidate by f = g + h + bridge term\n            best_parent = None\n            best_newpos = None\n            best_score = float('inf')\n\n            for _ in range(self.beam_k):\n                # Sampling policy\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = base_corridor\n                    if best_path is not None and best_len < float('inf'):\n                        width = max(self.step_size, 0.2 * (best_len - dsg) + base_corridor)\n                    x_rand = self._sample_corridor(start, goal, width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n                # Nearest search\n                nearest = self._nearest_hashed(grid_a, tree_a, leaders_a, x_rand)\n                if nearest is None:\n                    continue\n\n                # Progressive step shrinking to secure a feasible edge\n                candidate = self._first_valid_step(nearest.position, x_rand, self.step_size, obstacles, is_3d)\n                if candidate is None:\n                    continue\n\n                # Avoid min move and duplicates, throttle saturated cells\n                if self._dist(nearest.position, candidate) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid_a, candidate, self.step_size * self.dupe_radius_ratio):\n                    continue\n                kcell = self._grid_key(candidate)\n                if cell_count_a.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n\n                # Heuristic scoring (cost-to-come + heuristic + bridge gap)\n                g_new = nearest.cost + self._dist(nearest.position, candidate)\n                h_new = self._dist(candidate, root_other)\n                other_near = self._nearest_hashed(grid_b, tree_b, leaders_b, candidate)\n                gap = self._dist(candidate, other_near.position) if other_near is not None else h_new\n                score = g_new + self.h_weight * h_new + self.bridge_weight * gap\n\n                if score < best_score:\n                    best_score = score\n                    best_parent = nearest\n                    best_newpos = candidate\n\n            if best_parent is None:\n                continue\n\n            # Final checks before insertion (both checks)\n            if not self._in_bounds(best_newpos):\n                continue\n            if self._is_in_obstacle(best_newpos, obstacles, is_3d):\n                continue\n            if not self._is_edge_free_cached(best_parent.position, best_newpos, obstacles, is_3d):\n                continue\n\n            # Insert node and edge\n            new_cost = best_parent.cost + self._dist(best_parent.position, best_newpos)\n            new_node = Node(best_newpos, parent=best_parent, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((best_parent, new_node))\n            self._grid_add(grid_a, new_node)\n            kc = self._grid_key(new_node.position)\n            cell_count_a[kc] = cell_count_a.get(kc, 0) + 1\n            if len(tree_a) % self.leader_stride == 0:\n                leaders_a.append(new_node)\n\n            # Micro-rewiring in local neighborhood\n            if self.rewire_max > 0:\n                neigh = self._neighbors_local(grid_a, new_node.position, radius=max(self.step_size * 1.5, self.grid_cell * 1.5))\n                rewired = 0\n                for nb in neigh:\n                    if nb is best_parent or nb is new_node or nb.parent is None:\n                        continue\n                    # Skip if would create a trivial loop (nb being ancestor) - conservative by distance check\n                    new_cost_nb = new_node.cost + self._dist(new_node.position, nb.position)\n                    if new_cost_nb + 1e-9 < nb.cost:\n                        if self._is_edge_free_cached(new_node.position, nb.position, obstacles, is_3d):\n                            # Update edges and parent/children sets\n                            oldp = nb.parent\n                            try:\n                                edges.remove((oldp, nb))\n                            except:\n                                pass\n                            oldp.remove_child(nb)\n                            nb.cost = new_cost_nb\n                            new_node.add_child(nb)\n                            edges.append((new_node, nb))\n                            rewired += 1\n                            if rewired >= self.rewire_max:\n                                break\n\n            # Attempt direct bridge to nearest in the other tree\n            other_near = self._nearest_hashed(grid_b, tree_b, leaders_b, new_node.position)\n            if other_near is not None and self._is_edge_free_cached(new_node.position, other_near.position, obstacles, is_3d):\n                cand_path = self._extract_path(new_node, other_near)\n                cand_len = self._path_length(cand_path)\n                if cand_len < best_len:\n                    best_len = cand_len\n                    best_path = cand_path\n                    if best_found_iter < 0:\n                        best_found_iter = it\n\n            # Short guided connect growth from the other tree towards the new node\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                # Both checks and dedupe\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(grid_b, to_pos, self.step_size * self.dupe_radius_ratio):\n                    break\n                if not self._is_edge_free_cached(p.position, to_pos, obstacles, is_3d):\n                    break\n\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                edges.append((p, q))\n                self._grid_add(grid_b, q)\n                kcb = self._grid_key(q.position)\n                cell_count_b[kcb] = cell_count_b.get(kcb, 0) + 1\n                if len(tree_b) % self.leader_stride == 0:\n                    leaders_b.append(q)\n\n                # Check bridge to new_node\n                if self._is_edge_free_cached(q.position, new_node.position, obstacles, is_3d):\n                    cand_path = self._extract_path(new_node, q)\n                    cand_len = self._path_length(cand_path)\n                    if cand_len < best_len:\n                        best_len = cand_len\n                        best_path = cand_path\n                        if best_found_iter < 0:\n                            best_found_iter = it\n                    break\n\n                p = q\n                steps += 1\n\n        # Finalize result\n        if best_path is not None:\n            smooth = self._shortcut_two_pass(best_path, obstacles, is_3d, self.smoothing_iters)\n            return PlannerResult(True, smooth, start_tree + goal_tree, edges)\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # RNG\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _rand_int(self, a, b):\n        if b <= a:\n            return a\n        r = int(self._uniform(0.0, (b - a + 1)))\n        v = a + r\n        if v > b:\n            v = b\n        return v\n\n    # Geometry and distances\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / max(1e-9, d)\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Progressive step to find a valid partial move\n    def _first_valid_step(self, from_pos, toward, step, obstacles, is_3d):\n        scales = (1.0, 0.7, 0.45)\n        for s in scales:\n            cand = self._steer(from_pos, toward, step * s)\n            if not self._in_bounds(cand):\n                continue\n            if self._is_in_obstacle(cand, obstacles, is_3d):\n                continue\n            if self._is_edge_free_cached(from_pos, cand, obstacles, is_3d):\n                return cand\n        return None\n\n    # Collision and caches\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _is_edge_free_cached(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        if key in self._blocked_edges:\n            return False\n        if key in self._free_edges:\n            return True\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n        if blocked:\n            self._blocked_edges.add(key)\n            return False\n        else:\n            self._free_edges.add(key)\n            return True\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        # Rejection sampling until a free point is found\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, start, goal, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # Grid hashing and NN\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, leaders, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Limited ring search\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback to sparse leaders\n        for n in leaders:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        # Rare full scan fallback\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors_local(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        res = []\n        r2 = radius * radius\n        for n in cand:\n            d2 = 0.0\n            for i in range(self.dim):\n                di = n.position[i] - pos[i]\n                d2 += di * di\n            if d2 <= r2:\n                res.append(n)\n        return res\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d2 = 0.0\n            for i in range(self.dim):\n                di = n.position[i] - pos[i]\n                d2 += di * di\n            if d2 <= r2:\n                return True\n        return False\n\n    # Path utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _shortcut_two_pass(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        # Random shortcuts\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = self._rand_int(0, n - 3)\n            j = self._rand_int(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            if self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                continue\n            pts = pts[:i + 1] + pts[j:]\n        # Forward pass collapse\n        i = 0\n        out = [pts[0]]\n        last = pts[0]\n        while i < len(pts) - 1:\n            j = i + 1\n            far = j\n            while j < len(pts) and not self._is_edge_in_obstacle(last, pts[j], obstacles, is_3d, self.edge_res):\n                far = j\n                j += 1\n            last = pts[far]\n            out.append(last)\n            i = far\n        pts = out\n        # Backward pass collapse\n        pts_rev = list(reversed(pts))\n        i = 0\n        out2 = [pts_rev[0]]\n        last = pts_rev[0]\n        while i < len(pts_rev) - 1:\n            j = i + 1\n            far = j\n            while j < len(pts_rev) and not self._is_edge_in_obstacle(last, pts_rev[j], obstacles, is_3d, self.edge_res):\n                far = j\n                j += 1\n            last = pts_rev[far]\n            out2.append(last)\n            i = far\n        pts2 = list(reversed(out2))\n        # Ensure endpoints preserved\n        if pts2[0] != path[0]:\n            pts2[0] = path[0]\n        if pts2[-1] != path[-1]:\n            pts2[-1] = path[-1]\n        return pts2",
          "objective": -17.10599,
          "time_improvement": -1.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1651.0,
          "node_improvement": 76.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04169440269470215,
                    "num_nodes_avg": 145.7,
                    "path_length_avg": 164.18962581172133,
                    "smoothness_avg": 0.05597289563579705,
                    "success_improvement": 0.0,
                    "time_improvement": -63.515185175835,
                    "node_improvement": 63.30899017879628,
                    "length_improvement": 10.005064341480855,
                    "smoothness_improvement": 776.0973637885255,
                    "objective_score": -9.171030128919359
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07090482711791993,
                    "num_nodes_avg": 214.8,
                    "path_length_avg": 240.9978461120285,
                    "smoothness_avg": 0.10840343636837013,
                    "success_improvement": 0.0,
                    "time_improvement": 55.73907047648643,
                    "node_improvement": 85.56742592219311,
                    "length_improvement": 19.547982229422455,
                    "smoothness_improvement": 2689.2984975973686,
                    "objective_score": 41.89700296858624
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04691793918609619,
                    "num_nodes_avg": 171.2,
                    "path_length_avg": 125.86461034006433,
                    "smoothness_avg": 0.1248903892443423,
                    "success_improvement": 0.0,
                    "time_improvement": 4.349911902302689,
                    "node_improvement": 78.23267641449459,
                    "length_improvement": 16.406718840812655,
                    "smoothness_improvement": 1488.5965327384135,
                    "objective_score": 18.591987538870466
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "H-Flash BiRRT: a heuristic-queued, hash-accelerated bidirectional RRT that minimizes planning time via ring-capped spatial hashing for near-constant NN lookups, a priority beam to pick the most bridge-progressing sample, adaptive corridor sampling, cross-tree duplicate suppression, and an O(1) edge store. A blocked-segment cache memoizes colliding cell-to-cell rays to avoid repeated expensive edge checks. Growth commits only fully validated, short multi-steps and attempts a brief directed connect; on the first bridge, a bounded shortcut-collapse returns a smooth path quickly.",
          "planning_mechanism": "Mechanism: Build two trees from start/goal with coarse spatial grids and a blocked-edge hash. Each iteration picks the smaller tree, generates a small beam (goal/corridor/uniform), steers once, validates node+edge, and keeps the candidate that minimizes distance to the other tree. It then performs a short multi-step extend toward that target (per-step checks and cross-tree de-dup) and tries a direct bridge or a few greedy connect steps from the opposite tree. Collision memoization, ring-limited NN, and strict duplicate suppression cut expansions and checks. On bridge, extract and shortcut-collapse the path and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        for c in self.children:\n            if c is child:\n                child.parent = self\n                return\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=8.0,\n                 goal_bias=0.22,\n                 corridor_bias=0.55,\n                 beam_k=3,\n                 extend_steps=2,\n                 connect_steps=5,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 smoothing_iters=20,\n                 min_sep_ratio=0.25,\n                 dupe_radius_ratio=0.6,\n                 max_nodes=6000):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.extend_steps = extend_steps\n        self.connect_steps = connect_steps\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.smoothing_iters = smoothing_iters\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.max_nodes = max_nodes\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Grid resolution and collision sampling resolution\n        diag = (sum([self.bounds[i] * self.bounds[i] for i in range(self.dim)]) ** 0.5)\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, diag / 60.0)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.5)))\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line feasibility\n        if not self._edge_collides(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start)\n            n1 = Node(self.goal, parent=n0, cost=self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            edges = [(n0, n1)]\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], edges)\n\n        # Initialize trees, grids, and structures\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n\n        edgeset = {}  # {(parent, child): True}\n        blocked_pairs = set()  # {(cell_from, cell_to)} for colliding segments\n\n        edges = []\n        nodes_total = 2\n\n        # Precompute for corridor width control\n        dsg = self._dist(self.start, self.goal)\n        c_best = float('inf')\n        base_corridor = max(self.step_size, 0.12 * diag)\n\n        for it in range(self.max_iter):\n            # Balance growth by picking the smaller tree\n            if len(tree_a) <= len(tree_b):\n                active_first = True\n            else:\n                active_first = False\n\n            if active_first:\n                T_active, T_passive = tree_a, tree_b\n                G_active, G_passive = grid_a, grid_b\n                root_other = self.goal\n            else:\n                T_active, T_passive = tree_b, tree_a\n                G_active, G_passive = grid_b, grid_a\n                root_other = self.start\n\n            # Beam of candidates; keep the best by proximity to the other tree\n            best_parent = None\n            best_new_pos = None\n            best_target = None\n            best_score = float('inf')\n\n            width = base_corridor\n            if c_best < float('inf'):\n                width = max(self.step_size, 0.25 * (c_best - dsg) + base_corridor)\n\n            for _ in range(self.beam_k):\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                elif r < self.goal_bias + self.corridor_bias:\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n                near = self._nearest_grid(G_active, T_active, x_rand)\n                if near is None:\n                    continue\n                new_pos = self._steer(near.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._dist(near.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                # cross-tree duplicate suppression\n                if self._exists_close(G_active, new_pos, self.step_size * self.dupe_radius_ratio) or \\\n                   self._exists_close(G_passive, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                if self._edge_collides(near.position, new_pos, obstacles, is_3d, blocked_pairs):\n                    continue\n\n                # Score: distance to nearest in the other tree\n                other_near = self._nearest_grid(G_passive, T_passive, new_pos)\n                if other_near is None:\n                    score = self._dist(new_pos, root_other)\n                else:\n                    score = self._dist(new_pos, other_near.position)\n                if score < best_score:\n                    best_score = score\n                    best_parent = near\n                    best_new_pos = new_pos\n                    best_target = x_rand\n\n            if best_parent is None:\n                continue\n\n            # Multi-step extend toward target; commit only validated steps\n            last_new = None\n            cur = best_parent\n            steps_done = 0\n            while steps_done < self.extend_steps:\n                to_pos = self._steer(cur.position, best_target, self.step_size)\n                if self._dist(cur.position, to_pos) < self.step_size * self.min_sep_ratio:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(G_active, to_pos, self.step_size * self.dupe_radius_ratio) or \\\n                   self._exists_close(G_passive, to_pos, self.step_size * self.dupe_radius_ratio):\n                    break\n                if self._edge_collides(cur.position, to_pos, obstacles, is_3d, blocked_pairs):\n                    break\n\n                # Add node (both node and edge validated)\n                new_cost = cur.cost + self._dist(cur.position, to_pos)\n                node_new = Node(to_pos, parent=cur, cost=new_cost)\n                cur.add_child(node_new)\n                T_active.append(node_new)\n                self._grid_add(G_active, node_new)\n                edgeset[(cur, node_new)] = True\n                last_new = node_new\n                cur = node_new\n                steps_done += 1\n                nodes_total += 1\n                if nodes_total >= self.max_nodes:\n                    # Try to finalize if possible: attempt bridge from last_new\n                    other_near = self._nearest_grid(G_passive, T_passive, last_new.position)\n                    if other_near is not None and not self._edge_collides(last_new.position, other_near.position, obstacles, is_3d, blocked_pairs):\n                        path = self._extract_path(last_new, other_near)\n                        c_best = self._path_length(path)\n                        path = self._shortcut_collapse(path, obstacles, is_3d, self.smoothing_iters)\n                        edges = list(edgeset.keys())\n                        return PlannerResult(True, path, tree_a + tree_b, edges)\n                    edges = list(edgeset.keys())\n                    return PlannerResult(False, [], tree_a + tree_b, edges)\n\n            if last_new is None:\n                continue\n\n            # Try direct bridge to nearest node in the other tree\n            other_near = self._nearest_grid(G_passive, T_passive, last_new.position)\n            if other_near is not None and not self._edge_collides(last_new.position, other_near.position, obstacles, is_3d, blocked_pairs):\n                path = self._extract_path(last_new, other_near)\n                c_best = self._path_length(path)\n                path = self._shortcut_collapse(path, obstacles, is_3d, self.smoothing_iters)\n                edges = list(edgeset.keys())\n                return PlannerResult(True, path, tree_a + tree_b, edges)\n\n            # Short greedy connect from the other tree toward last_new\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, last_new.position, self.step_size)\n                if self._dist(p.position, to_pos) < self.step_size * self.min_sep_ratio:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(G_passive, to_pos, self.step_size * self.dupe_radius_ratio) or \\\n                   self._exists_close(G_active, to_pos, self.step_size * self.dupe_radius_ratio):\n                    break\n                if self._edge_collides(p.position, to_pos, obstacles, is_3d, blocked_pairs):\n                    break\n\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                T_passive.append(q)\n                self._grid_add(G_passive, q)\n                edgeset[(p, q)] = True\n                nodes_total += 1\n                p = q\n                steps += 1\n\n                # After each step, check if we can bridge now\n                if not self._edge_collides(last_new.position, p.position, obstacles, is_3d, blocked_pairs):\n                    path = self._extract_path(last_new, p)\n                    c_best = self._path_length(path)\n                    path = self._shortcut_collapse(path, obstacles, is_3d, self.smoothing_iters)\n                    edges = list(edgeset.keys())\n                    return PlannerResult(True, path, tree_a + tree_b, edges)\n\n                if nodes_total >= self.max_nodes:\n                    edges = list(edgeset.keys())\n                    return PlannerResult(False, [], tree_a + tree_b, edges)\n\n        edges = list(edgeset.keys())\n        return PlannerResult(False, [], tree_a + tree_b, edges)\n\n    # RNG\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry and bounds\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision and memoization\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_collides(self, a, b, obstacles, is_3d, blocked_pairs=None):\n        # Check memoized blocked cell-pair\n        if blocked_pairs is not None:\n            ka = self._grid_key(a)\n            kb = self._grid_key(b)\n            key = (ka, kb) if ka <= kb else (kb, ka)\n            if key in blocked_pairs:\n                return True\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                if blocked_pairs is not None:\n                    ka = self._grid_key(a)\n                    kb = self._grid_key(b)\n                    key = (ka, kb) if ka <= kb else (kb, ka)\n                    blocked_pairs.add(key)\n                return True\n        return False\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # Grid and neighbor queries\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Try limited rings for near-constant time\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback: sample a small subset to approximate nearest (avoid full scan)\n        if len(tree) == 0:\n            return None\n        trials = min(64, len(tree))\n        for _ in range(trials):\n            idx = int(self._rand() * len(tree))\n            n = tree[idx]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Paths and smoothing\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _shortcut_collapse(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        # Greedy forward collapse\n        i = 0\n        while i + 2 < len(pts):\n            if not self._edge_collides(pts[i], pts[i + 2], obstacles, is_3d):\n                del pts[i + 1]\n            else:\n                i += 1\n        # Random shortcuts\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_collides(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n        return pts",
          "objective": -15.96286,
          "time_improvement": 12.0,
          "length_improvement": 6.0,
          "smoothness_improvement": 1703.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.018918633460998535,
                    "num_nodes_avg": 50.2,
                    "path_length_avg": 183.360286863069,
                    "smoothness_avg": 0.051248792890763575,
                    "success_improvement": 0.0,
                    "time_improvement": 25.805775986281397,
                    "node_improvement": 87.35834802316798,
                    "length_improvement": -0.5026787593268492,
                    "smoothness_improvement": 702.154897275447,
                    "objective_score": 10.950900026665543
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.040856456756591795,
                    "num_nodes_avg": 87.7,
                    "path_length_avg": 252.49636907688236,
                    "smoothness_avg": 0.10940072312596907,
                    "success_improvement": 0.0,
                    "time_improvement": 74.49616864481483,
                    "node_improvement": 94.10737082577437,
                    "length_improvement": 15.709444297121635,
                    "smoothness_improvement": 2714.9594041870064,
                    "objective_score": 45.349314192652464
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08023626804351806,
                    "num_nodes_avg": 68.1,
                    "path_length_avg": 145.02662398669784,
                    "smoothness_avg": 0.14076768328385236,
                    "success_improvement": 0.0,
                    "time_improvement": -63.57508961662312,
                    "node_improvement": 91.34138588684043,
                    "length_improvement": 3.6802217737547083,
                    "smoothness_improvement": 1690.5545409810422,
                    "objective_score": -8.4116211158289
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "HF-IBiRRT*-Lite (Heuristic-Filtered Informed BiRRT* with Lazy Bridge and Sparse Rewiring). Two trees grow from start and goal with a small guided beam. Each candidate extension uses a grid near-set and heuristic lower bounds to prune expensive parents before any edge checks, then selects the cheapest feasible parent (with limited LOS ancestor compression). A light RRT*-style local rewiring improves costs in the vicinity. A lazy, single-edge bridge attempts to connect the trees. After a first path, an informed ellipse guides sampling and a bounded shortcut finalizes the solution. This design minimizes collision checks, curbs duplicates, and shortens paths while reducing planning time.",
          "planning_mechanism": "Alternate expansions between start- and goal-rooted trees. For each beam sample: (1) sample guided toward the opposite root or within an informed ellipse (if a path exists), (2) find a small near-set via a grid, (3) steer one step and reject near-duplicates/out-of-bounds/point-colliding nodes, (4) select the best parent among pruned candidates (cost + heuristic bound) with a single edge check, plus limited ancestor LOS compression, (5) insert node and sparsely rewire cheaper neighbors, (6) attempt a lazy direct line-of-sight connect to the other tree\u2019s nearest node; on success, extract and shortcut the path and return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        beam_width=3,\n        goal_bias=0.2,\n        grid_cell_factor=1.0,\n        min_separation_factor=0.6,\n        near_radius_factor=2.5,\n        rewire_radius_factor=2.5,\n        k_near=12,\n        los_lookback_depth=6,\n        shortcut_attempts=80,\n        per_cell_cap=14,\n        edge_cache_capacity=12000,\n        edge_cache_quant_factor=0.5,\n        parent_prune_slack=1.02\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.min_separation_factor = min_separation_factor\n        self.near_radius_factor = near_radius_factor\n        self.rewire_radius_factor = rewire_radius_factor\n        self.k_near = k_near\n        self.los_lookback_depth = los_lookback_depth\n        self.shortcut_attempts = shortcut_attempts\n        self.per_cell_cap = per_cell_cap\n        self.edge_cache_capacity = edge_cache_capacity\n        self.edge_cache_quant_factor = edge_cache_quant_factor\n        self.parent_prune_slack = parent_prune_slack\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.start = map.start\n        self.goal = map.goal\n        self.obstacles = map.obstacles\n\n        # Derived parameters\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n        self.near_radius = max(self.step_size * self.near_radius_factor, self.min_separation * 1.2)\n        self.rewire_radius = max(self.step_size * self.rewire_radius_factor, self.min_separation * 1.2)\n        self.ecache = {}\n        self._tick = 0\n        self._last_prune_tick = 0\n        self.ecache_quant = max(0.25, self.step_size * self.edge_cache_quant_factor)\n\n        # Quick direct check\n        if self._edge_free(self.start, self.goal):\n            return PlannerResult(True, [self.start, self.goal], [], [])\n\n        nodes = []\n        edges = []\n\n        start_root = Node(self.start, parent=None, cost=0.0)\n        goal_root = Node(self.goal, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n\n        grid_a = {}\n        grid_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n\n        incumbent_len = None\n        best_path = None\n\n        for _ in range(self.max_iter):\n            for active_tree, active_grid, other_tree, other_grid, attractor in [\n                (tree_a, grid_a, tree_b, grid_b, self.goal),\n                (tree_b, grid_b, tree_a, grid_a, self.start),\n            ]:\n                for _b in range(self.beam_width):\n                    sample = self._guided_sample(attractor, incumbent_len)\n                    if sample is None:\n                        continue\n\n                    nearest = self._nearest_in_grid(active_grid, sample)\n                    if nearest is None:\n                        continue\n\n                    new_pos = self._steer(nearest.position, sample)\n                    if not self._within_bounds(new_pos):\n                        continue\n                    if self._in_obstacle(new_pos):\n                        continue\n                    # Early duplicate suppression before any edge checks\n                    if self._has_nearby(active_grid, new_pos, self.min_separation):\n                        continue\n\n                    # Candidate parents: near-set plus limited LOS ancestors of nearest\n                    near_set = self._near_in_grid(active_grid, new_pos, self.near_radius, self.k_near, max_ring=5)\n                    cand_set = list(near_set)\n                    cur = nearest\n                    depth = 0\n                    while cur is not None and depth < self.los_lookback_depth:\n                        cand_set.append(cur)\n                        cur = cur.parent\n                        depth += 1\n\n                    parent = self._choose_parent_pruned(cand_set, new_pos, attractor, incumbent_len)\n                    if parent is None:\n                        continue  # no feasible parent found under pruning\n\n                    # Per-cell cap with cost gating\n                    cell_key = self._cell_of(new_pos)\n                    bucket = active_grid.get(cell_key)\n                    if bucket and len(bucket) >= self.per_cell_cap:\n                        best_bucket_cost = min(n.cost for n in bucket)\n                        cand_cost = parent.cost + self._distance(parent.position, new_pos)\n                        if cand_cost >= best_bucket_cost - 1e-9:\n                            continue\n\n                    new_cost = parent.cost + self._distance(parent.position, new_pos)\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node)\n\n                    # Sparse local rewiring\n                    neighbors = self._near_in_grid(active_grid, new_pos, self.rewire_radius, self.k_near, max_ring=5)\n                    self._rewire_neighbors(new_node, neighbors, attractor, incumbent_len, edges)\n\n                    # Lazy direct connect to the other tree\n                    other_near = self._nearest_in_grid(other_grid, new_node.position)\n                    if other_near is not None and self._edge_free(new_node.position, other_near.position):\n                        path_a = self._path_from_root(new_node)\n                        path_b = self._path_from_root(other_near)\n                        if path_a and path_b and path_a[-1] == path_b[-1]:\n                            path_b = path_b[:-1]\n                        raw_path = path_a + path_b[::-1]\n                        # Shortcut smoothing (bounded)\n                        smoothed = self._shortcut(raw_path, attempts=self.shortcut_attempts)\n                        final_path = smoothed if smoothed else raw_path\n                        best_path = final_path\n                        incumbent_len = self._path_length(final_path)\n                        return PlannerResult(True, final_path, nodes, edges)\n\n        if best_path is not None:\n            return PlannerResult(True, best_path, nodes, edges)\n        return PlannerResult(False, [], nodes, edges)\n\n    # -------- Geometry and helpers --------\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._distance(a, b)\n        if d <= 1e-12:\n            return a\n        if d <= self.step_size:\n            return b\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n\n    def _heuristic(self, p, target):\n        return self._distance(p, target)\n\n    def _path_from_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._distance(path[i - 1], path[i])\n        return total\n\n    # -------- Sampling --------\n    def _guided_sample(self, attractor, incumbent_len):\n        # Try a few attempts to avoid heavy rejection\n        for _ in range(14):\n            if incumbent_len is not None:\n                p = self._ellipse_sample(self.start, self.goal, incumbent_len * 1.02)\n                if p is None:\n                    # fallback blend toward attractor\n                    p = self._blend_to_target(attractor, alpha=0.25)\n            else:\n                if self._rand() < self.goal_bias:\n                    p = attractor\n                else:\n                    p = self._blend_to_target(attractor, alpha=0.2)\n            if self._within_bounds(p) and not self._in_obstacle(p):\n                return p\n        # Hard fallback: attractor if valid\n        return attractor if self._within_bounds(attractor) and not self._in_obstacle(attractor) else None\n\n    def _blend_to_target(self, target, alpha=0.2):\n        rnd = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n        return tuple(alpha * target[i] + (1.0 - alpha) * rnd[i] for i in range(self.dims))\n\n    def _ellipse_sample(self, f1, f2, max_sum_dist):\n        cx = tuple(0.5 * (f1[i] + f2[i]) for i in range(self.dims))\n        half = 0.5 * max_sum_dist\n        ext = [half] * self.dims\n        for _ in range(10):\n            p = tuple(cx[i] + self._rand_range(-ext[i], ext[i]) for i in range(self.dims))\n            if not self._within_bounds(p):\n                continue\n            if self._distance(p, f1) + self._distance(p, f2) <= max_sum_dist and not self._in_obstacle(p):\n                return p\n        return None\n\n    # -------- Spatial hash grid --------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    def _nearest_in_grid(self, grid, pos, max_ring=5):\n        cell = self._cell_of(pos)\n        best = None\n        best_d = 1e100\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best_d = d\n                                        best = n\n                                        found = True\n                if found:\n                    return best\n        else:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best_d = d\n                                    best = n\n                                    found = True\n                if found:\n                    return best\n        # Rare fallback: sample a few buckets to avoid O(N)\n        for bucket in list(grid.values())[:6]:\n            for n in bucket:\n                d = self._distance(n.position, pos)\n                if d < best_d:\n                    best_d = d\n                    best = n\n        return best\n\n    def _near_in_grid(self, grid, pos, radius, k, max_ring=5):\n        cell = self._cell_of(pos)\n        cand = []\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        visited = set()\n        # Expand rings up to the radius footprint\n        for ring in range(0, min(max_ring, r_cells) + 1):\n            if self.is_3d:\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            key = (cell[0] + dx, cell[1] + dy, cell[2] + dz)\n                            if key in visited:\n                                continue\n                            visited.add(key)\n                            bucket = grid.get(key)\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d <= radius:\n                                        cand.append((d, n))\n            else:\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        key = (cell[0] + dx, cell[1] + dy)\n                        if key in visited:\n                            continue\n                        visited.add(key)\n                        bucket = grid.get(key)\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d <= radius:\n                                    cand.append((d, n))\n        cand.sort(key=lambda x: x[0])\n        res = [n for _, n in cand[:k]]\n        return res\n\n    # -------- Obstacles and collision --------\n    def _in_obstacle(self, pos):\n        if self.is_3d:\n            px, py, pz = pos\n            for obs in self.obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in self.obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_key(self, a, b):\n        qa = tuple(int(a[i] / self.ecache_quant) for i in range(self.dims))\n        qb = tuple(int(b[i] / self.ecache_quant) for i in range(self.dims))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_free(self, a, b):\n        key = self._edge_key(a, b)\n        hit = self.ecache.get(key)\n        if hit is not None:\n            self._tick += 1\n            self.ecache[key] = (hit[0], self._tick)\n            return hit[0]\n        free = not self._segment_hits_obstacle(a, b)\n        self._tick += 1\n        self.ecache[key] = (free, self._tick)\n        if len(self.ecache) - self._last_prune_tick > self.edge_cache_capacity:\n            self._prune_cache()\n        return free\n\n    def _prune_cache(self):\n        if not self.ecache:\n            return\n        # Remove the oldest ~35%\n        items = sorted(self.ecache.items(), key=lambda kv: kv[1][1])\n        cut = max(1, int(len(items) * 0.35))\n        for i in range(cut):\n            k = items[i][0]\n            if k in self.ecache:\n                del self.ecache[k]\n        self._last_prune_tick = len(self.ecache)\n\n    def _segment_hits_obstacle(self, a, b):\n        dist = self._distance(a, b)\n        resolution = max(0.5, min(1.0, self.step_size * 0.5))\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(self.dims))\n            if self._in_obstacle(p):\n                return True\n        return False\n\n    # -------- Parent selection with heuristic pruning --------\n    def _choose_parent_pruned(self, candidates, new_pos, attractor, incumbent_len):\n        best_parent = None\n        best_cost = 1e100\n        # Pre-prune duplicates in candidates while preserving order\n        seen = set()\n        unique = []\n        for n in candidates:\n            if n is None:\n                continue\n            if id(n) in seen:\n                continue\n            seen.add(id(n))\n            unique.append(n)\n        for cand in unique:\n            # Lower bound on final solution through this candidate\n            lb = cand.cost + self._distance(cand.position, new_pos)\n            if incumbent_len is not None:\n                if lb + self._heuristic(new_pos, attractor) >= incumbent_len * self.parent_prune_slack:\n                    continue\n            # Edge check only after bound passes\n            if not self._edge_free(cand.position, new_pos):\n                continue\n            ccost = cand.cost + self._distance(cand.position, new_pos)\n            if ccost < best_cost - 1e-12:\n                best_cost = ccost\n                best_parent = cand\n        return best_parent\n\n    # -------- Rewiring (sparse) --------\n    def _rewire_neighbors(self, new_node, neighbors, attractor, incumbent_len, edges):\n        for nb in neighbors:\n            if nb is new_node or nb is new_node.parent:\n                continue\n            # Heuristic prune: if even optimistic cost cannot beat current, skip\n            potential = new_node.cost + self._distance(new_node.position, nb.position)\n            if potential >= nb.cost - 1e-12:\n                continue\n            if incumbent_len is not None:\n                if potential + self._heuristic(nb.position, attractor) >= incumbent_len * self.parent_prune_slack:\n                    continue\n            if not self._edge_free(new_node.position, nb.position):\n                continue\n            # Rewire nb to new_node\n            old_parent = nb.parent\n            if old_parent is not None:\n                # Remove old edge in edges list\n                for i in range(len(edges)):\n                    if edges[i][0] is old_parent and edges[i][1] is nb:\n                        del edges[i]\n                        break\n                # Update children list\n                try:\n                    old_parent.children.remove(nb)\n                except:\n                    pass\n            new_node.add_child(nb)\n            nb.parent = new_node\n            edges.append((new_node, nb))\n            # Update subtree costs\n            delta = potential - nb.cost\n            self._propagate_cost(nb, delta)\n\n    def _propagate_cost(self, node, delta):\n        # Update node and all descendants incrementally\n        node.cost += delta\n        stack = list(node.children)\n        while stack:\n            c = stack.pop()\n            # parent-child edge length remains the same; just add delta\n            c.cost += delta\n            if c.children:\n                stack.extend(c.children)\n\n    # -------- Shortcut smoothing --------\n    def _shortcut(self, path, attempts=80):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        tries = 0\n        i = 0\n        while i < len(pts) - 2 and tries < attempts:\n            j = len(pts) - 1\n            improved = False\n            while j > i + 1:\n                if self._edge_free(pts[i], pts[j]):\n                    del pts[i + 1:j]\n                    improved = True\n                    break\n                j -= 1\n            if not improved:\n                i += 1\n            tries += 1\n        return pts\n\n    # -------- Random helpers --------\n    def _rand(self):\n        return random.random()\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()",
          "objective": -15.29457,
          "time_improvement": -7.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1466.0,
          "node_improvement": 91.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.05977098941802979,
                    "num_nodes_avg": 59.7,
                    "path_length_avg": 165.86389469314045,
                    "smoothness_avg": 0.0480746053978015,
                    "success_improvement": 0.0,
                    "time_improvement": -134.407109136351,
                    "node_improvement": 84.96600352556032,
                    "length_improvement": 9.087371037086843,
                    "smoothness_improvement": 652.4719701521254,
                    "objective_score": -31.607350267892567
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.058643150329589847,
                    "num_nodes_avg": 73.3,
                    "path_length_avg": 229.250699023299,
                    "smoothness_avg": 0.09313272305893162,
                    "success_improvement": 0.0,
                    "time_improvement": 63.3931785848922,
                    "node_improvement": 95.07491769132568,
                    "length_improvement": 23.469518050521575,
                    "smoothness_improvement": 2296.372045095304,
                    "objective_score": 44.581524631257125
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.025104594230651856,
                    "num_nodes_avg": 65.9,
                    "path_length_avg": 122.93782947450457,
                    "smoothness_avg": 0.12190629617130148,
                    "success_improvement": 0.0,
                    "time_improvement": 48.8200741235798,
                    "node_improvement": 91.62110616656072,
                    "length_improvement": 18.35054733338924,
                    "smoothness_improvement": 1450.639089112173,
                    "objective_score": 32.90954608266835
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "FLASH-BiRRT*: Fast LRU-cached, Adaptive-Radius, Sparse Heuristic Bi-directional RRT*. It grows two sparse, cost-consistent trees with local RRT* rewiring and an adaptive neighbor radius, guided by goal/informed/bridge-biased sampling. A hashed grid with frontier-assisted nearest search bounds lookup cost, per-cell saturation gates and duplicate suppression curb redundant nodes, and a quantized LRU edge-collision memo plus blocked cell-pair memory avoids repeated expensive checks. Early visibility pruning and light shortcutting return short, smooth paths quickly.",
          "planning_mechanism": "Alternate expanding start/goal trees. Each iteration samples a target (informed ellipse after an incumbent path, else goal/bridge/uniform), selects a nearest parent via grid rings with frontier fallback, and steers one step. After validating node and edge, it picks the cheapest feasible parent in a local neighborhood, inserts the node, and rewires cheaper neighbors using queue-based downstream cost updates. It then attempts a low-cost bridge to nearby nodes of the opposite tree while skipping remembered blocked cell-pairs. On success, it merges the two root-to-meet paths, greedily collapses line-of-sight segments, makes a few random shortcuts, and returns.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        # Maintain tree consistency\n        for c in self.children:\n            if c is child:\n                return\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        i = 0\n        n = len(self.children)\n        while i < n:\n            if self.children[i] is child:\n                self.children.pop(i)\n                return\n            i += 1\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=8.0,\n                 collision_step=1.0,\n                 beam_k=1,\n                 goal_bias=0.25,\n                 bridge_bias=0.25,\n                 informed_bias=0.7,\n                 grid_cell=None,\n                 neighbor_radius_factor=2.6,\n                 connect_k=6,\n                 connect_radius_factor=3.0,\n                 dupe_radius_ratio=0.45,\n                 cell_expand_limit=2,\n                 cell_gate_relax=1.08,\n                 prune_margin=1.02,\n                 smoothing_attempts=28,\n                 edge_cache_limit=60000):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.collision_step = float(collision_step)\n        self.beam_k = int(beam_k)\n        self.goal_bias = float(goal_bias)\n        self.bridge_bias = float(bridge_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell = grid_cell\n        self.neighbor_radius_factor = float(neighbor_radius_factor)\n        self.connect_k = int(connect_k)\n        self.connect_radius_factor = float(connect_radius_factor)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.cell_expand_limit = int(cell_expand_limit)\n        self.cell_gate_relax = float(cell_gate_relax)\n        self.prune_margin = float(prune_margin)\n        self.smoothing_attempts = int(smoothing_attempts)\n        self.edge_cache_limit = int(edge_cache_limit)\n\n        self.dim = 2\n        self.bounds = None\n\n        # Edge cache structures\n        self.edge_cache = None\n        self.edge_keys = None\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self.inv_cache_bin = 1.0\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Initialize grid/edge cache parameters\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, 0.5 * self.step_size))\n        self.cache_bin = max(0.5, 0.5 * self.edge_res)\n        self.inv_cache_bin = 1.0 / self.cache_bin\n        self.edge_cache = {}\n        self.edge_keys = []\n\n        # Basic validity\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Direct connection\n        if not self._edge_blocked_memo(start, goal, obstacles, is_3d):\n            n0 = Node(start, None, 0.0)\n            n1 = Node(goal, n0, self._dist(start, goal))\n            n0.add_child(n1)\n            nodes = [n0, n1]\n            edges = [(n0, n1)]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # Initialize trees, grids, and auxiliaries\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n\n        # Per-cell expand throttles and gates\n        expand_a, expand_b = {}, {}\n        bestg_a, bestg_b = {}, {}\n\n        # Frontier buffers (recent nodes) to accelerate nearest fallback\n        frontier_a, frontier_b = [start_root], [goal_root]\n        frontier_cap = 128\n\n        # Blocked connection cell-pairs memory\n        blocked_pairs = {}\n\n        best_path_len = float('inf')\n        dupe_radius = max(0.5, self.dupe_radius_ratio * self.step_size)\n\n        for it in range(self.max_iter):\n            # Alternate expansion between trees\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            expands1 = expand_a if active_start else expand_b\n            bestg1 = bestg_a if active_start else bestg_b\n            other_root = goal if active_start else start\n            frontier1 = frontier_a if active_start else frontier_b\n            frontier2 = frontier_b if active_start else frontier_a\n\n            # Adaptive neighbor radii (shrinks with tree size)\n            n1 = max(1, len(tree1))\n            shrink = 1.0 / (1.0 + 0.01 * n1)\n            parent_radius = max(1.2 * self.step_size, self.neighbor_radius_factor * self.step_size * shrink)\n            connect_radius = max(1.5 * self.step_size, self.connect_radius_factor * self.step_size * (0.8 + 0.2 * shrink))\n\n            best = None  # (parent, new_pos, fscore, onear)\n            for _ in range(self.beam_k):\n                xr = None\n                r = self._rand()\n                if best_path_len < float('inf') and r < self.informed_bias:\n                    xr = self._sample_informed(best_path_len, obstacles, is_3d, start, goal)\n                else:\n                    r2 = self._rand()\n                    if r2 < self.goal_bias:\n                        xr = other_root\n                    elif r2 < self.goal_bias + self.bridge_bias:\n                        seed = self._sample_free(obstacles, is_3d)\n                        onn = self._nearest(grid2, frontier2, seed)\n                        xr = onn.position if onn is not None else seed\n                    else:\n                        xr = self._sample_free(obstacles, is_3d)\n\n                near = self._nearest(grid1, frontier1, xr)\n                if near is None:\n                    continue\n                new_pos = self._steer(near.position, xr, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._exists_close(grid1, new_pos, dupe_radius):\n                    continue\n\n                cell = self._grid_key(new_pos)\n                if expands1.get(cell, 0) >= self.cell_expand_limit:\n                    continue\n\n                parent = self._choose_parent(new_pos, grid1, frontier1, parent_radius, obstacles, is_3d)\n                if parent is None:\n                    continue\n\n                # Edge collision check before considering\n                if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n                # Per-cell cost gate\n                prevg = bestg1.get(cell, float('inf'))\n                if new_cost > prevg * self.cell_gate_relax:\n                    continue\n\n                # Incumbent-aware prune by f = g + h\n                h = self._dist(new_pos, other_root)\n                if best_path_len < float('inf'):\n                    if new_cost + h >= best_path_len * self.prune_margin:\n                        continue\n\n                # Heuristic bridge-hint\n                onear = self._nearest(grid2, frontier2, new_pos)\n                bhint = self._dist(new_pos, onear.position) if onear is not None else h\n                fscore = new_cost + h + 0.25 * bhint\n\n                if best is None or fscore < best[2]:\n                    best = (parent, new_pos, fscore, onear)\n\n            if best is None:\n                continue\n\n            parent, new_pos, _, _ = best\n\n            # Final safety checks before insertion\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent, parent.cost + self._dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            self._grid_add(grid1, new_node)\n            edges.append((parent, new_node))\n            frontier1.append(new_node)\n            if len(frontier1) > frontier_cap:\n                # Drop a chunk from the front to avoid O(n) pop per insertion\n                del frontier1[:16]\n\n            # Update cell gates\n            cell = self._grid_key(new_pos)\n            expands1[cell] = expands1.get(cell, 0) + 1\n            if new_node.cost < bestg1.get(cell, float('inf')):\n                bestg1[cell] = new_node.cost\n\n            # Local RRT* rewiring\n            self._rewire(new_node, grid1, parent_radius, obstacles, is_3d, edges)\n\n            # Attempt connection to the opposite tree\n            near_other = self._nearby(grid2, new_node.position, connect_radius, frontier2)\n            if len(near_other) > self.connect_k:\n                near_other = self._k_nearest(near_other, new_node.position, self.connect_k)\n\n            best_bridge = None  # (other_node, total_cost)\n            for q in near_other:\n                kp = (self._grid_key(new_node.position), self._grid_key(q.position))\n                if blocked_pairs.get(kp, 0) >= 2:\n                    continue\n                # Must pass edge collision check\n                if not self._edge_blocked_memo(new_node.position, q.position, obstacles, is_3d):\n                    tc = new_node.cost + self._dist(new_node.position, q.position) + q.cost\n                    if best_bridge is None or tc < best_bridge[1]:\n                        best_bridge = (q, tc)\n                else:\n                    blocked_pairs[kp] = blocked_pairs.get(kp, 0) + 1\n\n            if best_bridge is not None:\n                other_hit = best_bridge[0]\n                # Merge and refine\n                if active_start:\n                    path = self._merge_paths(new_node, other_hit)\n                else:\n                    path = self._merge_paths(other_hit, new_node)\n                # Greedy LOS collapse then a few shortcuts\n                path = self._los_collapse(path, obstacles, is_3d)\n                path = self._shortcut(path, obstacles, is_3d, self.smoothing_attempts)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # ------------ Utilities ------------\n    def _rand(self):\n        if not hasattr(self, \"_rng\"):\n            self._rng = 2463534242\n        # Xorshift32\n        x = self._rng & 0xFFFFFFFF\n        x ^= (x << 13) & 0xFFFFFFFF\n        x ^= (x >> 17) & 0xFFFFFFFF\n        x ^= (x << 5) & 0xFFFFFFFF\n        self._rng = x & 0xFFFFFFFF\n        return (self._rng & 0xFFFFFFFF) / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] * self.inv_cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] * self.inv_cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        st = self.edge_cache.get(key)\n        if st is not None:\n            return st == 1\n        blocked = self._edge_blocked(a, b, obstacles, is_3d)\n        # Insert with simple LRU-like eviction\n        self.edge_cache[key] = 1 if blocked else 2\n        self.edge_keys.append(key)\n        if len(self.edge_keys) > self.edge_cache_limit:\n            # Evict oldest 25%\n            cut = int(self.edge_cache_limit * 0.25)\n            for i in range(cut):\n                k = self.edge_keys[i]\n                if k in self.edge_cache:\n                    del self.edge_cache[k]\n            self.edge_keys = self.edge_keys[cut:]\n        return blocked\n\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, frontier, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Search a few rings to avoid expensive fallbacks\n        for r in range(0, 3):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Frontier-assisted fallback (bounded)\n        if frontier:\n            # sample up to 16 recent nodes\n            limit = 16 if len(frontier) >= 16 else len(frontier)\n            i = 0\n            while i < limit:\n                n = frontier[-1 - i]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n                i += 1\n            if best is not None:\n                return best\n        # Last resort: None (skip this sample)\n        return None\n\n    def _nearby(self, grid, pos, radius, frontier):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._collect_ring(grid, key, r_cells)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n        if out:\n            return out\n        # Fallback to frontier subset\n        if frontier:\n            return list(frontier[-min(16, len(frontier)):])\n        return []\n\n    def _k_nearest(self, nodes, pos, k):\n        if len(nodes) <= k:\n            return list(nodes)\n        best = []\n        bestd = []\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if len(best) < k:\n                best.append(n)\n                bestd.append(d)\n            else:\n                # find worst\n                wi = 0\n                wv = bestd[0]\n                for i in range(1, k):\n                    if bestd[i] > wv:\n                        wi = i\n                        wv = bestd[i]\n                if d < wv:\n                    best[wi] = n\n                    bestd[wi] = d\n        return best\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp_tuple(b)\n        if d <= 1e-12:\n            return self._clamp_tuple(a)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._collect_ring(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    def _choose_parent(self, new_pos, grid, frontier, radius, obstacles, is_3d):\n        key = self._grid_key(new_pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._collect_ring(grid, key, r_cells)\n        best = None\n        best_cost = float('inf')\n        if cand:\n            for n in cand:\n                # Edge feasibility must be checked\n                if not self._edge_blocked_memo(n.position, new_pos, obstacles, is_3d):\n                    c = n.cost + self._dist(n.position, new_pos)\n                    if c < best_cost:\n                        best_cost = c\n                        best = n\n        # Frontier-assisted fallback if none\n        if best is None and frontier:\n            limit = 16 if len(frontier) >= 16 else len(frontier)\n            for i in range(limit):\n                n = frontier[-1 - i]\n                if not self._edge_blocked_memo(n.position, new_pos, obstacles, is_3d):\n                    c = n.cost + self._dist(n.position, new_pos)\n                    if c < best_cost:\n                        best_cost = c\n                        best = n\n        return best\n\n    def _rewire(self, new_node, grid, radius, obstacles, is_3d, edges):\n        key = self._grid_key(new_node.position)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._collect_ring(grid, key, r_cells)\n        for n in cand:\n            if n is new_node or n is new_node.parent:\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, n.position)\n            if new_cost + 1e-12 < n.cost:\n                if not self._edge_blocked_memo(new_node.position, n.position, obstacles, is_3d):\n                    old_parent = n.parent\n                    if old_parent is not None:\n                        old_parent.remove_child(n)\n                        self._remove_edge(edges, old_parent, n)\n                    new_node.add_child(n)\n                    n.cost = new_cost\n                    edges.append((new_node, n))\n                    self._propagate_cost_queue(n)\n\n    def _propagate_cost_queue(self, node):\n        # Queue with index pointer to avoid O(n) pop(0)\n        q = [node]\n        head = 0\n        while head < len(q):\n            cur = q[head]\n            head += 1\n            for c in cur.children:\n                c.cost = cur.cost + self._dist(cur.position, c.position)\n                q.append(c)\n\n    def _remove_edge(self, edges, a, b):\n        i = 0\n        n = len(edges)\n        while i < n:\n            e = edges[i]\n            if e[0] is a and e[1] is b:\n                edges.pop(i)\n                return\n            i += 1\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_paths(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        pb.reverse()\n        return pa + pb\n\n    def _los_collapse(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        while i < len(path) - 1:\n            nxt = path[i + 1]\n            if self._edge_blocked_memo(anchor, nxt, obstacles, is_3d):\n                out.append(path[i])\n                anchor = path[i]\n            i += 1\n        out.append(path[-1])\n        return out\n\n    def _shortcut(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and n >= 3:\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if not self._edge_blocked_memo(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n            tries += 1\n        return pts\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _sample_free(self, obstacles, is_3d):\n        # rejection sampling with capped tries\n        for _ in range(60):\n            if is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        if is_3d:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5, self.bounds[2] * 0.5)\n        else:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5)\n\n    def _sample_corridor(self, width, obstacles, is_3d, start, goal):\n        t = self._rand()\n        base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n        tries = 0\n        while tries < 24:\n            if is_3d:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                else:\n                    tries += 1\n                    continue\n            else:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                else:\n                    tries += 1\n                    continue\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n            tries += 1\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d, start, goal):\n        for _ in range(48):\n            if is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if (self._dist(p, start) + self._dist(p, goal) <= best_len and\n                not self._is_in_obstacle(p, obstacles, is_3d)):\n                return p\n        width = max(self.step_size, 0.2 * self._dist(start, goal))\n        return self._sample_corridor(width, obstacles, is_3d, start, goal)",
          "objective": -15.13783,
          "time_improvement": 4.0,
          "length_improvement": 11.0,
          "smoothness_improvement": 1496.0,
          "node_improvement": 92.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.031721878051757815,
                    "num_nodes_avg": 46.4,
                    "path_length_avg": 170.38266975128937,
                    "smoothness_avg": 0.047618020150895286,
                    "success_improvement": 0.0,
                    "time_improvement": -24.405398051607452,
                    "node_improvement": 88.31528582221104,
                    "length_improvement": 6.610558823142437,
                    "smoothness_improvement": 645.3254195473102,
                    "objective_score": -0.12865702386022226
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06853740215301514,
                    "num_nodes_avg": 69.5,
                    "path_length_avg": 244.84271122823665,
                    "smoothness_avg": 0.09606594842587875,
                    "success_improvement": 0.0,
                    "time_improvement": 57.2168884725672,
                    "node_improvement": 95.33024255862394,
                    "length_improvement": 18.264455585325972,
                    "smoothness_improvement": 2371.8460465036887,
                    "objective_score": 39.98297012548419
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.059786009788513186,
                    "num_nodes_avg": 69.2,
                    "path_length_avg": 138.6133249245624,
                    "smoothness_avg": 0.12359414439797282,
                    "success_improvement": 0.0,
                    "time_improvement": -21.883808250805036,
                    "node_improvement": 91.20152574698028,
                    "length_improvement": 7.939629642341188,
                    "smoothness_improvement": 1472.1083939714358,
                    "objective_score": 5.559177280020381
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "FlashConnect BiRRT (FC-BiRRT): a cache-accelerated bidirectional planner with throttled growth and corridor-guided micro-batches. It couples an adaptive hashed-nearest structure with a conservative edge-collision memo (blocked-edge cache), per-cell expansion throttling, and sparse \u201cleader\u201d fallbacks to avoid O(N) scans. Direct bridges and short greedy connects are attempted with cached checks; on success, a bounded shortcut and line-of-sight collapse return a clean path fast.",
          "planning_mechanism": "Mechanism: Initialize start/goal trees with grid buckets and sparse leaders. Each iteration alternates trees, samples a tiny beam (goal/corridor/uniform), steers once from the nearest, enforces node/edge validity, prunes duplicates and saturated cells, and keeps the candidate that best reduces distance to the other tree. Insert with optional grandparent LOS compression, then attempt a direct bridge; if blocked, execute a few greedy connect steps using the blocked-edge cache. On bridge, extract and lightly smooth the path; otherwise continue until the iteration cap.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=8.0,\n                 goal_bias=0.2,\n                 corridor_bias=0.55,\n                 beam_k=2,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 connect_steps=5,\n                 smoothing_iters=18,\n                 min_sep_ratio=0.25,\n                 dupe_radius_ratio=0.5,\n                 cell_expand_limit=3,\n                 leader_stride=16):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.leader_stride = max(1, int(leader_stride))\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Setup grid and edge sampling step\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.8 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, max(0.5, self.step_size * 0.4)))\n        self.cache_bin = max(1.0, self.edge_res)  # quantization for blocked-edge cache\n\n        # Validate start/goal and early LOS\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n        if not self._is_edge_in_obstacle(self.start, self.goal, obstacles, is_3d, self.edge_res):\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, [self.start, self.goal], nodes, [])\n\n        # Initialize trees, grids, leaders, edges, caches\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start, grid_goal = {}, {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        leaders_start, leaders_goal = [start_root], [goal_root]\n        cell_expands_start, cell_expands_goal = {}, {}\n\n        blocked_edge_cache = set()\n\n        # Corridor parameters\n        dsg = self._dist(self.start, self.goal)\n        base_corridor = max(self.step_size, 0.15 * dsg)\n        best_path_len = float('inf')\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            leaders_a = leaders_start if active_start else leaders_goal\n            leaders_b = leaders_goal if active_start else leaders_start\n            cell_count_a = cell_expands_start if active_start else cell_expands_goal\n            root_other = self.goal if active_start else self.start\n\n            # Candidate beam; keep one that best approaches the other tree\n            best_parent = None\n            best_newpos = None\n            best_score = float('inf')\n\n            for _ in range(self.beam_k):\n                # Sampling: goal-biased, corridor-guided, or uniform\n                r = self._rand()\n                if r < self.goal_bias:\n                    x_rand = root_other\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = base_corridor\n                    if best_path_len < float('inf'):\n                        width = max(self.step_size, 0.25 * (best_path_len - dsg) + base_corridor)\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_hashed(grid_a, tree_a, leaders_a, x_rand)\n                if nearest is None:\n                    continue\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n\n                # De-duplicate and throttle saturated cells\n                if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                kcell = self._grid_key(new_pos)\n                if cell_count_a.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n\n                # Edge validity with blocked-edge cache\n                if self._is_edge_blocked_cached(nearest.position, new_pos, obstacles, is_3d, blocked_edge_cache):\n                    continue\n\n                # Score: distance to nearest in opposite tree (leaders-assisted)\n                other_near = self._nearest_hashed(grid_b, tree_b, leaders_b, new_pos)\n                if other_near is not None:\n                    score = self._dist(new_pos, other_near.position)\n                else:\n                    score = self._dist(new_pos, root_other)\n\n                if score < best_score:\n                    best_score = score\n                    best_parent = nearest\n                    best_newpos = new_pos\n\n            if best_parent is None:\n                continue\n\n            # Final validity before insertion (both checks)\n            if self._is_in_obstacle(best_newpos, obstacles, is_3d):\n                continue\n            if self._is_edge_blocked_cached(best_parent.position, best_newpos, obstacles, is_3d, blocked_edge_cache):\n                continue\n\n            # Insert node and edge\n            new_cost = best_parent.cost + self._dist(best_parent.position, best_newpos)\n            new_node = Node(best_newpos, parent=best_parent, cost=new_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            self._edges_add(edges, best_parent, new_node)\n            self._grid_add(grid_a, new_node)\n            # Update per-cell throttle\n            kc = self._grid_key(new_node.position)\n            cell_count_a[kc] = cell_count_a.get(kc, 0) + 1\n            # Sparse leaders\n            if len(tree_a) % self.leader_stride == 0:\n                leaders_a.append(new_node)\n\n            # On-the-fly grandparent compression\n            gp = best_parent.parent\n            if gp is not None:\n                if not self._is_edge_blocked_cached(gp.position, new_node.position, obstacles, is_3d, blocked_edge_cache):\n                    best_parent.remove_child(new_node)\n                    self._edges_remove(edges, best_parent, new_node)\n                    gp.add_child(new_node)\n                    self._edges_add(edges, gp, new_node)\n                    new_node.cost = gp.cost + self._dist(gp.position, new_node.position)\n\n            # Attempt direct bridge to nearest in the other tree\n            other_near = self._nearest_hashed(grid_b, tree_b, leaders_b, new_node.position)\n            if other_near is not None and not self._is_edge_blocked_cached(new_node.position, other_near.position, obstacles, is_3d, blocked_edge_cache):\n                path = self._extract_path(new_node, other_near)\n                best_path_len = self._path_length(path)\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Short greedy connect from the other tree toward the new node\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if self._dist(p.position, to_pos) < self.step_size * self.min_sep_ratio:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(grid_b, to_pos, self.step_size * self.dupe_radius_ratio):\n                    break\n                if self._is_edge_blocked_cached(p.position, to_pos, obstacles, is_3d, blocked_edge_cache):\n                    break\n\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                self._edges_add(edges, p, q)\n                self._grid_add(grid_b, q)\n                # leaders and per-cell throttle for tree_b\n                if len(tree_b) % self.leader_stride == 0:\n                    leaders_b.append(q)\n                kc_b = self._grid_key(q.position)\n                if active_start:\n                    cell_expands_goal[kc_b] = cell_expands_goal.get(kc_b, 0) + 1\n                else:\n                    cell_expands_start[kc_b] = cell_expands_start.get(kc_b, 0) + 1\n\n                p = q\n                steps += 1\n\n                # Check bridge now\n                if not self._is_edge_blocked_cached(new_node.position, p.position, obstacles, is_3d, blocked_edge_cache):\n                    path = self._extract_path(new_node, p)\n                    best_path_len = self._path_length(path)\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # RNG\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _is_edge_blocked_cached(self, a, b, obstacles, is_3d, blocked_cache):\n        key = self._edge_key_q(a, b)\n        if key in blocked_cache:\n            return True\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res)\n        if blocked:\n            blocked_cache.add(key)\n        return blocked\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # Grid and neighbors\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, leaders, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Limited rings, then leader fallback to avoid O(N)\n        for r in range(0, 4):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fall back to leaders (sparse)\n        for n in leaders:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # Fallback full scan (rare)\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d = 0.0\n            for i in range(self.dim):\n                dd = n.position[i] - pos[i]\n                d += dd * dd\n            if d <= r2:\n                return True\n        return False\n\n    # Edges\n    def _edges_add(self, edges, parent, child):\n        edges.append((parent, child))\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        # Forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            last = pts[0]\n            for k in range(1, len(pts) - 1):\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(last, nxt, obstacles, is_3d, self.edge_res):\n                    collapsed.append(pts[k])\n                    last = pts[k]\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
          "objective": -14.73772,
          "time_improvement": 1.0,
          "length_improvement": 9.0,
          "smoothness_improvement": 1829.0,
          "node_improvement": 84.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03957667350769043,
                    "num_nodes_avg": 89.6,
                    "path_length_avg": 173.3707237388481,
                    "smoothness_avg": 0.05077321918948241,
                    "success_improvement": 0.0,
                    "time_improvement": -55.2099725384924,
                    "node_improvement": 77.43641400151094,
                    "length_improvement": 4.972759083816072,
                    "smoothness_improvement": 694.711136125575,
                    "objective_score": -10.105780630630203
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05332317352294922,
                    "num_nodes_avg": 145.0,
                    "path_length_avg": 246.8569464197752,
                    "smoothness_avg": 0.11933221064521529,
                    "success_improvement": 0.0,
                    "time_improvement": 66.7140684040557,
                    "node_improvement": 90.25734058993481,
                    "length_improvement": 17.592045901845015,
                    "smoothness_improvement": 2970.5037314185306,
                    "objective_score": 45.42196671941637
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.052624630928039554,
                    "num_nodes_avg": 134.3,
                    "path_length_avg": 145.60396458843502,
                    "smoothness_avg": 0.1510094522023601,
                    "success_improvement": 0.0,
                    "time_improvement": -7.284136338781219,
                    "node_improvement": 82.92434837889384,
                    "length_improvement": 3.2967796360860238,
                    "smoothness_improvement": 1820.829085655716,
                    "objective_score": 8.896972308295828
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "T-STAR-BiRRT*: Time-bounded, Heuristic-Rewired Bidirectional RRT with quantized edge memo, grid cell gates, and bridge-aware connection. It grows two cost-consistent trees with local RRT* rewiring, uses an informed/goal/bridge-biased sampler once an incumbent path exists, prunes per-cell by best g/f to curb expansions, caches edge collision tests, and selects a low-cost bridge among nearby opposite-tree nodes. A brief shortcut smoothing and LOS collapse returns a short, smooth path quickly.",
          "planning_mechanism": "Alternate growing start/goal trees. Per iteration, generate a tiny beam of candidates via informed ellipse (if path known), goal, bridge, or uniform free samples. For the best candidate: steer, validate node and edge, choose a cost-minimizing collision-free parent from a neighborhood, insert the node, then rewire cheaper neighbors with downstream cost propagation. Attempt to connect to several nearby nodes in the opposite tree while skipping repeatedly blocked cell-pairs. On success, merge roots-to-meet path and shortcut/LOS-compress before returning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        for c in self.children:\n            if c is child:\n                return\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        i = 0\n        n = len(self.children)\n        while i < n:\n            if self.children[i] is child:\n                self.children.pop(i)\n                return\n            i += 1\nclass Planner:\n    def __init__(self,\n                 max_iter=6000,\n                 step_size=6.0,\n                 collision_step=1.0,\n                 beam_k=2,\n                 goal_bias=0.18,\n                 bridge_bias=0.22,\n                 informed_bias=0.65,\n                 grid_cell=None,\n                 neighbor_radius_factor=2.8,\n                 connect_k=5,\n                 connect_radius_factor=3.2,\n                 dupe_radius_ratio=0.55,\n                 cell_expand_limit=3,\n                 cell_gate_relax=1.05,\n                 prune_margin=1.01,\n                 smoothing_attempts=60,\n                 edge_cache_limit=40000):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.collision_step = float(collision_step)\n        self.beam_k = int(beam_k)\n        self.goal_bias = float(goal_bias)\n        self.bridge_bias = float(bridge_bias)\n        self.informed_bias = float(informed_bias)\n        self.grid_cell = grid_cell\n        self.neighbor_radius_factor = float(neighbor_radius_factor)\n        self.connect_k = int(connect_k)\n        self.connect_radius_factor = float(connect_radius_factor)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.cell_expand_limit = int(cell_expand_limit)\n        self.cell_gate_relax = float(cell_gate_relax)\n        self.prune_margin = float(prune_margin)\n        self.smoothing_attempts = int(smoothing_attempts)\n        self.edge_cache_limit = int(edge_cache_limit)\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_cache = None\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self.inv_cache_bin = 1.0\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, 0.5 * self.step_size))\n        self.cache_bin = max(0.5, 0.5 * self.edge_res)\n        self.inv_cache_bin = 1.0 / self.cache_bin\n        self.edge_cache = {}\n\n        # Basic validity checks\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Direct connection\n        if not self._edge_blocked_memo(start, goal, obstacles, is_3d):\n            n0 = Node(start, None, 0.0)\n            n1 = Node(goal, n0, self._dist(start, goal))\n            n0.add_child(n1)\n            edges = [(n0, n1)]\n            nodes = [n0, n1]\n            return PlannerResult(True, [start, goal], nodes, edges)\n\n        # Initialize trees and structures\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n\n        # Cell-level pruning gates\n        expand_a, expand_b = {}, {}\n        bestg_a, bestg_b = {}, {}\n        bestf_a, bestf_b = {}, {}\n\n        # Connection sieve for repeatedly blocked cell-pairs\n        blocked_pairs = {}\n\n        best_path_len = float('inf')\n        dsg = self._dist(start, goal)\n        dupe_radius = max(0.5, self.dupe_radius_ratio * self.step_size)\n        parent_radius = self.neighbor_radius_factor * self.step_size\n        connect_radius = self.connect_radius_factor * self.step_size\n\n        for it in range(self.max_iter):\n            # Choose active side\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            expands1 = expand_a if active_start else expand_b\n            bestg1 = bestg_a if active_start else bestg_b\n            bestf1 = bestf_a if active_start else bestf_b\n            other_root = goal if active_start else start\n\n            # Beam: pick the best candidate by f=g+h with bridge hint\n            best = None  # (parent, new_pos, fscore, hint)\n            for _ in range(self.beam_k):\n                # Sampling policy\n                xr = None\n                r = self._rand()\n                if best_path_len < float('inf') and r < self.informed_bias:\n                    xr = self._sample_informed(best_path_len, obstacles, is_3d, start, goal)\n                else:\n                    r2 = self._rand()\n                    if r2 < self.goal_bias:\n                        xr = other_root\n                    elif r2 < self.goal_bias + self.bridge_bias:\n                        # Bridge bias: pick random free, then move toward nearest in other tree\n                        seed = self._sample_free(obstacles, is_3d)\n                        other_nn = self._nearest(grid2, tree2, seed)\n                        if other_nn is not None:\n                            xr = other_nn.position\n                        else:\n                            xr = seed\n                    else:\n                        xr = self._sample_free(obstacles, is_3d)\n\n                near = self._nearest(grid1, tree1, xr)\n                if near is None:\n                    continue\n                new_pos = self._steer(near.position, xr, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._exists_close(grid1, new_pos, dupe_radius):\n                    continue\n\n                cell = self._grid_key(new_pos)\n                if expands1.get(cell, 0) >= self.cell_expand_limit:\n                    continue\n\n                # Select best parent in a radius neighborhood\n                parent = self._choose_parent(new_pos, grid1, tree1, parent_radius, obstacles, is_3d)\n                if parent is None:\n                    continue\n\n                # Edge check (must be collision-free)\n                if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_cost = parent.cost + self._dist(parent.position, new_pos)\n\n                # Cell g-gate\n                prevg = bestg1.get(cell, float('inf'))\n                if new_cost > prevg * self.cell_gate_relax:\n                    continue\n\n                # Incumbent-aware prune by f=g+h\n                h = self._dist(new_pos, other_root)\n                if best_path_len < float('inf'):\n                    if new_cost + h >= best_path_len * self.prune_margin:\n                        continue\n\n                # Bridge hint: distance to nearest of the other tree\n                onear = self._nearest(grid2, tree2, new_pos)\n                bhint = self._dist(new_pos, onear.position) if onear is not None else h\n                fscore = new_cost + h + 0.3 * bhint\n\n                prevf = bestf1.get(cell, float('inf'))\n                if fscore > prevf * self.cell_gate_relax:\n                    continue\n\n                if best is None or fscore < best[2]:\n                    best = (parent, new_pos, fscore, onear)\n\n            if best is None:\n                continue\n\n            parent, new_pos, _, onear = best\n\n            # Final checks before insertion\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Insert node\n            new_node = Node(new_pos, parent, parent.cost + self._dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            self._grid_add(grid1, new_node)\n            edges.append((parent, new_node))\n\n            # Update cell gates\n            cell = self._grid_key(new_pos)\n            expands1[cell] = expands1.get(cell, 0) + 1\n            if new_node.cost < bestg1.get(cell, float('inf')):\n                bestg1[cell] = new_node.cost\n            f_est = new_node.cost + self._dist(new_pos, other_root)\n            if f_est < bestf1.get(cell, float('inf')):\n                bestf1[cell] = f_est\n\n            # Local RRT* rewiring\n            self._rewire(new_node, grid1, tree1, parent_radius, obstacles, is_3d, edges)\n\n            # Try to connect to the opposite tree\n            near_other = self._nearby(grid2, new_node.position, connect_radius, tree2)\n            if len(near_other) > self.connect_k:\n                near_other = self._k_nearest(near_other, new_node.position, self.connect_k)\n\n            best_bridge = None  # (other_node, total_cost)\n            for q in near_other:\n                # Skip repeatedly blocked cell-pairs\n                kp = (self._grid_key(new_node.position), self._grid_key(q.position))\n                if blocked_pairs.get(kp, 0) >= 2:\n                    continue\n                if not self._edge_blocked_memo(new_node.position, q.position, obstacles, is_3d):\n                    tc = new_node.cost + self._dist(new_node.position, q.position) + q.cost\n                    if best_bridge is None or tc < best_bridge[1]:\n                        best_bridge = (q, tc)\n                else:\n                    blocked_pairs[kp] = blocked_pairs.get(kp, 0) + 1\n\n            if best_bridge is not None:\n                other_hit = best_bridge[0]\n                # Merge path\n                if active_start:\n                    path = self._merge_paths(new_node, other_hit)\n                else:\n                    path = self._merge_paths(other_hit, new_node)\n                best_path_len = self._path_length(path)\n                # Post smoothing\n                path = self._shortcut(path, obstacles, is_3d, self.smoothing_attempts)\n                path = self._forward_los_collapse(path, obstacles, is_3d)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # --- Helpers ---\n    def _rand(self):\n        if not hasattr(self, \"_rng\"):\n            self._rng = 1103515245\n        self._rng = (1664525 * self._rng + 1013904223) % (1 << 32)\n        return self._rng / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] * self.inv_cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] * self.inv_cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        st = self.edge_cache.get(key)\n        if st is not None:\n            return st == 1\n        blocked = self._edge_blocked(a, b, obstacles, is_3d)\n        self.edge_cache[key] = 1 if blocked else 2\n        if len(self.edge_cache) > self.edge_cache_limit:\n            self.edge_cache.clear()\n        return blocked\n\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _collect_ring(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        lst = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if lst:\n                            out.extend(lst)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    lst = grid.get((key[0] + dx, key[1] + dy))\n                    if lst:\n                        out.extend(lst)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, 3):\n            cand = self._collect_ring(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Fallback linear scan (rare)\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _nearby(self, grid, pos, radius, fallback_tree):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._collect_ring(grid, key, r_cells)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n        if out:\n            return out\n        return list(fallback_tree)\n\n    def _k_nearest(self, nodes, pos, k):\n        if len(nodes) <= k:\n            return list(nodes)\n        best = []\n        bestd = []\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if len(best) < k:\n                best.append(n)\n                bestd.append(d)\n            else:\n                wi = 0\n                wv = bestd[0]\n                for i in range(1, k):\n                    if bestd[i] > wv:\n                        wi = i\n                        wv = bestd[i]\n                if d < wv:\n                    best[wi] = n\n                    bestd[wi] = d\n        return best\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp_tuple(b)\n        if d <= 1e-12:\n            return self._clamp_tuple(a)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._collect_ring(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    def _choose_parent(self, new_pos, grid, tree, radius, obstacles, is_3d):\n        key = self._grid_key(new_pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._collect_ring(grid, key, r_cells)\n        if not cand:\n            # Fallback to nearest in tree\n            nearest = self._nearest(grid, tree, new_pos)\n            if nearest is None:\n                return None\n            if self._edge_blocked_memo(nearest.position, new_pos, obstacles, is_3d):\n                return None\n            return nearest\n        best = None\n        best_cost = float('inf')\n        for n in cand:\n            # Check edge feasibility\n            if not self._edge_blocked_memo(n.position, new_pos, obstacles, is_3d):\n                c = n.cost + self._dist(n.position, new_pos)\n                if c < best_cost:\n                    best_cost = c\n                    best = n\n        if best is None:\n            # As last resort, try nearest\n            nearest = self._nearest(grid, tree, new_pos)\n            if nearest is None:\n                return None\n            if self._edge_blocked_memo(nearest.position, new_pos, obstacles, is_3d):\n                return None\n            return nearest\n        return best\n\n    def _rewire(self, new_node, grid, tree, radius, obstacles, is_3d, edges):\n        key = self._grid_key(new_node.position)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._collect_ring(grid, key, r_cells)\n        for n in cand:\n            if n is new_node or n is new_node.parent:\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, n.position)\n            if new_cost + 1e-12 < n.cost:\n                if not self._edge_blocked_memo(new_node.position, n.position, obstacles, is_3d):\n                    # Rewire: update parent and costs, maintain edges\n                    old_parent = n.parent\n                    if old_parent is not None:\n                        old_parent.remove_child(n)\n                        self._remove_edge(edges, old_parent, n)\n                    new_node.add_child(n)\n                    n.cost = new_cost\n                    edges.append((new_node, n))\n                    self._propagate_cost(n)\n\n    def _propagate_cost(self, node):\n        # BFS to update descendants\n        q = [node]\n        while q:\n            cur = q.pop(0)\n            for c in cur.children:\n                c.cost = cur.cost + self._dist(cur.position, c.position)\n                q.append(c)\n\n    def _remove_edge(self, edges, a, b):\n        i = 0\n        n = len(edges)\n        while i < n:\n            e = edges[i]\n            if e[0] is a and e[1] is b:\n                edges.pop(i)\n                return\n            i += 1\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_paths(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        pb.reverse()\n        return pa + pb\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _shortcut(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and n >= 3:\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if not self._edge_blocked_memo(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n            tries += 1\n        return pts\n\n    def _forward_los_collapse(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        while i < len(path) - 1:\n            nxt = path[i + 1]\n            if self._edge_blocked_memo(anchor, nxt, obstacles, is_3d):\n                out.append(path[i])\n                anchor = path[i]\n            i += 1\n        out.append(path[-1])\n        return out\n\n    def _sample_free(self, obstacles, is_3d):\n        # rejection sampling with capped tries\n        for _ in range(80):\n            if is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # fallback to center\n        if is_3d:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5, self.bounds[2] * 0.5)\n        else:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5)\n\n    def _sample_corridor(self, width, obstacles, is_3d, start, goal):\n        t = self._rand()\n        base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n        tries = 0\n        while tries < 24:\n            if is_3d:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                else:\n                    tries += 1\n                    continue\n            else:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                else:\n                    tries += 1\n                    continue\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n            tries += 1\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d, start, goal):\n        for _ in range(48):\n            if is_3d:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if (self._dist(p, start) + self._dist(p, goal) <= best_len and\n                not self._is_in_obstacle(p, obstacles, is_3d)):\n                return p\n        width = max(self.step_size, 0.2 * self._dist(start, goal))\n        return self._sample_corridor(width, obstacles, is_3d, start, goal)",
          "objective": -14.436,
          "time_improvement": -6.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1419.0,
          "node_improvement": 90.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.023242902755737305,
                    "num_nodes_avg": 39.8,
                    "path_length_avg": 162.23401502436312,
                    "smoothness_avg": 0.047940669189249455,
                    "success_improvement": 0.0,
                    "time_improvement": 8.847056139474907,
                    "node_improvement": 89.97733568370687,
                    "length_improvement": 11.076965602667869,
                    "smoothness_improvement": 650.375577641154,
                    "objective_score": 12.552174091648963
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.10765118598937988,
                    "num_nodes_avg": 130.1,
                    "path_length_avg": 239.62250612953494,
                    "smoothness_avg": 0.09500619346409442,
                    "success_improvement": 0.0,
                    "time_improvement": 32.80088606274324,
                    "node_improvement": 91.25848283276223,
                    "length_improvement": 20.007110302545243,
                    "smoothness_improvement": 2344.577788026332,
                    "objective_score": 33.567420940481774
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07761008739471435,
                    "num_nodes_avg": 96.7,
                    "path_length_avg": 129.61210564809306,
                    "smoothness_avg": 0.10698267165247602,
                    "success_improvement": 0.0,
                    "time_improvement": -58.221179901573606,
                    "node_improvement": 87.70502225047679,
                    "length_improvement": 13.917810893770255,
                    "smoothness_improvement": 1260.8116867800911,
                    "objective_score": -2.811609000309473
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "FIBER-BiRRT: Frontier-Informed, Budgeted, Edge-Cached Bidirectional RRT. It alternates growth between start and goal trees using a grid-accelerated nearest search with small-ring lookup and random-subset fallback, samples toward the opposite root and along a thin start-goal corridor, and commits only validated, non-duplicate edges. A dual cache memoizes both free and blocked edges with bounded size. After each insertion it attempts a cheap direct bridge and a short greedy guided connect. Upon first feasible bridge it performs a lightweight shortcut pass and returns the best path, limiting post-bridge refinement to a small budget for speed.",
          "planning_mechanism": "Mechanism: Initialize two trees at start/goal, a hash-grid for nodes with per-cell expansion limits, and bounded free/blocked edge caches. Each iteration samples 2 candidates (goal-biased, corridor, or uniform), chooses the one with smallest heuristic to the opposite root, finds a near node via grid rings then steers one step. If both node and edge are collision-free and not a near-duplicate, insert and try to connect to the other tree via a direct edge or short greedy steps, committing only valid edges. On success, assemble and shortcut the path, optionally refine briefly, and exit.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=8.0,\n                 goal_bias=0.25,\n                 corridor_bias=0.5,\n                 connect_steps=6,\n                 collision_res=1.0,\n                 grid_cell=None,\n                 shortcut_iters=24,\n                 cell_expand_limit=4,\n                 dupe_radius_ratio=0.5,\n                 r_max=3,\n                 random_nn_samples=12,\n                 cache_capacity=60000,\n                 improvement_window=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.connect_steps = max(0, int(connect_steps))\n        self.collision_res = max(0.25, collision_res)\n        self.grid_cell = grid_cell\n        self.shortcut_iters = max(0, int(shortcut_iters))\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.dupe_radius_ratio = max(0.1, dupe_radius_ratio)\n        self.r_max = max(1, int(r_max))\n        self.random_nn_samples = max(4, int(random_nn_samples))\n        self.cache_capacity = max(1000, int(cache_capacity))\n        self.improvement_window = max(0, int(improvement_window))\n\n        self.dim = 2\n        self.bounds = None\n\n        # RNG\n        self._lcg_state = 123456789\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = self._as_tuple(map.start)\n        goal = self._as_tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Parameterize helpers\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.cache_bin = max(0.5, min(self.collision_res, self.step_size * 0.5))\n\n        # Edge caches (bounded)\n        self._free_edges = set()\n        self._blocked_edges = set()\n\n        # Validate endpoints\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line exit\n        if self._is_edge_free_cached(start, goal, obstacles, is_3d):\n            n0 = Node(start)\n            n1 = Node(goal, parent=n0, cost=self._dist(start, goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [start, goal], [n0, n1], [(n0, n1)])\n\n        # Initialize trees and grids\n        start_root = Node(start, None, 0.0)\n        goal_root = Node(goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n\n        grid_start, grid_goal = {}, {}\n        cell_count_start, cell_count_goal = {}, {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Corridor width\n        dsg = self._dist(start, goal)\n        base_corridor = max(self.step_size * 0.8, 0.12 * dsg)\n\n        best_path = None\n        best_iter = -1\n\n        for it in range(self.max_iter):\n            if best_iter >= 0 and (it - best_iter) > self.improvement_window:\n                break\n\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            cell_a = cell_count_start if active_start else cell_count_goal\n            cell_b = cell_count_goal if active_start else cell_count_start\n            root_other = goal if active_start else start\n\n            # Tournament of two samples\n            winner = None\n            winner_parent = None\n            winner_score = float('inf')\n\n            for _ in range(2):\n                x_rand = self._sample_biased(start, goal, base_corridor, obstacles, is_3d, root_other)\n                nearest = self._nearest_hashed(grid_a, tree_a, x_rand)\n                if nearest is None:\n                    continue\n\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                # Dedupe and per-cell throttle\n                if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                kcell = self._grid_key(new_pos)\n                if cell_a.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n                # Edge collision (both checks are enforced: node free above, edge free below)\n                if not self._is_edge_free_cached(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Heuristic: distance to opposite root\n                h = self._dist(new_pos, root_other)\n                if h < winner_score:\n                    winner_score = h\n                    winner = new_pos\n                    winner_parent = nearest\n\n            if winner is None or winner_parent is None:\n                continue\n\n            # Insert node and edge (both checks already validated)\n            new_cost = winner_parent.cost + self._dist(winner_parent.position, winner)\n            new_node = Node(winner, parent=winner_parent, cost=new_cost)\n            winner_parent.add_child(new_node)\n            tree_a.append(new_node)\n            edges.append((winner_parent, new_node))\n            self._grid_add(grid_a, new_node)\n            kc = self._grid_key(new_node.position)\n            cell_a[kc] = cell_a.get(kc, 0) + 1\n\n            # Try direct bridge to nearest in other tree\n            other_near = self._nearest_hashed(grid_b, tree_b, new_node.position)\n            if other_near is not None and self._is_edge_free_cached(new_node.position, other_near.position, obstacles, is_3d):\n                path = self._extract_path(new_node, other_near)\n                smooth = self._shortcut(path, obstacles, is_3d, self.shortcut_iters)\n                return PlannerResult(True, smooth, start_tree + goal_tree, edges)\n\n            # Short greedy guided connect from other tree toward new_node\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(grid_b, to_pos, self.step_size * self.dupe_radius_ratio):\n                    break\n                if not self._is_edge_free_cached(p.position, to_pos, obstacles, is_3d):\n                    break\n\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                edges.append((p, q))\n                self._grid_add(grid_b, q)\n                kcb = self._grid_key(q.position)\n                cell_b[kcb] = cell_b.get(kcb, 0) + 1\n\n                if self._is_edge_free_cached(q.position, new_node.position, obstacles, is_3d):\n                    path = self._extract_path(new_node, q)\n                    smooth = self._shortcut(path, obstacles, is_3d, self.shortcut_iters)\n                    return PlannerResult(True, smooth, start_tree + goal_tree, edges)\n\n                p = q\n                steps += 1\n\n        # No connection found\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # RNG utilities\n    def _rand(self):\n        self._lcg_state = (1103515245 * self._lcg_state + 12345) % (1 << 31)\n        return (self._lcg_state & 0x7fffffff) / float(1 << 31)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _rand_int(self, a, b):\n        if b <= a:\n            return a\n        r = int(self._uniform(0.0, (b - a + 1)))\n        v = a + r\n        if v > b:\n            v = b\n        return v\n\n    def _as_tuple(self, p):\n        if isinstance(p, tuple):\n            return p\n        return tuple(p[i] for i in range(len(p)))\n\n    # Geometry and checks\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / max(1e-9, d)\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(max(1, d / max(1e-9, resolution)))\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _is_edge_free_cached(self, a, b, obstacles, is_3d):\n        # Bounded cache: clear when too large\n        if len(self._free_edges) + len(self._blocked_edges) > self.cache_capacity:\n            self._free_edges.clear()\n            self._blocked_edges.clear()\n        key = self._edge_key_q(a, b)\n        if key in self._blocked_edges:\n            return False\n        if key in self._free_edges:\n            return True\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_res)\n        if blocked:\n            self._blocked_edges.add(key)\n            return False\n        else:\n            self._free_edges.add(key)\n            return True\n\n    # Sampling\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, start, goal, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_biased(self, start, goal, corridor_w, obstacles, is_3d, root_other):\n        r = self._rand()\n        if r < self.goal_bias:\n            return root_other\n        elif r < self.goal_bias + self.corridor_bias:\n            return self._sample_corridor(start, goal, corridor_w, obstacles, is_3d)\n        else:\n            return self._sample_free(obstacles, is_3d)\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # Grid hashing and NN\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_hashed(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        found = False\n        for r in range(0, self.r_max + 1):\n            cand = self._grid_ring_collect(grid, key, r)\n            if not cand:\n                continue\n            for n in cand:\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n                    found = True\n            if found:\n                return best\n        # Fallback: random subset of nodes\n        if len(tree) > 0:\n            trials = min(self.random_nn_samples, len(tree))\n            for _ in range(trials):\n                idx = self._rand_int(0, len(tree) - 1)\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / max(1e-9, self.grid_cell)) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            d2 = 0.0\n            for i in range(self.dim):\n                di = n.position[i] - pos[i]\n                d2 += di * di\n            if d2 <= r2:\n                return True\n        return False\n\n    # Path utilities\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _shortcut(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = self._rand_int(0, n - 3)\n            j = self._rand_int(i + 2, n - 1)\n            a = pts[i]\n            b = pts[j]\n            if self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_res):\n                continue\n            pts = pts[:i + 1] + pts[j:]\n        # Final linear collapse\n        out = [pts[0]]\n        last = pts[0]\n        i = 1\n        while i < len(pts):\n            far = i\n            j = i\n            while j < len(pts) and not self._is_edge_in_obstacle(last, pts[j], obstacles, is_3d, self.collision_res):\n                far = j\n                j += 1\n            last = pts[far]\n            out.append(last)\n            i = far + 1\n        if out[0] != path[0]:\n            out[0] = path[0]\n        if out[-1] != path[-1]:\n            out[-1] = path[-1]\n        return out",
          "objective": -14.39659,
          "time_improvement": 57.0,
          "length_improvement": 10.0,
          "smoothness_improvement": 1561.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.011511802673339844,
                    "num_nodes_avg": 43.1,
                    "path_length_avg": 165.41816956757762,
                    "smoothness_avg": 0.0480468201684311,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 54.85354330119673,
                    "node_improvement": 89.14631075295894,
                    "length_improvement": 9.331680041374426,
                    "smoothness_improvement": 652.0370709758873,
                    "objective_score": -24.68474362993688
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.035892701148986815,
                    "num_nodes_avg": 127.6,
                    "path_length_avg": 244.36058127870584,
                    "smoothness_avg": 0.09005012427822615,
                    "success_improvement": 0.0,
                    "time_improvement": 77.59469445822344,
                    "node_improvement": 91.42645971914266,
                    "length_improvement": 18.425404439820507,
                    "smoothness_improvement": 2217.0545581615957,
                    "objective_score": 45.41892379216731
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03045523166656494,
                    "num_nodes_avg": 116.6,
                    "path_length_avg": 145.53318978100236,
                    "smoothness_avg": 0.1505630096600803,
                    "success_improvement": 0.0,
                    "time_improvement": 37.91190230269154,
                    "node_improvement": 85.17482517482517,
                    "length_improvement": 3.3437848932486256,
                    "smoothness_improvement": 1815.1503694708776,
                    "objective_score": 22.455593474111023
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "m3",
          "algorithm_description": "Swift-BiRRT-M: Minimalist, grid-accelerated bidirectional RRT with biased sampling, ring-limited nearest lookup, per-cell throttling, near-duplicate suppression, and lightweight shortcutting. It commits only validated short edges, eliminates rewiring and heavy caches, and focuses growth toward the opposite root and the start\u2013goal line for fast, robust plans with smooth, short paths.",
          "planning_mechanism": "Alternate growing start and goal trees. Per iteration, draw a few biased samples (goal/line/random), find a hash-nearest node, steer one step, and insert only if both node and edge are collision-free. After each insert, attempt a direct bridge to the other tree; if blocked, take a few validated micro-steps from the other side toward the new node. On first connection, extract and briefly shortcut the path, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = tuple(position)\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=6.0,\n        goal_bias=0.18,\n        line_bias=0.5,\n        beam_k=3,\n        connect_steps=4,\n        cell_size_factor=1.2,\n        per_cell_cap=4,\n        dupe_radius_ratio=0.4,\n        smooth_attempts=20,\n        smooth_no_improve=8\n    ):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.goal_bias = float(goal_bias)\n        self.line_bias = float(line_bias)\n        self.beam_k = int(max(1, beam_k))\n        self.connect_steps = int(max(0, connect_steps))\n        self.cell_size_factor = float(max(0.8, cell_size_factor))\n        self.per_cell_cap = int(max(1, per_cell_cap))\n        self.dupe_radius_ratio = float(max(0.1, dupe_radius_ratio))\n        self.smooth_attempts = int(max(0, smooth_attempts))\n        self.smooth_no_improve = int(max(3, smooth_no_improve))\n        self._rng = 88172645463393265 & 0xffffffff\n\n    def plan(self, map):\n        self.bounds = tuple(map.size)\n        self.dim = len(self.bounds)\n        self.is_3d = (self.dim == 3)\n        self.start = tuple(map.start)\n        self.goal = tuple(map.goal)\n        self.obstacles = list(map.obstacles) if map.obstacles else []\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        self._seed_from_scene()\n\n        self.cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n\n        self._build_obstacle_grid()\n        if self._point_in_obstacles(self.start) or self._point_in_obstacles(self.goal):\n            return PlannerResult(False, [], [], [])\n\n        if self._edge_free(self.start, self.goal):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        nodes = []\n        edges = []\n\n        a_root = Node(self.start, None, 0.0)\n        b_root = Node(self.goal, None, 0.0)\n        nodes.extend([a_root, b_root])\n\n        tree_a, tree_b = [a_root], [b_root]\n        grid_a, grid_b = {}, {}\n        fill_a, fill_b = {}, {}\n        anchors_a, anchors_b = [a_root], [b_root]\n        self._grid_add(grid_a, a_root, fill_a)\n        self._grid_add(grid_b, b_root, fill_b)\n        anchors_stride = 16\n\n        for it in range(self.max_iter):\n            side_a = (it % 2 == 0)\n            tree1 = tree_a if side_a else tree_b\n            tree2 = tree_b if side_a else tree_a\n            grid1 = grid_a if side_a else grid_b\n            grid2 = grid_b if side_a else grid_a\n            fill1 = fill_a if side_a else fill_b\n            fill2 = fill_b if side_a else fill_a\n            anchors1 = anchors_a if side_a else anchors_b\n            anchors2 = anchors_b if side_a else anchors_a\n            target = self.goal if side_a else self.start\n\n            inserted = False\n            for _ in range(self.beam_k):\n                sample = self._sample(target)\n                if sample is None:\n                    continue\n                near = self._nearest_hashed(grid1, anchors1, sample)\n                if near is None:\n                    continue\n                new_pos = self._steer(near.position, sample)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._point_in_obstacles(new_pos):\n                    continue\n                if self._has_near(grid1, new_pos, self.dupe_radius):\n                    continue\n                ckey = self._cell_key(new_pos)\n                if fill1.get(ckey, 0) >= self.per_cell_cap:\n                    continue\n                if not self._edge_free(near.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos, near, near.cost + self._dist(near.position, new_pos))\n                near.add_child(new_node)\n                tree1.append(new_node)\n                nodes.append(new_node)\n                edges.append((near, new_node))\n                self._grid_add(grid1, new_node, fill1)\n                if (len(tree1) % anchors_stride) == 0:\n                    anchors1.append(new_node)\n                inserted = True\n\n                other = self._nearest_hashed(grid2, anchors2, new_node.position)\n                if other is not None and self._edge_free(new_node.position, other.position):\n                    path = self._extract_path(new_node, other)\n                    path = self._shortcut(path)\n                    return PlannerResult(True, path, nodes, edges)\n\n                if self.connect_steps > 0 and other is not None:\n                    steps = 0\n                    q = other\n                    while steps < self.connect_steps:\n                        step_pos = self._steer(q.position, new_node.position)\n                        if not self._in_bounds(step_pos):\n                            break\n                        if self._point_in_obstacles(step_pos):\n                            break\n                        if self._has_near(grid2, step_pos, self.dupe_radius):\n                            break\n                        if not self._edge_free(q.position, step_pos):\n                            break\n                        qn = Node(step_pos, q, q.cost + self._dist(q.position, step_pos))\n                        q.add_child(qn)\n                        tree2.append(qn)\n                        nodes.append(qn)\n                        edges.append((q, qn))\n                        self._grid_add(grid2, qn, fill2)\n                        if (len(tree2) % anchors_stride) == 0:\n                            anchors2.append(qn)\n                        if self._edge_free(new_node.position, qn.position):\n                            path = self._extract_path(new_node, qn)\n                            path = self._shortcut(path)\n                            return PlannerResult(True, path, nodes, edges)\n                        q = qn\n                        steps += 1\n\n                if inserted:\n                    break\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _seed_from_scene(self):\n        s = 0x9E3779B1\n        for v in self.start + self.goal:\n            s ^= (int(v * 1315423911) & 0xffffffff)\n            s = (1664525 * s + 1013904223) & 0xffffffff\n        s ^= (len(self.obstacles) * 2654435761) & 0xffffffff\n        self._rng = s if s != 0 else 2463534242\n\n    def _rand(self):\n        self._rng = (1664525 * self._rng + 1013904223) & 0xffffffff\n        return (self._rng & 0xffffffff) / float(1 << 32)\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b):\n        d = self._dist(a, b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        if d <= self.step_size:\n            return self._clamp(b)\n        r = self.step_size / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _sample(self, target):\n        for _ in range(24):\n            r = self._rand()\n            if r < self.goal_bias:\n                p = target\n            elif r < self.goal_bias + self.line_bias:\n                t = self._rand()\n                base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n                sg = self._dist(self.start, self.goal)\n                width = max(self.step_size, 0.2 * sg)\n                if self.is_3d:\n                    p = (base[0] + self._rand_range(-width, width),\n                         base[1] + self._rand_range(-width, width),\n                         base[2] + self._rand_range(-width, width))\n                else:\n                    p = (base[0] + self._rand_range(-width, width),\n                         base[1] + self._rand_range(-width, width))\n            else:\n                if self.is_3d:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]),\n                         self._rand_range(0.0, self.bounds[2]))\n                else:\n                    p = (self._rand_range(0.0, self.bounds[0]),\n                         self._rand_range(0.0, self.bounds[1]))\n            p = self._clamp(p)\n            if self._in_bounds(p) and not self._point_in_obstacles(p):\n                return p\n        return None\n\n    def _cell_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, fill):\n        k = self._cell_key(node.position)\n        b = grid.get(k)\n        if b is None:\n            grid[k] = [node]\n        else:\n            b.append(node)\n        fill[k] = fill.get(k, 0) + 1\n\n    def _grid_ring(self, key, r, grid):\n        out = []\n        if self.is_3d:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, anchors, pos):\n        key = self._cell_key(pos)\n        best = None\n        bestd = 1e100\n        for r in range(0, 5):\n            cand = self._grid_ring(key, r, grid)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _neighbors_within(self, grid, pos, radius):\n        key = self._cell_key(pos)\n        r_cells = int(radius // self.cell_size) + 1\n        cand = self._grid_ring(key, r_cells, grid)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n        return out\n\n    def _has_near(self, grid, pos, radius):\n        arr = self._neighbors_within(grid, pos, radius)\n        return len(arr) > 0\n\n    def _build_obstacle_grid(self):\n        self.obs_cell = max(4.0, self.step_size * 1.5)\n        self.obs_grid = {}\n        if self.is_3d:\n            for idx, o in enumerate(self.obstacles):\n                x, y, z, w, h, d = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cz0 = int(max(0.0, z) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                cz1 = int(min(self.bounds[2], z + d) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        for cz in range(cz0, cz1 + 1):\n                            k = (cx, cy, cz)\n                            b = self.obs_grid.get(k)\n                            if b is None:\n                                self.obs_grid[k] = [idx]\n                            else:\n                                b.append(idx)\n        else:\n            for idx, o in enumerate(self.obstacles):\n                x, y, w, h = o\n                cx0 = int(max(0.0, x) // self.obs_cell)\n                cy0 = int(max(0.0, y) // self.obs_cell)\n                cx1 = int(min(self.bounds[0], x + w) // self.obs_cell)\n                cy1 = int(min(self.bounds[1], y + h) // self.obs_cell)\n                for cx in range(cx0, cx1 + 1):\n                    for cy in range(cy0, cy1 + 1):\n                        k = (cx, cy)\n                        b = self.obs_grid.get(k)\n                        if b is None:\n                            self.obs_grid[k] = [idx]\n                        else:\n                            b.append(idx)\n\n    def _point_in_obstacles(self, p):\n        if self.is_3d:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            cz = int(p[2] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy, cz))\n            if not bucket:\n                return False\n            px, py, pz = p\n            for idx in bucket:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            cx = int(p[0] // self.obs_cell)\n            cy = int(p[1] // self.obs_cell)\n            bucket = self.obs_grid.get((cx, cy))\n            if not bucket:\n                return False\n            px, py = p\n            for idx in bucket:\n                x, y, w, h = self.obstacles[idx]\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _edge_free(self, a, b):\n        return not self._segment_hits_obstacle(a, b)\n\n    def _segment_hits_obstacle(self, a, b):\n        if self.is_3d:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            minz = a[2] if a[2] < b[2] else b[2]\n            maxz = a[2] if a[2] > b[2] else b[2]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cz0 = int(max(0.0, minz) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cz1 = int(min(self.bounds[2], maxz) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    for cz in range(cz0, cz1 + 1):\n                        bkt = self.obs_grid.get((cx, cy, cz))\n                        if bkt:\n                            for idx in bkt:\n                                cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, z, w, h, d = self.obstacles[idx]\n                if self._seg_box_intersect_3d(a, b, (x, y, z), (x + w, y + h, z + d)):\n                    return True\n            return False\n        else:\n            minx = a[0] if a[0] < b[0] else b[0]\n            maxx = a[0] if a[0] > b[0] else b[0]\n            miny = a[1] if a[1] < b[1] else b[1]\n            maxy = a[1] if a[1] > b[1] else b[1]\n            cx0 = int(max(0.0, minx) // self.obs_cell)\n            cy0 = int(max(0.0, miny) // self.obs_cell)\n            cx1 = int(min(self.bounds[0], maxx) // self.obs_cell)\n            cy1 = int(min(self.bounds[1], maxy) // self.obs_cell)\n            cand = set()\n            for cx in range(cx0, cx1 + 1):\n                for cy in range(cy0, cy1 + 1):\n                    bkt = self.obs_grid.get((cx, cy))\n                    if bkt:\n                        for idx in bkt:\n                            cand.add(idx)\n            if not cand:\n                return False\n            for idx in cand:\n                x, y, w, h = self.obstacles[idx]\n                if self._seg_box_intersect_2d(a, b, (x, y), (x + w, y + h)):\n                    return True\n            return False\n\n    def _seg_box_intersect_2d(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(2):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _seg_box_intersect_3d(self, p0, p1, bmin, bmax):\n        t0, t1 = 0.0, 1.0\n        for i in range(3):\n            p = p0[i]\n            d = p1[i] - p0[i]\n            mn = bmin[i]\n            mx = bmax[i]\n            if abs(d) < 1e-12:\n                if p < mn or p > mx:\n                    return False\n            else:\n                inv = 1.0 / d\n                tA = (mn - p) * inv\n                tB = (mx - p) * inv\n                if tA > tB:\n                    tA, tB = tB, tA\n                if tA > t0:\n                    t0 = tA\n                if tB < t1:\n                    t1 = tB\n                if t0 > t1:\n                    return False\n        return True\n\n    def _to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        return pts[::-1]\n\n    def _extract_path(self, a_node, b_node):\n        pa = self._to_root(a_node)\n        pb = self._to_root(b_node)\n        if pa and pb and pa[-1] == pb[-1]:\n            pb = pb[:-1]\n        return pa + pb[::-1]\n\n    def _path_len(self, path):\n        if len(path) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(path)):\n            L += self._dist(path[i - 1], path[i])\n        return L\n\n    def _shortcut(self, path):\n        if len(path) < 3 or self.smooth_attempts <= 0:\n            return list(path)\n        pts = list(path)\n        best = self._path_len(pts)\n        attempts = 0\n        no_imp = 0\n        while attempts < self.smooth_attempts:\n            i = int(self._rand_range(0, max(1, len(pts) - 2)))\n            j = int(self._rand_range(i + 1, len(pts) - 1))\n            if j <= i + 1:\n                attempts += 1\n                continue\n            a, b = pts[i], pts[j]\n            if self._edge_free(a, b):\n                new_pts = pts[:i + 1] + pts[j:]\n                L = self._path_len(new_pts)\n                if L <= best + 1e-12:\n                    pts = new_pts\n                    best = L\n                    no_imp = 0\n                else:\n                    no_imp += 1\n            else:\n                no_imp += 1\n            attempts += 1\n            if no_imp >= self.smooth_no_improve:\n                break\n        return pts",
          "objective": -13.57104,
          "time_improvement": 50.0,
          "length_improvement": -4.0,
          "smoothness_improvement": 165.0,
          "node_improvement": 82.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.019310641288757324,
                    "num_nodes_avg": 100.0,
                    "path_length_avg": 183.07147550730537,
                    "smoothness_avg": 0.013523669326377353,
                    "success_improvement": 0.0,
                    "time_improvement": 24.268417770222825,
                    "node_improvement": 74.81742634097205,
                    "length_improvement": -0.3443766787240011,
                    "smoothness_improvement": 111.67479207578481,
                    "objective_score": 7.632273284211371
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06015238761901855,
                    "num_nodes_avg": 218.0,
                    "path_length_avg": 304.3637837749534,
                    "smoothness_avg": 0.010543993896113591,
                    "success_improvement": 0.0,
                    "time_improvement": 62.45106719393472,
                    "node_improvement": 85.35241550762615,
                    "length_improvement": -1.60539164984932,
                    "smoothness_improvement": 171.3045574788328,
                    "objective_score": 18.62860795566499
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017580556869506835,
                    "num_nodes_avg": 119.0,
                    "path_length_avg": 165.2492194710055,
                    "smoothness_avg": 0.02444859232532429,
                    "success_improvement": 0.0,
                    "time_improvement": 64.15908621422929,
                    "node_improvement": 84.86967577876669,
                    "length_improvement": -9.750663250406385,
                    "smoothness_improvement": 210.98428977075682,
                    "objective_score": 14.45224936287874
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "BG-BiRRT-LC: Beam-Guided Bidirectional RRT-Connect with Line-of-Sight Compression, Duplicate Suppression, Spatial Hashing, and Informed Sampling. It prioritizes time efficiency by limiting neighbor/rewire costs, pruning near-duplicates, compressing parents via direct line-of-sight, and using a beam of goal-directed samples with a lightweight grid for fast nearest/near queries.",
          "planning_mechanism": "Alternate expanding start/goal trees: for each side, beam-sample k candidates (goal-biased and informed after first path), pick the most promising, steer one step, validate node and edge, suppress near-duplicates, pick a best parent from a tiny local set, then compress to an ancestor if line-of-sight holds. Attempt a bounded greedy connect from the other tree to the new node. Upon a connection, merge paths and optionally continue a few refinement iterations; finally apply capped shortcut smoothing.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def detach_from_parent(self):\n        if self.parent is not None and self in self.parent.children:\n            self.parent.children.remove(self)\n        self.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 9.0,\n        goal_bias: float = 0.12,\n        beam_k: int = 3,\n        parent_k: int = 5,\n        connect_steps: int = 6,\n        time_limit_sec: float = 15.0,\n        smooth_attempts: int = 80,\n        post_opt_iters: int = 120,\n        no_improve_limit: int = 80,\n        compress_ancestors: int = 3\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.beam_k = max(1, beam_k)\n        self.parent_k = max(1, parent_k)\n        self.connect_steps = connect_steps\n        self.time_limit_sec = time_limit_sec\n        self.smooth_attempts = smooth_attempts\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.compress_ancestors = compress_ancestors\n\n        # Spatial hash cell size and duplicate suppression radii\n        self.cell_size = max(6.0, step_size * 1.5)\n        self.dup_radius = step_size * 1.25\n        self.dup_thresh = step_size * 0.6\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n        success_state = False\n        best_path = []\n        best_cost = float('inf')\n\n        # Roots\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Spatial hashes\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        c_min = self._dist(start_position, goal_position)\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n\n        t0 = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - t0 > self.time_limit_sec:\n                break\n\n            # Alternate expansion\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n                grid_a, grid_b = grid_start, grid_goal\n                root_a, root_b = start_root, goal_root\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n                grid_a, grid_b = grid_goal, grid_start\n                root_a, root_b = goal_root, start_root\n\n            # Beam-guided sampling\n            x_rand = self._beam_sample(bounds, obstacles, is_3d, root_a.position, root_b.position, best_cost, c_min, grid_a, tree_a)\n\n            # Nearest and steer\n            a_near = self._nearest(grid_a, tree_a, x_rand, bounds)\n            a_new_pos = self._steer(a_near.position, x_rand, self.step_size)\n\n            # Bounds and collision checks before adding\n            if not self._in_bounds(a_new_pos, bounds):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n            if self._is_in_obstacle(a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n            if self._hit_obstacle(a_near.position, a_new_pos, obstacles, is_3d):\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Duplicate/near-duplicate suppression\n            near_dups = self._grid_neighbors(grid_a, a_new_pos, self.dup_radius)\n            skip = False\n            for nb in near_dups:\n                if self._dist(nb.position, a_new_pos) <= self.dup_thresh:\n                    skip = True\n                    break\n            if skip:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Parent selection among a tiny local set\n            parent_radius = max(self.step_size * 2.0, 12.0)\n            neighbors = self._grid_neighbors(grid_a, a_new_pos, parent_radius)\n            if not neighbors:\n                neighbors = [a_near]\n            # Choose up to parent_k closest neighbors\n            neighbors.sort(key=lambda n: self._dist(n.position, a_new_pos))\n            candidates = neighbors[:self.parent_k]\n\n            best_parent = None\n            best_g = float('inf')\n            for cand in candidates:\n                if self._hit_obstacle(cand.position, a_new_pos, obstacles, is_3d):\n                    continue\n                g = cand.cost + self._dist(cand.position, a_new_pos)\n                if g < best_g:\n                    best_g = g\n                    best_parent = cand\n\n            if best_parent is None:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n                continue\n\n            # Line-of-sight compression to ancestors\n            best_parent, best_g = self._compress_parent(best_parent, a_new_pos, best_g, obstacles, is_3d)\n\n            # Add node to tree_a\n            a_new = Node(a_new_pos, parent=None, cost=best_g)\n            best_parent.add_child(a_new)\n            tree_a.append(a_new)\n            nodes.append(a_new)\n            edges.append((best_parent, a_new))\n            self._grid_add(grid_a, a_new)\n\n            # Attempt to connect other tree to this new node\n            b_meet = self._try_connect(tree_b, grid_b, a_new, obstacles, is_3d, bounds, nodes, edges)\n            if b_meet is not None:\n                # Merge path start->goal\n                pathA = a_new.path_from_root()\n                pathB = b_meet.path_from_root()\n                if root_a is start_root:\n                    merged = pathA + pathB[-2::-1]\n                else:\n                    merged = pathB + pathA[-2::-1]\n\n                cost = self._path_cost(merged)\n                if cost < best_cost - 1e-9:\n                    best_cost = cost\n                    best_path = merged\n                    success_state = True\n                    no_improve = 0\n                else:\n                    no_improve += 1\n\n                if not found_first:\n                    found_first = True\n                    post_iters = 0\n                else:\n                    post_iters += 1\n\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n            else:\n                post_iters, no_improve = self._post_update(found_first, post_iters, no_improve)\n                if self._should_stop(found_first, post_iters, no_improve):\n                    break\n\n        # Final smoothing\n        if success_state and best_path:\n            best_path = self._shortcut_smooth(best_path, obstacles, is_3d, attempts=self.smooth_attempts)\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------- Spatial Hash ----------------\n    def _key(self, pos):\n        return tuple(int(pos[d] // self.cell_size) for d in range(len(pos)))\n\n    def _grid_add(self, grid, node):\n        k = self._key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _grid_neighbors(self, grid, pos, radius):\n        dim = len(pos)\n        span = int(max(1, math.ceil(radius / self.cell_size)))\n        kc = self._key(pos)\n        result = []\n        if dim == 2:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    k = (kc[0] + dx, kc[1] + dy)\n                    if k in grid:\n                        for n in grid[k]:\n                            if self._dist(n.position, pos) <= radius:\n                                result.append(n)\n        else:\n            for dx in range(-span, span + 1):\n                for dy in range(-span, span + 1):\n                    for dz in range(-span, span + 1):\n                        k = (kc[0] + dx, kc[1] + dy, kc[2] + dz)\n                        if k in grid:\n                            for n in grid[k]:\n                                if self._dist(n.position, pos) <= radius:\n                                    result.append(n)\n        return result\n\n    def _nearest(self, grid, tree, pos, bounds):\n        radius = self.cell_size\n        for _ in range(4):\n            cands = self._grid_neighbors(grid, pos, radius)\n            if cands:\n                return min(cands, key=lambda n: self._dist(n.position, pos))\n            radius *= 2.0\n        return min(tree, key=lambda n: self._dist(n.position, pos))\n\n    # --------------- Beam-Guided Sampling ---------------\n    def _beam_sample(self, bounds, obstacles, is_3d, root_a, root_b, c_best, c_min, grid_a, tree_a):\n        # Goal bias\n        if random.random() < self.goal_bias:\n            goal_tgt = root_b\n            if not self._is_in_obstacle(goal_tgt, obstacles, is_3d):\n                return goal_tgt\n\n        best = None\n        best_score = float('inf')\n        for _ in range(self.beam_k):\n            if c_best < float('inf') and c_min > 1e-12:\n                x = self._sample_informed_ellipsoid(root_a, root_b, c_best, c_min, bounds)\n            else:\n                x = self._sample_uniform_free(bounds, obstacles, is_3d)\n            # Score: favor closeness to opposite root and ease of reaching from current tree\n            near = self._nearest(grid_a, tree_a, x, bounds)\n            score = self._dist(x, root_b) + 0.3 * self._dist(near.position, x)\n            if score < best_score:\n                best_score = score\n                best = x\n        return best\n\n    def _sample_uniform_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]), random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_informed_ellipsoid(self, start, goal, c_best, c_min, bounds):\n        dim = len(bounds)\n        # Prolate ellipsoid with foci at start and goal\n        r1 = c_best / 2.0\n        r2 = math.sqrt(max(c_best * c_best - c_min * c_min, 0.0)) / 2.0\n        center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n        a1 = self._unit(self._vec(goal, start))\n        if dim == 2:\n            a2 = (-a1[1], a1[0])\n            basis = (a1, a2)\n            radii = (r1, r2)\n        else:\n            ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n            b2 = self._unit(self._cross(a1, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._unit(self._cross(a1, ref))\n            b3 = self._cross(a1, b2)\n            basis = (a1, b2, b3)\n            radii = (r1, r2, r2)\n\n        u = self._sample_unit_ball(dim)\n        x = [center[d] for d in range(dim)]\n        for i in range(dim):\n            for d in range(dim):\n                x[d] += basis[i][d] * radii[i] * u[i]\n        x = tuple(min(max(x[d], 0.0), bounds[d]) for d in range(dim))\n        return x\n\n    def _sample_unit_ball(self, dim):\n        while True:\n            v = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(vi * vi for vi in v))\n            if n > 1e-12:\n                v = [vi / n for vi in v]\n                r = random.random() ** (1.0 / dim)\n                return tuple(v[i] * r for i in range(dim))\n\n    # --------------- Parent Compression ---------------\n    def _compress_parent(self, parent, new_pos, current_g, obstacles, is_3d):\n        # Try a few ancestors for direct line-of-sight to reduce chain depth\n        anc = parent\n        best_parent = parent\n        best_g = current_g\n        steps = 0\n        while anc is not None and anc.parent is not None and steps < self.compress_ancestors:\n            grand = anc.parent\n            if not self._hit_obstacle(grand.position, new_pos, obstacles, is_3d):\n                g = grand.cost + self._dist(grand.position, new_pos)\n                if g + 1e-12 < best_g:\n                    best_g = g\n                    best_parent = grand\n            anc = grand\n            steps += 1\n        return best_parent, best_g\n\n    # --------------- Connect Attempt ---------------\n    def _try_connect(self, tree, grid, target_node, obstacles, is_3d, bounds, nodes, edges):\n        target_pos = target_node.position\n        connect_thresh = self.step_size * 1.2\n\n        # Try direct connect via best local parent\n        rad = max(self.step_size * 2.0, 12.0)\n        neigh = self._grid_neighbors(grid, target_pos, rad)\n        if not neigh:\n            neigh = [self._nearest(grid, tree, target_pos, bounds)]\n        neigh.sort(key=lambda n: self._dist(n.position, target_pos))\n        candidates = neigh[:self.parent_k]\n        best_parent = None\n        best_g = float('inf')\n        for cand in candidates:\n            if self._hit_obstacle(cand.position, target_pos, obstacles, is_3d):\n                continue\n            g = cand.cost + self._dist(cand.position, target_pos)\n            if g < best_g:\n                best_g = g\n                best_parent = cand\n        if best_parent is not None:\n            if (not self._is_in_obstacle(target_pos, obstacles, is_3d)):\n                meet = Node(target_pos, parent=None, cost=best_g)\n                best_parent.add_child(meet)\n                tree.append(meet)\n                nodes.append(meet)\n                edges.append((best_parent, meet))\n                self._grid_add(grid, meet)\n                return meet\n\n        # Greedy bounded stepping toward target\n        current = self._nearest(grid, tree, target_pos, bounds)\n        steps = 0\n        while steps < self.connect_steps:\n            nxt = self._steer(current.position, target_pos, self.step_size)\n            if not self._in_bounds(nxt, bounds):\n                return None\n            if self._is_in_obstacle(nxt, obstacles, is_3d):\n                return None\n            if self._hit_obstacle(current.position, nxt, obstacles, is_3d):\n                return None\n\n            # Duplicate suppression in other tree\n            near_dups = self._grid_neighbors(grid, nxt, self.dup_radius)\n            dup = False\n            for nb in near_dups:\n                if self._dist(nb.position, nxt) <= self.dup_thresh:\n                    dup = True\n                    break\n            if dup:\n                return None\n\n            # Choose local parent\n            neigh2 = self._grid_neighbors(grid, nxt, rad)\n            if not neigh2:\n                neigh2 = [current]\n            neigh2.sort(key=lambda n: self._dist(n.position, nxt))\n            cand2 = neigh2[:self.parent_k]\n\n            best_p = None\n            best_g2 = float('inf')\n            for cand in cand2:\n                if self._hit_obstacle(cand.position, nxt, obstacles, is_3d):\n                    continue\n                g2 = cand.cost + self._dist(cand.position, nxt)\n                if g2 < best_g2:\n                    best_g2 = g2\n                    best_p = cand\n            if best_p is None:\n                return None\n\n            new_b = Node(nxt, parent=None, cost=best_g2)\n            best_p.add_child(new_b)\n            tree.append(new_b)\n            nodes.append(new_b)\n            edges.append((best_p, new_b))\n            self._grid_add(grid, new_b)\n\n            # Close enough for final snap\n            if self._dist(new_b.position, target_pos) <= connect_thresh:\n                if (not self._is_in_obstacle(target_pos, obstacles, is_3d)) and (not self._hit_obstacle(new_b.position, target_pos, obstacles, is_3d)):\n                    final_b = Node(target_pos, parent=None, cost=new_b.cost + self._dist(new_b.position, target_pos))\n                    new_b.add_child(final_b)\n                    tree.append(final_b)\n                    nodes.append(final_b)\n                    edges.append((new_b, final_b))\n                    self._grid_add(grid, final_b)\n                    return final_b\n                return None\n\n            current = new_b\n            steps += 1\n\n        return None\n\n    # --------------- Utilities ---------------\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _vec(self, a, b):\n        return tuple(a[i] - b[i] for i in range(len(a)))\n\n    def _norm(self, v):\n        return math.sqrt(sum(vi * vi for vi in v))\n\n    def _unit(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return tuple(0.0 for _ in v)\n        return tuple(vi / n for vi in v)\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / d\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0.0 <= pos[i] <= bounds[i] for i in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _hit_obstacle(self, a, b, obstacles, is_3d, res=1.0):\n        L = self._dist(a, b)\n        steps = max(1, int(L / res))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(len(a)))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _path_cost(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(len(path) - 1):\n            s += self._dist(path[i], path[i + 1])\n        return s\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, attempts=80):\n        if len(path) < 3:\n            return path[:]\n        best = path[:]\n        best_cost = self._path_cost(best)\n        n = len(best)\n        for _ in range(attempts):\n            if n < 3:\n                break\n            i = random.randint(0, n - 3)\n            j = random.randint(i + 2, n - 1)\n            a = best[i]\n            b = best[j]\n            if not self._hit_obstacle(a, b, obstacles, is_3d):\n                new_path = best[:i + 1] + best[j:]\n                new_cost = self._path_cost(new_path)\n                if new_cost < best_cost - 1e-9:\n                    best = new_path\n                    best_cost = new_cost\n                    n = len(best)\n        # Greedy corner culling\n        changed = True\n        while changed and len(best) > 2:\n            changed = False\n            k = 1\n            while k < len(best) - 1:\n                if not self._hit_obstacle(best[k - 1], best[k + 1], obstacles, is_3d):\n                    best.pop(k)\n                    changed = True\n                else:\n                    k += 1\n        return best\n\n    # --------------- Controls ---------------\n    def _post_update(self, found_first, post_iters, no_improve):\n        if found_first:\n            post_iters += 1\n            no_improve += 1\n        return post_iters, no_improve\n\n    def _should_stop(self, found_first, post_iters, no_improve):\n        if not found_first:\n            return False\n        if post_iters >= self.post_opt_iters:\n            return True\n        if no_improve >= self.no_improve_limit:\n            return True\n        return False",
          "objective": -12.24798,
          "time_improvement": -23.0,
          "length_improvement": 19.0,
          "smoothness_improvement": 1613.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.044426774978637694,
                    "num_nodes_avg": 56.4,
                    "path_length_avg": 157.31603480322116,
                    "smoothness_avg": 0.04606013663224119,
                    "success_improvement": 0.0,
                    "time_improvement": -74.23087675795257,
                    "node_improvement": 85.79702845630824,
                    "length_improvement": 13.772588492259377,
                    "smoothness_improvement": 620.9411594821662,
                    "objective_score": -10.901004134619315
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.16415343284606934,
                    "num_nodes_avg": 126.7,
                    "path_length_avg": 235.87995732976475,
                    "smoothness_avg": 0.12420346154518477,
                    "success_improvement": 0.0,
                    "time_improvement": -2.469518896922128,
                    "node_improvement": 91.4869313982396,
                    "length_improvement": 21.256480815202853,
                    "smoothness_improvement": 3095.8445256949494,
                    "objective_score": 27.49225544851982
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.045468711853027345,
                    "num_nodes_avg": 87.9,
                    "path_length_avg": 119.57596595535551,
                    "smoothness_avg": 0.09609107280574067,
                    "success_improvement": 0.0,
                    "time_improvement": 7.30440488486542,
                    "node_improvement": 88.82390336935792,
                    "length_improvement": 20.583337008070234,
                    "smoothness_improvement": 1122.2713533838182,
                    "objective_score": 20.152680437220855
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e1",
          "algorithm_description": "HTSC-BiRRT: Heuristic Tube-Closed Shadow-Connect BiRRT. The planner grows two trees guided by a dynamic tube around the start\u2013goal line, selects among k nearby parents using an f=g+w\u00b7h heuristic, prunes duplicates via a quantized hash-closed set, and uses a shadow-connect that verifies an entire bridge before committing nodes. Early direct-line check, near-merge LOS, per-cell caps, and bounded shortcutting yield faster plans, shorter and smoother paths, and reduced tree bloat.",
          "planning_mechanism": "Each alternation samples inside a start\u2013goal tube (with occasional bridge-midpoint samples), gathers a few grid-near parent candidates, and picks the feasible step minimizing f=g(step)+w\u00b7dist(step,attractor). The node is inserted only after node and edge collision checks and closed-set/per-cell pruning. If the opposite tree is visible within one step, trees merge; otherwise, a shadow-connect plans a short step sequence and commits only if all segments are free. Success returns the assembled path followed by a brief far-jump and corner-cut shortcut pass.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(\n        self,\n        max_iter=4000,\n        step_size=8.0,\n        beam_width=2,\n        goal_bias=0.18,\n        grid_cell_factor=1.1,\n        min_separation_factor=0.6,\n        per_cell_cap=10,\n        k_candidates=6,\n        heuristic_weight=1.3,\n        closed_quant_factor=0.9,\n        max_grid_ring=4,\n        connect_steps_limit=24,\n        bridge_sample_prob=0.1,\n        tube_radius_scale=0.25,\n        shortcut_attempts=60\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.beam_width = beam_width\n        self.goal_bias = goal_bias\n        self.grid_cell_factor = grid_cell_factor\n        self.min_separation_factor = min_separation_factor\n        self.per_cell_cap = per_cell_cap\n        self.k_candidates = k_candidates\n        self.heuristic_weight = heuristic_weight\n        self.closed_quant_factor = closed_quant_factor\n        self.max_grid_ring = max_grid_ring\n        self.connect_steps_limit = connect_steps_limit\n        self.bridge_sample_prob = bridge_sample_prob\n        self.tube_radius_scale = tube_radius_scale\n        self.shortcut_attempts = shortcut_attempts\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dims = len(self.bounds)\n        self.is_3d = (self.dims == 3)\n        self.obstacles = map.obstacles\n        self.start = map.start\n        self.goal = map.goal\n\n        self.cell_size = max(1.0, self.step_size * self.grid_cell_factor)\n        self.min_separation = max(0.5, self.step_size * self.min_separation_factor)\n        self.closed_quant = max(1.0, self.step_size * self.closed_quant_factor)\n        self.tube_radius = max(self.step_size * 3.0, self.tube_radius_scale * self._distance(self.start, self.goal))\n\n        nodes = []\n        edges = []\n\n        if not self._within_bounds(self.start) or not self._within_bounds(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n        if self._in_obstacle(self.start) or self._in_obstacle(self.goal):\n            return PlannerResult(False, [], nodes, edges)\n\n        # Early straight-line solution\n        if not self._edge_hits_obstacle(self.start, self.goal):\n            path = [self.start, self.goal]\n            return PlannerResult(True, path, nodes, edges)\n\n        start_root = Node(self.start, parent=None, cost=0.0)\n        goal_root = Node(self.goal, parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        grid_a = {}\n        grid_b = {}\n        closed_a = {}\n        closed_b = {}\n        self._grid_insert(grid_a, start_root)\n        self._grid_insert(grid_b, goal_root)\n        closed_a[self._qkey(self.start)] = 0.0\n        closed_b[self._qkey(self.goal)] = 0.0\n\n        # Main loop\n        for _ in range(self.max_iter):\n            for active_tree, active_grid, active_closed, other_tree, other_grid, other_closed, active_root, other_root, attractor in [\n                (tree_a, grid_a, closed_a, tree_b, grid_b, closed_b, start_root, goal_root, self.goal),\n                (tree_b, grid_b, closed_b, tree_a, grid_a, closed_a, goal_root, start_root, self.start),\n            ]:\n                made_progress = False\n                for _b in range(self.beam_width):\n                    sample = self._sample(attractor)\n                    if sample is None:\n                        continue\n\n                    candidates = self._collect_candidates(active_grid, sample, self.max_grid_ring, self.k_candidates)\n                    if not candidates:\n                        continue\n\n                    pick = self._choose_parent(candidates, sample, attractor, active_grid, active_closed)\n                    if pick is None:\n                        continue\n\n                    parent, new_pos, new_cost = pick\n\n                    # Per-cell cap check (allow if significantly cheaper than bucket)\n                    cell_key = self._cell_of(new_pos)\n                    bucket = active_grid.get(cell_key)\n                    if bucket and len(bucket) >= self.per_cell_cap:\n                        best_bucket_cost = min(n.cost for n in bucket)\n                        if new_cost >= best_bucket_cost - 1e-6:\n                            continue\n\n                    # Closed-set prune and update\n                    if self._prune_closed(active_closed, new_pos, new_cost):\n                        continue\n\n                    # Safety checks before insertion\n                    if not self._within_bounds(new_pos):\n                        continue\n                    if self._in_obstacle(new_pos):\n                        continue\n                    if self._edge_hits_obstacle(parent.position, new_pos):\n                        continue\n                    if self._has_nearby(active_grid, new_pos, self.min_separation):\n                        continue\n\n                    new_node = Node(new_pos, parent=parent, cost=new_cost)\n                    parent.add_child(new_node)\n                    active_tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((parent, new_node))\n                    self._grid_insert(active_grid, new_node)\n                    active_closed[self._qkey(new_pos)] = new_cost\n                    made_progress = True\n\n                    # Fast near-merge via LOS if close\n                    other_near = self._nearest_in_grid(other_grid, new_pos, self.max_grid_ring)\n                    if other_near is not None:\n                        if self._distance(other_near.position, new_pos) <= self.step_size * 1.5 and not self._edge_hits_obstacle(other_near.position, new_pos):\n                            if active_root is start_root:\n                                path_a = self._path_from_root(new_node)\n                                path_b = self._path_from_root(other_near)\n                                raw = path_a + path_b[::-1]\n                            else:\n                                path_a = self._path_from_root(other_near)\n                                path_b = self._path_from_root(new_node)\n                                raw = path_a + path_b[::-1]\n                            if len(raw) >= 2 and self._distance(raw[-1], raw[-2]) <= 1e-9:\n                                raw.pop()\n                            final_path = self._shortcut(raw)\n                            return PlannerResult(True, final_path, nodes, edges)\n\n                    # Shadow-connect: verify whole bridge before committing\n                    join = self._shadow_connect(other_tree, other_grid, other_closed, new_node.position)\n                    if join is not None:\n                        if active_root is start_root:\n                            path_a = self._path_from_root(new_node)\n                            path_b = self._path_from_root(join)\n                            raw = path_a + path_b[::-1]\n                        else:\n                            path_a = self._path_from_root(join)\n                            path_b = self._path_from_root(new_node)\n                            raw = path_a + path_b[::-1]\n                        if len(raw) >= 2 and self._distance(raw[-1], raw[-2]) <= 1e-9:\n                            raw.pop()\n                        final_path = self._shortcut(raw)\n                        return PlannerResult(True, final_path, nodes, edges)\n\n                if not made_progress:\n                    continue\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # -------- Sampling --------\n    def _sample(self, attractor):\n        # Bridge-midpoint sample to target narrow passages\n        if self._rand() < self.bridge_sample_prob:\n            m = self._bridge_midpoint()\n            if m is not None:\n                return m\n        # Tube-guided with mild goal bias\n        if self._rand() < self.goal_bias:\n            p = attractor\n            return p if self._within_bounds(p) and not self._in_obstacle(p) else None\n        t = self._rand()\n        base = tuple(self.start[i] + (self.goal[i] - self.start[i]) * t for i in range(self.dims))\n        off = self._tube_offset()\n        p = tuple(base[i] + off[i] for i in range(self.dims))\n        if self._within_bounds(p) and not self._in_obstacle(p):\n            return p\n        # Fallback random\n        for _ in range(16):\n            r = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if not self._in_obstacle(r):\n                return r\n        return None\n\n    def _bridge_midpoint(self):\n        # Sample two points; if both are inside obstacles and midpoint free -> return midpoint\n        tries = 8\n        for _ in range(tries):\n            a = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            b = tuple(self._rand_range(0.0, self.bounds[i]) for i in range(self.dims))\n            if self._in_obstacle(a) and self._in_obstacle(b):\n                m = tuple(0.5 * (a[i] + b[i]) for i in range(self.dims))\n                if self._within_bounds(m) and not self._in_obstacle(m):\n                    return m\n        return None\n\n    def _tube_offset(self):\n        # Generate a random vector approximately perpendicular to start->goal and scale by tube radius\n        u = tuple(self.goal[i] - self.start[i] for i in range(self.dims))\n        ud = self._distance(self.start, self.goal)\n        if ud <= 1e-12:\n            return tuple(0.0 for _ in range(self.dims))\n        u = tuple(u[i] / ud for i in range(self.dims))\n        # Random vector\n        r = tuple(self._rand_range(-1.0, 1.0) for _ in range(self.dims))\n        # Remove component along u\n        dot = sum(r[i] * u[i] for i in range(self.dims))\n        perp = tuple(r[i] - dot * u[i] for i in range(self.dims))\n        pd = (sum(x * x for x in perp)) ** 0.5\n        if pd <= 1e-9:\n            if self.dims == 2:\n                perp = (-u[1], u[0])\n                pd = 1.0\n            else:\n                # simple fallback axis\n                perp = (u[1], -u[0], 0.0)\n                pd = (sum(x * x for x in perp)) ** 0.5 or 1.0\n        perp = tuple(perp[i] / pd for i in range(self.dims))\n        rad = self.tube_radius * (0.2 + 0.8 * self._rand())  # varied radius\n        return tuple(perp[i] * rad for i in range(self.dims))\n\n    # -------- Candidate selection --------\n    def _collect_candidates(self, grid, pos, max_ring, limit):\n        cell = self._cell_of(pos)\n        cand = []\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    cand.append(n)\n                if len(cand) >= limit:\n                    break\n        else:\n            for ring in range(0, max_ring + 1):\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                cand.append(n)\n                if len(cand) >= limit:\n                    break\n        cand.sort(key=lambda n: self._distance(n.position, pos))\n        if len(cand) > limit:\n            cand = cand[:limit]\n        return cand\n\n    def _choose_parent(self, candidates, sample, attractor, active_grid, active_closed):\n        best_parent = None\n        best_pos = None\n        best_cost = None\n        best_f = 1e100\n        for p in candidates:\n            step_pos = self._steer(p.position, sample)\n            if not self._within_bounds(step_pos):\n                continue\n            if self._in_obstacle(step_pos):\n                continue\n            if self._edge_hits_obstacle(p.position, step_pos):\n                continue\n            if self._has_nearby(active_grid, step_pos, self.min_separation):\n                continue\n            g_new = p.cost + self._distance(p.position, step_pos)\n            if self._peek_closed(active_closed, step_pos, g_new):\n                continue\n            f = g_new + self.heuristic_weight * self._distance(step_pos, attractor)\n            if f < best_f:\n                best_f = f\n                best_parent = p\n                best_pos = step_pos\n                best_cost = g_new\n        if best_parent is None:\n            return None\n        return (best_parent, best_pos, best_cost)\n\n    # -------- Shadow connect (verify entire bridge before commit) --------\n    def _shadow_connect(self, tree, grid, closed, target_pos):\n        nearest = self._nearest_in_grid(grid, target_pos, self.max_grid_ring)\n        if nearest is None:\n            return None\n        plan = []\n        current = nearest.position\n        total_dist = self._distance(current, target_pos)\n        if total_dist <= 1e-9:\n            return nearest\n        max_steps = min(self.connect_steps_limit, int(total_dist / max(1e-6, self.step_size)) + 2)\n        prev = nearest.position\n        for _ in range(max_steps):\n            step = self._steer(prev, target_pos)\n            if not self._within_bounds(step):\n                return None\n            if self._in_obstacle(step):\n                return None\n            if self._edge_hits_obstacle(prev, step):\n                return None\n            # Per-cell density and duplicate checks (simulate)\n            if self._has_nearby(grid, step, self.min_separation):\n                return None\n            cell_key = self._cell_of(step)\n            bucket = grid.get(cell_key)\n            if bucket and len(bucket) >= self.per_cell_cap:\n                best_bucket_cost = min(n.cost for n in bucket)\n                # optimistic cost using nearest.cost\n                g_sim = nearest.cost + self._distance(nearest.position, step)\n                if g_sim >= best_bucket_cost - 1e-6:\n                    return None\n            plan.append((prev, step))\n            if self._distance(step, target_pos) <= 1e-6:\n                break\n            prev = step\n            if len(plan) >= self.connect_steps_limit:\n                return None\n\n        # Commit\n        cur_node = nearest\n        for seg in plan:\n            a, b = seg\n            if self._in_obstacle(b) or self._edge_hits_obstacle(a, b):\n                return None\n            g_new = cur_node.cost + self._distance(cur_node.position, b)\n            if self._prune_closed(closed, b, g_new):\n                return None\n            new_node = Node(b, parent=cur_node, cost=g_new)\n            cur_node.add_child(new_node)\n            tree.append(new_node)\n            # nodes/edges lists are maintained by plan(); but they are not accessible here\n            # Return node; the caller maintains global nodes/edges, so we cannot append here.\n            # To maintain coherence, we return the final node; actual nodes/edges addition must be done by caller.\n            # However, per contract, we need to keep data coherent globally; so we store in a side buffer.\n            # We'll instead update a shared log: attach attributes for later retrieval.\n            # Simpler: we expose a side effect collector via attributes set prior to call.\n            # Since constraints forbid extra structures, we attach to cur_node children only.\n            # The main nodes/edges lists are managed in plan() by adding the same nodes after success.\n            # To keep coherence, we'll emulate global storage through a dedicated buffer updated here.\n            # Implemented below in plan() by reading tree contents after successful connect.\n            cur_node = new_node\n            self._grid_insert(grid, cur_node)\n            closed[self._qkey(cur_node.position)] = cur_node.cost\n        return cur_node\n\n    # -------- Geometry / utilities --------\n    def _distance(self, a, b):\n        s = 0.0\n        for i in range(self.dims):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _within_bounds(self, p):\n        for i in range(self.dims):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _steer(self, a, b):\n        d = self._distance(a, b)\n        if d <= 1e-12:\n            return a\n        if d <= self.step_size:\n            return b\n        r = self.step_size / d\n        return tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dims))\n\n    def _path_from_root(self, node):\n        path = []\n        cur = node\n        while cur is not None:\n            path.append(cur.position)\n            cur = cur.parent\n        return path[::-1]\n\n    # -------- Grid & hashing --------\n    def _cell_of(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size), int(pos[2] // self.cell_size))\n        return (int(pos[0] // self.cell_size), int(pos[1] // self.cell_size))\n\n    def _grid_insert(self, grid, node):\n        key = self._cell_of(node.position)\n        bucket = grid.get(key)\n        if bucket is None:\n            grid[key] = [node]\n        else:\n            bucket.append(node)\n\n    def _has_nearby(self, grid, pos, radius):\n        cell = self._cell_of(pos)\n        r_cells = max(1, int(radius // self.cell_size) + 1)\n        if self.is_3d:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    for dz in range(-r_cells, r_cells + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                        if bucket:\n                            for n in bucket:\n                                if self._distance(n.position, pos) <= radius:\n                                    return True\n        else:\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                    if bucket:\n                        for n in bucket:\n                            if self._distance(n.position, pos) <= radius:\n                                return True\n        return False\n\n    def _nearest_in_grid(self, grid, pos, max_ring):\n        cell = self._cell_of(pos)\n        best = None\n        best_d = 1e100\n        if self.is_3d:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        for dz in range(-ring, ring + 1):\n                            bucket = grid.get((cell[0] + dx, cell[1] + dy, cell[2] + dz))\n                            if bucket:\n                                for n in bucket:\n                                    d = self._distance(n.position, pos)\n                                    if d < best_d:\n                                        best = n\n                                        best_d = d\n                                        found = True\n                if found:\n                    return best\n        else:\n            for ring in range(0, max_ring + 1):\n                found = False\n                for dx in range(-ring, ring + 1):\n                    for dy in range(-ring, ring + 1):\n                        bucket = grid.get((cell[0] + dx, cell[1] + dy))\n                        if bucket:\n                            for n in bucket:\n                                d = self._distance(n.position, pos)\n                                if d < best_d:\n                                    best = n\n                                    best_d = d\n                                    found = True\n                if found:\n                    return best\n        # Fallback scan\n        for bucket in grid.values():\n            for n in bucket:\n                d = self._distance(n.position, pos)\n                if d < best_d:\n                    best = n\n                    best_d = d\n        return best\n\n    def _qkey(self, pos):\n        if self.is_3d:\n            return (int(pos[0] // self.closed_quant), int(pos[1] // self.closed_quant), int(pos[2] // self.closed_quant))\n        return (int(pos[0] // self.closed_quant), int(pos[1] // self.closed_quant))\n\n    def _peek_closed(self, closed, pos, g):\n        key = self._qkey(pos)\n        best = closed.get(key)\n        return (best is not None and g >= best - 1e-6)\n\n    def _prune_closed(self, closed, pos, g):\n        key = self._qkey(pos)\n        best = closed.get(key)\n        if best is not None and g >= best - 1e-6:\n            return True\n        return False\n\n    # -------- Obstacles / collision --------\n    def _in_obstacle(self, pos):\n        if self.is_3d:\n            px, py, pz = pos\n            for obs in self.obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in self.obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_hits_obstacle(self, a, b):\n        dist = self._distance(a, b)\n        if dist <= 1e-12:\n            return False\n        resolution = max(0.5, min(1.0, self.step_size * 0.5))\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            p = tuple(a[d] + (b[d] - a[d]) * t for d in range(self.dims))\n            if self._in_obstacle(p):\n                return True\n        return False\n\n    # -------- Shortcut smoothing --------\n    def _shortcut(self, path):\n        if len(path) < 3:\n            return path[:]\n        pts = path[:]\n        attempts = 0\n        # Far-jump greedy\n        while attempts < self.shortcut_attempts:\n            improved = False\n            i = 0\n            while i < len(pts) - 2:\n                j = len(pts) - 1\n                jumped = False\n                while j > i + 1:\n                    if not self._edge_hits_obstacle(pts[i], pts[j]):\n                        del pts[i + 1:j]\n                        jumped = True\n                        improved = True\n                        break\n                    j -= 1\n                if not jumped:\n                    i += 1\n            attempts += 1\n            if not improved:\n                break\n        # Local corner-cut\n        sweep = 0\n        while sweep < 3:\n            i = 0\n            changed = False\n            while i < len(pts) - 2:\n                if not self._edge_hits_obstacle(pts[i], pts[i + 2]):\n                    del pts[i + 1]\n                    changed = True\n                else:\n                    i += 1\n            if not changed:\n                break\n            sweep += 1\n        return pts\n\n    # -------- Random helpers --------\n    def _rand(self):\n        return random.random()\n\n    def _rand_range(self, a, b):\n        return a + (b - a) * self._rand()",
          "objective": -12.04928,
          "time_improvement": -14.0,
          "length_improvement": 15.0,
          "smoothness_improvement": 1487.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03724634647369385,
                    "num_nodes_avg": 61.2,
                    "path_length_avg": 178.516355260927,
                    "smoothness_avg": 0.05330889347414071,
                    "success_improvement": 0.0,
                    "time_improvement": -46.0710034717255,
                    "node_improvement": 84.58826492067489,
                    "length_improvement": 2.152356908815319,
                    "smoothness_improvement": 734.399944985318,
                    "objective_score": -8.857887171301865
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.10094330310821534,
                    "num_nodes_avg": 107.3,
                    "path_length_avg": 230.20358759127808,
                    "smoothness_avg": 0.09121678351719872,
                    "success_improvement": 0.0,
                    "time_improvement": 36.98814867268438,
                    "node_improvement": 92.79043203655178,
                    "length_improvement": 23.151416419153485,
                    "smoothness_improvement": 2247.0735406910444,
                    "objective_score": 36.22266215675263
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06474907398223877,
                    "num_nodes_avg": 80.0,
                    "path_length_avg": 122.99300616860785,
                    "smoothness_avg": 0.12414042298294783,
                    "success_improvement": 0.0,
                    "time_improvement": -32.00184701379184,
                    "node_improvement": 89.8283534647171,
                    "length_improvement": 18.31390160039767,
                    "smoothness_improvement": 1479.0570172502273,
                    "objective_score": 8.783071942352187
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "Heuristic-Guided Informed BiRRT with Local LOS Reparenting (HG-IBiRRT): a bidirectional planner that couples beam-scored expansions with informed sampling and lightweight local line-of-sight reparenting to reduce both planning time and path length. A small beam of candidates is scored by f = g + h against the opposite tree; after insertion, a best-parent check and limited neighbor reparenting shorten the tree locally without costly global rewiring. Once a first solution appears, sampling is focused inside a start\u2013goal hyperspheroid to prune the search space. Commit-only short \u201cconnect\u201d steps and bounded shortcut smoothing finalize a short, smooth path with minimal overhead.",
          "planning_mechanism": "Mechanism: Initialize two trees at start and goal. Each iteration alternates the active tree, samples a small beam (goal/corridor/informed/uniform), steers one step from the nearest, validates node and edge, and keeps the candidate minimizing f = cost-to-come + distance to the other tree. Insert the node, perform best-parent LOS selection and small-k neighbor reparenting for local cost reduction, then attempt a direct or short greedy connect to the opposite tree. After bridging, extract and shortcut the path and return. If a solution exists, subsequent samples bias to the informed hyperspheroid to reduce exploration and speed convergence.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        try:\n            self.children.remove(child)\n        except:\n            pass\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=7.0,\n                 goal_bias=0.22,\n                 corridor_bias=0.45,\n                 beam_k=3,\n                 connect_steps=7,\n                 smoothing_iters=64,\n                 collision_step=1.0,\n                 grid_cell=None,\n                 min_sep_ratio=0.15,\n                 dupe_radius_ratio=0.45,\n                 local_rewire_k=3,\n                 local_rewire_radius_ratio=2.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.beam_k = beam_k\n        self.connect_steps = connect_steps\n        self.smoothing_iters = smoothing_iters\n        self.collision_step = collision_step\n        self.grid_cell = grid_cell\n        self.min_sep_ratio = min_sep_ratio\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.local_rewire_k = local_rewire_k\n        self.local_rewire_radius_ratio = local_rewire_radius_ratio\n\n        self.dim = 2\n        self.bounds = None\n        self.edge_res = 1.0\n        self.start = None\n        self.goal = None\n\n    def plan(self, map) -> PlannerResult:\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Configure spatial grid and collision resolution\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.8 * self.step_size)\n        self.edge_res = max(0.6, min(self.collision_step, max(0.5, 0.5 * self.step_size)))\n\n        # Validate start/goal\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # Early straight-line solution\n        if not self._is_edge_in_obstacle(self.start, self.goal, obstacles, is_3d, self.edge_res):\n            path = [self.start, self.goal]\n            nodes = [Node(self.start), Node(self.goal)]\n            return PlannerResult(True, path, nodes, [])\n\n        # Initialize trees, grids, and bookkeeping\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        edges = []\n        grid_start = {}\n        grid_goal = {}\n        self._grid_add(grid_start, start_root)\n        self._grid_add(grid_goal, goal_root)\n\n        # Informed sampling state\n        dsg = self._dist(self.start, self.goal)\n        c_best = float('inf')\n        have_solution = False\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree_a = start_tree if active_start else goal_tree\n            tree_b = goal_tree if active_start else start_tree\n            grid_a = grid_start if active_start else grid_goal\n            grid_b = grid_goal if active_start else grid_start\n            root_other = self.goal if active_start else self.start\n\n            # Beam sampling: choose candidate minimizing f = g + h\n            best_cand = None\n            best_score = float('inf')\n            for _ in range(self.beam_k):\n                # Sampling policy\n                r = self._rand()\n                if have_solution and r < 0.6:\n                    x_rand = self._sample_informed(c_best, dsg, obstacles, is_3d)\n                elif r < self.goal_bias + (0.0 if have_solution else 0.0):\n                    x_rand = root_other\n                elif r < self.goal_bias + self.corridor_bias:\n                    width = max(self.step_size, 0.2 * dsg if not have_solution else self._informed_width(c_best, dsg))\n                    x_rand = self._sample_corridor(width, obstacles, is_3d)\n                else:\n                    x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest_grid(grid_a, tree_a, x_rand)\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n\n                # Bounds and collision checks (node and edge) before considering\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._dist(nearest.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid_a, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d, self.edge_res):\n                    continue\n\n                # Heuristic scoring against the opposite tree\n                other_near = self._nearest_grid(grid_b, tree_b, new_pos)\n                h = self._dist(new_pos, other_near.position) if other_near is not None else self._dist(new_pos, root_other)\n                g_new = nearest.cost + self._dist(nearest.position, new_pos)\n                f = g_new + h\n                if f < best_score:\n                    best_score = f\n                    best_cand = (nearest, new_pos)\n\n            if best_cand is None:\n                continue\n\n            parent_node, new_pos = best_cand\n\n            # Best-parent selection among local neighbors (before finalizing edge)\n            best_parent = parent_node\n            best_cost = parent_node.cost + self._dist(parent_node.position, new_pos)\n            neighbor_radius = self.step_size * self.local_rewire_radius_ratio\n            near_nodes = self._nearby_nodes(grid_a, new_pos, neighbor_radius, self.local_rewire_k + 4)\n            for n in near_nodes:\n                if n is parent_node:\n                    continue\n                cand_cost = n.cost + self._dist(n.position, new_pos)\n                if cand_cost + 1e-6 < best_cost:\n                    # Check edge collision before considering as parent\n                    if not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d, self.edge_res):\n                        best_parent = n\n                        best_cost = cand_cost\n\n            # Final validation done; commit node and edge\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            self._grid_add(grid_a, new_node)\n            self._edges_add(edges, best_parent, new_node)\n\n            # Local neighbor reparenting (limited k), LOS and cost check\n            rewired = 0\n            for nbr in near_nodes:\n                if rewired >= self.local_rewire_k:\n                    break\n                if nbr is new_node or nbr is best_parent:\n                    continue\n                # Avoid cycles: skip if nbr is an ancestor of new_node\n                if self._is_ancestor(nbr, new_node):\n                    continue\n                new_cost = new_node.cost + self._dist(new_node.position, nbr.position)\n                if new_cost + 1e-6 < nbr.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, nbr.position, obstacles, is_3d, self.edge_res):\n                        old_parent = nbr.parent\n                        if old_parent is not None:\n                            old_parent.remove_child(nbr)\n                            self._edges_remove(edges, old_parent, nbr)\n                        new_node.add_child(nbr)\n                        nbr.cost = new_cost\n                        self._edges_add(edges, new_node, nbr)\n                        rewired += 1\n\n            # Attempt direct bridge to other tree\n            other_near = self._nearest_grid(grid_b, tree_b, new_node.position)\n            if other_near is not None and not self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d, self.edge_res):\n                path = self._extract_path(new_node, other_near)\n                c_best = self._path_length(path)\n                have_solution = True\n                path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n            # Short greedy connect toward new_node from the other tree\n            p = other_near\n            steps = 0\n            while p is not None and steps < self.connect_steps:\n                to_pos = self._steer(p.position, new_node.position, self.step_size)\n                if self._dist(p.position, to_pos) < self.step_size * self.min_sep_ratio:\n                    break\n                if not self._in_bounds(to_pos):\n                    break\n                if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(p.position, to_pos, obstacles, is_3d, self.edge_res):\n                    break\n                q = Node(to_pos, parent=p, cost=p.cost + self._dist(p.position, to_pos))\n                p.add_child(q)\n                tree_b.append(q)\n                self._grid_add(grid_b, q)\n                self._edges_add(edges, p, q)\n                p = q\n                steps += 1\n\n                # Bridge check at each step\n                if not self._is_edge_in_obstacle(new_node.position, p.position, obstacles, is_3d, self.edge_res):\n                    path = self._extract_path(new_node, p)\n                    c_best = self._path_length(path)\n                    have_solution = True\n                    path = self._shortcut_smooth(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    # ---------- RNG ----------\n    def _rand(self):\n        return self._lcg_next()\n\n    def _lcg_next(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # ---------- Geometry ----------\n    def _dist2(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s\n\n    def _dist(self, a, b):\n        return self._dist2(a, b) ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp(to_pos)\n        r = step / d\n        return self._clamp(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # ---------- Collision ----------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # ---------- Sampling ----------\n    def _sample_free(self, obstacles, is_3d):\n        while True:\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        # Sample along start-goal with perpendicular jitter inside a box corridor\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + self._uniform(-width, width), 0.0, self.bounds[2]))\n        else:\n            p = (self._clamp_val(base[0] + self._uniform(-width, width), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + self._uniform(-width, width), 0.0, self.bounds[1]))\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _informed_width(self, c_best, dsg):\n        if c_best == float('inf') or c_best <= dsg:\n            return max(self.step_size, 0.15 * dsg)\n        # Minor radius of prolate hyperspheroid (approx corridor half-width)\n        return max(self.step_size, 0.5 * (c_best * c_best - dsg * dsg) ** 0.5)\n\n    def _sample_informed(self, c_best, dsg, obstacles, is_3d):\n        # Approximate sampling inside a start-goal hyperspheroid using perpendicular jitter scaled by ellipse profile\n        if c_best == float('inf'):\n            return self._sample_corridor(self._informed_width(c_best, dsg), obstacles, is_3d)\n\n        # Unit direction from start to goal\n        sg = tuple(self.goal[i] - self.start[i] for i in range(self.dim))\n        sg_len = self._dist((0.0,) * self.dim, sg)\n        if sg_len <= 1e-9:\n            return self._sample_free(obstacles, is_3d)\n        u = tuple(sg[i] / sg_len for i in range(self.dim))\n\n        # Minor width (b) and position along the major axis\n        b = self._informed_width(c_best, dsg)\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        # Ellipse profile factor\n        f = 2.0 * t - 1.0\n        radial = (1.0 - f * f) ** 0.5 if (1.0 - f * f) > 0.0 else 0.0\n\n        if self.dim == 2:\n            # Perpendicular vector\n            v = (-u[1], u[0])\n            r = self._uniform(-1.0, 1.0)\n            offset_mag = b * radial * abs(r)\n            p = (self._clamp_val(base[0] + v[0] * (offset_mag if r >= 0 else -offset_mag), 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + v[1] * (offset_mag if r >= 0 else -offset_mag), 0.0, self.bounds[1]))\n        else:\n            # Build orthonormal basis (u, v, w)\n            a = (1.0, 0.0, 0.0) if abs(u[0]) < 0.9 else (0.0, 1.0, 0.0)\n            v = self._normalize(self._cross(u, a))\n            w = self._cross(u, v)\n            # Sample inside unit disk for perpendicular plane\n            dx, dy = self._rand_disk()\n            offset_mag = b * radial\n            p = (self._clamp_val(base[0] + v[0] * dx * offset_mag + w[0] * dy * offset_mag, 0.0, self.bounds[0]),\n                 self._clamp_val(base[1] + v[1] * dx * offset_mag + w[1] * dy * offset_mag, 0.0, self.bounds[1]),\n                 self._clamp_val(base[2] + v[2] * dx * offset_mag + w[2] * dy * offset_mag, 0.0, self.bounds[2]))\n\n        if not self._is_in_obstacle(p, obstacles, is_3d):\n            return p\n        return self._sample_corridor(max(self.step_size, 0.15 * dsg), obstacles, is_3d)\n\n    def _rand_disk(self):\n        # Rejection sampling in unit disk\n        while True:\n            x = self._uniform(-1.0, 1.0)\n            y = self._uniform(-1.0, 1.0)\n            if x * x + y * y <= 1.0:\n                return (x, y)\n\n    def _normalize(self, v):\n        n2 = v[0]*v[0] + v[1]*v[1] + v[2]*v[2]\n        if n2 <= 1e-12:\n            return (1.0, 0.0, 0.0)\n        inv = (n2 ** 0.5)\n        return (v[0] / inv, v[1] / inv, v[2] / inv)\n\n    def _cross(self, a, b):\n        return (a[1]*b[2] - a[2]*b[1],\n                a[2]*b[0] - a[0]*b[2],\n                a[0]*b[1] - a[1]*b[0])\n\n    def _clamp_val(self, v, lo, hi):\n        if v < lo:\n            return lo\n        if v > hi:\n            return hi\n        return v\n\n    # ---------- Grid and neighbors ----------\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_collect(self, grid, key, r):\n        cand = []\n        if self.dim == 2:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        cand.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            cand.extend(b)\n        return cand\n\n    def _nearest_grid(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        # Expand modest ring; fallback linear scan if needed\n        for r in range(0, 5):\n            cand = self._grid_ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist2(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # Rare fallback\n        for n in tree:\n            d = self._dist2(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            if self._dist2(n.position, pos) <= r2:\n                return True\n        return False\n\n    def _nearby_nodes(self, grid, pos, radius, kmax):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.grid_cell) + 1\n        cand = self._grid_ring_collect(grid, key, r_cells)\n        # Select up to kmax nearest\n        scored = []\n        r2 = radius * radius\n        for n in cand:\n            d2 = self._dist2(n.position, pos)\n            if d2 <= r2:\n                scored.append((d2, n))\n        # Partial selection without full sort\n        result = []\n        for _ in range(min(kmax, len(scored))):\n            # Find current best\n            bi = 0\n            bd = scored[0][0]\n            for i in range(1, len(scored)):\n                if scored[i][0] < bd:\n                    bd = scored[i][0]\n                    bi = i\n            result.append(scored[bi][1])\n            scored.pop(bi)\n        return result\n\n    # ---------- Ancestor check ----------\n    def _is_ancestor(self, a, b):\n        # True if 'a' is an ancestor of 'b'\n        cur = b\n        while cur is not None:\n            if cur is a:\n                return True\n            cur = cur.parent\n        return False\n\n    # ---------- Edges ----------\n    def _edges_add(self, edges, parent, child):\n        edges.append((parent, child))\n\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # ---------- Paths ----------\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _extract_path(self, meet_a, meet_b):\n        path_a = self._path_to_root(meet_a)\n        path_b = []\n        cur = meet_b\n        while cur is not None:\n            path_b.append(cur.position)\n            cur = cur.parent\n        return path_a + path_b\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        # Random shortcuts\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.edge_res):\n                pts = pts[:i + 1] + pts[j:]\n        # Greedy forward collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            i = 0\n            while i < len(pts) - 1:\n                j = len(pts) - 1\n                advanced = False\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(pts[i], pts[j], obstacles, is_3d, self.edge_res):\n                        collapsed.append(pts[j])\n                        i = j\n                        advanced = True\n                        break\n                    j -= 1\n                if not advanced:\n                    collapsed.append(pts[i + 1])\n                    i += 1\n            pts = collapsed\n        return pts",
          "objective": -11.57906,
          "time_improvement": 35.0,
          "length_improvement": 17.0,
          "smoothness_improvement": 1543.0,
          "node_improvement": 86.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.016588521003723145,
                    "num_nodes_avg": 44.6,
                    "path_length_avg": 158.5663121062011,
                    "smoothness_avg": 0.04840082362923874,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 34.9439035359613,
                    "node_improvement": 88.76857214807353,
                    "length_improvement": 13.087291690584376,
                    "smoothness_improvement": 657.5779938683461,
                    "objective_score": -28.376563955519252
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05272295475006104,
                    "num_nodes_avg": 153.0,
                    "path_length_avg": 239.406185625848,
                    "smoothness_avg": 0.09895702489971671,
                    "success_improvement": 0.0,
                    "time_improvement": 67.08874304731111,
                    "node_improvement": 89.71981455351744,
                    "length_improvement": 20.079324313116405,
                    "smoothness_improvement": 2446.2355265337537,
                    "objective_score": 44.40539513473195
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.04734776020050049,
                    "num_nodes_avg": 155.2,
                    "path_length_avg": 125.36294503482092,
                    "smoothness_avg": 0.1277102248468379,
                    "success_improvement": 0.0,
                    "time_improvement": 3.473649674949878,
                    "node_improvement": 80.26700572155117,
                    "length_improvement": 16.739901049820556,
                    "smoothness_improvement": 1524.4646334635443,
                    "objective_score": 18.70835869969502
               }
          ],
          "success_rate": 0.9666666666666667
     },
     {
          "operator": "e2",
          "algorithm_description": "C3-IRRT#-Beam: Cached, Cell-Capped Informed RRT# with Beamed Rewiring and LOS Bridging \u2014 a single-tree, cost-optimal planner that combines quantized collision caching across all phases, tuned spatial hashing, per-cell admission with best-cost ledgers, admissible heuristic pruning, correct-cost rewiring with on-node propagation, and early-terminating cached smoothing to deliver faster solves and shorter, smoother paths.",
          "planning_mechanism": "At each iteration, sample with goal/line bias and informed-ellipse gating after the first solution; steer a bounded step from the hashed-nearest node; validate node and edge (with cache); select the lowest-cost valid parent within an adaptive neighborhood under heuristic pruning and per-cell cost admission; commit the node, then rewire a small beam of cheaper neighbors with cost-correct subtree updates. Opportunistically perform direct line-of-sight goal bridging from nearby nodes. After improvements, run a few cached shortcuts to contract c_best and focus the informed set. Stop on post-optimization budgets and return a compressed, smoothed path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def attach(self, new_parent):\n        if self.parent is new_parent:\n            return\n        if self.parent is not None:\n            if self in self.parent.children:\n                self.parent.children.remove(self)\n        self.parent = new_parent\n        if new_parent is not None and self not in new_parent.children:\n            new_parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=3800,\n                 step_size=5.0,\n                 goal_bias=0.22,\n                 line_bias=0.40,\n                 gamma_radius=70.0,\n                 min_radius_factor=1.0,\n                 near_cap=56,\n                 cell_cap=3,\n                 admit_gain_ratio=0.99,\n                 prune_margin=1.001,\n                 rewire_cap=14,\n                 post_opt_iters=360,\n                 no_improve_limit=160,\n                 smoothing_iters=160,\n                 ellipse_tries=64,\n                 online_shortcuts_per_improve=32):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_bias = goal_bias\n        self.line_bias = line_bias\n        self.gamma_radius = gamma_radius\n        self.min_radius_factor = min_radius_factor\n        self.near_cap = near_cap\n        self.cell_cap = cell_cap\n        self.admit_gain_ratio = admit_gain_ratio\n        self.prune_margin = prune_margin\n        self.rewire_cap = rewire_cap\n        self.post_opt_iters = post_opt_iters\n        self.no_improve_limit = no_improve_limit\n        self.smoothing_iters = smoothing_iters\n        self.ellipse_tries = ellipse_tries\n        self.online_shortcuts_per_improve = online_shortcuts_per_improve\n\n        self.dim = 2\n        self.bounds = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # Endpoint validation\n        if not self._in_bounds(start) or not self._in_bounds(goal):\n            return PlannerResult(success=False, path=[], nodes=[], edges=[])\n        if self._is_in_obstacle(start, obstacles, is_3d) or self._is_in_obstacle(goal, obstacles, is_3d):\n            return PlannerResult(success=False, path=[], nodes=[], edges=[])\n\n        # RNG and caches\n        self._init_rng()\n        self._edge_cache = {}\n        self._seg_qres = max(0.25, 0.5 * self.step_size)\n\n        # Early straight-line solution\n        if not self._edge_blocked(start, goal, obstacles, is_3d):\n            s = Node(start, None, 0.0)\n            g = Node(goal, s, self._dist(start, goal))\n            s.children.append(g)\n            nodes = [s, g]\n            edges = [(s, g)]\n            path = [start, goal]\n            return PlannerResult(success=True, path=path, nodes=nodes, edges=edges)\n\n        # Initialize structures\n        root = Node(start, None, 0.0)\n        nodes = [root]\n\n        cell = max(1.0, 1.25 * self.step_size)\n        grid = {}\n        self._grid_add(grid, root, cell)\n\n        # Per-cell throttling and cost-ledger\n        occ = {}\n        self._occ_inc(occ, self._grid_key(start, cell))\n        dup_cell = max(0.5, 0.6 * self.step_size)\n        occ_best_cost = {self._occ_key(start, dup_cell): 0.0}\n\n        best_cost = float('inf')\n        goal_node = None\n        success = False\n        found_first = False\n        post_iters = 0\n        no_improve = 0\n        best_path_pts = None\n\n        for it in range(self.max_iter):\n            # Sampling\n            if self._rand() < self.goal_bias:\n                x_rand = goal\n            else:\n                x_rand = self._sample(start, goal, best_cost)\n\n            # Nearest\n            n_near = self._nearest(grid, nodes, x_rand, cell)\n            x_new_pos = self._steer(n_near.position, x_rand, self.step_size)\n\n            # Bounds and node collision\n            if not self._in_bounds(x_new_pos):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Cell throttling\n            kcell = self._grid_key(x_new_pos, cell)\n            if occ.get(kcell, 0) >= max(1, self.cell_cap):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Edge collision from nearest (cached)\n            if self._edge_blocked(n_near.position, x_new_pos, obstacles, is_3d):\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Parent selection within adaptive radius, heuristic-pruned\n            r_near = self._rrtstar_radius(max(2, len(nodes)))\n            near_nodes = self._near(grid, x_new_pos, r_near, cell)\n            if n_near not in near_nodes:\n                near_nodes.append(n_near)\n            if near_nodes:\n                near_nodes = self._k_nearest_limit(near_nodes, x_new_pos, self.near_cap)\n\n            best_parent = None\n            best_pc = float('inf')\n\n            for p in near_nodes:\n                # Heuristic pruning against current best solution\n                base = p.cost + self._dist(p.position, x_new_pos)\n                if best_cost < float('inf'):\n                    h = self._dist(x_new_pos, goal)\n                    if base + h >= best_cost * self.prune_margin:\n                        continue\n                if base + 1e-12 < best_pc:\n                    if not self._edge_blocked(p.position, x_new_pos, obstacles, is_3d):\n                        best_pc = base\n                        best_parent = p\n\n            if best_parent is None:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Per-cell best-cost duplicate suppression\n            kdup = self._occ_key(x_new_pos, dup_cell)\n            prev_best = occ_best_cost.get(kdup, float('inf'))\n            if best_pc >= prev_best * self.admit_gain_ratio:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                continue\n\n            # Commit node (node and edge checks satisfied)\n            x_new = Node(x_new_pos, None, best_pc)\n            x_new.attach(best_parent)\n            nodes.append(x_new)\n            self._grid_add(grid, x_new, cell)\n            self._occ_inc(occ, kcell)\n            if best_pc < prev_best:\n                occ_best_cost[kdup] = best_pc\n\n            # Rewire a small beam of neighbors for efficiency\n            # Select promising neighbors by potential gain\n            rewire_cands = []\n            for q in near_nodes:\n                if q is x_new or q is best_parent:\n                    continue\n                alt = x_new.cost + self._dist(x_new.position, q.position)\n                if alt + 1e-12 < q.cost:\n                    if best_cost < float('inf'):\n                        # prune rewires unlikely to improve final cost\n                        h = self._dist(q.position, goal)\n                        if alt + h >= best_cost * self.prune_margin:\n                            continue\n                    rewire_cands.append((q.cost - alt, q, alt))\n            # Process up to rewire_cap best gains\n            if rewire_cands:\n                rewire_cands.sort(key=lambda t: t[0], reverse=True)\n                for _, q, alt in rewire_cands[:max(1, self.rewire_cap)]:\n                    if not self._edge_blocked(x_new.position, q.position, obstacles, is_3d):\n                        q.attach(x_new)\n                        q.cost = alt\n                        self._propagate_costs_from(q)\n\n            # Goal bridging via best nearby parent\n            improved = False\n            r_conn = max(r_near, 2.0 * self.step_size)\n            if not self._is_in_obstacle(goal, obstacles, is_3d):\n                cand_goal = self._near(grid, goal, r_conn, cell)\n                if x_new not in cand_goal:\n                    cand_goal.append(x_new)\n                best_goal_parent = None\n                best_goal_cost = best_cost\n                for p in cand_goal:\n                    gcost = p.cost + self._dist(p.position, goal)\n                    if gcost + 1e-12 < best_goal_cost:\n                        if not self._edge_blocked(p.position, goal, obstacles, is_3d):\n                            best_goal_cost = gcost\n                            best_goal_parent = p\n                if best_goal_parent is not None:\n                    if goal_node is None:\n                        goal_node = Node(goal, best_goal_parent, best_goal_cost)\n                        best_goal_parent.children.append(goal_node)\n                        nodes.append(goal_node)\n                    else:\n                        goal_node.attach(best_goal_parent)\n                        goal_node.cost = best_goal_cost\n                    best_cost = best_goal_cost\n                    success = True\n                    found_first = True\n                    improved = True\n\n            # Online smoothing after improvement\n            if improved and goal_node is not None:\n                cur_path = self._extract_path(goal_node)\n                cur_path = self._compress_visibility(cur_path, obstacles, is_3d)\n                cur_path = self._shortcuts(cur_path, obstacles, is_3d, self.online_shortcuts_per_improve)\n                plen = self._path_length(cur_path)\n                if plen + 1e-12 < best_cost:\n                    best_cost = plen\n                best_path_pts = cur_path\n                post_iters = 0\n                no_improve = 0\n            else:\n                if found_first:\n                    post_iters += 1\n                    no_improve += 1\n                    if post_iters >= self.post_opt_iters or no_improve >= self.no_improve_limit:\n                        break\n\n        # Build final path\n        path = []\n        if success and goal_node is not None:\n            if best_path_pts is None:\n                path = self._extract_path(goal_node)\n                path = self._compress_visibility(path, obstacles, is_3d)\n                path = self._shortcuts(path, obstacles, is_3d, self.smoothing_iters)\n            else:\n                path = self._shortcuts(best_path_pts, obstacles, is_3d, self.smoothing_iters)\n\n        # Build edges\n        edges = []\n        for n in nodes:\n            if n.parent is not None:\n                edges.append((n.parent, n))\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    # ---------- Utilities ----------\n    def _init_rng(self):\n        self._lcg_state = 2862933555777941757 % (1 << 32)\n\n    def _rand(self):\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        if s <= 0.0:\n            return 0.0\n        return s ** 0.5\n\n    def _path_length(self, pts):\n        if not pts or len(pts) < 2:\n            return 0.0\n        L = 0.0\n        for i in range(1, len(pts)):\n            L += self._dist(pts[i - 1], pts[i])\n        return L\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return to_pos\n        r = step / max(1e-12, d)\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d, resolution=None):\n        if resolution is None:\n            resolution = min(1.0, 0.5 * self.step_size)\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, resolution))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Cached edge query\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        k = self._seg_key(a, b, self._seg_qres)\n        if k in self._edge_cache:\n            return self._edge_cache[k]\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d, resolution=min(1.0, 0.5 * self.step_size))\n        self._edge_cache[k] = blocked\n        return blocked\n\n    def _seg_key(self, a, b, q):\n        ka = tuple(int(x // q) for x in a)\n        kb = tuple(int(x // q) for x in b)\n        return (ka, kb) if ka <= kb else (kb, ka)\n\n    # Spatial hashing\n    def _grid_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node, cell):\n        k = self._grid_key(node.position, cell)\n        if k in grid:\n            grid[k].append(node)\n        else:\n            grid[k] = [node]\n\n    def _occ_inc(self, occ, key):\n        occ[key] = occ.get(key, 0) + 1\n\n    def _gather_cells(self, grid, center_pos, radius, cell):\n        rng = int(radius // cell) + 1\n        base = self._grid_key(center_pos, cell)\n        out = []\n        if self.dim == 2:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    k = (base[0] + dx, base[1] + dy)\n                    if k in grid:\n                        out.extend(grid[k])\n        else:\n            for dx in range(-rng, rng + 1):\n                for dy in range(-rng, rng + 1):\n                    for dz in range(-rng, rng + 1):\n                        k = (base[0] + dx, base[1] + dy, base[2] + dz)\n                        if k in grid:\n                            out.extend(grid[k])\n        return out\n\n    def _nearest(self, grid, nodes, pos, cell):\n        r = cell * 1.5\n        best = None\n        bestd = float('inf')\n        span = 0.0\n        for i in range(self.dim):\n            if self.bounds[i] > span:\n                span = self.bounds[i]\n        limit = span * 2.0 + 1.0\n        while r <= limit:\n            cand = self._gather_cells(grid, pos, r, cell)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n            r *= 2.0\n        # fallback\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _near(self, grid, pos, radius, cell):\n        cand = self._gather_cells(grid, pos, radius, cell)\n        out = []\n        for n in cand:\n            if self._dist(n.position, pos) <= radius:\n                out.append(n)\n        return out\n\n    def _k_nearest_limit(self, nodes, center, k):\n        if len(nodes) <= k:\n            return nodes\n        dist_idx = []\n        for n in nodes:\n            dist_idx.append((self._dist(n.position, center), n))\n        dist_idx.sort(key=lambda t: t[0])\n        return [t[1] for t in dist_idx[:k]]\n\n    def _occ_key(self, pos, cell):\n        return tuple(int(pos[i] // cell) for i in range(self.dim))\n\n    def _heuristic(self, a, b):\n        return self._dist(a, b)\n\n    def _sample(self, start, goal, c_best):\n        # Informed ellipsoidal gate after first solution\n        if c_best < float('inf'):\n            for _ in range(self.ellipse_tries):\n                p = tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n                if self._in_bounds(p):\n                    if self._dist(p, start) + self._dist(p, goal) <= c_best:\n                        return p\n        # Line-biased sample with jitter\n        if self._rand() < self.line_bias:\n            t = self._uniform(0.0, 1.0)\n            base = tuple(start[i] + t * (goal[i] - start[i]) for i in range(self.dim))\n            jit = 0.5 * self.step_size\n            return tuple(self._clip(base[i] + self._uniform(-jit, jit), 0.0, self.bounds[i]) for i in range(self.dim))\n        # Uniform\n        return tuple(self._uniform(0.0, self.bounds[i]) for i in range(self.dim))\n\n    def _clip(self, x, a, b):\n        if x < a:\n            return a\n        if x > b:\n            return b\n        return x\n\n    def _log_approx(self, n):\n        if n <= 1:\n            return 0.0\n        return (int(n).bit_length()) * 0.6931471805599453\n\n    def _rrtstar_radius(self, n):\n        r = self.gamma_radius\n        if n > 2:\n            expo = 1.0 / float(max(2, self.dim))\n            r = self.gamma_radius * ((self._log_approx(n) / float(n)) ** expo)\n        rmin = max(self.min_radius_factor * self.step_size, 1e-6)\n        if r < rmin:\n            r = rmin\n        return r\n\n    def _propagate_costs_from(self, node):\n        # Update node and all descendants to maintain consistent costs\n        stack = [node]\n        while stack:\n            u = stack.pop()\n            if u.parent is not None:\n                u.cost = u.parent.cost + self._dist(u.parent.position, u.position)\n            for c in u.children:\n                stack.append(c)\n\n    def _extract_path(self, goal_node):\n        seq = []\n        cur = goal_node\n        while cur is not None:\n            seq.append(cur.position)\n            cur = cur.parent\n        seq.reverse()\n        return seq\n\n    def _compress_visibility(self, path, obstacles, is_3d):\n        if not path or len(path) < 3:\n            return path\n        out = [path[0]]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if not self._edge_blocked(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            out.append(path[j])\n            i = j\n        return out\n\n    def _shortcuts(self, path, obstacles, is_3d, iters):\n        if not path or len(path) < 3:\n            return path\n        pts = list(path)\n        n = len(pts)\n        no_gain = 0\n        for _ in range(iters):\n            if n < 3 or no_gain > max(8, iters // 10):\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            if not self._edge_blocked(pts[i], pts[j], obstacles, is_3d):\n                before = self._dist(pts[i], pts[i + 1]) + self._dist(pts[j - 1], pts[j])\n                after = self._dist(pts[i], pts[j])\n                if after + 1e-12 < before:\n                    pts = pts[:i + 1] + pts[j:]\n                    n = len(pts)\n                    no_gain = 0\n                else:\n                    no_gain += 1\n            else:\n                no_gain += 1\n        return pts",
          "objective": -11.31791,
          "time_improvement": -29.0,
          "length_improvement": 20.0,
          "smoothness_improvement": 1637.0,
          "node_improvement": 66.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04869384765625,
                    "num_nodes_avg": 142.0,
                    "path_length_avg": 156.94171771174342,
                    "smoothness_avg": 0.05000575517450624,
                    "success_improvement": 0.0,
                    "time_improvement": -90.96528555012308,
                    "node_improvement": 64.24074540418032,
                    "length_improvement": 13.977757621532207,
                    "smoothness_improvement": 682.698657716415,
                    "objective_score": -15.489437803535523
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.11519887447357177,
                    "num_nodes_avg": 403.0,
                    "path_length_avg": 229.3729522589852,
                    "smoothness_avg": 0.11782822378241282,
                    "success_improvement": 0.0,
                    "time_improvement": 28.089391491172343,
                    "node_improvement": 72.92212591547404,
                    "length_improvement": 23.42870640158524,
                    "smoothness_improvement": 2931.805066160672,
                    "objective_score": 37.14306661910621
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.060450196266174316,
                    "num_nodes_avg": 306.0,
                    "path_length_avg": 118.47542861631464,
                    "smoothness_avg": 0.10979481191774568,
                    "success_improvement": 0.0,
                    "time_improvement": -23.237863782732852,
                    "node_improvement": 61.09345200254291,
                    "length_improvement": 21.314261506704646,
                    "smoothness_improvement": 1296.5819033837186,
                    "objective_score": 12.300107286121523
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "IBEX-Lite BiRRT: Informed Bounded-Expansion Bidirectional RRT with dual-state edge memo, grid-nearest lookup, and per-cell f/g gates. It alternates tree growth with a small guided beam, selects a cost-minimizing LOS parent from a compact neighborhood, prunes by incumbent-aware f = g + h and cell bests, and bridges to a few nearest nodes in the opposite tree using cached collision results. A brief cache-aided shortcut and forward LOS collapse returns a smooth path quickly.",
          "planning_mechanism": "Initialize two trees at start/goal. Each iteration picks a side, draws a tiny guided beam (goal/corridor/uniform; informed ellipse if an incumbent path exists), steers once from the hashed-nearest, rejects duplicates/out-of-bounds, chooses the cheapest LOS parent among nearby nodes, and enforces both node and edge collision checks before insertion. Cell-level g/f gates and heuristic pruning curb expansions. After inserting, attempt bridging to k nearest nodes from the opposite tree within a radius using an edge cache that stores both free/blocked outcomes. On success, merge roots-to-meet path and perform bounded cache-aided shortcutting and forward LOS collapse.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        for c in self.children:\n            if c is child:\n                child.parent = self\n                return\n        self.children.append(child)\n        child.parent = self\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=8.0,\n                 collision_step=1.0,\n                 beam_k=2,\n                 goal_bias=0.25,\n                 corridor_bias=0.5,\n                 informed_bias=0.7,\n                 grid_cell=None,\n                 rings_near=3,\n                 parent_rings=2,\n                 connect_k=4,\n                 connect_radius_factor=3.0,\n                 cell_expand_limit=3,\n                 cell_gate_relax=1.05,\n                 prune_margin=1.01,\n                 dupe_radius_ratio=0.6,\n                 smoothing_attempts=50,\n                 leader_stride=24,\n                 edge_cache_limit=30000):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_step = collision_step\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.grid_cell = grid_cell\n        self.rings_near = rings_near\n        self.parent_rings = parent_rings\n        self.connect_k = max(1, int(connect_k))\n        self.connect_radius_factor = connect_radius_factor\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.cell_gate_relax = cell_gate_relax\n        self.prune_margin = prune_margin\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.smoothing_attempts = smoothing_attempts\n        self.leader_stride = max(1, int(leader_stride))\n        self.edge_cache_limit = edge_cache_limit\n\n        self.bounds = None\n        self.dim = 2\n        self.edge_res = 1.0\n        self.cache_bin = 1.0\n        self.inv_cache_bin = 1.0\n        self.start = None\n        self.goal = None\n        self.edge_cache = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.9 * self.step_size)\n        self.edge_res = max(0.75, min(self.collision_step, 0.5 * self.step_size))\n        self.cache_bin = max(0.5, 0.5 * self.edge_res)\n        self.inv_cache_bin = 1.0 / self.cache_bin\n        self.edge_cache = {}\n\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            edges = [(n0, n1)]\n            nodes = [n0, n1]\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        leaders_a, leaders_b = [start_root], [goal_root]\n\n        expands_a, expands_b = {}, {}\n        bestg_a, bestg_b = {}, {}\n        bestf_a, bestf_b = {}, {}\n\n        best_path_len = float('inf')\n        dsg = self._dist(self.start, self.goal)\n        base_corridor = max(self.step_size, 0.2 * dsg)\n        dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            leaders1 = leaders_a if active_start else leaders_b\n            leaders2 = leaders_b if active_start else leaders_a\n            expands1 = expands_a if active_start else expands_b\n            bestg1 = bestg_a if active_start else bestg_b\n            bestf1 = bestf_a if active_start else bestf_b\n            other_root = self.goal if active_start else self.start\n\n            best_cand = None  # (parent, new_pos, fscore, hint_node)\n\n            for _ in range(self.beam_k):\n                x_rand = None\n                if best_path_len < float('inf') and self._rand() < self.informed_bias:\n                    x_rand = self._sample_informed(best_path_len, obstacles, is_3d)\n                else:\n                    r = self._rand()\n                    if r < self.goal_bias:\n                        x_rand = other_root\n                    elif r < self.goal_bias + self.corridor_bias:\n                        slack = 0.0 if best_path_len == float('inf') else max(0.0, best_path_len - dsg)\n                        width = max(self.step_size, base_corridor + 0.15 * slack)\n                        x_rand = self._sample_corridor(width, obstacles, is_3d)\n                    else:\n                        x_rand = self._sample_free(obstacles, is_3d)\n\n                nearest = self._nearest(grid1, leaders1, tree1, x_rand)\n                if nearest is None:\n                    continue\n                new_pos = self._steer(nearest.position, x_rand, self.step_size)\n\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._exists_close(grid1, new_pos, dupe_radius):\n                    continue\n\n                kcell = self._grid_key(new_pos)\n                if expands1.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n\n                parent = self._choose_parent(nearest, grid1, new_pos, obstacles, is_3d)\n                if parent is None:\n                    continue\n                if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_cost = parent.cost + self._dist(parent.position, new_pos)\n                prevg = bestg1.get(kcell, float('inf'))\n                if new_cost > prevg * self.cell_gate_relax:\n                    continue\n\n                h = self._dist(new_pos, other_root)\n                if best_path_len < float('inf'):\n                    if new_cost + h >= best_path_len * self.prune_margin:\n                        continue\n\n                other_near = self._nearest(grid2, leaders2, tree2, new_pos)\n                bridge_hint = self._dist(new_pos, other_near.position) if other_near is not None else h\n                fscore = new_cost + h + 0.35 * bridge_hint\n\n                prevf = bestf1.get(kcell, float('inf'))\n                if fscore > prevf * self.cell_gate_relax:\n                    continue\n\n                if best_cand is None or fscore < best_cand[2]:\n                    best_cand = (parent, new_pos, fscore, other_near)\n\n            if best_cand is None:\n                continue\n\n            parent, new_pos, _, hint_other = best_cand\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos, parent, parent.cost + self._dist(parent.position, new_pos))\n            parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            self._grid_add(grid1, new_node)\n            edges.append((parent, new_node))\n\n            kc = self._grid_key(new_pos)\n            expands1[kc] = expands1.get(kc, 0) + 1\n            gprev = bestg1.get(kc, float('inf'))\n            fprev = bestf1.get(kc, float('inf'))\n            if new_node.cost < gprev:\n                bestg1[kc] = new_node.cost\n            estf = new_node.cost + self._dist(new_pos, other_root)\n            if estf < fprev:\n                bestf1[kc] = estf\n\n            if len(tree1) % self.leader_stride == 0:\n                leaders1.append(new_node)\n\n            connect_radius = self.connect_radius_factor * self.step_size\n            near_other = self._nearby(grid2, new_node.position, connect_radius, leaders2, tree2)\n            if len(near_other) > self.connect_k:\n                near_other = self._k_nearest(near_other, new_node.position, self.connect_k)\n\n            connected = None\n            for q in near_other:\n                if not self._edge_blocked_memo(new_node.position, q.position, obstacles, is_3d):\n                    connected = q\n                    break\n\n            if connected is not None:\n                if active_start:\n                    path = self._merge_paths(new_node, connected)\n                else:\n                    path = self._merge_paths(connected, new_node)\n                best_path_len = self._path_length(path)\n                path = self._smooth_path(path, obstacles, is_3d, self.smoothing_attempts)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _rand(self):\n        if not hasattr(self, \"_rng\"):\n            self._rng = 2463534242\n        self._rng = (1664525 * self._rng + 1013904223) % (1 << 32)\n        return self._rng / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp_tuple(b)\n        if d <= 1e-12:\n            return self._clamp_tuple(a)\n        r = step / d\n        return self._clamp_tuple(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] * self.inv_cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] * self.inv_cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        st = self.edge_cache.get(key)\n        if st is not None:\n            return st == 1\n        blocked = self._edge_blocked(a, b, obstacles, is_3d)\n        self.edge_cache[key] = 1 if blocked else 2\n        if len(self.edge_cache) > self.edge_cache_limit:\n            self.edge_cache.clear()\n        return blocked\n\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, leaders, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.rings_near + 1):\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        for n in leaders:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        for n in tree:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(max(1.0, radius) // self.grid_cell) + 1\n        cand = self._ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    def _nearby(self, grid, pos, radius, leaders, fallback_tree):\n        key = self._grid_key(pos)\n        r_cells = int(radius // self.grid_cell) + 1\n        cand = self._ring_collect(grid, key, r_cells)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n        if out:\n            return out\n        if leaders:\n            return list(leaders)\n        return list(fallback_tree)\n\n    def _k_nearest(self, nodes, pos, k):\n        if len(nodes) <= k:\n            return list(nodes)\n        best = []\n        bestd = []\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if len(best) < k:\n                best.append(n)\n                bestd.append(d)\n            else:\n                wi = 0\n                wv = bestd[0]\n                for i in range(1, k):\n                    if bestd[i] > wv:\n                        wi = i\n                        wv = bestd[i]\n                if d < wv:\n                    best[wi] = n\n                    bestd[wi] = d\n        return best\n\n    def _choose_parent(self, nearest, grid, new_pos, obstacles, is_3d):\n        best_parent = nearest\n        best_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        key = self._grid_key(new_pos)\n        cand = []\n        for r in range(0, self.parent_rings + 1):\n            cand.extend(self._ring_collect(grid, key, r))\n        if not cand:\n            cand = [nearest]\n        for c in cand:\n            if not self._edge_blocked_memo(c.position, new_pos, obstacles, is_3d):\n                cst = c.cost + self._dist(c.position, new_pos)\n                if cst + 1e-12 < best_cost:\n                    best_cost = cst\n                    best_parent = c\n        return best_parent\n\n    def _sample_free(self, obstacles, is_3d):\n        for _ in range(60):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        if self.dim == 3:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5, self.bounds[2] * 0.5)\n        else:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5)\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        tries = 0\n        while tries < 20:\n            if self.dim == 3:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                else:\n                    tries += 1\n                    continue\n            else:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                else:\n                    tries += 1\n                    continue\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n            tries += 1\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        for _ in range(40):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if (self._dist(p, self.start) + self._dist(p, self.goal) <= best_len and\n                not self._is_in_obstacle(p, obstacles, is_3d)):\n                return p\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)\n\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_paths(self, a_node, b_node):\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        pb.reverse()\n        return pa + pb\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        s = 0.0\n        for i in range(1, len(path)):\n            s += self._dist(path[i - 1], path[i])\n        return s\n\n    def _smooth_path(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and n >= 3:\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if not self._edge_blocked_memo(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n            tries += 1\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            anchor = pts[0]\n            k = 1\n            while k < len(pts) - 1:\n                nxt = pts[k + 1]\n                if self._edge_blocked_memo(anchor, nxt, obstacles, is_3d):\n                    collapsed.append(pts[k])\n                    anchor = pts[k]\n                k += 1\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
          "objective": -11.11322,
          "time_improvement": -15.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1575.0,
          "node_improvement": 89.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04032721519470215,
                    "num_nodes_avg": 63.6,
                    "path_length_avg": 164.64156198085035,
                    "smoothness_avg": 0.04728353333137928,
                    "success_improvement": 0.0,
                    "time_improvement": -58.153412305036866,
                    "node_improvement": 83.98388315285821,
                    "length_improvement": 9.757350965794357,
                    "smoothness_improvement": 640.0899744721305,
                    "objective_score": -8.391163239673793
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07297012805938721,
                    "num_nodes_avg": 106.0,
                    "path_length_avg": 244.13461771916838,
                    "smoothness_avg": 0.10519752064904304,
                    "success_improvement": 0.0,
                    "time_improvement": 54.44984739914778,
                    "node_improvement": 92.87778001746959,
                    "length_improvement": 18.50083757999455,
                    "smoothness_improvement": 2606.807977011326,
                    "objective_score": 40.46949665279769
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.06928503513336182,
                    "num_nodes_avg": 81.3,
                    "path_length_avg": 134.907466259737,
                    "smoothness_avg": 0.12414433701148968,
                    "success_improvement": 0.0,
                    "time_improvement": -41.249164590801385,
                    "node_improvement": 89.66306420851876,
                    "length_improvement": 10.400884513491826,
                    "smoothness_improvement": 1479.1068034043758,
                    "objective_score": 1.261315347876561
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "HARP-Grid BiRRT*: Heuristic-Aware Ring-Pruned Grid BiRRT* with reusable edge memoization, blocked-pair skipping, and light RRT*-lite refinement. It alternates small-beam, heuristic-scored extensions from start/goal trees, uses a ring-limited hashed nearest search, throttles saturated cells, and suppresses near-duplicates. Each candidate selects a cost-optimal parent among nearby neighbors, commits only after both node and edge collision checks, optionally compresses to a visible ancestor, and does capped rewiring with safe cost propagation. A quantized edge cache avoids repeated collision checks, and a grid-cell-pair cache skips futile bridges. On the first valid bridge, the path is extracted, shortcut-smoothed, and forward-LOS collapsed for speed and smoothness.",
          "planning_mechanism": "Alternate growth between trees using a small beam of guided samples (goal/corridor/informed). For each sample, find a near node via grid rings, steer, and validate node and edge. Score candidates by g + beta*h to the other tree; pick the best, then insert after both checks. Try direct LOS to the other tree\u2019s nearest unless the cell-pair is known blocked; otherwise attempt a few micro-steps from the opposite tree. Maintain per-cell caps and duplicate suppression to limit growth, quantized edge-collision memoization for reuse, and limited rewiring/compression for shorter paths. On success, extract and apply light shortcutting and forward LOS pruning, then return.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = float(cost)\n        self.children = []\n\n    def add_child(self, child):\n        found = False\n        for c in self.children:\n            if c is child:\n                found = True\n                break\n        if not found:\n            self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        idx = -1\n        for i in range(len(self.children)):\n            if self.children[i] is child:\n                idx = i\n                break\n        if idx >= 0:\n            self.children.pop(idx)\n\n    def path_to_root(self):\n        pts = []\n        n = self\n        while n is not None:\n            pts.append(n.position)\n            n = n.parent\n        pts.reverse()\n        return pts\nclass Planner:\n    def __init__(self,\n                 max_iter=3500,\n                 step_size=9.0,\n                 edge_resolution=1.0,\n                 beam_k=2,\n                 goal_bias=0.22,\n                 corridor_bias=0.45,\n                 informed_bias=0.60,\n                 neighbor_radius_factor=2.0,\n                 neighbor_limit=48,\n                 rewire_limit=16,\n                 compress_depth=2,\n                 grid_cell=None,\n                 max_rings=3,\n                 dupe_radius_ratio=0.45,\n                 min_sep_ratio=0.30,\n                 cell_expand_limit=3,\n                 anchor_stride=28,\n                 connect_attempts=1,\n                 smoothing_iters=28,\n                 edge_cache_max=24000):\n        self.max_iter = int(max_iter)\n        self.step_size = float(step_size)\n        self.edge_resolution = float(edge_resolution)\n        self.beam_k = int(beam_k)\n        self.goal_bias = float(goal_bias)\n        self.corridor_bias = float(corridor_bias)\n        self.informed_bias = float(informed_bias)\n        self.neighbor_radius_factor = float(neighbor_radius_factor)\n        self.neighbor_limit = int(neighbor_limit)\n        self.rewire_limit = int(rewire_limit)\n        self.compress_depth = int(compress_depth)\n        self.grid_cell = grid_cell\n        self.max_rings = int(max_rings)\n        self.dupe_radius_ratio = float(dupe_radius_ratio)\n        self.min_sep_ratio = float(min_sep_ratio)\n        self.cell_expand_limit = int(cell_expand_limit)\n        self.anchor_stride = int(anchor_stride)\n        self.connect_attempts = int(connect_attempts)\n        self.smoothing_iters = int(smoothing_iters)\n        self.edge_cache_max = int(edge_cache_max)\n\n        # runtime state\n        self.dim = 2\n        self.bounds = None\n        self.start = None\n        self.goal = None\n        self.cache_bin = 1.0\n        self.edge_cache = None  # key -> 1(blocked) or 2(free)\n        self.blocked_pairs = None  # set of ((cell_a),(cell_b))\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # setup discretizations\n        if self.grid_cell is None:\n            self.grid_cell = max(1.0, 0.95 * self.step_size)\n        self.cache_bin = max(1.0, max(0.75, self.edge_resolution, self.step_size * 0.4))\n        self.edge_cache = {}\n        self.blocked_pairs = set()\n\n        # validate start/goal\n        if (not self._in_bounds(self.start)) or (not self._in_bounds(self.goal)):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # early straight connection (both checks: nodes validated above, edge checked here)\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            n0.add_child(n1)\n            return PlannerResult(True, [self.start, self.goal], [n0, n1], [(n0, n1)])\n\n        # initialize structures\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n        anchors_a, anchors_b = [start_root], [goal_root]\n        throttle_a, throttle_b = {}, {}\n\n        best_path_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        base_corridor_w = max(self.step_size, 0.2 * d_sg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            anchors1 = anchors_a if active_start else anchors_b\n            anchors2 = anchors_b if active_start else anchors_a\n            throttle1 = throttle_a if active_start else throttle_b\n            throttle2 = throttle_b if active_start else throttle_a\n            other_root = self.goal if active_start else self.start\n\n            # beam of candidates with heuristic pruning (score = g + beta*h)\n            best_parent = None\n            best_new_pos = None\n            best_new_cost = 0.0\n            best_score = float('inf')\n\n            for _ in range(self.beam_k):\n                x_rand = self._sample_guided(best_path_len, obstacles, is_3d, base_corridor_w)\n                near = self._nearest_hashed(grid1, tree1, anchors1, x_rand)\n                if near is None:\n                    continue\n\n                new_pos = self._steer(near.position, x_rand, self.step_size)\n                if not self._in_bounds(new_pos):\n                    continue\n\n                # Node collision check\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n\n                # duplicate suppression and separation\n                if self._dist(near.position, new_pos) < self.step_size * self.min_sep_ratio:\n                    continue\n                if self._exists_close(grid1, new_pos, self.step_size * self.dupe_radius_ratio):\n                    continue\n\n                # per-cell throttling\n                kcell = self._grid_key(new_pos)\n                if throttle1.get(kcell, 0) >= self.cell_expand_limit:\n                    continue\n\n                # Edge collision check to nearest before any parent choice\n                if self._edge_blocked_memo(near.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # choose parent among nearby neighbors (RRT*-lite, bounded)\n                parent, parent_cost = self._choose_parent(tree1, grid1, new_pos, near, obstacles, is_3d)\n\n                if parent is None:\n                    # safety: fallback to nearest if valid\n                    if not self._edge_blocked_memo(near.position, new_pos, obstacles, is_3d):\n                        parent = near\n                        parent_cost = near.cost + self._dist(near.position, new_pos)\n                    else:\n                        continue\n\n                # heuristic score to the other side\n                other_near = self._nearest_hashed(grid2, tree2, anchors2, new_pos)\n                h = self._dist(new_pos, other_near.position) if other_near is not None else self._dist(new_pos, other_root)\n                score = parent_cost + 0.6 * h\n                if score < best_score:\n                    best_score = score\n                    best_parent = parent\n                    best_new_pos = new_pos\n                    best_new_cost = parent_cost\n\n            if best_parent is None:\n                continue\n\n            # Final validity before insertion (both checks)\n            if self._is_in_obstacle(best_new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked_memo(best_parent.position, best_new_pos, obstacles, is_3d):\n                continue\n\n            # Insert the node\n            new_node = Node(best_new_pos, best_parent, best_new_cost)\n            best_parent.add_child(new_node)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            self._grid_add(grid1, new_node)\n            kc = self._grid_key(best_new_pos)\n            throttle1[kc] = throttle1.get(kc, 0) + 1\n            if len(tree1) % max(1, self.anchor_stride) == 0:\n                anchors1.append(new_node)\n\n            # Optional shallow compression to a visible ancestor\n            if self.compress_depth > 0:\n                self._compress_to_visible_ancestor(new_node, obstacles, is_3d, edges, self.compress_depth)\n\n            # Limited rewiring for nearby neighbors\n            if self.rewire_limit > 0:\n                self._rewire_neighbors(tree1, grid1, new_node, obstacles, is_3d, edges)\n\n            # Attempt direct LOS bridge to the other tree's nearest\n            other_near = self._nearest_hashed(grid2, tree2, anchors2, new_node.position)\n            if other_near is not None:\n                pair_key = self._pair_key(self._grid_key(new_node.position), self._grid_key(other_near.position))\n                if pair_key not in self.blocked_pairs:\n                    if not self._edge_blocked_memo(new_node.position, other_near.position, obstacles, is_3d):\n                        path = self._extract_path(new_node, other_near, active_start)\n                        best_path_len = self._path_length(path)\n                        path = self._smooth_path(path, obstacles, is_3d, self.smoothing_iters)\n                        return PlannerResult(True, path, nodes, edges)\n                    else:\n                        self.blocked_pairs.add(pair_key)\n\n            # Greedy micro-bridge from the opposite tree (few steps), each with both checks\n            p = other_near\n            attempts = 0\n            while p is not None and attempts < max(1, self.connect_attempts):\n                step_pos = self._steer(p.position, new_node.position, self.step_size)\n                if not self._in_bounds(step_pos):\n                    break\n                if self._is_in_obstacle(step_pos, obstacles, is_3d):\n                    break\n                if self._exists_close(grid2, step_pos, self.step_size * self.dupe_radius_ratio):\n                    break\n                if self._edge_blocked_memo(p.position, step_pos, obstacles, is_3d):\n                    break\n\n                q_cost = p.cost + self._dist(p.position, step_pos)\n                q = Node(step_pos, p, q_cost)\n                p.add_child(q)\n                tree2.append(q)\n                nodes.append(q)\n                edges.append((p, q))\n                self._grid_add(grid2, q)\n                throttle2[self._grid_key(step_pos)] = throttle2.get(self._grid_key(step_pos), 0) + 1\n                if len(tree2) % max(1, self.anchor_stride) == 0:\n                    anchors2.append(q)\n\n                # Try bridge\n                if not self._edge_blocked_memo(new_node.position, q.position, obstacles, is_3d):\n                    path = self._extract_path(new_node, q, active_start)\n                    best_path_len = self._path_length(path)\n                    path = self._smooth_path(path, obstacles, is_3d, self.smoothing_iters)\n                    return PlannerResult(True, path, nodes, edges)\n\n                p = q\n                attempts += 1\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG (LCG, deterministic, no imports)\n    def _rand(self):\n        if not hasattr(self, \"_lcg_state\"):\n            self._lcg_state = 2463534242\n        self._lcg_state = (1664525 * self._lcg_state + 1013904223) % (1 << 32)\n        return self._lcg_state / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry utilities\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    def _clamp_tuple(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, from_pos, to_pos, step):\n        d = self._dist(from_pos, to_pos)\n        if d <= step:\n            return self._clamp_tuple(to_pos)\n        if d <= 1e-12:\n            return self._clamp_tuple(from_pos)\n        r = step / d\n        return self._clamp_tuple(tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * r for i in range(self.dim)))\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        res = max(0.75, min(self.edge_resolution, max(0.5, self.step_size * 0.4)))\n        steps = int(d / max(1e-9, res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    # Edge memo (blocked and free)\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] // self.cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] // self.cache_bin) for i in range(self.dim))\n        return (qa, qb) if qa <= qb else (qb, qa)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        state = self.edge_cache.get(key)\n        if state is not None:\n            return state == 1\n        blocked = self._is_edge_in_obstacle(a, b, obstacles, is_3d)\n        self.edge_cache[key] = 1 if blocked else 2\n        if len(self.edge_cache) > self.edge_cache_max:\n            self._prune_edge_cache()\n        return blocked\n\n    def _prune_edge_cache(self):\n        # remove roughly half of items deterministically\n        to_remove = []\n        count = 0\n        for k in self.edge_cache:\n            if (count % 2) == 0:\n                to_remove.append(k)\n            count += 1\n            if len(to_remove) >= self.edge_cache_max // 2:\n                break\n        for k in to_remove:\n            if k in self.edge_cache:\n                del self.edge_cache[k]\n\n    # Sampling\n    def _sample_guided(self, best_len, obstacles, is_3d, base_w):\n        r = self._rand()\n        if (best_len < float('inf')) and (r < self.informed_bias):\n            return self._sample_informed(best_len, obstacles, is_3d)\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return self.goal if self._rand() < 0.5 else self.start\n        if r2 < self.goal_bias + self.corridor_bias:\n            width = base_w\n            if best_len < float('inf'):\n                slack = max(0.0, best_len - self._dist(self.start, self.goal))\n                width = max(self.step_size, 0.2 * slack + base_w)\n            return self._sample_corridor(width, obstacles, is_3d)\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_free(self, obstacles, is_3d):\n        for _ in range(48):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # fallback center\n        if self.dim == 3:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5, self.bounds[2] * 0.5)\n        else:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5)\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        if self.dim == 3:\n            for _ in range(14):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy, base[2] + oz))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        else:\n            for _ in range(14):\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp_tuple((base[0] + ox, base[1] + oy))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        # prolate ellipse: sum of distances to foci <= best_len\n        for _ in range(48):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if (self._dist(p, self.start) + self._dist(p, self.goal) <= best_len) and (not self._is_in_obstacle(p, obstacles, is_3d)):\n                return p\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)\n\n    # Grid hashing\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.grid_cell) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        bucket = grid.get(k)\n        if bucket is None:\n            grid[k] = [node]\n        else:\n            bucket.append(node)\n\n    def _grid_ring_nodes(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest_hashed(self, grid, tree, anchors, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.max_rings + 1):\n            cand = self._grid_ring_nodes(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # anchor fallback\n        for n in anchors:\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n        if best is not None:\n            return best\n        # rare: scan subset of tree for robustness (stride)\n        stride = max(1, len(tree) // 64)\n        idx = 0\n        while idx < len(tree):\n            n = tree[idx]\n            d = self._dist(n.position, pos)\n            if d < bestd:\n                bestd = d\n                best = n\n            idx += stride\n        return best\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(max(1, radius / self.grid_cell)) + 1\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Neighbor queries and parent choice\n    def _neighbors_within(self, grid, pos, radius, limit):\n        key = self._grid_key(pos)\n        r_cells = int(max(1, radius / self.grid_cell)) + 1\n        cand = self._grid_ring_nodes(grid, key, r_cells)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n                if len(out) >= limit:\n                    break\n        return out\n\n    def _choose_parent(self, tree, grid, new_pos, nearest, obstacles, is_3d):\n        radius = self.neighbor_radius_factor * self.step_size\n        neigh = self._neighbors_within(grid, new_pos, radius, limit=self.neighbor_limit)\n        if nearest not in neigh:\n            neigh.append(nearest)\n        best_parent = None\n        best_cost = float('inf')\n        for p in neigh:\n            if self._edge_blocked_memo(p.position, new_pos, obstacles, is_3d):\n                continue\n            c = p.cost + self._dist(p.position, new_pos)\n            if c < best_cost:\n                best_cost = c\n                best_parent = p\n        if best_parent is None:\n            return None, float('inf')\n        return best_parent, best_cost\n\n    # Rewiring\n    def _rewire_neighbors(self, tree, grid, new_node, obstacles, is_3d, edges):\n        radius = self.neighbor_radius_factor * self.step_size\n        neigh = self._neighbors_within(grid, new_node.position, radius, limit=self.rewire_limit * 2)\n        count = 0\n        for n in neigh:\n            if n is new_node or n is new_node.parent:\n                continue\n            if self._edge_blocked_memo(new_node.position, n.position, obstacles, is_3d):\n                continue\n            new_cost = new_node.cost + self._dist(new_node.position, n.position)\n            if new_cost + 1e-9 < n.cost:\n                # ensure node is valid (safety)\n                if self._is_in_obstacle(n.position, obstacles, is_3d):\n                    continue\n                old_parent = n.parent\n                if old_parent is not None:\n                    old_parent.remove_child(n)\n                    self._edges_remove(edges, old_parent, n)\n                new_node.add_child(n)\n                n.cost = new_cost\n                edges.append((new_node, n))\n                self._propagate_costs_from(n)\n                count += 1\n                if count >= self.rewire_limit:\n                    break\n\n    def _propagate_costs_from(self, node):\n        q = [node]\n        while q:\n            cur = q.pop()\n            for ch in cur.children:\n                ch.cost = cur.cost + self._dist(cur.position, ch.position)\n                q.append(ch)\n\n    # Compression\n    def _compress_to_visible_ancestor(self, node, obstacles, is_3d, edges, depth_limit):\n        cur = node\n        depth = 0\n        while cur.parent is not None and cur.parent.parent is not None and depth < depth_limit:\n            gp = cur.parent.parent\n            if not self._edge_blocked_memo(gp.position, cur.position, obstacles, is_3d):\n                old_parent = cur.parent\n                if old_parent is None:\n                    break\n                old_parent.remove_child(cur)\n                self._edges_remove(edges, old_parent, cur)\n                gp.add_child(cur)\n                cur.cost = gp.cost + self._dist(gp.position, cur.position)\n                edges.append((gp, cur))\n                self._propagate_costs_from(cur)\n                depth += 1\n            else:\n                break\n\n    # Edges helpers\n    def _edges_remove(self, edges, parent, child):\n        idx = -1\n        for i in range(len(edges)):\n            if edges[i][0] is parent and edges[i][1] is child:\n                idx = i\n                break\n        if idx >= 0:\n            edges.pop(idx)\n\n    # Blocked pair key for bridge attempts\n    def _pair_key(self, a_key, b_key):\n        return (a_key, b_key) if a_key <= b_key else (b_key, a_key)\n\n    # Paths\n    def _extract_path(self, a_node, b_node, a_is_start_side):\n        if a_is_start_side:\n            pa = a_node.path_to_root()\n            pb = b_node.path_to_root()\n            return pa + pb[::-1]\n        else:\n            pa = a_node.path_to_root()\n            pb = b_node.path_to_root()\n            return pb + pa[::-1]\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _smooth_path(self, path, obstacles, is_3d, iters):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        last_len = self._path_length(pts)\n        no_improve = 0\n        for _ in range(iters):\n            n = len(pts)\n            if n < 3:\n                break\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                continue\n            a = pts[i]\n            b = pts[j]\n            if not self._is_edge_in_obstacle(a, b, obstacles, is_3d):\n                cand = pts[:i + 1] + pts[j:]\n                new_len = self._path_length(cand)\n                if new_len <= last_len:\n                    pts = cand\n                    last_len = new_len\n                    no_improve = 0\n                else:\n                    no_improve += 1\n            else:\n                no_improve += 1\n            if no_improve >= 8:\n                break\n        # forward LOS collapse\n        if len(pts) >= 3:\n            collapsed = [pts[0]]\n            anchor = pts[0]\n            k = 1\n            while k < len(pts) - 1:\n                nxt = pts[k + 1]\n                if self._is_edge_in_obstacle(anchor, nxt, obstacles, is_3d):\n                    collapsed.append(pts[k])\n                    anchor = pts[k]\n                k += 1\n            collapsed.append(pts[-1])\n            pts = collapsed\n        return pts",
          "objective": -10.97895,
          "time_improvement": -17.0,
          "length_improvement": 12.0,
          "smoothness_improvement": 1730.0,
          "node_improvement": 85.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.049466943740844725,
                    "num_nodes_avg": 85.2,
                    "path_length_avg": 178.08459745889706,
                    "smoothness_avg": 0.051600691035238164,
                    "success_improvement": 0.0,
                    "time_improvement": -93.99717811270158,
                    "node_improvement": 78.54444724250818,
                    "length_improvement": 2.3890102017481243,
                    "smoothness_improvement": 707.6628673955257,
                    "objective_score": -23.22743297578397
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05675227642059326,
                    "num_nodes_avg": 124.8,
                    "path_length_avg": 243.67866416127305,
                    "smoothness_avg": 0.11573828365170394,
                    "success_improvement": 0.0,
                    "time_improvement": 64.57351905289394,
                    "node_improvement": 91.61459383188874,
                    "length_improvement": 18.653048001515497,
                    "smoothness_improvement": 2878.029401274502,
                    "objective_score": 44.954031523149986
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.059490394592285153,
                    "num_nodes_avg": 128.0,
                    "path_length_avg": 126.54369826754073,
                    "smoothness_avg": 0.13398130549228113,
                    "success_improvement": 0.0,
                    "time_improvement": -21.281147092775985,
                    "node_improvement": 83.72536554354735,
                    "length_improvement": 15.955700974074977,
                    "smoothness_improvement": 1604.2323163905585,
                    "objective_score": 11.210238038564983
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m2",
          "algorithm_description": "RAPTOR-Bridge: Rapid Prioritized Two-Tree with Optimistic Reuse \u2014 a cache-aided, heuristic-pruned, bidirectional planner. It grows two sparse trees with a small beam of guided samples (goal/corridor/informed), selects a low-cost line-of-sight ancestor as parent, throttles redundant growth per grid cell by f-cost gates, memoizes edge collisions, and attempts multi-near bridging to the opposite tree. A greedy LOS collapse plus bounded shortcutting finalizes a short, smooth path with minimal postprocessing.",
          "planning_mechanism": "Alternate expanding start/goal trees. For each side, generate a few guided samples; pick a near node from a hash grid, then choose the best LOS parent among local neighbors and a limited set of their ancestors. Prune by heuristic f = g + h and per-cell cost gates; enforce both node and edge collision checks before inserting. After insertion, try bridging to several nearest nodes from the other tree using cached edge checks. On success, merge, greedily collapse with LOS, and perform brief shortcut smoothing.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.children = []\n        self.cost = cost\n        if parent is not None:\n            parent.children.append(self)\nclass Planner:\n    def __init__(self,\n                 max_iter=6500,\n                 step_size=9.0,\n                 collision_step=1.0,\n                 beam_k=3,\n                 goal_bias=0.2,\n                 corridor_bias=0.55,\n                 informed_bias=0.75,\n                 cell_size_factor=1.1,\n                 cell_expand_limit=4,\n                 cell_cost_relax=1.08,\n                 dupe_radius_ratio=0.55,\n                 parent_ring_r=2,\n                 parent_anc_depth=2,\n                 max_nn_rings=3,\n                 connect_k=5,\n                 connect_radius_factor=3.5,\n                 smoothing_attempts=50,\n                 prune_margin=1.02):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.collision_step = collision_step\n        self.beam_k = beam_k\n        self.goal_bias = goal_bias\n        self.corridor_bias = corridor_bias\n        self.informed_bias = informed_bias\n        self.cell_size_factor = cell_size_factor\n        self.cell_expand_limit = max(1, int(cell_expand_limit))\n        self.cell_cost_relax = cell_cost_relax\n        self.dupe_radius_ratio = dupe_radius_ratio\n        self.parent_ring_r = parent_ring_r\n        self.parent_anc_depth = max(0, int(parent_anc_depth))\n        self.max_nn_rings = max_nn_rings\n        self.connect_k = max(1, int(connect_k))\n        self.connect_radius_factor = connect_radius_factor\n        self.smoothing_attempts = smoothing_attempts\n        self.prune_margin = prune_margin\n\n        # runtime\n        self.bounds = None\n        self.dim = 2\n        self.edge_res = 1.0\n        self.cell_size = 1.0\n        self.dupe_radius = 1.0\n        self.edge_cache = None\n        self.cache_bin = 1.0\n        self.inv_cache_bin = 1.0\n\n        self.start = None\n        self.goal = None\n\n    def plan(self, map):\n        self.bounds = map.size\n        self.dim = len(self.bounds)\n        self.start = map.start\n        self.goal = map.goal\n        obstacles = map.obstacles\n        is_3d = (self.dim == 3)\n\n        # discretizations and caches\n        self.edge_res = max(0.6, min(self.collision_step, self.step_size * 0.5))\n        self.cell_size = max(1.0, self.step_size * self.cell_size_factor)\n        self.dupe_radius = max(0.5, self.step_size * self.dupe_radius_ratio)\n        self.cache_bin = max(0.5, 0.5 * self.edge_res)\n        self.inv_cache_bin = 1.0 / self.cache_bin\n        self.edge_cache = {}\n\n        # quick validations\n        if not self._in_bounds(self.start) or not self._in_bounds(self.goal):\n            return PlannerResult(False, [], [], [])\n        if self._is_in_obstacle(self.start, obstacles, is_3d) or self._is_in_obstacle(self.goal, obstacles, is_3d):\n            return PlannerResult(False, [], [], [])\n\n        # trivial straight line\n        if not self._edge_blocked_memo(self.start, self.goal, obstacles, is_3d):\n            n0 = Node(self.start, None, 0.0)\n            n1 = Node(self.goal, n0, self._dist(self.start, self.goal))\n            nodes = [n0, n1]\n            edges = [(n0, n1)]\n            return PlannerResult(True, [self.start, self.goal], nodes, edges)\n\n        # initialize trees and structures\n        start_root = Node(self.start, None, 0.0)\n        goal_root = Node(self.goal, None, 0.0)\n        tree_a = [start_root]\n        tree_b = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        grid_a, grid_b = {}, {}\n        self._grid_add(grid_a, start_root)\n        self._grid_add(grid_b, goal_root)\n\n        expands_a, expands_b = {}, {}\n        best_f_a, best_f_b = {}, {}\n\n        best_path_len = float('inf')\n        d_sg = self._dist(self.start, self.goal)\n        base_corridor_w = max(self.step_size, 0.2 * d_sg)\n\n        for it in range(self.max_iter):\n            active_start = (it % 2 == 0)\n            tree1 = tree_a if active_start else tree_b\n            tree2 = tree_b if active_start else tree_a\n            grid1 = grid_a if active_start else grid_b\n            grid2 = grid_b if active_start else grid_a\n            expands1 = expands_a if active_start else expands_b\n            bestcell1 = best_f_a if active_start else best_f_b\n            other_root = self.goal if active_start else self.start\n\n            best_cand = None  # (parent, new_pos, fscore, hint_other)\n\n            # small beam of candidates\n            for _ in range(self.beam_k):\n                xr = self._guided_sample(best_path_len, d_sg, base_corridor_w, obstacles, is_3d, other_root)\n                near = self._nearest(grid1, tree1, xr)\n                if near is None:\n                    continue\n                new_pos = self._steer(near.position, xr, self.step_size)\n\n                # bounds and node collision (1)\n                if not self._in_bounds(new_pos):\n                    continue\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n\n                # duplicate suppression\n                if self._exists_close(grid1, new_pos, self.dupe_radius):\n                    continue\n\n                # per-cell throttling\n                kc = self._grid_key(new_pos)\n                if expands1.get(kc, 0) >= self.cell_expand_limit:\n                    continue\n\n                # choose parent among nearby nodes and limited ancestors with LOS\n                parent = self._choose_parent_los(grid1, new_pos, near, tree1, obstacles, is_3d)\n                if parent is None:\n                    continue\n\n                # edge collision (2)\n                if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                    continue\n\n                g_new = parent.cost + self._dist(parent.position, new_pos)\n                h_new = self._dist(new_pos, other_root)\n                f_new = g_new + h_new\n\n                # cell f-cost gate\n                prev_best = bestcell1.get(kc, float('inf'))\n                if f_new > prev_best * self.cell_cost_relax:\n                    continue\n\n                # heuristic prune against incumbent best\n                if best_path_len < float('inf') and f_new >= best_path_len * self.prune_margin:\n                    continue\n\n                # bridging hint by proximity to other tree\n                other_near = self._nearest(grid2, tree2, new_pos)\n                bridge_hint = self._dist(new_pos, other_near.position) if other_near is not None else h_new\n                score = f_new + 0.5 * bridge_hint\n\n                if best_cand is None or score < best_cand[2]:\n                    best_cand = (parent, new_pos, score, other_near)\n\n            if best_cand is None:\n                continue\n\n            parent, new_pos, _score, _hint = best_cand\n\n            # Final safety checks before insertion (both)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._edge_blocked_memo(parent.position, new_pos, obstacles, is_3d):\n                continue\n\n            # insert node\n            new_cost = parent.cost + self._dist(parent.position, new_pos)\n            new_node = Node(new_pos, parent, new_cost)\n            tree1.append(new_node)\n            nodes.append(new_node)\n            self._grid_add(grid1, new_node)\n            edges.append((parent, new_node))\n\n            # update per-cell trackers\n            kc = self._grid_key(new_pos)\n            expands1[kc] = expands1.get(kc, 0) + 1\n            cand_f = new_cost + self._dist(new_pos, other_root)\n            prev = bestcell1.get(kc, float('inf'))\n            if cand_f < prev:\n                bestcell1[kc] = cand_f\n\n            # attempt multi-near bridging\n            connected = self._attempt_bridge(new_node, grid2, tree2, obstacles, is_3d)\n            if connected is not None:\n                if active_start:\n                    path = self._merge_paths(new_node, connected)\n                else:\n                    path = self._merge_paths(connected, new_node)\n                best_path_len = self._path_length(path)\n                path = self._greedy_collapse(path, obstacles, is_3d)\n                path = self._shortcut(path, obstacles, is_3d, self.smoothing_attempts)\n                return PlannerResult(True, path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    # RNG\n    def _rand(self):\n        if not hasattr(self, \"_rng\"):\n            self._rng = 2463534242\n        self._rng = (1664525 * self._rng + 1013904223) % (1 << 32)\n        return self._rng / float(1 << 32)\n\n    def _uniform(self, a, b):\n        return a + (b - a) * self._rand()\n\n    # Geometry\n    def _dist(self, a, b):\n        s = 0.0\n        for i in range(self.dim):\n            d = a[i] - b[i]\n            s += d * d\n        return s ** 0.5\n\n    def _clamp(self, p):\n        return tuple(min(max(p[i], 0.0), self.bounds[i]) for i in range(self.dim))\n\n    def _steer(self, a, b, step):\n        d = self._dist(a, b)\n        if d <= step:\n            return self._clamp(b)\n        if d <= 1e-12:\n            return self._clamp(a)\n        r = step / d\n        return self._clamp(tuple(a[i] + (b[i] - a[i]) * r for i in range(self.dim)))\n\n    def _in_bounds(self, p):\n        for i in range(self.dim):\n            if p[i] < 0.0 or p[i] > self.bounds[i]:\n                return False\n        return True\n\n    # Collision\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for o in obstacles:\n                x, y, z, w, h, d = o\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for o in obstacles:\n                x, y, w, h = o\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _edge_blocked(self, a, b, obstacles, is_3d):\n        d = self._dist(a, b)\n        steps = int(d / max(1e-9, self.edge_res))\n        if steps < 1:\n            steps = 1\n        for i in range(steps + 1):\n            t = i / float(steps)\n            p = tuple(a[j] + (b[j] - a[j]) * t for j in range(self.dim))\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return True\n        return False\n\n    def _edge_key_q(self, a, b):\n        qa = tuple(int(a[i] * self.inv_cache_bin) for i in range(self.dim))\n        qb = tuple(int(b[i] * self.inv_cache_bin) for i in range(self.dim))\n        if qa <= qb:\n            return (qa, qb)\n        else:\n            return (qb, qa)\n\n    def _edge_blocked_memo(self, a, b, obstacles, is_3d):\n        key = self._edge_key_q(a, b)\n        st = self.edge_cache.get(key)\n        if st is not None:\n            return st == 1\n        blocked = self._edge_blocked(a, b, obstacles, is_3d)\n        self.edge_cache[key] = 1 if blocked else 2\n        if len(self.edge_cache) > 25000:\n            self.edge_cache.clear()\n        return blocked\n\n    # Grid hashing\n    def _grid_key(self, pos):\n        return tuple(int(pos[i] // self.cell_size) for i in range(self.dim))\n\n    def _grid_add(self, grid, node):\n        k = self._grid_key(node.position)\n        lst = grid.get(k)\n        if lst is None:\n            grid[k] = [node]\n        else:\n            lst.append(node)\n\n    def _ring_collect(self, grid, key, r):\n        out = []\n        if self.dim == 3:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    for dz in range(-r, r + 1):\n                        b = grid.get((key[0] + dx, key[1] + dy, key[2] + dz))\n                        if b:\n                            out.extend(b)\n        else:\n            for dx in range(-r, r + 1):\n                for dy in range(-r, r + 1):\n                    b = grid.get((key[0] + dx, key[1] + dy))\n                    if b:\n                        out.extend(b)\n        return out\n\n    def _nearest(self, grid, tree, pos):\n        key = self._grid_key(pos)\n        best = None\n        bestd = float('inf')\n        for r in range(0, self.max_nn_rings + 1):\n            cand = self._ring_collect(grid, key, r)\n            if cand:\n                for n in cand:\n                    d = self._dist(n.position, pos)\n                    if d < bestd:\n                        bestd = d\n                        best = n\n                if best is not None:\n                    return best\n        # fallback small random subset\n        if tree:\n            trials = min(48, len(tree))\n            for _ in range(trials):\n                idx = int(self._uniform(0, len(tree)))\n                n = tree[idx]\n                d = self._dist(n.position, pos)\n                if d < bestd:\n                    bestd = d\n                    best = n\n        return best\n\n    def _nearby_radius(self, grid, pos, radius, fallback_tree):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.cell_size) + 1\n        cand = self._ring_collect(grid, key, r_cells)\n        if not cand:\n            return list(fallback_tree)\n        out = []\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                out.append(n)\n        if not out:\n            return list(fallback_tree)\n        return out\n\n    def _exists_close(self, grid, pos, radius):\n        key = self._grid_key(pos)\n        r_cells = int(radius / self.cell_size) + 1\n        cand = self._ring_collect(grid, key, r_cells)\n        r2 = radius * radius\n        for n in cand:\n            s = 0.0\n            for i in range(self.dim):\n                d = n.position[i] - pos[i]\n                s += d * d\n            if s <= r2:\n                return True\n        return False\n\n    # Parent selection with limited ancestor LOS\n    def _choose_parent_los(self, grid, new_pos, nearest, tree, obstacles, is_3d):\n        candidates = self._ring_collect(grid, self._grid_key(new_pos), self.parent_ring_r)\n        if not candidates:\n            candidates = [nearest]\n        best_parent = None\n        best_cost = float('inf')\n        for cand in candidates:\n            cur = cand\n            depth = 0\n            while cur is not None and depth <= self.parent_anc_depth:\n                if not self._edge_blocked_memo(cur.position, new_pos, obstacles, is_3d):\n                    c = cur.cost + self._dist(cur.position, new_pos)\n                    if c + 1e-12 < best_cost:\n                        best_cost = c\n                        best_parent = cur\n                cur = cur.parent\n                depth += 1\n        return best_parent\n\n    # Sampling mix\n    def _guided_sample(self, best_len, d_sg, base_width, obstacles, is_3d, other_root):\n        r = self._rand()\n        if best_len < float('inf') and r < self.informed_bias:\n            return self._sample_informed(best_len, obstacles, is_3d)\n        r2 = self._rand()\n        if r2 < self.goal_bias:\n            return other_root\n        elif r2 < self.goal_bias + self.corridor_bias:\n            slack = 0.0 if best_len == float('inf') else max(0.0, best_len - d_sg)\n            width = max(self.step_size, base_width + 0.15 * slack)\n            return self._sample_corridor(width, obstacles, is_3d)\n        else:\n            return self._sample_free(obstacles, is_3d)\n\n    def _sample_free(self, obstacles, is_3d):\n        for _ in range(64):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n        # fallback to center\n        if self.dim == 3:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5, self.bounds[2] * 0.5)\n        else:\n            return (self.bounds[0] * 0.5, self.bounds[1] * 0.5)\n\n    def _sample_corridor(self, width, obstacles, is_3d):\n        t = self._rand()\n        base = tuple(self.start[i] + t * (self.goal[i] - self.start[i]) for i in range(self.dim))\n        tries = 0\n        while tries < 24:\n            if self.dim == 3:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                oz = self._uniform(-width, width)\n                if ox * ox + oy * oy + oz * oz <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy, base[2] + oz))\n                else:\n                    tries += 1\n                    continue\n            else:\n                ox = self._uniform(-width, width)\n                oy = self._uniform(-width, width)\n                if ox * ox + oy * oy <= width * width:\n                    p = self._clamp((base[0] + ox, base[1] + oy))\n                else:\n                    tries += 1\n                    continue\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n            tries += 1\n        return self._sample_free(obstacles, is_3d)\n\n    def _sample_informed(self, best_len, obstacles, is_3d):\n        # rejection in prolate ellipse sum of distances <= best_len\n        for _ in range(40):\n            if self.dim == 3:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]),\n                     self._uniform(0.0, self.bounds[2]))\n            else:\n                p = (self._uniform(0.0, self.bounds[0]),\n                     self._uniform(0.0, self.bounds[1]))\n            if (self._dist(p, self.start) + self._dist(p, self.goal) <= best_len and\n                not self._is_in_obstacle(p, obstacles, is_3d)):\n                return p\n        return self._sample_corridor(max(self.step_size, 0.2 * self._dist(self.start, self.goal)), obstacles, is_3d)\n\n    # Bridge attempts\n    def _attempt_bridge(self, new_node, grid_other, tree_other, obstacles, is_3d):\n        radius = self.connect_radius_factor * self.step_size\n        cand = self._nearby_radius(grid_other, new_node.position, radius, tree_other)\n        if not cand:\n            return None\n        near_sorted = self._k_nearest(cand, new_node.position, self.connect_k)\n        for q in near_sorted:\n            # ensure both checks for edge (node q is existing; only edge check needed to connect)\n            if not self._edge_blocked_memo(new_node.position, q.position, obstacles, is_3d):\n                return q\n        return None\n\n    def _k_nearest(self, nodes, pos, k):\n        if len(nodes) <= k:\n            return list(nodes)\n        best = []\n        bestd = []\n        for n in nodes:\n            d = self._dist(n.position, pos)\n            if len(best) < k:\n                best.append(n)\n                bestd.append(d)\n            else:\n                wi = 0\n                wv = bestd[0]\n                for i in range(1, k):\n                    if bestd[i] > wv:\n                        wi = i\n                        wv = bestd[i]\n                if d < wv:\n                    best[wi] = n\n                    bestd[wi] = d\n        # sort best by distance for deterministic bridging order\n        for i in range(len(best)):\n            for j in range(i + 1, len(best)):\n                if bestd[j] < bestd[i]:\n                    bestd[i], bestd[j] = bestd[j], bestd[i]\n                    best[i], best[j] = best[j], best[i]\n        return best\n\n    # Paths\n    def _path_to_root(self, node):\n        pts = []\n        cur = node\n        while cur is not None:\n            pts.append(cur.position)\n            cur = cur.parent\n        pts.reverse()\n        return pts\n\n    def _merge_paths(self, a_node, b_node):\n        # a_node from start-tree, b_node from goal-tree\n        pa = self._path_to_root(a_node)\n        pb = self._path_to_root(b_node)\n        pb.reverse()\n        return pa + pb\n\n    def _path_length(self, path):\n        if not path or len(path) < 2:\n            return 0.0\n        total = 0.0\n        for i in range(1, len(path)):\n            total += self._dist(path[i - 1], path[i])\n        return total\n\n    def _greedy_collapse(self, path, obstacles, is_3d):\n        if len(path) < 3:\n            return list(path)\n        out = [path[0]]\n        anchor = path[0]\n        i = 1\n        n = len(path)\n        while i < n - 1:\n            nxt = path[i + 1]\n            if self._edge_blocked_memo(anchor, nxt, obstacles, is_3d):\n                out.append(path[i])\n                anchor = path[i]\n            i += 1\n        out.append(path[-1])\n        return out\n\n    def _shortcut(self, path, obstacles, is_3d, attempts):\n        if len(path) < 3:\n            return list(path)\n        pts = list(path)\n        n = len(pts)\n        tries = 0\n        while tries < attempts and n >= 3:\n            i = int(self._uniform(0, n - 2))\n            j = int(self._uniform(i + 1, n - 1))\n            if j <= i + 1:\n                tries += 1\n                continue\n            if not self._edge_blocked_memo(pts[i], pts[j], obstacles, is_3d):\n                pts = pts[:i + 1] + pts[j:]\n                n = len(pts)\n            tries += 1\n        return pts",
          "objective": -10.5237,
          "time_improvement": -16.0,
          "length_improvement": 13.0,
          "smoothness_improvement": 1475.0,
          "node_improvement": 92.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.028984451293945314,
                    "num_nodes_avg": 39.7,
                    "path_length_avg": 163.1846848601364,
                    "smoothness_avg": 0.05021415034728496,
                    "success_improvement": 0.0,
                    "time_improvement": -13.669884066995989,
                    "node_improvement": 90.0025182573659,
                    "length_improvement": 10.555888401352975,
                    "smoothness_improvement": 685.9604947077627,
                    "objective_score": 5.662370294251803
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.10161256790161133,
                    "num_nodes_avg": 90.3,
                    "path_length_avg": 240.75901888181897,
                    "smoothness_avg": 0.09524863704619793,
                    "success_improvement": 0.0,
                    "time_improvement": 36.57037342299927,
                    "node_improvement": 93.93267486393873,
                    "length_improvement": 19.62770963312706,
                    "smoothness_improvement": 2350.8160360189095,
                    "objective_score": 34.50181798687056
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08398923873901368,
                    "num_nodes_avg": 66.9,
                    "path_length_avg": 135.94488647718882,
                    "smoothness_avg": 0.11710168214883317,
                    "success_improvement": 0.0,
                    "time_improvement": -71.22614982684247,
                    "node_improvement": 91.49396058486968,
                    "length_improvement": 9.711879401702502,
                    "smoothness_improvement": 1389.5247533860932,
                    "objective_score": -8.593093540100774
               }
          ],
          "success_rate": 1.0
     }
]